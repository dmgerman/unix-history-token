begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997  * Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Silicon Graphics makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  */
end_comment

begin_comment
comment|/* NOTE: This is an internal header file, included by other STL headers.  *   You should not attempt to use it directly.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<iostream.h>
end_include

begin_expr_stmt
name|__STL_BEGIN_NAMESPACE
if|#
directive|if
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|_MIPS_SIM
operator|!=
name|_MIPS_SIM_ABI32
operator|)
pragma|#
directive|pragma
name|set
name|woff
name|1174
endif|#
directive|endif
comment|// Set buf_start, buf_end, and buf_ptr appropriately, filling tmp_buf
comment|// if necessary.  Assumes path_end[leaf_index] and leaf_pos are correct.
comment|// Results in a valid buf_ptr if the iterator can be legitimately
comment|// dereferenced.
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|void
name|__rope_iterator_base
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|setbuf
argument_list|(
argument|__rope_iterator_base<charT
argument_list|,
argument|Alloc>&x
argument_list|)
block|{
specifier|const
name|RopeBase
operator|*
name|leaf
operator|=
name|x
operator|.
name|path_end
index|[
name|x
operator|.
name|leaf_index
index|]
block|;
name|size_t
name|leaf_pos
operator|=
name|x
operator|.
name|leaf_pos
block|;
name|size_t
name|pos
operator|=
name|x
operator|.
name|current_pos
block|;
switch|switch
condition|(
name|leaf
operator|->
name|tag
condition|)
block|{
case|case
name|RopeBase
operator|::
name|leaf
case|:
name|x
operator|.
name|buf_start
operator|=
operator|(
operator|(
name|__rope_RopeLeaf
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|*
operator|)
name|leaf
operator|)
operator|->
name|data
expr_stmt|;
name|x
operator|.
name|buf_ptr
operator|=
name|x
operator|.
name|buf_start
operator|+
operator|(
name|pos
operator|-
name|leaf_pos
operator|)
expr_stmt|;
name|x
operator|.
name|buf_end
operator|=
name|x
operator|.
name|buf_start
operator|+
name|leaf
operator|->
name|size
expr_stmt|;
break|break;
case|case
name|RopeBase
operator|::
name|function
case|:
case|case
name|RopeBase
operator|::
name|substringfn
case|:
block|{
name|size_t
name|len
init|=
name|iterator_buf_len
decl_stmt|;
name|size_t
name|buf_start_pos
init|=
name|leaf_pos
decl_stmt|;
name|size_t
name|leaf_end
init|=
name|leaf_pos
operator|+
name|leaf
operator|->
name|size
decl_stmt|;
name|char_producer
operator|<
name|charT
operator|>
operator|*
name|fn
operator|=
operator|(
operator|(
name|__rope_RopeFunction
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|*
operator|)
name|leaf
operator|)
operator|->
name|fn
expr_stmt|;
if|if
condition|(
name|buf_start_pos
operator|+
name|len
operator|<=
name|pos
condition|)
block|{
name|buf_start_pos
operator|=
name|pos
operator|-
name|len
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|buf_start_pos
operator|+
name|len
operator|>
name|leaf_end
condition|)
block|{
name|buf_start_pos
operator|=
name|leaf_end
operator|-
name|len
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|} 		if
operator|(
name|buf_start_pos
operator|+
name|len
operator|>
name|leaf_end
operator|)
block|{
name|len
operator|=
name|leaf_end
operator|-
name|buf_start_pos
block|; 		}
call|(
modifier|*
name|fn
call|)
argument_list|(
name|buf_start_pos
operator|-
name|leaf_pos
argument_list|,
name|len
argument_list|,
name|x
operator|.
name|tmp_buf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|x
operator|.
name|buf_ptr
operator|=
name|x
operator|.
name|tmp_buf
operator|+
operator|(
name|pos
operator|-
name|buf_start_pos
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|x
operator|.
name|buf_start
operator|=
name|x
operator|.
name|tmp_buf
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|x
operator|.
name|buf_end
operator|=
name|x
operator|.
name|tmp_buf
operator|+
name|len
expr_stmt|;
end_expr_stmt

begin_empty_stmt
unit|} 	    break
empty_stmt|;
end_empty_stmt

begin_default
default|default:
end_default

begin_expr_stmt
name|__stl_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|} }
comment|// Set path and buffer inside a rope iterator.  We assume that
end_comment

begin_comment
comment|// pos and root are already set.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|void
name|__rope_iterator_base
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|setcache
argument_list|(
argument|__rope_iterator_base<charT
argument_list|,
argument|Alloc>&x
argument_list|)
block|{
specifier|const
name|RopeBase
operator|*
name|path
index|[
name|RopeBase
operator|::
name|max_rope_depth
operator|+
literal|1
index|]
block|;
specifier|const
name|RopeBase
operator|*
name|curr_rope
block|;
name|int
name|curr_depth
operator|=
operator|-
literal|1
block|;
comment|/* index into path    */
name|size_t
name|curr_start_pos
operator|=
literal|0
block|;
name|size_t
name|pos
operator|=
name|x
operator|.
name|current_pos
block|;
name|unsigned
name|char
name|dirns
operator|=
literal|0
block|;
comment|// Bit vector indicating right turns in the path
name|__stl_assert
argument_list|(
name|pos
operator|<=
name|x
operator|.
name|root
operator|->
name|size
argument_list|)
block|;
if|if
condition|(
name|pos
operator|>=
name|x
operator|.
name|root
operator|->
name|size
condition|)
block|{
name|x
operator|.
name|buf_ptr
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|curr_rope
operator|=
name|x
operator|.
name|root
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
literal|0
operator|!=
name|curr_rope
operator|->
name|c_string
condition|)
block|{
comment|/* Treat the root as a leaf. */
name|x
operator|.
name|buf_start
operator|=
name|curr_rope
operator|->
name|c_string
expr_stmt|;
name|x
operator|.
name|buf_end
operator|=
name|curr_rope
operator|->
name|c_string
operator|+
name|curr_rope
operator|->
name|size
expr_stmt|;
name|x
operator|.
name|buf_ptr
operator|=
name|curr_rope
operator|->
name|c_string
operator|+
name|pos
expr_stmt|;
name|x
operator|.
name|path_end
index|[
literal|0
index|]
operator|=
name|curr_rope
expr_stmt|;
name|x
operator|.
name|leaf_index
operator|=
literal|0
expr_stmt|;
name|x
operator|.
name|leaf_pos
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_if

begin_for
for|for
control|(
init|;
condition|;
control|)
block|{
operator|++
name|curr_depth
expr_stmt|;
name|__stl_assert
argument_list|(
name|curr_depth
operator|<=
name|RopeBase
operator|::
name|max_rope_depth
argument_list|)
expr_stmt|;
name|path
index|[
name|curr_depth
index|]
operator|=
name|curr_rope
expr_stmt|;
switch|switch
condition|(
name|curr_rope
operator|->
name|tag
condition|)
block|{
case|case
name|RopeBase
operator|::
name|leaf
case|:
case|case
name|RopeBase
operator|::
name|function
case|:
case|case
name|RopeBase
operator|::
name|substringfn
case|:
name|x
operator|.
name|leaf_pos
operator|=
name|curr_start_pos
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|RopeBase
operator|::
name|concat
case|:
block|{
name|__rope_RopeConcatenation
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|*
name|c
operator|=
operator|(
name|__rope_RopeConcatenation
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|*
operator|)
name|curr_rope
expr_stmt|;
name|RopeBase
modifier|*
name|left
init|=
name|c
operator|->
name|left
decl_stmt|;
name|size_t
name|left_len
init|=
name|left
operator|->
name|size
decl_stmt|;
name|dirns
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|curr_start_pos
operator|+
name|left_len
condition|)
block|{
name|dirns
operator||=
literal|1
expr_stmt|;
name|curr_rope
operator|=
name|c
operator|->
name|right
expr_stmt|;
name|curr_start_pos
operator|+=
name|left_len
expr_stmt|;
block|}
else|else
block|{
name|curr_rope
operator|=
name|left
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
end_for

begin_label
name|done
label|:
end_label

begin_comment
comment|// Copy last section of path into path_end.
end_comment

begin_block
block|{
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|j
init|=
name|curr_depth
operator|+
literal|1
operator|-
name|path_cache_len
decl_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|j
operator|<=
name|curr_depth
condition|)
block|{
name|x
operator|.
name|path_end
index|[
operator|++
name|i
index|]
operator|=
name|path
index|[
name|j
operator|++
index|]
expr_stmt|;
block|}
name|x
operator|.
name|leaf_index
operator|=
name|i
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|x
operator|.
name|path_directions
operator|=
name|dirns
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setbuf
argument_list|(
name|x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|// Specialized version of the above.  Assumes that
end_comment

begin_comment
comment|// the path cache is valid for the previous position.
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|void
name|__rope_iterator_base
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|setcache_for_incr
argument_list|(
argument|__rope_iterator_base<charT
argument_list|,
argument|Alloc>&x
argument_list|)
block|{
name|int
name|current_index
operator|=
name|x
operator|.
name|leaf_index
block|;
specifier|const
name|RopeBase
operator|*
name|current_node
operator|=
name|x
operator|.
name|path_end
index|[
name|current_index
index|]
block|;
name|size_t
name|len
operator|=
name|current_node
operator|->
name|size
block|;
name|size_t
name|node_start_pos
operator|=
name|x
operator|.
name|leaf_pos
block|;
name|unsigned
name|char
name|dirns
operator|=
name|x
operator|.
name|path_directions
block|;
name|__rope_RopeConcatenation
operator|<
name|charT
block|,
name|Alloc
operator|>
operator|*
name|c
block|;
name|__stl_assert
argument_list|(
name|x
operator|.
name|current_pos
operator|<=
name|x
operator|.
name|root
operator|->
name|size
argument_list|)
block|;
if|if
condition|(
name|x
operator|.
name|current_pos
operator|-
name|node_start_pos
operator|<
name|len
condition|)
block|{
comment|/* More stuff in this leaf, we just didn't cache it. */
name|setbuf
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return;
block|}
name|__stl_assert
argument_list|(
name|node_start_pos
operator|+
name|len
operator|==
name|x
operator|.
name|current_pos
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|//  node_start_pos is starting position of last_node.
end_comment

begin_while
while|while
condition|(
operator|--
name|current_index
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|dirns
operator|&
literal|1
operator|)
comment|/* Path turned left */
condition|)
break|break;
name|current_node
operator|=
name|x
operator|.
name|path_end
index|[
name|current_index
index|]
expr_stmt|;
name|c
operator|=
operator|(
name|__rope_RopeConcatenation
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|*
operator|)
name|current_node
expr_stmt|;
comment|// Otherwise we were in the right child.  Thus we should pop
comment|// the concatenation node.
name|node_start_pos
operator|-=
name|c
operator|->
name|left
operator|->
name|size
expr_stmt|;
name|dirns
operator|>>=
literal|1
expr_stmt|;
block|}
end_while

begin_if
if|if
condition|(
name|current_index
operator|<
literal|0
condition|)
block|{
comment|// We underflowed the cache. Punt.
name|setcache
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return;
block|}
end_if

begin_expr_stmt
name|current_node
operator|=
name|x
operator|.
name|path_end
index|[
name|current_index
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|c
operator|=
operator|(
name|__rope_RopeConcatenation
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|*
operator|)
name|current_node
expr_stmt|;
end_expr_stmt

begin_comment
comment|// current_node is a concatenation node.  We are positioned on the first
end_comment

begin_comment
comment|// character in its right child.
end_comment

begin_comment
comment|// node_start_pos is starting position of current_node.
end_comment

begin_expr_stmt
name|node_start_pos
operator|+=
name|c
operator|->
name|left
operator|->
name|size
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|current_node
operator|=
name|c
operator|->
name|right
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|x
operator|.
name|path_end
index|[
operator|++
name|current_index
index|]
operator|=
name|current_node
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dirns
operator||=
literal|1
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|RopeBase
operator|::
name|concat
operator|==
name|current_node
operator|->
name|tag
condition|)
block|{
operator|++
name|current_index
expr_stmt|;
if|if
condition|(
name|path_cache_len
operator|==
name|current_index
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|path_cache_len
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|.
name|path_end
index|[
name|i
index|]
operator|=
name|x
operator|.
name|path_end
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
operator|--
name|current_index
expr_stmt|;
block|}
name|current_node
operator|=
operator|(
operator|(
name|__rope_RopeConcatenation
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|*
operator|)
name|current_node
operator|)
operator|->
name|left
expr_stmt|;
name|x
operator|.
name|path_end
index|[
name|current_index
index|]
operator|=
name|current_node
expr_stmt|;
name|dirns
operator|<<=
literal|1
expr_stmt|;
comment|// node_start_pos is unchanged.
block|}
end_while

begin_expr_stmt
name|x
operator|.
name|leaf_index
operator|=
name|current_index
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|x
operator|.
name|leaf_pos
operator|=
name|node_start_pos
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|x
operator|.
name|path_directions
operator|=
name|dirns
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setbuf
argument_list|(
name|x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|void
name|__rope_iterator_base
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|incr
argument_list|(
argument|size_t n
argument_list|)
block|{
name|current_pos
operator|+=
name|n
block|;
if|if
condition|(
literal|0
operator|!=
name|buf_ptr
condition|)
block|{
name|size_t
name|chars_left
init|=
name|buf_end
operator|-
name|buf_ptr
decl_stmt|;
if|if
condition|(
name|chars_left
operator|>
name|n
condition|)
block|{
name|buf_ptr
operator|+=
name|n
expr_stmt|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
name|chars_left
operator|==
name|n
condition|)
block|{
name|buf_ptr
operator|+=
name|n
expr_stmt|;
name|setcache_for_incr
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
block|}
end_elseif

begin_else
else|else
block|{
name|buf_ptr
operator|=
literal|0
expr_stmt|;
block|}
end_else

begin_expr_stmt
unit|} }
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|void
name|__rope_iterator_base
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|decr
argument_list|(
argument|size_t n
argument_list|)
block|{
if|if
condition|(
literal|0
operator|!=
name|buf_ptr
condition|)
block|{
name|size_t
name|chars_left
init|=
name|buf_ptr
operator|-
name|buf_start
decl_stmt|;
if|if
condition|(
name|chars_left
operator|>=
name|n
condition|)
block|{
name|buf_ptr
operator|-=
name|n
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|buf_ptr
operator|=
literal|0
expr_stmt|;
block|}
end_else

begin_expr_stmt
unit|}     current_pos
operator|-=
name|n
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|void
name|__rope_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|check
argument_list|()
block|{
if|if
condition|(
name|root_rope
operator|->
name|tree_ptr
operator|!=
name|root
condition|)
block|{
comment|// Rope was modified.  Get things fixed up.
name|RopeBase
operator|::
name|unref
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|root
operator|=
name|root_rope
operator|->
name|tree_ptr
expr_stmt|;
name|RopeBase
operator|::
name|ref
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|buf_ptr
operator|=
literal|0
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|__rope_const_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|__rope_const_iterator
argument_list|(
specifier|const
name|__rope_iterator
operator|<
name|charT
argument_list|,
name|Alloc
operator|>
operator|&
name|x
argument_list|)
operator|:
name|__rope_iterator_base
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|x
operator|)
block|{ }
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|__rope_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|__rope_iterator
argument_list|(
argument|rope<charT
argument_list|,
argument|Alloc>& r
argument_list|,
argument|size_t pos
argument_list|)
operator|:
name|__rope_iterator_base
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|r
operator|.
name|tree_ptr
operator|,
name|pos
operator|)
operator|,
name|root_rope
argument_list|(
argument|&r
argument_list|)
block|{
name|RopeBase
operator|::
name|ref
argument_list|(
name|root
argument_list|)
block|; }
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|size_t
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|char_ptr_len
argument_list|(
argument|const charT *s
argument_list|)
block|{
specifier|const
name|charT
operator|*
name|p
operator|=
name|s
block|;
while|while
condition|(
operator|!
name|is0
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
operator|++
name|p
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
operator|(
name|p
operator|-
name|s
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|RopeLeaf
operator|*
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|RopeLeaf_from_char_ptr
argument_list|(
argument|__GC_CONST charT *s
argument_list|,
argument|size_t size
argument_list|)
block|{
name|RopeLeaf
operator|*
name|t
operator|=
name|LAlloc
operator|::
name|allocate
argument_list|()
block|;
name|t
operator|->
name|tag
operator|=
name|RopeBase
operator|::
name|leaf
block|;
if|if
condition|(
name|__is_basic_char_type
argument_list|(
operator|(
name|charT
operator|*
operator|)
literal|0
argument_list|)
condition|)
block|{
comment|// already eos terminated.
name|t
operator|->
name|c_string
operator|=
name|s
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|t
operator|->
name|c_string
operator|=
literal|0
expr_stmt|;
block|}
end_else

begin_expr_stmt
name|t
operator|->
name|is_balanced
operator|=
name|true
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|t
operator|->
name|depth
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|t
operator|->
name|size
operator|=
name|size
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|t
operator|->
name|data
operator|=
name|s
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_expr_stmt
name|t
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|t
operator|->
name|init_refcount_lock
argument_list|()
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_return
return|return
operator|(
name|t
operator|)
return|;
end_return

begin_ifdef
unit|}
ifdef|#
directive|ifdef
name|__GC
end_ifdef

begin_expr_stmt
unit|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|void
name|__rope_RopeBase
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|fn_finalization_proc
argument_list|(
argument|void * tree
argument_list|,
argument|void *
argument_list|)
block|{
name|delete
argument_list|(
operator|(
name|__rope_RopeFunction
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|*
operator|)
name|tree
argument_list|)
operator|->
name|fn
block|; }
endif|#
directive|endif
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|RopeFunction
operator|*
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|RopeFunction_from_fn
argument_list|(
argument|char_producer<charT> *fn
argument_list|,
argument|size_t size
argument_list|,
argument|bool delete_fn
argument_list|)
block|{
if|if
condition|(
literal|0
operator|==
name|size
condition|)
return|return
literal|0
return|;
name|RopeFunction
operator|*
name|t
operator|=
name|FAlloc
operator|::
name|allocate
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|t
operator|->
name|tag
operator|=
name|RopeBase
operator|::
name|function
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|t
operator|->
name|c_string
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|t
operator|->
name|is_balanced
operator|=
name|true
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|t
operator|->
name|depth
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|t
operator|->
name|size
operator|=
name|size
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|t
operator|->
name|fn
operator|=
name|fn
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__GC
end_ifdef

begin_if
if|if
condition|(
name|delete_fn
condition|)
block|{
name|GC_REGISTER_FINALIZER
argument_list|(
name|t
argument_list|,
name|RopeBase
operator|::
name|fn_finalization_proc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_if

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|t
operator|->
name|delete_when_done
operator|=
name|delete_fn
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|t
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|t
operator|->
name|init_refcount_lock
argument_list|()
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_return
return|return
operator|(
name|t
operator|)
return|;
end_return

begin_ifndef
unit|}
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_expr_stmt
unit|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|void
name|__rope_RopeBase
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|free_c_string
argument_list|()
block|{
name|charT
operator|*
name|cstr
operator|=
name|c_string
block|;
if|if
condition|(
literal|0
operator|!=
name|cstr
condition|)
block|{
name|size_t
name|sz
init|=
name|size
operator|+
literal|1
decl_stmt|;
name|destroy
argument_list|(
name|cstr
argument_list|,
name|cstr
operator|+
name|sz
argument_list|)
expr_stmt|;
name|DataAlloc
operator|::
name|deallocate
argument_list|(
name|cstr
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|void
name|__rope_RopeBase
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|free_string
argument_list|(
argument|charT* s
argument_list|,
argument|size_t n
argument_list|)
block|{
if|if
condition|(
operator|!
name|__is_basic_char_type
argument_list|(
operator|(
name|charT
operator|*
operator|)
literal|0
argument_list|)
condition|)
block|{
name|destroy
argument_list|(
name|s
argument_list|,
name|s
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
name|DataAlloc
operator|::
name|deallocate
argument_list|(
name|s
argument_list|,
name|rounded_up_size
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|void
name|__rope_RopeBase
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|free_tree
argument_list|()
block|{
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|leaf
case|:
block|{
name|__rope_RopeLeaf
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|*
name|l
operator|=
operator|(
name|__rope_RopeLeaf
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|*
operator|)
name|this
expr_stmt|;
name|charT
modifier|*
name|d
init|=
name|l
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|d
operator|!=
name|c_string
condition|)
block|{
name|free_c_string
argument_list|()
expr_stmt|;
block|}
name|free_string
argument_list|(
name|d
argument_list|,
name|size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LAlloc
operator|::
name|deallocate
argument_list|(
name|l
argument_list|)
expr_stmt|;
end_expr_stmt

begin_empty_stmt
unit|} 	    break
empty_stmt|;
end_empty_stmt

begin_case
case|case
name|concat
case|:
end_case

begin_block
block|{
name|__rope_RopeConcatenation
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|*
name|c
operator|=
operator|(
name|__rope_RopeConcatenation
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|*
operator|)
name|this
expr_stmt|;
name|__rope_RopeBase
modifier|*
name|left
init|=
name|c
operator|->
name|left
decl_stmt|;
name|__rope_RopeBase
modifier|*
name|right
init|=
name|c
operator|->
name|right
decl_stmt|;
name|free_c_string
argument_list|()
expr_stmt|;
name|left
operator|->
name|unref_nonnil
argument_list|()
expr_stmt|;
name|right
operator|->
name|unref_nonnil
argument_list|()
expr_stmt|;
name|CAlloc
operator|::
name|deallocate
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_break
break|break;
end_break

begin_case
case|case
name|function
case|:
end_case

begin_block
block|{
name|__rope_RopeFunction
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|*
name|fn
operator|=
operator|(
name|__rope_RopeFunction
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|*
operator|)
name|this
expr_stmt|;
name|free_c_string
argument_list|()
expr_stmt|;
if|if
condition|(
name|fn
operator|->
name|delete_when_done
condition|)
block|{
name|delete
name|fn
operator|->
name|fn
decl_stmt|;
block|}
name|FAlloc
operator|::
name|deallocate
argument_list|(
name|fn
argument_list|)
expr_stmt|;
break|break;
block|}
end_block

begin_case
case|case
name|substringfn
case|:
end_case

begin_block
block|{
name|__rope_RopeSubstring
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|*
name|ss
operator|=
operator|(
name|__rope_RopeSubstring
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|*
operator|)
name|this
expr_stmt|;
name|__rope_RopeBase
modifier|*
name|base
init|=
name|ss
operator|->
name|base
decl_stmt|;
name|free_c_string
argument_list|()
expr_stmt|;
name|base
operator|->
name|unref_nonnil
argument_list|()
expr_stmt|;
name|SAlloc
operator|::
name|deallocate
argument_list|(
name|ss
argument_list|)
expr_stmt|;
break|break;
block|}
end_block

begin_else
unit|} }
else|#
directive|else
end_else

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|void
name|__rope_RopeBase
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|free_string
argument_list|(
argument|charT* s
argument_list|,
argument|size_t n
argument_list|)
block|{}
endif|#
directive|endif
comment|// Concatenate a C string onto a leaf rope by copying the rope data.
comment|// Used for short ropes.
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|RopeLeaf
operator|*
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|leaf_concat_char_iter
argument_list|(
argument|RopeLeaf * r
argument_list|,
argument|const charT * iter
argument_list|,
argument|size_t len
argument_list|)
block|{
name|size_t
name|old_len
operator|=
name|r
operator|->
name|size
block|;
name|charT
operator|*
name|new_data
operator|=
operator|(
name|charT
operator|*
operator|)
name|DataAlloc
operator|::
name|allocate
argument_list|(
name|rounded_up_size
argument_list|(
name|old_len
operator|+
name|len
argument_list|)
argument_list|)
block|;
name|RopeLeaf
operator|*
name|result
block|;
name|uninitialized_copy_n
argument_list|(
name|r
operator|->
name|data
argument_list|,
name|old_len
argument_list|,
name|new_data
argument_list|)
block|;
name|uninitialized_copy_n
argument_list|(
name|iter
argument_list|,
name|len
argument_list|,
name|new_data
operator|+
name|old_len
argument_list|)
block|;
name|__cond_store_eos
argument_list|(
name|new_data
index|[
name|old_len
operator|+
name|len
index|]
argument_list|)
block|;
name|__STL_TRY
block|{
name|result
operator|=
name|RopeLeaf_from_char_ptr
argument_list|(
name|new_data
argument_list|,
name|old_len
operator|+
name|len
argument_list|)
block|;     }
name|__STL_UNWIND
argument_list|(
name|RopeBase
operator|::
name|free_string
argument_list|(
name|new_data
argument_list|,
name|old_len
operator|+
name|len
argument_list|)
argument_list|)
block|;
return|return
name|result
return|;
block|}
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_comment
comment|// As above, but it's OK to clobber original if refcount is 1
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|RopeLeaf
operator|*
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|destr_leaf_concat_char_iter
argument_list|(
argument|RopeLeaf * r
argument_list|,
argument|const charT * iter
argument_list|,
argument|size_t len
argument_list|)
block|{
name|__stl_assert
argument_list|(
name|r
operator|->
name|refcount
operator|>=
literal|1
argument_list|)
block|;
if|if
condition|(
name|r
operator|->
name|refcount
operator|>
literal|1
condition|)
return|return
name|leaf_concat_char_iter
argument_list|(
name|r
argument_list|,
name|iter
argument_list|,
name|len
argument_list|)
return|;
name|size_t
name|old_len
operator|=
name|r
operator|->
name|size
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|allocated_capacity
argument_list|(
name|old_len
argument_list|)
operator|>=
name|old_len
operator|+
name|len
condition|)
block|{
comment|// The space has been partially initialized for the standard
comment|// character types.  But that doesn't matter for those types.
name|uninitialized_copy_n
argument_list|(
name|iter
argument_list|,
name|len
argument_list|,
name|r
operator|->
name|data
operator|+
name|old_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|__is_basic_char_type
argument_list|(
operator|(
name|charT
operator|*
operator|)
literal|0
argument_list|)
condition|)
block|{
name|__cond_store_eos
argument_list|(
name|r
operator|->
name|data
index|[
name|old_len
operator|+
name|len
index|]
argument_list|)
expr_stmt|;
name|__stl_assert
argument_list|(
name|r
operator|->
name|c_string
operator|==
name|r
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|c_string
operator|!=
name|r
operator|->
name|data
operator|&&
literal|0
operator|!=
name|r
operator|->
name|c_string
condition|)
block|{
name|r
operator|->
name|free_c_string
argument_list|()
expr_stmt|;
name|r
operator|->
name|c_string
operator|=
literal|0
expr_stmt|;
block|}
name|r
operator|->
name|size
operator|=
name|old_len
operator|+
name|len
expr_stmt|;
name|__stl_assert
argument_list|(
name|r
operator|->
name|refcount
operator|==
literal|1
argument_list|)
expr_stmt|;
name|r
operator|->
name|refcount
operator|=
literal|2
expr_stmt|;
return|return
name|r
return|;
block|}
else|else
block|{
name|RopeLeaf
modifier|*
name|result
init|=
name|leaf_concat_char_iter
argument_list|(
name|r
argument_list|,
name|iter
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|__stl_assert
argument_list|(
name|result
operator|->
name|refcount
operator|==
literal|1
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_if

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|// Assumes left and right are not 0.
end_comment

begin_comment
comment|// Does not increment (nor decrement on exception) child reference counts.
end_comment

begin_comment
comment|// Result has ref count 1.
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|RopeBase
operator|*
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|tree_concat
argument_list|(
argument|RopeBase * left
argument_list|,
argument|RopeBase * right
argument_list|)
block|{
name|RopeConcatenation
operator|*
name|result
operator|=
name|CAlloc
operator|::
name|allocate
argument_list|()
block|;
name|unsigned
name|char
name|child_depth
operator|=
name|left
operator|->
name|depth
block|;
name|size_t
name|rsize
block|;
name|result
operator|->
name|tag
operator|=
name|RopeBase
operator|::
name|concat
block|;
name|result
operator|->
name|c_string
operator|=
literal|0
block|;
name|result
operator|->
name|is_balanced
operator|=
name|false
block|;
name|result
operator|->
name|size
operator|=
name|rsize
operator|=
name|left
operator|->
name|size
operator|+
name|right
operator|->
name|size
block|;
if|if
condition|(
name|right
operator|->
name|depth
operator|>
name|child_depth
condition|)
name|child_depth
operator|=
name|right
operator|->
name|depth
expr_stmt|;
name|unsigned
name|char
name|depth
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|child_depth
operator|+
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|result
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|result
operator|->
name|left
operator|=
name|left
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|result
operator|->
name|right
operator|=
name|right
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_expr_stmt
name|result
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|result
operator|->
name|init_refcount_lock
argument_list|()
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|depth
operator|>
literal|20
operator|&&
operator|(
name|rsize
operator|<
literal|1000
operator|||
name|depth
operator|>
name|RopeBase
operator|::
name|max_rope_depth
operator|)
condition|)
block|{
name|RopeBase
modifier|*
name|balanced
decl_stmt|;
name|__STL_TRY
block|{
name|balanced
operator|=
name|balance
argument_list|(
name|result
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__GC
if|if
condition|(
name|result
operator|!=
name|balanced
condition|)
block|{
name|__stl_assert
argument_list|(
literal|1
operator|==
name|result
operator|->
name|refcount
operator|&&
literal|1
operator|==
name|balanced
operator|->
name|refcount
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|result
operator|->
name|unref_nonnil
argument_list|()
expr_stmt|;
block|}
name|__STL_UNWIND
argument_list|(
name|CAlloc
operator|::
name|deallocate
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|// In case of exception, we need to deallocate
comment|// otherwise dangling result node.  But caller
comment|// still owns its children.  Thus unref is
comment|// inappropriate.
return|return
name|balanced
return|;
block|}
else|else
block|{
return|return
name|result
return|;
block|}
end_if

begin_expr_stmt
unit|}  template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|RopeBase
operator|*
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|concat_char_iter
argument_list|(
argument|RopeBase * r
argument_list|,
argument|const charT *s
argument_list|,
argument|size_t slen
argument_list|)
block|{
name|RopeBase
operator|*
name|result
block|;
if|if
condition|(
literal|0
operator|==
name|slen
condition|)
block|{
name|ref
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
literal|0
operator|==
name|r
condition|)
return|return
name|RopeLeaf_from_unowned_char_ptr
argument_list|(
name|s
argument_list|,
name|slen
argument_list|)
return|;
end_if

begin_if
if|if
condition|(
name|RopeBase
operator|::
name|leaf
operator|==
name|r
operator|->
name|tag
operator|&&
name|r
operator|->
name|size
operator|+
name|slen
operator|<=
name|copy_max
condition|)
block|{
name|result
operator|=
name|leaf_concat_char_iter
argument_list|(
operator|(
name|RopeLeaf
operator|*
operator|)
name|r
argument_list|,
name|s
argument_list|,
name|slen
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__GC
name|__stl_assert
argument_list|(
literal|1
operator|==
name|result
operator|->
name|refcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_if

begin_if
if|if
condition|(
name|RopeBase
operator|::
name|concat
operator|==
name|r
operator|->
name|tag
operator|&&
name|RopeBase
operator|::
name|leaf
operator|==
operator|(
operator|(
name|RopeConcatenation
operator|*
operator|)
name|r
operator|)
operator|->
name|right
operator|->
name|tag
condition|)
block|{
name|RopeLeaf
modifier|*
name|right
init|=
operator|(
name|RopeLeaf
operator|*
operator|)
operator|(
operator|(
operator|(
name|RopeConcatenation
operator|*
operator|)
name|r
operator|)
operator|->
name|right
operator|)
decl_stmt|;
if|if
condition|(
name|right
operator|->
name|size
operator|+
name|slen
operator|<=
name|copy_max
condition|)
block|{
name|RopeBase
modifier|*
name|left
init|=
operator|(
operator|(
name|RopeConcatenation
operator|*
operator|)
name|r
operator|)
operator|->
name|left
decl_stmt|;
name|RopeBase
modifier|*
name|nright
init|=
name|leaf_concat_char_iter
argument_list|(
operator|(
name|RopeLeaf
operator|*
operator|)
name|right
argument_list|,
name|s
argument_list|,
name|slen
argument_list|)
decl_stmt|;
name|left
operator|->
name|ref_nonnil
argument_list|()
expr_stmt|;
name|__STL_TRY
block|{
name|result
operator|=
name|tree_concat
argument_list|(
name|left
argument_list|,
name|nright
argument_list|)
expr_stmt|;
block|}
name|__STL_UNWIND
argument_list|(
argument|unref(left); unref(nright)
argument_list|)
empty_stmt|;
ifndef|#
directive|ifndef
name|__GC
name|__stl_assert
argument_list|(
literal|1
operator|==
name|result
operator|->
name|refcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
block|}
block|}
end_if

begin_decl_stmt
name|RopeBase
modifier|*
name|nright
init|=
name|RopeLeaf_from_unowned_char_ptr
argument_list|(
name|s
argument_list|,
name|slen
argument_list|)
decl_stmt|;
end_decl_stmt

begin_macro
name|__STL_TRY
end_macro

begin_block
block|{
name|r
operator|->
name|ref_nonnil
argument_list|()
expr_stmt|;
name|result
operator|=
name|tree_concat
argument_list|(
name|r
argument_list|,
name|nright
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|__STL_UNWIND
argument_list|(
argument|unref(r); unref(nright)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_expr_stmt
name|__stl_assert
argument_list|(
literal|1
operator|==
name|result
operator|->
name|refcount
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_return
return|return
name|result
return|;
end_return

begin_ifndef
unit|}
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_expr_stmt
unit|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|RopeBase
operator|*
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|destr_concat_char_iter
argument_list|(
argument|RopeBase * r
argument_list|,
argument|const charT *s
argument_list|,
argument|size_t slen
argument_list|)
block|{
name|RopeBase
operator|*
name|result
block|;
if|if
condition|(
literal|0
operator|==
name|r
condition|)
return|return
name|RopeLeaf_from_unowned_char_ptr
argument_list|(
name|s
argument_list|,
name|slen
argument_list|)
return|;
name|size_t
name|count
operator|=
name|r
operator|->
name|refcount
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|size_t
name|orig_size
init|=
name|r
operator|->
name|size
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|__stl_assert
argument_list|(
name|count
operator|>=
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|count
operator|>
literal|1
condition|)
return|return
name|concat_char_iter
argument_list|(
name|r
argument_list|,
name|s
argument_list|,
name|slen
argument_list|)
return|;
end_if

begin_if
if|if
condition|(
literal|0
operator|==
name|slen
condition|)
block|{
name|r
operator|->
name|refcount
operator|=
literal|2
expr_stmt|;
comment|// One more than before
return|return
name|r
return|;
block|}
end_if

begin_if
if|if
condition|(
name|orig_size
operator|+
name|slen
operator|<=
name|copy_max
operator|&&
name|RopeBase
operator|::
name|leaf
operator|==
name|r
operator|->
name|tag
condition|)
block|{
name|result
operator|=
name|destr_leaf_concat_char_iter
argument_list|(
operator|(
name|RopeLeaf
operator|*
operator|)
name|r
argument_list|,
name|s
argument_list|,
name|slen
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_if

begin_if
if|if
condition|(
name|RopeBase
operator|::
name|concat
operator|==
name|r
operator|->
name|tag
condition|)
block|{
name|RopeLeaf
modifier|*
name|right
init|=
operator|(
name|RopeLeaf
operator|*
operator|)
operator|(
operator|(
operator|(
name|RopeConcatenation
operator|*
operator|)
name|r
operator|)
operator|->
name|right
operator|)
decl_stmt|;
if|if
condition|(
name|RopeBase
operator|::
name|leaf
operator|==
name|right
operator|->
name|tag
operator|&&
name|right
operator|->
name|size
operator|+
name|slen
operator|<=
name|copy_max
condition|)
block|{
name|RopeBase
modifier|*
name|new_right
init|=
name|destr_leaf_concat_char_iter
argument_list|(
name|right
argument_list|,
name|s
argument_list|,
name|slen
argument_list|)
decl_stmt|;
if|if
condition|(
name|right
operator|==
name|new_right
condition|)
block|{
name|__stl_assert
argument_list|(
name|new_right
operator|->
name|refcount
operator|==
literal|2
argument_list|)
expr_stmt|;
name|new_right
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|__stl_assert
argument_list|(
name|new_right
operator|->
name|refcount
operator|>=
literal|1
argument_list|)
expr_stmt|;
name|right
operator|->
name|unref_nonnil
argument_list|()
expr_stmt|;
block|}
name|__stl_assert
argument_list|(
name|r
operator|->
name|refcount
operator|==
literal|1
argument_list|)
expr_stmt|;
name|r
operator|->
name|refcount
operator|=
literal|2
expr_stmt|;
comment|// One more than before.
operator|(
operator|(
name|RopeConcatenation
operator|*
operator|)
name|r
operator|)
operator|->
name|right
operator|=
name|new_right
expr_stmt|;
name|r
operator|->
name|size
operator|=
name|orig_size
operator|+
name|slen
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|r
operator|->
name|c_string
condition|)
block|{
name|r
operator|->
name|free_c_string
argument_list|()
expr_stmt|;
name|r
operator|->
name|c_string
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
block|}
end_if

begin_decl_stmt
name|RopeBase
modifier|*
name|right
init|=
name|RopeLeaf_from_unowned_char_ptr
argument_list|(
name|s
argument_list|,
name|slen
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|r
operator|->
name|ref_nonnil
argument_list|()
expr_stmt|;
end_expr_stmt

begin_macro
name|__STL_TRY
end_macro

begin_block
block|{
name|result
operator|=
name|tree_concat
argument_list|(
name|r
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|__STL_UNWIND
argument_list|(
argument|unref(r); unref(right)
argument_list|)
end_macro

begin_expr_stmt
name|__stl_assert
argument_list|(
literal|1
operator|==
name|result
operator|->
name|refcount
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|result
return|;
end_return

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__GC */
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|RopeBase
operator|*
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|concat
argument_list|(
argument|RopeBase * left
argument_list|,
argument|RopeBase * right
argument_list|)
block|{
if|if
condition|(
literal|0
operator|==
name|left
condition|)
block|{
name|ref
argument_list|(
name|right
argument_list|)
expr_stmt|;
return|return
name|right
return|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
literal|0
operator|==
name|right
condition|)
block|{
name|left
operator|->
name|ref_nonnil
argument_list|()
expr_stmt|;
return|return
name|left
return|;
block|}
end_if

begin_if
if|if
condition|(
name|RopeBase
operator|::
name|leaf
operator|==
name|right
operator|->
name|tag
condition|)
block|{
if|if
condition|(
name|RopeBase
operator|::
name|leaf
operator|==
name|left
operator|->
name|tag
condition|)
block|{
if|if
condition|(
name|right
operator|->
name|size
operator|+
name|left
operator|->
name|size
operator|<=
name|copy_max
condition|)
block|{
return|return
name|leaf_concat_char_iter
argument_list|(
operator|(
name|RopeLeaf
operator|*
operator|)
name|left
argument_list|,
operator|(
operator|(
name|RopeLeaf
operator|*
operator|)
name|right
operator|)
operator|->
name|data
argument_list|,
name|right
operator|->
name|size
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|RopeBase
operator|::
name|concat
operator|==
name|left
operator|->
name|tag
operator|&&
name|RopeBase
operator|::
name|leaf
operator|==
operator|(
operator|(
name|RopeConcatenation
operator|*
operator|)
name|left
operator|)
operator|->
name|right
operator|->
name|tag
condition|)
block|{
name|RopeLeaf
modifier|*
name|leftright
init|=
operator|(
name|RopeLeaf
operator|*
operator|)
operator|(
operator|(
operator|(
name|RopeConcatenation
operator|*
operator|)
name|left
operator|)
operator|->
name|right
operator|)
decl_stmt|;
if|if
condition|(
name|leftright
operator|->
name|size
operator|+
name|right
operator|->
name|size
operator|<=
name|copy_max
condition|)
block|{
name|RopeBase
modifier|*
name|leftleft
init|=
operator|(
operator|(
name|RopeConcatenation
operator|*
operator|)
name|left
operator|)
operator|->
name|left
decl_stmt|;
name|RopeBase
modifier|*
name|rest
init|=
name|leaf_concat_char_iter
argument_list|(
name|leftright
argument_list|,
operator|(
operator|(
name|RopeLeaf
operator|*
operator|)
name|right
operator|)
operator|->
name|data
argument_list|,
name|right
operator|->
name|size
argument_list|)
decl_stmt|;
name|leftleft
operator|->
name|ref_nonnil
argument_list|()
expr_stmt|;
name|__STL_TRY
block|{
return|return
operator|(
name|tree_concat
argument_list|(
name|leftleft
argument_list|,
name|rest
argument_list|)
operator|)
return|;
block|}
name|__STL_UNWIND
argument_list|(
argument|unref(leftleft); unref(rest)
argument_list|)
block|}
block|}
block|}
end_if

begin_expr_stmt
name|left
operator|->
name|ref_nonnil
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|right
operator|->
name|ref_nonnil
argument_list|()
expr_stmt|;
end_expr_stmt

begin_macro
name|__STL_TRY
end_macro

begin_block
block|{
return|return
operator|(
name|tree_concat
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|__STL_UNWIND
argument_list|(
argument|unref(left); unref(right)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|RopeBase
operator|*
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|substring
argument_list|(
argument|RopeBase * base
argument_list|,
argument|size_t start
argument_list|,
argument|size_t endp1
argument_list|)
block|{
if|if
condition|(
literal|0
operator|==
name|base
condition|)
return|return
literal|0
return|;
name|size_t
name|len
operator|=
name|base
operator|->
name|size
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|size_t
name|adj_endp1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|size_t
name|lazy_threshold
init|=
literal|128
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|endp1
operator|>=
name|len
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|start
condition|)
block|{
name|base
operator|->
name|ref_nonnil
argument_list|()
expr_stmt|;
return|return
name|base
return|;
block|}
else|else
block|{
name|adj_endp1
operator|=
name|len
expr_stmt|;
block|}
block|}
else|else
block|{
name|adj_endp1
operator|=
name|endp1
expr_stmt|;
block|}
end_if

begin_switch
switch|switch
condition|(
name|base
operator|->
name|tag
condition|)
block|{
case|case
name|RopeBase
operator|::
name|concat
case|:
block|{
name|RopeConcatenation
modifier|*
name|c
init|=
operator|(
name|RopeConcatenation
operator|*
operator|)
name|base
decl_stmt|;
name|RopeBase
modifier|*
name|left
init|=
name|c
operator|->
name|left
decl_stmt|;
name|RopeBase
modifier|*
name|right
init|=
name|c
operator|->
name|right
decl_stmt|;
name|size_t
name|left_len
init|=
name|left
operator|->
name|size
decl_stmt|;
name|RopeBase
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|adj_endp1
operator|<=
name|left_len
condition|)
block|{
return|return
name|substring
argument_list|(
name|left
argument_list|,
name|start
argument_list|,
name|endp1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|start
operator|>=
name|left_len
condition|)
block|{
return|return
name|substring
argument_list|(
name|right
argument_list|,
name|start
operator|-
name|left_len
argument_list|,
name|adj_endp1
operator|-
name|left_len
argument_list|)
return|;
block|}
name|self_destruct_ptr
name|left_result
argument_list|(
name|substring
argument_list|(
name|left
argument_list|,
name|start
argument_list|,
name|left_len
argument_list|)
argument_list|)
decl_stmt|;
name|self_destruct_ptr
name|right_result
argument_list|(
name|substring
argument_list|(
name|right
argument_list|,
literal|0
argument_list|,
name|endp1
operator|-
name|left_len
argument_list|)
argument_list|)
decl_stmt|;
name|result
operator|=
name|concat
argument_list|(
name|left_result
argument_list|,
name|right_result
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__GC
name|__stl_assert
argument_list|(
literal|1
operator|==
name|result
operator|->
name|refcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
block|}
case|case
name|RopeBase
operator|::
name|leaf
case|:
block|{
name|RopeLeaf
modifier|*
name|l
init|=
operator|(
name|RopeLeaf
operator|*
operator|)
name|base
decl_stmt|;
name|RopeLeaf
modifier|*
name|result
decl_stmt|;
name|size_t
name|result_len
decl_stmt|;
if|if
condition|(
name|start
operator|>=
name|adj_endp1
condition|)
return|return
literal|0
return|;
name|result_len
operator|=
name|adj_endp1
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|result_len
operator|>
name|lazy_threshold
condition|)
goto|goto
name|lazy
goto|;
ifdef|#
directive|ifdef
name|__GC
specifier|const
name|charT
modifier|*
name|section
init|=
name|l
operator|->
name|data
operator|+
name|start
decl_stmt|;
name|result
operator|=
name|RopeLeaf_from_char_ptr
argument_list|(
name|section
argument_list|,
name|result_len
argument_list|)
expr_stmt|;
name|result
operator|->
name|c_string
operator|=
literal|0
expr_stmt|;
comment|// Not eos terminated.
else|#
directive|else
comment|// We should sometimes create substring node instead.
name|result
operator|=
name|RopeLeaf_from_unowned_char_ptr
argument_list|(
name|l
operator|->
name|data
operator|+
name|start
argument_list|,
name|result_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
block|}
case|case
name|RopeBase
operator|::
name|substringfn
case|:
comment|// Avoid introducing mutiple layers of substring nodes.
block|{
name|RopeSubstring
modifier|*
name|old
init|=
operator|(
name|RopeSubstring
operator|*
operator|)
name|base
decl_stmt|;
name|size_t
name|result_len
decl_stmt|;
if|if
condition|(
name|start
operator|>=
name|adj_endp1
condition|)
return|return
literal|0
return|;
name|result_len
operator|=
name|adj_endp1
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|result_len
operator|>
name|lazy_threshold
condition|)
block|{
name|RopeSubstring
modifier|*
name|space
init|=
name|SAlloc
operator|::
name|allocate
argument_list|()
decl_stmt|;
name|RopeSubstring
modifier|*
name|result
init|=
name|new
argument_list|(
argument|space
argument_list|)
name|RopeSubstring
argument_list|(
name|old
operator|->
name|base
argument_list|,
name|start
operator|+
name|old
operator|->
name|start
argument_list|,
name|adj_endp1
operator|-
name|start
argument_list|)
decl_stmt|;
return|return
name|result
return|;
block|}
comment|// else fall through:
block|}
case|case
name|RopeBase
operator|::
name|function
case|:
block|{
name|RopeFunction
modifier|*
name|f
init|=
operator|(
name|RopeFunction
operator|*
operator|)
name|base
decl_stmt|;
name|charT
modifier|*
name|section
decl_stmt|;
name|size_t
name|result_len
decl_stmt|;
if|if
condition|(
name|start
operator|>=
name|adj_endp1
condition|)
return|return
literal|0
return|;
name|result_len
operator|=
name|adj_endp1
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|result_len
operator|>
name|lazy_threshold
condition|)
goto|goto
name|lazy
goto|;
name|section
operator|=
operator|(
name|charT
operator|*
operator|)
name|DataAlloc
operator|::
name|allocate
argument_list|(
name|rounded_up_size
argument_list|(
name|result_len
argument_list|)
argument_list|)
expr_stmt|;
name|__STL_TRY
block|{
operator|(
operator|*
operator|(
name|f
operator|->
name|fn
operator|)
operator|)
operator|(
name|start
operator|,
name|result_len
operator|,
name|section
operator|)
expr_stmt|;
block|}
name|__STL_UNWIND
argument_list|(
name|RopeBase
operator|::
name|free_string
argument_list|(
name|section
argument_list|,
name|result_len
argument_list|)
argument_list|)
expr_stmt|;
name|__cond_store_eos
argument_list|(
name|section
index|[
name|result_len
index|]
argument_list|)
expr_stmt|;
return|return
name|RopeLeaf_from_char_ptr
argument_list|(
name|section
argument_list|,
name|result_len
argument_list|)
return|;
block|}
block|}
end_switch

begin_comment
comment|/*NOTREACHED*/
end_comment

begin_expr_stmt
name|__stl_assert
argument_list|(
name|false
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|lazy
label|:
end_label

begin_block
block|{
comment|// Create substring node.
name|RopeSubstring
modifier|*
name|space
init|=
name|SAlloc
operator|::
name|allocate
argument_list|()
decl_stmt|;
name|RopeSubstring
modifier|*
name|result
init|=
name|new
argument_list|(
argument|space
argument_list|)
name|RopeSubstring
argument_list|(
name|base
argument_list|,
name|start
argument_list|,
name|adj_endp1
operator|-
name|start
argument_list|)
decl_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_expr_stmt
unit|}  template
operator|<
name|class
name|charT
operator|>
name|class
name|__rope_flatten_char_consumer
operator|:
name|public
name|__rope_char_consumer
operator|<
name|charT
operator|>
block|{
name|private
operator|:
name|charT
operator|*
name|buf_ptr
block|;
name|public
operator|:
name|charT
operator|*
name|buffer
block|;
name|__rope_flatten_char_consumer
argument_list|(
argument|charT * buffer
argument_list|)
block|{
name|buf_ptr
operator|=
name|buffer
block|; 	}
block|;
operator|~
name|__rope_flatten_char_consumer
argument_list|()
block|{}
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|charT
operator|*
name|leaf
operator|,
name|size_t
name|n
operator|)
block|{
name|uninitialized_copy_n
argument_list|(
name|leaf
argument_list|,
name|n
argument_list|,
name|buf_ptr
argument_list|)
block|;
name|buf_ptr
operator|+=
name|n
block|;
return|return
name|true
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|charT
operator|>
name|class
name|__rope_find_char_char_consumer
operator|:
name|public
name|__rope_char_consumer
operator|<
name|charT
operator|>
block|{
name|private
operator|:
name|charT
name|pattern
block|;
name|public
operator|:
name|size_t
name|count
block|;
comment|// Number of nonmatching characters
name|__rope_find_char_char_consumer
argument_list|(
argument|charT p
argument_list|)
operator|:
name|pattern
argument_list|(
name|p
argument_list|)
block|,
name|count
argument_list|(
literal|0
argument_list|)
block|{}
operator|~
name|__rope_find_char_char_consumer
argument_list|()
block|{}
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|charT
operator|*
name|leaf
operator|,
name|size_t
name|n
operator|)
block|{
name|size_t
name|i
block|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|leaf
index|[
name|i
index|]
operator|==
name|pattern
condition|)
block|{
name|count
operator|+=
name|i
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|count
operator|+=
name|n
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|true
return|;
end_return

begin_empty_stmt
unit|} }
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|>
name|class
name|__rope_insert_char_consumer
operator|:
name|public
name|__rope_char_consumer
operator|<
name|charT
operator|>
block|{
name|private
operator|:
typedef|typedef
name|ostream
name|insert_ostream
typedef|;
name|insert_ostream
operator|&
name|o
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_decl_stmt
name|charT
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|__rope_insert_char_consumer
argument_list|(
name|insert_ostream
operator|&
name|writer
argument_list|)
operator|:
name|o
argument_list|(
argument|writer
argument_list|)
block|{}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|~
name|__rope_insert_char_consumer
argument_list|()
block|{ }
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Caller is presumed to own the ostream
end_comment

begin_expr_stmt
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|charT
operator|*
name|leaf
operator|,
name|size_t
name|n
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Returns true to continue traversal.
end_comment

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|charT
operator|>
name|bool
name|__rope_insert_char_consumer
operator|<
name|charT
operator|>
operator|::
name|operator
argument_list|()
operator|(
specifier|const
name|charT
operator|*
name|leaf
operator|,
name|size_t
name|n
operator|)
block|{
name|size_t
name|i
block|;
comment|//  We assume that formatting is set up correctly for each element.
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|o
operator|<<
name|leaf
index|[
name|i
index|]
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|true
return|;
end_return

begin_expr_stmt
unit|}  inline
name|bool
name|__rope_insert_char_consumer
operator|<
name|char
operator|>
operator|::
name|operator
argument_list|()
operator|(
specifier|const
name|char
operator|*
name|leaf
operator|,
name|size_t
name|n
operator|)
block|{
name|size_t
name|i
block|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|o
operator|.
name|put
argument_list|(
name|leaf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|true
return|;
end_return

begin_if
unit|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
end_if

begin_comment
comment|// I couldn't get this to work with the VC++ version of basic_ostream.
end_comment

begin_expr_stmt
unit|inline
name|bool
name|__rope_insert_char_consumer
operator|<
name|wchar_t
operator|>
operator|::
name|operator
argument_list|()
operator|(
specifier|const
name|wchar_t
operator|*
name|leaf
operator|,
name|size_t
name|n
operator|)
block|{
name|size_t
name|i
block|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|o
operator|.
name|put
argument_list|(
name|leaf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|true
return|;
end_return

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_MSC_VER&& !BORLAND */
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|bool
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|apply_to_pieces
argument_list|(
argument|__rope_char_consumer<charT>& c
argument_list|,
argument|const RopeBase * r
argument_list|,
argument|size_t begin
argument_list|,
argument|size_t end
argument_list|)
block|{
if|if
condition|(
literal|0
operator|==
name|r
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|r
operator|->
name|tag
condition|)
block|{
case|case
name|RopeBase
operator|::
name|concat
case|:
block|{
name|RopeConcatenation
modifier|*
name|conc
init|=
operator|(
name|RopeConcatenation
operator|*
operator|)
name|r
decl_stmt|;
name|RopeBase
modifier|*
name|left
init|=
name|conc
operator|->
name|left
decl_stmt|;
name|size_t
name|left_len
init|=
name|left
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|begin
operator|<
name|left_len
condition|)
block|{
name|size_t
name|left_end
init|=
name|min
argument_list|(
name|left_len
argument_list|,
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|apply_to_pieces
argument_list|(
name|c
argument_list|,
name|left
argument_list|,
name|begin
argument_list|,
name|left_end
argument_list|)
condition|)
block|{
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|end
operator|>
name|left_len
condition|)
block|{
name|RopeBase
modifier|*
name|right
init|=
name|conc
operator|->
name|right
decl_stmt|;
name|size_t
name|right_start
init|=
name|max
argument_list|(
name|left_len
argument_list|,
name|begin
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|apply_to_pieces
argument_list|(
name|c
argument_list|,
name|right
argument_list|,
name|right_start
operator|-
name|left_len
argument_list|,
name|end
operator|-
name|left_len
argument_list|)
condition|)
block|{
return|return
name|false
return|;
block|}
block|}
block|}
return|return
name|true
return|;
case|case
name|RopeBase
operator|::
name|leaf
case|:
block|{
name|RopeLeaf
modifier|*
name|l
init|=
operator|(
name|RopeLeaf
operator|*
operator|)
name|r
decl_stmt|;
return|return
name|c
argument_list|(
name|l
operator|->
name|data
operator|+
name|begin
argument_list|,
name|end
operator|-
name|begin
argument_list|)
return|;
block|}
case|case
name|RopeBase
operator|::
name|function
case|:
case|case
name|RopeBase
operator|::
name|substringfn
case|:
block|{
name|RopeFunction
modifier|*
name|f
init|=
operator|(
name|RopeFunction
operator|*
operator|)
name|r
decl_stmt|;
name|size_t
name|len
init|=
name|end
operator|-
name|begin
decl_stmt|;
name|bool
name|result
decl_stmt|;
name|charT
modifier|*
name|buffer
init|=
name|DataAlloc
operator|::
name|allocate
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|__STL_TRY
block|{
operator|(
operator|*
operator|(
name|f
operator|->
name|fn
operator|)
operator|)
operator|(
name|begin
operator|,
name|end
operator|,
name|buffer
operator|)
expr_stmt|;
name|result
operator|=
name|c
argument_list|(
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|DataAlloc
operator|::
name|deallocate
argument_list|(
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|__STL_UNWIND
argument_list|(
argument|DataAlloc::deallocate(buffer, len)
argument_list|)
return|return
name|result
return|;
block|}
default|default:
name|__stl_assert
argument_list|(
name|false
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
return|return
name|false
return|;
block|}
end_switch

begin_function
unit|}  inline
name|void
name|__rope_fill
parameter_list|(
name|ostream
modifier|&
name|o
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|char
name|f
init|=
name|o
operator|.
name|fill
argument_list|()
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|o
operator|.
name|put
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|>
specifier|inline
name|bool
name|__rope_is_simple
argument_list|(
argument|charT *
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_function
specifier|inline
name|bool
name|__rope_is_simple
parameter_list|(
name|char
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|inline
name|bool
name|__rope_is_simple
parameter_list|(
name|wchar_t
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|ostream
operator|&
name|operator
operator|<<
operator|(
name|ostream
operator|&
name|o
operator|,
specifier|const
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|r
operator|)
block|{
name|size_t
name|w
operator|=
name|o
operator|.
name|width
argument_list|()
block|;
name|bool
name|left
operator|=
name|bool
argument_list|(
name|o
operator|.
name|flags
argument_list|()
operator|&
name|ios
operator|::
name|left
argument_list|)
block|;
name|size_t
name|pad_len
block|;
name|size_t
name|rope_len
operator|=
name|r
operator|.
name|size
argument_list|()
block|;
name|__rope_insert_char_consumer
operator|<
name|charT
operator|>
name|c
argument_list|(
name|o
argument_list|)
block|;
name|bool
name|is_simple
operator|=
name|__rope_is_simple
argument_list|(
operator|(
name|charT
operator|*
operator|)
literal|0
argument_list|)
block|;
if|if
condition|(
name|rope_len
operator|<
name|w
condition|)
block|{
name|pad_len
operator|=
name|w
operator|-
name|rope_len
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|pad_len
operator|=
literal|0
expr_stmt|;
block|}
end_else

begin_if
if|if
condition|(
operator|!
name|is_simple
condition|)
name|o
operator|.
name|width
argument_list|(
name|w
operator|/
name|rope_len
argument_list|)
expr_stmt|;
end_if

begin_macro
name|__STL_TRY
end_macro

begin_block
block|{
if|if
condition|(
name|is_simple
operator|&&
operator|!
name|left
operator|&&
name|pad_len
operator|>
literal|0
condition|)
block|{
name|__rope_fill
argument_list|(
name|o
argument_list|,
name|pad_len
argument_list|)
expr_stmt|;
block|}
name|r
operator|.
name|apply_to_pieces
argument_list|(
literal|0
argument_list|,
name|r
operator|.
name|size
argument_list|()
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_simple
operator|&&
name|left
operator|&&
name|pad_len
operator|>
literal|0
condition|)
block|{
name|__rope_fill
argument_list|(
name|o
argument_list|,
name|pad_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_simple
condition|)
name|o
operator|.
name|width
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|__STL_UNWIND
argument_list|(
argument|if (!is_simple) o.width(w)
argument_list|)
end_macro

begin_return
return|return
name|o
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|charT
operator|*
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|flatten
argument_list|(
argument|RopeBase * r
argument_list|,
argument|size_t start
argument_list|,
argument|size_t len
argument_list|,
argument|charT * buffer
argument_list|)
block|{
name|__rope_flatten_char_consumer
operator|<
name|charT
operator|>
name|c
argument_list|(
name|buffer
argument_list|)
block|;
name|apply_to_pieces
argument_list|(
name|c
argument_list|,
name|r
argument_list|,
name|start
argument_list|,
name|start
operator|+
name|len
argument_list|)
block|;
return|return
operator|(
name|buffer
operator|+
name|len
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|size_t
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|find
argument_list|(
argument|charT pattern
argument_list|,
argument|size_t start
argument_list|)
specifier|const
block|{
name|__rope_find_char_char_consumer
operator|<
name|charT
operator|>
name|c
argument_list|(
name|pattern
argument_list|)
block|;
name|apply_to_pieces
argument_list|(
name|c
argument_list|,
name|tree_ptr
argument_list|,
name|start
argument_list|,
name|size
argument_list|()
argument_list|)
block|;
return|return
name|start
operator|+
name|c
operator|.
name|count
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|charT
operator|*
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|flatten
argument_list|(
argument|RopeBase * r
argument_list|,
argument|charT * buffer
argument_list|)
block|{
if|if
condition|(
literal|0
operator|==
name|r
condition|)
return|return
name|buffer
return|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|r
operator|->
name|tag
condition|)
block|{
case|case
name|RopeBase
operator|::
name|concat
case|:
block|{
name|RopeConcatenation
modifier|*
name|c
init|=
operator|(
name|RopeConcatenation
operator|*
operator|)
name|r
decl_stmt|;
name|RopeBase
modifier|*
name|left
init|=
name|c
operator|->
name|left
decl_stmt|;
name|RopeBase
modifier|*
name|right
init|=
name|c
operator|->
name|right
decl_stmt|;
name|charT
modifier|*
name|rest
init|=
name|flatten
argument_list|(
name|left
argument_list|,
name|buffer
argument_list|)
decl_stmt|;
return|return
name|flatten
argument_list|(
name|right
argument_list|,
name|rest
argument_list|)
return|;
block|}
case|case
name|RopeBase
operator|::
name|leaf
case|:
block|{
name|RopeLeaf
modifier|*
name|l
init|=
operator|(
name|RopeLeaf
operator|*
operator|)
name|r
decl_stmt|;
return|return
name|copy_n
argument_list|(
name|l
operator|->
name|data
argument_list|,
name|l
operator|->
name|size
argument_list|,
name|buffer
argument_list|)
operator|.
name|second
return|;
block|}
case|case
name|RopeBase
operator|::
name|function
case|:
case|case
name|RopeBase
operator|::
name|substringfn
case|:
comment|// We dont yet do anything with substring nodes.
comment|// This needs to be fixed before ropefiles will work well.
block|{
name|RopeFunction
modifier|*
name|f
init|=
operator|(
name|RopeFunction
operator|*
operator|)
name|r
decl_stmt|;
operator|(
operator|*
operator|(
name|f
operator|->
name|fn
operator|)
operator|)
operator|(
literal|0
operator|,
name|f
operator|->
name|size
operator|,
name|buffer
operator|)
expr_stmt|;
return|return
name|buffer
operator|+
name|f
operator|->
name|size
return|;
block|}
default|default:
name|__stl_assert
argument_list|(
name|false
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
return|return
literal|0
return|;
block|}
end_switch

begin_comment
unit|}
comment|// This needs work for charT != char
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|void
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|dump
argument_list|(
argument|RopeBase * r
argument_list|,
argument|int indent
argument_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|indent
condition|;
name|i
operator|++
control|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
literal|0
operator|==
name|r
condition|)
block|{
name|printf
argument_list|(
literal|"NULL\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_if

begin_if
if|if
condition|(
name|RopeBase
operator|::
name|concat
operator|==
name|r
operator|->
name|tag
condition|)
block|{
name|RopeConcatenation
modifier|*
name|c
init|=
operator|(
name|RopeConcatenation
operator|*
operator|)
name|r
decl_stmt|;
name|RopeBase
modifier|*
name|left
init|=
name|c
operator|->
name|left
decl_stmt|;
name|RopeBase
modifier|*
name|right
init|=
name|c
operator|->
name|right
decl_stmt|;
ifdef|#
directive|ifdef
name|__GC
name|printf
argument_list|(
literal|"Concatenation %p (depth = %d, len = %ld, %s balanced)\n"
argument_list|,
name|r
argument_list|,
name|r
operator|->
name|depth
argument_list|,
name|r
operator|->
name|size
argument_list|,
name|r
operator|->
name|is_balanced
condition|?
literal|""
else|:
literal|"not"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"Concatenation %p (rc = %ld, depth = %d, len = %ld, %s balanced)\n"
argument_list|,
name|r
argument_list|,
name|r
operator|->
name|refcount
argument_list|,
name|r
operator|->
name|depth
argument_list|,
name|r
operator|->
name|size
argument_list|,
name|r
operator|->
name|is_balanced
condition|?
literal|""
else|:
literal|"not"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dump
argument_list|(
name|left
argument_list|,
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|dump
argument_list|(
name|right
argument_list|,
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|char
modifier|*
name|kind
decl_stmt|;
switch|switch
condition|(
name|r
operator|->
name|tag
condition|)
block|{
case|case
name|RopeBase
operator|::
name|leaf
case|:
name|kind
operator|=
literal|"Leaf"
expr_stmt|;
break|break;
case|case
name|RopeBase
operator|::
name|function
case|:
name|kind
operator|=
literal|"Function"
expr_stmt|;
break|break;
case|case
name|RopeBase
operator|::
name|substringfn
case|:
name|kind
operator|=
literal|"Function representing substring"
expr_stmt|;
break|break;
default|default:
name|kind
operator|=
literal|"(corrupted kind field!)"
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__GC
name|printf
argument_list|(
literal|"%s %p (depth = %d, len = %ld) "
argument_list|,
name|kind
argument_list|,
name|r
argument_list|,
name|r
operator|->
name|depth
argument_list|,
name|r
operator|->
name|size
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"%s %p (rc = %ld, depth = %d, len = %ld) "
argument_list|,
name|kind
argument_list|,
name|r
argument_list|,
name|r
operator|->
name|refcount
argument_list|,
name|r
operator|->
name|depth
argument_list|,
name|r
operator|->
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|__is_one_byte_char_type
argument_list|(
operator|(
name|charT
operator|*
operator|)
literal|0
argument_list|)
condition|)
block|{
specifier|const
name|int
name|max_len
init|=
literal|40
decl_stmt|;
name|self_destruct_ptr
name|prefix
argument_list|(
name|substring
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
name|max_len
argument_list|)
argument_list|)
decl_stmt|;
name|charT
name|buffer
index|[
name|max_len
operator|+
literal|1
index|]
decl_stmt|;
name|bool
name|too_big
init|=
name|r
operator|->
name|size
operator|>
name|prefix
operator|->
name|size
decl_stmt|;
name|flatten
argument_list|(
name|prefix
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|buffer
index|[
name|prefix
operator|->
name|size
index|]
operator|=
name|__eos
argument_list|(
operator|(
name|charT
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%s\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
argument_list|,
name|too_big
condition|?
literal|"...\n"
else|:
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_expr_stmt
unit|}  template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|const
name|unsigned
name|long
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|min_len
index|[
name|__rope_RopeBase
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|max_rope_depth
operator|+
literal|1
index|]
operator|=
block|{
comment|/* 0 */
literal|1
block|,
comment|/* 1 */
literal|2
block|,
comment|/* 2 */
literal|3
block|,
comment|/* 3 */
literal|5
block|,
comment|/* 4 */
literal|8
block|,
comment|/* 5 */
literal|13
block|,
comment|/* 6 */
literal|21
block|,
comment|/* 7 */
literal|34
block|,
comment|/* 8 */
literal|55
block|,
comment|/* 9 */
literal|89
block|,
comment|/* 10 */
literal|144
block|,
comment|/* 11 */
literal|233
block|,
comment|/* 12 */
literal|377
block|,
comment|/* 13 */
literal|610
block|,
comment|/* 14 */
literal|987
block|,
comment|/* 15 */
literal|1597
block|,
comment|/* 16 */
literal|2584
block|,
comment|/* 17 */
literal|4181
block|,
comment|/* 18 */
literal|6765
block|,
comment|/* 19 */
literal|10946
block|,
comment|/* 20 */
literal|17711
block|,
comment|/* 21 */
literal|28657
block|,
comment|/* 22 */
literal|46368
block|,
comment|/* 23 */
literal|75025
block|,
comment|/* 24 */
literal|121393
block|,
comment|/* 25 */
literal|196418
block|,
comment|/* 26 */
literal|317811
block|,
comment|/* 27 */
literal|514229
block|,
comment|/* 28 */
literal|832040
block|,
comment|/* 29 */
literal|1346269
block|,
comment|/* 30 */
literal|2178309
block|,
comment|/* 31 */
literal|3524578
block|,
comment|/* 32 */
literal|5702887
block|,
comment|/* 33 */
literal|9227465
block|,
comment|/* 34 */
literal|14930352
block|,
comment|/* 35 */
literal|24157817
block|,
comment|/* 36 */
literal|39088169
block|,
comment|/* 37 */
literal|63245986
block|,
comment|/* 38 */
literal|102334155
block|,
comment|/* 39 */
literal|165580141
block|,
comment|/* 40 */
literal|267914296
block|,
comment|/* 41 */
literal|433494437
block|,
comment|/* 42 */
literal|701408733
block|,
comment|/* 43 */
literal|1134903170
block|,
comment|/* 44 */
literal|1836311903
block|,
comment|/* 45 */
literal|2971215073
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|// These are Fibonacci numbers< 2**32.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|RopeBase
operator|*
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|balance
argument_list|(
argument|RopeBase *r
argument_list|)
block|{
name|RopeBase
operator|*
name|forest
index|[
name|RopeBase
operator|::
name|max_rope_depth
operator|+
literal|1
index|]
block|;
name|RopeBase
operator|*
name|result
operator|=
literal|0
block|;
name|int
name|i
block|;
comment|// Inariant:
comment|// The concatenation of forest in descending order is equal to r.
comment|// forest[i].size>= min_len[i]
comment|// forest[i].depth = i
comment|// References from forest are included in refcount.
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|RopeBase
operator|::
name|max_rope_depth
condition|;
operator|++
name|i
control|)
name|forest
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|__STL_TRY
block|{
name|add_to_forest
argument_list|(
name|r
argument_list|,
name|forest
argument_list|)
block|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|RopeBase
operator|::
name|max_rope_depth
condition|;
operator|++
name|i
control|)
if|if
condition|(
literal|0
operator|!=
name|forest
index|[
name|i
index|]
condition|)
block|{
ifndef|#
directive|ifndef
name|__GC
name|self_destruct_ptr
name|old
parameter_list|(
name|result
parameter_list|)
function_decl|;
endif|#
directive|endif
name|result
operator|=
name|concat
argument_list|(
name|forest
index|[
name|i
index|]
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|forest
index|[
name|i
index|]
operator|->
name|unref_nonnil
argument_list|()
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GC
argument_list|)
operator|&&
name|defined
argument_list|(
name|__STL_USE_EXCEPTIONS
argument_list|)
name|forest
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_expr_stmt

begin_expr_stmt
unit|}     __STL_UNWIND
operator|(
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|RopeBase
operator|::
name|max_rope_depth
condition|;
name|i
operator|++
control|)
name|unref
argument_list|(
name|forest
index|[
name|i
index|]
argument_list|)
operator|)
end_expr_stmt

begin_if
if|if
condition|(
name|result
operator|->
name|depth
operator|>
name|RopeBase
operator|::
name|max_rope_depth
condition|)
name|abort
argument_list|()
expr_stmt|;
end_if

begin_return
return|return
operator|(
name|result
operator|)
return|;
end_return

begin_expr_stmt
unit|}   template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|void
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|add_to_forest
argument_list|(
argument|RopeBase *r
argument_list|,
argument|RopeBase **forest
argument_list|)
block|{
if|if
condition|(
name|r
operator|->
name|is_balanced
condition|)
block|{
name|add_leaf_to_forest
argument_list|(
name|r
argument_list|,
name|forest
argument_list|)
expr_stmt|;
return|return;
block|}
name|__stl_assert
argument_list|(
name|r
operator|->
name|tag
operator|==
name|RopeBase
operator|::
name|concat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|RopeConcatenation
modifier|*
name|c
init|=
operator|(
name|RopeConcatenation
operator|*
operator|)
name|r
decl_stmt|;
name|add_to_forest
argument_list|(
name|c
operator|->
name|left
argument_list|,
name|forest
argument_list|)
expr_stmt|;
name|add_to_forest
argument_list|(
name|c
operator|->
name|right
argument_list|,
name|forest
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
unit|}   template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|void
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|add_leaf_to_forest
argument_list|(
argument|RopeBase *r
argument_list|,
argument|RopeBase **forest
argument_list|)
block|{
name|RopeBase
operator|*
name|insertee
block|;
comment|// included in refcount
name|RopeBase
operator|*
name|too_tiny
operator|=
literal|0
block|;
comment|// included in refcount
name|int
name|i
block|;
comment|// forest[0..i-1] is empty
name|size_t
name|s
operator|=
name|r
operator|->
name|size
block|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|s
operator|>=
name|min_len
index|[
name|i
operator|+
literal|1
index|]
comment|/* not this bucket */
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
literal|0
operator|!=
name|forest
index|[
name|i
index|]
condition|)
block|{
ifndef|#
directive|ifndef
name|__GC
name|self_destruct_ptr
name|old
parameter_list|(
name|too_tiny
parameter_list|)
function_decl|;
endif|#
directive|endif
name|too_tiny
operator|=
name|concat_and_set_balanced
argument_list|(
name|forest
index|[
name|i
index|]
argument_list|,
name|too_tiny
argument_list|)
expr_stmt|;
name|forest
index|[
name|i
index|]
operator|->
name|unref_nonnil
argument_list|()
expr_stmt|;
name|forest
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_expr_stmt

begin_ifndef
unit|}     {
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_function_decl
name|self_destruct_ptr
name|old
parameter_list|(
name|too_tiny
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|insertee
operator|=
name|concat_and_set_balanced
argument_list|(
name|too_tiny
argument_list|,
name|r
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|// Too_tiny dead, and no longer included in refcount.
end_comment

begin_comment
comment|// Insertee is live and included.
end_comment

begin_expr_stmt
unit|__stl_assert
operator|(
name|is_almost_balanced
argument_list|(
name|insertee
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__stl_assert
argument_list|(
name|insertee
operator|->
name|depth
operator|<=
name|r
operator|->
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
init|;
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
literal|0
operator|!=
name|forest
index|[
name|i
index|]
condition|)
block|{
ifndef|#
directive|ifndef
name|__GC
name|self_destruct_ptr
name|old
parameter_list|(
name|insertee
parameter_list|)
function_decl|;
endif|#
directive|endif
name|insertee
operator|=
name|concat_and_set_balanced
argument_list|(
name|forest
index|[
name|i
index|]
argument_list|,
name|insertee
argument_list|)
expr_stmt|;
name|forest
index|[
name|i
index|]
operator|->
name|unref_nonnil
argument_list|()
expr_stmt|;
name|forest
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|__stl_assert
argument_list|(
name|is_almost_balanced
argument_list|(
name|insertee
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|__stl_assert
argument_list|(
name|min_len
index|[
name|i
index|]
operator|<=
name|insertee
operator|->
name|size
argument_list|)
expr_stmt|;
name|__stl_assert
argument_list|(
name|forest
index|[
name|i
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|RopeBase
operator|::
name|max_rope_depth
operator|||
name|insertee
operator|->
name|size
operator|<
name|min_len
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
name|forest
index|[
name|i
index|]
operator|=
name|insertee
expr_stmt|;
comment|// refcount is OK since insertee is now dead.
return|return;
block|}
block|}
end_for

begin_expr_stmt
unit|}  template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|charT
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|fetch
argument_list|(
argument|RopeBase *r
argument_list|,
argument|size_type i
argument_list|)
block|{
name|__GC_CONST
name|charT
operator|*
name|cstr
operator|=
name|r
operator|->
name|c_string
block|;
name|__stl_assert
argument_list|(
name|i
operator|<
name|r
operator|->
name|size
argument_list|)
block|;
if|if
condition|(
literal|0
operator|!=
name|cstr
condition|)
return|return
name|cstr
index|[
name|i
index|]
return|;
end_expr_stmt

begin_for
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|r
operator|->
name|tag
condition|)
block|{
case|case
name|RopeBase
operator|::
name|concat
case|:
block|{
name|RopeConcatenation
modifier|*
name|c
init|=
operator|(
name|RopeConcatenation
operator|*
operator|)
name|r
decl_stmt|;
name|RopeBase
modifier|*
name|left
init|=
name|c
operator|->
name|left
decl_stmt|;
name|size_t
name|left_len
init|=
name|left
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|left_len
condition|)
block|{
name|i
operator|-=
name|left_len
expr_stmt|;
name|r
operator|=
name|c
operator|->
name|right
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|left
expr_stmt|;
block|}
block|}
break|break;
case|case
name|RopeBase
operator|::
name|leaf
case|:
block|{
name|RopeLeaf
modifier|*
name|l
init|=
operator|(
name|RopeLeaf
operator|*
operator|)
name|r
decl_stmt|;
return|return
name|l
operator|->
name|data
index|[
name|i
index|]
return|;
block|}
case|case
name|RopeBase
operator|::
name|function
case|:
case|case
name|RopeBase
operator|::
name|substringfn
case|:
block|{
name|RopeFunction
modifier|*
name|f
init|=
operator|(
name|RopeFunction
operator|*
operator|)
name|r
decl_stmt|;
name|charT
name|result
decl_stmt|;
operator|(
operator|*
operator|(
name|f
operator|->
name|fn
operator|)
operator|)
operator|(
name|i
operator|,
literal|1
operator|,
operator|&
name|result
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
block|}
end_for

begin_ifndef
unit|}
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_comment
comment|// Return a uniquely referenced character slot for the given
end_comment

begin_comment
comment|// position, or 0 if that's not possible.
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|charT
operator|*
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|fetch_ptr
argument_list|(
argument|RopeBase *r
argument_list|,
argument|size_type i
argument_list|)
block|{
name|RopeBase
operator|*
name|clrstack
index|[
name|RopeBase
operator|::
name|max_rope_depth
index|]
block|;
name|size_t
name|csptr
operator|=
literal|0
block|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|r
operator|->
name|refcount
operator|>
literal|1
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|r
operator|->
name|tag
condition|)
block|{
case|case
name|RopeBase
operator|::
name|concat
case|:
block|{
name|RopeConcatenation
modifier|*
name|c
init|=
operator|(
name|RopeConcatenation
operator|*
operator|)
name|r
decl_stmt|;
name|RopeBase
modifier|*
name|left
init|=
name|c
operator|->
name|left
decl_stmt|;
name|size_t
name|left_len
init|=
name|left
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|c_string
operator|!=
literal|0
condition|)
name|clrstack
index|[
name|csptr
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|left_len
condition|)
block|{
name|i
operator|-=
name|left_len
expr_stmt|;
name|r
operator|=
name|c
operator|->
name|right
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|r
operator|=
name|left
expr_stmt|;
block|}
end_else

begin_empty_stmt
unit|} 	    break
empty_stmt|;
end_empty_stmt

begin_case
case|case
name|RopeBase
operator|::
name|leaf
case|:
end_case

begin_block
block|{
name|RopeLeaf
modifier|*
name|l
init|=
operator|(
name|RopeLeaf
operator|*
operator|)
name|r
decl_stmt|;
if|if
condition|(
name|l
operator|->
name|c_string
operator|!=
name|l
operator|->
name|data
operator|&&
name|l
operator|->
name|c_string
operator|!=
literal|0
condition|)
name|clrstack
index|[
name|csptr
operator|++
index|]
operator|=
name|l
expr_stmt|;
while|while
condition|(
name|csptr
operator|>
literal|0
condition|)
block|{
operator|--
name|csptr
expr_stmt|;
name|RopeBase
modifier|*
name|d
init|=
name|clrstack
index|[
name|csptr
index|]
decl_stmt|;
name|d
operator|->
name|free_c_string
argument_list|()
expr_stmt|;
name|d
operator|->
name|c_string
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|l
operator|->
name|data
operator|+
name|i
return|;
block|}
end_block

begin_case
case|case
name|RopeBase
operator|::
name|function
case|:
end_case

begin_case
case|case
name|RopeBase
operator|::
name|substringfn
case|:
end_case

begin_return
return|return
literal|0
return|;
end_return

begin_endif
unit|}     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* __GC */
end_comment

begin_comment
comment|// The following could be implemented trivially using
end_comment

begin_comment
comment|// lexicographical_compare_3way.
end_comment

begin_comment
comment|// We do a little more work to avoid dealing with rope iterators for
end_comment

begin_comment
comment|// flat strings.
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|int
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|compare
argument_list|(
argument|const RopeBase *left
argument_list|,
argument|const RopeBase *right
argument_list|)
block|{
name|size_t
name|left_len
block|;
name|size_t
name|right_len
block|;
if|if
condition|(
literal|0
operator|==
name|right
condition|)
return|return
literal|0
operator|!=
name|left
return|;
end_expr_stmt

begin_if
if|if
condition|(
literal|0
operator|==
name|left
condition|)
return|return
operator|-
literal|1
return|;
end_if

begin_expr_stmt
name|left_len
operator|=
name|left
operator|->
name|size
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|right_len
operator|=
name|right
operator|->
name|size
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|RopeBase
operator|::
name|leaf
operator|==
name|left
operator|->
name|tag
condition|)
block|{
name|RopeLeaf
modifier|*
name|l
init|=
operator|(
name|RopeLeaf
operator|*
operator|)
name|left
decl_stmt|;
if|if
condition|(
name|RopeBase
operator|::
name|leaf
operator|==
name|right
operator|->
name|tag
condition|)
block|{
name|RopeLeaf
modifier|*
name|r
init|=
operator|(
name|RopeLeaf
operator|*
operator|)
name|right
decl_stmt|;
return|return
name|lexicographical_compare_3way
argument_list|(
name|l
operator|->
name|data
argument_list|,
name|l
operator|->
name|data
operator|+
name|left_len
argument_list|,
name|r
operator|->
name|data
argument_list|,
name|r
operator|->
name|data
operator|+
name|right_len
argument_list|)
return|;
block|}
else|else
block|{
name|const_iterator
name|rstart
argument_list|(
name|right
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|const_iterator
name|rend
parameter_list|(
name|right
parameter_list|,
name|right_len
parameter_list|)
function_decl|;
return|return
name|lexicographical_compare_3way
argument_list|(
name|l
operator|->
name|data
argument_list|,
name|l
operator|->
name|data
operator|+
name|left_len
argument_list|,
name|rstart
argument_list|,
name|rend
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|const_iterator
name|lstart
argument_list|(
name|left
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|const_iterator
name|lend
parameter_list|(
name|left
parameter_list|,
name|left_len
parameter_list|)
function_decl|;
if|if
condition|(
name|RopeBase
operator|::
name|leaf
operator|==
name|right
operator|->
name|tag
condition|)
block|{
name|RopeLeaf
modifier|*
name|r
init|=
operator|(
name|RopeLeaf
operator|*
operator|)
name|right
decl_stmt|;
return|return
name|lexicographical_compare_3way
argument_list|(
name|lstart
argument_list|,
name|lend
argument_list|,
name|r
operator|->
name|data
argument_list|,
name|r
operator|->
name|data
operator|+
name|right_len
argument_list|)
return|;
block|}
else|else
block|{
name|const_iterator
name|rstart
argument_list|(
name|right
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|const_iterator
name|rend
parameter_list|(
name|right
parameter_list|,
name|right_len
parameter_list|)
function_decl|;
return|return
name|lexicographical_compare_3way
argument_list|(
name|lstart
argument_list|,
name|lend
argument_list|,
name|rstart
argument_list|,
name|rend
argument_list|)
return|;
block|}
block|}
end_if

begin_comment
unit|}
comment|// Assignment to reference proxies.
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|__rope_charT_ref_proxy
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|__rope_charT_ref_proxy
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|operator
operator|=
operator|(
name|charT
name|c
operator|)
block|{
name|RopeBase
operator|*
name|old
operator|=
name|root
operator|->
name|tree_ptr
block|;
ifndef|#
directive|ifndef
name|__GC
comment|// First check for the case in which everything is uniquely
comment|// referenced.  In that case we can do this destructively.
name|charT
operator|*
name|charT_ptr
operator|=
name|my_rope
operator|::
name|fetch_ptr
argument_list|(
name|old
argument_list|,
name|pos
argument_list|)
block|;
if|if
condition|(
literal|0
operator|!=
name|charT_ptr
condition|)
block|{
operator|*
name|charT_ptr
operator|=
name|c
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
endif|#
directive|endif
name|self_destruct_ptr
name|left
argument_list|(
name|my_rope
operator|::
name|substring
argument_list|(
name|old
argument_list|,
literal|0
argument_list|,
name|pos
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|self_destruct_ptr
name|right
argument_list|(
name|my_rope
operator|::
name|substring
argument_list|(
name|old
argument_list|,
name|pos
operator|+
literal|1
argument_list|,
name|old
operator|->
name|size
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|self_destruct_ptr
name|result_left
argument_list|(
name|my_rope
operator|::
name|destr_concat_char_iter
argument_list|(
name|left
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_expr_stmt
name|__stl_assert
argument_list|(
name|left
operator|==
name|result_left
operator|||
literal|1
operator|==
name|result_left
operator|->
name|refcount
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|RopeBase
modifier|*
name|result
init|=
name|my_rope
operator|::
name|concat
argument_list|(
name|result_left
argument_list|,
name|right
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_expr_stmt
name|__stl_assert
argument_list|(
literal|1
operator|<=
name|result
operator|->
name|refcount
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RopeBase
operator|::
name|unref
argument_list|(
name|old
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|root
operator|->
name|tree_ptr
operator|=
name|result
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|__rope_charT_ref_proxy
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|operator
name|charT
argument_list|()
specifier|const
block|{
if|if
condition|(
name|current_valid
condition|)
block|{
return|return
name|current
return|;
block|}
end_expr_stmt

begin_else
else|else
block|{
return|return
name|my_rope
operator|::
name|fetch
argument_list|(
name|root
operator|->
name|tree_ptr
argument_list|,
name|pos
argument_list|)
return|;
block|}
end_else

begin_expr_stmt
unit|} template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|__rope_charT_ptr_proxy
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|__rope_charT_ref_proxy
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|operator
operator|&
operator|(
operator|)
specifier|const
block|{
return|return
name|__rope_charT_ptr_proxy
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
operator|*
name|this
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|rope
argument_list|(
argument|size_t n
argument_list|,
argument|charT c
argument_list|)
block|{
name|rope
name|result
block|;
specifier|const
name|size_t
name|exponentiate_threshold
operator|=
literal|32
block|;
name|size_t
name|exponent
block|;
name|size_t
name|rest
block|;
name|charT
operator|*
name|rest_buffer
block|;
name|RopeBase
operator|*
name|remainder
block|;
name|rope
name|remainder_rope
block|;
if|if
condition|(
literal|0
operator|==
name|n
condition|)
block|{
name|tree_ptr
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|exponent
operator|=
name|n
operator|/
name|exponentiate_threshold
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|rest
operator|=
name|n
operator|%
name|exponentiate_threshold
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
literal|0
operator|==
name|rest
condition|)
block|{
name|remainder
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|rest_buffer
operator|=
name|DataAlloc
operator|::
name|allocate
argument_list|(
name|rounded_up_size
argument_list|(
name|rest
argument_list|)
argument_list|)
expr_stmt|;
name|uninitialized_fill_n
argument_list|(
name|rest_buffer
argument_list|,
name|rest
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|__cond_store_eos
argument_list|(
name|rest_buffer
index|[
name|rest
index|]
argument_list|)
expr_stmt|;
name|__STL_TRY
block|{
name|remainder
operator|=
name|RopeLeaf_from_char_ptr
argument_list|(
name|rest_buffer
argument_list|,
name|rest
argument_list|)
expr_stmt|;
block|}
name|__STL_UNWIND
argument_list|(
argument|RopeBase::free_string(rest_buffer, rest)
argument_list|)
block|}
end_if

begin_expr_stmt
name|remainder_rope
operator|.
name|tree_ptr
operator|=
name|remainder
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|exponent
operator|!=
literal|0
condition|)
block|{
name|charT
modifier|*
name|base_buffer
init|=
name|DataAlloc
operator|::
name|allocate
argument_list|(
name|rounded_up_size
argument_list|(
name|exponentiate_threshold
argument_list|)
argument_list|)
decl_stmt|;
name|RopeLeaf
modifier|*
name|base_leaf
decl_stmt|;
name|rope
name|base_rope
decl_stmt|;
name|uninitialized_fill_n
argument_list|(
name|base_buffer
argument_list|,
name|exponentiate_threshold
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|__cond_store_eos
argument_list|(
name|base_buffer
index|[
name|exponentiate_threshold
index|]
argument_list|)
expr_stmt|;
name|__STL_TRY
block|{
name|base_leaf
operator|=
name|RopeLeaf_from_char_ptr
argument_list|(
name|base_buffer
argument_list|,
name|exponentiate_threshold
argument_list|)
expr_stmt|;
block|}
name|__STL_UNWIND
argument_list|(
argument|RopeBase::free_string(base_buffer, exponentiate_threshold)
argument_list|)
name|base_rope
operator|.
name|tree_ptr
operator|=
name|base_leaf
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|exponent
condition|)
block|{
name|result
operator|=
name|base_rope
expr_stmt|;
ifndef|#
directive|ifndef
name|__GC
name|__stl_assert
argument_list|(
literal|1
operator|==
name|result
operator|->
name|tree_ptr
operator|->
name|refcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|result
operator|=
name|power
argument_list|(
name|base_rope
argument_list|,
name|exponent
argument_list|,
name|concat_fn
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|!=
name|remainder
condition|)
block|{
name|result
operator|+=
name|remainder_rope
expr_stmt|;
block|}
block|}
else|else
block|{
name|result
operator|=
name|remainder_rope
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|tree_ptr
operator|=
name|result
operator|.
name|tree_ptr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|tree_ptr
operator|->
name|ref_nonnil
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|charT
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|empty_c_str
index|[
literal|1
index|]
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__STL_PTHREADS
end_ifdef

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|pthread_mutex_t
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|swap_lock
operator|=
name|PTHREAD_MUTEX_INITIALIZER
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|const
name|charT
operator|*
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|c_str
argument_list|()
specifier|const
block|{
if|if
condition|(
literal|0
operator|==
name|tree_ptr
condition|)
block|{
name|empty_c_str
index|[
literal|0
index|]
operator|=
name|__eos
argument_list|(
operator|(
name|charT
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|// Possibly redundant,
comment|// but probably fast.
return|return
name|empty_c_str
return|;
block|}
name|__GC_CONST
name|charT
operator|*
name|old_c_string
operator|=
name|tree_ptr
operator|->
name|c_string
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
literal|0
operator|!=
name|old_c_string
condition|)
return|return
operator|(
name|old_c_string
operator|)
return|;
end_if

begin_decl_stmt
name|size_t
name|s
init|=
name|size
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|charT
modifier|*
name|result
init|=
name|DataAlloc
operator|::
name|allocate
argument_list|(
name|s
operator|+
literal|1
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|flatten
argument_list|(
name|tree_ptr
argument_list|,
name|result
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|result
index|[
name|s
index|]
operator|=
name|__eos
argument_list|(
operator|(
name|charT
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__GC
end_ifdef

begin_expr_stmt
name|tree_ptr
operator|->
name|c_string
operator|=
name|result
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_if
if|if
condition|(
operator|(
name|old_c_string
operator|=
name|atomic_swap
argument_list|(
operator|&
operator|(
name|tree_ptr
operator|->
name|c_string
operator|)
argument_list|,
name|result
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// It must have been added in the interim.  Hence it had to have been
comment|// separately allocated.  Deallocate the old copy, since we just
comment|// replaced it.
name|destroy
argument_list|(
name|old_c_string
argument_list|,
name|old_c_string
operator|+
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
name|DataAlloc
operator|::
name|deallocate
argument_list|(
name|old_c_string
argument_list|,
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_return
return|return
operator|(
name|result
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|const
name|charT
operator|*
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|replace_with_c_str
argument_list|()
block|{
if|if
condition|(
literal|0
operator|==
name|tree_ptr
condition|)
block|{
name|empty_c_str
index|[
literal|0
index|]
operator|=
name|__eos
argument_list|(
operator|(
name|charT
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|empty_c_str
return|;
block|}
name|__GC_CONST
name|charT
operator|*
name|old_c_string
operator|=
name|tree_ptr
operator|->
name|c_string
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|RopeBase
operator|::
name|leaf
operator|==
name|tree_ptr
operator|->
name|tag
operator|&&
literal|0
operator|!=
name|old_c_string
condition|)
block|{
return|return
operator|(
name|old_c_string
operator|)
return|;
block|}
end_if

begin_decl_stmt
name|size_t
name|s
init|=
name|size
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|charT
modifier|*
name|result
init|=
name|DataAlloc
operator|::
name|allocate
argument_list|(
name|rounded_up_size
argument_list|(
name|s
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|flatten
argument_list|(
name|tree_ptr
argument_list|,
name|result
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|result
index|[
name|s
index|]
operator|=
name|__eos
argument_list|(
operator|(
name|charT
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|tree_ptr
operator|->
name|unref_nonnil
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|tree_ptr
operator|=
name|RopeLeaf_from_char_ptr
argument_list|(
name|result
argument_list|,
name|s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|result
operator|)
return|;
end_return

begin_comment
unit|}
comment|// Algorithm specializations.  More should be added.
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_MSC_VER
end_ifndef

begin_comment
comment|// I couldn't get this to work with VC++
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|void
name|__rope_rotate
argument_list|(
argument|__rope_iterator<charT
argument_list|,
argument|Alloc> first
argument_list|,
argument|__rope_iterator<charT
argument_list|,
argument|Alloc> middle
argument_list|,
argument|__rope_iterator<charT
argument_list|,
argument|Alloc> last
argument_list|)
block|{
name|__stl_assert
argument_list|(
name|first
operator|.
name|container
argument_list|()
operator|==
name|middle
operator|.
name|container
argument_list|()
operator|&&
name|middle
operator|.
name|container
argument_list|()
operator|==
name|last
operator|.
name|container
argument_list|()
argument_list|)
block|;
name|rope
operator|<
name|charT
block|,
name|Alloc
operator|>
operator|&
name|r
argument_list|(
name|first
operator|.
name|container
argument_list|()
argument_list|)
block|;
name|rope
operator|<
name|charT
block|,
name|Alloc
operator|>
name|prefix
operator|=
name|r
operator|.
name|substr
argument_list|(
literal|0
argument_list|,
name|first
operator|.
name|index
argument_list|()
argument_list|)
block|;
name|rope
operator|<
name|charT
block|,
name|Alloc
operator|>
name|suffix
operator|=
name|r
operator|.
name|substr
argument_list|(
name|last
operator|.
name|index
argument_list|()
argument_list|,
name|r
operator|.
name|size
argument_list|()
operator|-
name|last
operator|.
name|index
argument_list|()
argument_list|)
block|;
name|rope
operator|<
name|charT
block|,
name|Alloc
operator|>
name|part1
operator|=
name|r
operator|.
name|substr
argument_list|(
name|middle
operator|.
name|index
argument_list|()
argument_list|,
name|last
operator|.
name|index
argument_list|()
operator|-
name|middle
operator|.
name|index
argument_list|()
argument_list|)
block|;
name|rope
operator|<
name|charT
block|,
name|Alloc
operator|>
name|part2
operator|=
name|r
operator|.
name|substr
argument_list|(
name|first
operator|.
name|index
argument_list|()
argument_list|,
name|middle
operator|.
name|index
argument_list|()
operator|-
name|first
operator|.
name|index
argument_list|()
argument_list|)
block|;
name|r
operator|=
name|prefix
block|;
name|r
operator|+=
name|part1
block|;
name|r
operator|+=
name|part2
block|;
name|r
operator|+=
name|suffix
block|; }
specifier|inline
name|void
name|rotate
argument_list|(
argument|__rope_iterator<char
argument_list|,
argument|__ALLOC> first
argument_list|,
argument|__rope_iterator<char
argument_list|,
argument|__ALLOC> middle
argument_list|,
argument|__rope_iterator<char
argument_list|,
argument|__ALLOC> last
argument_list|)
block|{
name|__rope_rotate
argument_list|(
name|first
argument_list|,
name|middle
argument_list|,
name|last
argument_list|)
block|; }
if|#
directive|if
literal|0
comment|// Probably not useful for several reasons:
comment|// - for SGIs 7.1 compiler and probably some others,
comment|//   this forces lots of rope<wchar_t, ...> instantiations, creating a
comment|//   code bloat and compile time problem.  (Fixed in 7.2.)
comment|// - wchar_t is 4 bytes wide on most UNIX platforms, making it unattractive
comment|//   for unicode strings.  Unsigned short may be a better character
comment|//   type.
expr|inline void rotate(__rope_iterator<wchar_t,__ALLOC> first,                    __rope_iterator<wchar_t,__ALLOC> middle,                    __rope_iterator<wchar_t,__ALLOC> last) {     __rope_rotate(first, middle, last); }
endif|#
directive|endif
endif|#
directive|endif
comment|/* _MSC_VER */
if|#
directive|if
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|_MIPS_SIM
operator|!=
name|_MIPS_SIM_ABI32
operator|)
pragma|#
directive|pragma
name|reset
name|woff
name|1174
endif|#
directive|endif
name|__STL_END_NAMESPACE
end_expr_stmt

begin_comment
comment|// Local Variables:
end_comment

begin_comment
comment|// mode:C++
end_comment

begin_comment
comment|// End:
end_comment

end_unit

