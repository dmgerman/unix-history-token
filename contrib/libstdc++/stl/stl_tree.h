begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * Copyright (c) 1996,1997  * Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Silicon Graphics makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  *  *  * Copyright (c) 1994  * Hewlett-Packard Company  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Hewlett-Packard Company makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  *  *  */
end_comment

begin_comment
comment|/* NOTE: This is an internal header file, included by other STL headers.  *   You should not attempt to use it directly.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__SGI_STL_INTERNAL_TREE_H
end_ifndef

begin_define
define|#
directive|define
name|__SGI_STL_INTERNAL_TREE_H
end_define

begin_comment
comment|/*  Red-black tree class, designed for use in implementing STL associative containers (set, multiset, map, and multimap). The insertion and deletion algorithms are based on those in Cormen, Leiserson, and Rivest, Introduction to Algorithms (MIT Press, 1990), except that  (1) the header cell is maintained with links not only to the root but also to the leftmost node of the tree, to enable constant time begin(), and to the rightmost node of the tree, to enable linear time performance when used with the generic set algorithms (set_union, etc.);  (2) when a node being deleted has two children its successor node is relinked into its place, rather than copied, so that the only iterators invalidated are those referring to the deleted node.  */
end_comment

begin_include
include|#
directive|include
file|<stl_algobase.h>
end_include

begin_include
include|#
directive|include
file|<stl_alloc.h>
end_include

begin_include
include|#
directive|include
file|<stl_construct.h>
end_include

begin_include
include|#
directive|include
file|<stl_function.h>
end_include

begin_macro
name|__STL_BEGIN_NAMESPACE
end_macro

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|_MIPS_SIM
operator|!=
name|_MIPS_SIM_ABI32
operator|)
end_if

begin_pragma
pragma|#
directive|pragma
name|set
name|woff
name|1375
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|bool
name|_Rb_tree_Color_type
typedef|;
end_typedef

begin_decl_stmt
specifier|const
name|_Rb_tree_Color_type
name|_S_rb_tree_red
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|_Rb_tree_Color_type
name|_S_rb_tree_black
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|_Rb_tree_node_base
block|{
typedef|typedef
name|_Rb_tree_Color_type
name|_Color_type
typedef|;
typedef|typedef
name|_Rb_tree_node_base
modifier|*
name|_Base_ptr
typedef|;
name|_Color_type
name|_M_color
decl_stmt|;
name|_Base_ptr
name|_M_parent
decl_stmt|;
name|_Base_ptr
name|_M_left
decl_stmt|;
name|_Base_ptr
name|_M_right
decl_stmt|;
specifier|static
name|_Base_ptr
name|_S_minimum
parameter_list|(
name|_Base_ptr
name|__x
parameter_list|)
block|{
while|while
condition|(
name|__x
operator|->
name|_M_left
operator|!=
literal|0
condition|)
name|__x
operator|=
name|__x
operator|->
name|_M_left
expr_stmt|;
return|return
name|__x
return|;
block|}
specifier|static
name|_Base_ptr
name|_S_maximum
parameter_list|(
name|_Base_ptr
name|__x
parameter_list|)
block|{
while|while
condition|(
name|__x
operator|->
name|_M_right
operator|!=
literal|0
condition|)
name|__x
operator|=
name|__x
operator|->
name|_M_right
expr_stmt|;
return|return
name|__x
return|;
block|}
block|}
struct|;
end_struct

begin_expr_stmt
name|template
operator|<
name|class
name|_Value
operator|>
expr|struct
name|_Rb_tree_node
operator|:
name|public
name|_Rb_tree_node_base
block|{
typedef|typedef
name|_Rb_tree_node
operator|<
name|_Value
operator|>
operator|*
name|_Link_type
expr_stmt|;
name|_Value
name|_M_value_field
expr_stmt|;
end_expr_stmt

begin_struct
unit|};
struct|struct
name|_Rb_tree_base_iterator
block|{
typedef|typedef
name|_Rb_tree_node_base
operator|::
name|_Base_ptr
name|_Base_ptr
expr_stmt|;
typedef|typedef
name|bidirectional_iterator_tag
name|iterator_category
typedef|;
typedef|typedef
name|ptrdiff_t
name|difference_type
typedef|;
name|_Base_ptr
name|_M_node
decl_stmt|;
name|void
name|_M_increment
parameter_list|()
block|{
if|if
condition|(
name|_M_node
operator|->
name|_M_right
operator|!=
literal|0
condition|)
block|{
name|_M_node
operator|=
name|_M_node
operator|->
name|_M_right
expr_stmt|;
while|while
condition|(
name|_M_node
operator|->
name|_M_left
operator|!=
literal|0
condition|)
name|_M_node
operator|=
name|_M_node
operator|->
name|_M_left
expr_stmt|;
block|}
else|else
block|{
name|_Base_ptr
name|__y
init|=
name|_M_node
operator|->
name|_M_parent
decl_stmt|;
while|while
condition|(
name|_M_node
operator|==
name|__y
operator|->
name|_M_right
condition|)
block|{
name|_M_node
operator|=
name|__y
expr_stmt|;
name|__y
operator|=
name|__y
operator|->
name|_M_parent
expr_stmt|;
block|}
if|if
condition|(
name|_M_node
operator|->
name|_M_right
operator|!=
name|__y
condition|)
name|_M_node
operator|=
name|__y
expr_stmt|;
block|}
block|}
name|void
name|_M_decrement
parameter_list|()
block|{
if|if
condition|(
name|_M_node
operator|->
name|_M_color
operator|==
name|_S_rb_tree_red
operator|&&
name|_M_node
operator|->
name|_M_parent
operator|->
name|_M_parent
operator|==
name|_M_node
condition|)
name|_M_node
operator|=
name|_M_node
operator|->
name|_M_right
expr_stmt|;
elseif|else
if|if
condition|(
name|_M_node
operator|->
name|_M_left
operator|!=
literal|0
condition|)
block|{
name|_Base_ptr
name|__y
init|=
name|_M_node
operator|->
name|_M_left
decl_stmt|;
while|while
condition|(
name|__y
operator|->
name|_M_right
operator|!=
literal|0
condition|)
name|__y
operator|=
name|__y
operator|->
name|_M_right
expr_stmt|;
name|_M_node
operator|=
name|__y
expr_stmt|;
block|}
else|else
block|{
name|_Base_ptr
name|__y
init|=
name|_M_node
operator|->
name|_M_parent
decl_stmt|;
while|while
condition|(
name|_M_node
operator|==
name|__y
operator|->
name|_M_left
condition|)
block|{
name|_M_node
operator|=
name|__y
expr_stmt|;
name|__y
operator|=
name|__y
operator|->
name|_M_parent
expr_stmt|;
block|}
name|_M_node
operator|=
name|__y
expr_stmt|;
block|}
block|}
block|}
struct|;
end_struct

begin_expr_stmt
name|template
operator|<
name|class
name|_Value
operator|,
name|class
name|_Ref
operator|,
name|class
name|_Ptr
operator|>
expr|struct
name|_Rb_tree_iterator
operator|:
name|public
name|_Rb_tree_base_iterator
block|{
typedef|typedef
name|_Value
name|value_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|_Ref
name|reference
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|_Ptr
name|pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|_Rb_tree_iterator
operator|<
name|_Value
operator|,
name|_Value
operator|&
operator|,
name|_Value
operator|*
operator|>
name|iterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|_Rb_tree_iterator
operator|<
name|_Value
operator|,
specifier|const
name|_Value
operator|&
operator|,
specifier|const
name|_Value
operator|*
operator|>
name|const_iterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|_Rb_tree_iterator
operator|<
name|_Value
operator|,
name|_Ref
operator|,
name|_Ptr
operator|>
name|_Self
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|_Rb_tree_node
operator|<
name|_Value
operator|>
operator|*
name|_Link_type
expr_stmt|;
end_typedef

begin_macro
name|_Rb_tree_iterator
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_macro
name|_Rb_tree_iterator
argument_list|(
argument|_Link_type __x
argument_list|)
end_macro

begin_block
block|{
name|_M_node
operator|=
name|__x
expr_stmt|;
block|}
end_block

begin_macro
name|_Rb_tree_iterator
argument_list|(
argument|const iterator& __it
argument_list|)
end_macro

begin_block
block|{
name|_M_node
operator|=
name|__it
operator|.
name|_M_node
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|reference
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|_Link_type
argument_list|(
name|_M_node
argument_list|)
operator|->
name|_M_value_field
return|;
block|}
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__SGI_STL_NO_ARROW_OPERATOR
end_ifndef

begin_expr_stmt
name|pointer
name|operator
operator|->
expr|(
end_expr_stmt

begin_expr_stmt
unit|)
specifier|const
block|{
return|return
operator|&
operator|(
name|operator
operator|*
operator|(
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __SGI_STL_NO_ARROW_OPERATOR */
end_comment

begin_expr_stmt
name|_Self
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|_M_increment
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|_Self
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|_Self
name|__tmp
operator|=
operator|*
name|this
block|;
name|_M_increment
argument_list|()
block|;
return|return
name|__tmp
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|_Self
operator|&
name|operator
operator|--
operator|(
operator|)
block|{
name|_M_decrement
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|_Self
name|operator
operator|--
operator|(
name|int
operator|)
block|{
name|_Self
name|__tmp
operator|=
operator|*
name|this
block|;
name|_M_decrement
argument_list|()
block|;
return|return
name|__tmp
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|_Rb_tree_base_iterator
operator|&
name|__x
operator|,
specifier|const
name|_Rb_tree_base_iterator
operator|&
name|__y
operator|)
block|{
return|return
name|__x
operator|.
name|_M_node
operator|==
name|__y
operator|.
name|_M_node
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|_Rb_tree_base_iterator
operator|&
name|__x
operator|,
specifier|const
name|_Rb_tree_base_iterator
operator|&
name|__y
operator|)
block|{
return|return
name|__x
operator|.
name|_M_node
operator|!=
name|__y
operator|.
name|_M_node
return|;
block|}
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__STL_CLASS_PARTIAL_SPECIALIZATION
end_ifndef

begin_function
specifier|inline
name|bidirectional_iterator_tag
name|iterator_category
parameter_list|(
specifier|const
name|_Rb_tree_base_iterator
modifier|&
parameter_list|)
block|{
return|return
name|bidirectional_iterator_tag
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
specifier|inline
name|_Rb_tree_base_iterator
operator|::
name|difference_type
operator|*
name|distance_type
argument_list|(
argument|const _Rb_tree_base_iterator&
argument_list|)
block|{
return|return
operator|(
name|_Rb_tree_base_iterator
operator|::
name|difference_type
operator|*
operator|)
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Value
operator|,
name|class
name|_Ref
operator|,
name|class
name|_Ptr
operator|>
specifier|inline
name|_Value
operator|*
name|value_type
argument_list|(
argument|const _Rb_tree_iterator<_Value
argument_list|,
argument|_Ref
argument_list|,
argument|_Ptr>&
argument_list|)
block|{
return|return
operator|(
name|_Value
operator|*
operator|)
literal|0
return|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STL_CLASS_PARTIAL_SPECIALIZATION */
end_comment

begin_function
specifier|inline
name|void
name|_Rb_tree_rotate_left
parameter_list|(
name|_Rb_tree_node_base
modifier|*
name|__x
parameter_list|,
name|_Rb_tree_node_base
modifier|*
modifier|&
name|__root
parameter_list|)
block|{
name|_Rb_tree_node_base
modifier|*
name|__y
init|=
name|__x
operator|->
name|_M_right
decl_stmt|;
name|__x
operator|->
name|_M_right
operator|=
name|__y
operator|->
name|_M_left
expr_stmt|;
if|if
condition|(
name|__y
operator|->
name|_M_left
operator|!=
literal|0
condition|)
name|__y
operator|->
name|_M_left
operator|->
name|_M_parent
operator|=
name|__x
expr_stmt|;
name|__y
operator|->
name|_M_parent
operator|=
name|__x
operator|->
name|_M_parent
expr_stmt|;
if|if
condition|(
name|__x
operator|==
name|__root
condition|)
name|__root
operator|=
name|__y
expr_stmt|;
elseif|else
if|if
condition|(
name|__x
operator|==
name|__x
operator|->
name|_M_parent
operator|->
name|_M_left
condition|)
name|__x
operator|->
name|_M_parent
operator|->
name|_M_left
operator|=
name|__y
expr_stmt|;
else|else
name|__x
operator|->
name|_M_parent
operator|->
name|_M_right
operator|=
name|__y
expr_stmt|;
name|__y
operator|->
name|_M_left
operator|=
name|__x
expr_stmt|;
name|__x
operator|->
name|_M_parent
operator|=
name|__y
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|_Rb_tree_rotate_right
parameter_list|(
name|_Rb_tree_node_base
modifier|*
name|__x
parameter_list|,
name|_Rb_tree_node_base
modifier|*
modifier|&
name|__root
parameter_list|)
block|{
name|_Rb_tree_node_base
modifier|*
name|__y
init|=
name|__x
operator|->
name|_M_left
decl_stmt|;
name|__x
operator|->
name|_M_left
operator|=
name|__y
operator|->
name|_M_right
expr_stmt|;
if|if
condition|(
name|__y
operator|->
name|_M_right
operator|!=
literal|0
condition|)
name|__y
operator|->
name|_M_right
operator|->
name|_M_parent
operator|=
name|__x
expr_stmt|;
name|__y
operator|->
name|_M_parent
operator|=
name|__x
operator|->
name|_M_parent
expr_stmt|;
if|if
condition|(
name|__x
operator|==
name|__root
condition|)
name|__root
operator|=
name|__y
expr_stmt|;
elseif|else
if|if
condition|(
name|__x
operator|==
name|__x
operator|->
name|_M_parent
operator|->
name|_M_right
condition|)
name|__x
operator|->
name|_M_parent
operator|->
name|_M_right
operator|=
name|__y
expr_stmt|;
else|else
name|__x
operator|->
name|_M_parent
operator|->
name|_M_left
operator|=
name|__y
expr_stmt|;
name|__y
operator|->
name|_M_right
operator|=
name|__x
expr_stmt|;
name|__x
operator|->
name|_M_parent
operator|=
name|__y
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|_Rb_tree_rebalance
parameter_list|(
name|_Rb_tree_node_base
modifier|*
name|__x
parameter_list|,
name|_Rb_tree_node_base
modifier|*
modifier|&
name|__root
parameter_list|)
block|{
name|__x
operator|->
name|_M_color
operator|=
name|_S_rb_tree_red
expr_stmt|;
while|while
condition|(
name|__x
operator|!=
name|__root
operator|&&
name|__x
operator|->
name|_M_parent
operator|->
name|_M_color
operator|==
name|_S_rb_tree_red
condition|)
block|{
if|if
condition|(
name|__x
operator|->
name|_M_parent
operator|==
name|__x
operator|->
name|_M_parent
operator|->
name|_M_parent
operator|->
name|_M_left
condition|)
block|{
name|_Rb_tree_node_base
modifier|*
name|__y
init|=
name|__x
operator|->
name|_M_parent
operator|->
name|_M_parent
operator|->
name|_M_right
decl_stmt|;
if|if
condition|(
name|__y
operator|&&
name|__y
operator|->
name|_M_color
operator|==
name|_S_rb_tree_red
condition|)
block|{
name|__x
operator|->
name|_M_parent
operator|->
name|_M_color
operator|=
name|_S_rb_tree_black
expr_stmt|;
name|__y
operator|->
name|_M_color
operator|=
name|_S_rb_tree_black
expr_stmt|;
name|__x
operator|->
name|_M_parent
operator|->
name|_M_parent
operator|->
name|_M_color
operator|=
name|_S_rb_tree_red
expr_stmt|;
name|__x
operator|=
name|__x
operator|->
name|_M_parent
operator|->
name|_M_parent
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|__x
operator|==
name|__x
operator|->
name|_M_parent
operator|->
name|_M_right
condition|)
block|{
name|__x
operator|=
name|__x
operator|->
name|_M_parent
expr_stmt|;
name|_Rb_tree_rotate_left
argument_list|(
name|__x
argument_list|,
name|__root
argument_list|)
expr_stmt|;
block|}
name|__x
operator|->
name|_M_parent
operator|->
name|_M_color
operator|=
name|_S_rb_tree_black
expr_stmt|;
name|__x
operator|->
name|_M_parent
operator|->
name|_M_parent
operator|->
name|_M_color
operator|=
name|_S_rb_tree_red
expr_stmt|;
name|_Rb_tree_rotate_right
argument_list|(
name|__x
operator|->
name|_M_parent
operator|->
name|_M_parent
argument_list|,
name|__root
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|_Rb_tree_node_base
modifier|*
name|__y
init|=
name|__x
operator|->
name|_M_parent
operator|->
name|_M_parent
operator|->
name|_M_left
decl_stmt|;
if|if
condition|(
name|__y
operator|&&
name|__y
operator|->
name|_M_color
operator|==
name|_S_rb_tree_red
condition|)
block|{
name|__x
operator|->
name|_M_parent
operator|->
name|_M_color
operator|=
name|_S_rb_tree_black
expr_stmt|;
name|__y
operator|->
name|_M_color
operator|=
name|_S_rb_tree_black
expr_stmt|;
name|__x
operator|->
name|_M_parent
operator|->
name|_M_parent
operator|->
name|_M_color
operator|=
name|_S_rb_tree_red
expr_stmt|;
name|__x
operator|=
name|__x
operator|->
name|_M_parent
operator|->
name|_M_parent
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|__x
operator|==
name|__x
operator|->
name|_M_parent
operator|->
name|_M_left
condition|)
block|{
name|__x
operator|=
name|__x
operator|->
name|_M_parent
expr_stmt|;
name|_Rb_tree_rotate_right
argument_list|(
name|__x
argument_list|,
name|__root
argument_list|)
expr_stmt|;
block|}
name|__x
operator|->
name|_M_parent
operator|->
name|_M_color
operator|=
name|_S_rb_tree_black
expr_stmt|;
name|__x
operator|->
name|_M_parent
operator|->
name|_M_parent
operator|->
name|_M_color
operator|=
name|_S_rb_tree_red
expr_stmt|;
name|_Rb_tree_rotate_left
argument_list|(
name|__x
operator|->
name|_M_parent
operator|->
name|_M_parent
argument_list|,
name|__root
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|__root
operator|->
name|_M_color
operator|=
name|_S_rb_tree_black
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|_Rb_tree_node_base
modifier|*
name|_Rb_tree_rebalance_for_erase
parameter_list|(
name|_Rb_tree_node_base
modifier|*
name|__z
parameter_list|,
name|_Rb_tree_node_base
modifier|*
modifier|&
name|__root
parameter_list|,
name|_Rb_tree_node_base
modifier|*
modifier|&
name|__leftmost
parameter_list|,
name|_Rb_tree_node_base
modifier|*
modifier|&
name|__rightmost
parameter_list|)
block|{
name|_Rb_tree_node_base
modifier|*
name|__y
init|=
name|__z
decl_stmt|;
name|_Rb_tree_node_base
modifier|*
name|__x
init|=
literal|0
decl_stmt|;
name|_Rb_tree_node_base
modifier|*
name|__x_parent
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|__y
operator|->
name|_M_left
operator|==
literal|0
condition|)
comment|// __z has at most one non-null child. y == z.
name|__x
operator|=
name|__y
operator|->
name|_M_right
expr_stmt|;
comment|// __x might be null.
elseif|else
if|if
condition|(
name|__y
operator|->
name|_M_right
operator|==
literal|0
condition|)
comment|// __z has exactly one non-null child. y == z.
name|__x
operator|=
name|__y
operator|->
name|_M_left
expr_stmt|;
comment|// __x is not null.
else|else
block|{
comment|// __z has two non-null children.  Set __y to
name|__y
operator|=
name|__y
operator|->
name|_M_right
expr_stmt|;
comment|//   __z's successor.  __x might be null.
while|while
condition|(
name|__y
operator|->
name|_M_left
operator|!=
literal|0
condition|)
name|__y
operator|=
name|__y
operator|->
name|_M_left
expr_stmt|;
name|__x
operator|=
name|__y
operator|->
name|_M_right
expr_stmt|;
block|}
if|if
condition|(
name|__y
operator|!=
name|__z
condition|)
block|{
comment|// relink y in place of z.  y is z's successor
name|__z
operator|->
name|_M_left
operator|->
name|_M_parent
operator|=
name|__y
expr_stmt|;
name|__y
operator|->
name|_M_left
operator|=
name|__z
operator|->
name|_M_left
expr_stmt|;
if|if
condition|(
name|__y
operator|!=
name|__z
operator|->
name|_M_right
condition|)
block|{
name|__x_parent
operator|=
name|__y
operator|->
name|_M_parent
expr_stmt|;
if|if
condition|(
name|__x
condition|)
name|__x
operator|->
name|_M_parent
operator|=
name|__y
operator|->
name|_M_parent
expr_stmt|;
name|__y
operator|->
name|_M_parent
operator|->
name|_M_left
operator|=
name|__x
expr_stmt|;
comment|// __y must be a child of _M_left
name|__y
operator|->
name|_M_right
operator|=
name|__z
operator|->
name|_M_right
expr_stmt|;
name|__z
operator|->
name|_M_right
operator|->
name|_M_parent
operator|=
name|__y
expr_stmt|;
block|}
else|else
name|__x_parent
operator|=
name|__y
expr_stmt|;
if|if
condition|(
name|__root
operator|==
name|__z
condition|)
name|__root
operator|=
name|__y
expr_stmt|;
elseif|else
if|if
condition|(
name|__z
operator|->
name|_M_parent
operator|->
name|_M_left
operator|==
name|__z
condition|)
name|__z
operator|->
name|_M_parent
operator|->
name|_M_left
operator|=
name|__y
expr_stmt|;
else|else
name|__z
operator|->
name|_M_parent
operator|->
name|_M_right
operator|=
name|__y
expr_stmt|;
name|__y
operator|->
name|_M_parent
operator|=
name|__z
operator|->
name|_M_parent
expr_stmt|;
name|__STD
operator|::
name|swap
argument_list|(
name|__y
operator|->
name|_M_color
argument_list|,
name|__z
operator|->
name|_M_color
argument_list|)
expr_stmt|;
name|__y
operator|=
name|__z
expr_stmt|;
comment|// __y now points to node to be actually deleted
block|}
else|else
block|{
comment|// __y == __z
name|__x_parent
operator|=
name|__y
operator|->
name|_M_parent
expr_stmt|;
if|if
condition|(
name|__x
condition|)
name|__x
operator|->
name|_M_parent
operator|=
name|__y
operator|->
name|_M_parent
expr_stmt|;
if|if
condition|(
name|__root
operator|==
name|__z
condition|)
name|__root
operator|=
name|__x
expr_stmt|;
elseif|else
if|if
condition|(
name|__z
operator|->
name|_M_parent
operator|->
name|_M_left
operator|==
name|__z
condition|)
name|__z
operator|->
name|_M_parent
operator|->
name|_M_left
operator|=
name|__x
expr_stmt|;
else|else
name|__z
operator|->
name|_M_parent
operator|->
name|_M_right
operator|=
name|__x
expr_stmt|;
if|if
condition|(
name|__leftmost
operator|==
name|__z
condition|)
if|if
condition|(
name|__z
operator|->
name|_M_right
operator|==
literal|0
condition|)
comment|// __z->_M_left must be null also
name|__leftmost
operator|=
name|__z
operator|->
name|_M_parent
expr_stmt|;
comment|// makes __leftmost == _M_header if __z == __root
else|else
name|__leftmost
operator|=
name|_Rb_tree_node_base
operator|::
name|_S_minimum
argument_list|(
name|__x
argument_list|)
expr_stmt|;
if|if
condition|(
name|__rightmost
operator|==
name|__z
condition|)
if|if
condition|(
name|__z
operator|->
name|_M_left
operator|==
literal|0
condition|)
comment|// __z->_M_right must be null also
name|__rightmost
operator|=
name|__z
operator|->
name|_M_parent
expr_stmt|;
comment|// makes __rightmost == _M_header if __z == __root
else|else
comment|// __x == __z->_M_left
name|__rightmost
operator|=
name|_Rb_tree_node_base
operator|::
name|_S_maximum
argument_list|(
name|__x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|__y
operator|->
name|_M_color
operator|!=
name|_S_rb_tree_red
condition|)
block|{
while|while
condition|(
name|__x
operator|!=
name|__root
operator|&&
operator|(
name|__x
operator|==
literal|0
operator|||
name|__x
operator|->
name|_M_color
operator|==
name|_S_rb_tree_black
operator|)
condition|)
if|if
condition|(
name|__x
operator|==
name|__x_parent
operator|->
name|_M_left
condition|)
block|{
name|_Rb_tree_node_base
modifier|*
name|__w
init|=
name|__x_parent
operator|->
name|_M_right
decl_stmt|;
if|if
condition|(
name|__w
operator|->
name|_M_color
operator|==
name|_S_rb_tree_red
condition|)
block|{
name|__w
operator|->
name|_M_color
operator|=
name|_S_rb_tree_black
expr_stmt|;
name|__x_parent
operator|->
name|_M_color
operator|=
name|_S_rb_tree_red
expr_stmt|;
name|_Rb_tree_rotate_left
argument_list|(
name|__x_parent
argument_list|,
name|__root
argument_list|)
expr_stmt|;
name|__w
operator|=
name|__x_parent
operator|->
name|_M_right
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|__w
operator|->
name|_M_left
operator|==
literal|0
operator|||
name|__w
operator|->
name|_M_left
operator|->
name|_M_color
operator|==
name|_S_rb_tree_black
operator|)
operator|&&
operator|(
name|__w
operator|->
name|_M_right
operator|==
literal|0
operator|||
name|__w
operator|->
name|_M_right
operator|->
name|_M_color
operator|==
name|_S_rb_tree_black
operator|)
condition|)
block|{
name|__w
operator|->
name|_M_color
operator|=
name|_S_rb_tree_red
expr_stmt|;
name|__x
operator|=
name|__x_parent
expr_stmt|;
name|__x_parent
operator|=
name|__x_parent
operator|->
name|_M_parent
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|__w
operator|->
name|_M_right
operator|==
literal|0
operator|||
name|__w
operator|->
name|_M_right
operator|->
name|_M_color
operator|==
name|_S_rb_tree_black
condition|)
block|{
if|if
condition|(
name|__w
operator|->
name|_M_left
condition|)
name|__w
operator|->
name|_M_left
operator|->
name|_M_color
operator|=
name|_S_rb_tree_black
expr_stmt|;
name|__w
operator|->
name|_M_color
operator|=
name|_S_rb_tree_red
expr_stmt|;
name|_Rb_tree_rotate_right
argument_list|(
name|__w
argument_list|,
name|__root
argument_list|)
expr_stmt|;
name|__w
operator|=
name|__x_parent
operator|->
name|_M_right
expr_stmt|;
block|}
name|__w
operator|->
name|_M_color
operator|=
name|__x_parent
operator|->
name|_M_color
expr_stmt|;
name|__x_parent
operator|->
name|_M_color
operator|=
name|_S_rb_tree_black
expr_stmt|;
if|if
condition|(
name|__w
operator|->
name|_M_right
condition|)
name|__w
operator|->
name|_M_right
operator|->
name|_M_color
operator|=
name|_S_rb_tree_black
expr_stmt|;
name|_Rb_tree_rotate_left
argument_list|(
name|__x_parent
argument_list|,
name|__root
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|// same as above, with _M_right<-> _M_left.
name|_Rb_tree_node_base
modifier|*
name|__w
init|=
name|__x_parent
operator|->
name|_M_left
decl_stmt|;
if|if
condition|(
name|__w
operator|->
name|_M_color
operator|==
name|_S_rb_tree_red
condition|)
block|{
name|__w
operator|->
name|_M_color
operator|=
name|_S_rb_tree_black
expr_stmt|;
name|__x_parent
operator|->
name|_M_color
operator|=
name|_S_rb_tree_red
expr_stmt|;
name|_Rb_tree_rotate_right
argument_list|(
name|__x_parent
argument_list|,
name|__root
argument_list|)
expr_stmt|;
name|__w
operator|=
name|__x_parent
operator|->
name|_M_left
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|__w
operator|->
name|_M_right
operator|==
literal|0
operator|||
name|__w
operator|->
name|_M_right
operator|->
name|_M_color
operator|==
name|_S_rb_tree_black
operator|)
operator|&&
operator|(
name|__w
operator|->
name|_M_left
operator|==
literal|0
operator|||
name|__w
operator|->
name|_M_left
operator|->
name|_M_color
operator|==
name|_S_rb_tree_black
operator|)
condition|)
block|{
name|__w
operator|->
name|_M_color
operator|=
name|_S_rb_tree_red
expr_stmt|;
name|__x
operator|=
name|__x_parent
expr_stmt|;
name|__x_parent
operator|=
name|__x_parent
operator|->
name|_M_parent
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|__w
operator|->
name|_M_left
operator|==
literal|0
operator|||
name|__w
operator|->
name|_M_left
operator|->
name|_M_color
operator|==
name|_S_rb_tree_black
condition|)
block|{
if|if
condition|(
name|__w
operator|->
name|_M_right
condition|)
name|__w
operator|->
name|_M_right
operator|->
name|_M_color
operator|=
name|_S_rb_tree_black
expr_stmt|;
name|__w
operator|->
name|_M_color
operator|=
name|_S_rb_tree_red
expr_stmt|;
name|_Rb_tree_rotate_left
argument_list|(
name|__w
argument_list|,
name|__root
argument_list|)
expr_stmt|;
name|__w
operator|=
name|__x_parent
operator|->
name|_M_left
expr_stmt|;
block|}
name|__w
operator|->
name|_M_color
operator|=
name|__x_parent
operator|->
name|_M_color
expr_stmt|;
name|__x_parent
operator|->
name|_M_color
operator|=
name|_S_rb_tree_black
expr_stmt|;
if|if
condition|(
name|__w
operator|->
name|_M_left
condition|)
name|__w
operator|->
name|_M_left
operator|->
name|_M_color
operator|=
name|_S_rb_tree_black
expr_stmt|;
name|_Rb_tree_rotate_right
argument_list|(
name|__x_parent
argument_list|,
name|__root
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|__x
condition|)
name|__x
operator|->
name|_M_color
operator|=
name|_S_rb_tree_black
expr_stmt|;
block|}
return|return
name|__y
return|;
block|}
end_function

begin_comment
comment|// Base class to encapsulate the differences between old SGI-style
end_comment

begin_comment
comment|// allocators and standard-conforming allocators.  In order to avoid
end_comment

begin_comment
comment|// having an empty base class, we arbitrarily move one of rb_tree's
end_comment

begin_comment
comment|// data members into the base class.
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STL_USE_STD_ALLOCATORS
end_ifdef

begin_comment
comment|// _Base for general standard-conforming allocators.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|,
name|class
name|_Alloc
operator|,
name|bool
name|_S_instanceless
operator|>
name|class
name|_Rb_tree_alloc_base
block|{
name|public
operator|:
typedef|typedef
name|typename
name|_Alloc_traits
operator|<
name|_Tp
operator|,
name|_Alloc
operator|>
operator|::
name|allocator_type
name|allocator_type
expr_stmt|;
name|allocator_type
name|get_allocator
argument_list|()
specifier|const
block|{
return|return
name|_M_node_allocator
return|;
block|}
name|_Rb_tree_alloc_base
argument_list|(
specifier|const
name|allocator_type
operator|&
name|__a
argument_list|)
operator|:
name|_M_node_allocator
argument_list|(
name|__a
argument_list|)
operator|,
name|_M_header
argument_list|(
literal|0
argument_list|)
block|{}
name|protected
operator|:
name|typename
name|_Alloc_traits
operator|<
name|_Rb_tree_node
operator|<
name|_Tp
operator|>
operator|,
name|_Alloc
operator|>
operator|::
name|allocator_type
name|_M_node_allocator
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_Rb_tree_node
operator|<
name|_Tp
operator|>
operator|*
name|_M_header
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_Rb_tree_node
operator|<
name|_Tp
operator|>
operator|*
name|_M_get_node
argument_list|()
block|{
return|return
name|_M_node_allocator
operator|.
name|allocate
argument_list|(
literal|1
argument_list|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|void
name|_M_put_node
argument_list|(
name|_Rb_tree_node
operator|<
name|_Tp
operator|>
operator|*
name|__p
argument_list|)
block|{
name|_M_node_allocator
operator|.
name|deallocate
argument_list|(
name|__p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
unit|};
comment|// Specialization for instanceless allocators.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|,
name|class
name|_Alloc
operator|>
name|class
name|_Rb_tree_alloc_base
operator|<
name|_Tp
operator|,
name|_Alloc
operator|,
name|true
operator|>
block|{
name|public
operator|:
typedef|typedef
name|typename
name|_Alloc_traits
operator|<
name|_Tp
operator|,
name|_Alloc
operator|>
operator|::
name|allocator_type
name|allocator_type
expr_stmt|;
name|allocator_type
name|get_allocator
argument_list|()
specifier|const
block|{
return|return
name|allocator_type
argument_list|()
return|;
block|}
name|_Rb_tree_alloc_base
argument_list|(
specifier|const
name|allocator_type
operator|&
argument_list|)
operator|:
name|_M_header
argument_list|(
literal|0
argument_list|)
block|{}
name|protected
operator|:
name|_Rb_tree_node
operator|<
name|_Tp
operator|>
operator|*
name|_M_header
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|_Alloc_traits
operator|<
name|_Rb_tree_node
operator|<
name|_Tp
operator|>
operator|,
name|_Alloc
operator|>
operator|::
name|_Alloc_type
name|_Alloc_type
expr_stmt|;
end_typedef

begin_expr_stmt
name|_Rb_tree_node
operator|<
name|_Tp
operator|>
operator|*
name|_M_get_node
argument_list|()
block|{
return|return
name|_Alloc_type
operator|::
name|allocate
argument_list|(
literal|1
argument_list|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|void
name|_M_put_node
argument_list|(
name|_Rb_tree_node
operator|<
name|_Tp
operator|>
operator|*
name|__p
argument_list|)
block|{
name|_Alloc_type
operator|::
name|deallocate
argument_list|(
name|__p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Tp
operator|,
name|class
name|_Alloc
operator|>
expr|struct
name|_Rb_tree_base
operator|:
name|public
name|_Rb_tree_alloc_base
operator|<
name|_Tp
operator|,
name|_Alloc
operator|,
name|_Alloc_traits
operator|<
name|_Tp
operator|,
name|_Alloc
operator|>
operator|::
name|_S_instanceless
operator|>
block|{
typedef|typedef
name|_Rb_tree_alloc_base
operator|<
name|_Tp
operator|,
name|_Alloc
operator|,
name|_Alloc_traits
operator|<
name|_Tp
operator|,
name|_Alloc
operator|>
operator|::
name|_S_instanceless
operator|>
name|_Base
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|_Base
operator|::
name|allocator_type
name|allocator_type
expr_stmt|;
end_typedef

begin_expr_stmt
name|_Rb_tree_base
argument_list|(
specifier|const
name|allocator_type
operator|&
name|__a
argument_list|)
operator|:
name|_Base
argument_list|(
argument|__a
argument_list|)
block|{
name|_M_header
operator|=
name|_M_get_node
argument_list|()
block|; }
operator|~
name|_Rb_tree_base
argument_list|()
block|{
name|_M_put_node
argument_list|(
name|_M_header
argument_list|)
block|; }
end_expr_stmt

begin_else
unit|};
else|#
directive|else
end_else

begin_comment
comment|/* __STL_USE_STD_ALLOCATORS */
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|,
name|class
name|_Alloc
operator|>
expr|struct
name|_Rb_tree_base
block|{
typedef|typedef
name|_Alloc
name|allocator_type
typedef|;
name|allocator_type
name|get_allocator
argument_list|()
specifier|const
block|{
return|return
name|allocator_type
argument_list|()
return|;
block|}
name|_Rb_tree_base
argument_list|(
specifier|const
name|allocator_type
operator|&
argument_list|)
operator|:
name|_M_header
argument_list|(
literal|0
argument_list|)
block|{
name|_M_header
operator|=
name|_M_get_node
argument_list|()
block|; }
operator|~
name|_Rb_tree_base
argument_list|()
block|{
name|_M_put_node
argument_list|(
name|_M_header
argument_list|)
block|; }
name|protected
operator|:
name|_Rb_tree_node
operator|<
name|_Tp
operator|>
operator|*
name|_M_header
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|simple_alloc
operator|<
name|_Rb_tree_node
operator|<
name|_Tp
operator|>
operator|,
name|_Alloc
operator|>
name|_Alloc_type
expr_stmt|;
end_typedef

begin_expr_stmt
name|_Rb_tree_node
operator|<
name|_Tp
operator|>
operator|*
name|_M_get_node
argument_list|()
block|{
return|return
name|_Alloc_type
operator|::
name|allocate
argument_list|(
literal|1
argument_list|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|void
name|_M_put_node
argument_list|(
name|_Rb_tree_node
operator|<
name|_Tp
operator|>
operator|*
name|__p
argument_list|)
block|{
name|_Alloc_type
operator|::
name|deallocate
argument_list|(
name|__p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_endif
unit|};
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STL_USE_STD_ALLOCATORS */
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Value
operator|,
name|class
name|_KeyOfValue
operator|,
name|class
name|_Compare
operator|,
name|class
name|_Alloc
operator|=
name|__STL_DEFAULT_ALLOCATOR
argument_list|(
name|_Value
argument_list|)
operator|>
name|class
name|_Rb_tree
operator|:
name|protected
name|_Rb_tree_base
operator|<
name|_Value
operator|,
name|_Alloc
operator|>
block|{
typedef|typedef
name|_Rb_tree_base
operator|<
name|_Value
operator|,
name|_Alloc
operator|>
name|_Base
expr_stmt|;
name|protected
operator|:
end_expr_stmt

begin_typedef
typedef|typedef
name|_Rb_tree_node_base
modifier|*
name|_Base_ptr
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|_Rb_tree_node
operator|<
name|_Value
operator|>
name|_Rb_tree_node
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|_Rb_tree_Color_type
name|_Color_type
typedef|;
end_typedef

begin_label
name|public
label|:
end_label

begin_typedef
typedef|typedef
name|_Key
name|key_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|_Value
name|value_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|value_type
modifier|*
name|pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|value_type
modifier|*
name|const_pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|value_type
modifier|&
name|reference
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|value_type
modifier|&
name|const_reference
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|_Rb_tree_node
modifier|*
name|_Link_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|size_t
name|size_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|ptrdiff_t
name|difference_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|_Base
operator|::
name|allocator_type
name|allocator_type
expr_stmt|;
end_typedef

begin_expr_stmt
name|allocator_type
name|get_allocator
argument_list|()
specifier|const
block|{
return|return
name|_Base
operator|::
name|get_allocator
argument_list|()
return|;
block|}
end_expr_stmt

begin_label
name|protected
label|:
end_label

begin_ifdef
ifdef|#
directive|ifdef
name|__STL_USE_NAMESPACES
end_ifdef

begin_expr_stmt
name|using
name|_Base
operator|::
name|_M_get_node
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|using
name|_Base
operator|::
name|_M_put_node
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|using
name|_Base
operator|::
name|_M_header
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STL_USE_NAMESPACES */
end_comment

begin_label
name|protected
label|:
end_label

begin_function
name|_Link_type
name|_M_create_node
parameter_list|(
specifier|const
name|value_type
modifier|&
name|__x
parameter_list|)
block|{
name|_Link_type
name|__tmp
init|=
name|_M_get_node
argument_list|()
decl_stmt|;
name|__STL_TRY
block|{
name|construct
argument_list|(
operator|&
name|__tmp
operator|->
name|_M_value_field
argument_list|,
name|__x
argument_list|)
expr_stmt|;
block|}
name|__STL_UNWIND
argument_list|(
name|_M_put_node
argument_list|(
name|__tmp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|__tmp
return|;
block|}
end_function

begin_function
name|_Link_type
name|_M_clone_node
parameter_list|(
name|_Link_type
name|__x
parameter_list|)
block|{
name|_Link_type
name|__tmp
init|=
name|_M_create_node
argument_list|(
name|__x
operator|->
name|_M_value_field
argument_list|)
decl_stmt|;
name|__tmp
operator|->
name|_M_color
operator|=
name|__x
operator|->
name|_M_color
expr_stmt|;
name|__tmp
operator|->
name|_M_left
operator|=
literal|0
expr_stmt|;
name|__tmp
operator|->
name|_M_right
operator|=
literal|0
expr_stmt|;
return|return
name|__tmp
return|;
block|}
end_function

begin_function
name|void
name|destroy_node
parameter_list|(
name|_Link_type
name|__p
parameter_list|)
block|{
name|destroy
argument_list|(
operator|&
name|__p
operator|->
name|_M_value_field
argument_list|)
expr_stmt|;
name|_M_put_node
argument_list|(
name|__p
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|protected
label|:
end_label

begin_decl_stmt
name|size_type
name|_M_node_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|// keeps track of size of tree
end_comment

begin_decl_stmt
name|_Compare
name|_M_key_compare
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|_Link_type
operator|&
name|_M_root
argument_list|()
specifier|const
block|{
return|return
operator|(
name|_Link_type
operator|&
operator|)
name|_M_header
operator|->
name|_M_parent
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|_Link_type
operator|&
name|_M_leftmost
argument_list|()
specifier|const
block|{
return|return
operator|(
name|_Link_type
operator|&
operator|)
name|_M_header
operator|->
name|_M_left
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|_Link_type
operator|&
name|_M_rightmost
argument_list|()
specifier|const
block|{
return|return
operator|(
name|_Link_type
operator|&
operator|)
name|_M_header
operator|->
name|_M_right
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|_Link_type
modifier|&
name|_S_left
parameter_list|(
name|_Link_type
name|__x
parameter_list|)
block|{
return|return
operator|(
name|_Link_type
operator|&
operator|)
operator|(
name|__x
operator|->
name|_M_left
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|_Link_type
modifier|&
name|_S_right
parameter_list|(
name|_Link_type
name|__x
parameter_list|)
block|{
return|return
operator|(
name|_Link_type
operator|&
operator|)
operator|(
name|__x
operator|->
name|_M_right
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|_Link_type
modifier|&
name|_S_parent
parameter_list|(
name|_Link_type
name|__x
parameter_list|)
block|{
return|return
operator|(
name|_Link_type
operator|&
operator|)
operator|(
name|__x
operator|->
name|_M_parent
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|reference
name|_S_value
parameter_list|(
name|_Link_type
name|__x
parameter_list|)
block|{
return|return
name|__x
operator|->
name|_M_value_field
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|_Key
modifier|&
name|_S_key
parameter_list|(
name|_Link_type
name|__x
parameter_list|)
block|{
return|return
name|_KeyOfValue
argument_list|()
argument_list|(
name|_S_value
argument_list|(
name|__x
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|_Color_type
modifier|&
name|_S_color
parameter_list|(
name|_Link_type
name|__x
parameter_list|)
block|{
return|return
operator|(
name|_Color_type
operator|&
operator|)
operator|(
name|__x
operator|->
name|_M_color
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|_Link_type
modifier|&
name|_S_left
parameter_list|(
name|_Base_ptr
name|__x
parameter_list|)
block|{
return|return
operator|(
name|_Link_type
operator|&
operator|)
operator|(
name|__x
operator|->
name|_M_left
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|_Link_type
modifier|&
name|_S_right
parameter_list|(
name|_Base_ptr
name|__x
parameter_list|)
block|{
return|return
operator|(
name|_Link_type
operator|&
operator|)
operator|(
name|__x
operator|->
name|_M_right
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|_Link_type
modifier|&
name|_S_parent
parameter_list|(
name|_Base_ptr
name|__x
parameter_list|)
block|{
return|return
operator|(
name|_Link_type
operator|&
operator|)
operator|(
name|__x
operator|->
name|_M_parent
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|reference
name|_S_value
parameter_list|(
name|_Base_ptr
name|__x
parameter_list|)
block|{
return|return
operator|(
operator|(
name|_Link_type
operator|)
name|__x
operator|)
operator|->
name|_M_value_field
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|_Key
modifier|&
name|_S_key
parameter_list|(
name|_Base_ptr
name|__x
parameter_list|)
block|{
return|return
name|_KeyOfValue
argument_list|()
argument_list|(
name|_S_value
argument_list|(
name|_Link_type
argument_list|(
name|__x
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|_Color_type
modifier|&
name|_S_color
parameter_list|(
name|_Base_ptr
name|__x
parameter_list|)
block|{
return|return
operator|(
name|_Color_type
operator|&
operator|)
operator|(
name|_Link_type
argument_list|(
name|__x
argument_list|)
operator|->
name|_M_color
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|_Link_type
name|_S_minimum
parameter_list|(
name|_Link_type
name|__x
parameter_list|)
block|{
return|return
operator|(
name|_Link_type
operator|)
name|_Rb_tree_node_base
operator|::
name|_S_minimum
argument_list|(
name|__x
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|_Link_type
name|_S_maximum
parameter_list|(
name|_Link_type
name|__x
parameter_list|)
block|{
return|return
operator|(
name|_Link_type
operator|)
name|_Rb_tree_node_base
operator|::
name|_S_maximum
argument_list|(
name|__x
argument_list|)
return|;
block|}
end_function

begin_label
name|public
label|:
end_label

begin_typedef
typedef|typedef
name|_Rb_tree_iterator
operator|<
name|value_type
operator|,
name|reference
operator|,
name|pointer
operator|>
name|iterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|_Rb_tree_iterator
operator|<
name|value_type
operator|,
name|const_reference
operator|,
name|const_pointer
operator|>
name|const_iterator
expr_stmt|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|__STL_CLASS_PARTIAL_SPECIALIZATION
end_ifdef

begin_typedef
typedef|typedef
name|reverse_iterator
operator|<
name|const_iterator
operator|>
name|const_reverse_iterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|reverse_iterator
operator|<
name|iterator
operator|>
name|reverse_iterator
expr_stmt|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __STL_CLASS_PARTIAL_SPECIALIZATION */
end_comment

begin_typedef
typedef|typedef
name|reverse_bidirectional_iterator
operator|<
name|iterator
operator|,
name|value_type
operator|,
name|reference
operator|,
name|difference_type
operator|>
name|reverse_iterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|reverse_bidirectional_iterator
operator|<
name|const_iterator
operator|,
name|value_type
operator|,
name|const_reference
operator|,
name|difference_type
operator|>
name|const_reverse_iterator
expr_stmt|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STL_CLASS_PARTIAL_SPECIALIZATION */
end_comment

begin_label
name|private
label|:
end_label

begin_function_decl
name|iterator
name|_M_insert
parameter_list|(
name|_Base_ptr
name|__x
parameter_list|,
name|_Base_ptr
name|__y
parameter_list|,
specifier|const
name|value_type
modifier|&
name|__v
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|_Link_type
name|_M_copy
parameter_list|(
name|_Link_type
name|__x
parameter_list|,
name|_Link_type
name|__p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|_M_erase
parameter_list|(
name|_Link_type
name|__x
parameter_list|)
function_decl|;
end_function_decl

begin_label
name|public
label|:
end_label

begin_comment
comment|// allocation/deallocation
end_comment

begin_expr_stmt
name|_Rb_tree
argument_list|()
operator|:
name|_Base
argument_list|(
name|allocator_type
argument_list|()
argument_list|)
operator|,
name|_M_node_count
argument_list|(
literal|0
argument_list|)
operator|,
name|_M_key_compare
argument_list|()
block|{
name|_M_empty_initialize
argument_list|()
block|; }
name|_Rb_tree
argument_list|(
specifier|const
name|_Compare
operator|&
name|__comp
argument_list|)
operator|:
name|_Base
argument_list|(
name|allocator_type
argument_list|()
argument_list|)
operator|,
name|_M_node_count
argument_list|(
literal|0
argument_list|)
operator|,
name|_M_key_compare
argument_list|(
argument|__comp
argument_list|)
block|{
name|_M_empty_initialize
argument_list|()
block|; }
name|_Rb_tree
argument_list|(
specifier|const
name|_Compare
operator|&
name|__comp
argument_list|,
specifier|const
name|allocator_type
operator|&
name|__a
argument_list|)
operator|:
name|_Base
argument_list|(
name|__a
argument_list|)
operator|,
name|_M_node_count
argument_list|(
literal|0
argument_list|)
operator|,
name|_M_key_compare
argument_list|(
argument|__comp
argument_list|)
block|{
name|_M_empty_initialize
argument_list|()
block|; }
name|_Rb_tree
argument_list|(
specifier|const
name|_Rb_tree
operator|<
name|_Key
argument_list|,
name|_Value
argument_list|,
name|_KeyOfValue
argument_list|,
name|_Compare
argument_list|,
name|_Alloc
operator|>
operator|&
name|__x
argument_list|)
operator|:
name|_Base
argument_list|(
name|__x
operator|.
name|get_allocator
argument_list|()
argument_list|)
operator|,
name|_M_node_count
argument_list|(
literal|0
argument_list|)
operator|,
name|_M_key_compare
argument_list|(
argument|__x._M_key_compare
argument_list|)
block|{
if|if
condition|(
name|__x
operator|.
name|_M_root
argument_list|()
operator|==
literal|0
condition|)
name|_M_empty_initialize
argument_list|()
expr_stmt|;
else|else
block|{
name|_S_color
argument_list|(
name|_M_header
argument_list|)
operator|=
name|_S_rb_tree_red
expr_stmt|;
name|_M_root
argument_list|()
operator|=
name|_M_copy
argument_list|(
name|__x
operator|.
name|_M_root
argument_list|()
argument_list|,
name|_M_header
argument_list|)
expr_stmt|;
name|_M_leftmost
argument_list|()
operator|=
name|_S_minimum
argument_list|(
name|_M_root
argument_list|()
argument_list|)
expr_stmt|;
name|_M_rightmost
argument_list|()
operator|=
name|_S_maximum
argument_list|(
name|_M_root
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|_M_node_count
operator|=
name|__x
operator|.
name|_M_node_count
expr_stmt|;
end_expr_stmt

begin_macro
unit|}   ~
name|_Rb_tree
argument_list|()
end_macro

begin_block
block|{
name|clear
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|&
name|operator
operator|=
operator|(
specifier|const
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|&
name|__x
operator|)
expr_stmt|;
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_function
name|void
name|_M_empty_initialize
parameter_list|()
block|{
name|_S_color
argument_list|(
name|_M_header
argument_list|)
operator|=
name|_S_rb_tree_red
expr_stmt|;
comment|// used to distinguish header from
comment|// __root, in iterator.operator++
name|_M_root
argument_list|()
operator|=
literal|0
expr_stmt|;
name|_M_leftmost
argument_list|()
operator|=
name|_M_header
expr_stmt|;
name|_M_rightmost
argument_list|()
operator|=
name|_M_header
expr_stmt|;
block|}
end_function

begin_label
name|public
label|:
end_label

begin_comment
comment|// accessors:
end_comment

begin_expr_stmt
name|_Compare
name|key_comp
argument_list|()
specifier|const
block|{
return|return
name|_M_key_compare
return|;
block|}
end_expr_stmt

begin_function
name|iterator
name|begin
parameter_list|()
block|{
return|return
name|_M_leftmost
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|_M_leftmost
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|iterator
name|end
parameter_list|()
block|{
return|return
name|_M_header
return|;
block|}
end_function

begin_expr_stmt
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|_M_header
return|;
block|}
end_expr_stmt

begin_function
name|reverse_iterator
name|rbegin
parameter_list|()
block|{
return|return
name|reverse_iterator
argument_list|(
name|end
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|const_reverse_iterator
name|rbegin
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|end
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|reverse_iterator
name|rend
parameter_list|()
block|{
return|return
name|reverse_iterator
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|const_reverse_iterator
name|rend
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|_M_node_count
operator|==
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|size_type
name|size
argument_list|()
specifier|const
block|{
return|return
name|_M_node_count
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|size_type
name|max_size
argument_list|()
specifier|const
block|{
return|return
name|size_type
argument_list|(
operator|-
literal|1
argument_list|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|void
name|swap
argument_list|(
name|_Rb_tree
operator|<
name|_Key
argument_list|,
name|_Value
argument_list|,
name|_KeyOfValue
argument_list|,
name|_Compare
argument_list|,
name|_Alloc
operator|>
operator|&
name|__t
argument_list|)
block|{
name|__STD
operator|::
name|swap
argument_list|(
name|_M_header
argument_list|,
name|__t
operator|.
name|_M_header
argument_list|)
expr_stmt|;
name|__STD
operator|::
name|swap
argument_list|(
name|_M_node_count
argument_list|,
name|__t
operator|.
name|_M_node_count
argument_list|)
expr_stmt|;
name|__STD
operator|::
name|swap
argument_list|(
name|_M_key_compare
argument_list|,
name|__t
operator|.
name|_M_key_compare
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_comment
comment|// insert/erase
end_comment

begin_expr_stmt
name|pair
operator|<
name|iterator
operator|,
name|bool
operator|>
name|insert_unique
argument_list|(
specifier|const
name|value_type
operator|&
name|__x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
name|iterator
name|insert_equal
parameter_list|(
specifier|const
name|value_type
modifier|&
name|__x
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|iterator
name|insert_unique
parameter_list|(
name|iterator
name|__position
parameter_list|,
specifier|const
name|value_type
modifier|&
name|__x
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|iterator
name|insert_equal
parameter_list|(
name|iterator
name|__position
parameter_list|,
specifier|const
name|value_type
modifier|&
name|__x
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|__STL_MEMBER_TEMPLATES
end_ifdef

begin_expr_stmt
name|template
operator|<
name|class
name|_InputIterator
operator|>
name|void
name|insert_unique
argument_list|(
argument|_InputIterator __first
argument_list|,
argument|_InputIterator __last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_InputIterator
operator|>
name|void
name|insert_equal
argument_list|(
argument|_InputIterator __first
argument_list|,
argument|_InputIterator __last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __STL_MEMBER_TEMPLATES */
end_comment

begin_function_decl
name|void
name|insert_unique
parameter_list|(
name|const_iterator
name|__first
parameter_list|,
name|const_iterator
name|__last
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|insert_unique
parameter_list|(
specifier|const
name|value_type
modifier|*
name|__first
parameter_list|,
specifier|const
name|value_type
modifier|*
name|__last
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|insert_equal
parameter_list|(
name|const_iterator
name|__first
parameter_list|,
name|const_iterator
name|__last
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|insert_equal
parameter_list|(
specifier|const
name|value_type
modifier|*
name|__first
parameter_list|,
specifier|const
name|value_type
modifier|*
name|__last
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STL_MEMBER_TEMPLATES */
end_comment

begin_function_decl
name|void
name|erase
parameter_list|(
name|iterator
name|__position
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_type
name|erase
parameter_list|(
specifier|const
name|key_type
modifier|&
name|__x
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|erase
parameter_list|(
name|iterator
name|__first
parameter_list|,
name|iterator
name|__last
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|erase
parameter_list|(
specifier|const
name|key_type
modifier|*
name|__first
parameter_list|,
specifier|const
name|key_type
modifier|*
name|__last
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|clear
parameter_list|()
block|{
if|if
condition|(
name|_M_node_count
operator|!=
literal|0
condition|)
block|{
name|_M_erase
argument_list|(
name|_M_root
argument_list|()
argument_list|)
expr_stmt|;
name|_M_leftmost
argument_list|()
operator|=
name|_M_header
expr_stmt|;
name|_M_root
argument_list|()
operator|=
literal|0
expr_stmt|;
name|_M_rightmost
argument_list|()
operator|=
name|_M_header
expr_stmt|;
name|_M_node_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_label
name|public
label|:
end_label

begin_comment
comment|// set operations:
end_comment

begin_function_decl
name|iterator
name|find
parameter_list|(
specifier|const
name|key_type
modifier|&
name|__x
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|const_iterator
name|find
argument_list|(
specifier|const
name|key_type
operator|&
name|__x
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_type
name|count
argument_list|(
specifier|const
name|key_type
operator|&
name|__x
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_function_decl
name|iterator
name|lower_bound
parameter_list|(
specifier|const
name|key_type
modifier|&
name|__x
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|const_iterator
name|lower_bound
argument_list|(
specifier|const
name|key_type
operator|&
name|__x
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_function_decl
name|iterator
name|upper_bound
parameter_list|(
specifier|const
name|key_type
modifier|&
name|__x
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|const_iterator
name|upper_bound
argument_list|(
specifier|const
name|key_type
operator|&
name|__x
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|pair
operator|<
name|iterator
operator|,
name|iterator
operator|>
name|equal_range
argument_list|(
specifier|const
name|key_type
operator|&
name|__x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pair
operator|<
name|const_iterator
operator|,
name|const_iterator
operator|>
name|equal_range
argument_list|(
argument|const key_type& __x
argument_list|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_comment
comment|// Debugging.
end_comment

begin_expr_stmt
name|bool
name|__rb_verify
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Value
operator|,
name|class
name|_KeyOfValue
operator|,
name|class
name|_Compare
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|&
name|__x
operator|,
specifier|const
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|&
name|__y
operator|)
block|{
return|return
name|__x
operator|.
name|size
argument_list|()
operator|==
name|__y
operator|.
name|size
argument_list|()
operator|&&
name|equal
argument_list|(
name|__x
operator|.
name|begin
argument_list|()
argument_list|,
name|__x
operator|.
name|end
argument_list|()
argument_list|,
name|__y
operator|.
name|begin
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Value
operator|,
name|class
name|_KeyOfValue
operator|,
name|class
name|_Compare
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|&
name|__x
operator|,
specifier|const
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|&
name|__y
operator|)
block|{
return|return
name|lexicographical_compare
argument_list|(
name|__x
operator|.
name|begin
argument_list|()
argument_list|,
name|__x
operator|.
name|end
argument_list|()
argument_list|,
name|__y
operator|.
name|begin
argument_list|()
argument_list|,
name|__y
operator|.
name|end
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__STL_FUNCTION_TMPL_PARTIAL_ORDER
end_ifdef

begin_expr_stmt
name|template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Value
operator|,
name|class
name|_KeyOfValue
operator|,
name|class
name|_Compare
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|void
name|swap
argument_list|(
argument|_Rb_tree<_Key
argument_list|,
argument|_Value
argument_list|,
argument|_KeyOfValue
argument_list|,
argument|_Compare
argument_list|,
argument|_Alloc>& __x
argument_list|,
argument|_Rb_tree<_Key
argument_list|,
argument|_Value
argument_list|,
argument|_KeyOfValue
argument_list|,
argument|_Compare
argument_list|,
argument|_Alloc>& __y
argument_list|)
block|{
name|__x
operator|.
name|swap
argument_list|(
name|__y
argument_list|)
block|; }
endif|#
directive|endif
comment|/* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
name|template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Value
operator|,
name|class
name|_KeyOfValue
operator|,
name|class
name|_Compare
operator|,
name|class
name|_Alloc
operator|>
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|&
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|operator
operator|=
operator|(
specifier|const
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|&
name|__x
operator|)
block|{
if|if
condition|(
name|this
operator|!=
operator|&
name|__x
condition|)
block|{
comment|// Note that _Key may be a constant type.
name|clear
argument_list|()
expr_stmt|;
name|_M_node_count
operator|=
literal|0
expr_stmt|;
name|_M_key_compare
operator|=
name|__x
operator|.
name|_M_key_compare
expr_stmt|;
if|if
condition|(
name|__x
operator|.
name|_M_root
argument_list|()
operator|==
literal|0
condition|)
block|{
name|_M_root
argument_list|()
operator|=
literal|0
expr_stmt|;
name|_M_leftmost
argument_list|()
operator|=
name|_M_header
expr_stmt|;
name|_M_rightmost
argument_list|()
operator|=
name|_M_header
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|_M_root
argument_list|()
operator|=
name|_M_copy
argument_list|(
name|__x
operator|.
name|_M_root
argument_list|()
argument_list|,
name|_M_header
argument_list|)
expr_stmt|;
name|_M_leftmost
argument_list|()
operator|=
name|_S_minimum
argument_list|(
name|_M_root
argument_list|()
argument_list|)
expr_stmt|;
name|_M_rightmost
argument_list|()
operator|=
name|_S_maximum
argument_list|(
name|_M_root
argument_list|()
argument_list|)
expr_stmt|;
name|_M_node_count
operator|=
name|__x
operator|.
name|_M_node_count
expr_stmt|;
block|}
end_else

begin_expr_stmt
unit|}   return
operator|*
name|this
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Value
operator|,
name|class
name|_KeyOfValue
operator|,
name|class
name|_Compare
operator|,
name|class
name|_Alloc
operator|>
name|typename
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|iterator
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|_M_insert
argument_list|(
argument|_Base_ptr __x_
argument_list|,
argument|_Base_ptr __y_
argument_list|,
argument|const _Value& __v
argument_list|)
block|{
name|_Link_type
name|__x
operator|=
operator|(
name|_Link_type
operator|)
name|__x_
block|;
name|_Link_type
name|__y
operator|=
operator|(
name|_Link_type
operator|)
name|__y_
block|;
name|_Link_type
name|__z
block|;
if|if
condition|(
name|__y
operator|==
name|_M_header
operator|||
name|__x
operator|!=
literal|0
operator|||
name|_M_key_compare
argument_list|(
name|_KeyOfValue
argument_list|()
argument_list|(
name|__v
argument_list|)
argument_list|,
name|_S_key
argument_list|(
name|__y
argument_list|)
argument_list|)
condition|)
block|{
name|__z
operator|=
name|_M_create_node
argument_list|(
name|__v
argument_list|)
expr_stmt|;
name|_S_left
argument_list|(
name|__y
argument_list|)
operator|=
name|__z
expr_stmt|;
comment|// also makes _M_leftmost() = __z
comment|//    when __y == _M_header
if|if
condition|(
name|__y
operator|==
name|_M_header
condition|)
block|{
name|_M_root
argument_list|()
operator|=
name|__z
expr_stmt|;
name|_M_rightmost
argument_list|()
operator|=
name|__z
expr_stmt|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
name|__y
operator|==
name|_M_leftmost
argument_list|()
condition|)
name|_M_leftmost
argument_list|()
operator|=
name|__z
expr_stmt|;
end_elseif

begin_comment
comment|// maintain _M_leftmost() pointing to min node
end_comment

begin_block
unit|}   else
block|{
name|__z
operator|=
name|_M_create_node
argument_list|(
name|__v
argument_list|)
expr_stmt|;
name|_S_right
argument_list|(
name|__y
argument_list|)
operator|=
name|__z
expr_stmt|;
if|if
condition|(
name|__y
operator|==
name|_M_rightmost
argument_list|()
condition|)
name|_M_rightmost
argument_list|()
operator|=
name|__z
expr_stmt|;
comment|// maintain _M_rightmost() pointing to max node
block|}
end_block

begin_expr_stmt
name|_S_parent
argument_list|(
name|__z
argument_list|)
operator|=
name|__y
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_S_left
argument_list|(
name|__z
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_S_right
argument_list|(
name|__z
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_Rb_tree_rebalance
argument_list|(
name|__z
argument_list|,
name|_M_header
operator|->
name|_M_parent
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|++
name|_M_node_count
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|iterator
argument_list|(
name|__z
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Value
operator|,
name|class
name|_KeyOfValue
operator|,
name|class
name|_Compare
operator|,
name|class
name|_Alloc
operator|>
name|typename
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|iterator
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|insert_equal
argument_list|(
argument|const _Value& __v
argument_list|)
block|{
name|_Link_type
name|__y
operator|=
name|_M_header
block|;
name|_Link_type
name|__x
operator|=
name|_M_root
argument_list|()
block|;
while|while
condition|(
name|__x
operator|!=
literal|0
condition|)
block|{
name|__y
operator|=
name|__x
expr_stmt|;
name|__x
operator|=
name|_M_key_compare
argument_list|(
name|_KeyOfValue
argument_list|()
argument_list|(
name|__v
argument_list|)
argument_list|,
name|_S_key
argument_list|(
name|__x
argument_list|)
argument_list|)
condition|?
name|_S_left
argument_list|(
name|__x
argument_list|)
else|:
name|_S_right
argument_list|(
name|__x
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|_M_insert
argument_list|(
name|__x
argument_list|,
name|__y
argument_list|,
name|__v
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}   template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Value
operator|,
name|class
name|_KeyOfValue
operator|,
name|class
name|_Compare
operator|,
name|class
name|_Alloc
operator|>
name|pair
operator|<
name|typename
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|iterator
operator|,
name|bool
operator|>
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|insert_unique
argument_list|(
argument|const _Value& __v
argument_list|)
block|{
name|_Link_type
name|__y
operator|=
name|_M_header
block|;
name|_Link_type
name|__x
operator|=
name|_M_root
argument_list|()
block|;
name|bool
name|__comp
operator|=
name|true
block|;
while|while
condition|(
name|__x
operator|!=
literal|0
condition|)
block|{
name|__y
operator|=
name|__x
expr_stmt|;
name|__comp
operator|=
name|_M_key_compare
argument_list|(
name|_KeyOfValue
argument_list|()
argument_list|(
name|__v
argument_list|)
argument_list|,
name|_S_key
argument_list|(
name|__x
argument_list|)
argument_list|)
expr_stmt|;
name|__x
operator|=
name|__comp
condition|?
name|_S_left
argument_list|(
name|__x
argument_list|)
else|:
name|_S_right
argument_list|(
name|__x
argument_list|)
expr_stmt|;
block|}
name|iterator
name|__j
operator|=
name|iterator
argument_list|(
name|__y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|__comp
condition|)
if|if
condition|(
name|__j
operator|==
name|begin
argument_list|()
condition|)
return|return
name|pair
operator|<
name|iterator
operator|,
name|bool
operator|>
operator|(
name|_M_insert
argument_list|(
name|__x
argument_list|,
name|__y
argument_list|,
name|__v
argument_list|)
operator|,
name|true
operator|)
return|;
else|else
operator|--
name|__j
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|_M_key_compare
argument_list|(
name|_S_key
argument_list|(
name|__j
operator|.
name|_M_node
argument_list|)
argument_list|,
name|_KeyOfValue
argument_list|()
argument_list|(
name|__v
argument_list|)
argument_list|)
condition|)
return|return
name|pair
operator|<
name|iterator
operator|,
name|bool
operator|>
operator|(
name|_M_insert
argument_list|(
name|__x
argument_list|,
name|__y
argument_list|,
name|__v
argument_list|)
operator|,
name|true
operator|)
return|;
end_if

begin_return
return|return
name|pair
operator|<
name|iterator
operator|,
name|bool
operator|>
operator|(
name|__j
operator|,
name|false
operator|)
return|;
end_return

begin_expr_stmt
unit|}   template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Val
operator|,
name|class
name|_KeyOfValue
operator|,
name|class
name|_Compare
operator|,
name|class
name|_Alloc
operator|>
name|typename
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Val
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|iterator
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Val
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|insert_unique
argument_list|(
argument|iterator __position
argument_list|,
argument|const _Val& __v
argument_list|)
block|{
if|if
condition|(
name|__position
operator|.
name|_M_node
operator|==
name|_M_header
operator|->
name|_M_left
condition|)
block|{
comment|// begin()
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|_M_key_compare
argument_list|(
name|_KeyOfValue
argument_list|()
argument_list|(
name|__v
argument_list|)
argument_list|,
name|_S_key
argument_list|(
name|__position
operator|.
name|_M_node
argument_list|)
argument_list|)
condition|)
return|return
name|_M_insert
argument_list|(
name|__position
operator|.
name|_M_node
argument_list|,
name|__position
operator|.
name|_M_node
argument_list|,
name|__v
argument_list|)
return|;
comment|// first argument just needs to be non-null
else|else
return|return
name|insert_unique
argument_list|(
name|__v
argument_list|)
operator|.
name|first
return|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
name|__position
operator|.
name|_M_node
operator|==
name|_M_header
condition|)
block|{
comment|// end()
if|if
condition|(
name|_M_key_compare
argument_list|(
name|_S_key
argument_list|(
name|_M_rightmost
argument_list|()
argument_list|)
argument_list|,
name|_KeyOfValue
argument_list|()
argument_list|(
name|__v
argument_list|)
argument_list|)
condition|)
return|return
name|_M_insert
argument_list|(
literal|0
argument_list|,
name|_M_rightmost
argument_list|()
argument_list|,
name|__v
argument_list|)
return|;
else|else
return|return
name|insert_unique
argument_list|(
name|__v
argument_list|)
operator|.
name|first
return|;
block|}
end_elseif

begin_else
else|else
block|{
name|iterator
name|__before
init|=
name|__position
decl_stmt|;
operator|--
name|__before
expr_stmt|;
if|if
condition|(
name|_M_key_compare
argument_list|(
name|_S_key
argument_list|(
name|__before
operator|.
name|_M_node
argument_list|)
argument_list|,
name|_KeyOfValue
argument_list|()
argument_list|(
name|__v
argument_list|)
argument_list|)
operator|&&
name|_M_key_compare
argument_list|(
name|_KeyOfValue
argument_list|()
argument_list|(
name|__v
argument_list|)
argument_list|,
name|_S_key
argument_list|(
name|__position
operator|.
name|_M_node
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|_S_right
argument_list|(
name|__before
operator|.
name|_M_node
argument_list|)
operator|==
literal|0
condition|)
return|return
name|_M_insert
argument_list|(
literal|0
argument_list|,
name|__before
operator|.
name|_M_node
argument_list|,
name|__v
argument_list|)
return|;
else|else
return|return
name|_M_insert
argument_list|(
name|__position
operator|.
name|_M_node
argument_list|,
name|__position
operator|.
name|_M_node
argument_list|,
name|__v
argument_list|)
return|;
comment|// first argument just needs to be non-null
block|}
else|else
return|return
name|insert_unique
argument_list|(
name|__v
argument_list|)
operator|.
name|first
return|;
block|}
end_else

begin_expr_stmt
unit|}  template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Val
operator|,
name|class
name|_KeyOfValue
operator|,
name|class
name|_Compare
operator|,
name|class
name|_Alloc
operator|>
name|typename
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Val
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|iterator
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Val
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|insert_equal
argument_list|(
argument|iterator __position
argument_list|,
argument|const _Val& __v
argument_list|)
block|{
if|if
condition|(
name|__position
operator|.
name|_M_node
operator|==
name|_M_header
operator|->
name|_M_left
condition|)
block|{
comment|// begin()
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|_M_key_compare
argument_list|(
name|_KeyOfValue
argument_list|()
argument_list|(
name|__v
argument_list|)
argument_list|,
name|_S_key
argument_list|(
name|__position
operator|.
name|_M_node
argument_list|)
argument_list|)
condition|)
return|return
name|_M_insert
argument_list|(
name|__position
operator|.
name|_M_node
argument_list|,
name|__position
operator|.
name|_M_node
argument_list|,
name|__v
argument_list|)
return|;
comment|// first argument just needs to be non-null
else|else
return|return
name|insert_equal
argument_list|(
name|__v
argument_list|)
return|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
name|__position
operator|.
name|_M_node
operator|==
name|_M_header
condition|)
block|{
comment|// end()
if|if
condition|(
operator|!
name|_M_key_compare
argument_list|(
name|_KeyOfValue
argument_list|()
argument_list|(
name|__v
argument_list|)
argument_list|,
name|_S_key
argument_list|(
name|_M_rightmost
argument_list|()
argument_list|)
argument_list|)
condition|)
return|return
name|_M_insert
argument_list|(
literal|0
argument_list|,
name|_M_rightmost
argument_list|()
argument_list|,
name|__v
argument_list|)
return|;
else|else
return|return
name|insert_equal
argument_list|(
name|__v
argument_list|)
return|;
block|}
end_elseif

begin_else
else|else
block|{
name|iterator
name|__before
init|=
name|__position
decl_stmt|;
operator|--
name|__before
expr_stmt|;
if|if
condition|(
operator|!
name|_M_key_compare
argument_list|(
name|_KeyOfValue
argument_list|()
argument_list|(
name|__v
argument_list|)
argument_list|,
name|_S_key
argument_list|(
name|__before
operator|.
name|_M_node
argument_list|)
argument_list|)
operator|&&
operator|!
name|_M_key_compare
argument_list|(
name|_S_key
argument_list|(
name|__position
operator|.
name|_M_node
argument_list|)
argument_list|,
name|_KeyOfValue
argument_list|()
argument_list|(
name|__v
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|_S_right
argument_list|(
name|__before
operator|.
name|_M_node
argument_list|)
operator|==
literal|0
condition|)
return|return
name|_M_insert
argument_list|(
literal|0
argument_list|,
name|__before
operator|.
name|_M_node
argument_list|,
name|__v
argument_list|)
return|;
else|else
return|return
name|_M_insert
argument_list|(
name|__position
operator|.
name|_M_node
argument_list|,
name|__position
operator|.
name|_M_node
argument_list|,
name|__v
argument_list|)
return|;
comment|// first argument just needs to be non-null
block|}
else|else
return|return
name|insert_equal
argument_list|(
name|__v
argument_list|)
return|;
block|}
end_else

begin_ifdef
unit|}
ifdef|#
directive|ifdef
name|__STL_MEMBER_TEMPLATES
end_ifdef

begin_expr_stmt
unit|template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Val
operator|,
name|class
name|_KoV
operator|,
name|class
name|_Cmp
operator|,
name|class
name|_Alloc
operator|>
name|template
operator|<
name|class
name|_II
operator|>
name|void
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Val
operator|,
name|_KoV
operator|,
name|_Cmp
operator|,
name|_Alloc
operator|>
operator|::
name|insert_equal
argument_list|(
argument|_II __first
argument_list|,
argument|_II __last
argument_list|)
block|{
for|for
control|(
init|;
name|__first
operator|!=
name|__last
condition|;
operator|++
name|__first
control|)
name|insert_equal
argument_list|(
operator|*
name|__first
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Val
operator|,
name|class
name|_KoV
operator|,
name|class
name|_Cmp
operator|,
name|class
name|_Alloc
operator|>
name|template
operator|<
name|class
name|_II
operator|>
name|void
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Val
operator|,
name|_KoV
operator|,
name|_Cmp
operator|,
name|_Alloc
operator|>
operator|::
name|insert_unique
argument_list|(
argument|_II __first
argument_list|,
argument|_II __last
argument_list|)
block|{
for|for
control|(
init|;
name|__first
operator|!=
name|__last
condition|;
operator|++
name|__first
control|)
name|insert_unique
argument_list|(
operator|*
name|__first
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __STL_MEMBER_TEMPLATES */
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Val
operator|,
name|class
name|_KoV
operator|,
name|class
name|_Cmp
operator|,
name|class
name|_Alloc
operator|>
name|void
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Val
operator|,
name|_KoV
operator|,
name|_Cmp
operator|,
name|_Alloc
operator|>
operator|::
name|insert_equal
argument_list|(
argument|const _Val* __first
argument_list|,
argument|const _Val* __last
argument_list|)
block|{
for|for
control|(
init|;
name|__first
operator|!=
name|__last
condition|;
operator|++
name|__first
control|)
name|insert_equal
argument_list|(
operator|*
name|__first
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Val
operator|,
name|class
name|_KoV
operator|,
name|class
name|_Cmp
operator|,
name|class
name|_Alloc
operator|>
name|void
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Val
operator|,
name|_KoV
operator|,
name|_Cmp
operator|,
name|_Alloc
operator|>
operator|::
name|insert_equal
argument_list|(
argument|const_iterator __first
argument_list|,
argument|const_iterator __last
argument_list|)
block|{
for|for
control|(
init|;
name|__first
operator|!=
name|__last
condition|;
operator|++
name|__first
control|)
name|insert_equal
argument_list|(
operator|*
name|__first
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Val
operator|,
name|class
name|_KoV
operator|,
name|class
name|_Cmp
operator|,
name|class
name|_Alloc
operator|>
name|void
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Val
operator|,
name|_KoV
operator|,
name|_Cmp
operator|,
name|_Alloc
operator|>
operator|::
name|insert_unique
argument_list|(
argument|const _Val* __first
argument_list|,
argument|const _Val* __last
argument_list|)
block|{
for|for
control|(
init|;
name|__first
operator|!=
name|__last
condition|;
operator|++
name|__first
control|)
name|insert_unique
argument_list|(
operator|*
name|__first
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Val
operator|,
name|class
name|_KoV
operator|,
name|class
name|_Cmp
operator|,
name|class
name|_Alloc
operator|>
name|void
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Val
operator|,
name|_KoV
operator|,
name|_Cmp
operator|,
name|_Alloc
operator|>
operator|::
name|insert_unique
argument_list|(
argument|const_iterator __first
argument_list|,
argument|const_iterator __last
argument_list|)
block|{
for|for
control|(
init|;
name|__first
operator|!=
name|__last
condition|;
operator|++
name|__first
control|)
name|insert_unique
argument_list|(
operator|*
name|__first
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STL_MEMBER_TEMPLATES */
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Value
operator|,
name|class
name|_KeyOfValue
operator|,
name|class
name|_Compare
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|void
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|erase
argument_list|(
argument|iterator __position
argument_list|)
block|{
name|_Link_type
name|__y
operator|=
operator|(
name|_Link_type
operator|)
name|_Rb_tree_rebalance_for_erase
argument_list|(
name|__position
operator|.
name|_M_node
argument_list|,
name|_M_header
operator|->
name|_M_parent
argument_list|,
name|_M_header
operator|->
name|_M_left
argument_list|,
name|_M_header
operator|->
name|_M_right
argument_list|)
block|;
name|destroy_node
argument_list|(
name|__y
argument_list|)
block|;
operator|--
name|_M_node_count
block|; }
name|template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Value
operator|,
name|class
name|_KeyOfValue
operator|,
name|class
name|_Compare
operator|,
name|class
name|_Alloc
operator|>
name|typename
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|size_type
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|erase
argument_list|(
argument|const _Key& __x
argument_list|)
block|{
name|pair
operator|<
name|iterator
block|,
name|iterator
operator|>
name|__p
operator|=
name|equal_range
argument_list|(
name|__x
argument_list|)
block|;
name|size_type
name|__n
operator|=
literal|0
block|;
name|distance
argument_list|(
name|__p
operator|.
name|first
argument_list|,
name|__p
operator|.
name|second
argument_list|,
name|__n
argument_list|)
block|;
name|erase
argument_list|(
name|__p
operator|.
name|first
argument_list|,
name|__p
operator|.
name|second
argument_list|)
block|;
return|return
name|__n
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Val
operator|,
name|class
name|_KoV
operator|,
name|class
name|_Compare
operator|,
name|class
name|_Alloc
operator|>
name|typename
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Val
operator|,
name|_KoV
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|_Link_type
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Val
operator|,
name|_KoV
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|_M_copy
argument_list|(
argument|_Link_type __x
argument_list|,
argument|_Link_type __p
argument_list|)
block|{
comment|// structural copy.  __x and __p must be non-null.
name|_Link_type
name|__top
operator|=
name|_M_clone_node
argument_list|(
name|__x
argument_list|)
block|;
name|__top
operator|->
name|_M_parent
operator|=
name|__p
block|;
name|__STL_TRY
block|{
if|if
condition|(
name|__x
operator|->
name|_M_right
condition|)
name|__top
operator|->
name|_M_right
operator|=
name|_M_copy
argument_list|(
name|_S_right
argument_list|(
name|__x
argument_list|)
argument_list|,
name|__top
argument_list|)
expr_stmt|;
name|__p
operator|=
name|__top
block|;
name|__x
operator|=
name|_S_left
argument_list|(
name|__x
argument_list|)
block|;
while|while
condition|(
name|__x
operator|!=
literal|0
condition|)
block|{
name|_Link_type
name|__y
init|=
name|_M_clone_node
argument_list|(
name|__x
argument_list|)
decl_stmt|;
name|__p
operator|->
name|_M_left
operator|=
name|__y
expr_stmt|;
name|__y
operator|->
name|_M_parent
operator|=
name|__p
expr_stmt|;
if|if
condition|(
name|__x
operator|->
name|_M_right
condition|)
name|__y
operator|->
name|_M_right
operator|=
name|_M_copy
argument_list|(
name|_S_right
argument_list|(
name|__x
argument_list|)
argument_list|,
name|__y
argument_list|)
expr_stmt|;
name|__p
operator|=
name|__y
expr_stmt|;
name|__x
operator|=
name|_S_left
argument_list|(
name|__x
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}   __STL_UNWIND
operator|(
name|_M_erase
argument_list|(
name|__top
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|__top
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Value
operator|,
name|class
name|_KeyOfValue
operator|,
name|class
name|_Compare
operator|,
name|class
name|_Alloc
operator|>
name|void
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|_M_erase
argument_list|(
argument|_Link_type __x
argument_list|)
block|{
comment|// erase without rebalancing
while|while
condition|(
name|__x
operator|!=
literal|0
condition|)
block|{
name|_M_erase
argument_list|(
name|_S_right
argument_list|(
name|__x
argument_list|)
argument_list|)
expr_stmt|;
name|_Link_type
name|__y
init|=
name|_S_left
argument_list|(
name|__x
argument_list|)
decl_stmt|;
name|destroy_node
argument_list|(
name|__x
argument_list|)
expr_stmt|;
name|__x
operator|=
name|__y
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Value
operator|,
name|class
name|_KeyOfValue
operator|,
name|class
name|_Compare
operator|,
name|class
name|_Alloc
operator|>
name|void
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|erase
argument_list|(
argument|iterator __first
argument_list|,
argument|iterator __last
argument_list|)
block|{
if|if
condition|(
name|__first
operator|==
name|begin
argument_list|()
operator|&&
name|__last
operator|==
name|end
argument_list|()
condition|)
name|clear
argument_list|()
expr_stmt|;
else|else
while|while
condition|(
name|__first
operator|!=
name|__last
condition|)
name|erase
argument_list|(
name|__first
operator|++
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Value
operator|,
name|class
name|_KeyOfValue
operator|,
name|class
name|_Compare
operator|,
name|class
name|_Alloc
operator|>
name|void
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|erase
argument_list|(
argument|const _Key* __first
argument_list|,
argument|const _Key* __last
argument_list|)
block|{
while|while
condition|(
name|__first
operator|!=
name|__last
condition|)
name|erase
argument_list|(
operator|*
name|__first
operator|++
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Value
operator|,
name|class
name|_KeyOfValue
operator|,
name|class
name|_Compare
operator|,
name|class
name|_Alloc
operator|>
name|typename
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|iterator
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|find
argument_list|(
argument|const _Key& __k
argument_list|)
block|{
name|_Link_type
name|__y
operator|=
name|_M_header
block|;
comment|// Last node which is not less than __k.
name|_Link_type
name|__x
operator|=
name|_M_root
argument_list|()
block|;
comment|// Current node.
while|while
condition|(
name|__x
operator|!=
literal|0
condition|)
if|if
condition|(
operator|!
name|_M_key_compare
argument_list|(
name|_S_key
argument_list|(
name|__x
argument_list|)
argument_list|,
name|__k
argument_list|)
condition|)
name|__y
operator|=
name|__x
operator|,
name|__x
operator|=
name|_S_left
argument_list|(
name|__x
argument_list|)
expr_stmt|;
else|else
name|__x
operator|=
name|_S_right
argument_list|(
name|__x
argument_list|)
expr_stmt|;
name|iterator
name|__j
operator|=
name|iterator
argument_list|(
name|__y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|__j
operator|==
name|end
argument_list|()
operator|||
name|_M_key_compare
argument_list|(
name|__k
argument_list|,
name|_S_key
argument_list|(
name|__j
operator|.
name|_M_node
argument_list|)
argument_list|)
operator|)
condition|?
name|end
argument_list|()
else|:
name|__j
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Value
operator|,
name|class
name|_KeyOfValue
operator|,
name|class
name|_Compare
operator|,
name|class
name|_Alloc
operator|>
name|typename
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|const_iterator
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|find
argument_list|(
argument|const _Key& __k
argument_list|)
specifier|const
block|{
name|_Link_type
name|__y
operator|=
name|_M_header
block|;
comment|/* Last node which is not less than __k. */
name|_Link_type
name|__x
operator|=
name|_M_root
argument_list|()
block|;
comment|/* Current node. */
while|while
condition|(
name|__x
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|_M_key_compare
argument_list|(
name|_S_key
argument_list|(
name|__x
argument_list|)
argument_list|,
name|__k
argument_list|)
condition|)
name|__y
operator|=
name|__x
operator|,
name|__x
operator|=
name|_S_left
argument_list|(
name|__x
argument_list|)
expr_stmt|;
else|else
name|__x
operator|=
name|_S_right
argument_list|(
name|__x
argument_list|)
expr_stmt|;
block|}
name|const_iterator
name|__j
operator|=
name|const_iterator
argument_list|(
name|__y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|__j
operator|==
name|end
argument_list|()
operator|||
name|_M_key_compare
argument_list|(
name|__k
argument_list|,
name|_S_key
argument_list|(
name|__j
operator|.
name|_M_node
argument_list|)
argument_list|)
operator|)
condition|?
name|end
argument_list|()
else|:
name|__j
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Value
operator|,
name|class
name|_KeyOfValue
operator|,
name|class
name|_Compare
operator|,
name|class
name|_Alloc
operator|>
name|typename
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|size_type
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|count
argument_list|(
argument|const _Key& __k
argument_list|)
specifier|const
block|{
name|pair
operator|<
name|const_iterator
block|,
name|const_iterator
operator|>
name|__p
operator|=
name|equal_range
argument_list|(
name|__k
argument_list|)
block|;
name|size_type
name|__n
operator|=
literal|0
block|;
name|distance
argument_list|(
name|__p
operator|.
name|first
argument_list|,
name|__p
operator|.
name|second
argument_list|,
name|__n
argument_list|)
block|;
return|return
name|__n
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Value
operator|,
name|class
name|_KeyOfValue
operator|,
name|class
name|_Compare
operator|,
name|class
name|_Alloc
operator|>
name|typename
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|iterator
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|lower_bound
argument_list|(
argument|const _Key& __k
argument_list|)
block|{
name|_Link_type
name|__y
operator|=
name|_M_header
block|;
comment|/* Last node which is not less than __k. */
name|_Link_type
name|__x
operator|=
name|_M_root
argument_list|()
block|;
comment|/* Current node. */
while|while
condition|(
name|__x
operator|!=
literal|0
condition|)
if|if
condition|(
operator|!
name|_M_key_compare
argument_list|(
name|_S_key
argument_list|(
name|__x
argument_list|)
argument_list|,
name|__k
argument_list|)
condition|)
name|__y
operator|=
name|__x
operator|,
name|__x
operator|=
name|_S_left
argument_list|(
name|__x
argument_list|)
expr_stmt|;
else|else
name|__x
operator|=
name|_S_right
argument_list|(
name|__x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|iterator
argument_list|(
name|__y
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Value
operator|,
name|class
name|_KeyOfValue
operator|,
name|class
name|_Compare
operator|,
name|class
name|_Alloc
operator|>
name|typename
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|const_iterator
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|lower_bound
argument_list|(
argument|const _Key& __k
argument_list|)
specifier|const
block|{
name|_Link_type
name|__y
operator|=
name|_M_header
block|;
comment|/* Last node which is not less than __k. */
name|_Link_type
name|__x
operator|=
name|_M_root
argument_list|()
block|;
comment|/* Current node. */
while|while
condition|(
name|__x
operator|!=
literal|0
condition|)
if|if
condition|(
operator|!
name|_M_key_compare
argument_list|(
name|_S_key
argument_list|(
name|__x
argument_list|)
argument_list|,
name|__k
argument_list|)
condition|)
name|__y
operator|=
name|__x
operator|,
name|__x
operator|=
name|_S_left
argument_list|(
name|__x
argument_list|)
expr_stmt|;
else|else
name|__x
operator|=
name|_S_right
argument_list|(
name|__x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|const_iterator
argument_list|(
name|__y
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Value
operator|,
name|class
name|_KeyOfValue
operator|,
name|class
name|_Compare
operator|,
name|class
name|_Alloc
operator|>
name|typename
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|iterator
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|upper_bound
argument_list|(
argument|const _Key& __k
argument_list|)
block|{
name|_Link_type
name|__y
operator|=
name|_M_header
block|;
comment|/* Last node which is greater than __k. */
name|_Link_type
name|__x
operator|=
name|_M_root
argument_list|()
block|;
comment|/* Current node. */
while|while
condition|(
name|__x
operator|!=
literal|0
condition|)
if|if
condition|(
name|_M_key_compare
argument_list|(
name|__k
argument_list|,
name|_S_key
argument_list|(
name|__x
argument_list|)
argument_list|)
condition|)
name|__y
operator|=
name|__x
operator|,
name|__x
operator|=
name|_S_left
argument_list|(
name|__x
argument_list|)
expr_stmt|;
else|else
name|__x
operator|=
name|_S_right
argument_list|(
name|__x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|iterator
argument_list|(
name|__y
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Value
operator|,
name|class
name|_KeyOfValue
operator|,
name|class
name|_Compare
operator|,
name|class
name|_Alloc
operator|>
name|typename
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|const_iterator
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|upper_bound
argument_list|(
argument|const _Key& __k
argument_list|)
specifier|const
block|{
name|_Link_type
name|__y
operator|=
name|_M_header
block|;
comment|/* Last node which is greater than __k. */
name|_Link_type
name|__x
operator|=
name|_M_root
argument_list|()
block|;
comment|/* Current node. */
while|while
condition|(
name|__x
operator|!=
literal|0
condition|)
if|if
condition|(
name|_M_key_compare
argument_list|(
name|__k
argument_list|,
name|_S_key
argument_list|(
name|__x
argument_list|)
argument_list|)
condition|)
name|__y
operator|=
name|__x
operator|,
name|__x
operator|=
name|_S_left
argument_list|(
name|__x
argument_list|)
expr_stmt|;
else|else
name|__x
operator|=
name|_S_right
argument_list|(
name|__x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|const_iterator
argument_list|(
name|__y
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Value
operator|,
name|class
name|_KeyOfValue
operator|,
name|class
name|_Compare
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|pair
operator|<
name|typename
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|iterator
operator|,
name|typename
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|iterator
operator|>
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|equal_range
argument_list|(
argument|const _Key& __k
argument_list|)
block|{
return|return
name|pair
operator|<
name|iterator
operator|,
name|iterator
operator|>
operator|(
name|lower_bound
argument_list|(
name|__k
argument_list|)
operator|,
name|upper_bound
argument_list|(
name|__k
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Value
operator|,
name|class
name|_KoV
operator|,
name|class
name|_Compare
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|pair
operator|<
name|typename
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KoV
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|const_iterator
operator|,
name|typename
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KoV
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|const_iterator
operator|>
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KoV
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|equal_range
argument_list|(
argument|const _Key& __k
argument_list|)
specifier|const
block|{
return|return
name|pair
operator|<
name|const_iterator
operator|,
name|const_iterator
operator|>
operator|(
name|lower_bound
argument_list|(
name|__k
argument_list|)
operator|,
name|upper_bound
argument_list|(
name|__k
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_function
specifier|inline
name|int
name|__black_count
parameter_list|(
name|_Rb_tree_node_base
modifier|*
name|__node
parameter_list|,
name|_Rb_tree_node_base
modifier|*
name|__root
parameter_list|)
block|{
if|if
condition|(
name|__node
operator|==
literal|0
condition|)
return|return
literal|0
return|;
else|else
block|{
name|int
name|__bc
init|=
name|__node
operator|->
name|_M_color
operator|==
name|_S_rb_tree_black
condition|?
literal|1
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|__node
operator|==
name|__root
condition|)
return|return
name|__bc
return|;
else|else
return|return
name|__bc
operator|+
name|__black_count
argument_list|(
name|__node
operator|->
name|_M_parent
argument_list|,
name|__root
argument_list|)
return|;
block|}
block|}
end_function

begin_expr_stmt
name|template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Value
operator|,
name|class
name|_KeyOfValue
operator|,
name|class
name|_Compare
operator|,
name|class
name|_Alloc
operator|>
name|bool
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
operator|::
name|__rb_verify
argument_list|()
specifier|const
block|{
if|if
condition|(
name|_M_node_count
operator|==
literal|0
operator|||
name|begin
argument_list|()
operator|==
name|end
argument_list|()
condition|)
return|return
name|_M_node_count
operator|==
literal|0
operator|&&
name|begin
argument_list|()
operator|==
name|end
argument_list|()
operator|&&
name|_M_header
operator|->
name|_M_left
operator|==
name|_M_header
operator|&&
name|_M_header
operator|->
name|_M_right
operator|==
name|_M_header
return|;
name|int
name|__len
operator|=
name|__black_count
argument_list|(
name|_M_leftmost
argument_list|()
argument_list|,
name|_M_root
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|const_iterator
name|__it
init|=
name|begin
argument_list|()
init|;
name|__it
operator|!=
name|end
argument_list|()
condition|;
operator|++
name|__it
control|)
block|{
name|_Link_type
name|__x
init|=
operator|(
name|_Link_type
operator|)
name|__it
operator|.
name|_M_node
decl_stmt|;
name|_Link_type
name|__L
init|=
name|_S_left
argument_list|(
name|__x
argument_list|)
decl_stmt|;
name|_Link_type
name|__R
init|=
name|_S_right
argument_list|(
name|__x
argument_list|)
decl_stmt|;
if|if
condition|(
name|__x
operator|->
name|_M_color
operator|==
name|_S_rb_tree_red
condition|)
if|if
condition|(
operator|(
name|__L
operator|&&
name|__L
operator|->
name|_M_color
operator|==
name|_S_rb_tree_red
operator|)
operator|||
operator|(
name|__R
operator|&&
name|__R
operator|->
name|_M_color
operator|==
name|_S_rb_tree_red
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|__L
operator|&&
name|_M_key_compare
argument_list|(
name|_S_key
argument_list|(
name|__x
argument_list|)
argument_list|,
name|_S_key
argument_list|(
name|__L
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|__R
operator|&&
name|_M_key_compare
argument_list|(
name|_S_key
argument_list|(
name|__R
argument_list|)
argument_list|,
name|_S_key
argument_list|(
name|__x
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|__L
operator|&&
operator|!
name|__R
operator|&&
name|__black_count
argument_list|(
name|__x
argument_list|,
name|_M_root
argument_list|()
argument_list|)
operator|!=
name|__len
condition|)
return|return
name|false
return|;
block|}
end_for

begin_if
if|if
condition|(
name|_M_leftmost
argument_list|()
operator|!=
name|_Rb_tree_node_base
operator|::
name|_S_minimum
argument_list|(
name|_M_root
argument_list|()
argument_list|)
condition|)
return|return
name|false
return|;
end_if

begin_if
if|if
condition|(
name|_M_rightmost
argument_list|()
operator|!=
name|_Rb_tree_node_base
operator|::
name|_S_maximum
argument_list|(
name|_M_root
argument_list|()
argument_list|)
condition|)
return|return
name|false
return|;
end_if

begin_return
return|return
name|true
return|;
end_return

begin_comment
unit|}
comment|// Class rb_tree is not part of the C++ standard.  It is provided for
end_comment

begin_comment
comment|// compatibility with the HP STL.
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|_Key
operator|,
name|class
name|_Value
operator|,
name|class
name|_KeyOfValue
operator|,
name|class
name|_Compare
operator|,
name|class
name|_Alloc
operator|=
name|__STL_DEFAULT_ALLOCATOR
argument_list|(
name|_Value
argument_list|)
operator|>
expr|struct
name|rb_tree
operator|:
name|public
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
block|{
typedef|typedef
name|_Rb_tree
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_KeyOfValue
operator|,
name|_Compare
operator|,
name|_Alloc
operator|>
name|_Base
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|_Base
operator|::
name|allocator_type
name|allocator_type
expr_stmt|;
end_typedef

begin_expr_stmt
name|rb_tree
argument_list|(
specifier|const
name|_Compare
operator|&
name|__comp
operator|=
name|_Compare
argument_list|()
argument_list|,
specifier|const
name|allocator_type
operator|&
name|__a
operator|=
name|allocator_type
argument_list|()
argument_list|)
operator|:
name|_Base
argument_list|(
argument|__comp
argument_list|,
argument|__a
argument_list|)
block|{}
operator|~
name|rb_tree
argument_list|()
block|{}
end_expr_stmt

begin_if
unit|};
if|#
directive|if
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|_MIPS_SIM
operator|!=
name|_MIPS_SIM_ABI32
operator|)
end_if

begin_pragma
pragma|#
directive|pragma
name|reset
name|woff
name|1375
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|__STL_END_NAMESPACE
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __SGI_STL_INTERNAL_TREE_H */
end_comment

begin_comment
comment|// Local Variables:
end_comment

begin_comment
comment|// mode:C++
end_comment

begin_comment
comment|// End:
end_comment

end_unit

