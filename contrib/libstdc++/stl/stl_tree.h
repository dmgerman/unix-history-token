begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * Copyright (c) 1996,1997  * Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Silicon Graphics makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  *  *  * Copyright (c) 1994  * Hewlett-Packard Company  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Hewlett-Packard Company makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  *  *  */
end_comment

begin_comment
comment|/* NOTE: This is an internal header file, included by other STL headers.  *   You should not attempt to use it directly.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__SGI_STL_INTERNAL_TREE_H
end_ifndef

begin_define
define|#
directive|define
name|__SGI_STL_INTERNAL_TREE_H
end_define

begin_comment
comment|/*  Red-black tree class, designed for use in implementing STL associative containers (set, multiset, map, and multimap). The insertion and deletion algorithms are based on those in Cormen, Leiserson, and Rivest, Introduction to Algorithms (MIT Press, 1990), except that  (1) the header cell is maintained with links not only to the root but also to the leftmost node of the tree, to enable constant time begin(), and to the rightmost node of the tree, to enable linear time performance when used with the generic set algorithms (set_union, etc.);  (2) when a node being deleted has two children its successor node is relinked into its place, rather than copied, so that the only iterators invalidated are those referring to the deleted node.  */
end_comment

begin_include
include|#
directive|include
file|<stl_algobase.h>
end_include

begin_include
include|#
directive|include
file|<stl_alloc.h>
end_include

begin_include
include|#
directive|include
file|<stl_construct.h>
end_include

begin_include
include|#
directive|include
file|<stl_function.h>
end_include

begin_macro
name|__STL_BEGIN_NAMESPACE
end_macro

begin_typedef
typedef|typedef
name|bool
name|__rb_tree_color_type
typedef|;
end_typedef

begin_decl_stmt
specifier|const
name|__rb_tree_color_type
name|__rb_tree_red
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|__rb_tree_color_type
name|__rb_tree_black
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|__rb_tree_node_base
block|{
typedef|typedef
name|__rb_tree_color_type
name|color_type
typedef|;
typedef|typedef
name|__rb_tree_node_base
modifier|*
name|base_ptr
typedef|;
name|color_type
name|color
decl_stmt|;
name|base_ptr
name|parent
decl_stmt|;
name|base_ptr
name|left
decl_stmt|;
name|base_ptr
name|right
decl_stmt|;
specifier|static
name|base_ptr
name|minimum
parameter_list|(
name|base_ptr
name|x
parameter_list|)
block|{
while|while
condition|(
name|x
operator|->
name|left
operator|!=
literal|0
condition|)
name|x
operator|=
name|x
operator|->
name|left
expr_stmt|;
return|return
name|x
return|;
block|}
specifier|static
name|base_ptr
name|maximum
parameter_list|(
name|base_ptr
name|x
parameter_list|)
block|{
while|while
condition|(
name|x
operator|->
name|right
operator|!=
literal|0
condition|)
name|x
operator|=
name|x
operator|->
name|right
expr_stmt|;
return|return
name|x
return|;
block|}
block|}
struct|;
end_struct

begin_expr_stmt
name|template
operator|<
name|class
name|Value
operator|>
expr|struct
name|__rb_tree_node
operator|:
name|public
name|__rb_tree_node_base
block|{
typedef|typedef
name|__rb_tree_node
operator|<
name|Value
operator|>
operator|*
name|link_type
expr_stmt|;
name|Value
name|value_field
expr_stmt|;
end_expr_stmt

begin_struct
unit|};
struct|struct
name|__rb_tree_base_iterator
block|{
typedef|typedef
name|__rb_tree_node_base
operator|::
name|base_ptr
name|base_ptr
expr_stmt|;
typedef|typedef
name|bidirectional_iterator_tag
name|iterator_category
typedef|;
typedef|typedef
name|ptrdiff_t
name|difference_type
typedef|;
name|base_ptr
name|node
decl_stmt|;
name|void
name|increment
parameter_list|()
block|{
if|if
condition|(
name|node
operator|->
name|right
operator|!=
literal|0
condition|)
block|{
name|node
operator|=
name|node
operator|->
name|right
expr_stmt|;
while|while
condition|(
name|node
operator|->
name|left
operator|!=
literal|0
condition|)
name|node
operator|=
name|node
operator|->
name|left
expr_stmt|;
block|}
else|else
block|{
name|base_ptr
name|y
init|=
name|node
operator|->
name|parent
decl_stmt|;
while|while
condition|(
name|node
operator|==
name|y
operator|->
name|right
condition|)
block|{
name|node
operator|=
name|y
expr_stmt|;
name|y
operator|=
name|y
operator|->
name|parent
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|right
operator|!=
name|y
condition|)
name|node
operator|=
name|y
expr_stmt|;
block|}
block|}
name|void
name|decrement
parameter_list|()
block|{
if|if
condition|(
name|node
operator|->
name|color
operator|==
name|__rb_tree_red
operator|&&
name|node
operator|->
name|parent
operator|->
name|parent
operator|==
name|node
condition|)
name|node
operator|=
name|node
operator|->
name|right
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|->
name|left
operator|!=
literal|0
condition|)
block|{
name|base_ptr
name|y
init|=
name|node
operator|->
name|left
decl_stmt|;
while|while
condition|(
name|y
operator|->
name|right
operator|!=
literal|0
condition|)
name|y
operator|=
name|y
operator|->
name|right
expr_stmt|;
name|node
operator|=
name|y
expr_stmt|;
block|}
else|else
block|{
name|base_ptr
name|y
init|=
name|node
operator|->
name|parent
decl_stmt|;
while|while
condition|(
name|node
operator|==
name|y
operator|->
name|left
condition|)
block|{
name|node
operator|=
name|y
expr_stmt|;
name|y
operator|=
name|y
operator|->
name|parent
expr_stmt|;
block|}
name|node
operator|=
name|y
expr_stmt|;
block|}
block|}
block|}
struct|;
end_struct

begin_expr_stmt
name|template
operator|<
name|class
name|Value
operator|,
name|class
name|Ref
operator|,
name|class
name|Ptr
operator|>
expr|struct
name|__rb_tree_iterator
operator|:
name|public
name|__rb_tree_base_iterator
block|{
typedef|typedef
name|Value
name|value_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|Ref
name|reference
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|Ptr
name|pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|__rb_tree_iterator
operator|<
name|Value
operator|,
name|Value
operator|&
operator|,
name|Value
operator|*
operator|>
name|iterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|__rb_tree_iterator
operator|<
name|Value
operator|,
specifier|const
name|Value
operator|&
operator|,
specifier|const
name|Value
operator|*
operator|>
name|const_iterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|__rb_tree_iterator
operator|<
name|Value
operator|,
name|Ref
operator|,
name|Ptr
operator|>
name|self
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|__rb_tree_node
operator|<
name|Value
operator|>
operator|*
name|link_type
expr_stmt|;
end_typedef

begin_macro
name|__rb_tree_iterator
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_macro
name|__rb_tree_iterator
argument_list|(
argument|link_type x
argument_list|)
end_macro

begin_block
block|{
name|node
operator|=
name|x
expr_stmt|;
block|}
end_block

begin_macro
name|__rb_tree_iterator
argument_list|(
argument|const iterator& it
argument_list|)
end_macro

begin_block
block|{
name|node
operator|=
name|it
operator|.
name|node
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|reference
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|link_type
argument_list|(
name|node
argument_list|)
operator|->
name|value_field
return|;
block|}
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__SGI_STL_NO_ARROW_OPERATOR
end_ifndef

begin_expr_stmt
name|pointer
name|operator
operator|->
expr|(
end_expr_stmt

begin_expr_stmt
unit|)
specifier|const
block|{
return|return
operator|&
operator|(
name|operator
operator|*
operator|(
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __SGI_STL_NO_ARROW_OPERATOR */
end_comment

begin_expr_stmt
name|self
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|increment
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|self
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|self
name|tmp
operator|=
operator|*
name|this
block|;
name|increment
argument_list|()
block|;
return|return
name|tmp
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|self
operator|&
name|operator
operator|--
operator|(
operator|)
block|{
name|decrement
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|self
name|operator
operator|--
operator|(
name|int
operator|)
block|{
name|self
name|tmp
operator|=
operator|*
name|this
block|;
name|decrement
argument_list|()
block|;
return|return
name|tmp
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|__rb_tree_base_iterator
operator|&
name|x
operator|,
specifier|const
name|__rb_tree_base_iterator
operator|&
name|y
operator|)
block|{
return|return
name|x
operator|.
name|node
operator|==
name|y
operator|.
name|node
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|__rb_tree_base_iterator
operator|&
name|x
operator|,
specifier|const
name|__rb_tree_base_iterator
operator|&
name|y
operator|)
block|{
return|return
name|x
operator|.
name|node
operator|!=
name|y
operator|.
name|node
return|;
block|}
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__STL_CLASS_PARTIAL_SPECIALIZATION
end_ifndef

begin_function
specifier|inline
name|bidirectional_iterator_tag
name|iterator_category
parameter_list|(
specifier|const
name|__rb_tree_base_iterator
modifier|&
parameter_list|)
block|{
return|return
name|bidirectional_iterator_tag
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
specifier|inline
name|__rb_tree_base_iterator
operator|::
name|difference_type
operator|*
name|distance_type
argument_list|(
argument|const __rb_tree_base_iterator&
argument_list|)
block|{
return|return
operator|(
name|__rb_tree_base_iterator
operator|::
name|difference_type
operator|*
operator|)
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Value
operator|,
name|class
name|Ref
operator|,
name|class
name|Ptr
operator|>
specifier|inline
name|Value
operator|*
name|value_type
argument_list|(
argument|const __rb_tree_iterator<Value
argument_list|,
argument|Ref
argument_list|,
argument|Ptr>&
argument_list|)
block|{
return|return
operator|(
name|Value
operator|*
operator|)
literal|0
return|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STL_CLASS_PARTIAL_SPECIALIZATION */
end_comment

begin_function
specifier|inline
name|void
name|__rb_tree_rotate_left
parameter_list|(
name|__rb_tree_node_base
modifier|*
name|x
parameter_list|,
name|__rb_tree_node_base
modifier|*
modifier|&
name|root
parameter_list|)
block|{
name|__rb_tree_node_base
modifier|*
name|y
init|=
name|x
operator|->
name|right
decl_stmt|;
name|x
operator|->
name|right
operator|=
name|y
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|y
operator|->
name|left
operator|!=
literal|0
condition|)
name|y
operator|->
name|left
operator|->
name|parent
operator|=
name|x
expr_stmt|;
name|y
operator|->
name|parent
operator|=
name|x
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|root
condition|)
name|root
operator|=
name|y
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|x
operator|->
name|parent
operator|->
name|left
condition|)
name|x
operator|->
name|parent
operator|->
name|left
operator|=
name|y
expr_stmt|;
else|else
name|x
operator|->
name|parent
operator|->
name|right
operator|=
name|y
expr_stmt|;
name|y
operator|->
name|left
operator|=
name|x
expr_stmt|;
name|x
operator|->
name|parent
operator|=
name|y
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|__rb_tree_rotate_right
parameter_list|(
name|__rb_tree_node_base
modifier|*
name|x
parameter_list|,
name|__rb_tree_node_base
modifier|*
modifier|&
name|root
parameter_list|)
block|{
name|__rb_tree_node_base
modifier|*
name|y
init|=
name|x
operator|->
name|left
decl_stmt|;
name|x
operator|->
name|left
operator|=
name|y
operator|->
name|right
expr_stmt|;
if|if
condition|(
name|y
operator|->
name|right
operator|!=
literal|0
condition|)
name|y
operator|->
name|right
operator|->
name|parent
operator|=
name|x
expr_stmt|;
name|y
operator|->
name|parent
operator|=
name|x
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|root
condition|)
name|root
operator|=
name|y
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|x
operator|->
name|parent
operator|->
name|right
condition|)
name|x
operator|->
name|parent
operator|->
name|right
operator|=
name|y
expr_stmt|;
else|else
name|x
operator|->
name|parent
operator|->
name|left
operator|=
name|y
expr_stmt|;
name|y
operator|->
name|right
operator|=
name|x
expr_stmt|;
name|x
operator|->
name|parent
operator|=
name|y
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|__rb_tree_rebalance
parameter_list|(
name|__rb_tree_node_base
modifier|*
name|x
parameter_list|,
name|__rb_tree_node_base
modifier|*
modifier|&
name|root
parameter_list|)
block|{
name|x
operator|->
name|color
operator|=
name|__rb_tree_red
expr_stmt|;
while|while
condition|(
name|x
operator|!=
name|root
operator|&&
name|x
operator|->
name|parent
operator|->
name|color
operator|==
name|__rb_tree_red
condition|)
block|{
if|if
condition|(
name|x
operator|->
name|parent
operator|==
name|x
operator|->
name|parent
operator|->
name|parent
operator|->
name|left
condition|)
block|{
name|__rb_tree_node_base
modifier|*
name|y
init|=
name|x
operator|->
name|parent
operator|->
name|parent
operator|->
name|right
decl_stmt|;
if|if
condition|(
name|y
operator|&&
name|y
operator|->
name|color
operator|==
name|__rb_tree_red
condition|)
block|{
name|x
operator|->
name|parent
operator|->
name|color
operator|=
name|__rb_tree_black
expr_stmt|;
name|y
operator|->
name|color
operator|=
name|__rb_tree_black
expr_stmt|;
name|x
operator|->
name|parent
operator|->
name|parent
operator|->
name|color
operator|=
name|__rb_tree_red
expr_stmt|;
name|x
operator|=
name|x
operator|->
name|parent
operator|->
name|parent
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|x
operator|==
name|x
operator|->
name|parent
operator|->
name|right
condition|)
block|{
name|x
operator|=
name|x
operator|->
name|parent
expr_stmt|;
name|__rb_tree_rotate_left
argument_list|(
name|x
argument_list|,
name|root
argument_list|)
expr_stmt|;
block|}
name|x
operator|->
name|parent
operator|->
name|color
operator|=
name|__rb_tree_black
expr_stmt|;
name|x
operator|->
name|parent
operator|->
name|parent
operator|->
name|color
operator|=
name|__rb_tree_red
expr_stmt|;
name|__rb_tree_rotate_right
argument_list|(
name|x
operator|->
name|parent
operator|->
name|parent
argument_list|,
name|root
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|__rb_tree_node_base
modifier|*
name|y
init|=
name|x
operator|->
name|parent
operator|->
name|parent
operator|->
name|left
decl_stmt|;
if|if
condition|(
name|y
operator|&&
name|y
operator|->
name|color
operator|==
name|__rb_tree_red
condition|)
block|{
name|x
operator|->
name|parent
operator|->
name|color
operator|=
name|__rb_tree_black
expr_stmt|;
name|y
operator|->
name|color
operator|=
name|__rb_tree_black
expr_stmt|;
name|x
operator|->
name|parent
operator|->
name|parent
operator|->
name|color
operator|=
name|__rb_tree_red
expr_stmt|;
name|x
operator|=
name|x
operator|->
name|parent
operator|->
name|parent
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|x
operator|==
name|x
operator|->
name|parent
operator|->
name|left
condition|)
block|{
name|x
operator|=
name|x
operator|->
name|parent
expr_stmt|;
name|__rb_tree_rotate_right
argument_list|(
name|x
argument_list|,
name|root
argument_list|)
expr_stmt|;
block|}
name|x
operator|->
name|parent
operator|->
name|color
operator|=
name|__rb_tree_black
expr_stmt|;
name|x
operator|->
name|parent
operator|->
name|parent
operator|->
name|color
operator|=
name|__rb_tree_red
expr_stmt|;
name|__rb_tree_rotate_left
argument_list|(
name|x
operator|->
name|parent
operator|->
name|parent
argument_list|,
name|root
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|root
operator|->
name|color
operator|=
name|__rb_tree_black
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|__rb_tree_node_base
modifier|*
name|__rb_tree_rebalance_for_erase
parameter_list|(
name|__rb_tree_node_base
modifier|*
name|z
parameter_list|,
name|__rb_tree_node_base
modifier|*
modifier|&
name|root
parameter_list|,
name|__rb_tree_node_base
modifier|*
modifier|&
name|leftmost
parameter_list|,
name|__rb_tree_node_base
modifier|*
modifier|&
name|rightmost
parameter_list|)
block|{
name|__rb_tree_node_base
modifier|*
name|y
init|=
name|z
decl_stmt|;
name|__rb_tree_node_base
modifier|*
name|x
init|=
literal|0
decl_stmt|;
name|__rb_tree_node_base
modifier|*
name|x_parent
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|y
operator|->
name|left
operator|==
literal|0
condition|)
comment|// z has at most one non-null child. y == z.
name|x
operator|=
name|y
operator|->
name|right
expr_stmt|;
comment|// x might be null.
elseif|else
if|if
condition|(
name|y
operator|->
name|right
operator|==
literal|0
condition|)
comment|// z has exactly one non-null child.  y == z.
name|x
operator|=
name|y
operator|->
name|left
expr_stmt|;
comment|// x is not null.
else|else
block|{
comment|// z has two non-null children.  Set y to
name|y
operator|=
name|y
operator|->
name|right
expr_stmt|;
comment|//   z's successor.  x might be null.
while|while
condition|(
name|y
operator|->
name|left
operator|!=
literal|0
condition|)
name|y
operator|=
name|y
operator|->
name|left
expr_stmt|;
name|x
operator|=
name|y
operator|->
name|right
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|!=
name|z
condition|)
block|{
comment|// relink y in place of z.  y is z's successor
name|z
operator|->
name|left
operator|->
name|parent
operator|=
name|y
expr_stmt|;
name|y
operator|->
name|left
operator|=
name|z
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|y
operator|!=
name|z
operator|->
name|right
condition|)
block|{
name|x_parent
operator|=
name|y
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|x
condition|)
name|x
operator|->
name|parent
operator|=
name|y
operator|->
name|parent
expr_stmt|;
name|y
operator|->
name|parent
operator|->
name|left
operator|=
name|x
expr_stmt|;
comment|// y must be a left child
name|y
operator|->
name|right
operator|=
name|z
operator|->
name|right
expr_stmt|;
name|z
operator|->
name|right
operator|->
name|parent
operator|=
name|y
expr_stmt|;
block|}
else|else
name|x_parent
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|root
operator|==
name|z
condition|)
name|root
operator|=
name|y
expr_stmt|;
elseif|else
if|if
condition|(
name|z
operator|->
name|parent
operator|->
name|left
operator|==
name|z
condition|)
name|z
operator|->
name|parent
operator|->
name|left
operator|=
name|y
expr_stmt|;
else|else
name|z
operator|->
name|parent
operator|->
name|right
operator|=
name|y
expr_stmt|;
name|y
operator|->
name|parent
operator|=
name|z
operator|->
name|parent
expr_stmt|;
name|__STD
operator|::
name|swap
argument_list|(
name|y
operator|->
name|color
argument_list|,
name|z
operator|->
name|color
argument_list|)
expr_stmt|;
name|y
operator|=
name|z
expr_stmt|;
comment|// y now points to node to be actually deleted
block|}
else|else
block|{
comment|// y == z
name|x_parent
operator|=
name|y
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|x
condition|)
name|x
operator|->
name|parent
operator|=
name|y
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|root
operator|==
name|z
condition|)
name|root
operator|=
name|x
expr_stmt|;
elseif|else
if|if
condition|(
name|z
operator|->
name|parent
operator|->
name|left
operator|==
name|z
condition|)
name|z
operator|->
name|parent
operator|->
name|left
operator|=
name|x
expr_stmt|;
else|else
name|z
operator|->
name|parent
operator|->
name|right
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|leftmost
operator|==
name|z
condition|)
if|if
condition|(
name|z
operator|->
name|right
operator|==
literal|0
condition|)
comment|// z->left must be null also
name|leftmost
operator|=
name|z
operator|->
name|parent
expr_stmt|;
comment|// makes leftmost == header if z == root
else|else
name|leftmost
operator|=
name|__rb_tree_node_base
operator|::
name|minimum
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|rightmost
operator|==
name|z
condition|)
if|if
condition|(
name|z
operator|->
name|left
operator|==
literal|0
condition|)
comment|// z->right must be null also
name|rightmost
operator|=
name|z
operator|->
name|parent
expr_stmt|;
comment|// makes rightmost == header if z == root
else|else
comment|// x == z->left
name|rightmost
operator|=
name|__rb_tree_node_base
operator|::
name|maximum
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|->
name|color
operator|!=
name|__rb_tree_red
condition|)
block|{
while|while
condition|(
name|x
operator|!=
name|root
operator|&&
operator|(
name|x
operator|==
literal|0
operator|||
name|x
operator|->
name|color
operator|==
name|__rb_tree_black
operator|)
condition|)
if|if
condition|(
name|x
operator|==
name|x_parent
operator|->
name|left
condition|)
block|{
name|__rb_tree_node_base
modifier|*
name|w
init|=
name|x_parent
operator|->
name|right
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|color
operator|==
name|__rb_tree_red
condition|)
block|{
name|w
operator|->
name|color
operator|=
name|__rb_tree_black
expr_stmt|;
name|x_parent
operator|->
name|color
operator|=
name|__rb_tree_red
expr_stmt|;
name|__rb_tree_rotate_left
argument_list|(
name|x_parent
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|w
operator|=
name|x_parent
operator|->
name|right
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|w
operator|->
name|left
operator|==
literal|0
operator|||
name|w
operator|->
name|left
operator|->
name|color
operator|==
name|__rb_tree_black
operator|)
operator|&&
operator|(
name|w
operator|->
name|right
operator|==
literal|0
operator|||
name|w
operator|->
name|right
operator|->
name|color
operator|==
name|__rb_tree_black
operator|)
condition|)
block|{
name|w
operator|->
name|color
operator|=
name|__rb_tree_red
expr_stmt|;
name|x
operator|=
name|x_parent
expr_stmt|;
name|x_parent
operator|=
name|x_parent
operator|->
name|parent
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|w
operator|->
name|right
operator|==
literal|0
operator|||
name|w
operator|->
name|right
operator|->
name|color
operator|==
name|__rb_tree_black
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|left
condition|)
name|w
operator|->
name|left
operator|->
name|color
operator|=
name|__rb_tree_black
expr_stmt|;
name|w
operator|->
name|color
operator|=
name|__rb_tree_red
expr_stmt|;
name|__rb_tree_rotate_right
argument_list|(
name|w
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|w
operator|=
name|x_parent
operator|->
name|right
expr_stmt|;
block|}
name|w
operator|->
name|color
operator|=
name|x_parent
operator|->
name|color
expr_stmt|;
name|x_parent
operator|->
name|color
operator|=
name|__rb_tree_black
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|right
condition|)
name|w
operator|->
name|right
operator|->
name|color
operator|=
name|__rb_tree_black
expr_stmt|;
name|__rb_tree_rotate_left
argument_list|(
name|x_parent
argument_list|,
name|root
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|// same as above, with right<-> left.
name|__rb_tree_node_base
modifier|*
name|w
init|=
name|x_parent
operator|->
name|left
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|color
operator|==
name|__rb_tree_red
condition|)
block|{
name|w
operator|->
name|color
operator|=
name|__rb_tree_black
expr_stmt|;
name|x_parent
operator|->
name|color
operator|=
name|__rb_tree_red
expr_stmt|;
name|__rb_tree_rotate_right
argument_list|(
name|x_parent
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|w
operator|=
name|x_parent
operator|->
name|left
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|w
operator|->
name|right
operator|==
literal|0
operator|||
name|w
operator|->
name|right
operator|->
name|color
operator|==
name|__rb_tree_black
operator|)
operator|&&
operator|(
name|w
operator|->
name|left
operator|==
literal|0
operator|||
name|w
operator|->
name|left
operator|->
name|color
operator|==
name|__rb_tree_black
operator|)
condition|)
block|{
name|w
operator|->
name|color
operator|=
name|__rb_tree_red
expr_stmt|;
name|x
operator|=
name|x_parent
expr_stmt|;
name|x_parent
operator|=
name|x_parent
operator|->
name|parent
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|w
operator|->
name|left
operator|==
literal|0
operator|||
name|w
operator|->
name|left
operator|->
name|color
operator|==
name|__rb_tree_black
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|right
condition|)
name|w
operator|->
name|right
operator|->
name|color
operator|=
name|__rb_tree_black
expr_stmt|;
name|w
operator|->
name|color
operator|=
name|__rb_tree_red
expr_stmt|;
name|__rb_tree_rotate_left
argument_list|(
name|w
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|w
operator|=
name|x_parent
operator|->
name|left
expr_stmt|;
block|}
name|w
operator|->
name|color
operator|=
name|x_parent
operator|->
name|color
expr_stmt|;
name|x_parent
operator|->
name|color
operator|=
name|__rb_tree_black
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|left
condition|)
name|w
operator|->
name|left
operator|->
name|color
operator|=
name|__rb_tree_black
expr_stmt|;
name|__rb_tree_rotate_right
argument_list|(
name|x_parent
argument_list|,
name|root
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|x
condition|)
name|x
operator|->
name|color
operator|=
name|__rb_tree_black
expr_stmt|;
block|}
return|return
name|y
return|;
block|}
end_function

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|,
name|class
name|Alloc
operator|=
name|alloc
operator|>
name|class
name|rb_tree
block|{
name|protected
operator|:
typedef|typedef
name|void
modifier|*
name|void_pointer
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|__rb_tree_node_base
modifier|*
name|base_ptr
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|__rb_tree_node
operator|<
name|Value
operator|>
name|rb_tree_node
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|simple_alloc
operator|<
name|rb_tree_node
operator|,
name|Alloc
operator|>
name|rb_tree_node_allocator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|__rb_tree_color_type
name|color_type
typedef|;
end_typedef

begin_label
name|public
label|:
end_label

begin_typedef
typedef|typedef
name|Key
name|key_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|Value
name|value_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|value_type
modifier|*
name|pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|value_type
modifier|*
name|const_pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|value_type
modifier|&
name|reference
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|value_type
modifier|&
name|const_reference
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|rb_tree_node
modifier|*
name|link_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|size_t
name|size_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|ptrdiff_t
name|difference_type
typedef|;
end_typedef

begin_label
name|protected
label|:
end_label

begin_function
name|link_type
name|get_node
parameter_list|()
block|{
return|return
name|rb_tree_node_allocator
operator|::
name|allocate
argument_list|()
return|;
block|}
end_function

begin_function
name|void
name|put_node
parameter_list|(
name|link_type
name|p
parameter_list|)
block|{
name|rb_tree_node_allocator
operator|::
name|deallocate
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|link_type
name|create_node
parameter_list|(
specifier|const
name|value_type
modifier|&
name|x
parameter_list|)
block|{
name|link_type
name|tmp
init|=
name|get_node
argument_list|()
decl_stmt|;
name|__STL_TRY
block|{
name|construct
argument_list|(
operator|&
name|tmp
operator|->
name|value_field
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|__STL_UNWIND
argument_list|(
name|put_node
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_function
name|link_type
name|clone_node
parameter_list|(
name|link_type
name|x
parameter_list|)
block|{
name|link_type
name|tmp
init|=
name|create_node
argument_list|(
name|x
operator|->
name|value_field
argument_list|)
decl_stmt|;
name|tmp
operator|->
name|color
operator|=
name|x
operator|->
name|color
expr_stmt|;
name|tmp
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|tmp
operator|->
name|right
operator|=
literal|0
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_function
name|void
name|destroy_node
parameter_list|(
name|link_type
name|p
parameter_list|)
block|{
name|destroy
argument_list|(
operator|&
name|p
operator|->
name|value_field
argument_list|)
expr_stmt|;
name|put_node
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|protected
label|:
end_label

begin_decl_stmt
name|size_type
name|node_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|// keeps track of size of tree
end_comment

begin_decl_stmt
name|link_type
name|header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Compare
name|key_compare
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|link_type
operator|&
name|root
argument_list|()
specifier|const
block|{
return|return
operator|(
name|link_type
operator|&
operator|)
name|header
operator|->
name|parent
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|link_type
operator|&
name|leftmost
argument_list|()
specifier|const
block|{
return|return
operator|(
name|link_type
operator|&
operator|)
name|header
operator|->
name|left
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|link_type
operator|&
name|rightmost
argument_list|()
specifier|const
block|{
return|return
operator|(
name|link_type
operator|&
operator|)
name|header
operator|->
name|right
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|link_type
modifier|&
name|left
parameter_list|(
name|link_type
name|x
parameter_list|)
block|{
return|return
operator|(
name|link_type
operator|&
operator|)
operator|(
name|x
operator|->
name|left
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|link_type
modifier|&
name|right
parameter_list|(
name|link_type
name|x
parameter_list|)
block|{
return|return
operator|(
name|link_type
operator|&
operator|)
operator|(
name|x
operator|->
name|right
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|link_type
modifier|&
name|parent
parameter_list|(
name|link_type
name|x
parameter_list|)
block|{
return|return
operator|(
name|link_type
operator|&
operator|)
operator|(
name|x
operator|->
name|parent
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|reference
name|value
parameter_list|(
name|link_type
name|x
parameter_list|)
block|{
return|return
name|x
operator|->
name|value_field
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|Key
modifier|&
name|key
parameter_list|(
name|link_type
name|x
parameter_list|)
block|{
return|return
name|KeyOfValue
argument_list|()
argument_list|(
name|value
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|color_type
modifier|&
name|color
parameter_list|(
name|link_type
name|x
parameter_list|)
block|{
return|return
operator|(
name|color_type
operator|&
operator|)
operator|(
name|x
operator|->
name|color
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|link_type
modifier|&
name|left
parameter_list|(
name|base_ptr
name|x
parameter_list|)
block|{
return|return
operator|(
name|link_type
operator|&
operator|)
operator|(
name|x
operator|->
name|left
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|link_type
modifier|&
name|right
parameter_list|(
name|base_ptr
name|x
parameter_list|)
block|{
return|return
operator|(
name|link_type
operator|&
operator|)
operator|(
name|x
operator|->
name|right
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|link_type
modifier|&
name|parent
parameter_list|(
name|base_ptr
name|x
parameter_list|)
block|{
return|return
operator|(
name|link_type
operator|&
operator|)
operator|(
name|x
operator|->
name|parent
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|reference
name|value
parameter_list|(
name|base_ptr
name|x
parameter_list|)
block|{
return|return
operator|(
operator|(
name|link_type
operator|)
name|x
operator|)
operator|->
name|value_field
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|Key
modifier|&
name|key
parameter_list|(
name|base_ptr
name|x
parameter_list|)
block|{
return|return
name|KeyOfValue
argument_list|()
argument_list|(
name|value
argument_list|(
name|link_type
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|color_type
modifier|&
name|color
parameter_list|(
name|base_ptr
name|x
parameter_list|)
block|{
return|return
operator|(
name|color_type
operator|&
operator|)
operator|(
name|link_type
argument_list|(
name|x
argument_list|)
operator|->
name|color
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|link_type
name|minimum
parameter_list|(
name|link_type
name|x
parameter_list|)
block|{
return|return
operator|(
name|link_type
operator|)
name|__rb_tree_node_base
operator|::
name|minimum
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|link_type
name|maximum
parameter_list|(
name|link_type
name|x
parameter_list|)
block|{
return|return
operator|(
name|link_type
operator|)
name|__rb_tree_node_base
operator|::
name|maximum
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_label
name|public
label|:
end_label

begin_typedef
typedef|typedef
name|__rb_tree_iterator
operator|<
name|value_type
operator|,
name|reference
operator|,
name|pointer
operator|>
name|iterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|__rb_tree_iterator
operator|<
name|value_type
operator|,
name|const_reference
operator|,
name|const_pointer
operator|>
name|const_iterator
expr_stmt|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|__STL_CLASS_PARTIAL_SPECIALIZATION
end_ifdef

begin_typedef
typedef|typedef
name|reverse_iterator
operator|<
name|const_iterator
operator|>
name|const_reverse_iterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|reverse_iterator
operator|<
name|iterator
operator|>
name|reverse_iterator
expr_stmt|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __STL_CLASS_PARTIAL_SPECIALIZATION */
end_comment

begin_typedef
typedef|typedef
name|reverse_bidirectional_iterator
operator|<
name|iterator
operator|,
name|value_type
operator|,
name|reference
operator|,
name|difference_type
operator|>
name|reverse_iterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|reverse_bidirectional_iterator
operator|<
name|const_iterator
operator|,
name|value_type
operator|,
name|const_reference
operator|,
name|difference_type
operator|>
name|const_reverse_iterator
expr_stmt|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STL_CLASS_PARTIAL_SPECIALIZATION */
end_comment

begin_label
name|private
label|:
end_label

begin_function_decl
name|iterator
name|__insert
parameter_list|(
name|base_ptr
name|x
parameter_list|,
name|base_ptr
name|y
parameter_list|,
specifier|const
name|value_type
modifier|&
name|v
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|link_type
name|__copy
parameter_list|(
name|link_type
name|x
parameter_list|,
name|link_type
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__erase
parameter_list|(
name|link_type
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|init
parameter_list|()
block|{
name|header
operator|=
name|get_node
argument_list|()
expr_stmt|;
name|color
argument_list|(
name|header
argument_list|)
operator|=
name|__rb_tree_red
expr_stmt|;
comment|// used to distinguish header from
comment|// root, in iterator.operator++
name|root
argument_list|()
operator|=
literal|0
expr_stmt|;
name|leftmost
argument_list|()
operator|=
name|header
expr_stmt|;
name|rightmost
argument_list|()
operator|=
name|header
expr_stmt|;
block|}
end_function

begin_label
name|public
label|:
end_label

begin_comment
comment|// allocation/deallocation
end_comment

begin_expr_stmt
name|rb_tree
argument_list|(
specifier|const
name|Compare
operator|&
name|comp
operator|=
name|Compare
argument_list|()
argument_list|)
operator|:
name|node_count
argument_list|(
literal|0
argument_list|)
operator|,
name|key_compare
argument_list|(
argument|comp
argument_list|)
block|{
name|init
argument_list|()
block|; }
name|rb_tree
argument_list|(
specifier|const
name|rb_tree
operator|<
name|Key
argument_list|,
name|Value
argument_list|,
name|KeyOfValue
argument_list|,
name|Compare
argument_list|,
name|Alloc
operator|>
operator|&
name|x
argument_list|)
operator|:
name|node_count
argument_list|(
literal|0
argument_list|)
operator|,
name|key_compare
argument_list|(
argument|x.key_compare
argument_list|)
block|{
name|header
operator|=
name|get_node
argument_list|()
block|;
name|color
argument_list|(
name|header
argument_list|)
operator|=
name|__rb_tree_red
block|;
if|if
condition|(
name|x
operator|.
name|root
argument_list|()
operator|==
literal|0
condition|)
block|{
name|root
argument_list|()
operator|=
literal|0
expr_stmt|;
name|leftmost
argument_list|()
operator|=
name|header
expr_stmt|;
name|rightmost
argument_list|()
operator|=
name|header
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|__STL_TRY
block|{
name|root
argument_list|()
operator|=
name|__copy
argument_list|(
name|x
operator|.
name|root
argument_list|()
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
name|__STL_UNWIND
argument_list|(
name|put_node
argument_list|(
name|header
argument_list|)
argument_list|)
expr_stmt|;
name|leftmost
argument_list|()
operator|=
name|minimum
argument_list|(
name|root
argument_list|()
argument_list|)
expr_stmt|;
name|rightmost
argument_list|()
operator|=
name|maximum
argument_list|(
name|root
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_else

begin_expr_stmt
name|node_count
operator|=
name|x
operator|.
name|node_count
expr_stmt|;
end_expr_stmt

begin_macro
unit|}   ~
name|rb_tree
argument_list|()
end_macro

begin_block
block|{
name|clear
argument_list|()
expr_stmt|;
name|put_node
argument_list|(
name|header
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|&
name|operator
operator|=
operator|(
specifier|const
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|&
name|x
operator|)
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_comment
comment|// accessors:
end_comment

begin_expr_stmt
name|Compare
name|key_comp
argument_list|()
specifier|const
block|{
return|return
name|key_compare
return|;
block|}
end_expr_stmt

begin_function
name|iterator
name|begin
parameter_list|()
block|{
return|return
name|leftmost
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|leftmost
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|iterator
name|end
parameter_list|()
block|{
return|return
name|header
return|;
block|}
end_function

begin_expr_stmt
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|header
return|;
block|}
end_expr_stmt

begin_function
name|reverse_iterator
name|rbegin
parameter_list|()
block|{
return|return
name|reverse_iterator
argument_list|(
name|end
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|const_reverse_iterator
name|rbegin
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|end
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|reverse_iterator
name|rend
parameter_list|()
block|{
return|return
name|reverse_iterator
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|const_reverse_iterator
name|rend
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|node_count
operator|==
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|size_type
name|size
argument_list|()
specifier|const
block|{
return|return
name|node_count
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|size_type
name|max_size
argument_list|()
specifier|const
block|{
return|return
name|size_type
argument_list|(
operator|-
literal|1
argument_list|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|void
name|swap
argument_list|(
name|rb_tree
operator|<
name|Key
argument_list|,
name|Value
argument_list|,
name|KeyOfValue
argument_list|,
name|Compare
argument_list|,
name|Alloc
operator|>
operator|&
name|t
argument_list|)
block|{
name|__STD
operator|::
name|swap
argument_list|(
name|header
argument_list|,
name|t
operator|.
name|header
argument_list|)
expr_stmt|;
name|__STD
operator|::
name|swap
argument_list|(
name|node_count
argument_list|,
name|t
operator|.
name|node_count
argument_list|)
expr_stmt|;
name|__STD
operator|::
name|swap
argument_list|(
name|key_compare
argument_list|,
name|t
operator|.
name|key_compare
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_comment
comment|// insert/erase
end_comment

begin_expr_stmt
name|pair
operator|<
name|iterator
operator|,
name|bool
operator|>
name|insert_unique
argument_list|(
specifier|const
name|value_type
operator|&
name|x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
name|iterator
name|insert_equal
parameter_list|(
specifier|const
name|value_type
modifier|&
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|iterator
name|insert_unique
parameter_list|(
name|iterator
name|position
parameter_list|,
specifier|const
name|value_type
modifier|&
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|iterator
name|insert_equal
parameter_list|(
name|iterator
name|position
parameter_list|,
specifier|const
name|value_type
modifier|&
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|__STL_MEMBER_TEMPLATES
end_ifdef

begin_expr_stmt
name|template
operator|<
name|class
name|InputIterator
operator|>
name|void
name|insert_unique
argument_list|(
argument|InputIterator first
argument_list|,
argument|InputIterator last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|InputIterator
operator|>
name|void
name|insert_equal
argument_list|(
argument|InputIterator first
argument_list|,
argument|InputIterator last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __STL_MEMBER_TEMPLATES */
end_comment

begin_function_decl
name|void
name|insert_unique
parameter_list|(
name|const_iterator
name|first
parameter_list|,
name|const_iterator
name|last
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|insert_unique
parameter_list|(
specifier|const
name|value_type
modifier|*
name|first
parameter_list|,
specifier|const
name|value_type
modifier|*
name|last
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|insert_equal
parameter_list|(
name|const_iterator
name|first
parameter_list|,
name|const_iterator
name|last
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|insert_equal
parameter_list|(
specifier|const
name|value_type
modifier|*
name|first
parameter_list|,
specifier|const
name|value_type
modifier|*
name|last
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STL_MEMBER_TEMPLATES */
end_comment

begin_function_decl
name|void
name|erase
parameter_list|(
name|iterator
name|position
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_type
name|erase
parameter_list|(
specifier|const
name|key_type
modifier|&
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|erase
parameter_list|(
name|iterator
name|first
parameter_list|,
name|iterator
name|last
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|erase
parameter_list|(
specifier|const
name|key_type
modifier|*
name|first
parameter_list|,
specifier|const
name|key_type
modifier|*
name|last
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|clear
parameter_list|()
block|{
if|if
condition|(
name|node_count
operator|!=
literal|0
condition|)
block|{
name|__erase
argument_list|(
name|root
argument_list|()
argument_list|)
expr_stmt|;
name|leftmost
argument_list|()
operator|=
name|header
expr_stmt|;
name|root
argument_list|()
operator|=
literal|0
expr_stmt|;
name|rightmost
argument_list|()
operator|=
name|header
expr_stmt|;
name|node_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_label
name|public
label|:
end_label

begin_comment
comment|// set operations:
end_comment

begin_function_decl
name|iterator
name|find
parameter_list|(
specifier|const
name|key_type
modifier|&
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|const_iterator
name|find
argument_list|(
specifier|const
name|key_type
operator|&
name|x
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_type
name|count
argument_list|(
specifier|const
name|key_type
operator|&
name|x
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_function_decl
name|iterator
name|lower_bound
parameter_list|(
specifier|const
name|key_type
modifier|&
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|const_iterator
name|lower_bound
argument_list|(
specifier|const
name|key_type
operator|&
name|x
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_function_decl
name|iterator
name|upper_bound
parameter_list|(
specifier|const
name|key_type
modifier|&
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|const_iterator
name|upper_bound
argument_list|(
specifier|const
name|key_type
operator|&
name|x
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|pair
operator|<
name|iterator
operator|,
name|iterator
operator|>
name|equal_range
argument_list|(
specifier|const
name|key_type
operator|&
name|x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pair
operator|<
name|const_iterator
operator|,
name|const_iterator
operator|>
name|equal_range
argument_list|(
argument|const key_type& x
argument_list|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_comment
comment|// Debugging.
end_comment

begin_expr_stmt
name|bool
name|__rb_verify
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|&
name|x
operator|,
specifier|const
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|&
name|y
operator|)
block|{
return|return
name|x
operator|.
name|size
argument_list|()
operator|==
name|y
operator|.
name|size
argument_list|()
operator|&&
name|equal
argument_list|(
name|x
operator|.
name|begin
argument_list|()
argument_list|,
name|x
operator|.
name|end
argument_list|()
argument_list|,
name|y
operator|.
name|begin
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|&
name|x
operator|,
specifier|const
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|&
name|y
operator|)
block|{
return|return
name|lexicographical_compare
argument_list|(
name|x
operator|.
name|begin
argument_list|()
argument_list|,
name|x
operator|.
name|end
argument_list|()
argument_list|,
name|y
operator|.
name|begin
argument_list|()
argument_list|,
name|y
operator|.
name|end
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__STL_FUNCTION_TMPL_PARTIAL_ORDER
end_ifdef

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|void
name|swap
argument_list|(
argument|rb_tree<Key
argument_list|,
argument|Value
argument_list|,
argument|KeyOfValue
argument_list|,
argument|Compare
argument_list|,
argument|Alloc>& x
argument_list|,
argument|rb_tree<Key
argument_list|,
argument|Value
argument_list|,
argument|KeyOfValue
argument_list|,
argument|Compare
argument_list|,
argument|Alloc>& y
argument_list|)
block|{
name|x
operator|.
name|swap
argument_list|(
name|y
argument_list|)
block|; }
endif|#
directive|endif
comment|/* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|,
name|class
name|Alloc
operator|>
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|&
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|operator
operator|=
operator|(
specifier|const
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|&
name|x
operator|)
block|{
if|if
condition|(
name|this
operator|!=
operator|&
name|x
condition|)
block|{
comment|// Note that Key may be a constant type.
name|clear
argument_list|()
expr_stmt|;
name|node_count
operator|=
literal|0
expr_stmt|;
name|key_compare
operator|=
name|x
operator|.
name|key_compare
expr_stmt|;
if|if
condition|(
name|x
operator|.
name|root
argument_list|()
operator|==
literal|0
condition|)
block|{
name|root
argument_list|()
operator|=
literal|0
expr_stmt|;
name|leftmost
argument_list|()
operator|=
name|header
expr_stmt|;
name|rightmost
argument_list|()
operator|=
name|header
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|root
argument_list|()
operator|=
name|__copy
argument_list|(
name|x
operator|.
name|root
argument_list|()
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|leftmost
argument_list|()
operator|=
name|minimum
argument_list|(
name|root
argument_list|()
argument_list|)
expr_stmt|;
name|rightmost
argument_list|()
operator|=
name|maximum
argument_list|(
name|root
argument_list|()
argument_list|)
expr_stmt|;
name|node_count
operator|=
name|x
operator|.
name|node_count
expr_stmt|;
block|}
end_else

begin_expr_stmt
unit|}   return
operator|*
name|this
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|,
name|class
name|Alloc
operator|>
name|typename
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|iterator
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|__insert
argument_list|(
argument|base_ptr x_
argument_list|,
argument|base_ptr y_
argument_list|,
argument|const Value& v
argument_list|)
block|{
name|link_type
name|x
operator|=
operator|(
name|link_type
operator|)
name|x_
block|;
name|link_type
name|y
operator|=
operator|(
name|link_type
operator|)
name|y_
block|;
name|link_type
name|z
block|;
if|if
condition|(
name|y
operator|==
name|header
operator|||
name|x
operator|!=
literal|0
operator|||
name|key_compare
argument_list|(
name|KeyOfValue
argument_list|()
argument_list|(
name|v
argument_list|)
argument_list|,
name|key
argument_list|(
name|y
argument_list|)
argument_list|)
condition|)
block|{
name|z
operator|=
name|create_node
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|left
argument_list|(
name|y
argument_list|)
operator|=
name|z
expr_stmt|;
comment|// also makes leftmost() = z when y == header
if|if
condition|(
name|y
operator|==
name|header
condition|)
block|{
name|root
argument_list|()
operator|=
name|z
expr_stmt|;
name|rightmost
argument_list|()
operator|=
name|z
expr_stmt|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
name|y
operator|==
name|leftmost
argument_list|()
condition|)
name|leftmost
argument_list|()
operator|=
name|z
expr_stmt|;
end_elseif

begin_comment
comment|// maintain leftmost() pointing to min node
end_comment

begin_block
unit|}   else
block|{
name|z
operator|=
name|create_node
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|right
argument_list|(
name|y
argument_list|)
operator|=
name|z
expr_stmt|;
if|if
condition|(
name|y
operator|==
name|rightmost
argument_list|()
condition|)
name|rightmost
argument_list|()
operator|=
name|z
expr_stmt|;
comment|// maintain rightmost() pointing to max node
block|}
end_block

begin_expr_stmt
name|parent
argument_list|(
name|z
argument_list|)
operator|=
name|y
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|left
argument_list|(
name|z
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|right
argument_list|(
name|z
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__rb_tree_rebalance
argument_list|(
name|z
argument_list|,
name|header
operator|->
name|parent
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|++
name|node_count
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|iterator
argument_list|(
name|z
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|,
name|class
name|Alloc
operator|>
name|typename
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|iterator
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|insert_equal
argument_list|(
argument|const Value& v
argument_list|)
block|{
name|link_type
name|y
operator|=
name|header
block|;
name|link_type
name|x
operator|=
name|root
argument_list|()
block|;
while|while
condition|(
name|x
operator|!=
literal|0
condition|)
block|{
name|y
operator|=
name|x
expr_stmt|;
name|x
operator|=
name|key_compare
argument_list|(
name|KeyOfValue
argument_list|()
argument_list|(
name|v
argument_list|)
argument_list|,
name|key
argument_list|(
name|x
argument_list|)
argument_list|)
condition|?
name|left
argument_list|(
name|x
argument_list|)
else|:
name|right
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|__insert
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|v
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}   template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|,
name|class
name|Alloc
operator|>
name|pair
operator|<
name|typename
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|iterator
operator|,
name|bool
operator|>
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|insert_unique
argument_list|(
argument|const Value& v
argument_list|)
block|{
name|link_type
name|y
operator|=
name|header
block|;
name|link_type
name|x
operator|=
name|root
argument_list|()
block|;
name|bool
name|comp
operator|=
name|true
block|;
while|while
condition|(
name|x
operator|!=
literal|0
condition|)
block|{
name|y
operator|=
name|x
expr_stmt|;
name|comp
operator|=
name|key_compare
argument_list|(
name|KeyOfValue
argument_list|()
argument_list|(
name|v
argument_list|)
argument_list|,
name|key
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|comp
condition|?
name|left
argument_list|(
name|x
argument_list|)
else|:
name|right
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|iterator
name|j
operator|=
name|iterator
argument_list|(
name|y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|comp
condition|)
if|if
condition|(
name|j
operator|==
name|begin
argument_list|()
condition|)
return|return
name|pair
operator|<
name|iterator
operator|,
name|bool
operator|>
operator|(
name|__insert
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|v
argument_list|)
operator|,
name|true
operator|)
return|;
else|else
operator|--
name|j
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|key_compare
argument_list|(
name|key
argument_list|(
name|j
operator|.
name|node
argument_list|)
argument_list|,
name|KeyOfValue
argument_list|()
argument_list|(
name|v
argument_list|)
argument_list|)
condition|)
return|return
name|pair
operator|<
name|iterator
operator|,
name|bool
operator|>
operator|(
name|__insert
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|v
argument_list|)
operator|,
name|true
operator|)
return|;
end_if

begin_return
return|return
name|pair
operator|<
name|iterator
operator|,
name|bool
operator|>
operator|(
name|j
operator|,
name|false
operator|)
return|;
end_return

begin_expr_stmt
unit|}   template
operator|<
name|class
name|Key
operator|,
name|class
name|Val
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|,
name|class
name|Alloc
operator|>
name|typename
name|rb_tree
operator|<
name|Key
operator|,
name|Val
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|iterator
name|rb_tree
operator|<
name|Key
operator|,
name|Val
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|insert_unique
argument_list|(
argument|iterator position
argument_list|,
argument|const Val& v
argument_list|)
block|{
if|if
condition|(
name|position
operator|.
name|node
operator|==
name|header
operator|->
name|left
condition|)
comment|// begin()
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|key_compare
argument_list|(
name|KeyOfValue
argument_list|()
argument_list|(
name|v
argument_list|)
argument_list|,
name|key
argument_list|(
name|position
operator|.
name|node
argument_list|)
argument_list|)
condition|)
return|return
name|__insert
argument_list|(
name|position
operator|.
name|node
argument_list|,
name|position
operator|.
name|node
argument_list|,
name|v
argument_list|)
return|;
comment|// first argument just needs to be non-null
else|else
return|return
name|insert_unique
argument_list|(
name|v
argument_list|)
operator|.
name|first
return|;
elseif|else
if|if
condition|(
name|position
operator|.
name|node
operator|==
name|header
condition|)
comment|// end()
if|if
condition|(
name|key_compare
argument_list|(
name|key
argument_list|(
name|rightmost
argument_list|()
argument_list|)
argument_list|,
name|KeyOfValue
argument_list|()
argument_list|(
name|v
argument_list|)
argument_list|)
condition|)
return|return
name|__insert
argument_list|(
literal|0
argument_list|,
name|rightmost
argument_list|()
argument_list|,
name|v
argument_list|)
return|;
else|else
return|return
name|insert_unique
argument_list|(
name|v
argument_list|)
operator|.
name|first
return|;
else|else
block|{
name|iterator
name|before
init|=
name|position
decl_stmt|;
operator|--
name|before
expr_stmt|;
if|if
condition|(
name|key_compare
argument_list|(
name|key
argument_list|(
name|before
operator|.
name|node
argument_list|)
argument_list|,
name|KeyOfValue
argument_list|()
argument_list|(
name|v
argument_list|)
argument_list|)
operator|&&
name|key_compare
argument_list|(
name|KeyOfValue
argument_list|()
argument_list|(
name|v
argument_list|)
argument_list|,
name|key
argument_list|(
name|position
operator|.
name|node
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|right
argument_list|(
name|before
operator|.
name|node
argument_list|)
operator|==
literal|0
condition|)
return|return
name|__insert
argument_list|(
literal|0
argument_list|,
name|before
operator|.
name|node
argument_list|,
name|v
argument_list|)
return|;
else|else
return|return
name|__insert
argument_list|(
name|position
operator|.
name|node
argument_list|,
name|position
operator|.
name|node
argument_list|,
name|v
argument_list|)
return|;
comment|// first argument just needs to be non-null
else|else
return|return
name|insert_unique
argument_list|(
name|v
argument_list|)
operator|.
name|first
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Key
operator|,
name|class
name|Val
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|,
name|class
name|Alloc
operator|>
name|typename
name|rb_tree
operator|<
name|Key
operator|,
name|Val
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|iterator
name|rb_tree
operator|<
name|Key
operator|,
name|Val
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|insert_equal
argument_list|(
argument|iterator position
argument_list|,
argument|const Val& v
argument_list|)
block|{
if|if
condition|(
name|position
operator|.
name|node
operator|==
name|header
operator|->
name|left
condition|)
comment|// begin()
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|key_compare
argument_list|(
name|KeyOfValue
argument_list|()
argument_list|(
name|v
argument_list|)
argument_list|,
name|key
argument_list|(
name|position
operator|.
name|node
argument_list|)
argument_list|)
condition|)
return|return
name|__insert
argument_list|(
name|position
operator|.
name|node
argument_list|,
name|position
operator|.
name|node
argument_list|,
name|v
argument_list|)
return|;
comment|// first argument just needs to be non-null
else|else
return|return
name|insert_equal
argument_list|(
name|v
argument_list|)
return|;
elseif|else
if|if
condition|(
name|position
operator|.
name|node
operator|==
name|header
condition|)
comment|// end()
if|if
condition|(
operator|!
name|key_compare
argument_list|(
name|KeyOfValue
argument_list|()
argument_list|(
name|v
argument_list|)
argument_list|,
name|key
argument_list|(
name|rightmost
argument_list|()
argument_list|)
argument_list|)
condition|)
return|return
name|__insert
argument_list|(
literal|0
argument_list|,
name|rightmost
argument_list|()
argument_list|,
name|v
argument_list|)
return|;
else|else
return|return
name|insert_equal
argument_list|(
name|v
argument_list|)
return|;
else|else
block|{
name|iterator
name|before
init|=
name|position
decl_stmt|;
operator|--
name|before
expr_stmt|;
if|if
condition|(
operator|!
name|key_compare
argument_list|(
name|KeyOfValue
argument_list|()
argument_list|(
name|v
argument_list|)
argument_list|,
name|key
argument_list|(
name|before
operator|.
name|node
argument_list|)
argument_list|)
operator|&&
operator|!
name|key_compare
argument_list|(
name|key
argument_list|(
name|position
operator|.
name|node
argument_list|)
argument_list|,
name|KeyOfValue
argument_list|()
argument_list|(
name|v
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|right
argument_list|(
name|before
operator|.
name|node
argument_list|)
operator|==
literal|0
condition|)
return|return
name|__insert
argument_list|(
literal|0
argument_list|,
name|before
operator|.
name|node
argument_list|,
name|v
argument_list|)
return|;
else|else
return|return
name|__insert
argument_list|(
name|position
operator|.
name|node
argument_list|,
name|position
operator|.
name|node
argument_list|,
name|v
argument_list|)
return|;
comment|// first argument just needs to be non-null
else|else
return|return
name|insert_equal
argument_list|(
name|v
argument_list|)
return|;
block|}
end_expr_stmt

begin_ifdef
unit|}
ifdef|#
directive|ifdef
name|__STL_MEMBER_TEMPLATES
end_ifdef

begin_expr_stmt
unit|template
operator|<
name|class
name|K
operator|,
name|class
name|V
operator|,
name|class
name|KoV
operator|,
name|class
name|Cmp
operator|,
name|class
name|Al
operator|>
name|template
operator|<
name|class
name|II
operator|>
name|void
name|rb_tree
operator|<
name|K
operator|,
name|V
operator|,
name|KoV
operator|,
name|Cmp
operator|,
name|Al
operator|>
operator|::
name|insert_equal
argument_list|(
argument|II first
argument_list|,
argument|II last
argument_list|)
block|{
for|for
control|(
init|;
name|first
operator|!=
name|last
condition|;
operator|++
name|first
control|)
name|insert_equal
argument_list|(
operator|*
name|first
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|K
operator|,
name|class
name|V
operator|,
name|class
name|KoV
operator|,
name|class
name|Cmp
operator|,
name|class
name|Al
operator|>
name|template
operator|<
name|class
name|II
operator|>
name|void
name|rb_tree
operator|<
name|K
operator|,
name|V
operator|,
name|KoV
operator|,
name|Cmp
operator|,
name|Al
operator|>
operator|::
name|insert_unique
argument_list|(
argument|II first
argument_list|,
argument|II last
argument_list|)
block|{
for|for
control|(
init|;
name|first
operator|!=
name|last
condition|;
operator|++
name|first
control|)
name|insert_unique
argument_list|(
operator|*
name|first
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __STL_MEMBER_TEMPLATES */
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|K
operator|,
name|class
name|V
operator|,
name|class
name|KoV
operator|,
name|class
name|Cmp
operator|,
name|class
name|Al
operator|>
name|void
name|rb_tree
operator|<
name|K
operator|,
name|V
operator|,
name|KoV
operator|,
name|Cmp
operator|,
name|Al
operator|>
operator|::
name|insert_equal
argument_list|(
argument|const V* first
argument_list|,
argument|const V* last
argument_list|)
block|{
for|for
control|(
init|;
name|first
operator|!=
name|last
condition|;
operator|++
name|first
control|)
name|insert_equal
argument_list|(
operator|*
name|first
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|K
operator|,
name|class
name|V
operator|,
name|class
name|KoV
operator|,
name|class
name|Cmp
operator|,
name|class
name|Al
operator|>
name|void
name|rb_tree
operator|<
name|K
operator|,
name|V
operator|,
name|KoV
operator|,
name|Cmp
operator|,
name|Al
operator|>
operator|::
name|insert_equal
argument_list|(
argument|const_iterator first
argument_list|,
argument|const_iterator last
argument_list|)
block|{
for|for
control|(
init|;
name|first
operator|!=
name|last
condition|;
operator|++
name|first
control|)
name|insert_equal
argument_list|(
operator|*
name|first
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|K
operator|,
name|class
name|V
operator|,
name|class
name|KoV
operator|,
name|class
name|Cmp
operator|,
name|class
name|A
operator|>
name|void
name|rb_tree
operator|<
name|K
operator|,
name|V
operator|,
name|KoV
operator|,
name|Cmp
operator|,
name|A
operator|>
operator|::
name|insert_unique
argument_list|(
argument|const V* first
argument_list|,
argument|const V* last
argument_list|)
block|{
for|for
control|(
init|;
name|first
operator|!=
name|last
condition|;
operator|++
name|first
control|)
name|insert_unique
argument_list|(
operator|*
name|first
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|K
operator|,
name|class
name|V
operator|,
name|class
name|KoV
operator|,
name|class
name|Cmp
operator|,
name|class
name|A
operator|>
name|void
name|rb_tree
operator|<
name|K
operator|,
name|V
operator|,
name|KoV
operator|,
name|Cmp
operator|,
name|A
operator|>
operator|::
name|insert_unique
argument_list|(
argument|const_iterator first
argument_list|,
argument|const_iterator last
argument_list|)
block|{
for|for
control|(
init|;
name|first
operator|!=
name|last
condition|;
operator|++
name|first
control|)
name|insert_unique
argument_list|(
operator|*
name|first
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STL_MEMBER_TEMPLATES */
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|void
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|erase
argument_list|(
argument|iterator position
argument_list|)
block|{
name|link_type
name|y
operator|=
operator|(
name|link_type
operator|)
name|__rb_tree_rebalance_for_erase
argument_list|(
name|position
operator|.
name|node
argument_list|,
name|header
operator|->
name|parent
argument_list|,
name|header
operator|->
name|left
argument_list|,
name|header
operator|->
name|right
argument_list|)
block|;
name|destroy_node
argument_list|(
name|y
argument_list|)
block|;
operator|--
name|node_count
block|; }
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|,
name|class
name|Alloc
operator|>
name|typename
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|size_type
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|erase
argument_list|(
argument|const Key& x
argument_list|)
block|{
name|pair
operator|<
name|iterator
block|,
name|iterator
operator|>
name|p
operator|=
name|equal_range
argument_list|(
name|x
argument_list|)
block|;
name|size_type
name|n
operator|=
literal|0
block|;
name|distance
argument_list|(
name|p
operator|.
name|first
argument_list|,
name|p
operator|.
name|second
argument_list|,
name|n
argument_list|)
block|;
name|erase
argument_list|(
name|p
operator|.
name|first
argument_list|,
name|p
operator|.
name|second
argument_list|)
block|;
return|return
name|n
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|K
operator|,
name|class
name|V
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|,
name|class
name|Alloc
operator|>
name|typename
name|rb_tree
operator|<
name|K
operator|,
name|V
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|link_type
name|rb_tree
operator|<
name|K
operator|,
name|V
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|__copy
argument_list|(
argument|link_type x
argument_list|,
argument|link_type p
argument_list|)
block|{
comment|// structural copy.  x and p must be non-null.
name|link_type
name|top
operator|=
name|clone_node
argument_list|(
name|x
argument_list|)
block|;
name|top
operator|->
name|parent
operator|=
name|p
block|;
name|__STL_TRY
block|{
if|if
condition|(
name|x
operator|->
name|right
condition|)
name|top
operator|->
name|right
operator|=
name|__copy
argument_list|(
name|right
argument_list|(
name|x
argument_list|)
argument_list|,
name|top
argument_list|)
expr_stmt|;
name|p
operator|=
name|top
block|;
name|x
operator|=
name|left
argument_list|(
name|x
argument_list|)
block|;
while|while
condition|(
name|x
operator|!=
literal|0
condition|)
block|{
name|link_type
name|y
init|=
name|clone_node
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|p
operator|->
name|left
operator|=
name|y
expr_stmt|;
name|y
operator|->
name|parent
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|right
condition|)
name|y
operator|->
name|right
operator|=
name|__copy
argument_list|(
name|right
argument_list|(
name|x
argument_list|)
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|p
operator|=
name|y
expr_stmt|;
name|x
operator|=
name|left
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}   __STL_UNWIND
operator|(
name|__erase
argument_list|(
name|top
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|top
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|,
name|class
name|Alloc
operator|>
name|void
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|__erase
argument_list|(
argument|link_type x
argument_list|)
block|{
comment|// erase without rebalancing
while|while
condition|(
name|x
operator|!=
literal|0
condition|)
block|{
name|__erase
argument_list|(
name|right
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|link_type
name|y
init|=
name|left
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|destroy_node
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|y
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|,
name|class
name|Alloc
operator|>
name|void
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|erase
argument_list|(
argument|iterator first
argument_list|,
argument|iterator last
argument_list|)
block|{
if|if
condition|(
name|first
operator|==
name|begin
argument_list|()
operator|&&
name|last
operator|==
name|end
argument_list|()
condition|)
name|clear
argument_list|()
expr_stmt|;
else|else
while|while
condition|(
name|first
operator|!=
name|last
condition|)
name|erase
argument_list|(
name|first
operator|++
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|,
name|class
name|Alloc
operator|>
name|void
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|erase
argument_list|(
argument|const Key* first
argument_list|,
argument|const Key* last
argument_list|)
block|{
while|while
condition|(
name|first
operator|!=
name|last
condition|)
name|erase
argument_list|(
operator|*
name|first
operator|++
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|,
name|class
name|Alloc
operator|>
name|typename
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|iterator
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|find
argument_list|(
argument|const Key& k
argument_list|)
block|{
name|link_type
name|y
operator|=
name|header
block|;
comment|// Last node which is not less than k.
name|link_type
name|x
operator|=
name|root
argument_list|()
block|;
comment|// Current node.
while|while
condition|(
name|x
operator|!=
literal|0
condition|)
if|if
condition|(
operator|!
name|key_compare
argument_list|(
name|key
argument_list|(
name|x
argument_list|)
argument_list|,
name|k
argument_list|)
condition|)
name|y
operator|=
name|x
operator|,
name|x
operator|=
name|left
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|right
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|iterator
name|j
operator|=
name|iterator
argument_list|(
name|y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|j
operator|==
name|end
argument_list|()
operator|||
name|key_compare
argument_list|(
name|k
argument_list|,
name|key
argument_list|(
name|j
operator|.
name|node
argument_list|)
argument_list|)
operator|)
condition|?
name|end
argument_list|()
else|:
name|j
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|,
name|class
name|Alloc
operator|>
name|typename
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|const_iterator
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|find
argument_list|(
argument|const Key& k
argument_list|)
specifier|const
block|{
name|link_type
name|y
operator|=
name|header
block|;
comment|/* Last node which is not less than k. */
name|link_type
name|x
operator|=
name|root
argument_list|()
block|;
comment|/* Current node. */
while|while
condition|(
name|x
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|key_compare
argument_list|(
name|key
argument_list|(
name|x
argument_list|)
argument_list|,
name|k
argument_list|)
condition|)
name|y
operator|=
name|x
operator|,
name|x
operator|=
name|left
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|right
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|const_iterator
name|j
operator|=
name|const_iterator
argument_list|(
name|y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|j
operator|==
name|end
argument_list|()
operator|||
name|key_compare
argument_list|(
name|k
argument_list|,
name|key
argument_list|(
name|j
operator|.
name|node
argument_list|)
argument_list|)
operator|)
condition|?
name|end
argument_list|()
else|:
name|j
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|,
name|class
name|Alloc
operator|>
name|typename
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|size_type
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|count
argument_list|(
argument|const Key& k
argument_list|)
specifier|const
block|{
name|pair
operator|<
name|const_iterator
block|,
name|const_iterator
operator|>
name|p
operator|=
name|equal_range
argument_list|(
name|k
argument_list|)
block|;
name|size_type
name|n
operator|=
literal|0
block|;
name|distance
argument_list|(
name|p
operator|.
name|first
argument_list|,
name|p
operator|.
name|second
argument_list|,
name|n
argument_list|)
block|;
return|return
name|n
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|,
name|class
name|Alloc
operator|>
name|typename
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|iterator
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|lower_bound
argument_list|(
argument|const Key& k
argument_list|)
block|{
name|link_type
name|y
operator|=
name|header
block|;
comment|/* Last node which is not less than k. */
name|link_type
name|x
operator|=
name|root
argument_list|()
block|;
comment|/* Current node. */
while|while
condition|(
name|x
operator|!=
literal|0
condition|)
if|if
condition|(
operator|!
name|key_compare
argument_list|(
name|key
argument_list|(
name|x
argument_list|)
argument_list|,
name|k
argument_list|)
condition|)
name|y
operator|=
name|x
operator|,
name|x
operator|=
name|left
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|right
argument_list|(
name|x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|iterator
argument_list|(
name|y
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|,
name|class
name|Alloc
operator|>
name|typename
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|const_iterator
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|lower_bound
argument_list|(
argument|const Key& k
argument_list|)
specifier|const
block|{
name|link_type
name|y
operator|=
name|header
block|;
comment|/* Last node which is not less than k. */
name|link_type
name|x
operator|=
name|root
argument_list|()
block|;
comment|/* Current node. */
while|while
condition|(
name|x
operator|!=
literal|0
condition|)
if|if
condition|(
operator|!
name|key_compare
argument_list|(
name|key
argument_list|(
name|x
argument_list|)
argument_list|,
name|k
argument_list|)
condition|)
name|y
operator|=
name|x
operator|,
name|x
operator|=
name|left
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|right
argument_list|(
name|x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|const_iterator
argument_list|(
name|y
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|,
name|class
name|Alloc
operator|>
name|typename
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|iterator
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|upper_bound
argument_list|(
argument|const Key& k
argument_list|)
block|{
name|link_type
name|y
operator|=
name|header
block|;
comment|/* Last node which is greater than k. */
name|link_type
name|x
operator|=
name|root
argument_list|()
block|;
comment|/* Current node. */
while|while
condition|(
name|x
operator|!=
literal|0
condition|)
if|if
condition|(
name|key_compare
argument_list|(
name|k
argument_list|,
name|key
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|y
operator|=
name|x
operator|,
name|x
operator|=
name|left
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|right
argument_list|(
name|x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|iterator
argument_list|(
name|y
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|,
name|class
name|Alloc
operator|>
name|typename
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|const_iterator
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|upper_bound
argument_list|(
argument|const Key& k
argument_list|)
specifier|const
block|{
name|link_type
name|y
operator|=
name|header
block|;
comment|/* Last node which is greater than k. */
name|link_type
name|x
operator|=
name|root
argument_list|()
block|;
comment|/* Current node. */
while|while
condition|(
name|x
operator|!=
literal|0
condition|)
if|if
condition|(
name|key_compare
argument_list|(
name|k
argument_list|,
name|key
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|y
operator|=
name|x
operator|,
name|x
operator|=
name|left
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|right
argument_list|(
name|x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|const_iterator
argument_list|(
name|y
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|pair
operator|<
name|typename
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|iterator
operator|,
name|typename
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|iterator
operator|>
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|equal_range
argument_list|(
argument|const Key& k
argument_list|)
block|{
return|return
name|pair
operator|<
name|iterator
operator|,
name|iterator
operator|>
operator|(
name|lower_bound
argument_list|(
name|k
argument_list|)
operator|,
name|upper_bound
argument_list|(
name|k
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KoV
operator|,
name|class
name|Compare
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|pair
operator|<
name|typename
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KoV
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|const_iterator
operator|,
name|typename
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KoV
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|const_iterator
operator|>
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KoV
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|equal_range
argument_list|(
argument|const Key& k
argument_list|)
specifier|const
block|{
return|return
name|pair
operator|<
name|const_iterator
operator|,
name|const_iterator
operator|>
operator|(
name|lower_bound
argument_list|(
name|k
argument_list|)
operator|,
name|upper_bound
argument_list|(
name|k
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_function
specifier|inline
name|int
name|__black_count
parameter_list|(
name|__rb_tree_node_base
modifier|*
name|node
parameter_list|,
name|__rb_tree_node_base
modifier|*
name|root
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|0
condition|)
return|return
literal|0
return|;
else|else
block|{
name|int
name|bc
init|=
name|node
operator|->
name|color
operator|==
name|__rb_tree_black
condition|?
literal|1
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|root
condition|)
return|return
name|bc
return|;
else|else
return|return
name|bc
operator|+
name|__black_count
argument_list|(
name|node
operator|->
name|parent
argument_list|,
name|root
argument_list|)
return|;
block|}
block|}
end_function

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|,
name|class
name|Alloc
operator|>
name|bool
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|,
name|Alloc
operator|>
operator|::
name|__rb_verify
argument_list|()
specifier|const
block|{
if|if
condition|(
name|node_count
operator|==
literal|0
operator|||
name|begin
argument_list|()
operator|==
name|end
argument_list|()
condition|)
return|return
name|node_count
operator|==
literal|0
operator|&&
name|begin
argument_list|()
operator|==
name|end
argument_list|()
operator|&&
name|header
operator|->
name|left
operator|==
name|header
operator|&&
name|header
operator|->
name|right
operator|==
name|header
return|;
name|int
name|len
operator|=
name|__black_count
argument_list|(
name|leftmost
argument_list|()
argument_list|,
name|root
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|const_iterator
name|it
init|=
name|begin
argument_list|()
init|;
name|it
operator|!=
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|link_type
name|x
init|=
operator|(
name|link_type
operator|)
name|it
operator|.
name|node
decl_stmt|;
name|link_type
name|L
init|=
name|left
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|link_type
name|R
init|=
name|right
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|->
name|color
operator|==
name|__rb_tree_red
condition|)
if|if
condition|(
operator|(
name|L
operator|&&
name|L
operator|->
name|color
operator|==
name|__rb_tree_red
operator|)
operator|||
operator|(
name|R
operator|&&
name|R
operator|->
name|color
operator|==
name|__rb_tree_red
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|L
operator|&&
name|key_compare
argument_list|(
name|key
argument_list|(
name|x
argument_list|)
argument_list|,
name|key
argument_list|(
name|L
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|R
operator|&&
name|key_compare
argument_list|(
name|key
argument_list|(
name|R
argument_list|)
argument_list|,
name|key
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|L
operator|&&
operator|!
name|R
operator|&&
name|__black_count
argument_list|(
name|x
argument_list|,
name|root
argument_list|()
argument_list|)
operator|!=
name|len
condition|)
return|return
name|false
return|;
block|}
end_for

begin_if
if|if
condition|(
name|leftmost
argument_list|()
operator|!=
name|__rb_tree_node_base
operator|::
name|minimum
argument_list|(
name|root
argument_list|()
argument_list|)
condition|)
return|return
name|false
return|;
end_if

begin_if
if|if
condition|(
name|rightmost
argument_list|()
operator|!=
name|__rb_tree_node_base
operator|::
name|maximum
argument_list|(
name|root
argument_list|()
argument_list|)
condition|)
return|return
name|false
return|;
end_if

begin_return
return|return
name|true
return|;
end_return

begin_endif
unit|}  __STL_END_NAMESPACE
endif|#
directive|endif
end_endif

begin_comment
comment|/* __SGI_STL_INTERNAL_TREE_H */
end_comment

begin_comment
comment|// Local Variables:
end_comment

begin_comment
comment|// mode:C++
end_comment

begin_comment
comment|// End:
end_comment

end_unit

