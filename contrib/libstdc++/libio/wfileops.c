begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1993, 95, 97, 98, 99, 2000 Free Software Foundation, Inc.    This file is part of the GNU IO Library.    Written by Ulrich Drepper<drepper@cygnus.com>.    Based on the single byte version by Per Bothner<bothner@cygnus.com>.     This library is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2, or (at    your option) any later version.     This library is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this library; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330, Boston,    MA 02111-1307, USA.     As a special exception, if you link this library with files    compiled with a GNU compiler to produce an executable, this does    not cause the resulting executable to be covered by the GNU General    Public License.  This exception does not however invalidate any    other reasons why the executable file might be covered by the GNU    General Public License.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<libioP.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_GLIBCPP_USE_WCHAR_T
end_ifdef

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GCONV_H
end_ifdef

begin_include
include|#
directive|include
file|<gconv.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_LIBC
end_ifndef

begin_define
define|#
directive|define
name|_IO_new_do_write
value|_IO_do_write
end_define

begin_define
define|#
directive|define
name|_IO_new_file_attach
value|_IO_file_attach
end_define

begin_define
define|#
directive|define
name|_IO_new_file_close_it
value|_IO_file_close_it
end_define

begin_define
define|#
directive|define
name|_IO_new_file_finish
value|_IO_file_finish
end_define

begin_define
define|#
directive|define
name|_IO_new_file_fopen
value|_IO_file_fopen
end_define

begin_define
define|#
directive|define
name|_IO_new_file_init
value|_IO_file_init
end_define

begin_define
define|#
directive|define
name|_IO_new_file_setbuf
value|_IO_file_setbuf
end_define

begin_define
define|#
directive|define
name|_IO_new_file_sync
value|_IO_file_sync
end_define

begin_define
define|#
directive|define
name|_IO_new_file_overflow
value|_IO_file_overflow
end_define

begin_define
define|#
directive|define
name|_IO_new_file_seekoff
value|_IO_file_seekoff
end_define

begin_define
define|#
directive|define
name|_IO_new_file_underflow
value|_IO_file_underflow
end_define

begin_define
define|#
directive|define
name|_IO_new_file_write
value|_IO_file_write
end_define

begin_define
define|#
directive|define
name|_IO_new_file_xsputn
value|_IO_file_xsputn
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|_IO_FILE
modifier|*
name|_IO_wfile_setbuf
parameter_list|(
name|fp
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|wchar_t
modifier|*
name|p
decl_stmt|;
name|_IO_ssize_t
name|len
decl_stmt|;
block|{
if|if
condition|(
name|_IO_wdefault_setbuf
argument_list|(
name|fp
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_base
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_end
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
expr_stmt|;
name|_IO_wsetg
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_comment
comment|/* Convert TO_DO wide character from DATA to FP.    Then mark FP as having empty buffers. */
end_comment

begin_function
name|int
name|_IO_wdo_write
parameter_list|(
name|fp
parameter_list|,
name|data
parameter_list|,
name|to_do
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|wchar_t
modifier|*
name|data
decl_stmt|;
name|_IO_size_t
name|to_do
decl_stmt|;
block|{
name|struct
name|_IO_codecvt
modifier|*
name|cc
init|=
name|fp
operator|->
name|_codecvt
decl_stmt|;
if|if
condition|(
name|to_do
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|_IO_write_end
operator|==
name|fp
operator|->
name|_IO_write_ptr
operator|&&
name|fp
operator|->
name|_IO_write_end
operator|!=
name|fp
operator|->
name|_IO_write_base
condition|)
block|{
if|if
condition|(
name|_IO_new_do_write
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_write_base
argument_list|,
name|fp
operator|->
name|_IO_write_ptr
operator|-
name|fp
operator|->
name|_IO_write_base
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
block|}
do|do
block|{
name|enum
name|__codecvt_result
name|result
decl_stmt|;
specifier|const
name|wchar_t
modifier|*
name|new_data
decl_stmt|;
comment|/* Now convert from the internal format into the external buffer.  */
name|result
operator|=
call|(
modifier|*
name|cc
operator|->
name|__codecvt_do_out
call|)
argument_list|(
name|cc
argument_list|,
operator|&
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_state
argument_list|,
name|data
argument_list|,
name|data
operator|+
name|to_do
argument_list|,
operator|&
name|new_data
argument_list|,
name|fp
operator|->
name|_IO_write_ptr
argument_list|,
name|fp
operator|->
name|_IO_buf_end
argument_list|,
operator|&
name|fp
operator|->
name|_IO_write_ptr
argument_list|)
expr_stmt|;
comment|/* Write out what we produced so far.  */
if|if
condition|(
name|_IO_new_do_write
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_write_base
argument_list|,
name|fp
operator|->
name|_IO_write_ptr
operator|-
name|fp
operator|->
name|_IO_write_base
argument_list|)
operator|==
name|EOF
condition|)
comment|/* Something went wrong.  */
return|return
name|EOF
return|;
name|to_do
operator|-=
name|new_data
operator|-
name|data
expr_stmt|;
comment|/* Next see whether we had problems during the conversion.  If yes, 	     we cannot go on.  */
if|if
condition|(
name|result
operator|!=
name|__codecvt_ok
operator|&&
operator|(
name|result
operator|!=
name|__codecvt_partial
operator|||
name|new_data
operator|-
name|data
operator|==
literal|0
operator|)
condition|)
break|break;
name|data
operator|=
name|new_data
expr_stmt|;
block|}
do|while
condition|(
name|to_do
operator|>
literal|0
condition|)
do|;
block|}
name|_IO_wsetg
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_base
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_end
operator|=
operator|(
operator|(
name|fp
operator|->
name|_flags
operator|&
operator|(
name|_IO_LINE_BUF
operator|+
name|_IO_UNBUFFERED
operator|)
operator|)
condition|?
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
else|:
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_end
operator|)
expr_stmt|;
return|return
name|to_do
operator|==
literal|0
condition|?
literal|0
else|:
name|WEOF
return|;
block|}
end_function

begin_function
name|wint_t
name|_IO_wfile_underflow
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|struct
name|_IO_codecvt
modifier|*
name|cd
decl_stmt|;
name|enum
name|__codecvt_result
name|status
decl_stmt|;
name|_IO_ssize_t
name|count
decl_stmt|;
name|int
name|tries
decl_stmt|;
specifier|const
name|char
modifier|*
name|read_ptr_copy
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_NO_READS
condition|)
block|{
name|fp
operator|->
name|_flags
operator||=
name|_IO_ERR_SEEN
expr_stmt|;
name|__set_errno
argument_list|(
name|EBADF
argument_list|)
expr_stmt|;
return|return
name|WEOF
return|;
block|}
if|if
condition|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|<
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
condition|)
return|return
operator|*
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
return|;
name|cd
operator|=
name|fp
operator|->
name|_codecvt
expr_stmt|;
comment|/* Maybe there is something left in the external buffer.  */
if|if
condition|(
name|fp
operator|->
name|_IO_read_ptr
operator|<
name|fp
operator|->
name|_IO_read_end
condition|)
block|{
comment|/* Convert it.  */
name|size_t
name|avail_bytes
init|=
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_ptr
decl_stmt|;
if|if
condition|(
name|avail_bytes
operator|>=
call|(
modifier|*
name|cd
operator|->
name|__codecvt_do_max_length
call|)
argument_list|(
name|cd
argument_list|)
condition|)
block|{
comment|/* There is more in the external.  */
specifier|const
name|char
modifier|*
name|read_stop
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|fp
operator|->
name|_IO_read_ptr
decl_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_last_state
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_state
expr_stmt|;
name|status
operator|=
call|(
modifier|*
name|cd
operator|->
name|__codecvt_do_in
call|)
argument_list|(
name|cd
argument_list|,
operator|&
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_state
argument_list|,
name|fp
operator|->
name|_IO_read_ptr
argument_list|,
name|fp
operator|->
name|_IO_read_end
argument_list|,
operator|&
name|read_stop
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_end
argument_list|,
operator|&
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|read_stop
expr_stmt|;
comment|/* If we managed to generate some text return the next character.  */
if|if
condition|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|<
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
condition|)
return|return
operator|*
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
return|;
if|if
condition|(
name|status
operator|==
name|__codecvt_error
condition|)
block|{
name|__set_errno
argument_list|(
name|EILSEQ
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_flags
operator||=
name|_IO_ERR_SEEN
expr_stmt|;
return|return
name|WEOF
return|;
block|}
block|}
comment|/* Move the remaining content of the read buffer to the beginning.  */
name|memmove
argument_list|(
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_read_ptr
argument_list|,
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_ptr
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_read_end
operator|=
operator|(
name|fp
operator|->
name|_IO_buf_base
operator|+
operator|(
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_ptr
operator|)
operator|)
expr_stmt|;
name|fp
operator|->
name|_IO_read_base
operator|=
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_IO_buf_base
expr_stmt|;
block|}
else|else
name|fp
operator|->
name|_IO_read_base
operator|=
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_IO_read_end
operator|=
name|fp
operator|->
name|_IO_buf_base
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|_IO_buf_base
operator|==
name|NULL
condition|)
block|{
comment|/* Maybe we already have a push back pointer.  */
if|if
condition|(
name|fp
operator|->
name|_IO_save_base
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|fp
operator|->
name|_IO_save_base
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_flags
operator|&=
operator|~
name|_IO_IN_BACKUP
expr_stmt|;
block|}
name|_IO_doallocbuf
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_read_base
operator|=
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_IO_read_end
operator|=
name|fp
operator|->
name|_IO_buf_base
expr_stmt|;
block|}
name|fp
operator|->
name|_IO_write_base
operator|=
name|fp
operator|->
name|_IO_write_ptr
operator|=
name|fp
operator|->
name|_IO_write_end
operator|=
name|fp
operator|->
name|_IO_buf_base
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
operator|==
name|NULL
condition|)
block|{
comment|/* Maybe we already have a push back pointer.  */
if|if
condition|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_base
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_base
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_flags
operator|&=
operator|~
name|_IO_IN_BACKUP
expr_stmt|;
block|}
name|_IO_wdoallocbuf
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* Flush all line buffered files before reading. */
comment|/* FIXME This can/should be moved to genops ?? */
if|if
condition|(
name|fp
operator|->
name|_flags
operator|&
operator|(
name|_IO_LINE_BUF
operator||
name|_IO_UNBUFFERED
operator|)
condition|)
name|_IO_flush_all_linebuffered
argument_list|()
expr_stmt|;
name|_IO_switch_to_get_mode
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_base
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_end
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
expr_stmt|;
name|tries
operator|=
literal|0
expr_stmt|;
name|again
label|:
name|count
operator|=
name|_IO_SYSREAD
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_read_end
argument_list|,
name|fp
operator|->
name|_IO_buf_end
operator|-
name|fp
operator|->
name|_IO_read_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
operator|&&
name|tries
operator|==
literal|0
condition|)
name|fp
operator|->
name|_flags
operator||=
name|_IO_EOF_SEEN
expr_stmt|;
else|else
name|fp
operator|->
name|_flags
operator||=
name|_IO_ERR_SEEN
operator|,
name|count
operator|=
literal|0
expr_stmt|;
block|}
name|fp
operator|->
name|_IO_read_end
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tries
operator|!=
literal|0
condition|)
comment|/* There are some bytes in the external buffer but they don't            convert to anything.  */
name|__set_errno
argument_list|(
name|EILSEQ
argument_list|)
expr_stmt|;
return|return
name|WEOF
return|;
block|}
if|if
condition|(
name|fp
operator|->
name|_offset
operator|!=
name|_IO_pos_BAD
condition|)
name|_IO_pos_adjust
argument_list|(
name|fp
operator|->
name|_offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* Now convert the read input.  */
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_last_state
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_state
expr_stmt|;
name|fp
operator|->
name|_IO_read_base
operator|=
name|fp
operator|->
name|_IO_read_ptr
expr_stmt|;
name|status
operator|=
call|(
modifier|*
name|cd
operator|->
name|__codecvt_do_in
call|)
argument_list|(
name|cd
argument_list|,
operator|&
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_state
argument_list|,
name|fp
operator|->
name|_IO_read_ptr
argument_list|,
name|fp
operator|->
name|_IO_read_end
argument_list|,
operator|&
name|read_ptr_copy
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_end
argument_list|,
operator|&
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|read_ptr_copy
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
operator|==
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
condition|)
block|{
if|if
condition|(
name|status
operator|==
name|__codecvt_error
operator|||
name|fp
operator|->
name|_IO_read_end
operator|==
name|fp
operator|->
name|_IO_buf_end
condition|)
block|{
name|__set_errno
argument_list|(
name|EILSEQ
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_flags
operator||=
name|_IO_ERR_SEEN
expr_stmt|;
return|return
name|WEOF
return|;
block|}
comment|/* The read bytes make no complete character.  Try reading again.  */
name|assert
argument_list|(
name|status
operator|==
name|__codecvt_partial
argument_list|)
expr_stmt|;
operator|++
name|tries
expr_stmt|;
goto|goto
name|again
goto|;
block|}
return|return
operator|*
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
return|;
block|}
end_function

begin_function
name|wint_t
name|_IO_wfile_overflow
parameter_list|(
name|f
parameter_list|,
name|wch
parameter_list|)
name|_IO_FILE
modifier|*
name|f
decl_stmt|;
name|wint_t
name|wch
decl_stmt|;
block|{
if|if
condition|(
name|f
operator|->
name|_flags
operator|&
name|_IO_NO_WRITES
condition|)
comment|/* SET ERROR */
block|{
name|f
operator|->
name|_flags
operator||=
name|_IO_ERR_SEEN
expr_stmt|;
name|__set_errno
argument_list|(
name|EBADF
argument_list|)
expr_stmt|;
return|return
name|WEOF
return|;
block|}
comment|/* If currently reading or no buffer allocated. */
if|if
condition|(
operator|(
name|f
operator|->
name|_flags
operator|&
name|_IO_CURRENTLY_PUTTING
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Allocate a buffer if needed. */
if|if
condition|(
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_base
operator|==
literal|0
condition|)
block|{
name|_IO_wdoallocbuf
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|_IO_wsetg
argument_list|(
name|f
argument_list|,
name|f
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
argument_list|,
name|f
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
argument_list|,
name|f
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|_IO_write_base
operator|==
name|NULL
condition|)
block|{
name|_IO_doallocbuf
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|_IO_setg
argument_list|(
name|f
argument_list|,
name|f
operator|->
name|_IO_buf_base
argument_list|,
name|f
operator|->
name|_IO_buf_base
argument_list|,
name|f
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Otherwise must be currently reading.  If _IO_read_ptr 	     (and hence also _IO_read_end) is at the buffer end, 	     logically slide the buffer forwards one block (by setting 	     the read pointers to all point at the beginning of the 	     block).  This makes room for subsequent output. 	     Otherwise, set the read pointers to _IO_read_end (leaving 	     that alone, so it can continue to correspond to the 	     external position). */
if|if
condition|(
name|f
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|==
name|f
operator|->
name|_wide_data
operator|->
name|_IO_buf_end
condition|)
block|{
name|f
operator|->
name|_IO_read_end
operator|=
name|f
operator|->
name|_IO_read_ptr
operator|=
name|f
operator|->
name|_IO_buf_base
expr_stmt|;
name|f
operator|->
name|_wide_data
operator|->
name|_IO_read_end
operator|=
name|f
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|=
name|f
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
expr_stmt|;
block|}
block|}
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
operator|=
name|f
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
expr_stmt|;
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_base
operator|=
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
expr_stmt|;
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_end
operator|=
name|f
operator|->
name|_wide_data
operator|->
name|_IO_buf_end
expr_stmt|;
name|f
operator|->
name|_wide_data
operator|->
name|_IO_read_base
operator|=
name|f
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|=
name|f
operator|->
name|_wide_data
operator|->
name|_IO_read_end
expr_stmt|;
name|f
operator|->
name|_IO_write_ptr
operator|=
name|f
operator|->
name|_IO_read_ptr
expr_stmt|;
name|f
operator|->
name|_IO_write_base
operator|=
name|f
operator|->
name|_IO_write_ptr
expr_stmt|;
name|f
operator|->
name|_IO_write_end
operator|=
name|f
operator|->
name|_IO_buf_end
expr_stmt|;
name|f
operator|->
name|_IO_read_base
operator|=
name|f
operator|->
name|_IO_read_ptr
operator|=
name|f
operator|->
name|_IO_read_end
expr_stmt|;
name|f
operator|->
name|_flags
operator||=
name|_IO_CURRENTLY_PUTTING
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|_flags
operator|&
operator|(
name|_IO_LINE_BUF
operator|+
name|_IO_UNBUFFERED
operator|)
condition|)
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_end
operator|=
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
expr_stmt|;
block|}
if|if
condition|(
name|wch
operator|==
name|WEOF
condition|)
return|return
name|_IO_do_flush
argument_list|(
name|f
argument_list|)
return|;
if|if
condition|(
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
operator|==
name|f
operator|->
name|_wide_data
operator|->
name|_IO_buf_end
condition|)
comment|/* Buffer is really full */
if|if
condition|(
name|_IO_do_flush
argument_list|(
name|f
argument_list|)
operator|==
name|WEOF
condition|)
return|return
name|WEOF
return|;
operator|*
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
operator|++
operator|=
name|wch
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|->
name|_flags
operator|&
name|_IO_UNBUFFERED
operator|)
operator|||
operator|(
operator|(
name|f
operator|->
name|_flags
operator|&
name|_IO_LINE_BUF
operator|)
operator|&&
name|wch
operator|==
literal|L'
expr|\n'
operator|)
condition|)
if|if
condition|(
name|_IO_do_flush
argument_list|(
name|f
argument_list|)
operator|==
name|WEOF
condition|)
return|return
name|WEOF
return|;
return|return
name|wch
return|;
block|}
end_function

begin_function
name|wint_t
name|_IO_wfile_sync
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|_IO_ssize_t
name|delta
decl_stmt|;
name|wint_t
name|retval
init|=
literal|0
decl_stmt|;
comment|/*    char* ptr = cur_ptr(); */
if|if
condition|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
operator|>
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_base
condition|)
if|if
condition|(
name|_IO_do_flush
argument_list|(
name|fp
argument_list|)
condition|)
return|return
name|WEOF
return|;
name|delta
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|-
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
expr_stmt|;
if|if
condition|(
name|delta
operator|!=
literal|0
condition|)
block|{
comment|/* We have to find out how many bytes we have to go back in the 	 external buffer.  */
name|struct
name|_IO_codecvt
modifier|*
name|cv
init|=
name|fp
operator|->
name|_codecvt
decl_stmt|;
name|_IO_off64_t
name|new_pos
decl_stmt|;
name|int
name|clen
init|=
call|(
modifier|*
name|cv
operator|->
name|__codecvt_do_encoding
call|)
argument_list|(
name|cv
argument_list|)
decl_stmt|;
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
comment|/* It is easy, a fixed number of input bytes are used for each 	   wide character.  */
name|delta
operator|*=
name|clen
expr_stmt|;
else|else
block|{
comment|/* We have to find out the hard way how much to back off.              To do this we determine how much input we needed to              generate the wide characters up to the current reading              position.  */
name|int
name|nread
decl_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_state
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_last_state
expr_stmt|;
name|nread
operator|=
call|(
modifier|*
name|cv
operator|->
name|__codecvt_do_length
call|)
argument_list|(
name|cv
argument_list|,
operator|&
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_state
argument_list|,
name|fp
operator|->
name|_IO_read_base
argument_list|,
name|fp
operator|->
name|_IO_read_end
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_IO_read_base
operator|+
name|nread
expr_stmt|;
name|delta
operator|=
operator|-
operator|(
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_base
operator|-
name|nread
operator|)
expr_stmt|;
block|}
name|new_pos
operator|=
name|_IO_SYSSEEK
argument_list|(
name|fp
argument_list|,
name|delta
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_pos
operator|!=
operator|(
name|_IO_off64_t
operator|)
name|EOF
condition|)
block|{
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
expr_stmt|;
name|fp
operator|->
name|_IO_read_end
operator|=
name|fp
operator|->
name|_IO_read_ptr
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ESPIPE
elseif|else
if|if
condition|(
name|errno
operator|==
name|ESPIPE
condition|)
empty_stmt|;
comment|/* Ignore error from unseekable devices. */
endif|#
directive|endif
else|else
name|retval
operator|=
name|WEOF
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|!=
name|WEOF
condition|)
name|fp
operator|->
name|_offset
operator|=
name|_IO_pos_BAD
expr_stmt|;
comment|/* FIXME: Cleanup - can this be shared? */
comment|/*    setg(base(), ptr, ptr); */
return|return
name|retval
return|;
block|}
end_function

begin_function
name|_IO_off64_t
name|_IO_wfile_seekoff
parameter_list|(
name|fp
parameter_list|,
name|offset
parameter_list|,
name|dir
parameter_list|,
name|mode
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|_IO_off64_t
name|offset
decl_stmt|;
name|int
name|dir
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|_IO_off64_t
name|result
decl_stmt|;
name|_IO_off64_t
name|delta
decl_stmt|,
name|new_offset
decl_stmt|;
name|long
name|int
name|count
decl_stmt|;
comment|/* POSIX.1 8.2.3.7 says that after a call the fflush() the file      offset of the underlying file must be exact.  */
name|int
name|must_be_exact
init|=
operator|(
operator|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
operator|==
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
operator|)
operator|&&
operator|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_base
operator|==
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
name|dir
operator|=
name|_IO_seek_cur
operator|,
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* Don't move any pointers. */
comment|/* Flush unwritten characters.      (This may do an unneeded write if we seek within the buffer.      But to be able to switch to reading, we would need to set      egptr to ptr.  That can't be done in the current design,      which assumes file_ptr() is eGptr.  Anyway, since we probably      end up flushing when we close(), it doesn't make much difference.)      FIXME: simulate mem-papped files. */
if|if
condition|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
operator|>
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_base
operator|||
name|_IO_in_put_mode
argument_list|(
name|fp
argument_list|)
condition|)
if|if
condition|(
name|_IO_switch_to_wget_mode
argument_list|(
name|fp
argument_list|)
condition|)
return|return
name|WEOF
return|;
if|if
condition|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
operator|==
name|NULL
condition|)
block|{
comment|/* It could be that we already have a pushback buffer.  */
if|if
condition|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_flags
operator|&=
operator|~
name|_IO_IN_BACKUP
expr_stmt|;
block|}
name|_IO_doallocbuf
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|_IO_setp
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
name|_IO_setg
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
name|_IO_wsetp
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
name|_IO_wsetg
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|dir
condition|)
block|{
name|struct
name|_IO_codecvt
modifier|*
name|cv
decl_stmt|;
name|int
name|clen
decl_stmt|;
case|case
name|_IO_seek_cur
case|:
comment|/* Adjust for read-ahead (bytes is buffer).  To do this we must          find out which position in the external buffer corresponds to          the current position in the internal buffer.  */
name|cv
operator|=
name|fp
operator|->
name|_codecvt
expr_stmt|;
name|clen
operator|=
call|(
modifier|*
name|cv
operator|->
name|__codecvt_do_encoding
call|)
argument_list|(
name|cv
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
name|offset
operator|-=
operator|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|)
operator|*
name|clen
expr_stmt|;
else|else
block|{
name|int
name|nread
decl_stmt|;
name|delta
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|-
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_state
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_last_state
expr_stmt|;
name|nread
operator|=
call|(
modifier|*
name|cv
operator|->
name|__codecvt_do_length
call|)
argument_list|(
name|cv
argument_list|,
operator|&
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_state
argument_list|,
name|fp
operator|->
name|_IO_read_base
argument_list|,
name|fp
operator|->
name|_IO_read_end
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_IO_read_base
operator|+
name|nread
expr_stmt|;
name|offset
operator|-=
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_base
operator|-
name|nread
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|_offset
operator|==
name|_IO_pos_BAD
condition|)
goto|goto
name|dumb
goto|;
comment|/* Make offset absolute, assuming current pointer is file_ptr(). */
name|offset
operator|+=
name|fp
operator|->
name|_offset
expr_stmt|;
name|dir
operator|=
name|_IO_seek_set
expr_stmt|;
break|break;
case|case
name|_IO_seek_set
case|:
break|break;
case|case
name|_IO_seek_end
case|:
block|{
name|struct
name|_G_stat64
name|st
decl_stmt|;
if|if
condition|(
name|_IO_SYSSTAT
argument_list|(
name|fp
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
operator|&&
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|offset
operator|+=
name|st
operator|.
name|st_size
expr_stmt|;
name|dir
operator|=
name|_IO_seek_set
expr_stmt|;
block|}
else|else
goto|goto
name|dumb
goto|;
block|}
block|}
comment|/* At this point, dir==_IO_seek_set. */
comment|/* If we are only interested in the current position we've found it now.  */
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
return|return
name|offset
return|;
comment|/* If destination is within current buffer, optimize: */
if|if
condition|(
name|fp
operator|->
name|_offset
operator|!=
name|_IO_pos_BAD
operator|&&
name|fp
operator|->
name|_IO_read_base
operator|!=
name|NULL
operator|&&
operator|!
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
block|{
comment|/* Offset relative to start of main get area. */
name|_IO_off64_t
name|rel_offset
init|=
operator|(
name|offset
operator|-
name|fp
operator|->
name|_offset
operator|+
operator|(
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_base
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|rel_offset
operator|>=
literal|0
condition|)
block|{
if|#
directive|if
literal|0
block|if (_IO_in_backup (fp)) 	    _IO_switch_to_main_get_area (fp);
endif|#
directive|endif
if|if
condition|(
name|rel_offset
operator|<=
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_base
condition|)
block|{
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_IO_read_base
operator|+
name|rel_offset
expr_stmt|;
name|_IO_setp
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
comment|/* Now set the pointer for the internal buffer.  This                  might be an iterative process.  Though the read                  pointer is somewhere in the current external buffer                  this does not mean we can convert this whole buffer                  at once fitting in the internal buffer.  */
do|do
block|{  		}
do|while
condition|(
literal|0
condition|)
do|;
name|_IO_mask_flags
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
name|_IO_EOF_SEEN
argument_list|)
expr_stmt|;
goto|goto
name|resync
goto|;
block|}
ifdef|#
directive|ifdef
name|TODO
comment|/* If we have streammarkers, seek forward by reading ahead. */
if|if
condition|(
name|_IO_have_markers
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|int
name|to_skip
init|=
name|rel_offset
operator|-
operator|(
name|fp
operator|->
name|_IO_read_ptr
operator|-
name|fp
operator|->
name|_IO_read_base
operator|)
decl_stmt|;
if|if
condition|(
name|ignore
argument_list|(
name|to_skip
argument_list|)
operator|!=
name|to_skip
condition|)
goto|goto
name|dumb
goto|;
name|_IO_mask_flags
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
name|_IO_EOF_SEEN
argument_list|)
expr_stmt|;
goto|goto
name|resync
goto|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|TODO
if|if
condition|(
name|rel_offset
operator|<
literal|0
operator|&&
name|rel_offset
operator|>=
name|Bbase
argument_list|()
operator|-
name|Bptr
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|_IO_switch_to_backup_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|gbump
argument_list|(
name|fp
operator|->
name|_IO_read_end
operator|+
name|rel_offset
operator|-
name|fp
operator|->
name|_IO_read_ptr
argument_list|)
expr_stmt|;
name|_IO_mask_flags
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
name|_IO_EOF_SEEN
argument_list|)
expr_stmt|;
goto|goto
name|resync
goto|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|TODO
name|_IO_unsave_markers
argument_list|(
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_NO_READS
condition|)
goto|goto
name|dumb
goto|;
comment|/* Try to seek to a block boundary, to improve kernel page management. */
name|new_offset
operator|=
name|offset
operator|&
operator|~
operator|(
name|fp
operator|->
name|_IO_buf_end
operator|-
name|fp
operator|->
name|_IO_buf_base
operator|-
literal|1
operator|)
expr_stmt|;
name|delta
operator|=
name|offset
operator|-
name|new_offset
expr_stmt|;
if|if
condition|(
name|delta
operator|>
name|fp
operator|->
name|_IO_buf_end
operator|-
name|fp
operator|->
name|_IO_buf_base
condition|)
block|{
name|new_offset
operator|=
name|offset
expr_stmt|;
name|delta
operator|=
literal|0
expr_stmt|;
block|}
name|result
operator|=
name|_IO_SYSSEEK
argument_list|(
name|fp
argument_list|,
name|new_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
name|count
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|count
operator|=
name|_IO_SYSREAD
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
operator|(
name|must_be_exact
condition|?
name|delta
else|:
name|fp
operator|->
name|_IO_buf_end
operator|-
name|fp
operator|->
name|_IO_buf_base
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|delta
condition|)
block|{
comment|/* We weren't allowed to read, but try to seek the remainder. */
name|offset
operator|=
name|count
operator|==
name|EOF
condition|?
name|delta
else|:
name|delta
operator|-
name|count
expr_stmt|;
name|dir
operator|=
name|_IO_seek_cur
expr_stmt|;
goto|goto
name|dumb
goto|;
block|}
block|}
name|_IO_setg
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
operator|+
name|delta
argument_list|,
name|fp
operator|->
name|_IO_buf_base
operator|+
name|count
argument_list|)
expr_stmt|;
name|_IO_setp
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_offset
operator|=
name|result
operator|+
name|count
expr_stmt|;
name|_IO_mask_flags
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
name|_IO_EOF_SEEN
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
name|dumb
label|:
name|_IO_unsave_markers
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|result
operator|=
name|_IO_SYSSEEK
argument_list|(
name|fp
argument_list|,
name|offset
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|EOF
condition|)
block|{
name|_IO_mask_flags
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
name|_IO_EOF_SEEN
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_offset
operator|=
name|result
expr_stmt|;
name|_IO_setg
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
name|_IO_setp
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|,
name|fp
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
name|resync
label|:
comment|/* We need to do it since it is possible that the file offset in      the kernel may be changed behind our back. It may happen when      we fopen a file and then do a fork. One process may access the      the file and the kernel file offset will be changed. */
if|if
condition|(
name|fp
operator|->
name|_offset
operator|>=
literal|0
condition|)
name|_IO_SYSSEEK
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_function
name|_IO_size_t
name|_IO_wfile_xsputn
parameter_list|(
name|f
parameter_list|,
name|data
parameter_list|,
name|n
parameter_list|)
name|_IO_FILE
modifier|*
name|f
decl_stmt|;
specifier|const
name|void
modifier|*
name|data
decl_stmt|;
name|_IO_size_t
name|n
decl_stmt|;
block|{
specifier|register
specifier|const
name|wchar_t
modifier|*
name|s
init|=
operator|(
specifier|const
name|wchar_t
operator|*
operator|)
name|data
decl_stmt|;
name|_IO_size_t
name|to_do
init|=
name|n
decl_stmt|;
name|int
name|must_flush
init|=
literal|0
decl_stmt|;
name|_IO_size_t
name|count
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* This is an optimized implementation.      If the amount to be written straddles a block boundary      (or the filebuf is unbuffered), use sys_write directly. */
comment|/* First figure out how much space is available in the buffer. */
name|count
operator|=
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_end
operator|-
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|->
name|_flags
operator|&
name|_IO_LINE_BUF
operator|)
operator|&&
operator|(
name|f
operator|->
name|_flags
operator|&
name|_IO_CURRENTLY_PUTTING
operator|)
condition|)
block|{
name|count
operator|=
name|f
operator|->
name|_wide_data
operator|->
name|_IO_buf_end
operator|-
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|n
condition|)
block|{
specifier|register
specifier|const
name|wchar_t
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|s
operator|+
name|n
init|;
name|p
operator|>
name|s
condition|;
control|)
block|{
if|if
condition|(
operator|*
operator|--
name|p
operator|==
literal|L'
expr|\n'
condition|)
block|{
name|count
operator|=
name|p
operator|-
name|s
operator|+
literal|1
expr_stmt|;
name|must_flush
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* Then fill the buffer. */
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|>
name|to_do
condition|)
name|count
operator|=
name|to_do
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|20
condition|)
block|{
ifdef|#
directive|ifdef
name|_LIBC
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
operator|=
name|__wmempcpy
argument_list|(
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
argument_list|,
name|s
argument_list|,
name|count
argument_list|)
expr_stmt|;
else|#
directive|else
name|wmemcpy
argument_list|(
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
argument_list|,
name|s
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
operator|+=
name|count
expr_stmt|;
endif|#
directive|endif
name|s
operator|+=
name|count
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|wchar_t
modifier|*
name|p
init|=
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
decl_stmt|;
specifier|register
name|int
name|i
init|=
operator|(
name|int
operator|)
name|count
decl_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
operator|=
name|p
expr_stmt|;
block|}
name|to_do
operator|-=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|to_do
operator|>
literal|0
condition|)
name|to_do
operator|-=
name|_IO_wdefault_xsputn
argument_list|(
name|f
argument_list|,
name|s
argument_list|,
name|to_do
argument_list|)
expr_stmt|;
if|if
condition|(
name|must_flush
operator|&&
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
operator|!=
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_base
condition|)
name|_IO_wdo_write
argument_list|(
name|f
argument_list|,
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_base
argument_list|,
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
operator|-
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_base
argument_list|)
expr_stmt|;
return|return
name|n
operator|-
name|to_do
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|_IO_jump_t
name|_IO_wfile_jumps
init|=
block|{
name|JUMP_INIT_DUMMY
block|,
name|JUMP_INIT
argument_list|(
name|finish
argument_list|,
name|_IO_new_file_finish
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|overflow
argument_list|,
operator|(
name|_IO_overflow_t
operator|)
name|_IO_wfile_overflow
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|underflow
argument_list|,
operator|(
name|_IO_underflow_t
operator|)
name|_IO_wfile_underflow
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|uflow
argument_list|,
operator|(
name|_IO_underflow_t
operator|)
name|_IO_wdefault_uflow
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|pbackfail
argument_list|,
operator|(
name|_IO_pbackfail_t
operator|)
name|_IO_wdefault_pbackfail
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|xsputn
argument_list|,
name|_IO_wfile_xsputn
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|xsgetn
argument_list|,
name|_IO_file_xsgetn
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|seekoff
argument_list|,
name|_IO_wfile_seekoff
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|seekpos
argument_list|,
name|_IO_default_seekpos
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|setbuf
argument_list|,
name|_IO_new_file_setbuf
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|sync
argument_list|,
operator|(
name|_IO_sync_t
operator|)
name|_IO_wfile_sync
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|doallocate
argument_list|,
name|_IO_wfile_doallocate
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|read
argument_list|,
name|_IO_file_read
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|write
argument_list|,
name|_IO_new_file_write
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|seek
argument_list|,
name|_IO_file_seek
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|close
argument_list|,
name|_IO_file_close
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|stat
argument_list|,
name|_IO_file_stat
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
name|showmanyc
argument_list|,
name|_IO_default_showmanyc
argument_list|)
block|,
name|JUMP_INIT
argument_list|(
argument|imbue
argument_list|,
argument|_IO_default_imbue
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _GLIBCPP_USE_WCHAR_T */
end_comment

end_unit

