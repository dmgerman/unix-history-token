begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1999, 2000 Free Software Foundation, Inc.    This file is part of the GNU IO Library.     This library is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2, or (at    your option) any later version.     This library is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this library; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330, Boston,    MA 02111-1307, USA.     As a special exception, if you link this library with files    compiled with a GNU compiler to produce an executable, this does    not cause the resulting executable to be covered by the GNU General    Public License.  This exception does not however invalidate any    other reasons why the executable file might be covered by the GNU    General Public License.  */
end_comment

begin_include
include|#
directive|include
file|<libioP.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_include
include|#
directive|include
file|<locale/localeinfo.h>
end_include

begin_include
include|#
directive|include
file|<wcsmbs/wcsmbsload.h>
end_include

begin_include
include|#
directive|include
file|<iconv/gconv_int.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_LIBC
argument_list|)
operator|||
name|defined
argument_list|(
name|_GLIBCPP_USE_WCHAR_T
argument_list|)
end_if

begin_include
include|#
directive|include
file|<langinfo.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_GLIBCPP_USE_WCHAR_T
end_ifdef

begin_comment
comment|/* Prototypes of libio's codecvt functions.  */
end_comment

begin_function_decl
specifier|static
name|enum
name|__codecvt_result
name|do_out
parameter_list|(
name|struct
name|_IO_codecvt
modifier|*
name|codecvt
parameter_list|,
name|__c_mbstate_t
modifier|*
name|statep
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|from_start
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|from_end
parameter_list|,
specifier|const
name|wchar_t
modifier|*
modifier|*
name|from_stop
parameter_list|,
name|char
modifier|*
name|to_start
parameter_list|,
name|char
modifier|*
name|to_end
parameter_list|,
name|char
modifier|*
modifier|*
name|to_stop
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|__codecvt_result
name|do_unshift
parameter_list|(
name|struct
name|_IO_codecvt
modifier|*
name|codecvt
parameter_list|,
name|__c_mbstate_t
modifier|*
name|statep
parameter_list|,
name|char
modifier|*
name|to_start
parameter_list|,
name|char
modifier|*
name|to_end
parameter_list|,
name|char
modifier|*
modifier|*
name|to_stop
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|__codecvt_result
name|do_in
parameter_list|(
name|struct
name|_IO_codecvt
modifier|*
name|codecvt
parameter_list|,
name|__c_mbstate_t
modifier|*
name|statep
parameter_list|,
specifier|const
name|char
modifier|*
name|from_start
parameter_list|,
specifier|const
name|char
modifier|*
name|from_end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|from_stop
parameter_list|,
name|wchar_t
modifier|*
name|to_start
parameter_list|,
name|wchar_t
modifier|*
name|to_end
parameter_list|,
name|wchar_t
modifier|*
modifier|*
name|to_stop
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_encoding
parameter_list|(
name|struct
name|_IO_codecvt
modifier|*
name|codecvt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_length
parameter_list|(
name|struct
name|_IO_codecvt
modifier|*
name|codecvt
parameter_list|,
name|__c_mbstate_t
modifier|*
name|statep
parameter_list|,
specifier|const
name|char
modifier|*
name|from_start
parameter_list|,
specifier|const
name|char
modifier|*
name|from_end
parameter_list|,
name|_IO_size_t
name|max
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_max_length
parameter_list|(
name|struct
name|_IO_codecvt
modifier|*
name|codecvt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_always_noconv
parameter_list|(
name|struct
name|_IO_codecvt
modifier|*
name|codecvt
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The functions used in `codecvt' for libio are always the same.  */
end_comment

begin_decl_stmt
name|struct
name|_IO_codecvt
name|__libio_codecvt
init|=
block|{
operator|.
name|__codecvt_destr
operator|=
name|NULL
block|,
comment|/* Destructor, never used.  */
operator|.
name|__codecvt_do_out
operator|=
name|do_out
block|,
operator|.
name|__codecvt_do_unshift
operator|=
name|do_unshift
block|,
operator|.
name|__codecvt_do_in
operator|=
name|do_in
block|,
operator|.
name|__codecvt_do_encoding
operator|=
name|do_encoding
block|,
operator|.
name|__codecvt_do_always_noconv
operator|=
name|do_always_noconv
block|,
operator|.
name|__codecvt_do_length
operator|=
name|do_length
block|,
operator|.
name|__codecvt_do_max_length
operator|=
name|do_max_length
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|__gconv_trans_data
name|libio_translit
init|=
block|{
operator|.
name|__trans_fct
operator|=
name|__gconv_transliterate
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(GLIBCPP_USE_WCHAR_T) */
end_comment

begin_comment
comment|/* Return orientation of stream.  If mode is nonzero try to change    the orientation first.  */
end_comment

begin_undef
undef|#
directive|undef
name|_IO_fwide
end_undef

begin_function
name|int
name|_IO_fwide
parameter_list|(
name|fp
parameter_list|,
name|mode
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
comment|/* Normalize the value.  */
name|mode
operator|=
name|mode
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
operator|(
name|mode
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|0
operator|||
name|fp
operator|->
name|_mode
operator|!=
literal|0
condition|)
comment|/* The caller simply wants to know about the current orientation        or the orientation already has been determined.  */
return|return
name|fp
operator|->
name|_mode
return|;
comment|/* Set the orientation appropriately.  */
if|if
condition|(
name|mode
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|_GLIBCPP_USE_WCHAR_T
name|struct
name|_IO_codecvt
modifier|*
name|cc
init|=
name|fp
operator|->
name|_codecvt
decl_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_base
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
comment|/* Get the character conversion functions based on the currently 	 selected locale for LC_CTYPE.  */
block|{
name|struct
name|gconv_fcts
name|fcts
decl_stmt|;
comment|/* Clear the state.  We start all over again.  */
name|memset
argument_list|(
operator|&
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_state
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|__c_mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_last_state
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|__c_mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
name|__wcsmbs_clone_conv
argument_list|(
operator|&
name|fcts
argument_list|)
expr_stmt|;
comment|/* The functions are always the same.  */
operator|*
name|cc
operator|=
name|__libio_codecvt
expr_stmt|;
name|cc
operator|->
name|__cd_in
operator|.
name|__cd
operator|.
name|__nsteps
operator|=
literal|1
expr_stmt|;
comment|/* Only one step allowed.  */
name|cc
operator|->
name|__cd_in
operator|.
name|__cd
operator|.
name|__steps
operator|=
name|fcts
operator|.
name|towc
expr_stmt|;
name|cc
operator|->
name|__cd_in
operator|.
name|__cd
operator|.
name|__data
index|[
literal|0
index|]
operator|.
name|__invocation_counter
operator|=
literal|0
expr_stmt|;
name|cc
operator|->
name|__cd_in
operator|.
name|__cd
operator|.
name|__data
index|[
literal|0
index|]
operator|.
name|__internal_use
operator|=
literal|1
expr_stmt|;
name|cc
operator|->
name|__cd_in
operator|.
name|__cd
operator|.
name|__data
index|[
literal|0
index|]
operator|.
name|__flags
operator|=
name|__GCONV_IS_LAST
expr_stmt|;
name|cc
operator|->
name|__cd_in
operator|.
name|__cd
operator|.
name|__data
index|[
literal|0
index|]
operator|.
name|__statep
operator|=
operator|&
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_state
expr_stmt|;
comment|/* XXX For now no transliteration.  */
name|cc
operator|->
name|__cd_in
operator|.
name|__cd
operator|.
name|__data
index|[
literal|0
index|]
operator|.
name|__trans
operator|=
name|NULL
expr_stmt|;
name|cc
operator|->
name|__cd_out
operator|.
name|__cd
operator|.
name|__nsteps
operator|=
literal|1
expr_stmt|;
comment|/* Only one step allowed.  */
name|cc
operator|->
name|__cd_out
operator|.
name|__cd
operator|.
name|__steps
operator|=
name|fcts
operator|.
name|tomb
expr_stmt|;
name|cc
operator|->
name|__cd_out
operator|.
name|__cd
operator|.
name|__data
index|[
literal|0
index|]
operator|.
name|__invocation_counter
operator|=
literal|0
expr_stmt|;
name|cc
operator|->
name|__cd_out
operator|.
name|__cd
operator|.
name|__data
index|[
literal|0
index|]
operator|.
name|__internal_use
operator|=
literal|1
expr_stmt|;
name|cc
operator|->
name|__cd_out
operator|.
name|__cd
operator|.
name|__data
index|[
literal|0
index|]
operator|.
name|__flags
operator|=
name|__GCONV_IS_LAST
expr_stmt|;
name|cc
operator|->
name|__cd_out
operator|.
name|__cd
operator|.
name|__data
index|[
literal|0
index|]
operator|.
name|__statep
operator|=
operator|&
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_state
expr_stmt|;
comment|/* And now the transliteration.  */
name|cc
operator|->
name|__cd_out
operator|.
name|__cd
operator|.
name|__data
index|[
literal|0
index|]
operator|.
name|__trans
operator|=
operator|&
name|libio_translit
expr_stmt|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|_GLIBCPP_USE_WCHAR_T
block|{
comment|/* Determine internal and external character sets. 	   XXX For now we make our life easy: we assume a fixed internal 	   encoding (as most sane systems have; hi HP/UX!).  If somebody 	   cares about systems which changing internal charsets they 	   should come up with a solution for the determination of the 	   currently used internal character set.  */
if|#
directive|if
literal|0
block|const char *internal_ccs = _G_INTERNAL_CCS; 	const char *external_ccs = nl_langinfo(CODESET);  	if (external_ccs == NULL) 	  external_ccs = "ISO-8859-1";  	cc->__cd_in = iconv_open (internal_ccs, external_ccs); 	if (cc->__cd_in != (iconv_t) -1) 	  cc->__cd_out = iconv_open (external_ccs, internal_ccs);
endif|#
directive|endif
block|}
else|#
directive|else
error|#
directive|error
literal|"somehow determine this from LC_CTYPE"
endif|#
directive|endif
endif|#
directive|endif
comment|/* From now on use the wide character callback functions.  */
operator|(
operator|(
expr|struct
name|_IO_FILE_plus
operator|*
operator|)
name|fp
operator|)
operator|->
name|vtable
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_wide_vtable
expr_stmt|;
else|#
directive|else
comment|/* !defined(_GLIBCPP_USE_WCHAR_T) */
name|mode
operator|=
name|fp
operator|->
name|_mode
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(_GLIBCPP_USE_WCHAR_T) */
block|}
comment|/* Set the mode now.  */
name|fp
operator|->
name|_mode
operator|=
name|mode
expr_stmt|;
return|return
name|mode
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|weak_alias
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|_IO_fwide
argument_list|,
argument|fwide
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_GLIBCPP_USE_WCHAR_T
end_ifdef

begin_function
specifier|static
name|enum
name|__codecvt_result
name|do_out
parameter_list|(
name|struct
name|_IO_codecvt
modifier|*
name|codecvt
parameter_list|,
name|__c_mbstate_t
modifier|*
name|statep
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|from_start
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|from_end
parameter_list|,
specifier|const
name|wchar_t
modifier|*
modifier|*
name|from_stop
parameter_list|,
name|char
modifier|*
name|to_start
parameter_list|,
name|char
modifier|*
name|to_end
parameter_list|,
name|char
modifier|*
modifier|*
name|to_stop
parameter_list|)
block|{
name|enum
name|__codecvt_result
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|struct
name|__gconv_step
modifier|*
name|gs
init|=
name|codecvt
operator|->
name|__cd_out
operator|.
name|__cd
operator|.
name|__steps
decl_stmt|;
name|int
name|status
decl_stmt|;
name|size_t
name|dummy
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|from_start_copy
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|from_start
decl_stmt|;
name|codecvt
operator|->
name|__cd_out
operator|.
name|__cd
operator|.
name|__data
index|[
literal|0
index|]
operator|.
name|__outbuf
operator|=
name|to_start
expr_stmt|;
name|codecvt
operator|->
name|__cd_out
operator|.
name|__cd
operator|.
name|__data
index|[
literal|0
index|]
operator|.
name|__outbufend
operator|=
name|to_end
expr_stmt|;
name|codecvt
operator|->
name|__cd_out
operator|.
name|__cd
operator|.
name|__data
index|[
literal|0
index|]
operator|.
name|__statep
operator|=
name|statep
expr_stmt|;
name|status
operator|=
name|DL_CALL_FCT
argument_list|(
name|gs
operator|->
name|__fct
argument_list|,
operator|(
name|gs
operator|,
name|codecvt
operator|->
name|__cd_out
operator|.
name|__cd
operator|.
name|__data
operator|,
operator|&
name|from_start_copy
operator|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|from_end
operator|,
name|NULL
operator|,
operator|&
name|dummy
operator|,
literal|0
operator|,
literal|0
operator|)
argument_list|)
expr_stmt|;
operator|*
name|from_stop
operator|=
operator|(
name|wchar_t
operator|*
operator|)
name|from_start_copy
expr_stmt|;
operator|*
name|to_stop
operator|=
name|codecvt
operator|->
name|__cd_out
operator|.
name|__cd
operator|.
name|__data
index|[
literal|0
index|]
operator|.
name|__outbuf
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|__GCONV_OK
case|:
case|case
name|__GCONV_EMPTY_INPUT
case|:
name|result
operator|=
name|__codecvt_ok
expr_stmt|;
break|break;
case|case
name|__GCONV_FULL_OUTPUT
case|:
case|case
name|__GCONV_INCOMPLETE_INPUT
case|:
name|result
operator|=
name|__codecvt_partial
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|__codecvt_error
expr_stmt|;
break|break;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|_GLIBCPP_USE_WCHAR_T
name|size_t
name|res
decl_stmt|;
specifier|const
name|char
modifier|*
name|from_start_copy
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|from_start
decl_stmt|;
name|size_t
name|from_len
init|=
name|from_end
operator|-
name|from_start
decl_stmt|;
name|char
modifier|*
name|to_start_copy
init|=
name|to_start
decl_stmt|;
name|size_t
name|to_len
init|=
name|to_end
operator|-
name|to_start
decl_stmt|;
name|res
operator|=
name|iconv
argument_list|(
name|codecvt
operator|->
name|__cd_out
argument_list|,
operator|&
name|from_start_copy
argument_list|,
operator|&
name|from_len
argument_list|,
operator|&
name|to_start_copy
argument_list|,
operator|&
name|to_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
operator|||
name|from_len
operator|==
literal|0
condition|)
name|result
operator|=
name|__codecvt_ok
expr_stmt|;
elseif|else
if|if
condition|(
name|to_len
operator|<
name|codecvt
operator|->
name|__codecvt_do_max_length
argument_list|(
name|codecvt
argument_list|)
condition|)
name|result
operator|=
name|__codecvt_partial
expr_stmt|;
else|else
name|result
operator|=
name|__codecvt_error
expr_stmt|;
else|#
directive|else
comment|/* Decide what to do.  */
name|result
operator|=
name|__codecvt_error
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|__codecvt_result
name|do_unshift
parameter_list|(
name|struct
name|_IO_codecvt
modifier|*
name|codecvt
parameter_list|,
name|__c_mbstate_t
modifier|*
name|statep
parameter_list|,
name|char
modifier|*
name|to_start
parameter_list|,
name|char
modifier|*
name|to_end
parameter_list|,
name|char
modifier|*
modifier|*
name|to_stop
parameter_list|)
block|{
name|enum
name|__codecvt_result
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|struct
name|__gconv_step
modifier|*
name|gs
init|=
name|codecvt
operator|->
name|__cd_out
operator|.
name|__cd
operator|.
name|__steps
decl_stmt|;
name|int
name|status
decl_stmt|;
name|size_t
name|dummy
decl_stmt|;
name|codecvt
operator|->
name|__cd_out
operator|.
name|__cd
operator|.
name|__data
index|[
literal|0
index|]
operator|.
name|__outbuf
operator|=
name|to_start
expr_stmt|;
name|codecvt
operator|->
name|__cd_out
operator|.
name|__cd
operator|.
name|__data
index|[
literal|0
index|]
operator|.
name|__outbufend
operator|=
name|to_end
expr_stmt|;
name|codecvt
operator|->
name|__cd_out
operator|.
name|__cd
operator|.
name|__data
index|[
literal|0
index|]
operator|.
name|__statep
operator|=
name|statep
expr_stmt|;
name|status
operator|=
name|DL_CALL_FCT
argument_list|(
name|gs
operator|->
name|__fct
argument_list|,
operator|(
name|gs
operator|,
name|codecvt
operator|->
name|__cd_out
operator|.
name|__cd
operator|.
name|__data
operator|,
name|NULL
operator|,
name|NULL
operator|,
name|NULL
operator|,
operator|&
name|dummy
operator|,
literal|1
operator|,
literal|0
operator|)
argument_list|)
expr_stmt|;
operator|*
name|to_stop
operator|=
name|codecvt
operator|->
name|__cd_out
operator|.
name|__cd
operator|.
name|__data
index|[
literal|0
index|]
operator|.
name|__outbuf
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|__GCONV_OK
case|:
case|case
name|__GCONV_EMPTY_INPUT
case|:
name|result
operator|=
name|__codecvt_ok
expr_stmt|;
break|break;
case|case
name|__GCONV_FULL_OUTPUT
case|:
case|case
name|__GCONV_INCOMPLETE_INPUT
case|:
name|result
operator|=
name|__codecvt_partial
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|__codecvt_error
expr_stmt|;
break|break;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|_GLIBCPP_USE_WCHAR_T
name|size_t
name|res
decl_stmt|;
name|char
modifier|*
name|to_start_copy
init|=
operator|(
name|char
operator|*
operator|)
name|to_start
decl_stmt|;
name|size_t
name|to_len
init|=
name|to_end
operator|-
name|to_start
decl_stmt|;
name|res
operator|=
name|iconv
argument_list|(
name|codecvt
operator|->
name|__cd_out
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|to_start_copy
argument_list|,
operator|&
name|to_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
name|result
operator|=
name|__codecvt_ok
expr_stmt|;
elseif|else
if|if
condition|(
name|to_len
operator|<
name|codecvt
operator|->
name|__codecvt_do_max_length
argument_list|(
name|codecvt
argument_list|)
condition|)
name|result
operator|=
name|__codecvt_partial
expr_stmt|;
else|else
name|result
operator|=
name|__codecvt_error
expr_stmt|;
else|#
directive|else
comment|/* Decide what to do.  */
name|result
operator|=
name|__codecvt_error
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|__codecvt_result
name|do_in
parameter_list|(
name|struct
name|_IO_codecvt
modifier|*
name|codecvt
parameter_list|,
name|__c_mbstate_t
modifier|*
name|statep
parameter_list|,
specifier|const
name|char
modifier|*
name|from_start
parameter_list|,
specifier|const
name|char
modifier|*
name|from_end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|from_stop
parameter_list|,
name|wchar_t
modifier|*
name|to_start
parameter_list|,
name|wchar_t
modifier|*
name|to_end
parameter_list|,
name|wchar_t
modifier|*
modifier|*
name|to_stop
parameter_list|)
block|{
name|enum
name|__codecvt_result
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|struct
name|__gconv_step
modifier|*
name|gs
init|=
name|codecvt
operator|->
name|__cd_in
operator|.
name|__cd
operator|.
name|__steps
decl_stmt|;
name|int
name|status
decl_stmt|;
name|size_t
name|dummy
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|from_start_copy
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|from_start
decl_stmt|;
name|codecvt
operator|->
name|__cd_in
operator|.
name|__cd
operator|.
name|__data
index|[
literal|0
index|]
operator|.
name|__outbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|to_start
expr_stmt|;
name|codecvt
operator|->
name|__cd_in
operator|.
name|__cd
operator|.
name|__data
index|[
literal|0
index|]
operator|.
name|__outbufend
operator|=
operator|(
name|char
operator|*
operator|)
name|to_end
expr_stmt|;
name|codecvt
operator|->
name|__cd_in
operator|.
name|__cd
operator|.
name|__data
index|[
literal|0
index|]
operator|.
name|__statep
operator|=
name|statep
expr_stmt|;
name|status
operator|=
name|DL_CALL_FCT
argument_list|(
name|gs
operator|->
name|__fct
argument_list|,
operator|(
name|gs
operator|,
name|codecvt
operator|->
name|__cd_in
operator|.
name|__cd
operator|.
name|__data
operator|,
operator|&
name|from_start_copy
operator|,
name|from_end
operator|,
name|NULL
operator|,
operator|&
name|dummy
operator|,
literal|0
operator|,
literal|0
operator|)
argument_list|)
expr_stmt|;
operator|*
name|from_stop
operator|=
name|from_start_copy
expr_stmt|;
operator|*
name|to_stop
operator|=
operator|(
name|wchar_t
operator|*
operator|)
name|codecvt
operator|->
name|__cd_in
operator|.
name|__cd
operator|.
name|__data
index|[
literal|0
index|]
operator|.
name|__outbuf
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|__GCONV_OK
case|:
case|case
name|__GCONV_EMPTY_INPUT
case|:
name|result
operator|=
name|__codecvt_ok
expr_stmt|;
break|break;
case|case
name|__GCONV_FULL_OUTPUT
case|:
case|case
name|__GCONV_INCOMPLETE_INPUT
case|:
name|result
operator|=
name|__codecvt_partial
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|__codecvt_error
expr_stmt|;
break|break;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|_GLIBCPP_USE_WCHAR_T
name|size_t
name|res
decl_stmt|;
specifier|const
name|char
modifier|*
name|from_start_copy
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|from_start
decl_stmt|;
name|size_t
name|from_len
init|=
name|from_end
operator|-
name|from_start
decl_stmt|;
name|char
modifier|*
name|to_start_copy
init|=
operator|(
name|char
operator|*
operator|)
name|from_start
decl_stmt|;
name|size_t
name|to_len
init|=
name|to_end
operator|-
name|to_start
decl_stmt|;
name|res
operator|=
name|iconv
argument_list|(
name|codecvt
operator|->
name|__cd_in
argument_list|,
operator|&
name|from_start_copy
argument_list|,
operator|&
name|from_len
argument_list|,
operator|&
name|to_start_copy
argument_list|,
operator|&
name|to_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
name|result
operator|=
name|__codecvt_ok
expr_stmt|;
elseif|else
if|if
condition|(
name|to_len
operator|==
literal|0
condition|)
name|result
operator|=
name|__codecvt_partial
expr_stmt|;
elseif|else
if|if
condition|(
name|from_len
operator|<
name|codecvt
operator|->
name|__codecvt_do_max_length
argument_list|(
name|codecvt
argument_list|)
condition|)
name|result
operator|=
name|__codecvt_partial
expr_stmt|;
else|else
name|result
operator|=
name|__codecvt_error
expr_stmt|;
else|#
directive|else
comment|/* Decide what to do.  */
name|result
operator|=
name|__codecvt_error
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_encoding
parameter_list|(
name|struct
name|_IO_codecvt
modifier|*
name|codecvt
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_LIBC
comment|/* See whether the encoding is stateful.  */
if|if
condition|(
name|codecvt
operator|->
name|__cd_in
operator|.
name|__cd
operator|.
name|__steps
index|[
literal|0
index|]
operator|.
name|__stateful
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Fortunately not.  Now determine the input bytes for the conversion      necessary for each wide character.  */
if|if
condition|(
name|codecvt
operator|->
name|__cd_in
operator|.
name|__cd
operator|.
name|__steps
index|[
literal|0
index|]
operator|.
name|__min_needed_from
operator|!=
name|codecvt
operator|->
name|__cd_in
operator|.
name|__cd
operator|.
name|__steps
index|[
literal|0
index|]
operator|.
name|__max_needed_from
condition|)
comment|/* Not a constant value.  */
return|return
literal|0
return|;
return|return
name|codecvt
operator|->
name|__cd_in
operator|.
name|__cd
operator|.
name|__steps
index|[
literal|0
index|]
operator|.
name|__min_needed_from
return|;
else|#
directive|else
comment|/* Worst case scenario.  */
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|do_always_noconv
parameter_list|(
name|struct
name|_IO_codecvt
modifier|*
name|codecvt
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_length
parameter_list|(
name|struct
name|_IO_codecvt
modifier|*
name|codecvt
parameter_list|,
name|__c_mbstate_t
modifier|*
name|statep
parameter_list|,
specifier|const
name|char
modifier|*
name|from_start
parameter_list|,
specifier|const
name|char
modifier|*
name|from_end
parameter_list|,
name|_IO_size_t
name|max
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
specifier|const
name|unsigned
name|char
modifier|*
name|cp
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|from_start
decl_stmt|;
name|wchar_t
name|to_buf
index|[
name|max
index|]
decl_stmt|;
name|struct
name|__gconv_step
modifier|*
name|gs
init|=
name|codecvt
operator|->
name|__cd_in
operator|.
name|__cd
operator|.
name|__steps
decl_stmt|;
name|int
name|status
decl_stmt|;
name|size_t
name|dummy
decl_stmt|;
name|codecvt
operator|->
name|__cd_in
operator|.
name|__cd
operator|.
name|__data
index|[
literal|0
index|]
operator|.
name|__outbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|to_buf
expr_stmt|;
name|codecvt
operator|->
name|__cd_in
operator|.
name|__cd
operator|.
name|__data
index|[
literal|0
index|]
operator|.
name|__outbufend
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|to_buf
index|[
name|max
index|]
expr_stmt|;
name|codecvt
operator|->
name|__cd_in
operator|.
name|__cd
operator|.
name|__data
index|[
literal|0
index|]
operator|.
name|__statep
operator|=
name|statep
expr_stmt|;
name|status
operator|=
name|DL_CALL_FCT
argument_list|(
name|gs
operator|->
name|__fct
argument_list|,
operator|(
name|gs
operator|,
name|codecvt
operator|->
name|__cd_in
operator|.
name|__cd
operator|.
name|__data
operator|,
operator|&
name|cp
operator|,
name|from_end
operator|,
name|NULL
operator|,
operator|&
name|dummy
operator|,
literal|0
operator|,
literal|0
operator|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|cp
operator|-
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|from_start
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|_GLIBCPP_USE_WCHAR_T
specifier|const
name|char
modifier|*
name|from_start_copy
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|from_start
decl_stmt|;
name|size_t
name|from_len
init|=
name|from_end
operator|-
name|from_start
decl_stmt|;
name|wchar_t
name|to_buf
index|[
name|max
index|]
decl_stmt|;
name|size_t
name|res
decl_stmt|;
name|char
modifier|*
name|to_start
init|=
operator|(
name|char
operator|*
operator|)
name|to_buf
decl_stmt|;
name|res
operator|=
name|iconv
argument_list|(
name|codecvt
operator|->
name|__cd_in
argument_list|,
operator|&
name|from_start_copy
argument_list|,
operator|&
name|from_len
argument_list|,
operator|&
name|to_start
argument_list|,
operator|&
name|max
argument_list|)
expr_stmt|;
name|result
operator|=
name|from_start_copy
operator|-
operator|(
name|char
operator|*
operator|)
name|from_start
expr_stmt|;
else|#
directive|else
comment|/* Decide what to do.  */
name|result
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_max_length
parameter_list|(
name|struct
name|_IO_codecvt
modifier|*
name|codecvt
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_LIBC
return|return
name|codecvt
operator|->
name|__cd_in
operator|.
name|__cd
operator|.
name|__steps
index|[
literal|0
index|]
operator|.
name|__max_needed_from
return|;
else|#
directive|else
return|return
name|MB_CUR_MAX
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(_GLIBCPP_USE_WCHAR_T) */
end_comment

end_unit

