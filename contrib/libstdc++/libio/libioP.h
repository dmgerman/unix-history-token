begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1993, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.    This file is part of the GNU IO Library.     This library is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2, or (at    your option) any later version.     This library is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this library; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330, Boston,    MA 02111-1307, USA.     As a special exception, if you link this library with files    compiled with a GNU compiler to produce an executable, this does    not cause the resulting executable to be covered by the GNU General    Public License.  This exception does not however invalidate any    other reasons why the executable file might be covered by the GNU    General Public License.  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__set_errno
end_ifndef

begin_define
define|#
directive|define
name|__set_errno
parameter_list|(
name|Val
parameter_list|)
value|errno = (Val)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|__GLIBC__
operator|&&
name|__GLIBC__
operator|>=
literal|2
end_if

begin_include
include|#
directive|include
file|<bits/libc-lock.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*# include<comthread.h>*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"iolibio.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
define|#
directive|define
name|_IO_seek_set
value|0
define|#
directive|define
name|_IO_seek_cur
value|1
define|#
directive|define
name|_IO_seek_end
value|2
comment|/* THE JUMPTABLE FUNCTIONS.   * The _IO_FILE type is used to implement the FILE type in GNU libc,  * as well as the streambuf class in GNU iostreams for C++.  * These are all the same, just used differently.  * An _IO_FILE (or FILE) object is allows followed by a pointer to  * a jump table (of pointers to functions).  The pointer is accessed  * with the _IO_JUMPS macro.  The jump table has a eccentric format,  * so as to be compatible with the layout of a C++ virtual function table.  * (as implemented by g++).  When a pointer to a streambuf object is  * coerced to an (_IO_FILE*), then _IO_JUMPS on the result just  * happens to point to the virtual function table of the streambuf.  * Thus the _IO_JUMPS function table used for C stdio/libio does  * double duty as the virtual function table for C++ streambuf.  *  * The entries in the _IO_JUMPS function table (and hence also the  * virtual functions of a streambuf) are described below.  * The first parameter of each function entry is the _IO_FILE/streambuf  * object being acted on (i.e. the 'this' parameter).  */
if|#
directive|if
operator|(
operator|!
name|defined
name|_IO_USE_OLD_IO_FILE
expr|\
operator|&&
operator|(
operator|!
name|defined
name|_G_IO_NO_BACKWARD_COMPAT
operator|||
name|_G_IO_NO_BACKWARD_COMPAT
operator|==
literal|0
operator|)
operator|)
define|#
directive|define
name|_IO_JUMPS_OFFSET
value|1
endif|#
directive|endif
define|#
directive|define
name|_IO_JUMPS
parameter_list|(
name|THIS
parameter_list|)
value|(THIS)->vtable
define|#
directive|define
name|_IO_WIDE_JUMPS
parameter_list|(
name|THIS
parameter_list|)
value|((struct _IO_FILE *) (THIS))->_wide_data->_wide_vtable
define|#
directive|define
name|_IO_CHECK_WIDE
parameter_list|(
name|THIS
parameter_list|)
value|(((struct _IO_FILE *) (THIS))->_wide_data != NULL)
if|#
directive|if
name|_IO_JUMPS_OFFSET
define|#
directive|define
name|_IO_JUMPS_FUNC
parameter_list|(
name|THIS
parameter_list|)
define|\
value|(*(struct _IO_jump_t **) ((void *)&_IO_JUMPS ((struct _IO_FILE_plus *) (THIS)) \ 			   + (THIS)->_vtable_offset))
else|#
directive|else
define|#
directive|define
name|_IO_JUMPS_FUNC
parameter_list|(
name|THIS
parameter_list|)
value|_IO_JUMPS ((struct _IO_FILE_plus *) (THIS))
endif|#
directive|endif
define|#
directive|define
name|_IO_WIDE_JUMPS_FUNC
parameter_list|(
name|THIS
parameter_list|)
value|_IO_WIDE_JUMPS(THIS)
if|#
directive|if
name|_G_USING_THUNKS
define|#
directive|define
name|JUMP_FIELD
parameter_list|(
name|TYPE
parameter_list|,
name|NAME
parameter_list|)
value|TYPE NAME
define|#
directive|define
name|JUMP0
parameter_list|(
name|FUNC
parameter_list|,
name|THIS
parameter_list|)
value|_IO_JUMPS_FUNC(THIS)->FUNC (THIS)
define|#
directive|define
name|JUMP1
parameter_list|(
name|FUNC
parameter_list|,
name|THIS
parameter_list|,
name|X1
parameter_list|)
value|_IO_JUMPS_FUNC(THIS)->FUNC (THIS, X1)
define|#
directive|define
name|JUMP2
parameter_list|(
name|FUNC
parameter_list|,
name|THIS
parameter_list|,
name|X1
parameter_list|,
name|X2
parameter_list|)
value|_IO_JUMPS_FUNC(THIS)->FUNC (THIS, X1, X2)
define|#
directive|define
name|JUMP3
parameter_list|(
name|FUNC
parameter_list|,
name|THIS
parameter_list|,
name|X1
parameter_list|,
name|X2
parameter_list|,
name|X3
parameter_list|)
value|_IO_JUMPS_FUNC(THIS)->FUNC (THIS, X1,X2, X3)
define|#
directive|define
name|JUMP_INIT
parameter_list|(
name|NAME
parameter_list|,
name|VALUE
parameter_list|)
value|VALUE
define|#
directive|define
name|JUMP_INIT_DUMMY
value|JUMP_INIT(dummy, 0), JUMP_INIT (dummy2, 0)
define|#
directive|define
name|WJUMP0
parameter_list|(
name|FUNC
parameter_list|,
name|THIS
parameter_list|)
value|_IO_WIDE_JUMPS_FUNC(THIS)->FUNC (THIS)
define|#
directive|define
name|WJUMP1
parameter_list|(
name|FUNC
parameter_list|,
name|THIS
parameter_list|,
name|X1
parameter_list|)
value|_IO_WIDE_JUMPS_FUNC(THIS)->FUNC (THIS, X1)
define|#
directive|define
name|WJUMP2
parameter_list|(
name|FUNC
parameter_list|,
name|THIS
parameter_list|,
name|X1
parameter_list|,
name|X2
parameter_list|)
value|_IO_WIDE_JUMPS_FUNC(THIS)->FUNC (THIS, X1, X2)
define|#
directive|define
name|WJUMP3
parameter_list|(
name|FUNC
parameter_list|,
name|THIS
parameter_list|,
name|X1
parameter_list|,
name|X2
parameter_list|,
name|X3
parameter_list|)
value|_IO_WIDE_JUMPS_FUNC(THIS)->FUNC (THIS, X1,X2, X3)
else|#
directive|else
comment|/* These macros will change when we re-implement vtables to use "thunks"! */
define|#
directive|define
name|JUMP_FIELD
parameter_list|(
name|TYPE
parameter_list|,
name|NAME
parameter_list|)
value|struct { short delta1, delta2; TYPE pfn; } NAME
define|#
directive|define
name|JUMP0
parameter_list|(
name|FUNC
parameter_list|,
name|THIS
parameter_list|)
value|_IO_JUMPS_FUNC(THIS)->FUNC.pfn (THIS)
define|#
directive|define
name|JUMP1
parameter_list|(
name|FUNC
parameter_list|,
name|THIS
parameter_list|,
name|X1
parameter_list|)
value|_IO_JUMPS_FUNC(THIS)->FUNC.pfn (THIS, X1)
define|#
directive|define
name|JUMP2
parameter_list|(
name|FUNC
parameter_list|,
name|THIS
parameter_list|,
name|X1
parameter_list|,
name|X2
parameter_list|)
value|_IO_JUMPS_FUNC(THIS)->FUNC.pfn (THIS, X1, X2)
define|#
directive|define
name|JUMP3
parameter_list|(
name|FUNC
parameter_list|,
name|THIS
parameter_list|,
name|X1
parameter_list|,
name|X2
parameter_list|,
name|X3
parameter_list|)
value|_IO_JUMPS_FUNC(THIS)->FUNC.pfn (THIS, X1,X2,X3)
define|#
directive|define
name|JUMP_INIT
parameter_list|(
name|NAME
parameter_list|,
name|VALUE
parameter_list|)
value|{0, 0, VALUE}
define|#
directive|define
name|JUMP_INIT_DUMMY
value|JUMP_INIT(dummy, 0)
define|#
directive|define
name|WJUMP0
parameter_list|(
name|FUNC
parameter_list|,
name|THIS
parameter_list|)
value|_IO_WIDE_JUMPS_FUNC(THIS)->FUNC.pfn (THIS)
define|#
directive|define
name|WJUMP1
parameter_list|(
name|FUNC
parameter_list|,
name|THIS
parameter_list|,
name|X1
parameter_list|)
value|_IO_WIDE_JUMPS_FUNC(THIS)->FUNC.pfn (THIS, X1)
define|#
directive|define
name|WJUMP2
parameter_list|(
name|FUNC
parameter_list|,
name|THIS
parameter_list|,
name|X1
parameter_list|,
name|X2
parameter_list|)
value|_IO_WIDE_JUMPS_FUNC(THIS)->FUNC.pfn (THIS, X1, X2)
define|#
directive|define
name|WJUMP3
parameter_list|(
name|FUNC
parameter_list|,
name|THIS
parameter_list|,
name|X1
parameter_list|,
name|X2
parameter_list|,
name|X3
parameter_list|)
value|_IO_WIDE_JUMPS_FUNC(THIS)->FUNC.pfn (THIS, X1,X2,X3)
endif|#
directive|endif
comment|/* The 'finish' function does any final cleaning up of an _IO_FILE object.    It does not delete (free) it, but does everything else to finalize it.    It matches the streambuf::~streambuf virtual destructor.  */
typedef|typedef
name|void
argument_list|(
argument|*_IO_finish_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
comment|/* finalize */
define|#
directive|define
name|_IO_FINISH
parameter_list|(
name|FP
parameter_list|)
value|JUMP1 (__finish, FP, 0)
define|#
directive|define
name|_IO_WFINISH
parameter_list|(
name|FP
parameter_list|)
value|WJUMP1 (__finish, FP, 0)
comment|/* The 'overflow' hook flushes the buffer.    The second argument is a character, or EOF.    It matches the streambuf::overflow virtual function. */
typedef|typedef
name|int
argument_list|(
argument|*_IO_overflow_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_OVERFLOW
parameter_list|(
name|FP
parameter_list|,
name|CH
parameter_list|)
value|JUMP1 (__overflow, FP, CH)
define|#
directive|define
name|_IO_WOVERFLOW
parameter_list|(
name|FP
parameter_list|,
name|CH
parameter_list|)
value|WJUMP1 (__overflow, FP, CH)
comment|/* The 'underflow' hook tries to fills the get buffer.    It returns the next character (as an unsigned char) or EOF.  The next    character remains in the get buffer, and the get position is not changed.    It matches the streambuf::underflow virtual function. */
typedef|typedef
name|int
argument_list|(
argument|*_IO_underflow_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_UNDERFLOW
parameter_list|(
name|FP
parameter_list|)
value|JUMP0 (__underflow, FP)
define|#
directive|define
name|_IO_WUNDERFLOW
parameter_list|(
name|FP
parameter_list|)
value|WJUMP0 (__underflow, FP)
comment|/* The 'uflow' hook returns the next character in the input stream    (cast to unsigned char), and increments the read position;    EOF is returned on failure.    It matches the streambuf::uflow virtual function, which is not in the    cfront implementation, but was added to C++ by the ANSI/ISO committee. */
define|#
directive|define
name|_IO_UFLOW
parameter_list|(
name|FP
parameter_list|)
value|JUMP0 (__uflow, FP)
define|#
directive|define
name|_IO_WUFLOW
parameter_list|(
name|FP
parameter_list|)
value|WJUMP0 (__uflow, FP)
comment|/* The 'pbackfail' hook handles backing up.    It matches the streambuf::pbackfail virtual function. */
typedef|typedef
name|int
argument_list|(
argument|*_IO_pbackfail_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_PBACKFAIL
parameter_list|(
name|FP
parameter_list|,
name|CH
parameter_list|)
value|JUMP1 (__pbackfail, FP, CH)
define|#
directive|define
name|_IO_WPBACKFAIL
parameter_list|(
name|FP
parameter_list|,
name|CH
parameter_list|)
value|WJUMP1 (__pbackfail, FP, CH)
comment|/* The 'xsputn' hook writes upto N characters from buffer DATA.    Returns the number of character actually written.    It matches the streambuf::xsputn virtual function. */
typedef|typedef
name|_IO_size_t
argument_list|(
argument|*_IO_xsputn_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
name|FP
operator|,
specifier|const
name|void
operator|*
name|DATA
operator|,
name|_IO_size_t
name|N
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_XSPUTN
parameter_list|(
name|FP
parameter_list|,
name|DATA
parameter_list|,
name|N
parameter_list|)
value|JUMP2 (__xsputn, FP, DATA, N)
define|#
directive|define
name|_IO_WXSPUTN
parameter_list|(
name|FP
parameter_list|,
name|DATA
parameter_list|,
name|N
parameter_list|)
value|WJUMP2 (__xsputn, FP, DATA, N)
comment|/* The 'xsgetn' hook reads upto N characters into buffer DATA.    Returns the number of character actually read.    It matches the streambuf::xsgetn virtual function. */
typedef|typedef
name|_IO_size_t
argument_list|(
argument|*_IO_xsgetn_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
name|FP
operator|,
name|void
operator|*
name|DATA
operator|,
name|_IO_size_t
name|N
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_XSGETN
parameter_list|(
name|FP
parameter_list|,
name|DATA
parameter_list|,
name|N
parameter_list|)
value|JUMP2 (__xsgetn, FP, DATA, N)
define|#
directive|define
name|_IO_WXSGETN
parameter_list|(
name|FP
parameter_list|,
name|DATA
parameter_list|,
name|N
parameter_list|)
value|WJUMP2 (__xsgetn, FP, DATA, N)
comment|/* The 'seekoff' hook moves the stream position to a new position    relative to the start of the file (if DIR==0), the current position    (MODE==1), or the end of the file (MODE==2).    It matches the streambuf::seekoff virtual function.    It is also used for the ANSI fseek function. */
typedef|typedef
name|_IO_off64_t
argument_list|(
argument|*_IO_seekoff_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
name|FP
operator|,
name|_IO_off64_t
name|OFF
operator|,
name|int
name|DIR
operator|,
name|int
name|MODE
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_SEEKOFF
parameter_list|(
name|FP
parameter_list|,
name|OFF
parameter_list|,
name|DIR
parameter_list|,
name|MODE
parameter_list|)
value|JUMP3 (__seekoff, FP, OFF, DIR, MODE)
define|#
directive|define
name|_IO_WSEEKOFF
parameter_list|(
name|FP
parameter_list|,
name|OFF
parameter_list|,
name|DIR
parameter_list|,
name|MODE
parameter_list|)
value|WJUMP3 (__seekoff, FP, OFF, DIR, MODE)
comment|/* The 'seekpos' hook also moves the stream position,    but to an absolute position given by a fpos64_t (seekpos).    It matches the streambuf::seekpos virtual function.    It is also used for the ANSI fgetpos and fsetpos functions.  */
comment|/* The _IO_seek_cur and _IO_seek_end options are not allowed. */
typedef|typedef
name|_IO_off64_t
argument_list|(
argument|*_IO_seekpos_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_off64_t
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_SEEKPOS
parameter_list|(
name|FP
parameter_list|,
name|POS
parameter_list|,
name|FLAGS
parameter_list|)
value|JUMP2 (__seekpos, FP, POS, FLAGS)
define|#
directive|define
name|_IO_WSEEKPOS
parameter_list|(
name|FP
parameter_list|,
name|POS
parameter_list|,
name|FLAGS
parameter_list|)
value|WJUMP2 (__seekpos, FP, POS, FLAGS)
comment|/* The 'setbuf' hook gives a buffer to the file.    It matches the streambuf::setbuf virtual function. */
typedef|typedef
name|_IO_FILE
operator|*
operator|(
operator|*
name|_IO_setbuf_t
operator|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|_IO_ssize_t
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_SETBUF
parameter_list|(
name|FP
parameter_list|,
name|BUFFER
parameter_list|,
name|LENGTH
parameter_list|)
value|JUMP2 (__setbuf, FP, BUFFER, LENGTH)
define|#
directive|define
name|_IO_WSETBUF
parameter_list|(
name|FP
parameter_list|,
name|BUFFER
parameter_list|,
name|LENGTH
parameter_list|)
value|WJUMP2 (__setbuf, FP, BUFFER, LENGTH)
comment|/* The 'sync' hook attempts to synchronize the internal data structures    of the file with the external state.    It matches the streambuf::sync virtual function. */
typedef|typedef
name|int
argument_list|(
argument|*_IO_sync_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_SYNC
parameter_list|(
name|FP
parameter_list|)
value|JUMP0 (__sync, FP)
define|#
directive|define
name|_IO_WSYNC
parameter_list|(
name|FP
parameter_list|)
value|WJUMP0 (__sync, FP)
comment|/* The 'doallocate' hook is used to tell the file to allocate a buffer.    It matches the streambuf::doallocate virtual function, which is not    in the ANSI/ISO C++ standard, but is part traditional implementations. */
typedef|typedef
name|int
argument_list|(
argument|*_IO_doallocate_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_DOALLOCATE
parameter_list|(
name|FP
parameter_list|)
value|JUMP0 (__doallocate, FP)
define|#
directive|define
name|_IO_WDOALLOCATE
parameter_list|(
name|FP
parameter_list|)
value|WJUMP0 (__doallocate, FP)
comment|/* The following four hooks (sysread, syswrite, sysclose, sysseek, and    sysstat) are low-level hooks specific to this implementation.    There is no correspondence in the ANSI/ISO C++ standard library.    The hooks basically correspond to the Unix system functions    (read, write, close, lseek, and stat) except that a _IO_FILE*    parameter is used instead of a integer file descriptor;  the default    implementation used for normal files just calls those functions.    The advantage of overriding these functions instead of the higher-level    ones (underflow, overflow etc) is that you can leave all the buffering    higher-level functions.  */
comment|/* The 'sysread' hook is used to read data from the external file into    an existing buffer.  It generalizes the Unix read(2) function.    It matches the streambuf::sys_read virtual function, which is    specific to this implementation. */
typedef|typedef
name|_IO_ssize_t
argument_list|(
argument|*_IO_read_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|void
operator|*
operator|,
name|_IO_ssize_t
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_SYSREAD
parameter_list|(
name|FP
parameter_list|,
name|DATA
parameter_list|,
name|LEN
parameter_list|)
value|JUMP2 (__read, FP, DATA, LEN)
define|#
directive|define
name|_IO_WSYSREAD
parameter_list|(
name|FP
parameter_list|,
name|DATA
parameter_list|,
name|LEN
parameter_list|)
value|WJUMP2 (__read, FP, DATA, LEN)
comment|/* The 'syswrite' hook is used to write data from an existing buffer    to an external file.  It generalizes the Unix write(2) function.    It matches the streambuf::sys_write virtual function, which is    specific to this implementation. */
typedef|typedef
name|_IO_ssize_t
argument_list|(
argument|*_IO_write_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|void
operator|*
operator|,
name|_IO_ssize_t
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_SYSWRITE
parameter_list|(
name|FP
parameter_list|,
name|DATA
parameter_list|,
name|LEN
parameter_list|)
value|JUMP2 (__write, FP, DATA, LEN)
define|#
directive|define
name|_IO_WSYSWRITE
parameter_list|(
name|FP
parameter_list|,
name|DATA
parameter_list|,
name|LEN
parameter_list|)
value|WJUMP2 (__write, FP, DATA, LEN)
comment|/* The 'sysseek' hook is used to re-position an external file.    It generalizes the Unix lseek(2) function.    It matches the streambuf::sys_seek virtual function, which is    specific to this implementation. */
typedef|typedef
name|_IO_off64_t
argument_list|(
argument|*_IO_seek_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_off64_t
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_SYSSEEK
parameter_list|(
name|FP
parameter_list|,
name|OFFSET
parameter_list|,
name|MODE
parameter_list|)
value|JUMP2 (__seek, FP, OFFSET, MODE)
define|#
directive|define
name|_IO_WSYSSEEK
parameter_list|(
name|FP
parameter_list|,
name|OFFSET
parameter_list|,
name|MODE
parameter_list|)
value|WJUMP2 (__seek, FP, OFFSET, MODE)
comment|/* The 'sysclose' hook is used to finalize (close, finish up) an    external file.  It generalizes the Unix close(2) function.    It matches the streambuf::sys_close virtual function, which is    specific to this implementation. */
typedef|typedef
name|int
argument_list|(
argument|*_IO_close_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* finalize */
define|#
directive|define
name|_IO_SYSCLOSE
parameter_list|(
name|FP
parameter_list|)
value|JUMP0 (__close, FP)
define|#
directive|define
name|_IO_WSYSCLOSE
parameter_list|(
name|FP
parameter_list|)
value|WJUMP0 (__close, FP)
comment|/* The 'sysstat' hook is used to get information about an external file    into a struct stat buffer.  It generalizes the Unix fstat(2) call.    It matches the streambuf::sys_stat virtual function, which is    specific to this implementation. */
typedef|typedef
name|int
argument_list|(
argument|*_IO_stat_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_SYSSTAT
parameter_list|(
name|FP
parameter_list|,
name|BUF
parameter_list|)
value|JUMP1 (__stat, FP, BUF)
define|#
directive|define
name|_IO_WSYSSTAT
parameter_list|(
name|FP
parameter_list|,
name|BUF
parameter_list|)
value|WJUMP1 (__stat, FP, BUF)
comment|/* The 'showmany' hook can be used to get an image how much input is    available.  In many cases the answer will be 0 which means unknown    but some cases one can provide real information.  */
typedef|typedef
name|int
argument_list|(
argument|*_IO_showmanyc_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_SHOWMANYC
parameter_list|(
name|FP
parameter_list|)
value|JUMP0 (__showmanyc, FP)
define|#
directive|define
name|_IO_WSHOWMANYC
parameter_list|(
name|FP
parameter_list|)
value|WJUMP0 (__showmanyc, FP)
comment|/* The 'imbue' hook is used to get information about the currently    installed locales.  */
typedef|typedef
name|void
argument_list|(
argument|*_IO_imbue_t
argument_list|)
name|__PMT
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|_IO_IMBUE
parameter_list|(
name|FP
parameter_list|,
name|LOCALE
parameter_list|)
value|JUMP1 (__imbue, FP, LOCALE)
define|#
directive|define
name|_IO_WIMBUE
parameter_list|(
name|FP
parameter_list|,
name|LOCALE
parameter_list|)
value|WJUMP1 (__imbue, FP, LOCALE)
define|#
directive|define
name|_IO_CHAR_TYPE
value|char
comment|/* unsigned char ? */
define|#
directive|define
name|_IO_INT_TYPE
value|int
struct|struct
name|_IO_jump_t
block|{
name|JUMP_FIELD
argument_list|(
name|_G_size_t
argument_list|,
name|__dummy
argument_list|)
expr_stmt|;
if|#
directive|if
name|_G_USING_THUNKS
name|JUMP_FIELD
argument_list|(
name|_G_size_t
argument_list|,
name|__dummy2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|JUMP_FIELD
argument_list|(
name|_IO_finish_t
argument_list|,
name|__finish
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_overflow_t
argument_list|,
name|__overflow
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_underflow_t
argument_list|,
name|__underflow
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_underflow_t
argument_list|,
name|__uflow
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_pbackfail_t
argument_list|,
name|__pbackfail
argument_list|)
expr_stmt|;
comment|/* showmany */
name|JUMP_FIELD
argument_list|(
name|_IO_xsputn_t
argument_list|,
name|__xsputn
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_xsgetn_t
argument_list|,
name|__xsgetn
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_seekoff_t
argument_list|,
name|__seekoff
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_seekpos_t
argument_list|,
name|__seekpos
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_setbuf_t
argument_list|,
name|__setbuf
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_sync_t
argument_list|,
name|__sync
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_doallocate_t
argument_list|,
name|__doallocate
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_read_t
argument_list|,
name|__read
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_write_t
argument_list|,
name|__write
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_seek_t
argument_list|,
name|__seek
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_close_t
argument_list|,
name|__close
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_stat_t
argument_list|,
name|__stat
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_showmanyc_t
argument_list|,
name|__showmanyc
argument_list|)
expr_stmt|;
name|JUMP_FIELD
argument_list|(
name|_IO_imbue_t
argument_list|,
name|__imbue
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|get_column;     set_column;
endif|#
directive|endif
block|}
struct|;
comment|/* We always allocate an extra word following an _IO_FILE.    This contains a pointer to the function jump table used.    This is for compatibility with C++ streambuf; the word can    be used to smash to a pointer to a virtual function table. */
struct|struct
name|_IO_FILE_plus
block|{
name|_IO_FILE
name|file
decl_stmt|;
specifier|const
name|struct
name|_IO_jump_t
modifier|*
name|vtable
decl_stmt|;
block|}
struct|;
comment|/* Special file type for fopencookie function.  */
struct|struct
name|_IO_cookie_file
block|{
name|struct
name|_IO_FILE_plus
name|__fp
decl_stmt|;
name|void
modifier|*
name|__cookie
decl_stmt|;
name|_IO_cookie_io_functions_t
name|__io_functions
decl_stmt|;
block|}
struct|;
comment|/* Iterator type for walking global linked list of _IO_FILE objects. */
typedef|typedef
name|struct
name|_IO_FILE
modifier|*
name|_IO_ITER
typedef|;
comment|/* Generic functions */
specifier|extern
name|void
name|_IO_switch_to_main_get_area
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_switch_to_backup_area
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_switch_to_get_mode
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_init
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_sputbackc
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_sungetc
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_un_link
name|__P
argument_list|(
operator|(
expr|struct
name|_IO_FILE_plus
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_link_in
name|__P
argument_list|(
operator|(
expr|struct
name|_IO_FILE_plus
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_doallocbuf
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_unsave_markers
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_setb
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|unsigned
name|_IO_adjust_column
name|__P
argument_list|(
operator|(
name|unsigned
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
define|#
directive|define
name|_IO_sputn
parameter_list|(
name|__fp
parameter_list|,
name|__s
parameter_list|,
name|__n
parameter_list|)
value|_IO_XSPUTN (__fp, __s, __n)
specifier|extern
name|void
name|_IO_switch_to_main_wget_area
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_switch_to_wbackup_area
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_switch_to_wget_mode
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_wsetb
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|wchar_t
operator|*
operator|,
name|wchar_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|wint_t
name|_IO_sputbackwc
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|wint_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|wint_t
name|_IO_sungetwc
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_wdoallocbuf
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_unsave_wmarkers
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|unsigned
name|_IO_adjust_wcolumn
name|__P
argument_list|(
operator|(
name|unsigned
operator|,
specifier|const
name|wchar_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Marker-related function. */
specifier|extern
name|void
name|_IO_init_marker
name|__P
argument_list|(
operator|(
expr|struct
name|_IO_marker
operator|*
operator|,
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_init_wmarker
name|__P
argument_list|(
operator|(
expr|struct
name|_IO_marker
operator|*
operator|,
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_remove_marker
name|__P
argument_list|(
operator|(
expr|struct
name|_IO_marker
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_marker_difference
name|__P
argument_list|(
operator|(
expr|struct
name|_IO_marker
operator|*
operator|,
expr|struct
name|_IO_marker
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_marker_delta
name|__P
argument_list|(
operator|(
expr|struct
name|_IO_marker
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_wmarker_delta
name|__P
argument_list|(
operator|(
expr|struct
name|_IO_marker
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_seekmark
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
expr|struct
name|_IO_marker
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_seekwmark
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
expr|struct
name|_IO_marker
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Functions for iterating global list and dealing with    its lock */
specifier|extern
name|_IO_ITER
name|_IO_iter_begin
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_ITER
name|_IO_iter_end
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_ITER
name|_IO_iter_next
name|__P
argument_list|(
operator|(
name|_IO_ITER
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_FILE
modifier|*
name|_IO_iter_file
name|__P
argument_list|(
operator|(
name|_IO_ITER
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_list_lock
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_list_unlock
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_list_resetlock
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
comment|/* Default jumptable functions. */
specifier|extern
name|int
name|_IO_default_underflow
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_default_uflow
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|wint_t
name|_IO_wdefault_uflow
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_default_doallocate
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_wdefault_doallocate
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_default_finish
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_wdefault_finish
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_default_pbackfail
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|wint_t
name|_IO_wdefault_pbackfail
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|wint_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_FILE
modifier|*
name|_IO_default_setbuf
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|_IO_ssize_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_FILE
modifier|*
name|_IO_wdefault_setbuf
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|wchar_t
operator|*
operator|,
name|_IO_ssize_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_size_t
name|_IO_default_xsputn
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|void
operator|*
operator|,
name|_IO_size_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_size_t
name|_IO_wdefault_xsputn
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|void
operator|*
operator|,
name|_IO_size_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_size_t
name|_IO_default_xsgetn
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|void
operator|*
operator|,
name|_IO_size_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_size_t
name|_IO_wdefault_xsgetn
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|void
operator|*
operator|,
name|_IO_size_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_off64_t
name|_IO_default_seekoff
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_off64_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_off64_t
name|_IO_default_seekpos
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_off64_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_ssize_t
name|_IO_default_write
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|void
operator|*
operator|,
name|_IO_ssize_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_ssize_t
name|_IO_default_read
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|void
operator|*
operator|,
name|_IO_ssize_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_default_stat
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_off64_t
name|_IO_default_seek
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_off64_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_default_sync
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
define|#
directive|define
name|_IO_default_close
value|((_IO_close_t) _IO_default_sync)
specifier|extern
name|int
name|_IO_default_showmanyc
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_default_imbue
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|struct
name|_IO_jump_t
name|_IO_file_jumps
decl_stmt|;
specifier|extern
name|struct
name|_IO_jump_t
name|_IO_wfile_jumps
decl_stmt|;
specifier|extern
name|struct
name|_IO_jump_t
name|_IO_old_file_jumps
decl_stmt|;
specifier|extern
name|struct
name|_IO_jump_t
name|_IO_streambuf_jumps
decl_stmt|;
specifier|extern
name|struct
name|_IO_jump_t
name|_IO_proc_jumps
decl_stmt|;
specifier|extern
name|struct
name|_IO_jump_t
name|_IO_old_proc_jumps
decl_stmt|;
specifier|extern
name|struct
name|_IO_jump_t
name|_IO_str_jumps
decl_stmt|;
specifier|extern
name|struct
name|_IO_jump_t
name|_IO_wstr_jumps
decl_stmt|;
specifier|extern
name|struct
name|_IO_codecvt
name|__libio_codecvt
decl_stmt|;
specifier|extern
name|int
name|_IO_do_write
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|_IO_size_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_new_do_write
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|_IO_size_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_old_do_write
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|_IO_size_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_wdo_write
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|wchar_t
operator|*
operator|,
name|_IO_size_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_flush_all
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_cleanup
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_flush_all_linebuffered
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_new_fgetpos
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_fpos_t
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_old_fgetpos
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_fpos_t
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_new_fsetpos
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|_IO_fpos_t
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_old_fsetpos
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|_IO_fpos_t
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_new_fgetpos64
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_fpos64_t
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_old_fgetpos64
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_fpos64_t
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_new_fsetpos64
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|_IO_fpos64_t
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_old_fsetpos64
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|_IO_fpos64_t
operator|*
operator|)
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
name|_LIBC
operator|||
name|defined
name|_GLIBCPP_USE_WCHAR_T
define|#
directive|define
name|_IO_do_flush
parameter_list|(
name|_f
parameter_list|)
define|\
value|((_f)->_mode<= 0							      \    ? _IO_do_write(_f, (_f)->_IO_write_base,				      \ 		  (_f)->_IO_write_ptr-(_f)->_IO_write_base)		      \    : _IO_wdo_write(_f, (_f)->_wide_data->_IO_write_base,		      \ 		   ((_f)->_wide_data->_IO_write_ptr			      \ 		    - (_f)->_wide_data->_IO_write_base)))
else|#
directive|else
define|#
directive|define
name|_IO_do_flush
parameter_list|(
name|_f
parameter_list|)
define|\
value|_IO_do_write(_f, (_f)->_IO_write_base,				      \ 		(_f)->_IO_write_ptr-(_f)->_IO_write_base)
endif|#
directive|endif
define|#
directive|define
name|_IO_old_do_flush
parameter_list|(
name|_f
parameter_list|)
define|\
value|_IO_old_do_write(_f, (_f)->_IO_write_base, \ 		   (_f)->_IO_write_ptr-(_f)->_IO_write_base)
define|#
directive|define
name|_IO_in_put_mode
parameter_list|(
name|_fp
parameter_list|)
value|((_fp)->_flags& _IO_CURRENTLY_PUTTING)
define|#
directive|define
name|_IO_mask_flags
parameter_list|(
name|fp
parameter_list|,
name|f
parameter_list|,
name|mask
parameter_list|)
define|\
value|((fp)->_flags = ((fp)->_flags& ~(mask)) | ((f)& (mask)))
define|#
directive|define
name|_IO_setg
parameter_list|(
name|fp
parameter_list|,
name|eb
parameter_list|,
name|g
parameter_list|,
name|eg
parameter_list|)
value|((fp)->_IO_read_base = (eb),\ 	(fp)->_IO_read_ptr = (g), (fp)->_IO_read_end = (eg))
define|#
directive|define
name|_IO_wsetg
parameter_list|(
name|fp
parameter_list|,
name|eb
parameter_list|,
name|g
parameter_list|,
name|eg
parameter_list|)
value|((fp)->_wide_data->_IO_read_base = (eb),\ 	(fp)->_wide_data->_IO_read_ptr = (g), \ 	(fp)->_wide_data->_IO_read_end = (eg))
define|#
directive|define
name|_IO_setp
parameter_list|(
name|__fp
parameter_list|,
name|__p
parameter_list|,
name|__ep
parameter_list|)
define|\
value|((__fp)->_IO_write_base = (__fp)->_IO_write_ptr \ 	= __p, (__fp)->_IO_write_end = (__ep))
define|#
directive|define
name|_IO_wsetp
parameter_list|(
name|__fp
parameter_list|,
name|__p
parameter_list|,
name|__ep
parameter_list|)
define|\
value|((__fp)->_wide_data->_IO_write_base \ 	= (__fp)->_wide_data->_IO_write_ptr = __p, \ 	(__fp)->_wide_data->_IO_write_end = (__ep))
define|#
directive|define
name|_IO_have_backup
parameter_list|(
name|fp
parameter_list|)
value|((fp)->_IO_save_base != NULL)
define|#
directive|define
name|_IO_have_wbackup
parameter_list|(
name|fp
parameter_list|)
value|((fp)->_wide_data->_IO_save_base != NULL)
define|#
directive|define
name|_IO_in_backup
parameter_list|(
name|fp
parameter_list|)
value|((fp)->_flags& _IO_IN_BACKUP)
define|#
directive|define
name|_IO_have_markers
parameter_list|(
name|fp
parameter_list|)
value|((fp)->_markers != NULL)
define|#
directive|define
name|_IO_blen
parameter_list|(
name|fp
parameter_list|)
value|((fp)->_IO_buf_end - (fp)->_IO_buf_base)
define|#
directive|define
name|_IO_wblen
parameter_list|(
name|fp
parameter_list|)
value|((fp)->_wide_data->_IO_buf_end \ 		       - (fp)->_wide_data->_IO_buf_base)
comment|/* Jumptable functions for files. */
specifier|extern
name|int
name|_IO_file_doallocate
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_FILE
modifier|*
name|_IO_file_setbuf
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|_IO_ssize_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_off64_t
name|_IO_file_seekoff
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_off64_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_size_t
name|_IO_file_xsputn
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|void
operator|*
operator|,
name|_IO_size_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_size_t
name|_IO_file_xsgetn
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|void
operator|*
operator|,
name|_IO_size_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_file_stat
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_file_close
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_file_underflow
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_file_overflow
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
define|#
directive|define
name|_IO_file_is_open
parameter_list|(
name|__fp
parameter_list|)
value|((__fp)->_fileno != -1)
specifier|extern
name|void
name|_IO_file_init
name|__P
argument_list|(
operator|(
expr|struct
name|_IO_FILE_plus
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_FILE
modifier|*
name|_IO_file_attach
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_FILE
modifier|*
name|_IO_file_open
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_FILE
modifier|*
name|_IO_file_fopen
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_ssize_t
name|_IO_file_write
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|void
operator|*
operator|,
name|_IO_ssize_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_ssize_t
name|_IO_file_read
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|void
operator|*
operator|,
name|_IO_ssize_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_file_sync
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_file_close_it
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_off64_t
name|_IO_file_seek
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_off64_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_file_finish
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_FILE
modifier|*
name|_IO_new_file_attach
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_new_file_close_it
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_new_file_finish
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_FILE
modifier|*
name|_IO_new_file_fopen
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_no_init
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|,
expr|struct
name|_IO_wide_data
operator|*
operator|,
expr|struct
name|_IO_jump_t
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_new_file_init
name|__P
argument_list|(
operator|(
expr|struct
name|_IO_FILE_plus
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_FILE
modifier|*
name|_IO_new_file_setbuf
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|_IO_ssize_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_new_file_sync
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_new_file_underflow
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_new_file_overflow
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_off64_t
name|_IO_new_file_seekoff
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_off64_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_ssize_t
name|_IO_new_file_write
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|void
operator|*
operator|,
name|_IO_ssize_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_size_t
name|_IO_new_file_xsputn
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|void
operator|*
operator|,
name|_IO_size_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_FILE
modifier|*
name|_IO_old_file_setbuf
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|_IO_ssize_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_off64_t
name|_IO_old_file_seekoff
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_off64_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_size_t
name|_IO_old_file_xsputn
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|void
operator|*
operator|,
name|_IO_size_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_old_file_underflow
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_old_file_overflow
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_old_file_init
name|__P
argument_list|(
operator|(
expr|struct
name|_IO_FILE_plus
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_FILE
modifier|*
name|_IO_old_file_attach
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_FILE
modifier|*
name|_IO_old_file_fopen
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_ssize_t
name|_IO_old_file_write
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|void
operator|*
operator|,
name|_IO_ssize_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_old_file_sync
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_old_file_close_it
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_old_file_finish
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_wfile_doallocate
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_size_t
name|_IO_wfile_xsputn
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|void
operator|*
operator|,
name|_IO_size_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_FILE
modifier|*
name|_IO_wfile_setbuf
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|wchar_t
operator|*
operator|,
name|_IO_ssize_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|wint_t
name|_IO_wfile_sync
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|wint_t
name|_IO_wfile_underflow
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|wint_t
name|_IO_wfile_overflow
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|wint_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_off64_t
name|_IO_wfile_seekoff
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_off64_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Jumptable functions for proc_files. */
specifier|extern
name|_IO_FILE
modifier|*
name|_IO_proc_open
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_FILE
modifier|*
name|_IO_new_proc_open
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_FILE
modifier|*
name|_IO_old_proc_open
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_proc_close
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_new_proc_close
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_old_proc_close
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Jumptable functions for strfiles. */
specifier|extern
name|int
name|_IO_str_underflow
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_str_overflow
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_str_pbackfail
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_off64_t
name|_IO_str_seekoff
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_off64_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_str_finish
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Other strfile functions */
struct_decl|struct
name|_IO_strfile_
struct_decl|;
specifier|extern
name|void
name|_IO_str_init_static
name|__P
argument_list|(
operator|(
expr|struct
name|_IO_strfile_
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_str_init_readonly
name|__P
argument_list|(
operator|(
expr|struct
name|_IO_strfile_
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_ssize_t
name|_IO_str_count
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* And the wide character versions.  */
specifier|extern
name|void
name|_IO_wstr_init_static
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|wchar_t
operator|*
operator|,
name|int
operator|,
name|wchar_t
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_wstr_init_readonly
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_ssize_t
name|_IO_wstr_count
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_wint_t
name|_IO_wstr_overflow
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_wint_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_wint_t
name|_IO_wstr_underflow
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_off64_t
name|_IO_wstr_seekoff
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_off64_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_wint_t
name|_IO_wstr_pbackfail
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|_IO_wint_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|_IO_wstr_finish
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_vasprintf
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
name|result_ptr
operator|,
name|__const
name|char
operator|*
name|format
operator|,
name|_IO_va_list
name|args
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_vdprintf
name|__P
argument_list|(
operator|(
name|int
name|d
operator|,
name|__const
name|char
operator|*
name|format
operator|,
name|_IO_va_list
name|arg
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_vsnprintf
name|__P
argument_list|(
operator|(
name|char
operator|*
name|string
operator|,
name|_IO_size_t
name|maxlen
operator|,
name|__const
name|char
operator|*
name|format
operator|,
name|_IO_va_list
name|args
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_size_t
name|_IO_getline
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|_IO_size_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_size_t
name|_IO_getline_info
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|_IO_size_t
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_ssize_t
name|_IO_getdelim
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|_IO_size_t
operator|*
operator|,
name|int
operator|,
name|_IO_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_size_t
name|_IO_getwline
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|wchar_t
operator|*
operator|,
name|_IO_size_t
operator|,
name|wint_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|_IO_size_t
name|_IO_getwline_info
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
operator|,
name|wchar_t
operator|*
operator|,
name|_IO_size_t
operator|,
name|wint_t
operator|,
name|int
operator|,
name|wint_t
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|double
name|_IO_strtod
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
name|_IO_dtoa
name|__P
argument_list|(
operator|(
name|double
name|__d
operator|,
name|int
name|__mode
operator|,
name|int
name|__ndigits
operator|,
name|int
operator|*
name|__decpt
operator|,
name|int
operator|*
name|__sign
operator|,
name|char
operator|*
operator|*
name|__rve
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|_IO_outfloat
name|__P
argument_list|(
operator|(
name|double
name|__value
operator|,
name|_IO_FILE
operator|*
name|__sb
operator|,
name|int
name|__type
operator|,
name|int
name|__width
operator|,
name|int
name|__precision
operator|,
name|int
name|__flags
operator|,
name|int
name|__sign_mode
operator|,
name|int
name|__fill
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|struct
name|_IO_FILE_plus
modifier|*
name|_IO_list_all
decl_stmt|;
extern|extern void (*_IO_cleanup_registration_needed
block|)
name|__PMT
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_extern

begin_ifndef
ifndef|#
directive|ifndef
name|EOF
end_ifndef

begin_define
define|#
directive|define
name|EOF
value|(-1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_if
if|#
directive|if
name|defined
name|__GNUG__
operator|&&
expr|\
operator|(
name|__GNUC__
operator|>
literal|2
operator|||
operator|(
name|__GNUC__
operator|==
literal|2
operator|&&
name|__GNUC_MINOR__
operator|>=
literal|8
operator|)
operator|)
end_if

begin_define
define|#
directive|define
name|NULL
value|(__null)
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_define
define|#
directive|define
name|NULL
value|((void*)0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NULL
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|_G_HAVE_MMAP
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_expr_stmt
unit|extern
literal|"C"
block|{
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAP_ANONYMOUS
argument_list|)
operator|&&
name|defined
argument_list|(
name|MAP_ANON
argument_list|)
define|#
directive|define
name|MAP_ANONYMOUS
value|MAP_ANON
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAP_ANONYMOUS
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|EXEC_PAGESIZE
argument_list|)
undef|#
directive|undef
name|_G_HAVE_MMAP
define|#
directive|define
name|_G_HAVE_MMAP
value|0
endif|#
directive|endif
endif|#
directive|endif
comment|/* _G_HAVE_MMAP */
if|#
directive|if
name|_G_HAVE_MMAP
ifdef|#
directive|ifdef
name|_LIBC
comment|/* When using this code in the GNU libc we must not pollute the name space.  */
define|#
directive|define
name|mmap
value|__mmap
define|#
directive|define
name|munmap
value|__munmap
define|#
directive|define
name|ftruncate
value|__ftruncate
endif|#
directive|endif
define|#
directive|define
name|ROUND_TO_PAGE
parameter_list|(
name|_S
parameter_list|)
define|\
value|(((_S) + EXEC_PAGESIZE - 1)& ~(EXEC_PAGESIZE - 1))
define|#
directive|define
name|FREE_BUF
parameter_list|(
name|_B
parameter_list|,
name|_S
parameter_list|)
define|\
value|munmap ((_B), ROUND_TO_PAGE (_S))
define|#
directive|define
name|ALLOC_BUF
parameter_list|(
name|_B
parameter_list|,
name|_S
parameter_list|,
name|_R
parameter_list|)
define|\
value|do {								      \ 	  (_B) = (char *) mmap (0, ROUND_TO_PAGE (_S),			      \ 				PROT_READ | PROT_WRITE,			      \ 				MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);	      \ 	  if ((_B) == (char *) MAP_FAILED)				      \ 	    return (_R);						      \        } while (0)
define|#
directive|define
name|ALLOC_WBUF
parameter_list|(
name|_B
parameter_list|,
name|_S
parameter_list|,
name|_R
parameter_list|)
define|\
value|do {								      \ 	  (_B) = (wchar_t *) mmap (0, ROUND_TO_PAGE (_S),		      \ 				   PROT_READ | PROT_WRITE,		      \ 				   MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);	      \ 	  if ((_B) == (wchar_t *) MAP_FAILED)				      \ 	    return (_R);						      \        } while (0)
else|#
directive|else
comment|/* _G_HAVE_MMAP */
define|#
directive|define
name|FREE_BUF
parameter_list|(
name|_B
parameter_list|,
name|_S
parameter_list|)
define|\
value|free(_B)
define|#
directive|define
name|ALLOC_BUF
parameter_list|(
name|_B
parameter_list|,
name|_S
parameter_list|,
name|_R
parameter_list|)
define|\
value|do {								      \ 	  (_B) = (char*)malloc(_S);					      \ 	  if ((_B) == NULL)						      \ 	    return (_R);						      \        } while (0)
define|#
directive|define
name|ALLOC_WBUF
parameter_list|(
name|_B
parameter_list|,
name|_S
parameter_list|,
name|_R
parameter_list|)
define|\
value|do {								      \ 	  (_B) = (wchar_t *)malloc(_S);					      \ 	  if ((_B) == NULL)						      \ 	    return (_R);						      \        } while (0)
endif|#
directive|endif
comment|/* _G_HAVE_MMAP */
ifndef|#
directive|ifndef
name|OS_FSTAT
define|#
directive|define
name|OS_FSTAT
value|fstat
endif|#
directive|endif
block|struct
name|stat
block|;
specifier|extern
name|_IO_ssize_t
name|_IO_read
name|__P
argument_list|(
operator|(
name|int
operator|,
name|void
operator|*
operator|,
name|_IO_size_t
operator|)
argument_list|)
block|;
specifier|extern
name|_IO_ssize_t
name|_IO_write
name|__P
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|void
operator|*
operator|,
name|_IO_size_t
operator|)
argument_list|)
block|;
specifier|extern
name|_IO_off64_t
name|_IO_lseek
name|__P
argument_list|(
operator|(
name|int
operator|,
name|_IO_off64_t
operator|,
name|int
operator|)
argument_list|)
block|;
specifier|extern
name|int
name|_IO_close
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
block|;
specifier|extern
name|int
name|_IO_fstat
name|__P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|stat
operator|*
operator|)
argument_list|)
block|;
specifier|extern
name|int
name|_IO_vscanf
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|_IO_va_list
operator|)
argument_list|)
block|;
comment|/* _IO_pos_BAD is an _IO_off64_t value indicating error, unknown, or EOF. */
ifndef|#
directive|ifndef
name|_IO_pos_BAD
define|#
directive|define
name|_IO_pos_BAD
value|((_IO_off64_t) -1)
endif|#
directive|endif
comment|/* _IO_pos_adjust adjust an _IO_off64_t by some number of bytes. */
ifndef|#
directive|ifndef
name|_IO_pos_adjust
define|#
directive|define
name|_IO_pos_adjust
parameter_list|(
name|pos
parameter_list|,
name|delta
parameter_list|)
value|((pos) += (delta))
endif|#
directive|endif
comment|/* _IO_pos_0 is an _IO_off64_t value indicating beginning of file. */
ifndef|#
directive|ifndef
name|_IO_pos_0
define|#
directive|define
name|_IO_pos_0
value|((_IO_off64_t) 0)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__cplusplus
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_IO_MTSAFE_IO
comment|/* check following! */
ifdef|#
directive|ifdef
name|_IO_USE_OLD_IO_FILE
define|#
directive|define
name|FILEBUF_LITERAL
parameter_list|(
name|CHAIN
parameter_list|,
name|FLAGS
parameter_list|,
name|FD
parameter_list|,
name|WDP
parameter_list|)
define|\
value|{ _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \ 	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (_IO_FILE *) CHAIN, FD, \ 	 0, _IO_pos_BAD, 0, 0, { 0 },&_IO_stdfile_##FD##_lock }
else|#
directive|else
if|#
directive|if
name|defined
name|_LIBC
operator|||
name|defined
name|_GLIBCPP_USE_WCHAR_T
define|#
directive|define
name|FILEBUF_LITERAL
parameter_list|(
name|CHAIN
parameter_list|,
name|FLAGS
parameter_list|,
name|FD
parameter_list|,
name|WDP
parameter_list|)
define|\
value|{ _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \ 	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (_IO_FILE *) CHAIN, FD, \ 	 0, _IO_pos_BAD, 0, 0, { 0 },&_IO_stdfile_##FD##_lock, _IO_pos_BAD,\ 	 NULL, WDP, 0 }
else|#
directive|else
define|#
directive|define
name|FILEBUF_LITERAL
parameter_list|(
name|CHAIN
parameter_list|,
name|FLAGS
parameter_list|,
name|FD
parameter_list|,
name|WDP
parameter_list|)
define|\
value|{ _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \ 	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (_IO_FILE *) CHAIN, FD, \ 	 0, _IO_pos_BAD, 0, 0, { 0 },&_IO_stdfile_##FD##_lock, _IO_pos_BAD,\ 	 0 }
endif|#
directive|endif
endif|#
directive|endif
else|#
directive|else
ifdef|#
directive|ifdef
name|_IO_USE_OLD_IO_FILE
define|#
directive|define
name|FILEBUF_LITERAL
parameter_list|(
name|CHAIN
parameter_list|,
name|FLAGS
parameter_list|,
name|FD
parameter_list|,
name|WDP
parameter_list|)
define|\
value|{ _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \ 	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (_IO_FILE *) CHAIN, FD, \ 	 0, _IO_pos_BAD }
else|#
directive|else
if|#
directive|if
name|defined
name|_LIBC
operator|||
name|defined
name|_GLIBCPP_USE_WCHAR_T
define|#
directive|define
name|FILEBUF_LITERAL
parameter_list|(
name|CHAIN
parameter_list|,
name|FLAGS
parameter_list|,
name|FD
parameter_list|,
name|WDP
parameter_list|)
define|\
value|{ _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \ 	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (_IO_FILE *) CHAIN, FD, \ 	 0, _IO_pos_BAD, 0, 0, { 0 }, 0, _IO_pos_BAD, \ 	 NULL, WDP, 0 }
else|#
directive|else
define|#
directive|define
name|FILEBUF_LITERAL
parameter_list|(
name|CHAIN
parameter_list|,
name|FLAGS
parameter_list|,
name|FD
parameter_list|,
name|WDP
parameter_list|)
define|\
value|{ _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \ 	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (_IO_FILE *) CHAIN, FD, \ 	 0, _IO_pos_BAD, 0, 0, { 0 }, 0, _IO_pos_BAD, \ 	 0 }
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* VTABLE_LABEL defines NAME as of the CLASS class.    CNLENGTH is strlen(#CLASS).  */
ifdef|#
directive|ifdef
name|__GNUC__
if|#
directive|if
name|_G_VTABLE_LABEL_HAS_LENGTH
define|#
directive|define
name|VTABLE_LABEL
parameter_list|(
name|NAME
parameter_list|,
name|CLASS
parameter_list|,
name|CNLENGTH
parameter_list|)
define|\
value|extern char NAME[] asm (_G_VTABLE_LABEL_PREFIX #CNLENGTH #CLASS);
else|#
directive|else
define|#
directive|define
name|VTABLE_LABEL
parameter_list|(
name|NAME
parameter_list|,
name|CLASS
parameter_list|,
name|CNLENGTH
parameter_list|)
define|\
value|extern char NAME[] asm (_G_VTABLE_LABEL_PREFIX #CLASS);
endif|#
directive|endif
endif|#
directive|endif
comment|/* __GNUC__ */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|builtinbuf_vtable
argument_list|)
operator|&&
name|defined
argument_list|(
name|__cplusplus
argument_list|)
ifdef|#
directive|ifdef
name|__GNUC__
name|VTABLE_LABEL
argument_list|(
argument|builtinbuf_vtable
argument_list|,
argument|builtinbuf
argument_list|,
literal|10
argument_list|)
else|#
directive|else
if|#
directive|if
name|_G_VTABLE_LABEL_HAS_LENGTH
define|#
directive|define
name|builtinbuf_vtable
value|_G_VTABLE_LABEL_PREFIX_ID##10builtinbuf
else|#
directive|else
define|#
directive|define
name|builtinbuf_vtable
value|_G_VTABLE_LABEL_PREFIX_ID##builtinbuf
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* !defined(builtinbuf_vtable)&& defined(__cplusplus) */
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
define|#
directive|define
name|_IO_va_start
parameter_list|(
name|args
parameter_list|,
name|last
parameter_list|)
value|va_start(args, last)
else|#
directive|else
define|#
directive|define
name|_IO_va_start
parameter_list|(
name|args
parameter_list|,
name|last
parameter_list|)
value|va_start(args)
endif|#
directive|endif
specifier|extern
expr|struct
name|_IO_fake_stdiobuf
name|_IO_stdin_buf
operator|,
name|_IO_stdout_buf
operator|,
name|_IO_stderr_buf
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
literal|1
end_if

begin_define
define|#
directive|define
name|COERCE_FILE
parameter_list|(
name|FILE
parameter_list|)
end_define

begin_comment
comment|/* Nothing */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* This is part of the kludge for binary compatibility with old stdio. */
end_comment

begin_define
define|#
directive|define
name|COERCE_FILE
parameter_list|(
name|FILE
parameter_list|)
define|\
value|(((FILE)->_IO_file_flags& _IO_MAGIC_MASK) == _OLD_MAGIC_MASK \&& (FILE) = *(FILE**)&((int*)fp)[1])
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EINVAL
end_ifdef

begin_define
define|#
directive|define
name|MAYBE_SET_EINVAL
value|__set_errno (EINVAL)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MAYBE_SET_EINVAL
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IO_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|CHECK_FILE
parameter_list|(
name|FILE
parameter_list|,
name|RET
parameter_list|)
define|\
value|if ((FILE) == NULL) { MAYBE_SET_EINVAL; return RET; } \ 	else { COERCE_FILE(FILE); \ 	       if (((FILE)->_IO_file_flags& _IO_MAGIC_MASK) != _IO_MAGIC) \ 	  { MAYBE_SET_EINVAL; return RET; }}
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CHECK_FILE
parameter_list|(
name|FILE
parameter_list|,
name|RET
parameter_list|)
value|COERCE_FILE (FILE)
end_define

begin_endif
endif|#
directive|endif
end_endif

end_unit

