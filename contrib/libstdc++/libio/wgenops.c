begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1993, 1995, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.    This file is part of the GNU IO Library.    Written by Ulrich Drepper<drepper@cygnus.com>.    Based on the single byte version by Per Bothner<bothner@cygnus.com>.     This library is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2, or (at    your option) any later version.     This library is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this library; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330, Boston,    MA 02111-1307, USA.     As a special exception, if you link this library with files    compiled with a GNU compiler to produce an executable, this does    not cause the resulting executable to be covered by the GNU General    Public License.  This exception does not however invalidate any    other reasons why the executable file might be covered by the GNU    General Public License.  */
end_comment

begin_comment
comment|/* Generic or default I/O operations. */
end_comment

begin_include
include|#
directive|include
file|"libioP.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_GLIBCPP_USE_WCHAR_T
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_LIBC
end_ifndef

begin_define
define|#
directive|define
name|__wmemcpy
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|n
parameter_list|)
value|wmemcpy (dst, src, n)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|save_for_wbackup
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
name|fp
operator|,
name|wchar_t
operator|*
name|end_p
operator|)
argument_list|)
ifdef|#
directive|ifdef
name|_LIBC
name|internal_function
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return minimum _pos markers    Assumes the current get area is the main get area. */
end_comment

begin_decl_stmt
name|_IO_ssize_t
name|_IO_least_wmarker
name|__P
argument_list|(
operator|(
name|_IO_FILE
operator|*
name|fp
operator|,
name|wchar_t
operator|*
name|end_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|_IO_ssize_t
name|_IO_least_wmarker
parameter_list|(
name|fp
parameter_list|,
name|end_p
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|wchar_t
modifier|*
name|end_p
decl_stmt|;
block|{
name|_IO_ssize_t
name|least_so_far
init|=
name|end_p
operator|-
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
decl_stmt|;
name|struct
name|_IO_marker
modifier|*
name|mark
decl_stmt|;
for|for
control|(
name|mark
operator|=
name|fp
operator|->
name|_markers
init|;
name|mark
operator|!=
name|NULL
condition|;
name|mark
operator|=
name|mark
operator|->
name|_next
control|)
if|if
condition|(
name|mark
operator|->
name|_pos
operator|<
name|least_so_far
condition|)
name|least_so_far
operator|=
name|mark
operator|->
name|_pos
expr_stmt|;
return|return
name|least_so_far
return|;
block|}
end_function

begin_comment
comment|/* Switch current get area from backup buffer to (start of) main get area. */
end_comment

begin_function
name|void
name|_IO_switch_to_main_wget_area
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|wchar_t
modifier|*
name|tmp
decl_stmt|;
name|fp
operator|->
name|_flags
operator|&=
operator|~
name|_IO_IN_BACKUP
expr_stmt|;
comment|/* Swap _IO_read_end and _IO_save_end. */
name|tmp
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_end
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_end
operator|=
name|tmp
expr_stmt|;
comment|/* Swap _IO_read_base and _IO_save_base. */
name|tmp
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_base
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_base
operator|=
name|tmp
expr_stmt|;
comment|/* Set _IO_read_ptr. */
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Switch current get area from main get area to (end of) backup area. */
end_comment

begin_function
name|void
name|_IO_switch_to_wbackup_area
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|wchar_t
modifier|*
name|tmp
decl_stmt|;
name|fp
operator|->
name|_flags
operator||=
name|_IO_IN_BACKUP
expr_stmt|;
comment|/* Swap _IO_read_end and _IO_save_end. */
name|tmp
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_end
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_end
operator|=
name|tmp
expr_stmt|;
comment|/* Swap _IO_read_base and _IO_save_base. */
name|tmp
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_base
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_base
operator|=
name|tmp
expr_stmt|;
comment|/* Set _IO_read_ptr.  */
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_IO_wsetb
parameter_list|(
name|f
parameter_list|,
name|b
parameter_list|,
name|eb
parameter_list|,
name|a
parameter_list|)
name|_IO_FILE
modifier|*
name|f
decl_stmt|;
name|wchar_t
modifier|*
name|b
decl_stmt|;
name|wchar_t
modifier|*
name|eb
decl_stmt|;
name|int
name|a
decl_stmt|;
block|{
if|if
condition|(
name|f
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
operator|&&
operator|!
operator|(
name|f
operator|->
name|_flags
operator|&
name|_IO_USER_BUF
operator|)
condition|)
name|FREE_BUF
argument_list|(
name|f
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
argument_list|,
name|_IO_wblen
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
operator|=
name|b
expr_stmt|;
name|f
operator|->
name|_wide_data
operator|->
name|_IO_buf_end
operator|=
name|eb
expr_stmt|;
if|if
condition|(
name|a
condition|)
name|f
operator|->
name|_flags
operator|&=
operator|~
name|_IO_USER_BUF
expr_stmt|;
else|else
name|f
operator|->
name|_flags
operator||=
name|_IO_USER_BUF
expr_stmt|;
block|}
end_function

begin_function
name|wint_t
name|_IO_wdefault_pbackfail
parameter_list|(
name|fp
parameter_list|,
name|c
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|wint_t
name|c
decl_stmt|;
block|{
if|if
condition|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|>
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
operator|&&
operator|!
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
operator|&&
operator|(
name|wint_t
operator|)
name|fp
operator|->
name|_IO_read_ptr
index|[
operator|-
literal|1
index|]
operator|==
name|c
condition|)
operator|--
name|fp
operator|->
name|_IO_read_ptr
expr_stmt|;
else|else
block|{
comment|/* Need to handle a filebuf in write mode (switch to read mode). FIXME!*/
if|if
condition|(
operator|!
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
block|{
comment|/* We need to keep the invariant that the main get area 	     logically follows the backup area.  */
if|if
condition|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|>
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
operator|&&
name|_IO_have_wbackup
argument_list|(
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|save_for_wbackup
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
argument_list|)
condition|)
return|return
name|WEOF
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|_IO_have_wbackup
argument_list|(
name|fp
argument_list|)
condition|)
block|{
comment|/* No backup buffer: allocate one. */
comment|/* Use nshort buffer, if unused? (probably not)  FIXME */
name|int
name|backup_size
init|=
literal|128
decl_stmt|;
name|wchar_t
modifier|*
name|bbuf
init|=
operator|(
name|wchar_t
operator|*
operator|)
name|malloc
argument_list|(
name|backup_size
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bbuf
operator|==
name|NULL
condition|)
return|return
name|WEOF
return|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_base
operator|=
name|bbuf
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_end
operator|=
operator|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_base
operator|+
name|backup_size
operator|)
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_backup_base
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_end
expr_stmt|;
block|}
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
expr_stmt|;
name|_IO_switch_to_wbackup_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|<=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
condition|)
block|{
comment|/* Increase size of existing backup buffer. */
name|_IO_size_t
name|new_size
decl_stmt|;
name|_IO_size_t
name|old_size
init|=
operator|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
operator|)
decl_stmt|;
name|wchar_t
modifier|*
name|new_buf
decl_stmt|;
name|new_size
operator|=
literal|2
operator|*
name|old_size
expr_stmt|;
name|new_buf
operator|=
operator|(
name|wchar_t
operator|*
operator|)
name|malloc
argument_list|(
name|new_size
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_buf
operator|==
name|NULL
condition|)
return|return
name|WEOF
return|;
name|__wmemcpy
argument_list|(
name|new_buf
operator|+
operator|(
name|new_size
operator|-
name|old_size
operator|)
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
argument_list|,
name|old_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
argument_list|)
expr_stmt|;
name|_IO_wsetg
argument_list|(
name|fp
argument_list|,
name|new_buf
argument_list|,
name|new_buf
operator|+
operator|(
name|new_size
operator|-
name|old_size
operator|)
argument_list|,
name|new_buf
operator|+
name|new_size
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_backup_base
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
expr_stmt|;
block|}
operator|*
operator|--
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|=
name|c
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_function
name|void
name|_IO_wdefault_finish
parameter_list|(
name|fp
parameter_list|,
name|dummy
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|dummy
decl_stmt|;
block|{
name|struct
name|_IO_marker
modifier|*
name|mark
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
operator|&&
operator|!
operator|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_USER_BUF
operator|)
condition|)
block|{
name|FREE_BUF
argument_list|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
argument_list|,
name|_IO_wblen
argument_list|(
name|fp
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_end
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|mark
operator|=
name|fp
operator|->
name|_markers
init|;
name|mark
operator|!=
name|NULL
condition|;
name|mark
operator|=
name|mark
operator|->
name|_next
control|)
name|mark
operator|->
name|_sbuf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|_IO_save_base
condition|)
block|{
name|free
argument_list|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_base
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_save_base
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|_IO_MTSAFE_IO
name|_IO_lock_fini
argument_list|(
operator|*
name|fp
operator|->
name|_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_IO_un_link
argument_list|(
operator|(
expr|struct
name|_IO_FILE_plus
operator|*
operator|)
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|wint_t
name|_IO_wdefault_uflow
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|wint_t
name|wch
decl_stmt|;
name|wch
operator|=
name|_IO_UNDERFLOW
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|wch
operator|==
name|WEOF
condition|)
return|return
name|WEOF
return|;
return|return
operator|*
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|++
return|;
block|}
end_function

begin_function
name|wint_t
name|__woverflow
parameter_list|(
name|f
parameter_list|,
name|wch
parameter_list|)
name|_IO_FILE
modifier|*
name|f
decl_stmt|;
name|wint_t
name|wch
decl_stmt|;
block|{
if|if
condition|(
name|f
operator|->
name|_mode
operator|==
literal|0
condition|)
name|_IO_fwide
argument_list|(
name|f
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|_IO_OVERFLOW
argument_list|(
name|f
argument_list|,
name|wch
argument_list|)
return|;
block|}
end_function

begin_function
name|wint_t
name|__wuflow
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|fp
operator|->
name|_mode
operator|<
literal|0
operator|||
operator|(
name|fp
operator|->
name|_mode
operator|==
literal|0
operator|&&
name|_IO_fwide
argument_list|(
name|fp
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
operator|)
condition|)
return|return
name|WEOF
return|;
if|if
condition|(
name|fp
operator|->
name|_mode
operator|==
literal|0
condition|)
name|_IO_fwide
argument_list|(
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|_IO_in_put_mode
argument_list|(
name|fp
argument_list|)
condition|)
if|if
condition|(
name|_IO_switch_to_wget_mode
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|WEOF
return|;
if|if
condition|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|<
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
condition|)
return|return
operator|*
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|++
return|;
if|if
condition|(
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|_IO_switch_to_main_wget_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|<
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
condition|)
return|return
operator|*
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|++
return|;
block|}
if|if
condition|(
name|_IO_have_markers
argument_list|(
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|save_for_wbackup
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
argument_list|)
condition|)
return|return
name|WEOF
return|;
block|}
elseif|else
if|if
condition|(
name|_IO_have_wbackup
argument_list|(
name|fp
argument_list|)
condition|)
name|_IO_free_wbackup_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|_IO_UFLOW
argument_list|(
name|fp
argument_list|)
return|;
block|}
end_function

begin_function
name|wint_t
name|__wunderflow
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|fp
operator|->
name|_mode
operator|<
literal|0
operator|||
operator|(
name|fp
operator|->
name|_mode
operator|==
literal|0
operator|&&
name|_IO_fwide
argument_list|(
name|fp
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
operator|)
condition|)
return|return
name|WEOF
return|;
if|if
condition|(
name|fp
operator|->
name|_mode
operator|==
literal|0
condition|)
name|_IO_fwide
argument_list|(
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|_IO_in_put_mode
argument_list|(
name|fp
argument_list|)
condition|)
if|if
condition|(
name|_IO_switch_to_wget_mode
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|WEOF
return|;
if|if
condition|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|<
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
condition|)
return|return
operator|*
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
return|;
if|if
condition|(
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|_IO_switch_to_main_wget_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|<
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
condition|)
return|return
operator|*
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
return|;
block|}
if|if
condition|(
name|_IO_have_markers
argument_list|(
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|save_for_wbackup
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
argument_list|)
condition|)
return|return
name|WEOF
return|;
block|}
elseif|else
if|if
condition|(
name|_IO_have_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|_IO_free_wbackup_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|_IO_UNDERFLOW
argument_list|(
name|fp
argument_list|)
return|;
block|}
end_function

begin_function
name|_IO_size_t
name|_IO_wdefault_xsputn
parameter_list|(
name|f
parameter_list|,
name|data
parameter_list|,
name|n
parameter_list|)
name|_IO_FILE
modifier|*
name|f
decl_stmt|;
specifier|const
name|void
modifier|*
name|data
decl_stmt|;
name|_IO_size_t
name|n
decl_stmt|;
block|{
specifier|const
name|wchar_t
modifier|*
name|s
init|=
operator|(
specifier|const
name|wchar_t
operator|*
operator|)
name|data
decl_stmt|;
name|_IO_size_t
name|more
init|=
name|n
decl_stmt|;
if|if
condition|(
name|more
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Space available. */
name|_IO_ssize_t
name|count
init|=
operator|(
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_end
operator|-
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
operator|)
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|_IO_size_t
operator|)
name|count
operator|>
name|more
condition|)
name|count
operator|=
name|more
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|20
condition|)
block|{
ifdef|#
directive|ifdef
name|_LIBC
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
operator|=
name|__wmempcpy
argument_list|(
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
argument_list|,
name|s
argument_list|,
name|count
argument_list|)
expr_stmt|;
else|#
directive|else
name|memcpy
argument_list|(
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
argument_list|,
name|s
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
operator|+=
name|count
expr_stmt|;
endif|#
directive|endif
name|s
operator|+=
name|count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
name|count
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|wchar_t
modifier|*
name|p
init|=
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
decl_stmt|;
name|_IO_ssize_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|count
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|f
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
operator|=
name|p
expr_stmt|;
block|}
name|more
operator|-=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|more
operator|==
literal|0
operator|||
name|__woverflow
argument_list|(
name|f
argument_list|,
operator|*
name|s
operator|++
argument_list|)
operator|==
name|WEOF
condition|)
break|break;
name|more
operator|--
expr_stmt|;
block|}
return|return
name|n
operator|-
name|more
return|;
block|}
end_function

begin_function
name|_IO_size_t
name|_IO_wdefault_xsgetn
parameter_list|(
name|fp
parameter_list|,
name|data
parameter_list|,
name|n
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|_IO_size_t
name|n
decl_stmt|;
block|{
name|_IO_size_t
name|more
init|=
name|n
decl_stmt|;
name|wchar_t
modifier|*
name|s
init|=
operator|(
name|wchar_t
operator|*
operator|)
name|data
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Data available. */
name|_IO_ssize_t
name|count
init|=
operator|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|)
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|_IO_size_t
operator|)
name|count
operator|>
name|more
condition|)
name|count
operator|=
name|more
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|20
condition|)
block|{
ifdef|#
directive|ifdef
name|_LIBC
name|s
operator|=
name|__wmempcpy
argument_list|(
name|s
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
argument_list|,
name|count
argument_list|)
expr_stmt|;
else|#
directive|else
name|memcpy
argument_list|(
name|s
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|s
operator|+=
name|count
expr_stmt|;
endif|#
directive|endif
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|+=
name|count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
name|count
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|wchar_t
modifier|*
name|p
init|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
decl_stmt|;
name|int
name|i
init|=
operator|(
name|int
operator|)
name|count
decl_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|=
name|p
expr_stmt|;
block|}
name|more
operator|-=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|more
operator|==
literal|0
operator|||
name|__wunderflow
argument_list|(
name|fp
argument_list|)
operator|==
name|WEOF
condition|)
break|break;
block|}
return|return
name|n
operator|-
name|more
return|;
block|}
end_function

begin_function
name|void
name|_IO_wdoallocbuf
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_UNBUFFERED
operator|)
condition|)
if|if
condition|(
name|_IO_DOALLOCATE
argument_list|(
name|fp
argument_list|)
operator|!=
name|WEOF
condition|)
return|return;
name|_IO_wsetb
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_shortbuf
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_shortbuf
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|_IO_FILE
modifier|*
name|_IO_wdefault_setbuf
parameter_list|(
name|fp
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|wchar_t
modifier|*
name|p
decl_stmt|;
name|_IO_ssize_t
name|len
decl_stmt|;
block|{
if|if
condition|(
name|_IO_SYNC
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|len
operator|==
literal|0
condition|)
block|{
name|fp
operator|->
name|_flags
operator||=
name|_IO_UNBUFFERED
expr_stmt|;
name|_IO_wsetb
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_shortbuf
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_shortbuf
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|->
name|_flags
operator|&=
operator|~
name|_IO_UNBUFFERED
expr_stmt|;
name|_IO_wsetb
argument_list|(
name|fp
argument_list|,
name|p
argument_list|,
name|p
operator|+
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_base
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_end
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
operator|=
literal|0
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_function
name|int
name|_IO_wdefault_doallocate
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|wchar_t
modifier|*
name|buf
decl_stmt|;
name|ALLOC_WBUF
argument_list|(
name|buf
argument_list|,
name|_IO_BUFSIZ
argument_list|,
name|EOF
argument_list|)
expr_stmt|;
name|_IO_wsetb
argument_list|(
name|fp
argument_list|,
name|buf
argument_list|,
name|buf
operator|+
name|_IO_BUFSIZ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|_IO_switch_to_wget_mode
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
operator|>
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_base
condition|)
if|if
condition|(
name|_IO_OVERFLOW
argument_list|(
name|fp
argument_list|,
name|WEOF
argument_list|)
operator|==
name|WEOF
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_backup_base
expr_stmt|;
else|else
block|{
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_buf_base
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
operator|>
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
condition|)
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
expr_stmt|;
block|}
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_base
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_ptr
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_write_end
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
expr_stmt|;
name|fp
operator|->
name|_flags
operator|&=
operator|~
name|_IO_CURRENTLY_PUTTING
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|_IO_free_wbackup_area
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|_IO_switch_to_main_wget_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Just in case. */
name|free
argument_list|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_base
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_base
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_end
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_backup_base
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|int _IO_switch_to_wput_mode (fp)      _IO_FILE *fp; {   fp->_wide_data->_IO_write_base = fp->_wide_data->_IO_read_ptr;   fp->_wide_data->_IO_write_ptr = fp->_wide_data->_IO_read_ptr;
comment|/* Following is wrong if line- or un-buffered? */
end_comment

begin_endif
unit|fp->_wide_data->_IO_write_end = (fp->_flags& _IO_IN_BACKUP 				   ? fp->_wide_data->_IO_read_end 				   : fp->_wide_data->_IO_buf_end);    fp->_wide_data->_IO_read_ptr = fp->_wide_data->_IO_read_end;   fp->_wide_data->_IO_read_base = fp->_wide_data->_IO_read_end;    fp->_flags |= _IO_CURRENTLY_PUTTING;   return 0; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|_LIBC
name|internal_function
endif|#
directive|endif
name|save_for_wbackup
parameter_list|(
name|fp
parameter_list|,
name|end_p
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|wchar_t
modifier|*
name|end_p
decl_stmt|;
block|{
comment|/* Append [_IO_read_base..end_p] to backup area. */
name|_IO_ssize_t
name|least_mark
init|=
name|_IO_least_wmarker
argument_list|(
name|fp
argument_list|,
name|end_p
argument_list|)
decl_stmt|;
comment|/* needed_size is how much space we need in the backup area. */
name|_IO_size_t
name|needed_size
init|=
operator|(
operator|(
name|end_p
operator|-
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
operator|)
operator|-
name|least_mark
operator|)
decl_stmt|;
comment|/* FIXME: Dubious arithmetic if pointers are NULL */
name|_IO_size_t
name|current_Bsize
init|=
operator|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_end
operator|-
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_base
operator|)
decl_stmt|;
name|_IO_size_t
name|avail
decl_stmt|;
comment|/* Extra space available for future expansion. */
name|_IO_ssize_t
name|delta
decl_stmt|;
name|struct
name|_IO_marker
modifier|*
name|mark
decl_stmt|;
if|if
condition|(
name|needed_size
operator|>
name|current_Bsize
condition|)
block|{
name|wchar_t
modifier|*
name|new_buffer
decl_stmt|;
name|avail
operator|=
literal|100
expr_stmt|;
name|new_buffer
operator|=
operator|(
name|wchar_t
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|avail
operator|+
name|needed_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_buffer
operator|==
name|NULL
condition|)
return|return
name|EOF
return|;
comment|/* FIXME */
if|if
condition|(
name|least_mark
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|_LIBC
name|__wmempcpy
argument_list|(
name|__wmempcpy
argument_list|(
name|new_buffer
operator|+
name|avail
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_end
operator|+
name|least_mark
argument_list|,
operator|-
name|least_mark
argument_list|)
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
argument_list|,
name|end_p
operator|-
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
argument_list|)
expr_stmt|;
else|#
directive|else
name|memcpy
argument_list|(
name|new_buffer
operator|+
name|avail
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_end
operator|+
name|least_mark
argument_list|,
operator|-
name|least_mark
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_buffer
operator|+
name|avail
operator|-
name|least_mark
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
argument_list|,
operator|(
name|end_p
operator|-
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|_LIBC
name|__wmemcpy
argument_list|(
name|new_buffer
operator|+
name|avail
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
operator|+
name|least_mark
argument_list|,
name|needed_size
argument_list|)
expr_stmt|;
else|#
directive|else
name|memcpy
argument_list|(
name|new_buffer
operator|+
name|avail
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
operator|+
name|least_mark
argument_list|,
name|needed_size
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_base
condition|)
name|free
argument_list|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_base
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_base
operator|=
name|new_buffer
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_end
operator|=
name|new_buffer
operator|+
name|avail
operator|+
name|needed_size
expr_stmt|;
block|}
else|else
block|{
name|avail
operator|=
name|current_Bsize
operator|-
name|needed_size
expr_stmt|;
if|if
condition|(
name|least_mark
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|_LIBC
name|__wmemmove
argument_list|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_base
operator|+
name|avail
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_end
operator|+
name|least_mark
argument_list|,
operator|-
name|least_mark
argument_list|)
expr_stmt|;
name|__wmemcpy
argument_list|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_base
operator|+
name|avail
operator|-
name|least_mark
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
argument_list|,
name|end_p
operator|-
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
argument_list|)
expr_stmt|;
else|#
directive|else
name|memmove
argument_list|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_base
operator|+
name|avail
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_end
operator|+
name|least_mark
argument_list|,
operator|-
name|least_mark
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_base
operator|+
name|avail
operator|-
name|least_mark
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
argument_list|,
operator|(
name|end_p
operator|-
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|needed_size
operator|>
literal|0
condition|)
ifdef|#
directive|ifdef
name|_LIBC
name|__wmemcpy
argument_list|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_base
operator|+
name|avail
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
operator|+
name|least_mark
argument_list|,
name|needed_size
argument_list|)
expr_stmt|;
else|#
directive|else
name|memcpy
argument_list|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_base
operator|+
name|avail
argument_list|,
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
operator|+
name|least_mark
argument_list|,
name|needed_size
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_backup_base
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_save_base
operator|+
name|avail
expr_stmt|;
comment|/* Adjust all the streammarkers. */
name|delta
operator|=
name|end_p
operator|-
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
expr_stmt|;
for|for
control|(
name|mark
operator|=
name|fp
operator|->
name|_markers
init|;
name|mark
operator|!=
name|NULL
condition|;
name|mark
operator|=
name|mark
operator|->
name|_next
control|)
name|mark
operator|->
name|_pos
operator|-=
name|delta
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|wint_t
name|_IO_sputbackwc
parameter_list|(
name|fp
parameter_list|,
name|c
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|wint_t
name|c
decl_stmt|;
block|{
name|wint_t
name|result
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|>
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
operator|&&
operator|(
name|wchar_t
operator|)
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
index|[
operator|-
literal|1
index|]
operator|==
operator|(
name|wchar_t
operator|)
name|c
condition|)
block|{
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|--
expr_stmt|;
name|result
operator|=
name|c
expr_stmt|;
block|}
else|else
name|result
operator|=
name|_IO_PBACKFAIL
argument_list|(
name|fp
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|EOF
condition|)
name|fp
operator|->
name|_flags
operator|&=
operator|~
name|_IO_EOF_SEEN
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|wint_t
name|_IO_sungetwc
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|>
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
condition|)
block|{
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|--
expr_stmt|;
name|result
operator|=
operator|*
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
expr_stmt|;
block|}
else|else
name|result
operator|=
name|_IO_PBACKFAIL
argument_list|(
name|fp
argument_list|,
name|EOF
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|WEOF
condition|)
name|fp
operator|->
name|_flags
operator|&=
operator|~
name|_IO_EOF_SEEN
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|unsigned
name|_IO_adjust_wcolumn
parameter_list|(
name|start
parameter_list|,
name|line
parameter_list|,
name|count
parameter_list|)
name|unsigned
name|start
decl_stmt|;
specifier|const
name|wchar_t
modifier|*
name|line
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
specifier|const
name|wchar_t
modifier|*
name|ptr
init|=
name|line
operator|+
name|count
decl_stmt|;
while|while
condition|(
name|ptr
operator|>
name|line
condition|)
if|if
condition|(
operator|*
operator|--
name|ptr
operator|==
literal|L'
expr|\n'
condition|)
return|return
name|line
operator|+
name|count
operator|-
name|ptr
operator|-
literal|1
return|;
return|return
name|start
operator|+
name|count
return|;
block|}
end_function

begin_function
name|void
name|_IO_init_wmarker
parameter_list|(
name|marker
parameter_list|,
name|fp
parameter_list|)
name|struct
name|_IO_marker
modifier|*
name|marker
decl_stmt|;
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|marker
operator|->
name|_sbuf
operator|=
name|fp
expr_stmt|;
if|if
condition|(
name|_IO_in_put_mode
argument_list|(
name|fp
argument_list|)
condition|)
name|_IO_switch_to_wget_mode
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|marker
operator|->
name|_pos
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|-
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
expr_stmt|;
else|else
name|marker
operator|->
name|_pos
operator|=
operator|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|-
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
operator|)
expr_stmt|;
comment|/* Should perhaps sort the chain? */
name|marker
operator|->
name|_next
operator|=
name|fp
operator|->
name|_markers
expr_stmt|;
name|fp
operator|->
name|_markers
operator|=
name|marker
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|BAD_DELTA
value|EOF
end_define

begin_comment
comment|/* Return difference between MARK and current position of MARK's stream. */
end_comment

begin_function
name|int
name|_IO_wmarker_delta
parameter_list|(
name|mark
parameter_list|)
name|struct
name|_IO_marker
modifier|*
name|mark
decl_stmt|;
block|{
name|int
name|cur_pos
decl_stmt|;
if|if
condition|(
name|mark
operator|->
name|_sbuf
operator|==
name|NULL
condition|)
return|return
name|BAD_DELTA
return|;
if|if
condition|(
name|_IO_in_backup
argument_list|(
name|mark
operator|->
name|_sbuf
argument_list|)
condition|)
name|cur_pos
operator|=
operator|(
name|mark
operator|->
name|_sbuf
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|-
name|mark
operator|->
name|_sbuf
operator|->
name|_wide_data
operator|->
name|_IO_read_end
operator|)
expr_stmt|;
else|else
name|cur_pos
operator|=
operator|(
name|mark
operator|->
name|_sbuf
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|-
name|mark
operator|->
name|_sbuf
operator|->
name|_wide_data
operator|->
name|_IO_read_base
operator|)
expr_stmt|;
return|return
name|mark
operator|->
name|_pos
operator|-
name|cur_pos
return|;
block|}
end_function

begin_function
name|int
name|_IO_seekwmark
parameter_list|(
name|fp
parameter_list|,
name|mark
parameter_list|,
name|delta
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|_IO_marker
modifier|*
name|mark
decl_stmt|;
name|int
name|delta
decl_stmt|;
block|{
if|if
condition|(
name|mark
operator|->
name|_sbuf
operator|!=
name|fp
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|mark
operator|->
name|_pos
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|_IO_switch_to_main_wget_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|=
operator|(
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_base
operator|+
name|mark
operator|->
name|_pos
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|_IO_switch_to_wbackup_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_wide_data
operator|->
name|_IO_read_end
operator|+
name|mark
operator|->
name|_pos
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|_IO_unsave_wmarkers
parameter_list|(
name|fp
parameter_list|)
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|struct
name|_IO_marker
modifier|*
name|mark
init|=
name|fp
operator|->
name|_markers
decl_stmt|;
if|if
condition|(
name|mark
condition|)
block|{
ifdef|#
directive|ifdef
name|TODO
name|streampos
name|offset
init|=
name|seekoff
argument_list|(
literal|0
argument_list|,
name|ios
operator|::
name|cur
argument_list|,
name|ios
operator|::
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|!=
name|EOF
condition|)
block|{
name|offset
operator|+=
name|eGptr
argument_list|()
operator|-
name|Gbase
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|mark
operator|!=
name|NULL
condition|;
name|mark
operator|=
name|mark
operator|->
name|_next
control|)
name|mark
operator|->
name|set_streampos
argument_list|(
name|mark
operator|->
name|_pos
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|mark
operator|!=
name|NULL
condition|;
name|mark
operator|=
name|mark
operator|->
name|_next
control|)
name|mark
operator|->
name|set_streampos
argument_list|(
name|EOF
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|fp
operator|->
name|_markers
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|_IO_have_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|_IO_free_wbackup_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _GLIBCPP_USE_WCHAR_T */
end_comment

end_unit

