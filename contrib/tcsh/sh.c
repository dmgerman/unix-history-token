begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header: /p/tcsh/cvsroot/tcsh/sh.c,v 3.136 2007/02/22 21:57:37 christos Exp $ */
end_comment

begin_comment
comment|/*  * sh.c: Main shell routines  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1980, 1991 The Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_define
define|#
directive|define
name|EXTERN
end_define

begin_comment
comment|/* Intern */
end_comment

begin_include
include|#
directive|include
file|"sh.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1991 The Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_macro
name|RCSID
argument_list|(
literal|"$tcsh: sh.c,v 3.136 2007/02/22 21:57:37 christos Exp $"
argument_list|)
end_macro

begin_include
include|#
directive|include
file|"tc.h"
end_include

begin_include
include|#
directive|include
file|"ed.h"
end_include

begin_include
include|#
directive|include
file|"tw.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|MapsAreInited
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|NLSMapsAreInited
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * C Shell  *  * Bill Joy, UC Berkeley, California, USA  * October 1978, May 1980  *  * Jim Kulp, IIASA, Laxenburg, Austria  * April 1980  *  * Filename recognition added:  * Ken Greer, Ind. Consultant, Palo Alto CA  * October 1983.  *  * Karl Kleinpaste, Computer Consoles, Inc.  * Added precmd, periodic/tperiod, prompt changes,  * directory stack hack, and login watch.  * Sometime March 1983 - Feb 1984.  *  * Added scheduled commands, including the "sched" command,  * plus the call to sched_run near the precmd et al  * routines.  * Upgraded scheduled events for running events while  * sitting idle at command input.  *  * Paul Placeway, Ohio State  * added stuff for running with twenex/inputl  9 Oct 1984.  *  * ported to Apple Unix (TM) (OREO)  26 -- 29 Jun 1987  */
end_comment

begin_decl_stmt
name|jmp_buf_t
name|reslab
name|INIT_ZERO_STRUCT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|tcshstr
index|[]
init|=
literal|"tcsh"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sigaction
name|parintr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parents interrupt catch */
end_comment

begin_decl_stmt
name|struct
name|sigaction
name|parterm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parents terminate catch */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TESLA
end_ifdef

begin_decl_stmt
name|int
name|do_logout
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TESLA */
end_comment

begin_decl_stmt
name|int
name|use_fork
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use fork() instead of vfork()? */
end_comment

begin_comment
comment|/*  * Magic pointer values. Used to specify other invalid conditions aside  * from null.  */
end_comment

begin_decl_stmt
specifier|static
name|Char
name|INVCHAR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Char
modifier|*
name|INVPTR
init|=
operator|&
name|INVCHAR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Char
modifier|*
modifier|*
name|INVPPTR
init|=
operator|&
name|INVPTR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fast
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|prompt
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|enterhist
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tellwhat
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|time_t
name|t_period
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Char
modifier|*
name|ffile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dolzero
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|insource
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|exitset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|chktim
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Time mail last checked */
end_comment

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tcsh
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This preserves the input state of the shell. It is used by  * st_save and st_restore to manupulate shell state.  */
end_comment

begin_struct
struct|struct
name|saved_state
block|{
name|int
name|insource
decl_stmt|;
name|int
name|OLDSTD
decl_stmt|;
name|int
name|SHIN
decl_stmt|;
name|int
name|SHOUT
decl_stmt|;
name|int
name|SHDIAG
decl_stmt|;
name|int
name|intty
decl_stmt|;
name|struct
name|whyle
modifier|*
name|whyles
decl_stmt|;
name|Char
modifier|*
name|gointr
decl_stmt|;
name|Char
modifier|*
name|arginp
decl_stmt|;
name|Char
modifier|*
name|evalp
decl_stmt|;
name|Char
modifier|*
modifier|*
name|evalvec
decl_stmt|;
name|Char
modifier|*
name|alvecp
decl_stmt|;
name|Char
modifier|*
modifier|*
name|alvec
decl_stmt|;
name|int
name|onelflg
decl_stmt|;
name|int
name|enterhist
decl_stmt|;
name|Char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|Char
modifier|*
modifier|*
name|av
decl_stmt|;
name|Char
name|HIST
decl_stmt|;
name|int
name|cantell
decl_stmt|;
name|struct
name|Bin
name|B
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|srccat
parameter_list|(
name|Char
modifier|*
parameter_list|,
name|Char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|WINNT_NATIVE
end_ifndef

begin_function_decl
specifier|static
name|int
name|srcfile
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|Char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|int
name|srcfile
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|Char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*WINNT_NATIVE*/
end_comment

begin_function_decl
specifier|static
name|void
name|srcunit
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|Char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mailchk
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|_PATH_DEFPATH
end_ifndef

begin_function_decl
specifier|static
name|Char
modifier|*
modifier|*
name|defaultpath
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|record
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|st_save
parameter_list|(
name|struct
name|saved_state
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|Char
modifier|*
modifier|*
parameter_list|,
name|Char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|st_restore
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|main
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|batch
init|=
literal|0
decl_stmt|;
specifier|volatile
name|int
name|nexececho
init|=
literal|0
decl_stmt|;
name|int
name|nofile
init|=
literal|0
decl_stmt|;
specifier|volatile
name|int
name|nverbose
init|=
literal|0
decl_stmt|;
specifier|volatile
name|int
name|rdirs
init|=
literal|0
decl_stmt|;
name|int
name|quitit
init|=
literal|0
decl_stmt|;
name|Char
modifier|*
name|cp
decl_stmt|;
ifdef|#
directive|ifdef
name|AUTOLOGOUT
name|Char
modifier|*
name|cp2
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|tcp
decl_stmt|,
modifier|*
name|ttyn
decl_stmt|;
name|int
name|f
decl_stmt|,
name|reenter
decl_stmt|;
name|char
modifier|*
modifier|*
name|tempv
decl_stmt|;
name|int
name|osetintr
decl_stmt|;
name|struct
name|sigaction
name|oparintr
decl_stmt|;
ifdef|#
directive|ifdef
name|WINNT_NATIVE
name|nt_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* WINNT_NATIVE */
if|#
directive|if
name|defined
argument_list|(
name|NLS_CATALOGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|LC_MESSAGES
argument_list|)
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NLS_CATALOGS&& LC_MESSAGES */
ifdef|#
directive|ifdef
name|NLS
ifdef|#
directive|ifdef
name|LC_CTYPE
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* for iscntrl */
endif|#
directive|endif
comment|/* LC_CTYPE */
endif|#
directive|endif
comment|/* NLS */
name|nlsinit
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_TRACE
name|mal_setstatsfile
argument_list|(
name|fdopen
argument_list|(
name|dmove
argument_list|(
name|xopen
argument_list|(
literal|"/tmp/tcsh.trace"
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_LARGEFILE
argument_list|,
literal|0666
argument_list|)
argument_list|,
literal|25
argument_list|)
argument_list|,
literal|"w"
argument_list|)
argument_list|)
expr_stmt|;
name|mal_trace
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MALLOC_TRACE */
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|BSDTIMES
argument_list|)
operator|||
name|defined
argument_list|(
name|_SEQUENT_
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|POSIX
argument_list|)
ifdef|#
directive|ifdef
name|_SC_CLK_TCK
name|clk_tck
operator|=
operator|(
name|clock_t
operator|)
name|sysconf
argument_list|(
name|_SC_CLK_TCK
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! _SC_CLK_TCK */
ifdef|#
directive|ifdef
name|CLK_TCK
name|clk_tck
operator|=
name|CLK_TCK
expr_stmt|;
else|#
directive|else
comment|/* !CLK_TCK */
name|clk_tck
operator|=
name|HZ
expr_stmt|;
endif|#
directive|endif
comment|/* CLK_TCK */
endif|#
directive|endif
comment|/* _SC_CLK_TCK */
endif|#
directive|endif
comment|/* !BSDTIMES&& POSIX */
name|settimes
argument_list|()
expr_stmt|;
comment|/* Immed. estab. timing base */
ifdef|#
directive|ifdef
name|TESLA
name|do_logout
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* TESLA */
comment|/*      * Make sure we have 0, 1, 2 open      * Otherwise `` jobs will not work... (From knaff@poly.polytechnique.fr)      */
block|{
do|do
if|if
condition|(
operator|(
name|f
operator|=
name|xopen
argument_list|(
name|_PATH_DEVNULL
argument_list|,
name|O_RDONLY
operator||
name|O_LARGEFILE
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|&&
operator|(
name|f
operator|=
name|xopen
argument_list|(
literal|"/"
argument_list|,
name|O_RDONLY
operator||
name|O_LARGEFILE
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
name|f
operator|<
literal|3
condition|)
do|;
name|xclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|O_TEXT
name|setmode
argument_list|(
literal|0
argument_list|,
name|O_TEXT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|osinit
argument_list|()
expr_stmt|;
comment|/* Os dependent initialization */
block|{
name|char
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WINNT_NATIVE
block|{
name|char
modifier|*
name|s
init|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'\\'
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
condition|)
name|t
operator|=
name|s
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* WINNT_NATIVE */
name|t
operator|=
name|t
condition|?
name|t
operator|+
literal|1
else|:
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'-'
condition|)
name|t
operator|++
expr_stmt|;
name|progname
operator|=
name|strsave
argument_list|(
operator|(
name|t
operator|&&
operator|*
name|t
operator|)
condition|?
name|t
else|:
name|tcshstr
argument_list|)
expr_stmt|;
comment|/* never want a null */
name|tcsh
operator|=
name|strcmp
argument_list|(
name|progname
argument_list|,
name|tcshstr
argument_list|)
operator|==
literal|0
expr_stmt|;
block|}
comment|/*      * Initialize non constant strings      */
ifdef|#
directive|ifdef
name|_PATH_BSHELL
name|STR_BSHELL
operator|=
name|SAVE
argument_list|(
name|_PATH_BSHELL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_PATH_TCSHELL
name|STR_SHELLPATH
operator|=
name|SAVE
argument_list|(
name|_PATH_TCSHELL
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|_PATH_CSHELL
name|STR_SHELLPATH
operator|=
name|SAVE
argument_list|(
name|_PATH_CSHELL
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|STR_environ
operator|=
name|blk2short
argument_list|(
name|environ
argument_list|)
expr_stmt|;
name|environ
operator|=
name|short2blk
argument_list|(
name|STR_environ
argument_list|)
expr_stmt|;
comment|/* So that we can free it */
name|STR_WORD_CHARS
operator|=
name|SAVE
argument_list|(
name|WORD_CHARS
argument_list|)
expr_stmt|;
name|HIST
operator|=
literal|'!'
expr_stmt|;
name|HISTSUB
operator|=
literal|'^'
expr_stmt|;
name|PRCH
operator|=
literal|'>'
expr_stmt|;
name|PRCHROOT
operator|=
literal|'#'
expr_stmt|;
name|word_chars
operator|=
name|STR_WORD_CHARS
expr_stmt|;
name|bslash_quote
operator|=
literal|0
expr_stmt|;
comment|/* PWP: do tcsh-style backslash quoting? */
comment|/* Default history size to 100 */
name|setcopy
argument_list|(
name|STRhistory
argument_list|,
name|str2short
argument_list|(
literal|"100"
argument_list|)
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
name|tempv
operator|=
name|argv
expr_stmt|;
name|ffile
operator|=
name|SAVE
argument_list|(
name|tempv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dolzero
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eq
argument_list|(
name|ffile
argument_list|,
name|STRaout
argument_list|)
condition|)
comment|/* A.out's are quittable */
name|quitit
operator|=
literal|1
expr_stmt|;
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|gid
operator|=
name|getgid
argument_list|()
expr_stmt|;
name|euid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
name|egid
operator|=
name|getegid
argument_list|()
expr_stmt|;
comment|/*      * We are a login shell if: 1. we were invoked as -<something> with      * optional arguments 2. or we were invoked only with the -l flag      */
name|loginsh
operator|=
operator|(
operator|*
operator|*
name|tempv
operator|==
literal|'-'
operator|)
operator|||
operator|(
name|argc
operator|==
literal|2
operator|&&
name|tempv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|tempv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'l'
operator|&&
name|tempv
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_VMS_POSIX
comment|/* No better way to find if we are a login shell */
if|if
condition|(
operator|!
name|loginsh
condition|)
block|{
name|loginsh
operator|=
operator|(
name|argc
operator|==
literal|1
operator|&&
name|getppid
argument_list|()
operator|==
literal|1
operator|)
expr_stmt|;
operator|*
operator|*
name|tempv
operator|=
literal|'-'
expr_stmt|;
comment|/* Avoid giving VMS an acidic stomach */
block|}
endif|#
directive|endif
comment|/* _VMS_POSIX */
if|if
condition|(
name|loginsh
operator|&&
operator|*
operator|*
name|tempv
operator|!=
literal|'-'
condition|)
block|{
name|char
modifier|*
name|argv0
decl_stmt|;
comment|/* 	 * Mangle the argv space 	 */
name|tempv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tempv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tempv
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|argv0
operator|=
name|strspl
argument_list|(
literal|"-"
argument_list|,
operator|*
name|tempv
argument_list|)
expr_stmt|;
operator|*
name|tempv
operator|=
name|argv0
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|loginsh
condition|)
block|{
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|chktim
argument_list|)
expr_stmt|;
name|setNS
argument_list|(
name|STRloginsh
argument_list|)
expr_stmt|;
block|}
name|AsciiOnly
operator|=
literal|1
expr_stmt|;
name|NoNLSRebind
operator|=
name|getenv
argument_list|(
literal|"NOREBIND"
argument_list|)
operator|!=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|NLS
ifdef|#
directive|ifdef
name|SETLOCALEBUG
name|dont_free
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* SETLOCALEBUG */
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LC_COLLATE
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_COLLATE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SETLOCALEBUG
name|dont_free
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* SETLOCALEBUG */
ifdef|#
directive|ifdef
name|STRCOLLBUG
name|fix_strcoll_bug
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* STRCOLLBUG */
block|{
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0200
init|;
name|k
operator|<=
literal|0377
operator|&&
operator|!
name|Isprint
argument_list|(
name|CTL_ESC
argument_list|(
name|k
argument_list|)
argument_list|)
condition|;
name|k
operator|++
control|)
continue|continue;
name|AsciiOnly
operator|=
name|MB_CUR_MAX
operator|==
literal|1
operator|&&
name|k
operator|>
literal|0377
expr_stmt|;
block|}
else|#
directive|else
name|AsciiOnly
operator|=
name|getenv
argument_list|(
literal|"LANG"
argument_list|)
operator|==
name|NULL
operator|&&
name|getenv
argument_list|(
literal|"LC_CTYPE"
argument_list|)
operator|==
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* NLS */
if|if
condition|(
name|MapsAreInited
operator|&&
operator|!
name|NLSMapsAreInited
condition|)
name|ed_InitNLSMaps
argument_list|()
expr_stmt|;
name|ResetArrowKeys
argument_list|()
expr_stmt|;
comment|/*      * Initialize for periodic command intervals. Also, initialize the dummy      * tty list for login-watch.      */
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|t_period
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|HAVENOUTMP
name|initwatch
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* !HAVENOUTMP */
if|#
directive|if
name|defined
argument_list|(
name|alliant
argument_list|)
comment|/*      * From:  Jim Pace<jdp@research.att.com>      * tcsh does not work properly on the alliants through an rlogin session.      * The shell generally hangs.  Also, reference to the controlling terminal      * does not work ( ie: echo foo> /dev/tty ).      *      * A security feature was added to rlogind affecting FX/80's Concentrix      * from revision 5.5.xx upwards (through 5.7 where this fix was implemented)      * This security change also affects the FX/2800 series.      * The security change to rlogind requires the process group of an rlogin      * session become disassociated with the tty in rlogind.      *      * The changes needed are:      * 1. set the process group      * 2. reenable the control terminal      */
if|if
condition|(
name|loginsh
operator|&&
name|isatty
argument_list|(
name|SHIN
argument_list|)
condition|)
block|{
name|ttyn
operator|=
name|ttyname
argument_list|(
name|SHIN
argument_list|)
expr_stmt|;
name|xclose
argument_list|(
name|SHIN
argument_list|)
expr_stmt|;
name|SHIN
operator|=
name|xopen
argument_list|(
name|ttyn
argument_list|,
name|O_RDWR
operator||
name|O_LARGEFILE
argument_list|)
expr_stmt|;
name|shpgrp
operator|=
name|getpid
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|SHIN
argument_list|,
name|TIOCSPGRP
argument_list|,
operator|(
name|ioctl_t
operator|)
operator|&
name|shpgrp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setpgid
argument_list|(
literal|0
argument_list|,
name|shpgrp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* alliant */
comment|/*      * Move the descriptors to safe places. The variable didfds is 0 while we      * have only FSH* to work with. When didfds is true, we have 0,1,2 and      * prefer to use these.      */
name|initdesc
argument_list|()
expr_stmt|;
comment|/*      * Get and set the tty now      */
if|if
condition|(
operator|(
name|ttyn
operator|=
name|ttyname
argument_list|(
name|SHIN
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 	 * Could use rindex to get rid of other possible path components, but 	 * hpux preserves the subdirectory /pty/ when storing the tty name in 	 * utmp, so we keep it too. 	 */
if|if
condition|(
name|strncmp
argument_list|(
name|ttyn
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|setv
argument_list|(
name|STRtty
argument_list|,
name|cp
operator|=
name|SAVE
argument_list|(
name|ttyn
operator|+
literal|5
argument_list|)
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
else|else
name|setv
argument_list|(
name|STRtty
argument_list|,
name|cp
operator|=
name|SAVE
argument_list|(
name|ttyn
argument_list|)
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
block|}
else|else
name|setv
argument_list|(
name|STRtty
argument_list|,
name|cp
operator|=
name|SAVE
argument_list|(
literal|""
argument_list|)
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
comment|/*      * Initialize the shell variables. ARGV and PROMPT are initialized later.      * STATUS is also munged in several places. CHILD is munged when      * forking/waiting      */
comment|/*      * 7-10-87 Paul Placeway autologout should be set ONLY on login shells and      * on shells running as root.  Out of these, autologout should NOT be set      * for any psudo-terminals (this catches most window systems) and not for      * any terminal running X windows.      *       * At Ohio State, we have had problems with a user having his X session       * drop out from under him (on a Sun) because the shell in his master       * xterm timed out and exited.      *       * Really, this should be done with a program external to the shell, that      * watches for no activity (and NO running programs, such as dump) on a      * terminal for a long peroid of time, and then SIGHUPS the shell on that      * terminal.      *       * bugfix by Rich Salz<rsalz@PINEAPPLE.BBN.COM>: For root rsh things       * allways first check to see if loginsh or really root, then do things       * with ttyname()      *       * Also by Jean-Francois Lamy<lamy%ai.toronto.edu@RELAY.CS.NET>: check the      * value of cp before using it! ("root can rsh too")      *       * PWP: keep the nested ifs; the order of the tests matters and a good       * (smart) C compiler might re-arange things wrong.      */
ifdef|#
directive|ifdef
name|AUTOLOGOUT
ifdef|#
directive|ifdef
name|convex
if|if
condition|(
name|uid
operator|==
literal|0
condition|)
comment|/*  root always has a 15 minute autologout  */
name|setcopy
argument_list|(
name|STRautologout
argument_list|,
name|STRrootdefautologout
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|loginsh
condition|)
comment|/*  users get autologout set to 0  */
name|setcopy
argument_list|(
name|STRautologout
argument_list|,
name|STR0
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* convex */
if|if
condition|(
name|loginsh
operator|||
operator|(
name|uid
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|cp
condition|)
block|{
comment|/* only for login shells or root and we must have a tty */
if|if
condition|(
operator|(
name|cp2
operator|=
name|Strrchr
argument_list|(
name|cp
argument_list|,
operator|(
name|Char
operator|)
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|=
name|cp2
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|cp2
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
name|Strncmp
argument_list|(
name|cp2
argument_list|,
name|STRtty
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|Isalpha
argument_list|(
name|cp2
index|[
literal|3
index|]
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|Strncmp
argument_list|(
name|cp
argument_list|,
name|STRpts
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|cp
index|[
literal|3
index|]
operator|==
literal|'/'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|getenv
argument_list|(
literal|"DISPLAY"
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* NOT on X window shells */
name|setcopy
argument_list|(
name|STRautologout
argument_list|,
name|STRdefautologout
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
comment|/* convex */
endif|#
directive|endif
comment|/* AUTOLOGOUT */
name|sigset_interrupting
argument_list|(
name|SIGALRM
argument_list|,
name|queue_alrmcatch
argument_list|)
expr_stmt|;
name|setcopy
argument_list|(
name|STRstatus
argument_list|,
name|STR0
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
comment|/*      * get and set machine specific environment variables      */
name|getmachine
argument_list|()
expr_stmt|;
comment|/*      * Publish the selected echo style      */
if|#
directive|if
name|ECHO_STYLE
operator|!=
name|BSD_ECHO
if|if
condition|(
name|tcsh
condition|)
block|{
if|#
directive|if
name|ECHO_STYLE
operator|==
name|NONE_ECHO
name|setcopy
argument_list|(
name|STRecho_style
argument_list|,
name|STRnone
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ECHO_STYLE == NONE_ECHO */
if|#
directive|if
name|ECHO_STYLE
operator|==
name|SYSV_ECHO
name|setcopy
argument_list|(
name|STRecho_style
argument_list|,
name|STRsysv
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ECHO_STYLE == SYSV_ECHO */
if|#
directive|if
name|ECHO_STYLE
operator|==
name|BOTH_ECHO
name|setcopy
argument_list|(
name|STRecho_style
argument_list|,
name|STRboth
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ECHO_STYLE == BOTH_ECHO */
block|}
else|else
endif|#
directive|endif
comment|/* ECHO_STYLE != BSD_ECHO */
name|setcopy
argument_list|(
name|STRecho_style
argument_list|,
name|STRbsd
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
comment|/*      * increment the shell level.      */
name|shlvl
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tcp
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cp
operator|=
name|quote
argument_list|(
name|SAVE
argument_list|(
name|tcp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|cp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|fast
operator|=
literal|1
expr_stmt|;
comment|/* No home -> can't read scripts */
else|else
name|setv
argument_list|(
name|STRhome
argument_list|,
name|cp
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
name|dinit
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* dinit thinks that HOME == cwd in a login 				 * shell */
comment|/*      * Grab other useful things from the environment. Should we grab      * everything??      */
block|{
name|char
modifier|*
name|cln
decl_stmt|,
modifier|*
name|cus
decl_stmt|,
modifier|*
name|cgr
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|struct
name|group
modifier|*
name|gr
decl_stmt|;
ifdef|#
directive|ifdef
name|apollo
name|int
name|oid
init|=
name|getoid
argument_list|()
decl_stmt|;
name|setv
argument_list|(
name|STRoid
argument_list|,
name|Itoa
argument_list|(
name|oid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* apollo */
name|setv
argument_list|(
name|STRuid
argument_list|,
name|Itoa
argument_list|(
name|uid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
name|setv
argument_list|(
name|STRgid
argument_list|,
name|Itoa
argument_list|(
name|gid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
name|cln
operator|=
name|getenv
argument_list|(
literal|"LOGNAME"
argument_list|)
expr_stmt|;
name|cus
operator|=
name|getenv
argument_list|(
literal|"USER"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cus
operator|!=
name|NULL
condition|)
name|setv
argument_list|(
name|STRuser
argument_list|,
name|quote
argument_list|(
name|SAVE
argument_list|(
name|cus
argument_list|)
argument_list|)
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cln
operator|!=
name|NULL
condition|)
name|setv
argument_list|(
name|STRuser
argument_list|,
name|quote
argument_list|(
name|SAVE
argument_list|(
name|cln
argument_list|)
argument_list|)
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pw
operator|=
name|xgetpwuid
argument_list|(
name|uid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|setcopy
argument_list|(
name|STRuser
argument_list|,
name|str2short
argument_list|(
literal|"unknown"
argument_list|)
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
else|else
name|setcopy
argument_list|(
name|STRuser
argument_list|,
name|str2short
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|)
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cln
operator|==
name|NULL
condition|)
name|tsetenv
argument_list|(
name|STRLOGNAME
argument_list|,
name|varval
argument_list|(
name|STRuser
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cus
operator|==
name|NULL
condition|)
name|tsetenv
argument_list|(
name|STRKUSER
argument_list|,
name|varval
argument_list|(
name|STRuser
argument_list|)
argument_list|)
expr_stmt|;
name|cgr
operator|=
name|getenv
argument_list|(
literal|"GROUP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cgr
operator|!=
name|NULL
condition|)
name|setv
argument_list|(
name|STRgroup
argument_list|,
name|quote
argument_list|(
name|SAVE
argument_list|(
name|cgr
argument_list|)
argument_list|)
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|gr
operator|=
name|xgetgrgid
argument_list|(
name|gid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|setcopy
argument_list|(
name|STRgroup
argument_list|,
name|str2short
argument_list|(
literal|"unknown"
argument_list|)
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
else|else
name|setcopy
argument_list|(
name|STRgroup
argument_list|,
name|str2short
argument_list|(
name|gr
operator|->
name|gr_name
argument_list|)
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cgr
operator|==
name|NULL
condition|)
name|tsetenv
argument_list|(
name|STRKGROUP
argument_list|,
name|varval
argument_list|(
name|STRgroup
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*      * HOST may be wrong, since rexd transports the entire environment on sun      * 3.x Just set it again      */
block|{
name|char
name|cbuff
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
if|if
condition|(
name|gethostname
argument_list|(
name|cbuff
argument_list|,
sizeof|sizeof
argument_list|(
name|cbuff
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|cbuff
index|[
sizeof|sizeof
argument_list|(
name|cbuff
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* just in case */
name|tsetenv
argument_list|(
name|STRHOST
argument_list|,
name|str2short
argument_list|(
name|cbuff
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|tsetenv
argument_list|(
name|STRHOST
argument_list|,
name|str2short
argument_list|(
literal|"unknown"
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|REMOTEHOST
comment|/*      * Try to determine the remote host we were logged in from.      */
name|remotehost
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* REMOTEHOST */
ifdef|#
directive|ifdef
name|apollo
if|if
condition|(
operator|(
name|tcp
operator|=
name|getenv
argument_list|(
literal|"SYSTYPE"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|tcp
operator|=
literal|"bsd4.3"
expr_stmt|;
name|tsetenv
argument_list|(
name|STRSYSTYPE
argument_list|,
name|quote
argument_list|(
name|str2short
argument_list|(
name|tcp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* apollo */
comment|/*      * set editing on by default, unless running under Emacs as an inferior      * shell.      * We try to do this intelligently. If $TERM is available, then it      * should determine if we should edit or not. $TERM is preserved      * across rlogin sessions, so we will not get confused if we rlogin      * under an emacs shell. Another advantage is that if we run an      * xterm under an emacs shell, then the $TERM will be set to       * xterm, so we are going to want to edit. Unfortunately emacs      * does not restore all the tty modes, so xterm is not very well      * set up. But this is not the shell's fault.      * Also don't edit if $TERM == wm, for when we're running under an ATK app.      * Finally, emacs compiled under terminfo, sets the terminal to dumb,      * so disable editing for that too.      *       * Unfortunately, in some cases the initial $TERM setting is "unknown",      * "dumb", or "network" which is then changed in the user's startup files.      * We fix this by setting noediting here if $TERM is unknown/dumb and      * if noediting is set, we switch on editing if $TERM is changed.      */
if|if
condition|(
operator|(
name|tcp
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|setv
argument_list|(
name|STRterm
argument_list|,
name|quote
argument_list|(
name|SAVE
argument_list|(
name|tcp
argument_list|)
argument_list|)
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
name|noediting
operator|=
name|strcmp
argument_list|(
name|tcp
argument_list|,
literal|"unknown"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|tcp
argument_list|,
literal|"dumb"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|tcp
argument_list|,
literal|"network"
argument_list|)
operator|==
literal|0
expr_stmt|;
name|editing
operator|=
name|strcmp
argument_list|(
name|tcp
argument_list|,
literal|"emacs"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|tcp
argument_list|,
literal|"wm"
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|noediting
expr_stmt|;
block|}
else|else
block|{
name|noediting
operator|=
literal|0
expr_stmt|;
name|editing
operator|=
operator|(
operator|(
name|tcp
operator|=
name|getenv
argument_list|(
literal|"EMACS"
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|tcp
argument_list|,
literal|"t"
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
comment|/*       * The 'edit' variable is either set or unset.  It doesn't       * need a value.  Making it 'emacs' might be confusing.       */
if|if
condition|(
name|editing
condition|)
name|setNS
argument_list|(
name|STRedit
argument_list|)
expr_stmt|;
comment|/*      * still more mutability: make the complete routine automatically add the      * suffix of file names...      */
name|setNS
argument_list|(
name|STRaddsuffix
argument_list|)
expr_stmt|;
comment|/*      * Compatibility with tcsh>= 6.12 by default      */
name|setNS
argument_list|(
name|STRcsubstnonl
argument_list|)
expr_stmt|;
comment|/*      * Random default kill ring size      */
name|setcopy
argument_list|(
name|STRkillring
argument_list|,
name|str2short
argument_list|(
literal|"30"
argument_list|)
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
comment|/*      * Re-initialize path if set in environment      */
if|if
condition|(
operator|(
name|tcp
operator|=
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
ifdef|#
directive|ifdef
name|_PATH_DEFPATH
name|importpath
argument_list|(
name|str2short
argument_list|(
name|_PATH_DEFPATH
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !_PATH_DEFPATH */
name|setq
argument_list|(
name|STRpath
argument_list|,
name|defaultpath
argument_list|()
argument_list|,
operator|&
name|shvhed
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _PATH_DEFPATH */
else|else
comment|/* Importpath() allocates memory for the path, and the 	 * returned pointer from SAVE() was discarded, so 	 * this was a memory leak.. (sg) 	 * 	 * importpath(SAVE(tcp)); 	 */
name|importpath
argument_list|(
name|str2short
argument_list|(
name|tcp
argument_list|)
argument_list|)
expr_stmt|;
block|{
comment|/* If the SHELL environment variable ends with "tcsh", set 	 * STRshell to the same path.  This is to facilitate using 	 * the executable in environments where the compiled-in 	 * default isn't appropriate (sg). 	 */
name|size_t
name|sh_len
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|tcp
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sh_len
operator|=
name|strlen
argument_list|(
name|tcp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sh_len
operator|>=
literal|5
operator|&&
name|strcmp
argument_list|(
name|tcp
operator|+
operator|(
name|sh_len
operator|-
literal|5
operator|)
argument_list|,
literal|"/tcsh"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|!
name|tcsh
operator|&&
name|sh_len
operator|>=
literal|4
operator|&&
name|strcmp
argument_list|(
name|tcp
operator|+
operator|(
name|sh_len
operator|-
literal|4
operator|)
argument_list|,
literal|"/csh"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|setv
argument_list|(
name|STRshell
argument_list|,
name|quote
argument_list|(
name|SAVE
argument_list|(
name|tcp
argument_list|)
argument_list|)
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
else|else
name|sh_len
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sh_len
operator|==
literal|0
condition|)
name|setcopy
argument_list|(
name|STRshell
argument_list|,
name|STR_SHELLPATH
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|_OSD_POSIX
comment|/* BS2000 needs this variable set to "SHELL" */
if|if
condition|(
operator|(
name|tcp
operator|=
name|getenv
argument_list|(
literal|"PROGRAM_ENVIRONMENT"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|tcp
operator|=
literal|"SHELL"
expr_stmt|;
name|tsetenv
argument_list|(
name|STRPROGRAM_ENVIRONMENT
argument_list|,
name|quote
argument_list|(
name|str2short
argument_list|(
name|tcp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _OSD_POSIX */
ifdef|#
directive|ifdef
name|COLOR_LS_F
if|if
condition|(
operator|(
name|tcp
operator|=
name|getenv
argument_list|(
literal|"LS_COLORS"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|parseLS_COLORS
argument_list|(
name|str2short
argument_list|(
name|tcp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COLOR_LS_F */
name|doldol
operator|=
name|putn
argument_list|(
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* For $$ */
ifdef|#
directive|ifdef
name|WINNT_NATIVE
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|Char
modifier|*
name|tmp2
decl_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|getenv
argument_list|(
literal|"TMP"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|tmp
operator|=
name|xasprintf
argument_list|(
literal|"%s/%s"
argument_list|,
name|tmp
argument_list|,
literal|"sh"
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|SAVE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp2
operator|=
name|SAVE
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|shtemp
operator|=
name|Strspl
argument_list|(
name|tmp2
argument_list|,
name|doldol
argument_list|)
expr_stmt|;
comment|/* For<< */
name|xfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* !WINNT_NATIVE */
name|shtemp
operator|=
name|Strspl
argument_list|(
name|STRtmpsh
argument_list|,
name|doldol
argument_list|)
expr_stmt|;
comment|/* For<< */
endif|#
directive|endif
comment|/* WINNT_NATIVE */
comment|/*      * Record the interrupt states from the parent process. If the parent is      * non-interruptible our hand must be forced or we (and our children) won't      * be either. Our children inherit termination from our parent. We catch it      * only if we are the login shell.      */
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
name|NULL
argument_list|,
operator|&
name|parintr
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGTERM
argument_list|,
name|NULL
argument_list|,
operator|&
name|parterm
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCF
comment|/* Enable process migration on ourselves and our progeny */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGMIGRATE
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TCF */
comment|/*      * dspkanji/dspmbyte autosetting      */
comment|/* PATCH IDEA FROM Issei.Suzuki VERY THANKS */
if|#
directive|if
name|defined
argument_list|(
name|DSPMBYTE
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|NLS
argument_list|)
operator|&&
name|defined
argument_list|(
name|LC_CTYPE
argument_list|)
if|if
condition|(
operator|(
operator|(
name|tcp
operator|=
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|tcp
operator|=
name|getenv
argument_list|(
literal|"LANG"
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|adrof
argument_list|(
name|CHECK_MBYTEVAR
argument_list|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|tcp
operator|=
name|getenv
argument_list|(
literal|"LANG"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|!
name|adrof
argument_list|(
name|CHECK_MBYTEVAR
argument_list|)
condition|)
block|{
endif|#
directive|endif
name|autoset_dspmbyte
argument_list|(
name|str2short
argument_list|(
name|tcp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|WINNT_NATIVE
argument_list|)
elseif|else
if|if
condition|(
operator|!
name|adrof
argument_list|(
name|CHECK_MBYTEVAR
argument_list|)
condition|)
name|nt_autoset_dspmbyte
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* WINNT_NATIVE */
endif|#
directive|endif
name|fix_version
argument_list|()
expr_stmt|;
comment|/* publish the shell version */
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"--version"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xprintf
argument_list|(
literal|"%S\n"
argument_list|,
name|varval
argument_list|(
name|STRversion
argument_list|)
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"--help"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xprintf
argument_list|(
literal|"%S\n\n"
argument_list|,
name|varval
argument_list|(
name|STRversion
argument_list|)
argument_list|)
expr_stmt|;
name|xprintf
argument_list|(
name|CGETS
argument_list|(
literal|11
argument_list|,
literal|8
argument_list|,
name|HELP_STRING
argument_list|)
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*      * Process the arguments.      *       * Note that processing of -v/-x is actually delayed till after script      * processing.      *       * We set the first character of our name to be '-' if we are a shell       * running interruptible commands.  Many programs which examine ps'es       * use this to filter such shells out.      */
name|argc
operator|--
operator|,
name|tempv
operator|++
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|0
operator|&&
operator|(
name|tcp
operator|=
name|tempv
index|[
literal|0
index|]
operator|)
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
operator|*
operator|++
name|tcp
operator|!=
literal|'\0'
operator|&&
operator|!
name|batch
condition|)
block|{
do|do
switch|switch
condition|(
operator|*
name|tcp
operator|++
condition|)
block|{
case|case
literal|0
case|:
comment|/* -	Interruptible, no prompt */
name|prompt
operator|=
literal|0
expr_stmt|;
name|setintr
operator|=
literal|1
expr_stmt|;
name|nofile
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* -b	Next arg is input file */
name|batch
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* -c	Command input from arg */
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|argc
operator|--
operator|,
name|tempv
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|M_XENIX
comment|/* Xenix Vi bug: 		   it relies on a 7 bit environment (/bin/sh), so it 		   pass ascii arguments with the 8th bit set */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"sh"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|tempv
index|[
literal|0
index|]
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
operator|*
name|p
operator|&=
name|ASCII
expr_stmt|;
block|}
endif|#
directive|endif
name|arginp
operator|=
name|SAVE
argument_list|(
name|tempv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* 		 * we put the command into a variable 		 */
if|if
condition|(
name|arginp
operator|!=
name|NULL
condition|)
name|setv
argument_list|(
name|STRcommand
argument_list|,
name|quote
argument_list|(
name|Strsave
argument_list|(
name|arginp
argument_list|)
argument_list|)
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
comment|/* 		 * * Give an error on -c arguments that end in * backslash to 		 * ensure that you don't make * nonportable csh scripts. 		 */
block|{
name|int
name|count
decl_stmt|;
name|cp
operator|=
name|Strend
argument_list|(
name|arginp
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cp
operator|>
name|arginp
operator|&&
operator|*
operator|--
name|cp
operator|==
literal|'\\'
condition|)
operator|++
name|count
expr_stmt|;
if|if
condition|(
operator|(
name|count
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|exiterr
operator|=
literal|1
expr_stmt|;
name|stderror
argument_list|(
name|ERR_ARGC
argument_list|)
expr_stmt|;
block|}
block|}
name|prompt
operator|=
literal|0
expr_stmt|;
name|nofile
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* -d	Load directory stack from file */
name|rdirs
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|apollo
case|case
literal|'D'
case|:
comment|/* -D	Define environment variable */
block|{
name|Char
modifier|*
name|dp
decl_stmt|;
name|cp
operator|=
name|str2short
argument_list|(
name|tcp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|=
name|Strchr
argument_list|(
name|cp
argument_list|,
literal|'='
argument_list|)
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|tsetenv
argument_list|(
name|cp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
else|else
name|tsetenv
argument_list|(
name|cp
argument_list|,
name|STRNULL
argument_list|)
expr_stmt|;
block|}
operator|*
name|tcp
operator|=
literal|'\0'
expr_stmt|;
comment|/* done with this argument */
break|break;
endif|#
directive|endif
comment|/* apollo */
case|case
literal|'e'
case|:
comment|/* -e	Exit on any error */
name|exiterr
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* -f	Fast start */
name|fast
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* -i	Interactive, even if !intty */
name|intact
operator|=
literal|1
expr_stmt|;
name|nofile
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* -m	read .cshrc (from su) */
name|mflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* -n	Don't execute */
name|noexec
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* -q	(Undoc'd) ... die on quit */
name|quitit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* -s	Read from std input */
name|nofile
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* -t	Read one line from input */
name|onelflg
operator|=
literal|2
expr_stmt|;
name|prompt
operator|=
literal|0
expr_stmt|;
name|nofile
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* -v	Echo hist expanded input */
name|nverbose
operator|=
literal|1
expr_stmt|;
comment|/* ... later */
break|break;
case|case
literal|'x'
case|:
comment|/* -x	Echo just before execution */
name|nexececho
operator|=
literal|1
expr_stmt|;
comment|/* ... later */
break|break;
case|case
literal|'V'
case|:
comment|/* -V	Echo hist expanded input */
name|setNS
argument_list|(
name|STRverbose
argument_list|)
expr_stmt|;
comment|/* NOW! */
break|break;
case|case
literal|'X'
case|:
comment|/* -X	Echo just before execution */
name|setNS
argument_list|(
name|STRecho
argument_list|)
expr_stmt|;
comment|/* NOW! */
break|break;
case|case
literal|'F'
case|:
comment|/* 		 * This will cause children to be created using fork instead of 		 * vfork. 		 */
name|use_fork
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
comment|/*  		 * for O/S's that don't do the argument parsing right in  		 * "#!/foo -f " scripts 		 */
break|break;
default|default:
comment|/* Unknown command option */
name|exiterr
operator|=
literal|1
expr_stmt|;
name|stderror
argument_list|(
name|ERR_TCSHUSAGE
argument_list|,
name|tcp
operator|-
literal|1
argument_list|,
name|progname
argument_list|)
expr_stmt|;
break|break;
block|}
do|while
condition|(
operator|*
name|tcp
condition|)
do|;
name|tempv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|quitit
condition|)
comment|/* With all due haste, for debugging */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/*      * Unless prevented by -, -c, -i, -s, or -t, if there are remaining      * arguments the first of them is the name of a shell file from which to      * read commands.      */
if|if
condition|(
name|nofile
operator|==
literal|0
operator|&&
name|argc
operator|>
literal|0
condition|)
block|{
name|nofile
operator|=
name|xopen
argument_list|(
name|tempv
index|[
literal|0
index|]
argument_list|,
name|O_RDONLY
operator||
name|O_LARGEFILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nofile
operator|<
literal|0
condition|)
block|{
name|child
operator|=
literal|1
expr_stmt|;
comment|/* So this ... */
comment|/* ... doesn't return */
name|stderror
argument_list|(
name|ERR_SYSTEM
argument_list|,
name|tempv
index|[
literal|0
index|]
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|O_TEXT
name|setmode
argument_list|(
name|nofile
argument_list|,
name|O_TEXT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xfree
argument_list|(
name|ffile
argument_list|)
expr_stmt|;
name|dolzero
operator|=
literal|1
expr_stmt|;
name|ffile
operator|=
name|SAVE
argument_list|(
name|tempv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/*  	 * Replace FSHIN. Handle /dev/std{in,out,err} specially 	 * since once they are closed we cannot open them again. 	 * In that case we use our own saved descriptors 	 */
if|if
condition|(
operator|(
name|SHIN
operator|=
name|dmove
argument_list|(
name|nofile
argument_list|,
name|FSHIN
argument_list|)
operator|)
operator|<
literal|0
condition|)
switch|switch
condition|(
name|nofile
condition|)
block|{
case|case
literal|0
case|:
name|SHIN
operator|=
name|FSHIN
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|SHIN
operator|=
name|FSHOUT
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|SHIN
operator|=
name|FSHDIAG
expr_stmt|;
break|break;
default|default:
name|stderror
argument_list|(
name|ERR_SYSTEM
argument_list|,
name|tempv
index|[
literal|0
index|]
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|close_on_exec
argument_list|(
name|SHIN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|prompt
operator|=
literal|0
expr_stmt|;
comment|/* argc not used any more */
name|tempv
operator|++
expr_stmt|;
block|}
comment|/*       * Call to closem() used to be part of initdesc(). Now called below where      * the script name argument has become stdin. Kernel may have used a file      * descriptor to hold the name of the script (setuid case) and this name      * mustn't be lost by closing the fd too soon.      */
name|closem
argument_list|()
expr_stmt|;
comment|/*      * Consider input a tty if it really is or we are interactive. but not for      * editing (christos)      */
if|if
condition|(
operator|!
operator|(
name|intty
operator|=
name|isatty
argument_list|(
name|SHIN
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|adrof
argument_list|(
name|STRedit
argument_list|)
condition|)
name|unsetv
argument_list|(
name|STRedit
argument_list|)
expr_stmt|;
name|editing
operator|=
literal|0
expr_stmt|;
block|}
name|intty
operator||=
name|intact
expr_stmt|;
ifndef|#
directive|ifndef
name|convex
if|if
condition|(
name|intty
operator|||
operator|(
name|intact
operator|&&
name|isatty
argument_list|(
name|SHOUT
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|batch
operator|&&
operator|(
name|uid
operator|!=
name|euid
operator|||
name|gid
operator|!=
name|egid
operator|)
condition|)
block|{
name|errno
operator|=
name|EACCES
expr_stmt|;
name|child
operator|=
literal|1
expr_stmt|;
comment|/* So this ... */
comment|/* ... doesn't return */
name|stderror
argument_list|(
name|ERR_SYSTEM
argument_list|,
name|progname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* convex */
name|isoutatty
operator|=
name|isatty
argument_list|(
name|SHOUT
argument_list|)
expr_stmt|;
name|isdiagatty
operator|=
name|isatty
argument_list|(
name|SHDIAG
argument_list|)
expr_stmt|;
comment|/*      * Decide whether we should play with signals or not. If we are explicitly      * told (via -i, or -) or we are a login shell (arg0 starts with -) or the      * input and output are both the ttys("csh", or "csh</dev/ttyx>/dev/ttyx")      * Note that in only the login shell is it likely that parent may have set      * signals to be ignored      */
if|if
condition|(
name|loginsh
operator|||
name|intact
operator|||
operator|(
name|intty
operator|&&
name|isatty
argument_list|(
name|SHOUT
argument_list|)
operator|)
condition|)
name|setintr
operator|=
literal|1
expr_stmt|;
name|settell
argument_list|()
expr_stmt|;
comment|/*      * Save the remaining arguments in argv.      */
name|setq
argument_list|(
name|STRargv
argument_list|,
name|blk2short
argument_list|(
name|tempv
argument_list|)
argument_list|,
operator|&
name|shvhed
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
comment|/*      * Set up the prompt.      */
if|if
condition|(
name|prompt
condition|)
block|{
if|if
condition|(
name|tcsh
condition|)
name|setcopy
argument_list|(
name|STRprompt
argument_list|,
name|STRdeftcshprompt
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
else|else
name|setcopy
argument_list|(
name|STRprompt
argument_list|,
name|STRdefcshprompt
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
comment|/* that's a meta-questionmark */
name|setcopy
argument_list|(
name|STRprompt2
argument_list|,
name|STRmquestion
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
name|setcopy
argument_list|(
name|STRprompt3
argument_list|,
name|STRKCORRECT
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
block|}
comment|/*      * If we are an interactive shell, then start fiddling with the signals;      * this is a tricky game.      */
name|shpgrp
operator|=
name|mygetpgrp
argument_list|()
expr_stmt|;
name|opgrp
operator|=
name|tpgrp
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|setintr
condition|)
block|{
name|struct
name|sigaction
name|osig
decl_stmt|;
operator|*
operator|*
name|argv
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
operator|!
name|quitit
condition|)
comment|/* Wary! */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|pintr_disabled
operator|=
literal|1
expr_stmt|;
name|sigset_interrupting
argument_list|(
name|SIGINT
argument_list|,
name|queue_pintr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/*  	 * No reason I can see not to save history on all these events.. 	 * Most usual occurrence is in a window system, where we're not a login 	 * shell, but might as well be... (sg) 	 * But there might be races when lots of shells exit together... 	 * [this is also incompatible]. 	 * We have to be mre careful here. If the parent wants to  	 * ignore the signals then we leave them untouched... 	 * We also only setup the handlers for shells that are trully 	 * interactive. 	 */
name|sigaction
argument_list|(
name|SIGHUP
argument_list|,
name|NULL
argument_list|,
operator|&
name|osig
argument_list|)
expr_stmt|;
if|if
condition|(
name|loginsh
operator|||
name|osig
operator|.
name|sa_handler
operator|!=
name|SIG_IGN
condition|)
comment|/* exit processing on HUP */
name|sigset_interrupting
argument_list|(
name|SIGHUP
argument_list|,
name|queue_phup
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGXCPU
name|sigaction
argument_list|(
name|SIGXCPU
argument_list|,
name|NULL
argument_list|,
operator|&
name|osig
argument_list|)
expr_stmt|;
if|if
condition|(
name|loginsh
operator|||
name|osig
operator|.
name|sa_handler
operator|!=
name|SIG_IGN
condition|)
comment|/* exit processing on XCPU */
name|sigset_interrupting
argument_list|(
name|SIGXCPU
argument_list|,
name|queue_phup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXFSZ
name|sigaction
argument_list|(
name|SIGXFSZ
argument_list|,
name|NULL
argument_list|,
operator|&
name|osig
argument_list|)
expr_stmt|;
if|if
condition|(
name|loginsh
operator|||
name|osig
operator|.
name|sa_handler
operator|!=
name|SIG_IGN
condition|)
comment|/* exit processing on XFSZ */
name|sigset_interrupting
argument_list|(
name|SIGXFSZ
argument_list|,
name|queue_phup
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|quitit
operator|==
literal|0
operator|&&
name|arginp
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|SIGTSTP
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTTIN
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTTOU
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	     * Wait till in foreground, in case someone stupidly runs csh& 	     * dont want to try to grab away the tty. 	     */
if|if
condition|(
name|isatty
argument_list|(
name|FSHDIAG
argument_list|)
condition|)
name|f
operator|=
name|FSHDIAG
expr_stmt|;
elseif|else
if|if
condition|(
name|isatty
argument_list|(
name|FSHOUT
argument_list|)
condition|)
name|f
operator|=
name|FSHOUT
expr_stmt|;
elseif|else
if|if
condition|(
name|isatty
argument_list|(
name|OLDSTD
argument_list|)
condition|)
name|f
operator|=
name|OLDSTD
expr_stmt|;
else|else
name|f
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|NeXT
comment|/* NeXT 2.0 /usr/etc/rlogind, does not set our process group! */
if|if
condition|(
name|shpgrp
operator|==
literal|0
condition|)
block|{
name|shpgrp
operator|=
name|getpid
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|setpgid
argument_list|(
literal|0
argument_list|,
name|shpgrp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tcsetpgrp
argument_list|(
name|f
argument_list|,
name|shpgrp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NeXT */
ifdef|#
directive|ifdef
name|BSDJOBS
comment|/* if we have tty job control */
name|retry
label|:
if|if
condition|(
operator|(
name|tpgrp
operator|=
name|tcgetpgrp
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|tpgrp
operator|!=
name|shpgrp
condition|)
block|{
name|struct
name|sigaction
name|old
decl_stmt|;
name|sigaction
argument_list|(
name|SIGTTIN
argument_list|,
name|NULL
argument_list|,
operator|&
name|old
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTTIN
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGTTIN
argument_list|,
operator|&
name|old
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
comment|/* 		 * Thanks to Matt Day for the POSIX references, and to 		 * Paul Close for the SGI clarification. 		 */
if|if
condition|(
name|setdisc
argument_list|(
name|f
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|opgrp
operator|=
name|shpgrp
expr_stmt|;
name|shpgrp
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|tpgrp
operator|=
name|shpgrp
expr_stmt|;
if|if
condition|(
name|tcsetpgrp
argument_list|(
name|f
argument_list|,
name|shpgrp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 			 * On hpux 7.03 this fails with EPERM. This happens on 			 * the 800 when opgrp != shpgrp at this point. (we were 			 * forked from a non job control shell) 			 * POSIX 7.2.4, says we failed because the process 			 * group specified did not belong to a process 			 * in the same session with the tty. So we set our 			 * process group and try again. 			 */
if|if
condition|(
name|setpgid
argument_list|(
literal|0
argument_list|,
name|shpgrp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|xprintf
argument_list|(
literal|"setpgid:"
argument_list|)
expr_stmt|;
goto|goto
name|notty
goto|;
block|}
if|if
condition|(
name|tcsetpgrp
argument_list|(
name|f
argument_list|,
name|shpgrp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|xprintf
argument_list|(
literal|"tcsetpgrp:"
argument_list|)
expr_stmt|;
goto|goto
name|notty
goto|;
block|}
block|}
comment|/* 		     * We check the process group now. If it is the same, then 		     * we don't need to set it again. On hpux 7.0 on the 300's 		     * if we set it again it fails with EPERM. This is the 		     * correct behavior according to POSIX 4.3.3 if the process 		     * was a session leader . 		     */
elseif|else
if|if
condition|(
name|shpgrp
operator|!=
name|mygetpgrp
argument_list|()
condition|)
block|{
if|if
condition|(
name|setpgid
argument_list|(
literal|0
argument_list|,
name|shpgrp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|xprintf
argument_list|(
literal|"setpgid:"
argument_list|)
expr_stmt|;
goto|goto
name|notty
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|IRIS4D
comment|/* 		     * But on irix 3.3 we need to set it again, even if it is 		     * the same. We do that to tell the system that we 		     * need BSD process group compatibility. 		     */
else|else
operator|(
name|void
operator|)
name|setpgid
argument_list|(
literal|0
argument_list|,
name|shpgrp
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|close_on_exec
argument_list|(
name|dcopy
argument_list|(
name|f
argument_list|,
name|FSHTTY
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|tpgrp
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tpgrp
operator|==
operator|-
literal|1
condition|)
block|{
name|notty
label|:
name|xprintf
argument_list|(
name|CGETS
argument_list|(
literal|11
argument_list|,
literal|1
argument_list|,
literal|"Warning: no access to tty (%s).\n"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|xprintf
argument_list|(
name|CGETS
argument_list|(
literal|11
argument_list|,
literal|2
argument_list|,
literal|"Thus no job control in this shell.\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Fix from:Sakari Jalovaara<sja@sirius.hut.fi> if we don't 		 * have access to tty, disable editing too 		 */
if|if
condition|(
name|adrof
argument_list|(
name|STRedit
argument_list|)
condition|)
name|unsetv
argument_list|(
name|STRedit
argument_list|)
expr_stmt|;
name|editing
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
comment|/* BSDJOBS */
comment|/* don't have job control, so frotz it */
name|tpgrp
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* BSDJOBS */
block|}
block|}
if|if
condition|(
name|setintr
operator|==
literal|0
operator|&&
name|parintr
operator|.
name|sa_handler
operator|==
name|SIG_DFL
condition|)
name|setintr
operator|=
literal|1
expr_stmt|;
comment|/*  * SVR4 doesn't send a SIGCHLD when a child is stopped or continued if the  * handler is installed with signal(2) or sigset(2).  sigaction(2) must  * be used instead.  *  * David Dawes (dawes@physics.su.oz.au) Sept 1991  */
name|sigset_interrupting
argument_list|(
name|SIGCHLD
argument_list|,
name|queue_pchild
argument_list|)
expr_stmt|;
if|if
condition|(
name|intty
operator|&&
operator|!
name|arginp
condition|)
operator|(
name|void
operator|)
name|ed_Setup
argument_list|(
name|editing
argument_list|)
expr_stmt|;
comment|/* Get the tty state, and set defaults */
comment|/* Only alter the tty state if editing */
comment|/*      * Set an exit here in case of an interrupt or error reading the shell      * start-up scripts.      */
name|osetintr
operator|=
name|setintr
expr_stmt|;
name|oparintr
operator|=
name|parintr
expr_stmt|;
operator|(
name|void
operator|)
name|cleanup_push_mark
argument_list|()
expr_stmt|;
comment|/* There is no outer handler */
if|if
condition|(
name|setexit
argument_list|()
operator|!=
literal|0
condition|)
comment|/* PWP */
name|reenter
operator|=
literal|1
expr_stmt|;
else|else
name|reenter
operator|=
literal|0
expr_stmt|;
name|exitset
operator|++
expr_stmt|;
name|haderr
operator|=
literal|0
expr_stmt|;
comment|/* In case second time through */
if|if
condition|(
operator|!
name|fast
operator|&&
name|reenter
operator|==
literal|0
condition|)
block|{
comment|/* Will have varval(STRhome) here because set fast if don't */
block|{
name|pintr_disabled
operator|++
expr_stmt|;
name|cleanup_push
argument_list|(
operator|&
name|pintr_disabled
argument_list|,
name|disabled_cleanup
argument_list|)
expr_stmt|;
name|setintr
operator|=
literal|0
expr_stmt|;
comment|/*FIXRESET:cleanup*/
comment|/* onintr in /etc/ files has no effect */
name|parintr
operator|.
name|sa_handler
operator|=
name|SIG_IGN
expr_stmt|;
comment|/*FIXRESET: cleanup*/
ifdef|#
directive|ifdef
name|LOGINFIRST
ifdef|#
directive|ifdef
name|_PATH_DOTLOGIN
if|if
condition|(
name|loginsh
condition|)
operator|(
name|void
operator|)
name|srcfile
argument_list|(
name|_PATH_DOTLOGIN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_PATH_DOTCSHRC
operator|(
name|void
operator|)
name|srcfile
argument_list|(
name|_PATH_DOTCSHRC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|arginp
operator|&&
operator|!
name|onelflg
operator|&&
operator|!
name|havhash
condition|)
name|dohash
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|LOGINFIRST
ifdef|#
directive|ifdef
name|_PATH_DOTLOGIN
if|if
condition|(
name|loginsh
condition|)
operator|(
name|void
operator|)
name|srcfile
argument_list|(
name|_PATH_DOTLOGIN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|cleanup_until
argument_list|(
operator|&
name|pintr_disabled
argument_list|)
expr_stmt|;
name|setintr
operator|=
name|osetintr
expr_stmt|;
name|parintr
operator|=
name|oparintr
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LOGINFIRST
if|if
condition|(
name|loginsh
condition|)
operator|(
name|void
operator|)
name|srccat
argument_list|(
name|varval
argument_list|(
name|STRhome
argument_list|)
argument_list|,
name|STRsldotlogin
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* upward compat. */
if|if
condition|(
operator|!
name|srccat
argument_list|(
name|varval
argument_list|(
name|STRhome
argument_list|)
argument_list|,
name|STRsldottcshrc
argument_list|)
condition|)
operator|(
name|void
operator|)
name|srccat
argument_list|(
name|varval
argument_list|(
name|STRhome
argument_list|)
argument_list|,
name|STRsldotcshrc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arginp
operator|&&
operator|!
name|onelflg
operator|&&
operator|!
name|havhash
condition|)
name|dohash
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Source history before .login so that it is available in .login 	 */
name|loadhist
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|LOGINFIRST
if|if
condition|(
name|loginsh
condition|)
operator|(
name|void
operator|)
name|srccat
argument_list|(
name|varval
argument_list|(
name|STRhome
argument_list|)
argument_list|,
name|STRsldotlogin
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|loginsh
operator|||
name|rdirs
condition|)
name|loaddirs
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Reset interrupt flag */
name|setintr
operator|=
name|osetintr
expr_stmt|;
name|parintr
operator|=
name|oparintr
expr_stmt|;
name|exitset
operator|--
expr_stmt|;
comment|/* Initing AFTER .cshrc is the Right Way */
if|if
condition|(
name|intty
operator|&&
operator|!
name|arginp
condition|)
block|{
comment|/* PWP setup stuff */
name|ed_Init
argument_list|()
expr_stmt|;
comment|/* init the new line editor */
ifdef|#
directive|ifdef
name|SIG_WINDOW
name|check_window_size
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* mung environment */
endif|#
directive|endif
comment|/* SIG_WINDOW */
block|}
comment|/*      * Now are ready for the -v and -x flags      */
if|if
condition|(
name|nverbose
condition|)
name|setNS
argument_list|(
name|STRverbose
argument_list|)
expr_stmt|;
if|if
condition|(
name|nexececho
condition|)
name|setNS
argument_list|(
name|STRecho
argument_list|)
expr_stmt|;
comment|/*      * All the rest of the world is inside this call. The argument to process      * indicates whether it should catch "error unwinds".  Thus if we are a      * interactive shell our call here will never return by being blown past on      * an error.      */
name|process
argument_list|(
name|setintr
argument_list|)
expr_stmt|;
comment|/*      * Mop-up.      */
if|if
condition|(
name|intty
condition|)
block|{
if|if
condition|(
name|loginsh
condition|)
block|{
name|xprintf
argument_list|(
literal|"logout\n"
argument_list|)
expr_stmt|;
name|xclose
argument_list|(
name|SHIN
argument_list|)
expr_stmt|;
name|child
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|TESLA
name|do_logout
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* TESLA */
name|goodbye
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xprintf
argument_list|(
literal|"exit\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|record
argument_list|()
expr_stmt|;
name|exitstat
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|void
name|untty
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BSDJOBS
if|if
condition|(
name|tpgrp
operator|>
literal|0
operator|&&
name|opgrp
operator|!=
name|shpgrp
condition|)
block|{
operator|(
name|void
operator|)
name|setpgid
argument_list|(
literal|0
argument_list|,
name|opgrp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tcsetpgrp
argument_list|(
name|FSHTTY
argument_list|,
name|opgrp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|resetdisc
argument_list|(
name|FSHTTY
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* BSDJOBS */
block|}
name|void
name|importpath
parameter_list|(
name|Char
modifier|*
name|cp
parameter_list|)
block|{
name|size_t
name|i
init|=
literal|0
decl_stmt|;
name|Char
modifier|*
name|dp
decl_stmt|;
name|Char
modifier|*
modifier|*
name|pv
decl_stmt|;
name|int
name|c
decl_stmt|;
for|for
control|(
name|dp
operator|=
name|cp
init|;
operator|*
name|dp
condition|;
name|dp
operator|++
control|)
if|if
condition|(
operator|*
name|dp
operator|==
name|PATHSEP
condition|)
name|i
operator|++
expr_stmt|;
comment|/*      * i+2 where i is the number of colons in the path. There are i+1      * directories in the path plus we need room for a zero terminator.      */
name|pv
operator|=
name|xcalloc
argument_list|(
name|i
operator|+
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|Char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|=
name|cp
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|dp
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|dp
operator|)
operator|==
name|PATHSEP
operator|||
name|c
operator|==
literal|0
condition|)
block|{
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
name|pv
index|[
name|i
operator|++
index|]
operator|=
name|Strsave
argument_list|(
operator|*
name|cp
condition|?
name|cp
else|:
name|STRdot
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
name|cp
operator|=
name|dp
operator|+
literal|1
expr_stmt|;
operator|*
name|dp
operator|=
name|PATHSEP
expr_stmt|;
block|}
else|else
break|break;
block|}
ifdef|#
directive|ifdef
name|WINNT_NATIVE
elseif|else
if|if
condition|(
operator|*
name|dp
operator|==
literal|'\\'
condition|)
operator|*
name|dp
operator|=
literal|'/'
expr_stmt|;
endif|#
directive|endif
comment|/* WINNT_NATIVE */
name|dp
operator|++
expr_stmt|;
block|}
name|pv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|cleanup_push
argument_list|(
name|pv
argument_list|,
name|blk_cleanup
argument_list|)
expr_stmt|;
name|setq
argument_list|(
name|STRpath
argument_list|,
name|pv
argument_list|,
operator|&
name|shvhed
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
name|cleanup_ignore
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|cleanup_until
argument_list|(
name|pv
argument_list|)
expr_stmt|;
block|}
comment|/*  * Source to the file which is the catenation of the argument names.  */
specifier|static
name|int
name|srccat
parameter_list|(
name|Char
modifier|*
name|cp
parameter_list|,
name|Char
modifier|*
name|dp
parameter_list|)
block|{
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
name|srcfile
argument_list|(
name|short2str
argument_list|(
name|dp
argument_list|)
argument_list|,
operator|(
name|mflag
condition|?
literal|0
else|:
literal|1
operator|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
else|else
block|{
name|Char
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|rv
decl_stmt|;
ifdef|#
directive|ifdef
name|WINNT_NATIVE
name|ep
operator|=
name|Strend
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|!=
name|cp
operator|&&
name|ep
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|&&
name|dp
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
comment|/* silly win95 */
name|dp
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* WINNT_NATIVE */
name|ep
operator|=
name|Strspl
argument_list|(
name|cp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|cleanup_push
argument_list|(
name|ep
argument_list|,
name|xfree
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|short2str
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|rv
operator|=
name|srcfile
argument_list|(
name|ptr
argument_list|,
operator|(
name|mflag
condition|?
literal|0
else|:
literal|1
operator|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cleanup_until
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
block|}
comment|/*  * Source to a file putting the file descriptor in a safe place (> 2).  */
ifndef|#
directive|ifndef
name|WINNT_NATIVE
specifier|static
name|int
else|#
directive|else
name|int
endif|#
directive|endif
comment|/*WINNT_NATIVE*/
name|srcfile
parameter_list|(
specifier|const
name|char
modifier|*
name|f
parameter_list|,
name|int
name|onlyown
parameter_list|,
name|int
name|flag
parameter_list|,
name|Char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
if|if
condition|(
operator|(
name|unit
operator|=
name|xopen
argument_list|(
name|f
argument_list|,
name|O_RDONLY
operator||
name|O_LARGEFILE
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|O_TEXT
name|setmode
argument_list|(
name|unit
argument_list|,
name|O_TEXT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cleanup_push
argument_list|(
operator|&
name|unit
argument_list|,
name|open_cleanup
argument_list|)
expr_stmt|;
name|unit
operator|=
name|dmove
argument_list|(
name|unit
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cleanup_ignore
argument_list|(
operator|&
name|unit
argument_list|)
expr_stmt|;
name|cleanup_until
argument_list|(
operator|&
name|unit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close_on_exec
argument_list|(
name|unit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|srcunit
argument_list|(
name|unit
argument_list|,
name|onlyown
argument_list|,
name|flag
argument_list|,
name|av
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/*  * Save the shell state, and establish new argument vector, and new input  * fd.  */
specifier|static
name|void
name|st_save
parameter_list|(
name|struct
name|saved_state
modifier|*
name|st
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|hflg
parameter_list|,
name|Char
modifier|*
modifier|*
name|al
parameter_list|,
name|Char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|st
operator|->
name|insource
operator|=
name|insource
expr_stmt|;
name|st
operator|->
name|SHIN
operator|=
name|SHIN
expr_stmt|;
comment|/* Want to preserve the meaning of "source file>output".      * Save old descriptors, move new 0,1,2 to safe places and assign      * them to SH* and let process() redo 0,1,2 from them.      *      * The macro returns true if d1 and d2 are good and they point to      * different things.  If you don't avoid saving duplicate      * descriptors, you really limit the depth of "source" recursion      * you can do because of all the open file descriptors.  -IAN!      */
define|#
directive|define
name|NEED_SAVE_FD
parameter_list|(
name|d1
parameter_list|,
name|d2
parameter_list|)
define|\
value|(fstat(d1,&s1) != -1&& fstat(d2,&s2) != -1 \&& (s1.st_ino != s2.st_ino || s1.st_dev != s2.st_dev) )
name|st
operator|->
name|OLDSTD
operator|=
name|st
operator|->
name|SHOUT
operator|=
name|st
operator|->
name|SHDIAG
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* test later to restore these */
if|if
condition|(
name|didfds
condition|)
block|{
name|struct
name|stat
name|s1
decl_stmt|,
name|s2
decl_stmt|;
if|if
condition|(
name|NEED_SAVE_FD
argument_list|(
literal|0
argument_list|,
name|OLDSTD
argument_list|)
condition|)
block|{
name|st
operator|->
name|OLDSTD
operator|=
name|OLDSTD
expr_stmt|;
name|OLDSTD
operator|=
name|dmove
argument_list|(
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close_on_exec
argument_list|(
name|OLDSTD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NEED_SAVE_FD
argument_list|(
literal|1
argument_list|,
name|SHOUT
argument_list|)
condition|)
block|{
name|st
operator|->
name|SHOUT
operator|=
name|SHOUT
expr_stmt|;
name|SHOUT
operator|=
name|dmove
argument_list|(
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close_on_exec
argument_list|(
name|SHOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NEED_SAVE_FD
argument_list|(
literal|2
argument_list|,
name|SHDIAG
argument_list|)
condition|)
block|{
name|st
operator|->
name|SHDIAG
operator|=
name|SHDIAG
expr_stmt|;
name|SHDIAG
operator|=
name|dmove
argument_list|(
literal|2
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close_on_exec
argument_list|(
name|SHDIAG
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|donefds
argument_list|()
expr_stmt|;
block|}
name|st
operator|->
name|intty
operator|=
name|intty
expr_stmt|;
name|st
operator|->
name|whyles
operator|=
name|whyles
expr_stmt|;
name|st
operator|->
name|gointr
operator|=
name|gointr
expr_stmt|;
name|st
operator|->
name|arginp
operator|=
name|arginp
expr_stmt|;
name|st
operator|->
name|evalp
operator|=
name|evalp
expr_stmt|;
name|st
operator|->
name|evalvec
operator|=
name|evalvec
expr_stmt|;
name|st
operator|->
name|alvecp
operator|=
name|alvecp
expr_stmt|;
name|st
operator|->
name|alvec
operator|=
name|alvec
expr_stmt|;
name|st
operator|->
name|onelflg
operator|=
name|onelflg
expr_stmt|;
name|st
operator|->
name|enterhist
operator|=
name|enterhist
expr_stmt|;
if|if
condition|(
name|hflg
condition|)
name|st
operator|->
name|HIST
operator|=
name|HIST
expr_stmt|;
else|else
name|st
operator|->
name|HIST
operator|=
literal|'\0'
expr_stmt|;
name|st
operator|->
name|cantell
operator|=
name|cantell
expr_stmt|;
name|cpybin
argument_list|(
name|st
operator|->
name|B
argument_list|,
name|B
argument_list|)
expr_stmt|;
comment|/*      * we can now pass arguments to source.       * For compatibility we do that only if arguments were really      * passed, otherwise we keep the old, global $argv like before.      */
if|if
condition|(
name|av
operator|!=
name|NULL
operator|&&
operator|*
name|av
operator|!=
name|NULL
condition|)
block|{
name|struct
name|varent
modifier|*
name|vp
decl_stmt|;
if|if
condition|(
operator|(
name|vp
operator|=
name|adrof
argument_list|(
name|STRargv
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|vp
operator|->
name|vec
operator|!=
name|NULL
condition|)
name|st
operator|->
name|argv
operator|=
name|saveblk
argument_list|(
name|vp
operator|->
name|vec
argument_list|)
expr_stmt|;
else|else
name|st
operator|->
name|argv
operator|=
name|NULL
expr_stmt|;
name|setq
argument_list|(
name|STRargv
argument_list|,
name|saveblk
argument_list|(
name|av
argument_list|)
argument_list|,
operator|&
name|shvhed
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
block|}
else|else
name|st
operator|->
name|argv
operator|=
name|NULL
expr_stmt|;
name|st
operator|->
name|av
operator|=
name|av
expr_stmt|;
name|SHIN
operator|=
name|unit
expr_stmt|;
comment|/* Do this first */
comment|/* Establish new input arena */
block|{
name|fbuf
operator|=
name|NULL
expr_stmt|;
name|fseekp
operator|=
name|feobp
operator|=
name|fblocks
operator|=
literal|0
expr_stmt|;
name|settell
argument_list|()
expr_stmt|;
block|}
name|arginp
operator|=
literal|0
expr_stmt|;
name|onelflg
operator|=
literal|0
expr_stmt|;
name|intty
operator|=
name|isatty
argument_list|(
name|SHIN
argument_list|)
expr_stmt|;
name|whyles
operator|=
literal|0
expr_stmt|;
name|gointr
operator|=
literal|0
expr_stmt|;
name|evalvec
operator|=
literal|0
expr_stmt|;
name|evalp
operator|=
literal|0
expr_stmt|;
name|alvec
operator|=
name|al
expr_stmt|;
name|alvecp
operator|=
literal|0
expr_stmt|;
name|enterhist
operator|=
name|hflg
expr_stmt|;
if|if
condition|(
name|enterhist
condition|)
name|HIST
operator|=
literal|'\0'
expr_stmt|;
name|insource
operator|=
literal|1
expr_stmt|;
block|}
comment|/*  * Restore the shell to a saved state  */
specifier|static
name|void
name|st_restore
parameter_list|(
name|void
modifier|*
name|xst
parameter_list|)
block|{
name|struct
name|saved_state
modifier|*
name|st
decl_stmt|;
name|st
operator|=
name|xst
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|SHIN
operator|==
operator|-
literal|1
condition|)
return|return;
comment|/* Reset input arena */
block|{
name|int
name|i
decl_stmt|;
name|Char
modifier|*
modifier|*
name|nfbuf
init|=
name|fbuf
decl_stmt|;
name|int
name|nfblocks
init|=
name|fblocks
decl_stmt|;
name|fblocks
operator|=
literal|0
expr_stmt|;
name|fbuf
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfblocks
condition|;
name|i
operator|++
control|)
name|xfree
argument_list|(
name|nfbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|nfbuf
argument_list|)
expr_stmt|;
block|}
name|cpybin
argument_list|(
name|B
argument_list|,
name|st
operator|->
name|B
argument_list|)
expr_stmt|;
name|xclose
argument_list|(
name|SHIN
argument_list|)
expr_stmt|;
name|insource
operator|=
name|st
operator|->
name|insource
expr_stmt|;
name|SHIN
operator|=
name|st
operator|->
name|SHIN
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|OLDSTD
operator|!=
operator|-
literal|1
condition|)
name|xclose
argument_list|(
name|OLDSTD
argument_list|)
operator|,
name|OLDSTD
operator|=
name|st
operator|->
name|OLDSTD
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|SHOUT
operator|!=
operator|-
literal|1
condition|)
name|xclose
argument_list|(
name|SHOUT
argument_list|)
operator|,
name|SHOUT
operator|=
name|st
operator|->
name|SHOUT
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|SHDIAG
operator|!=
operator|-
literal|1
condition|)
name|xclose
argument_list|(
name|SHDIAG
argument_list|)
operator|,
name|SHDIAG
operator|=
name|st
operator|->
name|SHDIAG
expr_stmt|;
name|arginp
operator|=
name|st
operator|->
name|arginp
expr_stmt|;
name|onelflg
operator|=
name|st
operator|->
name|onelflg
expr_stmt|;
name|evalp
operator|=
name|st
operator|->
name|evalp
expr_stmt|;
name|evalvec
operator|=
name|st
operator|->
name|evalvec
expr_stmt|;
name|alvecp
operator|=
name|st
operator|->
name|alvecp
expr_stmt|;
name|alvec
operator|=
name|st
operator|->
name|alvec
expr_stmt|;
name|intty
operator|=
name|st
operator|->
name|intty
expr_stmt|;
name|whyles
operator|=
name|st
operator|->
name|whyles
expr_stmt|;
name|gointr
operator|=
name|st
operator|->
name|gointr
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|HIST
operator|!=
literal|'\0'
condition|)
name|HIST
operator|=
name|st
operator|->
name|HIST
expr_stmt|;
name|enterhist
operator|=
name|st
operator|->
name|enterhist
expr_stmt|;
name|cantell
operator|=
name|st
operator|->
name|cantell
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|argv
operator|!=
name|NULL
condition|)
name|setq
argument_list|(
name|STRargv
argument_list|,
name|st
operator|->
name|argv
argument_list|,
operator|&
name|shvhed
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|st
operator|->
name|av
operator|!=
name|NULL
operator|&&
operator|*
name|st
operator|->
name|av
operator|!=
name|NULL
operator|&&
name|adrof
argument_list|(
name|STRargv
argument_list|)
operator|!=
name|NULL
condition|)
name|unsetv
argument_list|(
name|STRargv
argument_list|)
expr_stmt|;
block|}
comment|/*  * Source to a unit.  If onlyown it must be our file or our group or  * we don't chance it.	This occurs on ".cshrc"s and the like.  */
specifier|static
name|void
name|srcunit
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|onlyown
parameter_list|,
name|int
name|hflg
parameter_list|,
name|Char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|struct
name|saved_state
name|st
decl_stmt|;
name|st
operator|.
name|SHIN
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* st_restore checks this */
if|if
condition|(
name|unit
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|onlyown
condition|)
block|{
name|struct
name|stat
name|stb
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|unit
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|xclose
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Does nothing before st_save() because st.SHIN == -1 */
name|cleanup_push
argument_list|(
operator|&
name|st
argument_list|,
name|st_restore
argument_list|)
expr_stmt|;
if|if
condition|(
name|setintr
condition|)
block|{
name|pintr_disabled
operator|++
expr_stmt|;
name|cleanup_push
argument_list|(
operator|&
name|pintr_disabled
argument_list|,
name|disabled_cleanup
argument_list|)
expr_stmt|;
block|}
comment|/* Save the current state and move us to a new state */
name|st_save
argument_list|(
operator|&
name|st
argument_list|,
name|unit
argument_list|,
name|hflg
argument_list|,
name|NULL
argument_list|,
name|av
argument_list|)
expr_stmt|;
comment|/*      * Now if we are allowing commands to be interrupted, we let ourselves be      * interrupted.      */
if|if
condition|(
name|setintr
condition|)
block|{
name|cleanup_until
argument_list|(
operator|&
name|pintr_disabled
argument_list|)
expr_stmt|;
name|pintr_disabled
operator|++
expr_stmt|;
name|cleanup_push
argument_list|(
operator|&
name|pintr_disabled
argument_list|,
name|disabled_cleanup
argument_list|)
expr_stmt|;
block|}
name|process
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 0 -> blow away on errors */
comment|/* Restore the old state */
name|cleanup_until
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
block|}
comment|/*ARGSUSED*/
name|void
name|goodbye
parameter_list|(
name|Char
modifier|*
modifier|*
name|v
parameter_list|,
name|struct
name|command
modifier|*
name|c
parameter_list|)
block|{
name|USE
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|USE
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|record
argument_list|()
expr_stmt|;
if|if
condition|(
name|loginsh
condition|)
block|{
name|size_t
name|omark
decl_stmt|;
name|sigset_t
name|set
decl_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGQUIT
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|set
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|set
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|phup_disabled
operator|=
literal|1
expr_stmt|;
name|setintr
operator|=
literal|0
expr_stmt|;
comment|/* No interrupts after "logout" */
comment|/* Trap errors inside .logout */
name|omark
operator|=
name|cleanup_push_mark
argument_list|()
expr_stmt|;
if|if
condition|(
name|setexit
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|adrof
argument_list|(
name|STRlogout
argument_list|)
operator|)
condition|)
name|setcopy
argument_list|(
name|STRlogout
argument_list|,
name|STRnormal
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_PATH_DOTLOGOUT
operator|(
name|void
operator|)
name|srcfile
argument_list|(
name|_PATH_DOTLOGOUT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|adrof
argument_list|(
name|STRhome
argument_list|)
condition|)
operator|(
name|void
operator|)
name|srccat
argument_list|(
name|varval
argument_list|(
name|STRhome
argument_list|)
argument_list|,
name|STRsldtlogout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TESLA
name|do_logout
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* TESLA */
block|}
name|cleanup_pop_mark
argument_list|(
name|omark
argument_list|)
expr_stmt|;
block|}
name|exitstat
argument_list|()
expr_stmt|;
block|}
name|void
name|exitstat
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PROF
name|monitor
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * Note that if STATUS is corrupted (i.e. getn bombs) then error will exit      * directly because we poke child here. Otherwise we might continue      * unwarrantedly (sic).      */
name|child
operator|=
literal|1
expr_stmt|;
name|xexit
argument_list|(
name|getn
argument_list|(
name|varval
argument_list|(
name|STRstatus
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*  * in the event of a HUP we want to save the history  */
name|void
name|phup
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|loginsh
condition|)
block|{
name|setcopy
argument_list|(
name|STRlogout
argument_list|,
name|STRhangup
argument_list|,
name|VAR_READWRITE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_PATH_DOTLOGOUT
operator|(
name|void
operator|)
name|srcfile
argument_list|(
name|_PATH_DOTLOGOUT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|adrof
argument_list|(
name|STRhome
argument_list|)
condition|)
operator|(
name|void
operator|)
name|srccat
argument_list|(
name|varval
argument_list|(
name|STRhome
argument_list|)
argument_list|,
name|STRsldtlogout
argument_list|)
expr_stmt|;
block|}
name|record
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|POSIXJOBS
comment|/*      * We kill the last foreground process group. It then becomes      * responsible to propagate the SIGHUP to its progeny.       */
block|{
name|struct
name|process
modifier|*
name|pp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
for|for
control|(
name|pp
operator|=
name|proclist
operator|.
name|p_next
init|;
name|pp
condition|;
name|pp
operator|=
name|pp
operator|->
name|p_next
control|)
block|{
name|np
operator|=
name|pp
expr_stmt|;
comment|/*  	     * Find if this job is in the foreground. It could be that 	     * the process leader has exited and the foreground flag 	     * is cleared for it. 	     */
do|do
comment|/* 		 * If a process is in the foreground we try to kill 		 * it's process group. If we succeed, then the  		 * whole job is gone. Otherwise we keep going... 		 * But avoid sending HUP to the shell again. 		 */
if|if
condition|(
operator|(
operator|(
name|np
operator|->
name|p_flags
operator|&
name|PFOREGND
operator|)
operator|!=
literal|0
operator|)
operator|&&
name|np
operator|->
name|p_jobid
operator|!=
name|shpgrp
condition|)
block|{
name|np
operator|->
name|p_flags
operator|&=
operator|~
name|PHUP
expr_stmt|;
if|if
condition|(
name|killpg
argument_list|(
name|np
operator|->
name|p_jobid
argument_list|,
name|SIGHUP
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* In case the job was suspended... */
ifdef|#
directive|ifdef
name|SIGCONT
operator|(
name|void
operator|)
name|killpg
argument_list|(
name|np
operator|->
name|p_jobid
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
do|while
condition|(
operator|(
name|np
operator|=
name|np
operator|->
name|p_friends
operator|)
operator|!=
name|pp
condition|)
do|;
block|}
block|}
endif|#
directive|endif
comment|/* POSIXJOBS */
name|xexit
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
block|}
specifier|static
name|Char
modifier|*
name|jobargv
index|[
literal|2
index|]
init|=
block|{
name|STRjobs
block|,
literal|0
block|}
decl_stmt|;
comment|/*  * Catch an interrupt, e.g. during lexical input.  * If we are an interactive shell, we reset the interrupt catch  * immediately.  In any case we drain the shell output,  * and finally go through the normal error mechanism, which  * gets a chance to make the shell go away.  */
name|int
name|just_signaled
decl_stmt|;
comment|/* bugfix by Michael Bloom (mg@ttidca.TTI.COM) */
name|void
name|pintr
parameter_list|(
name|void
parameter_list|)
block|{
name|just_signaled
operator|=
literal|1
expr_stmt|;
name|pintr1
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|void
name|pintr1
parameter_list|(
name|int
name|wantnl
parameter_list|)
block|{
if|if
condition|(
name|setintr
condition|)
block|{
if|if
condition|(
name|pjobs
condition|)
block|{
name|pjobs
operator|=
literal|0
expr_stmt|;
name|xputchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|dojobs
argument_list|(
name|jobargv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|stderror
argument_list|(
name|ERR_NAME
operator||
name|ERR_INTR
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* MH - handle interrupted completions specially */
block|{
if|if
condition|(
name|InsideCompletion
condition|)
name|stderror
argument_list|(
name|ERR_SILENT
argument_list|)
expr_stmt|;
block|}
comment|/* JV - Make sure we shut off inputl */
block|{
operator|(
name|void
operator|)
name|Cookedmode
argument_list|()
expr_stmt|;
name|GettingInput
operator|=
literal|0
expr_stmt|;
block|}
name|drainoline
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_GETPWENT
operator|(
name|void
operator|)
name|endpwent
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/*      * If we have an active "onintr" then we search for the label. Note that if      * one does "onintr -" then we shan't be interruptible so we needn't worry      * about that here.      */
if|if
condition|(
name|gointr
condition|)
block|{
name|gotolab
argument_list|(
name|gointr
argument_list|)
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intty
operator|&&
name|wantnl
condition|)
block|{
if|if
condition|(
name|editing
condition|)
block|{
comment|/*  	     * If we are editing a multi-line input command, and move to 	     * the beginning of the line, we don't want to trash it when 	     * we hit ^C 	     */
name|PastBottom
argument_list|()
expr_stmt|;
name|ClearLines
argument_list|()
expr_stmt|;
name|ClearDisp
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* xputchar('\n'); */
comment|/* Some like this, others don't */
operator|(
name|void
operator|)
name|putraw
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putraw
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
name|stderror
argument_list|(
name|ERR_SILENT
argument_list|)
expr_stmt|;
block|}
comment|/*  * Process is the main driving routine for the shell.  * It runs all command processing, except for those within { ... }  * in expressions (which is run by a routine evalav in sh.exp.c which  * is a stripped down process), and `...` evaluation which is run  * also by a subset of this code in sh.glob.c in the routine backeval.  *  * The code here is a little strange because part of it is interruptible  * and hence freeing of structures appears to occur when none is necessary  * if this is ignored.  *  * Note that if catch is not set then we will unwind on any error.  * If an end-of-file occurs, we return.  */
name|void
name|process
parameter_list|(
name|int
name|catch
parameter_list|)
block|{
name|jmp_buf_t
name|osetexit
decl_stmt|;
comment|/* PWP: This might get nuked my longjmp so don't make it a register var */
name|size_t
name|omark
decl_stmt|;
name|getexit
argument_list|(
name|osetexit
argument_list|)
expr_stmt|;
name|omark
operator|=
name|cleanup_push_mark
argument_list|()
expr_stmt|;
name|exitset
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|command
modifier|*
name|t
decl_stmt|;
name|int
name|hadhist
decl_stmt|,
name|old_pintr_disabled
decl_stmt|;
operator|(
name|void
operator|)
name|setexit
argument_list|()
expr_stmt|;
name|pendjob
argument_list|()
expr_stmt|;
name|justpr
operator|=
name|enterhist
expr_stmt|;
comment|/* execute if not entering history */
if|if
condition|(
name|haderr
condition|)
block|{
if|if
condition|(
operator|!
name|catch
condition|)
block|{
comment|/* unwind */
name|doneinp
operator|=
literal|0
expr_stmt|;
name|cleanup_pop_mark
argument_list|(
name|omark
argument_list|)
expr_stmt|;
name|resexit
argument_list|(
name|osetexit
argument_list|)
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
block|}
name|haderr
operator|=
literal|0
expr_stmt|;
comment|/* 	     * Every error is eventually caught here or the shell dies.  It is 	     * at this point that we clean up any left-over open files, by 	     * closing all but a fixed number of pre-defined files.  Thus 	     * routines don't have to worry about leaving files open due to 	     * deeper errors... they will get closed here. 	     */
name|closem
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|doneinp
condition|)
block|{
name|doneinp
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|chkstop
condition|)
name|chkstop
operator|--
expr_stmt|;
if|if
condition|(
name|neednote
condition|)
name|pnote
argument_list|()
expr_stmt|;
if|if
condition|(
name|intty
operator|&&
name|prompt
operator|&&
name|evalvec
operator|==
literal|0
condition|)
block|{
name|just_signaled
operator|=
literal|0
expr_stmt|;
name|mailchk
argument_list|()
expr_stmt|;
comment|/* 	     * Watch for logins/logouts. Next is scheduled commands stored 	     * previously using "sched." Then execute periodic commands. 	     * Following that, the prompt precmd is run. 	     */
ifndef|#
directive|ifndef
name|HAVENOUTMP
name|watch_login
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !HAVENOUTMP */
name|sched_run
argument_list|()
expr_stmt|;
name|period_cmd
argument_list|()
expr_stmt|;
name|precmd
argument_list|()
expr_stmt|;
comment|/* 	     * If we are at the end of the input buffer then we are going to 	     * read fresh stuff. Otherwise, we are rereading input and don't 	     * need or want to prompt. 	     */
if|if
condition|(
name|fseekp
operator|==
name|feobp
operator|&&
name|aret
operator|==
name|TCSH_F_SEEK
condition|)
name|printprompt
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|setalarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|seterr
condition|)
block|{
name|xfree
argument_list|(
name|seterr
argument_list|)
expr_stmt|;
name|seterr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Interruptible during interactive reads 	 */
if|if
condition|(
name|setintr
condition|)
name|pintr_push_enable
argument_list|(
operator|&
name|old_pintr_disabled
argument_list|)
expr_stmt|;
name|hadhist
operator|=
name|lex
argument_list|(
operator|&
name|paraml
argument_list|)
expr_stmt|;
if|if
condition|(
name|setintr
condition|)
name|cleanup_until
argument_list|(
operator|&
name|old_pintr_disabled
argument_list|)
expr_stmt|;
name|cleanup_push
argument_list|(
operator|&
name|paraml
argument_list|,
name|lex_cleanup
argument_list|)
expr_stmt|;
comment|/* 	 * Echo not only on VERBOSE, but also with history expansion. If there 	 * is a lexical error then we forego history echo. 	 */
if|if
condition|(
operator|(
name|hadhist
operator|&&
operator|!
name|seterr
operator|&&
name|intty
operator|&&
operator|!
name|tellwhat
operator|&&
operator|!
name|Expand
operator|&&
operator|!
name|whyles
operator|)
operator|||
name|adrof
argument_list|(
name|STRverbose
argument_list|)
condition|)
block|{
name|int
name|odidfds
init|=
name|didfds
decl_stmt|;
name|haderr
operator|=
literal|1
expr_stmt|;
name|didfds
operator|=
literal|0
expr_stmt|;
name|prlex
argument_list|(
operator|&
name|paraml
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|haderr
operator|=
literal|0
expr_stmt|;
name|didfds
operator|=
name|odidfds
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Autologout OFF */
name|alrmcatch_disabled
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Save input text on the history list if reading in old history, or it 	 * is from the terminal at the top level and not in a loop. 	 *  	 * PWP: entry of items in the history list while in a while loop is done 	 * elsewhere... 	 */
if|if
condition|(
name|enterhist
operator|||
operator|(
name|catch
operator|&&
name|intty
operator|&&
operator|!
name|whyles
operator|&&
operator|!
name|tellwhat
operator|&&
operator|!
name|arun
operator|)
condition|)
name|savehist
argument_list|(
operator|&
name|paraml
argument_list|,
name|enterhist
operator|>
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|Expand
operator|&&
name|seterr
condition|)
name|Expand
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Print lexical error messages, except when sourcing history lists. 	 */
if|if
condition|(
operator|!
name|enterhist
operator|&&
name|seterr
condition|)
name|stderror
argument_list|(
name|ERR_OLD
argument_list|)
expr_stmt|;
comment|/* 	 * If had a history command :p modifier then this is as far as we 	 * should go 	 */
if|if
condition|(
name|justpr
condition|)
goto|goto
name|cmd_done
goto|;
comment|/* 	 * If had a tellwhat from twenex() then do 	 */
if|if
condition|(
name|tellwhat
condition|)
block|{
operator|(
name|void
operator|)
name|tellmewhat
argument_list|(
operator|&
name|paraml
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|cmd_done
goto|;
block|}
name|alias
argument_list|(
operator|&
name|paraml
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSDJOBS
comment|/* 	 * If we are interactive, try to continue jobs that we have stopped 	 */
if|if
condition|(
name|prompt
condition|)
name|continue_jobs
argument_list|(
operator|&
name|paraml
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSDJOBS */
comment|/* 	 * Check to see if the user typed "rm * .o" or something 	 */
if|if
condition|(
name|prompt
condition|)
name|rmstar
argument_list|(
operator|&
name|paraml
argument_list|)
expr_stmt|;
comment|/* 	 * Parse the words of the input into a parse tree. 	 */
name|t
operator|=
name|syntax
argument_list|(
name|paraml
operator|.
name|next
argument_list|,
operator|&
name|paraml
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cleanup_push
argument_list|(
name|t
argument_list|,
name|syntax_cleanup
argument_list|)
expr_stmt|;
if|if
condition|(
name|seterr
condition|)
name|stderror
argument_list|(
name|ERR_OLD
argument_list|)
expr_stmt|;
name|postcmd
argument_list|()
expr_stmt|;
comment|/* 	 * Execute the parse tree From: Michael Schroeder 	 *<mlschroe@immd4.informatik.uni-erlangen.de> was execute(t, tpgrp); 	 */
name|execute
argument_list|(
name|t
argument_list|,
operator|(
name|tpgrp
operator|>
literal|0
condition|?
name|tpgrp
else|:
operator|-
literal|1
operator|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * Made it! 	 */
ifdef|#
directive|ifdef
name|SIG_WINDOW
if|if
condition|(
name|windowchg
operator|||
operator|(
name|catch
operator|&&
name|intty
operator|&&
operator|!
name|whyles
operator|&&
operator|!
name|tellwhat
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|check_window_size
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* for window systems */
block|}
endif|#
directive|endif
comment|/* SIG_WINDOW */
name|setcopy
argument_list|(
name|STR_
argument_list|,
name|InputBuf
argument_list|,
name|VAR_READWRITE
operator||
name|VAR_NOGLOB
argument_list|)
expr_stmt|;
name|cmd_done
label|:
name|cleanup_until
argument_list|(
operator|&
name|paraml
argument_list|)
expr_stmt|;
block|}
name|exitset
operator|--
expr_stmt|;
name|cleanup_pop_mark
argument_list|(
name|omark
argument_list|)
expr_stmt|;
name|resexit
argument_list|(
name|osetexit
argument_list|)
expr_stmt|;
block|}
comment|/*ARGSUSED*/
name|void
name|dosource
parameter_list|(
name|Char
modifier|*
modifier|*
name|t
parameter_list|,
name|struct
name|command
modifier|*
name|c
parameter_list|)
block|{
name|Char
modifier|*
name|f
decl_stmt|;
name|int
name|hflg
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|USE
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|t
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|&&
name|eq
argument_list|(
operator|*
name|t
argument_list|,
name|STRmh
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|t
operator|==
name|NULL
condition|)
name|stderror
argument_list|(
name|ERR_NAME
operator||
name|ERR_HFLAG
argument_list|)
expr_stmt|;
name|hflg
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|t
operator|&&
name|eq
argument_list|(
operator|*
name|t
argument_list|,
name|STRmm
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|t
operator|==
name|NULL
condition|)
name|stderror
argument_list|(
name|ERR_NAME
operator||
name|ERR_MFLAG
argument_list|)
expr_stmt|;
name|hflg
operator|=
literal|2
expr_stmt|;
block|}
name|f
operator|=
name|globone
argument_list|(
operator|*
name|t
operator|++
argument_list|,
name|G_ERROR
argument_list|)
expr_stmt|;
name|file
operator|=
name|strsave
argument_list|(
name|short2str
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup_push
argument_list|(
name|file
argument_list|,
name|xfree
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|t
operator|=
name|glob_all_or_error
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|srcfile
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
name|hflg
argument_list|,
name|t
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|hflg
operator|)
operator|&&
operator|(
operator|!
name|bequiet
operator|)
condition|)
name|stderror
argument_list|(
name|ERR_SYSTEM
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup_until
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
comment|/*  * Check for mail.  * If we are a login shell, then we don't want to tell  * about any mail file unless its been modified  * after the time we started.  * This prevents us from telling the user things he already  * knows, since the login program insists on saying  * "You have mail."  */
comment|/*  * The AMS version.  * This version checks if the file is a directory, and if so,  * tells you the number of files in it, otherwise do the old thang.  * The magic "+1" in the time calculation is to compensate for  * an AFS bug where directory mtimes are set to 1 second in  * the future.  */
specifier|static
name|void
name|mailchk
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|varent
modifier|*
name|v
decl_stmt|;
name|Char
modifier|*
modifier|*
name|vp
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|int
name|intvl
decl_stmt|,
name|cnt
decl_stmt|;
name|struct
name|stat
name|stb
decl_stmt|;
name|int
name|new
decl_stmt|;
name|v
operator|=
name|adrof
argument_list|(
name|STRmail
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
operator|||
name|v
operator|->
name|vec
operator|==
name|NULL
condition|)
return|return;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|vp
operator|=
name|v
operator|->
name|vec
expr_stmt|;
name|cnt
operator|=
name|blklen
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|intvl
operator|=
operator|(
name|cnt
operator|&&
name|number
argument_list|(
operator|*
name|vp
argument_list|)
operator|)
condition|?
operator|(
operator|--
name|cnt
operator|,
name|getn
argument_list|(
operator|*
name|vp
operator|++
argument_list|)
operator|)
else|:
name|MAILINTVL
expr_stmt|;
if|if
condition|(
name|intvl
operator|<
literal|1
condition|)
name|intvl
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|chktim
operator|+
name|intvl
operator|>
name|t
condition|)
return|return;
for|for
control|(
init|;
operator|*
name|vp
condition|;
name|vp
operator|++
control|)
block|{
name|char
modifier|*
name|filename
init|=
name|short2str
argument_list|(
operator|*
name|vp
argument_list|)
decl_stmt|;
name|char
modifier|*
name|mboxdir
init|=
name|filename
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
if|#
directive|if
name|defined
argument_list|(
name|BSDTIMES
argument_list|)
operator|||
name|defined
argument_list|(
name|_SEQUENT_
argument_list|)
name|new
operator|=
name|stb
operator|.
name|st_mtime
operator|>
name|time0
operator|.
name|tv_sec
expr_stmt|;
else|#
directive|else
name|new
operator|=
name|stb
operator|.
name|st_mtime
operator|>
name|seconds0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|S_ISDIR
argument_list|(
name|stb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|DIR
modifier|*
name|mailbox
decl_stmt|;
name|int
name|mailcount
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|tempfilename
decl_stmt|;
name|struct
name|stat
name|stc
decl_stmt|;
name|tempfilename
operator|=
name|xasprintf
argument_list|(
literal|"%s/new"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|tempfilename
argument_list|,
operator|&
name|stc
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|S_ISDIR
argument_list|(
name|stc
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* 		 * "filename/new" exists and is a directory; you are 		 * using Qmail. 		 */
name|stb
operator|=
name|stc
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|BSDTIMES
argument_list|)
operator|||
name|defined
argument_list|(
name|_SEQUENT_
argument_list|)
name|new
operator|=
name|stb
operator|.
name|st_mtime
operator|>
name|time0
operator|.
name|tv_sec
expr_stmt|;
else|#
directive|else
name|new
operator|=
name|stb
operator|.
name|st_mtime
operator|>
name|seconds0
expr_stmt|;
endif|#
directive|endif
name|mboxdir
operator|=
name|tempfilename
expr_stmt|;
block|}
if|if
condition|(
name|stb
operator|.
name|st_mtime
operator|<=
name|chktim
operator|+
literal|1
operator|||
operator|(
name|loginsh
operator|&&
operator|!
name|new
operator|)
condition|)
block|{
name|xfree
argument_list|(
name|tempfilename
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mailbox
operator|=
name|opendir
argument_list|(
name|mboxdir
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|tempfilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|mailbox
operator|==
name|NULL
condition|)
continue|continue;
comment|/* skip . and .. */
if|if
condition|(
operator|!
name|readdir
argument_list|(
name|mailbox
argument_list|)
operator|||
operator|!
name|readdir
argument_list|(
name|mailbox
argument_list|)
condition|)
continue|continue;
while|while
condition|(
name|readdir
argument_list|(
name|mailbox
argument_list|)
condition|)
name|mailcount
operator|++
expr_stmt|;
if|if
condition|(
name|mailcount
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|cnt
operator|==
literal|1
condition|)
name|xprintf
argument_list|(
name|CGETS
argument_list|(
literal|11
argument_list|,
literal|3
argument_list|,
literal|"You have %d mail messages.\n"
argument_list|)
argument_list|,
name|mailcount
argument_list|)
expr_stmt|;
else|else
name|xprintf
argument_list|(
name|CGETS
argument_list|(
literal|11
argument_list|,
literal|4
argument_list|,
literal|"You have %d mail messages in %s.\n"
argument_list|)
argument_list|,
name|mailcount
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|type
decl_stmt|;
if|if
condition|(
name|stb
operator|.
name|st_size
operator|==
literal|0
operator|||
name|stb
operator|.
name|st_atime
operator|>
name|stb
operator|.
name|st_mtime
operator|||
operator|(
name|stb
operator|.
name|st_atime
operator|<=
name|chktim
operator|&&
name|stb
operator|.
name|st_mtime
operator|<=
name|chktim
operator|)
operator|||
operator|(
name|loginsh
operator|&&
operator|!
name|new
operator|)
condition|)
continue|continue;
name|type
operator|=
name|strsave
argument_list|(
name|new
condition|?
name|CGETS
argument_list|(
literal|11
argument_list|,
literal|6
argument_list|,
literal|"new "
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
name|cleanup_push
argument_list|(
name|type
argument_list|,
name|xfree
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|1
condition|)
name|xprintf
argument_list|(
name|CGETS
argument_list|(
literal|11
argument_list|,
literal|5
argument_list|,
literal|"You have %smail.\n"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|xprintf
argument_list|(
name|CGETS
argument_list|(
literal|11
argument_list|,
literal|7
argument_list|,
literal|"You have %smail in %s.\n"
argument_list|)
argument_list|,
name|type
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|cleanup_until
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
name|chktim
operator|=
name|t
expr_stmt|;
block|}
comment|/*  * Extract a home directory from the password file  * The argument points to a buffer where the name of the  * user whose home directory is sought is currently.  * We return home directory of the user, or NULL.  */
name|Char
modifier|*
name|gethdir
parameter_list|(
specifier|const
name|Char
modifier|*
name|home
parameter_list|)
block|{
name|Char
modifier|*
name|h
decl_stmt|;
comment|/*      * Is it us?      */
if|if
condition|(
operator|*
name|home
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|h
operator|=
name|varval
argument_list|(
name|STRhome
argument_list|)
operator|)
operator|!=
name|STRNULL
condition|)
return|return
name|Strsave
argument_list|(
name|h
argument_list|)
return|;
else|else
return|return
name|NULL
return|;
block|}
comment|/*      * Look in the cache      */
if|if
condition|(
operator|(
name|h
operator|=
name|gettilde
argument_list|(
name|home
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|Strsave
argument_list|(
name|h
argument_list|)
return|;
block|}
comment|/*  * Move the initial descriptors to their eventual  * resting places, closing all other units.  */
name|void
name|initdesc
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|NLS_BUGS
ifdef|#
directive|ifdef
name|NLS_CATALOGS
name|nlsclose
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* NLS_CATALOGS */
endif|#
directive|endif
comment|/* NLS_BUGS */
name|didfds
operator|=
literal|0
expr_stmt|;
comment|/* 0, 1, 2 aren't set up */
operator|(
name|void
operator|)
name|close_on_exec
argument_list|(
name|SHIN
operator|=
name|dcopy
argument_list|(
literal|0
argument_list|,
name|FSHIN
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close_on_exec
argument_list|(
name|SHOUT
operator|=
name|dcopy
argument_list|(
literal|1
argument_list|,
name|FSHOUT
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close_on_exec
argument_list|(
name|SHDIAG
operator|=
name|dcopy
argument_list|(
literal|2
argument_list|,
name|FSHDIAG
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close_on_exec
argument_list|(
name|OLDSTD
operator|=
name|dcopy
argument_list|(
name|SHIN
argument_list|,
name|FOLDSTD
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|CLOSE_ON_EXEC
name|didcch
operator|=
literal|0
expr_stmt|;
comment|/* Havent closed for child */
endif|#
directive|endif
comment|/* CLOSE_ON_EXEC */
name|isdiagatty
operator|=
name|isatty
argument_list|(
name|SHDIAG
argument_list|)
expr_stmt|;
name|isoutatty
operator|=
name|isatty
argument_list|(
name|SHOUT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NLS_BUGS
ifdef|#
directive|ifdef
name|NLS_CATALOGS
name|nlsinit
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* NLS_CATALOGS */
endif|#
directive|endif
comment|/* NLS_BUGS */
block|}
name|void
ifdef|#
directive|ifdef
name|PROF
name|done
parameter_list|(
name|int
name|i
parameter_list|)
else|#
directive|else
function|xexit
parameter_list|(
name|int
name|i
parameter_list|)
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|TESLA
if|if
condition|(
name|loginsh
operator|&&
name|do_logout
condition|)
block|{
comment|/* this is to send hangup signal to the develcon */
comment|/* we toggle DTR. clear dtr - sleep 1 - set dtr */
comment|/* ioctl will return ENOTTY for pty's but we ignore it 	 */
comment|/* exitstat will run after disconnect */
comment|/* we sleep for 2 seconds to let things happen in */
comment|/* .logout and rechist() */
ifdef|#
directive|ifdef
name|TIOCCDTR
operator|(
name|void
operator|)
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|FSHTTY
argument_list|,
name|TIOCCDTR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|FSHTTY
argument_list|,
name|TIOCSDTR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCCDTR */
block|}
endif|#
directive|endif
comment|/* TESLA */
block|{
name|struct
name|process
modifier|*
name|pp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
comment|/* Kill all processes marked for hup'ing */
for|for
control|(
name|pp
operator|=
name|proclist
operator|.
name|p_next
init|;
name|pp
condition|;
name|pp
operator|=
name|pp
operator|->
name|p_next
control|)
block|{
name|np
operator|=
name|pp
expr_stmt|;
do|do
if|if
condition|(
operator|(
name|np
operator|->
name|p_flags
operator|&
name|PHUP
operator|)
operator|&&
name|np
operator|->
name|p_jobid
operator|!=
name|shpgrp
condition|)
block|{
if|if
condition|(
name|killpg
argument_list|(
name|np
operator|->
name|p_jobid
argument_list|,
name|SIGHUP
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* In case the job was suspended... */
ifdef|#
directive|ifdef
name|SIGCONT
operator|(
name|void
operator|)
name|killpg
argument_list|(
name|np
operator|->
name|p_jobid
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
do|while
condition|(
operator|(
name|np
operator|=
name|np
operator|->
name|p_friends
operator|)
operator|!=
name|pp
condition|)
do|;
block|}
block|}
name|untty
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|NLS_CATALOGS
comment|/*      * We need to call catclose, because SVR4 leaves symlinks behind otherwise      * in the catalog directories. We cannot close on a vforked() child,      * because messages will stop working on the parent too.      */
if|if
condition|(
name|child
operator|==
literal|0
condition|)
name|nlsclose
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* NLS_CATALOGS */
ifdef|#
directive|ifdef
name|WINNT_NATIVE
name|nt_cleanup
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* WINNT_NATIVE */
name|_exit
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|_PATH_DEFPATH
specifier|static
name|Char
modifier|*
modifier|*
name|defaultpath
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|Char
modifier|*
modifier|*
name|blk
decl_stmt|,
modifier|*
modifier|*
name|blkp
decl_stmt|;
name|struct
name|stat
name|stb
decl_stmt|;
name|blkp
operator|=
name|blk
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Char
operator|*
argument_list|)
operator|*
literal|10
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NODOT
ifndef|#
directive|ifndef
name|DOTLAST
operator|*
name|blkp
operator|++
operator|=
name|Strsave
argument_list|(
name|STRdot
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
define|#
directive|define
name|DIRAPPEND
parameter_list|(
name|a
parameter_list|)
define|\
value|if (stat(ptr = a,&stb) == 0&& S_ISDIR(stb.st_mode)) \ 		*blkp++ = SAVE(ptr)
ifdef|#
directive|ifdef
name|_PATH_LOCAL
name|DIRAPPEND
argument_list|(
name|_PATH_LOCAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_PATH_USRUCB
name|DIRAPPEND
argument_list|(
name|_PATH_USRUCB
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_PATH_USRBSD
name|DIRAPPEND
argument_list|(
name|_PATH_USRBSD
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_PATH_BIN
name|DIRAPPEND
argument_list|(
name|_PATH_BIN
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_PATH_USRBIN
name|DIRAPPEND
argument_list|(
name|_PATH_USRBIN
argument_list|)
expr_stmt|;
endif|#
directive|endif
undef|#
directive|undef
name|DIRAPPEND
ifndef|#
directive|ifndef
name|NODOT
ifdef|#
directive|ifdef
name|DOTLAST
operator|*
name|blkp
operator|++
operator|=
name|Strsave
argument_list|(
name|STRdot
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
operator|*
name|blkp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|blk
operator|)
return|;
block|}
endif|#
directive|endif
specifier|static
name|void
name|record
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|fast
condition|)
block|{
name|recdirs
argument_list|(
name|NULL
argument_list|,
name|adrof
argument_list|(
name|STRsavedirs
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rechist
argument_list|(
name|NULL
argument_list|,
name|adrof
argument_list|(
name|STRsavehist
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

