begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * tclUnixNotify.c --  *  *	This file contains the implementation of the select-based  *	Unix-specific notifier, which is the lowest-level part of the  *	Tcl event loop.  This file works together with  *	../generic/tclNotify.c.  *  * Copyright (c) 1995-1997 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclUnixNotfy.c 1.44 97/11/05 13:02:20  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/*  * This structure is used to keep track of the notifier info for a   * a registered file.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|FileHandler
block|{
name|int
name|fd
decl_stmt|;
name|int
name|mask
decl_stmt|;
comment|/* Mask of desired events: TCL_READABLE, 				 * etc. */
name|int
name|readyMask
decl_stmt|;
comment|/* Mask of events that have been seen since the 				 * last time file handlers were invoked for 				 * this file. */
name|Tcl_FileProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to call, in the style of 				 * Tcl_CreateFileHandler. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Argument to pass to proc. */
name|struct
name|FileHandler
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next in list of all files we care about. */
block|}
name|FileHandler
typedef|;
end_typedef

begin_comment
comment|/*  * The following structure is what is added to the Tcl event queue when  * file handlers are ready to fire.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|FileHandlerEvent
block|{
name|Tcl_Event
name|header
decl_stmt|;
comment|/* Information that is standard for 				 * all events. */
name|int
name|fd
decl_stmt|;
comment|/* File descriptor that is ready.  Used 				 * to find the FileHandler structure for 				 * the file (can't point directly to the 				 * FileHandler structure because it could 				 * go away while the event is queued). */
block|}
name|FileHandlerEvent
typedef|;
end_typedef

begin_comment
comment|/*  * The following static structure contains the state information for the  * select based implementation of the Tcl notifier.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|FileHandler
modifier|*
name|firstFileHandlerPtr
decl_stmt|;
comment|/* Pointer to head of file handler list. */
name|fd_mask
name|checkMasks
index|[
literal|3
operator|*
name|MASK_SIZE
index|]
decl_stmt|;
comment|/* This array is used to build up the masks 				 * to be used in the next call to select. 				 * Bits are set in response to calls to 				 * Tcl_CreateFileHandler. */
name|fd_mask
name|readyMasks
index|[
literal|3
operator|*
name|MASK_SIZE
index|]
decl_stmt|;
comment|/* This array reflects the readable/writable 				 * conditions that were found to exist by the 				 * last call to select. */
name|int
name|numFdBits
decl_stmt|;
comment|/* Number of valid bits in checkMasks 				 * (one more than highest fd for which 				 * Tcl_WatchFile has been called). */
block|}
name|notifier
struct|;
end_struct

begin_comment
comment|/*  * The following static indicates whether this module has been initialized.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Static routines defined in this file.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|InitNotifier
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|NotifierExitHandler
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|FileHandlerEventProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Event
operator|*
name|evPtr
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InitNotifier --  *  *	Initializes the notifier state.  *  * Results:  *	None.  *  * Side effects:  *	Creates a new exit handler.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|InitNotifier
parameter_list|()
block|{
name|initialized
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|notifier
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|notifier
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_CreateExitHandler
argument_list|(
name|NotifierExitHandler
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * NotifierExitHandler --  *  *	This function is called to cleanup the notifier state before  *	Tcl is unloaded.  *  * Results:  *	None.  *  * Side effects:  *	Destroys the notifier window.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|NotifierExitHandler
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
block|{
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetTimer --  *  *	This procedure sets the current notifier timer value.  This  *	interface is not implemented in this notifier because we are  *	always running inside of Tcl_DoOneEvent.  *  * Results:  *	None.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_SetTimer
parameter_list|(
name|timePtr
parameter_list|)
name|Tcl_Time
modifier|*
name|timePtr
decl_stmt|;
comment|/* Timeout value, may be NULL. */
block|{
comment|/*      * The interval timer doesn't do anything in this implementation,      * because the only event loop is via Tcl_DoOneEvent, which passes      * timeout values to Tcl_WaitForEvent.      */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CreateFileHandler --  *  *	This procedure registers a file handler with the Xt notifier.  *  * Results:  *	None.  *  * Side effects:  *	Creates a new file handler structure and registers one or more  *	input procedures with Xt.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_CreateFileHandler
parameter_list|(
name|fd
parameter_list|,
name|mask
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|int
name|fd
decl_stmt|;
comment|/* Handle of stream to watch. */
name|int
name|mask
decl_stmt|;
comment|/* OR'ed combination of TCL_READABLE, 				 * TCL_WRITABLE, and TCL_EXCEPTION: 				 * indicates conditions under which 				 * proc should be called. */
name|Tcl_FileProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to call for each 				 * selected event. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary data to pass to proc. */
block|{
name|FileHandler
modifier|*
name|filePtr
decl_stmt|;
name|int
name|index
decl_stmt|,
name|bit
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|InitNotifier
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|filePtr
operator|=
name|notifier
operator|.
name|firstFileHandlerPtr
init|;
name|filePtr
operator|!=
name|NULL
condition|;
name|filePtr
operator|=
name|filePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|filePtr
operator|->
name|fd
operator|==
name|fd
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|filePtr
operator|==
name|NULL
condition|)
block|{
name|filePtr
operator|=
operator|(
name|FileHandler
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FileHandler
argument_list|)
argument_list|)
expr_stmt|;
comment|/* MLK */
name|filePtr
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|filePtr
operator|->
name|readyMask
operator|=
literal|0
expr_stmt|;
name|filePtr
operator|->
name|nextPtr
operator|=
name|notifier
operator|.
name|firstFileHandlerPtr
expr_stmt|;
name|notifier
operator|.
name|firstFileHandlerPtr
operator|=
name|filePtr
expr_stmt|;
block|}
name|filePtr
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|filePtr
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
name|filePtr
operator|->
name|mask
operator|=
name|mask
expr_stmt|;
comment|/*      * Update the check masks for this file.      */
name|index
operator|=
name|fd
operator|/
operator|(
name|NBBY
operator|*
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
operator|)
expr_stmt|;
name|bit
operator|=
literal|1
operator|<<
operator|(
name|fd
operator|%
operator|(
name|NBBY
operator|*
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|TCL_READABLE
condition|)
block|{
name|notifier
operator|.
name|checkMasks
index|[
name|index
index|]
operator||=
name|bit
expr_stmt|;
block|}
else|else
block|{
name|notifier
operator|.
name|checkMasks
index|[
name|index
index|]
operator|&=
operator|~
name|bit
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|TCL_WRITABLE
condition|)
block|{
operator|(
name|notifier
operator|.
name|checkMasks
operator|+
name|MASK_SIZE
operator|)
index|[
name|index
index|]
operator||=
name|bit
expr_stmt|;
block|}
else|else
block|{
operator|(
name|notifier
operator|.
name|checkMasks
operator|+
name|MASK_SIZE
operator|)
index|[
name|index
index|]
operator|&=
operator|~
name|bit
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|TCL_EXCEPTION
condition|)
block|{
operator|(
name|notifier
operator|.
name|checkMasks
operator|+
literal|2
operator|*
operator|(
name|MASK_SIZE
operator|)
operator|)
index|[
name|index
index|]
operator||=
name|bit
expr_stmt|;
block|}
else|else
block|{
operator|(
name|notifier
operator|.
name|checkMasks
operator|+
literal|2
operator|*
operator|(
name|MASK_SIZE
operator|)
operator|)
index|[
name|index
index|]
operator|&=
operator|~
name|bit
expr_stmt|;
block|}
if|if
condition|(
name|notifier
operator|.
name|numFdBits
operator|<=
name|fd
condition|)
block|{
name|notifier
operator|.
name|numFdBits
operator|=
name|fd
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DeleteFileHandler --  *  *	Cancel a previously-arranged callback arrangement for  *	a file.  *  * Results:  *	None.  *  * Side effects:  *	If a callback was previously registered on file, remove it.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DeleteFileHandler
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
comment|/* Stream id for which to remove callback procedure. */
block|{
name|FileHandler
modifier|*
name|filePtr
decl_stmt|,
modifier|*
name|prevPtr
decl_stmt|;
name|int
name|index
decl_stmt|,
name|bit
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|InitNotifier
argument_list|()
expr_stmt|;
block|}
comment|/*      * Find the entry for the given file (and return if there      * isn't one).      */
for|for
control|(
name|prevPtr
operator|=
name|NULL
operator|,
name|filePtr
operator|=
name|notifier
operator|.
name|firstFileHandlerPtr
init|;
condition|;
name|prevPtr
operator|=
name|filePtr
operator|,
name|filePtr
operator|=
name|filePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|filePtr
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|filePtr
operator|->
name|fd
operator|==
name|fd
condition|)
block|{
break|break;
block|}
block|}
comment|/*      * Update the check masks for this file.      */
name|index
operator|=
name|fd
operator|/
operator|(
name|NBBY
operator|*
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
operator|)
expr_stmt|;
name|bit
operator|=
literal|1
operator|<<
operator|(
name|fd
operator|%
operator|(
name|NBBY
operator|*
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|filePtr
operator|->
name|mask
operator|&
name|TCL_READABLE
condition|)
block|{
name|notifier
operator|.
name|checkMasks
index|[
name|index
index|]
operator|&=
operator|~
name|bit
expr_stmt|;
block|}
if|if
condition|(
name|filePtr
operator|->
name|mask
operator|&
name|TCL_WRITABLE
condition|)
block|{
operator|(
name|notifier
operator|.
name|checkMasks
operator|+
name|MASK_SIZE
operator|)
index|[
name|index
index|]
operator|&=
operator|~
name|bit
expr_stmt|;
block|}
if|if
condition|(
name|filePtr
operator|->
name|mask
operator|&
name|TCL_EXCEPTION
condition|)
block|{
operator|(
name|notifier
operator|.
name|checkMasks
operator|+
literal|2
operator|*
operator|(
name|MASK_SIZE
operator|)
operator|)
index|[
name|index
index|]
operator|&=
operator|~
name|bit
expr_stmt|;
block|}
comment|/*      * Find current max fd.      */
if|if
condition|(
name|fd
operator|+
literal|1
operator|==
name|notifier
operator|.
name|numFdBits
condition|)
block|{
for|for
control|(
name|notifier
operator|.
name|numFdBits
operator|=
literal|0
init|;
name|index
operator|>=
literal|0
condition|;
name|index
operator|--
control|)
block|{
name|flags
operator|=
name|notifier
operator|.
name|checkMasks
index|[
name|index
index|]
operator||
operator|(
name|notifier
operator|.
name|checkMasks
operator|+
name|MASK_SIZE
operator|)
index|[
name|index
index|]
operator||
operator|(
name|notifier
operator|.
name|checkMasks
operator|+
literal|2
operator|*
operator|(
name|MASK_SIZE
operator|)
operator|)
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|flags
condition|)
block|{
for|for
control|(
name|i
operator|=
operator|(
name|NBBY
operator|*
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
operator|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|flags
operator|&
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|)
operator|<<
operator|(
name|i
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
break|break;
block|}
block|}
name|notifier
operator|.
name|numFdBits
operator|=
name|index
operator|*
operator|(
name|NBBY
operator|*
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
operator|)
operator|+
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/*      * Clean up information in the callback record.      */
if|if
condition|(
name|prevPtr
operator|==
name|NULL
condition|)
block|{
name|notifier
operator|.
name|firstFileHandlerPtr
operator|=
name|filePtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
name|prevPtr
operator|->
name|nextPtr
operator|=
name|filePtr
operator|->
name|nextPtr
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|filePtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FileHandlerEventProc --  *  *	This procedure is called by Tcl_ServiceEvent when a file event  *	reaches the front of the event queue.  This procedure is  *	responsible for actually handling the event by invoking the  *	callback for the file handler.  *  * Results:  *	Returns 1 if the event was handled, meaning it should be removed  *	from the queue.  Returns 0 if the event was not handled, meaning  *	it should stay on the queue.  The only time the event isn't  *	handled is if the TCL_FILE_EVENTS flag bit isn't set.  *  * Side effects:  *	Whatever the file handler's callback procedure does.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|FileHandlerEventProc
parameter_list|(
name|evPtr
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Event
modifier|*
name|evPtr
decl_stmt|;
comment|/* Event to service. */
name|int
name|flags
decl_stmt|;
comment|/* Flags that indicate what events to 				 * handle, such as TCL_FILE_EVENTS. */
block|{
name|FileHandler
modifier|*
name|filePtr
decl_stmt|;
name|FileHandlerEvent
modifier|*
name|fileEvPtr
init|=
operator|(
name|FileHandlerEvent
operator|*
operator|)
name|evPtr
decl_stmt|;
name|int
name|mask
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TCL_FILE_EVENTS
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/*      * Search through the file handlers to find the one whose handle matches      * the event.  We do this rather than keeping a pointer to the file      * handler directly in the event, so that the handler can be deleted      * while the event is queued without leaving a dangling pointer.      */
for|for
control|(
name|filePtr
operator|=
name|notifier
operator|.
name|firstFileHandlerPtr
init|;
name|filePtr
operator|!=
name|NULL
condition|;
name|filePtr
operator|=
name|filePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|filePtr
operator|->
name|fd
operator|!=
name|fileEvPtr
operator|->
name|fd
condition|)
block|{
continue|continue;
block|}
comment|/* 	 * The code is tricky for two reasons: 	 * 1. The file handler's desired events could have changed 	 *    since the time when the event was queued, so AND the 	 *    ready mask with the desired mask. 	 * 2. The file could have been closed and re-opened since 	 *    the time when the event was queued.  This is why the 	 *    ready mask is stored in the file handler rather than 	 *    the queued event:  it will be zeroed when a new 	 *    file handler is created for the newly opened file. 	 */
name|mask
operator|=
name|filePtr
operator|->
name|readyMask
operator|&
name|filePtr
operator|->
name|mask
expr_stmt|;
name|filePtr
operator|->
name|readyMask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|filePtr
operator|->
name|proc
call|)
argument_list|(
name|filePtr
operator|->
name|clientData
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_WaitForEvent --  *  *	This function is called by Tcl_DoOneEvent to wait for new  *	events on the message queue.  If the block time is 0, then  *	Tcl_WaitForEvent just polls without blocking.  *  * Results:  *	Returns -1 if the select would block forever, otherwise  *	returns 0.  *  * Side effects:  *	Queues file events that are detected by the select.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_WaitForEvent
parameter_list|(
name|timePtr
parameter_list|)
name|Tcl_Time
modifier|*
name|timePtr
decl_stmt|;
comment|/* Maximum block time, or NULL. */
block|{
name|FileHandler
modifier|*
name|filePtr
decl_stmt|;
name|FileHandlerEvent
modifier|*
name|fileEvPtr
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|,
modifier|*
name|timeoutPtr
decl_stmt|;
name|int
name|bit
decl_stmt|,
name|index
decl_stmt|,
name|mask
decl_stmt|,
name|numFound
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|InitNotifier
argument_list|()
expr_stmt|;
block|}
comment|/*      * Set up the timeout structure.  Note that if there are no events to      * check for, we return with a negative result rather than blocking      * forever.      */
if|if
condition|(
name|timePtr
condition|)
block|{
name|timeout
operator|.
name|tv_sec
operator|=
name|timePtr
operator|->
name|sec
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
name|timePtr
operator|->
name|usec
expr_stmt|;
name|timeoutPtr
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|notifier
operator|.
name|numFdBits
operator|==
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|timeoutPtr
operator|=
name|NULL
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|notifier
operator|.
name|readyMasks
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|notifier
operator|.
name|checkMasks
argument_list|,
literal|3
operator|*
name|MASK_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
argument_list|)
expr_stmt|;
name|numFound
operator|=
name|select
argument_list|(
name|notifier
operator|.
name|numFdBits
argument_list|,
operator|(
name|SELECT_MASK
operator|*
operator|)
operator|&
name|notifier
operator|.
name|readyMasks
index|[
literal|0
index|]
argument_list|,
operator|(
name|SELECT_MASK
operator|*
operator|)
operator|&
name|notifier
operator|.
name|readyMasks
index|[
name|MASK_SIZE
index|]
argument_list|,
operator|(
name|SELECT_MASK
operator|*
operator|)
operator|&
name|notifier
operator|.
name|readyMasks
index|[
literal|2
operator|*
name|MASK_SIZE
index|]
argument_list|,
name|timeoutPtr
argument_list|)
expr_stmt|;
comment|/*      * Some systems don't clear the masks after an error, so      * we have to do it here.      */
if|if
condition|(
name|numFound
operator|==
operator|-
literal|1
condition|)
block|{
name|memset
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|notifier
operator|.
name|readyMasks
argument_list|,
literal|0
argument_list|,
literal|3
operator|*
name|MASK_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*      * Queue all detected file events before returning.      */
for|for
control|(
name|filePtr
operator|=
name|notifier
operator|.
name|firstFileHandlerPtr
init|;
operator|(
name|filePtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|numFound
operator|>
literal|0
operator|)
condition|;
name|filePtr
operator|=
name|filePtr
operator|->
name|nextPtr
control|)
block|{
name|index
operator|=
name|filePtr
operator|->
name|fd
operator|/
operator|(
name|NBBY
operator|*
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
operator|)
expr_stmt|;
name|bit
operator|=
literal|1
operator|<<
operator|(
name|filePtr
operator|->
name|fd
operator|%
operator|(
name|NBBY
operator|*
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
operator|)
operator|)
expr_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|notifier
operator|.
name|readyMasks
index|[
name|index
index|]
operator|&
name|bit
condition|)
block|{
name|mask
operator||=
name|TCL_READABLE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|notifier
operator|.
name|readyMasks
operator|+
name|MASK_SIZE
operator|)
index|[
name|index
index|]
operator|&
name|bit
condition|)
block|{
name|mask
operator||=
name|TCL_WRITABLE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|notifier
operator|.
name|readyMasks
operator|+
literal|2
operator|*
operator|(
name|MASK_SIZE
operator|)
operator|)
index|[
name|index
index|]
operator|&
name|bit
condition|)
block|{
name|mask
operator||=
name|TCL_EXCEPTION
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mask
condition|)
block|{
continue|continue;
block|}
else|else
block|{
name|numFound
operator|--
expr_stmt|;
block|}
comment|/* 	 * Don't bother to queue an event if the mask was previously 	 * non-zero since an event must still be on the queue. 	 */
if|if
condition|(
name|filePtr
operator|->
name|readyMask
operator|==
literal|0
condition|)
block|{
name|fileEvPtr
operator|=
operator|(
name|FileHandlerEvent
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FileHandlerEvent
argument_list|)
argument_list|)
expr_stmt|;
name|fileEvPtr
operator|->
name|header
operator|.
name|proc
operator|=
name|FileHandlerEventProc
expr_stmt|;
name|fileEvPtr
operator|->
name|fd
operator|=
name|filePtr
operator|->
name|fd
expr_stmt|;
name|Tcl_QueueEvent
argument_list|(
operator|(
name|Tcl_Event
operator|*
operator|)
name|fileEvPtr
argument_list|,
name|TCL_QUEUE_TAIL
argument_list|)
expr_stmt|;
block|}
name|filePtr
operator|->
name|readyMask
operator|=
name|mask
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

