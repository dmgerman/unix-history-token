begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclUnixNotify.c --  *  *	This file contains Unix-specific procedures for the notifier,  *	which is the lowest-level part of the Tcl event loop.  This file  *	works together with ../generic/tclNotify.c.  *  * Copyright (c) 1995 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclUnixNotfy.c 1.31 96/07/23 16:17:29  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/*  * The information below is used to provide read, write, and  * exception masks to select during calls to Tcl_DoOneEvent.  */
end_comment

begin_decl_stmt
specifier|static
name|fd_mask
name|checkMasks
index|[
literal|3
operator|*
name|MASK_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array is used to build up the masks 				 * to be used in the next call to select. 				 * Bits are set in response to calls to 				 * Tcl_WatchFile. */
end_comment

begin_decl_stmt
specifier|static
name|fd_mask
name|readyMasks
index|[
literal|3
operator|*
name|MASK_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array reflects the readable/writable 				 * conditions that were found to exist by the 				 * last call to select. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|numFdBits
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of valid bits in checkMasks 				 * (one more than highest fd for which 				 * Tcl_WatchFile has been called). */
end_comment

begin_comment
comment|/*  * Static routines in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|MaskEmpty
name|_ANSI_ARGS_
argument_list|(
operator|(
name|long
operator|*
name|maskPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_WatchFile --  *  *	Arrange for Tcl_DoOneEvent to include this file in the masks  *	for the next call to select.  This procedure is invoked by  *	event sources, which are in turn invoked by Tcl_DoOneEvent  *	before it invokes select.  *  * Results:  *	None.  *  * Side effects:  *	  *	The notifier will generate a file event when the I/O channel  *	given by fd next becomes ready in the way indicated by mask.  *	If fd is already registered then the old mask will be replaced  *	with the new one.  Once the event is sent, the notifier will  *	not send any more events about the fd until the next call to  *	Tcl_NotifyFile.   *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_WatchFile
parameter_list|(
name|file
parameter_list|,
name|mask
parameter_list|)
name|Tcl_File
name|file
decl_stmt|;
comment|/* Generic file handle for a stream. */
name|int
name|mask
decl_stmt|;
comment|/* OR'ed combination of TCL_READABLE, 				 * TCL_WRITABLE, and TCL_EXCEPTION: 				 * indicates conditions to wait for 				 * in select. */
block|{
name|int
name|fd
decl_stmt|,
name|type
decl_stmt|,
name|index
decl_stmt|;
name|fd_mask
name|bit
decl_stmt|;
name|fd
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|file
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|TCL_UNIX_FD
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_WatchFile: unexpected file type"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|>=
name|FD_SETSIZE
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_WatchFile can't handle file id %d"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
name|index
operator|=
name|fd
operator|/
operator|(
name|NBBY
operator|*
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
operator|)
expr_stmt|;
name|bit
operator|=
literal|1
operator|<<
operator|(
name|fd
operator|%
operator|(
name|NBBY
operator|*
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|TCL_READABLE
condition|)
block|{
name|checkMasks
index|[
name|index
index|]
operator||=
name|bit
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|TCL_WRITABLE
condition|)
block|{
operator|(
name|checkMasks
operator|+
name|MASK_SIZE
operator|)
index|[
name|index
index|]
operator||=
name|bit
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|TCL_EXCEPTION
condition|)
block|{
operator|(
name|checkMasks
operator|+
literal|2
operator|*
operator|(
name|MASK_SIZE
operator|)
operator|)
index|[
name|index
index|]
operator||=
name|bit
expr_stmt|;
block|}
if|if
condition|(
name|numFdBits
operator|<=
name|fd
condition|)
block|{
name|numFdBits
operator|=
name|fd
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_FileReady --  *  *	Indicates what conditions (readable, writable, etc.) were  *	present on a file the last time the notifier invoked select.  *	This procedure is typically invoked by event sources to see  *	if they should queue events.  *  * Results:  *	The return value is 0 if none of the conditions specified by mask  *	was true for fd the last time the system checked.  If any of the  *	conditions were true, then the return value is a mask of those  *	that were true.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_FileReady
parameter_list|(
name|file
parameter_list|,
name|mask
parameter_list|)
name|Tcl_File
name|file
decl_stmt|;
comment|/* Generic file handle for a stream. */
name|int
name|mask
decl_stmt|;
comment|/* OR'ed combination of TCL_READABLE, 				 * TCL_WRITABLE, and TCL_EXCEPTION: 				 * indicates conditions caller cares about. */
block|{
name|int
name|index
decl_stmt|,
name|result
decl_stmt|,
name|type
decl_stmt|,
name|fd
decl_stmt|;
name|fd_mask
name|bit
decl_stmt|;
name|fd
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|file
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|TCL_UNIX_FD
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_FileReady: unexpected file type"
argument_list|)
expr_stmt|;
block|}
name|index
operator|=
name|fd
operator|/
operator|(
name|NBBY
operator|*
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
operator|)
expr_stmt|;
name|bit
operator|=
literal|1
operator|<<
operator|(
name|fd
operator|%
operator|(
name|NBBY
operator|*
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
operator|)
operator|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|TCL_READABLE
operator|)
operator|&&
operator|(
name|readyMasks
index|[
name|index
index|]
operator|&
name|bit
operator|)
condition|)
block|{
name|result
operator||=
name|TCL_READABLE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|TCL_WRITABLE
operator|)
operator|&&
operator|(
operator|(
name|readyMasks
operator|+
name|MASK_SIZE
operator|)
index|[
name|index
index|]
operator|&
name|bit
operator|)
condition|)
block|{
name|result
operator||=
name|TCL_WRITABLE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|TCL_EXCEPTION
operator|)
operator|&&
operator|(
operator|(
name|readyMasks
operator|+
operator|(
literal|2
operator|*
name|MASK_SIZE
operator|)
operator|)
index|[
name|index
index|]
operator|&
name|bit
operator|)
condition|)
block|{
name|result
operator||=
name|TCL_EXCEPTION
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * MaskEmpty --  *  *	Returns nonzero if mask is empty (has no bits set).  *  * Results:  *	Nonzero if the mask is empty, zero otherwise.  *  * Side effects:  *	None  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|MaskEmpty
parameter_list|(
name|maskPtr
parameter_list|)
name|long
modifier|*
name|maskPtr
decl_stmt|;
block|{
name|long
modifier|*
name|runPtr
decl_stmt|,
modifier|*
name|tailPtr
decl_stmt|;
name|int
name|found
decl_stmt|,
name|sz
decl_stmt|;
name|sz
operator|=
literal|3
operator|*
operator|(
operator|(
name|MASK_SIZE
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
expr_stmt|;
for|for
control|(
name|runPtr
operator|=
name|maskPtr
operator|,
name|tailPtr
operator|=
name|maskPtr
operator|+
name|sz
operator|,
name|found
operator|=
literal|0
init|;
name|runPtr
operator|<
name|tailPtr
condition|;
name|runPtr
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|runPtr
operator|!=
literal|0
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|!
name|found
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_WaitForEvent --  *  *	This procedure does the lowest level wait for events in a  *	platform-specific manner.  It uses information provided by  *	previous calls to Tcl_WatchFile, plus the timePtr argument,  *	to determine what to wait for and how long to wait.  *  * Results:  *	The return value is normally TCL_OK.  However, if there are  *	no events to wait for (e.g. no files and no timers) so that  *	the procedure would block forever, then it returns TCL_ERROR.  *  * Side effects:  *	May put the process to sleep for a while, depending on timePtr.  *	When this procedure returns, an event of interest to the application  *	has probably, but not necessarily, occurred.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_WaitForEvent
parameter_list|(
name|timePtr
parameter_list|)
name|Tcl_Time
modifier|*
name|timePtr
decl_stmt|;
comment|/* Specifies the maximum amount of time 				 * that this procedure should block before 				 * returning.  The time is given as an 				 * interval, not an absolute wakeup time. 				 * NULL means block forever. */
block|{
name|struct
name|timeval
name|timeout
decl_stmt|,
modifier|*
name|timeoutPtr
decl_stmt|;
name|int
name|numFound
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|readyMasks
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|checkMasks
argument_list|,
literal|3
operator|*
name|MASK_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|timePtr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|numFdBits
operator|==
literal|0
operator|)
operator|||
operator|(
name|MaskEmpty
argument_list|(
operator|(
name|long
operator|*
operator|)
name|readyMasks
argument_list|)
operator|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|timeoutPtr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|timeoutPtr
operator|=
operator|&
name|timeout
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
name|timePtr
operator|->
name|sec
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
name|timePtr
operator|->
name|usec
expr_stmt|;
block|}
name|numFound
operator|=
name|select
argument_list|(
name|numFdBits
argument_list|,
operator|(
name|SELECT_MASK
operator|*
operator|)
operator|&
name|readyMasks
index|[
literal|0
index|]
argument_list|,
operator|(
name|SELECT_MASK
operator|*
operator|)
operator|&
name|readyMasks
index|[
name|MASK_SIZE
index|]
argument_list|,
operator|(
name|SELECT_MASK
operator|*
operator|)
operator|&
name|readyMasks
index|[
literal|2
operator|*
name|MASK_SIZE
index|]
argument_list|,
name|timeoutPtr
argument_list|)
expr_stmt|;
comment|/*      * Some systems don't clear the masks after an error, so      * we have to do it here.      */
if|if
condition|(
name|numFound
operator|==
operator|-
literal|1
condition|)
block|{
name|memset
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|readyMasks
argument_list|,
literal|0
argument_list|,
literal|3
operator|*
name|MASK_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*      * Reset the check masks in preparation for the next call to      * select.      */
name|numFdBits
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|checkMasks
argument_list|,
literal|0
argument_list|,
literal|3
operator|*
name|MASK_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_Sleep --  *  *	Delay execution for the specified number of milliseconds.  *  * Results:  *	None.  *  * Side effects:  *	Time passes.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_Sleep
parameter_list|(
name|ms
parameter_list|)
name|int
name|ms
decl_stmt|;
comment|/* Number of milliseconds to sleep. */
block|{
specifier|static
name|struct
name|timeval
name|delay
decl_stmt|;
name|Tcl_Time
name|before
decl_stmt|,
name|after
decl_stmt|;
comment|/*      * The only trick here is that select appears to return early      * under some conditions, so we have to check to make sure that      * the right amount of time really has elapsed.  If it's too      * early, go back to sleep again.      */
name|TclpGetTime
argument_list|(
operator|&
name|before
argument_list|)
expr_stmt|;
name|after
operator|=
name|before
expr_stmt|;
name|after
operator|.
name|sec
operator|+=
name|ms
operator|/
literal|1000
expr_stmt|;
name|after
operator|.
name|usec
operator|+=
operator|(
name|ms
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
if|if
condition|(
name|after
operator|.
name|usec
operator|>
literal|1000000
condition|)
block|{
name|after
operator|.
name|usec
operator|-=
literal|1000000
expr_stmt|;
name|after
operator|.
name|sec
operator|+=
literal|1
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|delay
operator|.
name|tv_sec
operator|=
name|after
operator|.
name|sec
operator|-
name|before
operator|.
name|sec
expr_stmt|;
name|delay
operator|.
name|tv_usec
operator|=
name|after
operator|.
name|usec
operator|-
name|before
operator|.
name|usec
expr_stmt|;
if|if
condition|(
name|delay
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|delay
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
name|delay
operator|.
name|tv_sec
operator|-=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Special note:  must convert delay.tv_sec to int before comparing 	 * to zero, since delay.tv_usec is unsigned on some platforms. 	 */
if|if
condition|(
operator|(
operator|(
operator|(
name|int
operator|)
name|delay
operator|.
name|tv_sec
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|delay
operator|.
name|tv_usec
operator|==
literal|0
operator|)
operator|&&
operator|(
name|delay
operator|.
name|tv_sec
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
break|break;
block|}
operator|(
name|void
operator|)
name|select
argument_list|(
literal|0
argument_list|,
operator|(
name|SELECT_MASK
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|SELECT_MASK
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|SELECT_MASK
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|delay
argument_list|)
expr_stmt|;
name|TclpGetTime
argument_list|(
operator|&
name|before
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

