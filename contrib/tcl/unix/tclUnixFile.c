begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclUnixFile.c --  *  *      This file contains wrappers around UNIX file handling functions.  *      These wrappers mask differences between Windows and UNIX.  *  * Copyright (c) 1995 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclUnixFile.c 1.38 96/04/18 08:43:51  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * The variable below caches the name of the current working directory  * in order to avoid repeated calls to getcwd.  The string is malloc-ed.  * NULL means the cache needs to be refreshed.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|currentDir
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|currentDirExitHandlerSet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The variable below is set if the exit routine for deleting the string  * containing the executable name has been registered.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|executableNameExitHandlerSet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|pid_t
name|waitpid
name|_ANSI_ARGS_
argument_list|(
operator|(
name|pid_t
name|pid
operator|,
name|int
operator|*
name|stat_loc
operator|,
name|int
name|options
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Static routines for this file:  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|FreeCurrentDir
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|FreeExecutableName
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_WaitPid --  *  *	Implements the waitpid system call on Unix systems.  *  * Results:  *	Result of calling waitpid.  *  * Side effects:  *	Waits for a process to terminate.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_WaitPid
parameter_list|(
name|pid
parameter_list|,
name|statPtr
parameter_list|,
name|options
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
modifier|*
name|statPtr
decl_stmt|;
name|int
name|options
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|pid_t
name|real_pid
decl_stmt|;
name|real_pid
operator|=
operator|(
name|pid_t
operator|)
name|pid
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|result
operator|=
operator|(
name|int
operator|)
name|waitpid
argument_list|(
name|real_pid
argument_list|,
name|statPtr
argument_list|,
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|!=
operator|-
literal|1
operator|)
operator|||
operator|(
name|errno
operator|!=
name|EINTR
operator|)
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FreeCurrentDir --  *  *	Frees the string stored in the currentDir variable. This routine  *	is registered as an exit handler and will be called during shutdown.  *  * Results:  *	None.  *  * Side effects:  *	Frees the memory occuppied by the currentDir value.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|FreeCurrentDir
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
block|{
if|if
condition|(
name|currentDir
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|currentDir
argument_list|)
expr_stmt|;
name|currentDir
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FreeExecutableName --  *  *	Frees the string stored in the tclExecutableName variable. This  *	routine is registered as an exit handler and will be called  *	during shutdown.  *  * Results:  *	None.  *  * Side effects:  *	Frees the memory occuppied by the tclExecutableName value.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|FreeExecutableName
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
block|{
if|if
condition|(
name|tclExecutableName
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|tclExecutableName
argument_list|)
expr_stmt|;
name|tclExecutableName
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclChdir --  *  *	Change the current working directory.  *  * Results:  *	The result is a standard Tcl result.  If an error occurs and   *	interp isn't NULL, an error message is left in interp->result.  *  * Side effects:  *	The working directory for this application is changed.  Also  *	the cache maintained used by TclGetCwd is deallocated and  *	set to NULL.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclChdir
parameter_list|(
name|interp
parameter_list|,
name|dirName
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* If non NULL, used for error reporting. */
name|char
modifier|*
name|dirName
decl_stmt|;
comment|/* Path to new working directory. */
block|{
if|if
condition|(
name|currentDir
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|currentDir
argument_list|)
expr_stmt|;
name|currentDir
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|chdir
argument_list|(
name|dirName
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't change working directory to \""
argument_list|,
name|dirName
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclGetCwd --  *  *	Return the path name of the current working directory.  *  * Results:  *	The result is the full path name of the current working  *	directory, or NULL if an error occurred while figuring it out.  *	The returned string is owned by the TclGetCwd routine and must  *	not be freed by the caller.  If an error occurs and interp  *	isn't NULL, an error message is left in interp->result.  *  * Side effects:  *	The path name is cached to avoid having to recompute it  *	on future calls;  if it is already cached, the cached  *	value is returned.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|TclGetCwd
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* If non NULL, used for error reporting. */
block|{
name|char
name|buffer
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|currentDir
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|currentDirExitHandlerSet
condition|)
block|{
name|currentDirExitHandlerSet
operator|=
literal|1
expr_stmt|;
name|Tcl_CreateExitHandler
argument_list|(
name|FreeCurrentDir
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getcwd
argument_list|(
name|buffer
argument_list|,
name|MAXPATHLEN
operator|+
literal|1
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ERANGE
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"working directory name is too long"
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"error getting working directory name: "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|NULL
return|;
block|}
name|currentDir
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|currentDir
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
return|return
name|currentDir
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclOpenFile --  *  *	Implements a mechanism to open files on Unix systems.  *  * Results:  *	The opened file.  *  * Side effects:  *	May cause a file to be created on the file system.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_File
name|TclOpenFile
parameter_list|(
name|fname
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* The name of the file to open. */
name|int
name|mode
decl_stmt|;
comment|/* In what mode to open the file? */
block|{
name|int
name|fd
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|mode
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
return|return
name|Tcl_GetFile
argument_list|(
operator|(
name|ClientData
operator|)
name|fd
argument_list|,
name|TCL_UNIX_FD
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCloseFile --  *  *	Implements a mechanism to close a UNIX file.  *  * Results:  *	Returns 0 on success, or -1 on error, setting errno.  *  * Side effects:  *	The file is closed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclCloseFile
parameter_list|(
name|file
parameter_list|)
name|Tcl_File
name|file
decl_stmt|;
comment|/* The file to close. */
block|{
name|int
name|type
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|result
decl_stmt|;
name|fd
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|file
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|TCL_UNIX_FD
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_CloseFile: unexpected file type"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Refuse to close the fds for stdin, stdout and stderr.      */
if|if
condition|(
operator|(
name|fd
operator|==
literal|0
operator|)
operator|||
operator|(
name|fd
operator|==
literal|1
operator|)
operator|||
operator|(
name|fd
operator|==
literal|2
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
name|result
operator|=
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|Tcl_DeleteFileHandler
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|Tcl_FreeFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclReadFile --  *  *	Implements a mechanism to read from files on Unix systems. Also  *	simulates blocking behavior on non-blocking files when asked to.  *  * Results:  *	The number of characters read from the specified file.  *  * Side effects:  *	May consume characters from the file.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|TclReadFile
parameter_list|(
name|file
parameter_list|,
name|shouldBlock
parameter_list|,
name|buf
parameter_list|,
name|toRead
parameter_list|)
name|Tcl_File
name|file
decl_stmt|;
comment|/* The file to read from. */
name|int
name|shouldBlock
decl_stmt|;
comment|/* Not used. */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* The buffer to store input in. */
name|int
name|toRead
decl_stmt|;
comment|/* Number of characters to read. */
block|{
name|int
name|type
decl_stmt|,
name|fd
decl_stmt|;
name|fd
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|file
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|TCL_UNIX_FD
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_ReadFile: unexpected file type"
argument_list|)
expr_stmt|;
block|}
return|return
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
operator|(
name|size_t
operator|)
name|toRead
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclWriteFile --  *  *	Implements a mechanism to write to files on Unix systems.  *  * Results:  *	The number of characters written to the specified file.  *  * Side effects:  *	May produce characters on the file.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|TclWriteFile
parameter_list|(
name|file
parameter_list|,
name|shouldBlock
parameter_list|,
name|buf
parameter_list|,
name|toWrite
parameter_list|)
name|Tcl_File
name|file
decl_stmt|;
comment|/* The file to write to. */
name|int
name|shouldBlock
decl_stmt|;
comment|/* Not used. */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Where output is stored. */
name|int
name|toWrite
decl_stmt|;
comment|/* Number of characters to write. */
block|{
name|int
name|type
decl_stmt|,
name|fd
decl_stmt|;
name|fd
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|file
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|TCL_UNIX_FD
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_WriteFile: unexpected file type"
argument_list|)
expr_stmt|;
block|}
return|return
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
operator|(
name|size_t
operator|)
name|toWrite
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclSeekFile --  *  *	Sets the file pointer on the indicated UNIX file.  *  * Results:  *	The new position at which the file will be accessed, or -1 on  *	failure.  *  * Side effects:  *	May change the position at which subsequent operations access the  *	file designated by the file.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclSeekFile
parameter_list|(
name|file
parameter_list|,
name|offset
parameter_list|,
name|whence
parameter_list|)
name|Tcl_File
name|file
decl_stmt|;
comment|/* The file to seek on. */
name|int
name|offset
decl_stmt|;
comment|/* How far to seek? */
name|int
name|whence
decl_stmt|;
comment|/* And from where to seek? */
block|{
name|int
name|type
decl_stmt|,
name|fd
decl_stmt|;
name|fd
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|file
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|TCL_UNIX_FD
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_SeekFile: unexpected file type"
argument_list|)
expr_stmt|;
block|}
return|return
name|lseek
argument_list|(
name|fd
argument_list|,
name|offset
argument_list|,
name|whence
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCreateTempFile --  *  *	This function creates a temporary file initialized with an  *	optional string, and returns a file handle with the file pointer  *	at the beginning of the file.  *  * Results:  *	A handle to a file.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_File
name|TclCreateTempFile
parameter_list|(
name|contents
parameter_list|)
name|char
modifier|*
name|contents
decl_stmt|;
comment|/* String to write into temp file, or NULL. */
block|{
name|char
name|fileName
index|[
name|L_tmpnam
index|]
decl_stmt|;
name|Tcl_File
name|file
decl_stmt|;
name|size_t
name|length
init|=
operator|(
name|contents
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|contents
argument_list|)
decl_stmt|;
name|tmpnam
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
name|file
operator|=
name|TclOpenFile
argument_list|(
name|fileName
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|file
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|length
operator|>
literal|0
operator|)
condition|)
block|{
name|int
name|fd
init|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|file
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|contents
argument_list|,
name|length
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|Tcl_FreeFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
return|return
name|file
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_FindExecutable --  *  *	This procedure computes the absolute path name of the current  *	application, given its argv[0] value.  *  * Results:  *	None.  *  * Side effects:  *	The variable tclExecutableName gets filled in with the file  *	name for the application, if we figured it out.  If we couldn't  *	figure it out, Tcl_FindExecutable is set to NULL.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_FindExecutable
parameter_list|(
name|argv0
parameter_list|)
name|char
modifier|*
name|argv0
decl_stmt|;
comment|/* The value of the application's argv[0]. */
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|cwd
decl_stmt|;
name|Tcl_DString
name|buffer
decl_stmt|;
name|int
name|length
decl_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|tclExecutableName
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|tclExecutableName
argument_list|)
expr_stmt|;
name|tclExecutableName
operator|=
name|NULL
expr_stmt|;
block|}
name|name
operator|=
name|argv0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
block|{
comment|/* 	     * The name contains a slash, so use the name directly 	     * without doing a path search. 	     */
goto|goto
name|gotName
goto|;
block|}
block|}
name|p
operator|=
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * There's no PATH environment variable; use the default that 	 * is used by sh. 	 */
name|p
operator|=
literal|":/bin:/usr/bin"
expr_stmt|;
block|}
comment|/*      * Search through all the directories named in the PATH variable      * to see if argv[0] is in one of them.  If so, use that file      * name.      */
while|while
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
name|name
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|p
operator|!=
literal|':'
operator|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|0
operator|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
name|Tcl_DStringSetLength
argument_list|(
operator|&
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|name
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|buffer
argument_list|,
name|name
argument_list|,
name|p
operator|-
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|buffer
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|Tcl_DStringAppend
argument_list|(
operator|&
name|buffer
argument_list|,
name|argv0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|Tcl_DStringValue
argument_list|(
operator|&
name|buffer
argument_list|)
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|name
operator|=
name|Tcl_DStringValue
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
goto|goto
name|gotName
goto|;
block|}
name|p
operator|++
expr_stmt|;
block|}
goto|goto
name|done
goto|;
comment|/*      * If the name starts with "/" then just copy it to tclExecutableName.      */
name|gotName
label|:
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|tclExecutableName
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tclExecutableName
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*      * The name is relative to the current working directory.  First      * strip off a leading "./", if any, then add the full path name of      * the current working directory.      */
if|if
condition|(
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
name|name
operator|+=
literal|2
expr_stmt|;
block|}
name|cwd
operator|=
name|TclGetCwd
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cwd
operator|==
name|NULL
condition|)
block|{
name|tclExecutableName
operator|=
name|NULL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|length
operator|=
name|strlen
argument_list|(
name|cwd
argument_list|)
expr_stmt|;
name|tclExecutableName
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|length
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tclExecutableName
argument_list|,
name|cwd
argument_list|)
expr_stmt|;
name|tclExecutableName
index|[
name|length
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|tclExecutableName
operator|+
name|length
operator|+
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|done
label|:
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|executableNameExitHandlerSet
condition|)
block|{
name|executableNameExitHandlerSet
operator|=
literal|1
expr_stmt|;
name|Tcl_CreateExitHandler
argument_list|(
name|FreeExecutableName
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclGetUserHome --  *  *	This function takes the passed in user name and finds the  *	corresponding home directory specified in the password file.  *  * Results:  *	The result is a pointer to a static string containing  *	the new name.  If there was an error in processing the  *	user name then the return value is NULL.  Otherwise the  *	result is stored in bufferPtr, and the caller must call  *	Tcl_DStringFree(bufferPtr) to free the result.  *  * Side effects:  *	Information may be left in bufferPtr.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|TclGetUserHome
parameter_list|(
name|name
parameter_list|,
name|bufferPtr
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* User name to use to find home directory. */
name|Tcl_DString
modifier|*
name|bufferPtr
decl_stmt|;
comment|/* May be used to hold result.  Must not hold 				 * anything at the time of the call, and need 				 * not even be initialized. */
block|{
name|struct
name|passwd
modifier|*
name|pwPtr
decl_stmt|;
name|pwPtr
operator|=
name|getpwnam
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwPtr
operator|==
name|NULL
condition|)
block|{
name|endpwent
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|Tcl_DStringInit
argument_list|(
name|bufferPtr
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
name|bufferPtr
argument_list|,
name|pwPtr
operator|->
name|pw_dir
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
return|return
name|bufferPtr
operator|->
name|string
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclMatchFiles --  *  *	This routine is used by the globbing code to search a  *	directory for all files which match a given pattern.  *  * Results:   *	If the tail argument is NULL, then the matching files are  *	added to the interp->result.  Otherwise, TclDoGlob is called  *	recursively for each matching subdirectory.  The return value  *	is a standard Tcl result indicating whether an error occurred  *	in globbing.  *  * Side effects:  *	None.  *  *---------------------------------------------------------------------- */
end_comment

begin_function
name|int
name|TclMatchFiles
parameter_list|(
name|interp
parameter_list|,
name|separators
parameter_list|,
name|dirPtr
parameter_list|,
name|pattern
parameter_list|,
name|tail
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to receive results. */
name|char
modifier|*
name|separators
decl_stmt|;
comment|/* Path separators to pass to TclDoGlob. */
name|Tcl_DString
modifier|*
name|dirPtr
decl_stmt|;
comment|/* Contains path to directory to search. */
name|char
modifier|*
name|pattern
decl_stmt|;
comment|/* Pattern to match against. */
name|char
modifier|*
name|tail
decl_stmt|;
comment|/* Pointer to end of pattern. */
block|{
name|char
modifier|*
name|dirName
decl_stmt|,
modifier|*
name|patternEnd
init|=
name|tail
decl_stmt|;
name|char
name|savedChar
init|=
literal|0
decl_stmt|;
comment|/* Initialization needed only to prevent 				 * compiler warning from gcc. */
name|DIR
modifier|*
name|d
decl_stmt|;
name|struct
name|stat
name|statBuf
decl_stmt|;
name|struct
name|dirent
modifier|*
name|entryPtr
decl_stmt|;
name|int
name|matchHidden
decl_stmt|;
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
name|int
name|baseLength
init|=
name|Tcl_DStringLength
argument_list|(
name|dirPtr
argument_list|)
decl_stmt|;
comment|/*      * Make sure that the directory part of the name really is a      * directory.  If the directory name is "", use the name "."      * instead, because some UNIX systems don't treat "" like "."      * automatically.  Keep the "" for use in generating file names,      * otherwise "glob foo.c" would return "./foo.c".      */
if|if
condition|(
name|dirPtr
operator|->
name|string
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|dirName
operator|=
literal|"."
expr_stmt|;
block|}
else|else
block|{
name|dirName
operator|=
name|dirPtr
operator|->
name|string
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stat
argument_list|(
name|dirName
argument_list|,
operator|&
name|statBuf
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|!
name|S_ISDIR
argument_list|(
name|statBuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
comment|/*      * Check to see if the pattern needs to compare with hidden files.      */
if|if
condition|(
operator|(
name|pattern
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|||
operator|(
operator|(
name|pattern
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
name|pattern
index|[
literal|1
index|]
operator|==
literal|'.'
operator|)
operator|)
condition|)
block|{
name|matchHidden
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|matchHidden
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * Now open the directory for reading and iterate over the contents.      */
name|d
operator|=
name|opendir
argument_list|(
name|dirName
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
comment|/* 	 * Strip off a trailing '/' if necessary, before reporting the error. 	 */
if|if
condition|(
name|baseLength
operator|>
literal|0
condition|)
block|{
name|savedChar
operator|=
name|dirPtr
operator|->
name|string
index|[
name|baseLength
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|savedChar
operator|==
literal|'/'
condition|)
block|{
name|dirPtr
operator|->
name|string
index|[
name|baseLength
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't read directory \""
argument_list|,
name|dirPtr
operator|->
name|string
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|baseLength
operator|>
literal|0
condition|)
block|{
name|dirPtr
operator|->
name|string
index|[
name|baseLength
operator|-
literal|1
index|]
operator|=
name|savedChar
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Clean up the end of the pattern and the tail pointer.  Leave      * the tail pointing to the first character after the path separator      * following the pattern, or NULL.  Also, ensure that the pattern      * is null-terminated.      */
if|if
condition|(
operator|*
name|tail
operator|==
literal|'\\'
condition|)
block|{
name|tail
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|tail
operator|==
literal|'\0'
condition|)
block|{
name|tail
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|tail
operator|++
expr_stmt|;
block|}
name|savedChar
operator|=
operator|*
name|patternEnd
expr_stmt|;
operator|*
name|patternEnd
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|entryPtr
operator|=
name|readdir
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|entryPtr
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
comment|/* 	 * Don't match names starting with "." unless the "." is 	 * present in the pattern. 	 */
if|if
condition|(
operator|!
name|matchHidden
operator|&&
operator|(
operator|*
name|entryPtr
operator|->
name|d_name
operator|==
literal|'.'
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* 	 * Now check to see if the file matches.  If there are more 	 * characters to be processed, then ensure matching files are 	 * directories before calling TclDoGlob. Otherwise, just add 	 * the file to the result. 	 */
if|if
condition|(
name|Tcl_StringMatch
argument_list|(
name|entryPtr
operator|->
name|d_name
argument_list|,
name|pattern
argument_list|)
condition|)
block|{
name|Tcl_DStringSetLength
argument_list|(
name|dirPtr
argument_list|,
name|baseLength
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
name|dirPtr
argument_list|,
name|entryPtr
operator|->
name|d_name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|dirPtr
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|stat
argument_list|(
name|dirPtr
operator|->
name|string
argument_list|,
operator|&
name|statBuf
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|S_ISDIR
argument_list|(
name|statBuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|dirPtr
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TclDoGlob
argument_list|(
name|interp
argument_list|,
name|separators
argument_list|,
name|dirPtr
argument_list|,
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
break|break;
block|}
block|}
block|}
block|}
operator|*
name|patternEnd
operator|=
name|savedChar
expr_stmt|;
name|closedir
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

end_unit

