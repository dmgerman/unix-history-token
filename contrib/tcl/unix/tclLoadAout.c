begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclLoadAout.c --  *  *	This procedure provides a version of the TclLoadFile that  *	provides pseudo-static linking using version-7 compatible  *	a.out files described in either sys/exec.h or sys/a.out.h.  *  * Copyright (c) 1995, by General Electric Company. All rights reserved.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * This work was supported in part by the ARPA Manufacturing Automation  * and Design Engineering (MADE) Initiative through ARPA contract  * F33615-94-C-4400.  *  * SCCS: @(#) tclLoadAout.c 1.7 96/02/15 11:58:53  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXEC_AOUT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/exec_aout.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Some systems describe the a.out header in sys/exec.h, and some in  * a.out.h.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_SYS_EXEC_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_A_OUT_H
end_ifdef

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_SYS_EXEC_AOUT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/exec_aout.h>
end_include

begin_define
define|#
directive|define
name|a_magic
value|a_midmag
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * TCL_LOADSHIM is the amount by which to shim the break when loading  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TCL_LOADSHIM
end_ifndef

begin_define
define|#
directive|define
name|TCL_LOADSHIM
value|0x4000L
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * TCL_LOADALIGN must be a power of 2, and is the alignment to which  * to force the origin of load modules  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TCL_LOADALIGN
end_ifndef

begin_define
define|#
directive|define
name|TCL_LOADALIGN
value|0x4000L
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * TCL_LOADMAX is the maximum size of a load module, and is used as  * a sanity check when loading  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TCL_LOADMAX
end_ifndef

begin_define
define|#
directive|define
name|TCL_LOADMAX
value|2000000L
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Kernel calls that appear to be missing from the system .h files:  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|brk
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sbrk
name|_ANSI_ARGS_
argument_list|(
operator|(
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The static variable SymbolTableFile contains the file name where the  * result of the last link was stored.  The file is kept because doing so  * allows one load module to use the symbols defined in another.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SymbolTableFile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Type of the dictionary function that begins each load module.  */
end_comment

begin_typedef
typedef|typedef
name|Tcl_PackageInitProc
operator|*
operator|(
operator|*
name|DictFn
operator|)
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|symbol
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_comment
comment|/*  * Prototypes for procedures referenced only in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|FindLibraries
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|fileName
operator|,
name|Tcl_DString
operator|*
name|buf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|UnlinkSymbolTable
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclLoadFile --  *  *	Dynamically loads a binary code file into memory and returns  *	the addresses of two procedures within that file, if they  *	are defined.  *  * Results:  *	A standard Tcl completion code.  If an error occurs, an error  *	message is left in interp->result.  *proc1Ptr and *proc2Ptr  *	are filled in with the addresses of the symbols given by  *	*sym1 and *sym2, or NULL if those symbols can't be found.  *  * Side effects:  *	New code suddenly appears in memory.  *  *  * Bugs:  *	This function does not attempt to handle the case where the  *	BSS segment is not executable.  It will therefore fail on  *	Encore Multimax, Pyramid 90x, and similar machines.  The  *	reason is that the mprotect() kernel call, which would  *	otherwise be employed to mark the newly-loaded text segment  *	executable, results in a system crash on BSD/386.  *  *	In an effort to make it fast, this function eschews the  *	technique of linking the load module once, reading its header  *	to determine its size, allocating memory for it, and linking  *	it again.  Instead, it `shims out' memory allocation by  *	placing the module TCL_LOADSHIM bytes beyond the break,  *	and assuming that any malloc() calls required to run the  *	linker will not advance the break beyond that point.  If  *	the break is advanced beyonnd that point, the load will  *	fail with an `inconsistent memory allocation' error.  *	It perhaps ought to retry the link, but the failure has  *	not been observed in two years of daily use of this function.  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclLoadFile
parameter_list|(
name|interp
parameter_list|,
name|fileName
parameter_list|,
name|sym1
parameter_list|,
name|sym2
parameter_list|,
name|proc1Ptr
parameter_list|,
name|proc2Ptr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|char
modifier|*
name|fileName
decl_stmt|;
comment|/* Name of the file containing the desired 				 * code. */
name|char
modifier|*
name|sym1
decl_stmt|,
decl|*
name|sym2
decl_stmt|;
end_function

begin_comment
comment|/* Names of two procedures to look up in 				 * the file's symbol table. */
end_comment

begin_decl_stmt
name|Tcl_PackageInitProc
modifier|*
modifier|*
name|proc1Ptr
decl_stmt|,
modifier|*
modifier|*
name|proc2Ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where to return the addresses corresponding 				 * to sym1 and sym2. */
end_comment

begin_block
block|{
name|char
modifier|*
name|inputSymbolTable
decl_stmt|;
comment|/* Name of the file containing the  				 * symbol table from the last link. */
name|Tcl_DString
name|linkCommandBuf
decl_stmt|;
comment|/* Command to do the run-time relocation 				 * of the module.*/
name|char
modifier|*
name|linkCommand
decl_stmt|;
name|char
name|relocatedFileName
index|[
name|L_tmpnam
index|]
decl_stmt|;
comment|/* Name of the file holding the relocated */
comment|/* text of the module */
name|int
name|relocatedFd
decl_stmt|;
comment|/* File descriptor of the file holding 				 * relocated text */
name|struct
name|exec
name|relocatedHead
decl_stmt|;
comment|/* Header of the relocated text */
name|unsigned
name|long
name|relocatedSize
decl_stmt|;
comment|/* Size of the relocated text */
name|char
modifier|*
name|startAddress
decl_stmt|;
comment|/* Starting address of the module */
name|DictFn
name|dictionary
decl_stmt|;
comment|/* Dictionary function in the load module */
name|int
name|status
decl_stmt|;
comment|/* Status return from Tcl_ calls */
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Find the file that contains the symbols for the run-time link. */
if|if
condition|(
name|SymbolTableFile
operator|!=
name|NULL
condition|)
block|{
name|inputSymbolTable
operator|=
name|SymbolTableFile
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tclExecutableName
operator|==
name|NULL
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"can't find the tclsh executable"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
else|else
block|{
name|inputSymbolTable
operator|=
name|tclExecutableName
expr_stmt|;
block|}
comment|/* Construct the `ld' command that builds the relocated module */
name|tmpnam
argument_list|(
name|relocatedFileName
argument_list|)
expr_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|linkCommandBuf
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|linkCommandBuf
argument_list|,
literal|"exec ld -o "
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|linkCommandBuf
argument_list|,
name|relocatedFileName
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__mips
argument_list|)
operator|||
name|defined
argument_list|(
name|mips
argument_list|)
name|Tcl_DStringAppend
argument_list|(
operator|&
name|linkCommandBuf
argument_list|,
literal|" -G 0 "
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Tcl_DStringAppend
argument_list|(
operator|&
name|linkCommandBuf
argument_list|,
literal|" -A "
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|linkCommandBuf
argument_list|,
name|inputSymbolTable
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|linkCommandBuf
argument_list|,
literal|" -N -T XXXXXXXX "
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|linkCommandBuf
argument_list|,
name|fileName
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|linkCommandBuf
argument_list|,
literal|" "
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|FindLibraries
argument_list|(
name|interp
argument_list|,
name|fileName
argument_list|,
operator|&
name|linkCommandBuf
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_DStringFree
argument_list|(
operator|&
name|linkCommandBuf
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|linkCommand
operator|=
name|Tcl_DStringValue
argument_list|(
operator|&
name|linkCommandBuf
argument_list|)
expr_stmt|;
comment|/* Determine the starting address, and plug it into the command */
name|startAddress
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
operator|+
name|TCL_LOADSHIM
operator|+
name|TCL_LOADALIGN
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
name|TCL_LOADALIGN
operator|)
operator|)
expr_stmt|;
name|p
operator|=
name|strstr
argument_list|(
name|linkCommand
argument_list|,
literal|"-T"
argument_list|)
operator|+
literal|3
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%08lx"
argument_list|,
operator|(
name|long
operator|)
name|startAddress
argument_list|)
expr_stmt|;
name|p
index|[
literal|8
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* Run the linker */
name|status
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|linkCommand
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|linkCommandBuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
comment|/* Open the linker's result file and read the header */
name|relocatedFd
operator|=
name|open
argument_list|(
name|relocatedFileName
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocatedFd
operator|<
literal|0
condition|)
block|{
goto|goto
name|ioError
goto|;
block|}
name|status
operator|=
name|read
argument_list|(
name|relocatedFd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|relocatedHead
argument_list|,
sizeof|sizeof
name|relocatedHead
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
sizeof|sizeof
name|relocatedHead
condition|)
block|{
goto|goto
name|ioError
goto|;
block|}
comment|/* Check the magic number */
if|if
condition|(
name|relocatedHead
operator|.
name|a_magic
operator|!=
name|OMAGIC
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad magic number in intermediate file \""
argument_list|,
name|relocatedFileName
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
comment|/* Make sure that memory allocation is still consistent */
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
operator|>
operator|(
name|unsigned
name|long
operator|)
name|startAddress
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"can't load, memory allocation is inconsistent."
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
comment|/* Make sure that the relocated module's size is reasonable */
name|relocatedSize
operator|=
name|relocatedHead
operator|.
name|a_text
operator|+
name|relocatedHead
operator|.
name|a_data
operator|+
name|relocatedHead
operator|.
name|a_bss
expr_stmt|;
if|if
condition|(
name|relocatedSize
operator|>
name|TCL_LOADMAX
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"module too big to load"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
comment|/* Advance the break to protect the loaded module */
operator|(
name|void
operator|)
name|brk
argument_list|(
name|startAddress
operator|+
name|relocatedSize
argument_list|)
expr_stmt|;
comment|/* Seek to the start of the module's text */
if|#
directive|if
name|defined
argument_list|(
name|__mips
argument_list|)
operator|||
name|defined
argument_list|(
name|mips
argument_list|)
name|status
operator|=
name|lseek
argument_list|(
name|relocatedFd
argument_list|,
name|N_TXTOFF
argument_list|(
name|relocatedHead
operator|.
name|ex_f
argument_list|,
name|relocatedHead
operator|.
name|ex_o
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
else|#
directive|else
name|status
operator|=
name|lseek
argument_list|(
name|relocatedFd
argument_list|,
name|N_TXTOFF
argument_list|(
name|relocatedHead
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
goto|goto
name|ioError
goto|;
block|}
comment|/* Read in the module's text and data */
name|relocatedSize
operator|=
name|relocatedHead
operator|.
name|a_text
operator|+
name|relocatedHead
operator|.
name|a_data
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|relocatedFd
argument_list|,
name|startAddress
argument_list|,
name|relocatedSize
argument_list|)
operator|<
name|relocatedSize
condition|)
block|{
name|brk
argument_list|(
name|startAddress
argument_list|)
expr_stmt|;
name|ioError
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"error on intermediate file \""
argument_list|,
name|relocatedFileName
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|failure
label|:
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|relocatedFileName
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/* Close the intermediate file. */
operator|(
name|void
operator|)
name|close
argument_list|(
name|relocatedFd
argument_list|)
expr_stmt|;
comment|/* Arrange things so that intermediate symbol tables eventually get    * deleted. */
if|if
condition|(
name|SymbolTableFile
operator|!=
name|NULL
condition|)
block|{
name|UnlinkSymbolTable
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|atexit
argument_list|(
name|UnlinkSymbolTable
argument_list|)
expr_stmt|;
block|}
name|SymbolTableFile
operator|=
name|ckalloc
argument_list|(
name|strlen
argument_list|(
name|relocatedFileName
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|SymbolTableFile
argument_list|,
name|relocatedFileName
argument_list|)
expr_stmt|;
comment|/* Look up the entry points in the load module's dictionary. */
name|dictionary
operator|=
operator|(
name|DictFn
operator|)
name|startAddress
expr_stmt|;
operator|*
name|proc1Ptr
operator|=
name|dictionary
argument_list|(
name|sym1
argument_list|)
expr_stmt|;
operator|*
name|proc2Ptr
operator|=
name|dictionary
argument_list|(
name|sym2
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *------------------------------------------------------------------------  *  * FindLibraries --  *  *	Find the libraries needed to link a load module at run time.  *  * Results:  *	A standard Tcl completion code.  If an error occurs,  *	an error message is left in interp->result.  The -l and -L flags  *	are concatenated onto the dynamic string `buf'.  *  *------------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|FindLibraries
parameter_list|(
name|interp
parameter_list|,
name|fileName
parameter_list|,
name|buf
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting */
name|char
modifier|*
name|fileName
decl_stmt|;
comment|/* Name of the load module */
name|Tcl_DString
modifier|*
name|buf
decl_stmt|;
comment|/* Buffer where the -l an -L flags */
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
comment|/* The load module */
name|int
name|c
decl_stmt|;
comment|/* Byte from the load module */
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Open the load module */
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|fileName
argument_list|,
literal|"rb"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't open \""
argument_list|,
name|fileName
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/* Search for the library list in the load module */
name|p
operator|=
literal|"@LIBS: "
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
operator|*
name|p
condition|)
block|{
operator|++
name|p
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
literal|"@LIBS: "
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|*
name|p
condition|)
block|{
operator|++
name|p
expr_stmt|;
block|}
block|}
block|}
comment|/* No library list -- this must be an ill-formed module */
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"File \""
argument_list|,
name|fileName
argument_list|,
literal|"\" is not a Tcl load module."
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/* Accumulate the library list */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
name|EOF
condition|)
block|{
name|char
name|cc
init|=
name|c
decl_stmt|;
name|Tcl_DStringAppend
argument_list|(
name|buf
argument_list|,
operator|&
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"Library directory in \""
argument_list|,
name|fileName
argument_list|,
literal|"\" ends prematurely."
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *------------------------------------------------------------------------  *  * UnlinkSymbolTable --  *  *	Remove the symbol table file from the last dynamic link.  *  * Results:  *	None.  *  * Side effects:  *	The symbol table file from the last dynamic link is removed.  *	This function is called when (a) a new symbol table is present  *	because another dynamic link is complete, or (b) the process  *	is exiting.  *------------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|UnlinkSymbolTable
parameter_list|()
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|SymbolTableFile
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|SymbolTableFile
argument_list|)
expr_stmt|;
name|SymbolTableFile
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclGuessPackageName --  *  *	If the "load" command is invoked without providing a package  *	name, this procedure is invoked to try to figure it out.  *  * Results:  *	Always returns 0 to indicate that we couldn't figure out a  *	package name;  generic code will then try to guess the package  *	from the file name.  A return value of 1 would have meant that  *	we figured out the package name and put it in bufPtr.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclGuessPackageName
parameter_list|(
name|fileName
parameter_list|,
name|bufPtr
parameter_list|)
name|char
modifier|*
name|fileName
decl_stmt|;
comment|/* Name of file containing package (already 				 * translated to local form if needed). */
name|Tcl_DString
modifier|*
name|bufPtr
decl_stmt|;
comment|/* Initialized empty dstring.  Append 				 * package name to this if possible. */
block|{
return|return
literal|0
return|;
block|}
end_function

end_unit

