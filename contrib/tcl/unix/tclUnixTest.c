begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclUnixTest.c --  *  *	Contains platform specific test commands for the Unix platform.  *  * Copyright (c) 1996 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclUnixTest.c 1.5 97/10/31 17:23:42  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * The following macros convert between TclFile's and fd's.  The conversion  * simple involves shifting fd's up by one to ensure that no valid fd is ever  * the same as NULL.  Note that this code is duplicated from tclUnixPipe.c  */
end_comment

begin_define
define|#
directive|define
name|MakeFile
parameter_list|(
name|fd
parameter_list|)
value|((TclFile)((fd)+1))
end_define

begin_define
define|#
directive|define
name|GetFd
parameter_list|(
name|file
parameter_list|)
value|(((int)file)-1)
end_define

begin_comment
comment|/*  * The stuff below is used to keep track of file handlers created and  * exercised by the "testfilehandler" command.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Pipe
block|{
name|TclFile
name|readFile
decl_stmt|;
comment|/* File handle for reading from the 				 * pipe.  NULL means pipe doesn't exist yet. */
name|TclFile
name|writeFile
decl_stmt|;
comment|/* File handle for writing from the 				 * pipe. */
name|int
name|readCount
decl_stmt|;
comment|/* Number of times the file handler for 				 * this file has triggered and the file 				 * was readable. */
name|int
name|writeCount
decl_stmt|;
comment|/* Number of times the file handler for 				 * this file has triggered and the file 				 * was writable. */
block|}
name|Pipe
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MAX_PIPES
value|10
end_define

begin_decl_stmt
specifier|static
name|Pipe
name|testPipes
index|[
name|MAX_PIPES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Forward declarations of procedures defined later in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|TestFileHandlerProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|int
name|mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestfilehandlerCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestfilewaitCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestgetopenfileCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|TclplatformtestInit
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclplatformtestInit --  *  *	Defines commands that test platform specific functionality for  *	Unix platforms.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Defines new commands.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclplatformtestInit
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to add commands to. */
block|{
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testfilehandler"
argument_list|,
name|TestfilehandlerCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testfilewait"
argument_list|,
name|TestfilewaitCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testgetopenfile"
argument_list|,
name|TestgetopenfileCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestfilehandlerCmd --  *  *	This procedure implements the "testfilehandler" command. It is  *	used to test Tcl_CreateFileHandler, Tcl_DeleteFileHandler, and  *	TclWaitForFile.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestfilehandlerCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Pipe
modifier|*
name|pipePtr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|mask
decl_stmt|,
name|timeout
decl_stmt|;
specifier|static
name|int
name|initialized
init|=
literal|0
decl_stmt|;
name|char
name|buffer
index|[
literal|4000
index|]
decl_stmt|;
name|TclFile
name|file
decl_stmt|;
comment|/*      * NOTE: When we make this code work on Windows also, the following      * variable needs to be made Unix-only.      */
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_PIPES
condition|;
name|i
operator|++
control|)
block|{
name|testPipes
index|[
name|i
index|]
operator|.
name|readFile
operator|=
name|NULL
expr_stmt|;
block|}
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" option ... \""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|pipePtr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|argc
operator|>=
literal|3
condition|)
block|{
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|i
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|i
operator|>=
name|MAX_PIPES
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad index "
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|pipePtr
operator|=
operator|&
name|testPipes
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"close"
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_PIPES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|testPipes
index|[
name|i
index|]
operator|.
name|readFile
operator|!=
name|NULL
condition|)
block|{
name|TclpCloseFile
argument_list|(
name|testPipes
index|[
name|i
index|]
operator|.
name|readFile
argument_list|)
expr_stmt|;
name|testPipes
index|[
name|i
index|]
operator|.
name|readFile
operator|=
name|NULL
expr_stmt|;
name|TclpCloseFile
argument_list|(
name|testPipes
index|[
name|i
index|]
operator|.
name|writeFile
argument_list|)
expr_stmt|;
name|testPipes
index|[
name|i
index|]
operator|.
name|writeFile
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"clear"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" clear index\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|pipePtr
operator|->
name|readCount
operator|=
name|pipePtr
operator|->
name|writeCount
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"counts"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" counts index\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d %d"
argument_list|,
name|pipePtr
operator|->
name|readCount
argument_list|,
name|pipePtr
operator|->
name|writeCount
argument_list|)
expr_stmt|;
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"create"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|5
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" create index readMode writeMode\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|pipePtr
operator|->
name|readFile
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|TclpCreatePipe
argument_list|(
operator|&
name|pipePtr
operator|->
name|readFile
argument_list|,
operator|&
name|pipePtr
operator|->
name|writeFile
argument_list|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't open pipe: "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
ifdef|#
directive|ifdef
name|O_NONBLOCK
name|fcntl
argument_list|(
name|GetFd
argument_list|(
name|pipePtr
operator|->
name|readFile
argument_list|)
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|GetFd
argument_list|(
name|pipePtr
operator|->
name|writeFile
argument_list|)
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
expr_stmt|;
else|#
directive|else
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"can't make pipes non-blocking"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
endif|#
directive|endif
block|}
name|pipePtr
operator|->
name|readCount
operator|=
literal|0
expr_stmt|;
name|pipePtr
operator|->
name|writeCount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|,
literal|"readable"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_CreateFileHandler
argument_list|(
name|GetFd
argument_list|(
name|pipePtr
operator|->
name|readFile
argument_list|)
argument_list|,
name|TCL_READABLE
argument_list|,
name|TestFileHandlerProc
argument_list|,
operator|(
name|ClientData
operator|)
name|pipePtr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_DeleteFileHandler
argument_list|(
name|GetFd
argument_list|(
name|pipePtr
operator|->
name|readFile
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|,
literal|"disabled"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_CreateFileHandler
argument_list|(
name|GetFd
argument_list|(
name|pipePtr
operator|->
name|readFile
argument_list|)
argument_list|,
literal|0
argument_list|,
name|TestFileHandlerProc
argument_list|,
operator|(
name|ClientData
operator|)
name|pipePtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad read mode \""
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|,
literal|"writable"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_CreateFileHandler
argument_list|(
name|GetFd
argument_list|(
name|pipePtr
operator|->
name|writeFile
argument_list|)
argument_list|,
name|TCL_WRITABLE
argument_list|,
name|TestFileHandlerProc
argument_list|,
operator|(
name|ClientData
operator|)
name|pipePtr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_DeleteFileHandler
argument_list|(
name|GetFd
argument_list|(
name|pipePtr
operator|->
name|writeFile
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|,
literal|"disabled"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_CreateFileHandler
argument_list|(
name|GetFd
argument_list|(
name|pipePtr
operator|->
name|writeFile
argument_list|)
argument_list|,
literal|0
argument_list|,
name|TestFileHandlerProc
argument_list|,
operator|(
name|ClientData
operator|)
name|pipePtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad read mode \""
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"empty"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" empty index\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
while|while
condition|(
name|read
argument_list|(
name|GetFd
argument_list|(
name|pipePtr
operator|->
name|readFile
argument_list|)
argument_list|,
name|buffer
argument_list|,
literal|4000
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Empty loop body. */
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"fill"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" empty index\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|memset
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|buffer
argument_list|,
literal|'a'
argument_list|,
literal|4000
argument_list|)
expr_stmt|;
while|while
condition|(
name|write
argument_list|(
name|GetFd
argument_list|(
name|pipePtr
operator|->
name|writeFile
argument_list|)
argument_list|,
name|buffer
argument_list|,
literal|4000
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Empty loop body. */
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"fillpartial"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" empty index\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|memset
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|buffer
argument_list|,
literal|'b'
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|write
argument_list|(
name|GetFd
argument_list|(
name|pipePtr
operator|->
name|writeFile
argument_list|)
argument_list|,
name|buffer
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"oneevent"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_DoOneEvent
argument_list|(
name|TCL_FILE_EVENTS
operator||
name|TCL_DONT_WAIT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"wait"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|5
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" wait index readable/writable timeout\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|pipePtr
operator|->
name|readFile
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"pipe "
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|" doesn't exist"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|,
literal|"readable"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mask
operator|=
name|TCL_READABLE
expr_stmt|;
name|file
operator|=
name|pipePtr
operator|->
name|readFile
expr_stmt|;
block|}
else|else
block|{
name|mask
operator|=
name|TCL_WRITABLE
expr_stmt|;
name|file
operator|=
name|pipePtr
operator|->
name|writeFile
expr_stmt|;
block|}
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
operator|&
name|timeout
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|i
operator|=
name|TclUnixWaitForFile
argument_list|(
name|GetFd
argument_list|(
name|file
argument_list|)
argument_list|,
name|mask
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|TCL_READABLE
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"readable"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|&
name|TCL_WRITABLE
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"writable"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"windowevent"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_DoOneEvent
argument_list|(
name|TCL_WINDOW_EVENTS
operator||
name|TCL_DONT_WAIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": must be close, clear, counts, create, empty, fill, "
argument_list|,
literal|"fillpartial, oneevent, wait, or windowevent"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|TestFileHandlerProc
parameter_list|(
name|clientData
parameter_list|,
name|mask
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Points to a Pipe structure. */
name|int
name|mask
decl_stmt|;
comment|/* Indicates which events happened: 				 * TCL_READABLE or TCL_WRITABLE. */
block|{
name|Pipe
modifier|*
name|pipePtr
init|=
operator|(
name|Pipe
operator|*
operator|)
name|clientData
decl_stmt|;
if|if
condition|(
name|mask
operator|&
name|TCL_READABLE
condition|)
block|{
name|pipePtr
operator|->
name|readCount
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|TCL_WRITABLE
condition|)
block|{
name|pipePtr
operator|->
name|writeCount
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestfilewaitCmd --  *  *	This procedure implements the "testfilewait" command. It is  *	used to test TclUnixWaitForFile.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestfilewaitCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|mask
decl_stmt|,
name|result
decl_stmt|,
name|timeout
decl_stmt|;
name|Tcl_Channel
name|channel
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|ClientData
name|data
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" file readable|writable|both timeout\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|channel
operator|=
name|Tcl_GetChannel
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"readable"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mask
operator|=
name|TCL_READABLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"writable"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mask
operator|=
name|TCL_WRITABLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"both"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mask
operator|=
name|TCL_WRITABLE
operator||
name|TCL_READABLE
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad argument \""
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"\": must be readable, writable, or both"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetChannelHandle
argument_list|(
name|channel
argument_list|,
operator|(
name|mask
operator|&
name|TCL_READABLE
operator|)
condition|?
name|TCL_READABLE
else|:
name|TCL_WRITABLE
argument_list|,
operator|(
name|ClientData
operator|*
operator|)
operator|&
name|data
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't get channel file"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|fd
operator|=
operator|(
name|int
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
operator|&
name|timeout
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|result
operator|=
name|TclUnixWaitForFile
argument_list|(
name|fd
argument_list|,
name|mask
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|&
name|TCL_READABLE
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"readable"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|&
name|TCL_WRITABLE
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"writable"
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestgetopenfileCmd --  *  *	This procedure implements the "testgetopenfile" command. It is  *	used to get a FILE * value from a registered channel.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestgetopenfileCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|ClientData
name|filePtr
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" channelName forWriting\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetOpenFile
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|atoi
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|filePtr
argument_list|)
operator|==
name|TCL_ERROR
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|filePtr
operator|==
operator|(
name|ClientData
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"Tcl_GetOpenFile succeeded but FILE * NULL!"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

end_unit

