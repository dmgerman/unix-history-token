begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclLoadDl.c --  *  *	This procedure provides a version of the TclLoadFile that  *	works with the "dlopen" and "dlsym" library procedures for  *	dynamic loading.  *  * Copyright (c) 1995 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclLoadDl.c 1.8 96/12/03 16:57:00  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NO_DLFCN_H
end_ifdef

begin_include
include|#
directive|include
file|"../compat/dlfcn.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * In some systems, like SunOS 4.1.3, the RTLD_NOW flag isn't defined  * and this argument to dlopen must always be 1.  The RTLD_GLOBAL  * flag is needed on some systems (e.g. SCO and UnixWare) but doesn't  * exist on others;  if it doesn't exist, set it to 0 so it has no effect.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RTLD_NOW
end_ifndef

begin_define
define|#
directive|define
name|RTLD_NOW
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RTLD_GLOBAL
end_ifndef

begin_define
define|#
directive|define
name|RTLD_GLOBAL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclLoadFile --  *  *	Dynamically loads a binary code file into memory and returns  *	the addresses of two procedures within that file, if they  *	are defined.  *  * Results:  *	A standard Tcl completion code.  If an error occurs, an error  *	message is left in interp->result.  *proc1Ptr and *proc2Ptr  *	are filled in with the addresses of the symbols given by  *	*sym1 and *sym2, or NULL if those symbols can't be found.  *  * Side effects:  *	New code suddenly appears in memory.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclLoadFile
parameter_list|(
name|interp
parameter_list|,
name|fileName
parameter_list|,
name|sym1
parameter_list|,
name|sym2
parameter_list|,
name|proc1Ptr
parameter_list|,
name|proc2Ptr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|char
modifier|*
name|fileName
decl_stmt|;
comment|/* Name of the file containing the desired 				 * code. */
name|char
modifier|*
name|sym1
decl_stmt|,
decl|*
name|sym2
decl_stmt|;
end_function

begin_comment
comment|/* Names of two procedures to look up in 				 * the file's symbol table. */
end_comment

begin_decl_stmt
name|Tcl_PackageInitProc
modifier|*
modifier|*
name|proc1Ptr
decl_stmt|,
modifier|*
modifier|*
name|proc2Ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where to return the addresses corresponding 				 * to sym1 and sym2. */
end_comment

begin_block
block|{
name|VOID
modifier|*
name|handle
decl_stmt|;
name|Tcl_DString
name|newName
decl_stmt|;
name|handle
operator|=
name|dlopen
argument_list|(
name|fileName
argument_list|,
name|RTLD_NOW
operator||
name|RTLD_GLOBAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't load file \""
argument_list|,
name|fileName
argument_list|,
literal|"\": "
argument_list|,
name|dlerror
argument_list|()
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*       * Some platforms still add an underscore to the beginning of symbol      * names.  If we can't find a name without an underscore, try again      * with the underscore.      */
operator|*
name|proc1Ptr
operator|=
operator|(
name|Tcl_PackageInitProc
operator|*
operator|)
name|dlsym
argument_list|(
name|handle
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sym1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|proc1Ptr
operator|==
name|NULL
condition|)
block|{
name|Tcl_DStringInit
argument_list|(
operator|&
name|newName
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|newName
argument_list|,
literal|"_"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|newName
argument_list|,
name|sym1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|proc1Ptr
operator|=
operator|(
name|Tcl_PackageInitProc
operator|*
operator|)
name|dlsym
argument_list|(
name|handle
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|newName
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|newName
argument_list|)
expr_stmt|;
block|}
operator|*
name|proc2Ptr
operator|=
operator|(
name|Tcl_PackageInitProc
operator|*
operator|)
name|dlsym
argument_list|(
name|handle
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sym2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|proc2Ptr
operator|==
name|NULL
condition|)
block|{
name|Tcl_DStringInit
argument_list|(
operator|&
name|newName
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|newName
argument_list|,
literal|"_"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|newName
argument_list|,
name|sym2
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|proc2Ptr
operator|=
operator|(
name|Tcl_PackageInitProc
operator|*
operator|)
name|dlsym
argument_list|(
name|handle
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|newName
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|newName
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclGuessPackageName --  *  *	If the "load" command is invoked without providing a package  *	name, this procedure is invoked to try to figure it out.  *  * Results:  *	Always returns 0 to indicate that we couldn't figure out a  *	package name;  generic code will then try to guess the package  *	from the file name.  A return value of 1 would have meant that  *	we figured out the package name and put it in bufPtr.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclGuessPackageName
parameter_list|(
name|fileName
parameter_list|,
name|bufPtr
parameter_list|)
name|char
modifier|*
name|fileName
decl_stmt|;
comment|/* Name of file containing package (already 				 * translated to local form if needed). */
name|Tcl_DString
modifier|*
name|bufPtr
decl_stmt|;
comment|/* Initialized empty dstring.  Append 				 * package name to this if possible. */
block|{
return|return
literal|0
return|;
block|}
end_function

end_unit

