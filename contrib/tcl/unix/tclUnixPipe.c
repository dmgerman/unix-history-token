begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclUnixPipe.c --  *  *	This file implements the UNIX-specific exec pipeline functions,  *	the "pipe" channel driver, and the "pid" Tcl command.  *  * Copyright (c) 1991-1994 The Regents of the University of California.  * Copyright (c) 1994-1997 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclUnixPipe.c 1.37 97/10/31 17:23:37  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * The following macros convert between TclFile's and fd's.  The conversion  * simple involves shifting fd's up by one to ensure that no valid fd is ever  * the same as NULL.  */
end_comment

begin_define
define|#
directive|define
name|MakeFile
parameter_list|(
name|fd
parameter_list|)
value|((TclFile)(((int)fd)+1))
end_define

begin_define
define|#
directive|define
name|GetFd
parameter_list|(
name|file
parameter_list|)
value|(((int)file)-1)
end_define

begin_comment
comment|/*  * This structure describes per-instance state of a pipe based channel.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|PipeState
block|{
name|Tcl_Channel
name|channel
decl_stmt|;
comment|/* Channel associated with this file. */
name|TclFile
name|inFile
decl_stmt|;
comment|/* Output from pipe. */
name|TclFile
name|outFile
decl_stmt|;
comment|/* Input to pipe. */
name|TclFile
name|errorFile
decl_stmt|;
comment|/* Error output from pipe. */
name|int
name|numPids
decl_stmt|;
comment|/* How many processes are attached to this pipe? */
name|Tcl_Pid
modifier|*
name|pidPtr
decl_stmt|;
comment|/* The process IDs themselves. Allocated by                          * the creator of the pipe. */
name|int
name|isNonBlocking
decl_stmt|;
comment|/* Nonzero when the pipe is in nonblocking mode.                          * Used to decide whether to wait for the children                          * at close time. */
block|}
name|PipeState
typedef|;
end_typedef

begin_comment
comment|/*  * Declarations for local procedures defined in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|PipeBlockModeProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|int
name|mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|PipeCloseProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|PipeGetHandleProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|int
name|direction
operator|,
name|ClientData
operator|*
name|handlePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|PipeInputProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|char
operator|*
name|buf
operator|,
name|int
name|toRead
operator|,
name|int
operator|*
name|errorCode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|PipeOutputProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|char
operator|*
name|buf
operator|,
name|int
name|toWrite
operator|,
name|int
operator|*
name|errorCode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|PipeWatchProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|int
name|mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|RestoreSignals
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SetupStdFile
name|_ANSI_ARGS_
argument_list|(
operator|(
name|TclFile
name|file
operator|,
name|int
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This structure describes the channel type structure for command pipe  * based IO:  */
end_comment

begin_decl_stmt
specifier|static
name|Tcl_ChannelType
name|pipeChannelType
init|=
block|{
literal|"pipe"
block|,
comment|/* Type name. */
name|PipeBlockModeProc
block|,
comment|/* Set blocking/nonblocking mode.*/
name|PipeCloseProc
block|,
comment|/* Close proc. */
name|PipeInputProc
block|,
comment|/* Input proc. */
name|PipeOutputProc
block|,
comment|/* Output proc. */
name|NULL
block|,
comment|/* Seek proc. */
name|NULL
block|,
comment|/* Set option proc. */
name|NULL
block|,
comment|/* Get option proc. */
name|PipeWatchProc
block|,
comment|/* Initialize notifier. */
name|PipeGetHandleProc
block|,
comment|/* Get OS handles out of channel. */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclpMakeFile --  *  *	Make a TclFile from a channel.  *  * Results:  *	Returns a new TclFile or NULL on failure.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|TclFile
name|TclpMakeFile
parameter_list|(
name|channel
parameter_list|,
name|direction
parameter_list|)
name|Tcl_Channel
name|channel
decl_stmt|;
comment|/* Channel to get file from. */
name|int
name|direction
decl_stmt|;
comment|/* Either TCL_READABLE or TCL_WRITABLE. */
block|{
name|ClientData
name|data
decl_stmt|;
if|if
condition|(
name|Tcl_GetChannelHandle
argument_list|(
name|channel
argument_list|,
name|direction
argument_list|,
operator|(
name|ClientData
operator|*
operator|)
operator|&
name|data
argument_list|)
operator|==
name|TCL_OK
condition|)
block|{
return|return
name|MakeFile
argument_list|(
operator|(
name|int
operator|)
name|data
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|TclFile
operator|)
name|NULL
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclpOpenFile --  *  *	Open a file for use in a pipeline.    *  * Results:  *	Returns a new TclFile handle or NULL on failure.  *  * Side effects:  *	May cause a file to be created on the file system.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|TclFile
name|TclpOpenFile
parameter_list|(
name|fname
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* The name of the file to open. */
name|int
name|mode
decl_stmt|;
comment|/* In what mode to open the file? */
block|{
name|int
name|fd
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|mode
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
comment|/* 	 * If the file is being opened for writing, seek to the end 	 * so we can append to any data already in the file. 	 */
if|if
condition|(
name|mode
operator|&
name|O_WRONLY
condition|)
block|{
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Increment the fd so it can't be 0, which would conflict with 	 * the NULL return for errors. 	 */
return|return
name|MakeFile
argument_list|(
name|fd
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclpCreateTempFile --  *  *	This function creates a temporary file initialized with an  *	optional string, and returns a file handle with the file pointer  *	at the beginning of the file.  *  * Results:  *	A handle to a file.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|TclFile
name|TclpCreateTempFile
parameter_list|(
name|contents
parameter_list|,
name|namePtr
parameter_list|)
name|char
modifier|*
name|contents
decl_stmt|;
comment|/* String to write into temp file, or NULL. */
name|Tcl_DString
modifier|*
name|namePtr
decl_stmt|;
comment|/* If non-NULL, pointer to initialized  				 * DString that is filled with the name of  				 * the temp file that was created. */
block|{
name|char
name|fileName
index|[
name|L_tmpnam
index|]
decl_stmt|;
name|TclFile
name|file
decl_stmt|;
name|size_t
name|length
init|=
operator|(
name|contents
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|contents
argument_list|)
decl_stmt|;
name|tmpnam
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
name|file
operator|=
name|TclpOpenFile
argument_list|(
name|fileName
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|file
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|length
operator|>
literal|0
operator|)
condition|)
block|{
name|int
name|fd
init|=
name|GetFd
argument_list|(
name|file
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|contents
argument_list|,
name|length
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|namePtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|namePtr
argument_list|,
name|fileName
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|file
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclpCreatePipe --  *  *      Creates a pipe - simply calls the pipe() function.  *  * Results:  *      Returns 1 on success, 0 on failure.   *  * Side effects:  *      Creates a pipe.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclpCreatePipe
parameter_list|(
name|readPipe
parameter_list|,
name|writePipe
parameter_list|)
name|TclFile
modifier|*
name|readPipe
decl_stmt|;
comment|/* Location to store file handle for 				 * read side of pipe. */
name|TclFile
modifier|*
name|writePipe
decl_stmt|;
comment|/* Location to store file handle for 				 * write side of pipe. */
block|{
name|int
name|pipeIds
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|pipeIds
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|fcntl
argument_list|(
name|pipeIds
index|[
literal|0
index|]
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|pipeIds
index|[
literal|1
index|]
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
operator|*
name|readPipe
operator|=
name|MakeFile
argument_list|(
name|pipeIds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|*
name|writePipe
operator|=
name|MakeFile
argument_list|(
name|pipeIds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclpCloseFile --  *  *	Implements a mechanism to close a UNIX file.  *  * Results:  *	Returns 0 on success, or -1 on error, setting errno.  *  * Side effects:  *	The file is closed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclpCloseFile
parameter_list|(
name|file
parameter_list|)
name|TclFile
name|file
decl_stmt|;
comment|/* The file to close. */
block|{
name|int
name|fd
init|=
name|GetFd
argument_list|(
name|file
argument_list|)
decl_stmt|;
comment|/*      * Refuse to close the fds for stdin, stdout and stderr.      */
if|if
condition|(
operator|(
name|fd
operator|==
literal|0
operator|)
operator|||
operator|(
name|fd
operator|==
literal|1
operator|)
operator|||
operator|(
name|fd
operator|==
literal|2
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
name|Tcl_DeleteFileHandler
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|close
argument_list|(
name|fd
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclpCreateProcess --  *  *	Create a child process that has the specified files as its   *	standard input, output, and error.  The child process runs  *	asynchronously and runs with the same environment variables  *	as the creating process.  *  *	The path is searched to find the specified executable.    *  * Results:  *	The return value is TCL_ERROR and an error message is left in  *	interp->result if there was a problem creating the child   *	process.  Otherwise, the return value is TCL_OK and *pidPtr is  *	filled with the process id of the child process.  *   * Side effects:  *	A process is created.  *	  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|TclpCreateProcess
parameter_list|(
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|inputFile
parameter_list|,
name|outputFile
parameter_list|,
name|errorFile
parameter_list|,
name|pidPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to leave errors that 				 * occurred when creating the child process. 				 * Error messages from the child process 				 * itself are sent to errorFile. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments in following array. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Array of argument strings.  argv[0] 				 * contains the name of the executable 				 * converted to native format (using the 				 * Tcl_TranslateFileName call).  Additional 				 * arguments have not been converted. */
name|TclFile
name|inputFile
decl_stmt|;
comment|/* If non-NULL, gives the file to use as 				 * input for the child process.  If inputFile 				 * file is not readable or is NULL, the child 				 * will receive no standard input. */
name|TclFile
name|outputFile
decl_stmt|;
comment|/* If non-NULL, gives the file that 				 * receives output from the child process.  If 				 * outputFile file is not writeable or is 				 * NULL, output from the child will be 				 * discarded. */
name|TclFile
name|errorFile
decl_stmt|;
comment|/* If non-NULL, gives the file that 				 * receives errors from the child process.  If 				 * errorFile file is not writeable or is NULL, 				 * errors from the child will be discarded. 				 * errorFile may be the same as outputFile. */
name|Tcl_Pid
modifier|*
name|pidPtr
decl_stmt|;
comment|/* If this procedure is successful, pidPtr 				 * is filled with the process id of the child 				 * process. */
block|{
name|TclFile
name|errPipeIn
decl_stmt|,
name|errPipeOut
decl_stmt|;
name|int
name|joinThisError
decl_stmt|,
name|count
decl_stmt|,
name|status
decl_stmt|,
name|fd
decl_stmt|;
name|char
name|errSpace
index|[
literal|200
index|]
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|errPipeIn
operator|=
name|NULL
expr_stmt|;
name|errPipeOut
operator|=
name|NULL
expr_stmt|;
name|pid
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*      * Create a pipe that the child can use to return error      * information if anything goes wrong.      */
if|if
condition|(
name|TclpCreatePipe
argument_list|(
operator|&
name|errPipeIn
argument_list|,
operator|&
name|errPipeOut
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't create pipe: "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|joinThisError
operator|=
operator|(
name|errorFile
operator|==
name|outputFile
operator|)
expr_stmt|;
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|fd
operator|=
name|GetFd
argument_list|(
name|errPipeOut
argument_list|)
expr_stmt|;
comment|/* 	 * Set up stdio file handles for the child process. 	 */
if|if
condition|(
operator|!
name|SetupStdFile
argument_list|(
name|inputFile
argument_list|,
name|TCL_STDIN
argument_list|)
operator|||
operator|!
name|SetupStdFile
argument_list|(
name|outputFile
argument_list|,
name|TCL_STDOUT
argument_list|)
operator|||
operator|(
operator|!
name|joinThisError
operator|&&
operator|!
name|SetupStdFile
argument_list|(
name|errorFile
argument_list|,
name|TCL_STDERR
argument_list|)
operator|)
operator|||
operator|(
name|joinThisError
operator|&&
operator|(
operator|(
name|dup2
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|fcntl
argument_list|(
literal|2
argument_list|,
name|F_SETFD
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|errSpace
argument_list|,
literal|"%dforked process couldn't set up input/output: "
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
name|errSpace
argument_list|,
operator|(
name|size_t
operator|)
name|strlen
argument_list|(
name|errSpace
argument_list|)
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Close the input side of the error pipe. 	 */
name|RestoreSignals
argument_list|()
expr_stmt|;
name|execvp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|errSpace
argument_list|,
literal|"%dcouldn't execute \"%.150s\": "
argument_list|,
name|errno
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
name|errSpace
argument_list|,
operator|(
name|size_t
operator|)
name|strlen
argument_list|(
name|errSpace
argument_list|)
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't fork child process: "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/*      * Read back from the error pipe to see if the child started      * up OK.  The info in the pipe (if any) consists of a decimal      * errno value followed by an error message.      */
name|TclpCloseFile
argument_list|(
name|errPipeOut
argument_list|)
expr_stmt|;
name|errPipeOut
operator|=
name|NULL
expr_stmt|;
name|fd
operator|=
name|GetFd
argument_list|(
name|errPipeIn
argument_list|)
expr_stmt|;
name|count
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|errSpace
argument_list|,
call|(
name|size_t
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|errSpace
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|errSpace
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
name|errno
operator|=
name|strtol
argument_list|(
name|errSpace
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|end
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|TclpCloseFile
argument_list|(
name|errPipeIn
argument_list|)
expr_stmt|;
operator|*
name|pidPtr
operator|=
operator|(
name|Tcl_Pid
operator|)
name|pid
expr_stmt|;
return|return
name|TCL_OK
return|;
name|error
label|:
if|if
condition|(
name|pid
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 	 * Reap the child process now if an error occurred during its 	 * startup. 	 */
name|Tcl_WaitPid
argument_list|(
operator|(
name|Tcl_Pid
operator|)
name|pid
argument_list|,
operator|&
name|status
argument_list|,
name|WNOHANG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errPipeIn
condition|)
block|{
name|TclpCloseFile
argument_list|(
name|errPipeIn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errPipeOut
condition|)
block|{
name|TclpCloseFile
argument_list|(
name|errPipeOut
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * RestoreSignals --  *  *      This procedure is invoked in a forked child process just before  *      exec-ing a new program to restore all signals to their default  *      settings.  *  * Results:  *      None.  *  * Side effects:  *      Signal settings get changed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|RestoreSignals
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|SIGABRT
name|signal
argument_list|(
name|SIGABRT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGALRM
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGFPE
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGILL
name|signal
argument_list|(
name|SIGILL
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGINT
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGSEGV
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGUSR1
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGUSR2
name|signal
argument_list|(
name|SIGUSR2
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGCHLD
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGCONT
name|signal
argument_list|(
name|SIGCONT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTSTP
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTTIN
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTTOU
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SetupStdFile --  *  *	Set up stdio file handles for the child process, using the  *	current standard channels if no other files are specified.  *	If no standard channel is defined, or if no file is associated  *	with the channel, then the corresponding standard fd is closed.  *  * Results:  *	Returns 1 on success, or 0 on failure.  *  * Side effects:  *	Replaces stdio fds.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SetupStdFile
parameter_list|(
name|file
parameter_list|,
name|type
parameter_list|)
name|TclFile
name|file
decl_stmt|;
comment|/* File to dup, or NULL. */
name|int
name|type
decl_stmt|;
comment|/* One of TCL_STDIN, TCL_STDOUT, TCL_STDERR */
block|{
name|Tcl_Channel
name|channel
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|targetFd
init|=
literal|0
decl_stmt|;
comment|/* Initializations here needed only to */
name|int
name|direction
init|=
literal|0
decl_stmt|;
comment|/* prevent warnings about using uninitialized 				 * variables. */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TCL_STDIN
case|:
name|targetFd
operator|=
literal|0
expr_stmt|;
name|direction
operator|=
name|TCL_READABLE
expr_stmt|;
break|break;
case|case
name|TCL_STDOUT
case|:
name|targetFd
operator|=
literal|1
expr_stmt|;
name|direction
operator|=
name|TCL_WRITABLE
expr_stmt|;
break|break;
case|case
name|TCL_STDERR
case|:
name|targetFd
operator|=
literal|2
expr_stmt|;
name|direction
operator|=
name|TCL_WRITABLE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|file
condition|)
block|{
name|channel
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
condition|)
block|{
name|file
operator|=
name|TclpMakeFile
argument_list|(
name|channel
argument_list|,
name|direction
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|file
condition|)
block|{
name|fd
operator|=
name|GetFd
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
name|targetFd
condition|)
block|{
if|if
condition|(
name|dup2
argument_list|(
name|fd
argument_list|,
name|targetFd
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/*              * Must clear the close-on-exec flag for the target FD, since              * some systems (e.g. Ultrix) do not clear the CLOEXEC flag on              * the target FD.              */
name|fcntl
argument_list|(
name|targetFd
argument_list|,
name|F_SETFD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|result
decl_stmt|;
comment|/* 	     * Since we aren't dup'ing the file, we need to explicitly clear 	     * the close-on-exec flag. 	     */
name|result
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|close
argument_list|(
name|targetFd
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclpCreateCommandChannel --  *  *	This function is called by the generic IO level to perform  *	the platform specific channel initialization for a command  *	channel.  *  * Results:  *	Returns a new channel or NULL on failure.  *  * Side effects:  *	Allocates a new channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Channel
name|TclpCreateCommandChannel
parameter_list|(
name|readFile
parameter_list|,
name|writeFile
parameter_list|,
name|errorFile
parameter_list|,
name|numPids
parameter_list|,
name|pidPtr
parameter_list|)
name|TclFile
name|readFile
decl_stmt|;
comment|/* If non-null, gives the file for reading. */
name|TclFile
name|writeFile
decl_stmt|;
comment|/* If non-null, gives the file for writing. */
name|TclFile
name|errorFile
decl_stmt|;
comment|/* If non-null, gives the file where errors 				 * can be read. */
name|int
name|numPids
decl_stmt|;
comment|/* The number of pids in the pid array. */
name|Tcl_Pid
modifier|*
name|pidPtr
decl_stmt|;
comment|/* An array of process identifiers.                                  * Allocated by the caller, freed when                                  * the channel is closed or the processes                                  * are detached (in a background exec). */
block|{
name|char
name|channelName
index|[
literal|20
index|]
decl_stmt|;
name|int
name|channelId
decl_stmt|;
name|PipeState
modifier|*
name|statePtr
init|=
operator|(
name|PipeState
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|PipeState
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|statePtr
operator|->
name|inFile
operator|=
name|readFile
expr_stmt|;
name|statePtr
operator|->
name|outFile
operator|=
name|writeFile
expr_stmt|;
name|statePtr
operator|->
name|errorFile
operator|=
name|errorFile
expr_stmt|;
name|statePtr
operator|->
name|numPids
operator|=
name|numPids
expr_stmt|;
name|statePtr
operator|->
name|pidPtr
operator|=
name|pidPtr
expr_stmt|;
name|statePtr
operator|->
name|isNonBlocking
operator|=
literal|0
expr_stmt|;
name|mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|readFile
condition|)
block|{
name|mode
operator||=
name|TCL_READABLE
expr_stmt|;
block|}
if|if
condition|(
name|writeFile
condition|)
block|{
name|mode
operator||=
name|TCL_WRITABLE
expr_stmt|;
block|}
comment|/*      * Use one of the fds associated with the channel as the      * channel id.      */
if|if
condition|(
name|readFile
condition|)
block|{
name|channelId
operator|=
name|GetFd
argument_list|(
name|readFile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|writeFile
condition|)
block|{
name|channelId
operator|=
name|GetFd
argument_list|(
name|writeFile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errorFile
condition|)
block|{
name|channelId
operator|=
name|GetFd
argument_list|(
name|errorFile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|channelId
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * For backward compatibility with previous versions of Tcl, we      * use "file%d" as the base name for pipes even though it would      * be more natural to use "pipe%d".      */
name|sprintf
argument_list|(
name|channelName
argument_list|,
literal|"file%d"
argument_list|,
name|channelId
argument_list|)
expr_stmt|;
name|statePtr
operator|->
name|channel
operator|=
name|Tcl_CreateChannel
argument_list|(
operator|&
name|pipeChannelType
argument_list|,
name|channelName
argument_list|,
operator|(
name|ClientData
operator|)
name|statePtr
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|statePtr
operator|->
name|channel
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclGetAndDetachPids --  *  *	This procedure is invoked in the generic implementation of a  *	background "exec" (An exec when invoked with a terminating "&")  *	to store a list of the PIDs for processes in a command pipeline  *	in interp->result and to detach the processes.  *  * Results:  *	None.  *  * Side effects:  *	Modifies interp->result. Detaches processes.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclGetAndDetachPids
parameter_list|(
name|interp
parameter_list|,
name|chan
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
name|Tcl_Channel
name|chan
decl_stmt|;
block|{
name|PipeState
modifier|*
name|pipePtr
decl_stmt|;
name|Tcl_ChannelType
modifier|*
name|chanTypePtr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
comment|/*      * Punt if the channel is not a command channel.      */
name|chanTypePtr
operator|=
name|Tcl_GetChannelType
argument_list|(
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|chanTypePtr
operator|!=
operator|&
name|pipeChannelType
condition|)
block|{
return|return;
block|}
name|pipePtr
operator|=
operator|(
name|PipeState
operator|*
operator|)
name|Tcl_GetChannelInstanceData
argument_list|(
name|chan
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pipePtr
operator|->
name|numPids
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld"
argument_list|,
name|TclpGetPid
argument_list|(
name|pipePtr
operator|->
name|pidPtr
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|Tcl_DetachPids
argument_list|(
literal|1
argument_list|,
operator|&
operator|(
name|pipePtr
operator|->
name|pidPtr
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pipePtr
operator|->
name|numPids
operator|>
literal|0
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pipePtr
operator|->
name|pidPtr
argument_list|)
expr_stmt|;
name|pipePtr
operator|->
name|numPids
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * PipeBlockModeProc --  *  *	Helper procedure to set blocking and nonblocking modes on a  *	pipe based channel. Invoked by generic IO level code.  *  * Results:  *	0 if successful, errno when failed.  *  * Side effects:  *	Sets the device into blocking or non-blocking mode.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|PipeBlockModeProc
parameter_list|(
name|instanceData
parameter_list|,
name|mode
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* Pipe state. */
name|int
name|mode
decl_stmt|;
comment|/* The mode to set. Can be one of                                          * TCL_MODE_BLOCKING or                                          * TCL_MODE_NONBLOCKING. */
block|{
name|PipeState
modifier|*
name|psPtr
init|=
operator|(
name|PipeState
operator|*
operator|)
name|instanceData
decl_stmt|;
name|int
name|curStatus
decl_stmt|;
name|int
name|fd
decl_stmt|;
ifndef|#
directive|ifndef
name|USE_FIONBIO
if|if
condition|(
name|psPtr
operator|->
name|inFile
condition|)
block|{
name|fd
operator|=
name|GetFd
argument_list|(
name|psPtr
operator|->
name|inFile
argument_list|)
expr_stmt|;
name|curStatus
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|TCL_MODE_BLOCKING
condition|)
block|{
name|curStatus
operator|&=
operator|(
operator|~
operator|(
name|O_NONBLOCK
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|curStatus
operator||=
name|O_NONBLOCK
expr_stmt|;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|curStatus
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|errno
return|;
block|}
name|curStatus
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|psPtr
operator|->
name|outFile
condition|)
block|{
name|fd
operator|=
name|GetFd
argument_list|(
name|psPtr
operator|->
name|outFile
argument_list|)
expr_stmt|;
name|curStatus
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|TCL_MODE_BLOCKING
condition|)
block|{
name|curStatus
operator|&=
operator|(
operator|~
operator|(
name|O_NONBLOCK
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|curStatus
operator||=
name|O_NONBLOCK
expr_stmt|;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|curStatus
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|errno
return|;
block|}
block|}
endif|#
directive|endif
comment|/* !FIONBIO */
ifdef|#
directive|ifdef
name|USE_FIONBIO
if|if
condition|(
name|psPtr
operator|->
name|inFile
condition|)
block|{
name|fd
operator|=
name|GetFd
argument_list|(
name|psPtr
operator|->
name|inFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|TCL_MODE_BLOCKING
condition|)
block|{
name|curStatus
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|curStatus
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
operator|(
name|int
operator|)
name|FIONBIO
argument_list|,
operator|&
name|curStatus
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|errno
return|;
block|}
block|}
if|if
condition|(
name|psPtr
operator|->
name|outFile
operator|!=
name|NULL
condition|)
block|{
name|fd
operator|=
name|GetFd
argument_list|(
name|psPtr
operator|->
name|outFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|TCL_MODE_BLOCKING
condition|)
block|{
name|curStatus
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|curStatus
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
operator|(
name|int
operator|)
name|FIONBIO
argument_list|,
operator|&
name|curStatus
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|errno
return|;
block|}
block|}
endif|#
directive|endif
comment|/* USE_FIONBIO */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * PipeCloseProc --  *  *	This procedure is invoked by the generic IO level to perform  *	channel-type-specific cleanup when a command pipeline channel  *	is closed.  *  * Results:  *	0 on success, errno otherwise.  *  * Side effects:  *	Closes the command pipeline channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|PipeCloseProc
parameter_list|(
name|instanceData
parameter_list|,
name|interp
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* The pipe to close. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* For error reporting. */
block|{
name|PipeState
modifier|*
name|pipePtr
decl_stmt|;
name|Tcl_Channel
name|errChan
decl_stmt|;
name|int
name|errorCode
decl_stmt|,
name|result
decl_stmt|;
name|errorCode
operator|=
literal|0
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|pipePtr
operator|=
operator|(
name|PipeState
operator|*
operator|)
name|instanceData
expr_stmt|;
if|if
condition|(
name|pipePtr
operator|->
name|inFile
condition|)
block|{
if|if
condition|(
name|TclpCloseFile
argument_list|(
name|pipePtr
operator|->
name|inFile
argument_list|)
operator|<
literal|0
condition|)
block|{
name|errorCode
operator|=
name|errno
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pipePtr
operator|->
name|outFile
condition|)
block|{
if|if
condition|(
operator|(
name|TclpCloseFile
argument_list|(
name|pipePtr
operator|->
name|outFile
argument_list|)
operator|<
literal|0
operator|)
operator|&&
operator|(
name|errorCode
operator|==
literal|0
operator|)
condition|)
block|{
name|errorCode
operator|=
name|errno
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pipePtr
operator|->
name|isNonBlocking
operator|||
name|TclInExit
argument_list|()
condition|)
block|{
comment|/*          * If the channel is non-blocking or Tcl is being cleaned up, just          * detach the children PIDs, reap them (important if we are in a          * dynamic load module), and discard the errorFile.          */
name|Tcl_DetachPids
argument_list|(
name|pipePtr
operator|->
name|numPids
argument_list|,
name|pipePtr
operator|->
name|pidPtr
argument_list|)
expr_stmt|;
name|Tcl_ReapDetachedProcs
argument_list|()
expr_stmt|;
if|if
condition|(
name|pipePtr
operator|->
name|errorFile
condition|)
block|{
name|TclpCloseFile
argument_list|(
name|pipePtr
operator|->
name|errorFile
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*          * Wrap the error file into a channel and give it to the cleanup          * routine.          */
if|if
condition|(
name|pipePtr
operator|->
name|errorFile
condition|)
block|{
name|errChan
operator|=
name|Tcl_MakeFileChannel
argument_list|(
operator|(
name|ClientData
operator|)
name|GetFd
argument_list|(
name|pipePtr
operator|->
name|errorFile
argument_list|)
argument_list|,
name|TCL_READABLE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errChan
operator|=
name|NULL
expr_stmt|;
block|}
name|result
operator|=
name|TclCleanupChildren
argument_list|(
name|interp
argument_list|,
name|pipePtr
operator|->
name|numPids
argument_list|,
name|pipePtr
operator|->
name|pidPtr
argument_list|,
name|errChan
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pipePtr
operator|->
name|numPids
operator|!=
literal|0
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pipePtr
operator|->
name|pidPtr
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pipePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorCode
operator|==
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
return|return
name|errorCode
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * PipeInputProc --  *  *	This procedure is invoked from the generic IO level to read  *	input from a command pipeline based channel.  *  * Results:  *	The number of bytes read is returned or -1 on error. An output  *	argument contains a POSIX error code if an error occurs, or zero.  *  * Side effects:  *	Reads input from the input device of the channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|PipeInputProc
parameter_list|(
name|instanceData
parameter_list|,
name|buf
parameter_list|,
name|toRead
parameter_list|,
name|errorCodePtr
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* Pipe state. */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Where to store data read. */
name|int
name|toRead
decl_stmt|;
comment|/* How much space is available                                          * in the buffer? */
name|int
modifier|*
name|errorCodePtr
decl_stmt|;
comment|/* Where to store error code. */
block|{
name|PipeState
modifier|*
name|psPtr
init|=
operator|(
name|PipeState
operator|*
operator|)
name|instanceData
decl_stmt|;
name|int
name|bytesRead
decl_stmt|;
comment|/* How many bytes were actually                                          * read from the input device? */
operator|*
name|errorCodePtr
operator|=
literal|0
expr_stmt|;
comment|/*      * Assume there is always enough input available. This will block      * appropriately, and read will unblock as soon as a short read is      * possible, if the channel is in blocking mode. If the channel is      * nonblocking, the read will never block.      */
name|bytesRead
operator|=
name|read
argument_list|(
name|GetFd
argument_list|(
name|psPtr
operator|->
name|inFile
argument_list|)
argument_list|,
name|buf
argument_list|,
operator|(
name|size_t
operator|)
name|toRead
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytesRead
operator|>
operator|-
literal|1
condition|)
block|{
return|return
name|bytesRead
return|;
block|}
operator|*
name|errorCodePtr
operator|=
name|errno
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * PipeOutputProc--  *  *	This procedure is invoked from the generic IO level to write  *	output to a command pipeline based channel.  *  * Results:  *	The number of bytes written is returned or -1 on error. An  *	output argument	contains a POSIX error code if an error occurred,  *	or zero.  *  * Side effects:  *	Writes output on the output device of the channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|PipeOutputProc
parameter_list|(
name|instanceData
parameter_list|,
name|buf
parameter_list|,
name|toWrite
parameter_list|,
name|errorCodePtr
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* Pipe state. */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* The data buffer. */
name|int
name|toWrite
decl_stmt|;
comment|/* How many bytes to write? */
name|int
modifier|*
name|errorCodePtr
decl_stmt|;
comment|/* Where to store error code. */
block|{
name|PipeState
modifier|*
name|psPtr
init|=
operator|(
name|PipeState
operator|*
operator|)
name|instanceData
decl_stmt|;
name|int
name|written
decl_stmt|;
operator|*
name|errorCodePtr
operator|=
literal|0
expr_stmt|;
name|written
operator|=
name|write
argument_list|(
name|GetFd
argument_list|(
name|psPtr
operator|->
name|outFile
argument_list|)
argument_list|,
name|buf
argument_list|,
operator|(
name|size_t
operator|)
name|toWrite
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|>
operator|-
literal|1
condition|)
block|{
return|return
name|written
return|;
block|}
operator|*
name|errorCodePtr
operator|=
name|errno
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * PipeWatchProc --  *  *	Initialize the notifier to watch the fds from this channel.  *  * Results:  *	None.  *  * Side effects:  *	Sets up the notifier so that a future event on the channel will  *	be seen by Tcl.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|PipeWatchProc
parameter_list|(
name|instanceData
parameter_list|,
name|mask
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* The pipe state. */
name|int
name|mask
decl_stmt|;
comment|/* Events of interest; an OR-ed                                          * combination of TCL_READABLE,                                          * TCL_WRITABEL and TCL_EXCEPTION. */
block|{
name|PipeState
modifier|*
name|psPtr
init|=
operator|(
name|PipeState
operator|*
operator|)
name|instanceData
decl_stmt|;
name|int
name|newmask
decl_stmt|;
if|if
condition|(
name|psPtr
operator|->
name|inFile
condition|)
block|{
name|newmask
operator|=
name|mask
operator|&
operator|(
name|TCL_READABLE
operator||
name|TCL_EXCEPTION
operator|)
expr_stmt|;
if|if
condition|(
name|newmask
condition|)
block|{
name|Tcl_CreateFileHandler
argument_list|(
name|GetFd
argument_list|(
name|psPtr
operator|->
name|inFile
argument_list|)
argument_list|,
name|mask
argument_list|,
operator|(
name|Tcl_FileProc
operator|*
operator|)
name|Tcl_NotifyChannel
argument_list|,
operator|(
name|ClientData
operator|)
name|psPtr
operator|->
name|channel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_DeleteFileHandler
argument_list|(
name|GetFd
argument_list|(
name|psPtr
operator|->
name|inFile
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|psPtr
operator|->
name|outFile
condition|)
block|{
name|newmask
operator|=
name|mask
operator|&
operator|(
name|TCL_WRITABLE
operator||
name|TCL_EXCEPTION
operator|)
expr_stmt|;
if|if
condition|(
name|newmask
condition|)
block|{
name|Tcl_CreateFileHandler
argument_list|(
name|GetFd
argument_list|(
name|psPtr
operator|->
name|outFile
argument_list|)
argument_list|,
name|mask
argument_list|,
operator|(
name|Tcl_FileProc
operator|*
operator|)
name|Tcl_NotifyChannel
argument_list|,
operator|(
name|ClientData
operator|)
name|psPtr
operator|->
name|channel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_DeleteFileHandler
argument_list|(
name|GetFd
argument_list|(
name|psPtr
operator|->
name|outFile
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * PipeGetHandleProc --  *  *	Called from Tcl_GetChannelHandle to retrieve OS handles from  *	inside a command pipeline based channel.  *  * Results:  *	Returns TCL_OK with the fd in handlePtr, or TCL_ERROR if  *	there is no handle for the specified direction.   *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|PipeGetHandleProc
parameter_list|(
name|instanceData
parameter_list|,
name|direction
parameter_list|,
name|handlePtr
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* The pipe state. */
name|int
name|direction
decl_stmt|;
comment|/* TCL_READABLE or TCL_WRITABLE */
name|ClientData
modifier|*
name|handlePtr
decl_stmt|;
comment|/* Where to store the handle.  */
block|{
name|PipeState
modifier|*
name|psPtr
init|=
operator|(
name|PipeState
operator|*
operator|)
name|instanceData
decl_stmt|;
if|if
condition|(
name|direction
operator|==
name|TCL_READABLE
operator|&&
name|psPtr
operator|->
name|inFile
condition|)
block|{
operator|*
name|handlePtr
operator|=
operator|(
name|ClientData
operator|)
name|GetFd
argument_list|(
name|psPtr
operator|->
name|inFile
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|direction
operator|==
name|TCL_WRITABLE
operator|&&
name|psPtr
operator|->
name|outFile
condition|)
block|{
operator|*
name|handlePtr
operator|=
operator|(
name|ClientData
operator|)
name|GetFd
argument_list|(
name|psPtr
operator|->
name|outFile
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_WaitPid --  *  *	Implements the waitpid system call on Unix systems.  *  * Results:  *	Result of calling waitpid.  *  * Side effects:  *	Waits for a process to terminate.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Pid
name|Tcl_WaitPid
parameter_list|(
name|pid
parameter_list|,
name|statPtr
parameter_list|,
name|options
parameter_list|)
name|Tcl_Pid
name|pid
decl_stmt|;
name|int
modifier|*
name|statPtr
decl_stmt|;
name|int
name|options
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|pid_t
name|real_pid
decl_stmt|;
name|real_pid
operator|=
operator|(
name|pid_t
operator|)
name|pid
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|result
operator|=
operator|(
name|int
operator|)
name|waitpid
argument_list|(
name|real_pid
argument_list|,
name|statPtr
argument_list|,
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|!=
operator|-
literal|1
operator|)
operator|||
operator|(
name|errno
operator|!=
name|EINTR
operator|)
condition|)
block|{
return|return
operator|(
name|Tcl_Pid
operator|)
name|result
return|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_PidObjCmd --  *  *	This procedure is invoked to process the "pid" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_PidObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
modifier|*
name|objv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Tcl_Channel
name|chan
decl_stmt|;
name|Tcl_ChannelType
modifier|*
name|chanTypePtr
decl_stmt|;
name|PipeState
modifier|*
name|pipePtr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|Tcl_Obj
modifier|*
name|resultPtr
decl_stmt|,
modifier|*
name|longObjPtr
decl_stmt|;
if|if
condition|(
name|objc
operator|>
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"?channelId?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|objc
operator|==
literal|1
condition|)
block|{
name|Tcl_SetLongObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chan
operator|=
name|Tcl_GetChannel
argument_list|(
name|interp
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|chanTypePtr
operator|=
name|Tcl_GetChannelType
argument_list|(
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|chanTypePtr
operator|!=
operator|&
name|pipeChannelType
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
name|pipePtr
operator|=
operator|(
name|PipeState
operator|*
operator|)
name|Tcl_GetChannelInstanceData
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|resultPtr
operator|=
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pipePtr
operator|->
name|numPids
condition|;
name|i
operator|++
control|)
block|{
name|longObjPtr
operator|=
name|Tcl_NewLongObj
argument_list|(
operator|(
name|long
operator|)
name|TclpGetPid
argument_list|(
name|pipePtr
operator|->
name|pidPtr
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
name|NULL
argument_list|,
name|resultPtr
argument_list|,
name|longObjPtr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

end_unit

