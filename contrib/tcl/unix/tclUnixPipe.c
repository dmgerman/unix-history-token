begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclUnixPipe.c -- This file implements the UNIX-specific exec pipeline   *                  functions.  *  * Copyright (c) 1991-1994 The Regents of the University of California.  * Copyright (c) 1994-1996 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclUnixPipe.c 1.29 96/04/18 15:56:26  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * Declarations for local procedures defined in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|RestoreSignals
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SetupStdFile
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_File
name|file
operator|,
name|int
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * RestoreSignals --  *  *      This procedure is invoked in a forked child process just before  *      exec-ing a new program to restore all signals to their default  *      settings.  *  * Results:  *      None.  *  * Side effects:  *      Signal settings get changed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|RestoreSignals
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|SIGABRT
name|signal
argument_list|(
name|SIGABRT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGALRM
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGFPE
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGILL
name|signal
argument_list|(
name|SIGILL
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGINT
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGSEGV
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGUSR1
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGUSR2
name|signal
argument_list|(
name|SIGUSR2
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGCHLD
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGCONT
name|signal
argument_list|(
name|SIGCONT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTSTP
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTTIN
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTTOU
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SetupStdFile --  *  *	Set up stdio file handles for the child process, using the  *	current standard channels if no other files are specified.  *	If no standard channel is defined, or if no file is associated  *	with the channel, then the corresponding standard fd is closed.  *  * Results:  *	Returns 1 on success, or 0 on failure.  *  * Side effects:  *	Replaces stdio fds.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SetupStdFile
parameter_list|(
name|file
parameter_list|,
name|type
parameter_list|)
name|Tcl_File
name|file
decl_stmt|;
comment|/* File to dup, or NULL. */
name|int
name|type
decl_stmt|;
comment|/* One of TCL_STDIN, TCL_STDOUT, TCL_STDERR */
block|{
name|Tcl_Channel
name|channel
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|targetFd
init|=
literal|0
decl_stmt|;
comment|/* Initializations here needed only to */
name|int
name|direction
init|=
literal|0
decl_stmt|;
comment|/* prevent warnings about using uninitialized 				 * variables. */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TCL_STDIN
case|:
name|targetFd
operator|=
literal|0
expr_stmt|;
name|direction
operator|=
name|TCL_READABLE
expr_stmt|;
break|break;
case|case
name|TCL_STDOUT
case|:
name|targetFd
operator|=
literal|1
expr_stmt|;
name|direction
operator|=
name|TCL_WRITABLE
expr_stmt|;
break|break;
case|case
name|TCL_STDERR
case|:
name|targetFd
operator|=
literal|2
expr_stmt|;
name|direction
operator|=
name|TCL_WRITABLE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|file
condition|)
block|{
name|channel
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
condition|)
block|{
name|file
operator|=
name|Tcl_GetChannelFile
argument_list|(
name|channel
argument_list|,
name|direction
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|file
condition|)
block|{
name|fd
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|file
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
name|targetFd
condition|)
block|{
if|if
condition|(
name|dup2
argument_list|(
name|fd
argument_list|,
name|targetFd
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/*              * Must clear the close-on-exec flag for the target FD, since              * some systems (e.g. Ultrix) do not clear the CLOEXEC flag on              * the target FD.              */
name|fcntl
argument_list|(
name|targetFd
argument_list|,
name|F_SETFD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|result
decl_stmt|;
comment|/* 	     * Since we aren't dup'ing the file, we need to explicitly clear 	     * the close-on-exec flag. 	     */
name|result
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|close
argument_list|(
name|targetFd
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclSpawnPipeline --  *  *      Given an argc/argv array, instantiate a pipeline of processes  *      as described by the argv.  *  * Results:  *      The return value is 1 on success, 0 on error  *  * Side effects:  *      Processes and pipes are created.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclSpawnPipeline
parameter_list|(
name|interp
parameter_list|,
name|pidPtr
parameter_list|,
name|numPids
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|inputFile
parameter_list|,
name|outputFile
parameter_list|,
name|errorFile
parameter_list|,
name|intIn
parameter_list|,
name|finalOut
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to process pipeline. */
name|int
modifier|*
name|pidPtr
decl_stmt|;
comment|/* Array of pids which are created. */
name|int
modifier|*
name|numPids
decl_stmt|;
comment|/* Number of pids created. */
name|int
name|argc
decl_stmt|;
comment|/* Number of entries in argv. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Array of strings describing commands in 				 * pipeline plus I/O redirection with<, 				 *<<,>, etc. argv[argc] must be NULL. */
name|Tcl_File
name|inputFile
decl_stmt|;
comment|/* If>=0, gives file id to use as input for 				 * first process in pipeline (specified via< 				 * or<@). */
name|Tcl_File
name|outputFile
decl_stmt|;
comment|/* Writable file id for output from last 				 * command in pipeline (could be file or 				 * pipe). NULL means use stdout. */
name|Tcl_File
name|errorFile
decl_stmt|;
comment|/* Writable file id for error output from all 				 * commands in the pipeline. NULL means use 				 * stderr */
name|char
modifier|*
name|intIn
decl_stmt|;
comment|/* File name for initial input (for Win32s). */
name|char
modifier|*
name|finalOut
decl_stmt|;
comment|/* File name for final output (for Win32s). */
block|{
name|int
name|firstArg
decl_stmt|,
name|lastArg
decl_stmt|;
name|int
name|pid
decl_stmt|,
name|count
decl_stmt|;
name|Tcl_DString
name|buffer
decl_stmt|;
name|char
modifier|*
name|execName
decl_stmt|;
name|char
name|errSpace
index|[
literal|200
index|]
decl_stmt|;
name|Tcl_File
name|pipeIn
decl_stmt|,
name|errPipeIn
decl_stmt|,
name|errPipeOut
decl_stmt|;
name|int
name|joinThisError
decl_stmt|;
name|Tcl_File
name|curOutFile
init|=
name|NULL
decl_stmt|,
name|curInFile
decl_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|pipeIn
operator|=
name|errPipeIn
operator|=
name|errPipeOut
operator|=
name|NULL
expr_stmt|;
name|curInFile
operator|=
name|inputFile
expr_stmt|;
for|for
control|(
name|firstArg
operator|=
literal|0
init|;
name|firstArg
operator|<
name|argc
condition|;
name|firstArg
operator|=
name|lastArg
operator|+
literal|1
control|)
block|{
comment|/* 	 * Convert the program name into native form. 	 */
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|execName
operator|=
name|Tcl_TranslateFileName
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|firstArg
index|]
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|execName
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* 	 * Find the end of the current segment of the pipeline. 	 */
name|joinThisError
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|lastArg
operator|=
name|firstArg
init|;
name|lastArg
operator|<
name|argc
condition|;
name|lastArg
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|lastArg
index|]
index|[
literal|0
index|]
operator|==
literal|'|'
condition|)
block|{
if|if
condition|(
name|argv
index|[
name|lastArg
index|]
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|(
name|argv
index|[
name|lastArg
index|]
index|[
literal|1
index|]
operator|==
literal|'&'
operator|)
operator|&&
operator|(
name|argv
index|[
name|lastArg
index|]
index|[
literal|2
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|joinThisError
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
name|argv
index|[
name|lastArg
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If this is the last segment, use the specified outputFile. 	 * Otherwise create an intermediate pipe. 	 */
if|if
condition|(
name|lastArg
operator|==
name|argc
condition|)
block|{
name|curOutFile
operator|=
name|outputFile
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TclCreatePipe
argument_list|(
operator|&
name|pipeIn
argument_list|,
operator|&
name|curOutFile
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't create pipe: "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
comment|/* 	 * Create a pipe that the child can use to return error 	 * information if anything goes wrong. 	 */
if|if
condition|(
name|TclCreatePipe
argument_list|(
operator|&
name|errPipeIn
argument_list|,
operator|&
name|errPipeOut
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't create pipe: "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* 	     * Set up stdio file handles for the child process. 	     */
if|if
condition|(
operator|!
name|SetupStdFile
argument_list|(
name|curInFile
argument_list|,
name|TCL_STDIN
argument_list|)
operator|||
operator|!
name|SetupStdFile
argument_list|(
name|curOutFile
argument_list|,
name|TCL_STDOUT
argument_list|)
operator|||
operator|(
operator|!
name|joinThisError
operator|&&
operator|!
name|SetupStdFile
argument_list|(
name|errorFile
argument_list|,
name|TCL_STDERR
argument_list|)
operator|)
operator|||
operator|(
name|joinThisError
operator|&&
operator|(
operator|(
name|dup2
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|fcntl
argument_list|(
literal|2
argument_list|,
name|F_SETFD
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|errSpace
argument_list|,
literal|"%dforked process couldn't set up input/output: "
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|TclWriteFile
argument_list|(
name|errPipeOut
argument_list|,
literal|1
argument_list|,
name|errSpace
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|errSpace
argument_list|)
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*              * Close the input side of the error pipe.              */
name|RestoreSignals
argument_list|()
expr_stmt|;
name|execvp
argument_list|(
name|execName
argument_list|,
operator|&
name|argv
index|[
name|firstArg
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|errSpace
argument_list|,
literal|"%dcouldn't execute \"%.150s\": "
argument_list|,
name|errno
argument_list|,
name|argv
index|[
name|firstArg
index|]
argument_list|)
expr_stmt|;
name|TclWriteFile
argument_list|(
name|errPipeOut
argument_list|,
literal|1
argument_list|,
name|errSpace
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|errSpace
argument_list|)
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't fork child process: "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* 	 * Add the child process to the list of those to be reaped. 	 * Note: must do it now, so that the process will be reaped even if 	 * an error occurs during its startup. 	 */
name|pidPtr
index|[
operator|*
name|numPids
index|]
operator|=
name|pid
expr_stmt|;
operator|(
operator|*
name|numPids
operator|)
operator|++
expr_stmt|;
comment|/* 	 * Read back from the error pipe to see if the child startup 	 * up OK.  The info in the pipe (if any) consists of a decimal 	 * errno value followed by an error message. 	 */
name|TclCloseFile
argument_list|(
name|errPipeOut
argument_list|)
expr_stmt|;
name|errPipeOut
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|TclReadFile
argument_list|(
name|errPipeIn
argument_list|,
literal|1
argument_list|,
name|errSpace
argument_list|,
call|(
name|size_t
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|errSpace
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|errSpace
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
name|errno
operator|=
name|strtol
argument_list|(
name|errSpace
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|end
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|TclCloseFile
argument_list|(
name|errPipeIn
argument_list|)
expr_stmt|;
name|errPipeIn
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Close off our copies of file descriptors that were set up for 	 * this child, then set up the input for the next child. 	 */
if|if
condition|(
name|curInFile
operator|&&
operator|(
name|curInFile
operator|!=
name|inputFile
operator|)
condition|)
block|{
name|TclCloseFile
argument_list|(
name|curInFile
argument_list|)
expr_stmt|;
block|}
name|curInFile
operator|=
name|pipeIn
expr_stmt|;
name|pipeIn
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|curOutFile
operator|&&
operator|(
name|curOutFile
operator|!=
name|outputFile
operator|)
condition|)
block|{
name|TclCloseFile
argument_list|(
name|curOutFile
argument_list|)
expr_stmt|;
block|}
name|curOutFile
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|1
return|;
comment|/*      * An error occured, so we need to clean up any open pipes.      */
name|error
label|:
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|errPipeIn
condition|)
block|{
name|TclCloseFile
argument_list|(
name|errPipeIn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errPipeOut
condition|)
block|{
name|TclCloseFile
argument_list|(
name|errPipeOut
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pipeIn
condition|)
block|{
name|TclCloseFile
argument_list|(
name|pipeIn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curOutFile
operator|&&
operator|(
name|curOutFile
operator|!=
name|outputFile
operator|)
condition|)
block|{
name|TclCloseFile
argument_list|(
name|curOutFile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curInFile
operator|&&
operator|(
name|curInFile
operator|!=
name|inputFile
operator|)
condition|)
block|{
name|TclCloseFile
argument_list|(
name|curInFile
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCreatePipe --  *  *      Creates a pipe - simply calls the pipe() function.  *  * Results:  *      Returns 1 on success, 0 on failure.   *  * Side effects:  *      Creates a pipe.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclCreatePipe
parameter_list|(
name|readPipe
parameter_list|,
name|writePipe
parameter_list|)
name|Tcl_File
modifier|*
name|readPipe
decl_stmt|;
comment|/* Location to store file handle for 				 * read side of pipe. */
name|Tcl_File
modifier|*
name|writePipe
decl_stmt|;
comment|/* Location to store file handle for 				 * write side of pipe. */
block|{
name|int
name|pipeIds
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|pipeIds
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|fcntl
argument_list|(
name|pipeIds
index|[
literal|0
index|]
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|pipeIds
index|[
literal|1
index|]
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
operator|*
name|readPipe
operator|=
name|Tcl_GetFile
argument_list|(
operator|(
name|ClientData
operator|)
name|pipeIds
index|[
literal|0
index|]
argument_list|,
name|TCL_UNIX_FD
argument_list|)
expr_stmt|;
operator|*
name|writePipe
operator|=
name|Tcl_GetFile
argument_list|(
operator|(
name|ClientData
operator|)
name|pipeIds
index|[
literal|1
index|]
argument_list|,
name|TCL_UNIX_FD
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CreatePipeline --  *  *	This function is a compatibility wrapper for TclCreatePipeline.  *	It is only available under Unix, and may be removed from later  *	versions.  *  * Results:  *	Same as TclCreatePipeline.  *  * Side effects:  *	Same as TclCreatePipeline.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_CreatePipeline
parameter_list|(
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pidArrayPtr
parameter_list|,
name|inPipePtr
parameter_list|,
name|outPipePtr
parameter_list|,
name|errFilePtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
modifier|*
modifier|*
name|pidArrayPtr
decl_stmt|;
name|int
modifier|*
name|inPipePtr
decl_stmt|;
name|int
modifier|*
name|outPipePtr
decl_stmt|;
name|int
modifier|*
name|errFilePtr
decl_stmt|;
block|{
name|Tcl_File
name|inFile
decl_stmt|,
name|outFile
decl_stmt|,
name|errFile
decl_stmt|;
name|int
name|result
decl_stmt|;
name|result
operator|=
name|TclCreatePipeline
argument_list|(
name|interp
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|pidArrayPtr
argument_list|,
operator|(
name|inPipePtr
condition|?
operator|&
name|inFile
else|:
name|NULL
operator|)
argument_list|,
operator|(
name|outPipePtr
condition|?
operator|&
name|outFile
else|:
name|NULL
operator|)
argument_list|,
operator|(
name|errFilePtr
condition|?
operator|&
name|errFile
else|:
name|NULL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inPipePtr
condition|)
block|{
if|if
condition|(
name|inFile
condition|)
block|{
operator|*
name|inPipePtr
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|inFile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_FreeFile
argument_list|(
name|inFile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|inPipePtr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|outPipePtr
condition|)
block|{
if|if
condition|(
name|outFile
condition|)
block|{
operator|*
name|outPipePtr
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|outFile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_FreeFile
argument_list|(
name|outFile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|outPipePtr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errFilePtr
condition|)
block|{
if|if
condition|(
name|errFile
condition|)
block|{
operator|*
name|errFilePtr
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|errFile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_FreeFile
argument_list|(
name|errFile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|errFilePtr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

end_unit

