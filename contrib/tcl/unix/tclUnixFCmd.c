begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * tclUnixFCmd.c  *  *      This file implements the unix specific portion of file manipulation   *      subcommands of the "file" command.  All filename arguments should  *	already be translated to native format.  *  * Copyright (c) 1996-1997 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclUnixFCmd.c 1.31 97/10/13 16:51:14  *  * Portions of this code were derived from NetBSD source code which has  * the following copyright notice:  *  * Copyright (c) 1988, 1993, 1994  *      The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by the University of  *      California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_comment
comment|/*  * The following constants specify the type of callback when  * TraverseUnixTree() calls the traverseProc()  */
end_comment

begin_define
define|#
directive|define
name|DOTREE_PRED
value|1
end_define

begin_comment
comment|/* pre-order directory  */
end_comment

begin_define
define|#
directive|define
name|DOTREE_POSTD
value|2
end_define

begin_comment
comment|/* post-order directory */
end_comment

begin_define
define|#
directive|define
name|DOTREE_F
value|3
end_define

begin_comment
comment|/* regular file */
end_comment

begin_comment
comment|/*  * Callbacks for file attributes code.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|GetGroupAttribute
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objIndex
operator|,
name|char
operator|*
name|fileName
operator|,
name|Tcl_Obj
operator|*
operator|*
name|attributePtrPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|GetOwnerAttribute
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objIndex
operator|,
name|char
operator|*
name|fileName
operator|,
name|Tcl_Obj
operator|*
operator|*
name|attributePtrPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|GetPermissionsAttribute
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objIndex
operator|,
name|char
operator|*
name|fileName
operator|,
name|Tcl_Obj
operator|*
operator|*
name|attributePtrPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SetGroupAttribute
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objIndex
operator|,
name|char
operator|*
name|fileName
operator|,
name|Tcl_Obj
operator|*
name|attributePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SetOwnerAttribute
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objIndex
operator|,
name|char
operator|*
name|fileName
operator|,
name|Tcl_Obj
operator|*
name|attributePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SetPermissionsAttribute
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objIndex
operator|,
name|char
operator|*
name|fileName
operator|,
name|Tcl_Obj
operator|*
name|attributePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Prototype for the TraverseUnixTree callback function.  */
end_comment

begin_typedef
typedef|typedef
name|int
argument_list|(
argument|TraversalProc
argument_list|)
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|src
operator|,
name|char
operator|*
name|dst
operator|,
expr|struct
name|stat
operator|*
name|sb
operator|,
name|int
name|type
operator|,
name|Tcl_DString
operator|*
name|errorPtr
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_comment
comment|/*  * Constants and variables necessary for file attributes subcommand.  */
end_comment

begin_enum
enum|enum
block|{
name|UNIX_GROUP_ATTRIBUTE
block|,
name|UNIX_OWNER_ATTRIBUTE
block|,
name|UNIX_PERMISSIONS_ATTRIBUTE
block|}
enum|;
end_enum

begin_decl_stmt
name|char
modifier|*
name|tclpFileAttrStrings
index|[]
init|=
block|{
literal|"-group"
block|,
literal|"-owner"
block|,
literal|"-permissions"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CONST
name|TclFileAttrProcs
name|tclpFileAttrProcs
index|[]
init|=
block|{
block|{
name|GetGroupAttribute
block|,
name|SetGroupAttribute
block|}
block|,
block|{
name|GetOwnerAttribute
block|,
name|SetOwnerAttribute
block|}
block|,
block|{
name|GetPermissionsAttribute
block|,
name|SetPermissionsAttribute
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Declarations for local procedures defined in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|CopyFile
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|src
operator|,
name|char
operator|*
name|dst
operator|,
expr|struct
name|stat
operator|*
name|srcStatBufPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CopyFileAtts
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|src
operator|,
name|char
operator|*
name|dst
operator|,
expr|struct
name|stat
operator|*
name|srcStatBufPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TraversalCopy
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|src
operator|,
name|char
operator|*
name|dst
operator|,
expr|struct
name|stat
operator|*
name|sbPtr
operator|,
name|int
name|type
operator|,
name|Tcl_DString
operator|*
name|errorPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TraversalDelete
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|src
operator|,
name|char
operator|*
name|dst
operator|,
expr|struct
name|stat
operator|*
name|sbPtr
operator|,
name|int
name|type
operator|,
name|Tcl_DString
operator|*
name|errorPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TraverseUnixTree
name|_ANSI_ARGS_
argument_list|(
operator|(
name|TraversalProc
operator|*
name|traversalProc
operator|,
name|Tcl_DString
operator|*
name|sourcePath
operator|,
name|Tcl_DString
operator|*
name|destPath
operator|,
name|Tcl_DString
operator|*
name|errorPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *---------------------------------------------------------------------------  *  * TclpRenameFile --  *  *      Changes the name of an existing file or directory, from src to dst.  *	If src and dst refer to the same file or directory, does nothing  *	and returns success.  Otherwise if dst already exists, it will be  *	deleted and replaced by src subject to the following conditions:  *	    If src is a directory, dst may be an empty directory.  *	    If src is a file, dst may be a file.  *	In any other situation where dst already exists, the rename will  *	fail.    *  * Results:  *	If the directory was successfully created, returns TCL_OK.  *	Otherwise the return value is TCL_ERROR and errno is set to  *	indicate the error.  Some possible values for errno are:  *  *	EACCES:     src or dst parent directory can't be read and/or written.  *	EEXIST:	    dst is a non-empty directory.  *	EINVAL:	    src is a root directory or dst is a subdirectory of src.  *	EISDIR:	    dst is a directory, but src is not.  *	ENOENT:	    src doesn't exist, or src or dst is "".  *	ENOTDIR:    src is a directory, but dst is not.    *	EXDEV:	    src and dst are on different filesystems.  *	  * Side effects:  *	The implementation of rename may allow cross-filesystem renames,  *	but the caller should be prepared to emulate it with copy and  *	delete if errno is EXDEV.  *  *---------------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclpRenameFile
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
name|char
modifier|*
name|src
decl_stmt|;
comment|/* Pathname of file or dir to be renamed. */
name|char
modifier|*
name|dst
decl_stmt|;
comment|/* New pathname of file or directory. */
block|{
if|if
condition|(
name|rename
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|errno
operator|==
name|ENOTEMPTY
condition|)
block|{
name|errno
operator|=
name|EEXIST
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|sparc
comment|/*      * SunOS 4.1.4 reports overwriting a non-empty directory with a      * directory as EINVAL instead of EEXIST (first rule out the correct      * EINVAL result code for moving a directory into itself).  Must be      * conditionally compiled because realpath() is only defined on SunOS.      */
if|if
condition|(
name|errno
operator|==
name|EINVAL
condition|)
block|{
name|char
name|srcPath
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|dstPath
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|DIR
modifier|*
name|dirPtr
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dirEntPtr
decl_stmt|;
if|if
condition|(
operator|(
name|realpath
argument_list|(
name|src
argument_list|,
name|srcPath
argument_list|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|realpath
argument_list|(
name|dst
argument_list|,
name|dstPath
argument_list|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|srcPath
argument_list|,
name|dstPath
argument_list|,
name|strlen
argument_list|(
name|srcPath
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|dirPtr
operator|=
name|opendir
argument_list|(
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirPtr
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|dirEntPtr
operator|=
name|readdir
argument_list|(
name|dirPtr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|dirEntPtr
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|dirEntPtr
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|errno
operator|=
name|EEXIST
expr_stmt|;
name|closedir
argument_list|(
name|dirPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
name|closedir
argument_list|(
name|dirPtr
argument_list|)
expr_stmt|;
block|}
block|}
name|errno
operator|=
name|EINVAL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* sparc */
if|if
condition|(
name|strcmp
argument_list|(
name|src
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 	 * Alpha reports renaming / as EBUSY and Linux reports it as EACCES, 	 * instead of EINVAL. 	 */
name|errno
operator|=
name|EINVAL
expr_stmt|;
block|}
comment|/*      * DEC Alpha OSF1 V3.0 returns EACCES when attempting to move a      * file across filesystems and the parent directory of that file is      * not writable.  Most other systems return EXDEV.  Does nothing to      * correct this behavior.      */
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *---------------------------------------------------------------------------  *  * TclpCopyFile --  *  *      Copy a single file (not a directory).  If dst already exists and  *	is not a directory, it is removed.  *  * Results:  *	If the file was successfully copied, returns TCL_OK.  Otherwise  *	the return value is TCL_ERROR and errno is set to indicate the  *	error.  Some possible values for errno are:  *  *	EACCES:     src or dst parent directory can't be read and/or written.  *	EISDIR:	    src or dst is a directory.  *	ENOENT:	    src doesn't exist.  src or dst is "".  *  * Side effects:  *      This procedure will also copy symbolic links, block, and  *      character devices, and fifos.  For symbolic links, the links   *      themselves will be copied and not what they point to.  For the  *	other special file types, the directory entry will be copied and  *	not the contents of the device that it refers to.  *  *---------------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclpCopyFile
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
name|char
modifier|*
name|src
decl_stmt|;
comment|/* Pathname of file to be copied. */
name|char
modifier|*
name|dst
decl_stmt|;
comment|/* Pathname of file to copy to. */
block|{
name|struct
name|stat
name|srcStatBuf
decl_stmt|,
name|dstStatBuf
decl_stmt|;
name|char
name|link
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/*      * Have to do a stat() to determine the filetype.      */
if|if
condition|(
name|lstat
argument_list|(
name|src
argument_list|,
operator|&
name|srcStatBuf
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|S_ISDIR
argument_list|(
name|srcStatBuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EISDIR
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * symlink, and some of the other calls will fail if the target       * exists, so we remove it first      */
if|if
condition|(
name|lstat
argument_list|(
name|dst
argument_list|,
operator|&
name|dstStatBuf
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|S_ISDIR
argument_list|(
name|dstStatBuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EISDIR
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
if|if
condition|(
name|unlink
argument_list|(
name|dst
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
switch|switch
condition|(
call|(
name|int
call|)
argument_list|(
name|srcStatBuf
operator|.
name|st_mode
operator|&
name|S_IFMT
argument_list|)
condition|)
block|{
case|case
name|S_IFLNK
case|:
name|length
operator|=
name|readlink
argument_list|(
name|src
argument_list|,
name|link
argument_list|,
sizeof|sizeof
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|link
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|symlink
argument_list|(
name|link
argument_list|,
name|dst
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
break|break;
case|case
name|S_IFBLK
case|:
case|case
name|S_IFCHR
case|:
if|if
condition|(
name|mknod
argument_list|(
name|dst
argument_list|,
name|srcStatBuf
operator|.
name|st_mode
argument_list|,
name|srcStatBuf
operator|.
name|st_rdev
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|CopyFileAtts
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
operator|&
name|srcStatBuf
argument_list|)
return|;
case|case
name|S_IFIFO
case|:
if|if
condition|(
name|mkfifo
argument_list|(
name|dst
argument_list|,
name|srcStatBuf
operator|.
name|st_mode
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|CopyFileAtts
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
operator|&
name|srcStatBuf
argument_list|)
return|;
default|default:
return|return
name|CopyFile
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
operator|&
name|srcStatBuf
argument_list|)
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CopyFile -   *  *      Helper function for TclpCopyFile.  Copies one regular file,  *	using read() and write().  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *      A file is copied.  Dst will be overwritten if it exists.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CopyFile
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|srcStatBufPtr
parameter_list|)
name|char
modifier|*
name|src
decl_stmt|;
comment|/* Pathname of file to copy. */
name|char
modifier|*
name|dst
decl_stmt|;
comment|/* Pathname of file to create/overwrite. */
name|struct
name|stat
modifier|*
name|srcStatBufPtr
decl_stmt|;
comment|/* Used to determine mode and blocksize */
block|{
name|int
name|srcFd
decl_stmt|;
name|int
name|dstFd
decl_stmt|;
name|u_int
name|blockSize
decl_stmt|;
comment|/* Optimal I/O blocksize for filesystem */
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* Data buffer for copy */
name|size_t
name|nread
decl_stmt|;
if|if
condition|(
operator|(
name|srcFd
operator|=
name|open
argument_list|(
name|src
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|dstFd
operator|=
name|open
argument_list|(
name|dst
argument_list|,
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_WRONLY
argument_list|,
name|srcStatBufPtr
operator|->
name|st_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|dstFd
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|srcFd
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|#
directive|if
name|HAVE_ST_BLKSIZE
name|blockSize
operator|=
name|srcStatBufPtr
operator|->
name|st_blksize
expr_stmt|;
else|#
directive|else
name|blockSize
operator|=
literal|4096
expr_stmt|;
endif|#
directive|endif
name|buffer
operator|=
name|ckalloc
argument_list|(
name|blockSize
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|nread
operator|=
name|read
argument_list|(
name|srcFd
argument_list|,
name|buffer
argument_list|,
name|blockSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nread
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|nread
operator|==
literal|0
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|write
argument_list|(
name|dstFd
argument_list|,
name|buffer
argument_list|,
name|nread
argument_list|)
operator|!=
name|nread
condition|)
block|{
name|nread
operator|=
operator|(
name|size_t
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|ckfree
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|srcFd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|close
argument_list|(
name|dstFd
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|nread
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|unlink
argument_list|(
name|dst
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|CopyFileAtts
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|srcStatBufPtr
argument_list|)
operator|==
name|TCL_ERROR
condition|)
block|{
comment|/* 	 * The copy succeeded, but setting the permissions failed, so be in 	 * a consistent state, we remove the file that was created by the 	 * copy. 	 */
name|unlink
argument_list|(
name|dst
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *---------------------------------------------------------------------------  *  * TclpDeleteFile --  *  *      Removes a single file (not a directory).  *  * Results:  *	If the file was successfully deleted, returns TCL_OK.  Otherwise  *	the return value is TCL_ERROR and errno is set to indicate the  *	error.  Some possible values for errno are:  *  *	EACCES:     a parent directory can't be read and/or written.  *	EISDIR:	    path is a directory.  *	ENOENT:	    path doesn't exist or is "".  *  * Side effects:  *      The file is deleted, even if it is read-only.  *  *---------------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclpDeleteFile
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Pathname of file to be removed. */
block|{
if|if
condition|(
name|unlink
argument_list|(
name|path
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *---------------------------------------------------------------------------  *  * TclpCreateDirectory --  *  *      Creates the specified directory.  All parent directories of the  *	specified directory must already exist.  The directory is  *	automatically created with permissions so that user can access  *	the new directory and create new files or subdirectories in it.  *  * Results:  *	If the directory was successfully created, returns TCL_OK.  *	Otherwise the return value is TCL_ERROR and errno is set to  *	indicate the error.  Some possible values for errno are:  *  *	EACCES:     a parent directory can't be read and/or written.  *	EEXIST:	    path already exists.  *	ENOENT:	    a parent directory doesn't exist.  *  * Side effects:  *      A directory is created with the current umask, except that  *	permission for u+rwx will always be added.  *  *---------------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclpCreateDirectory
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Pathname of directory to create. */
block|{
name|mode_t
name|mode
decl_stmt|;
name|mode
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/*      * umask return value is actually the inverse of the permissions.      */
name|mode
operator|=
operator|(
literal|0777
operator|&
operator|~
name|mode
operator|)
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|path
argument_list|,
name|mode
operator||
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IXUSR
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *---------------------------------------------------------------------------  *  * TclpCopyDirectory --  *  *      Recursively copies a directory.  The target directory dst must  *	not already exist.  Note that this function does not merge two  *	directory hierarchies, even if the target directory is an an  *	empty directory.  *  * Results:  *	If the directory was successfully copied, returns TCL_OK.  *	Otherwise the return value is TCL_ERROR, errno is set to indicate  *	the error, and the pathname of the file that caused the error  *	is stored in errorPtr.  See TclpCreateDirectory and TclpCopyFile  *	for a description of possible values for errno.  *  * Side effects:  *      An exact copy of the directory hierarchy src will be created  *	with the name dst.  If an error occurs, the error will  *      be returned immediately, and remaining files will not be  *	processed.  *  *---------------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclpCopyDirectory
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|errorPtr
parameter_list|)
name|char
modifier|*
name|src
decl_stmt|;
comment|/* Pathname of directory to be copied.  */
name|char
modifier|*
name|dst
decl_stmt|;
comment|/* Pathname of target directory. */
name|Tcl_DString
modifier|*
name|errorPtr
decl_stmt|;
comment|/* If non-NULL, initialized DString for 				 * error reporting. */
block|{
name|int
name|result
decl_stmt|;
name|Tcl_DString
name|srcBuffer
decl_stmt|;
name|Tcl_DString
name|dstBuffer
decl_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|srcBuffer
argument_list|)
expr_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|dstBuffer
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|srcBuffer
argument_list|,
name|src
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|dstBuffer
argument_list|,
name|dst
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TraverseUnixTree
argument_list|(
name|TraversalCopy
argument_list|,
operator|&
name|srcBuffer
argument_list|,
operator|&
name|dstBuffer
argument_list|,
name|errorPtr
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|srcBuffer
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|dstBuffer
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *---------------------------------------------------------------------------  *  * TclpRemoveDirectory --  *  *	Removes directory (and its contents, if the recursive flag is set).  *  * Results:  *	If the directory was successfully removed, returns TCL_OK.  *	Otherwise the return value is TCL_ERROR, errno is set to indicate  *	the error, and the pathname of the file that caused the error  *	is stored in errorPtr.  Some possible values for errno are:  *  *	EACCES:     path directory can't be read and/or written.  *	EEXIST:	    path is a non-empty directory.  *	EINVAL:	    path is a root directory.  *	ENOENT:	    path doesn't exist or is "".  * 	ENOTDIR:    path is not a directory.  *  * Side effects:  *	Directory removed.  If an error occurs, the error will be returned  *	immediately, and remaining files will not be deleted.  *  *---------------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclpRemoveDirectory
parameter_list|(
name|path
parameter_list|,
name|recursive
parameter_list|,
name|errorPtr
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Pathname of directory to be removed. */
name|int
name|recursive
decl_stmt|;
comment|/* If non-zero, removes directories that 				 * are nonempty.  Otherwise, will only remove 				 * empty directories. */
name|Tcl_DString
modifier|*
name|errorPtr
decl_stmt|;
comment|/* If non-NULL, initialized DString for 				 * error reporting. */
block|{
name|int
name|result
decl_stmt|;
name|Tcl_DString
name|buffer
decl_stmt|;
if|if
condition|(
name|rmdir
argument_list|(
name|path
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|errno
operator|==
name|ENOTEMPTY
condition|)
block|{
name|errno
operator|=
name|EEXIST
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|errno
operator|!=
name|EEXIST
operator|)
operator|||
operator|(
name|recursive
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|errorPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|errorPtr
argument_list|,
name|path
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * The directory is nonempty, but the recursive flag has been      * specified, so we recursively remove all the files in the directory.      */
name|Tcl_DStringInit
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|buffer
argument_list|,
name|path
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TraverseUnixTree
argument_list|(
name|TraversalDelete
argument_list|,
operator|&
name|buffer
argument_list|,
name|NULL
argument_list|,
name|errorPtr
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *---------------------------------------------------------------------------  *  * TraverseUnixTree --  *  *      Traverse directory tree specified by sourcePtr, calling the function   *	traverseProc for each file and directory encountered.  If destPtr   *	is non-null, each of name in the sourcePtr directory is appended to   *	the directory specified by destPtr and passed as the second argument   *	to traverseProc() .  *  * Results:  *      Standard Tcl result.  *  * Side effects:  *      None caused by TraverseUnixTree, however the user specified   *	traverseProc() may change state.  If an error occurs, the error will  *      be returned immediately, and remaining files will not be processed.  *  *---------------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TraverseUnixTree
parameter_list|(
name|traverseProc
parameter_list|,
name|sourcePtr
parameter_list|,
name|targetPtr
parameter_list|,
name|errorPtr
parameter_list|)
name|TraversalProc
modifier|*
name|traverseProc
decl_stmt|;
comment|/* Function to call for every file and 				 * directory in source hierarchy. */
name|Tcl_DString
modifier|*
name|sourcePtr
decl_stmt|;
comment|/* Pathname of source directory to be 				 * traversed. */
name|Tcl_DString
modifier|*
name|targetPtr
decl_stmt|;
comment|/* Pathname of directory to traverse in 				 * parallel with source directory. */
name|Tcl_DString
modifier|*
name|errorPtr
decl_stmt|;
comment|/* If non-NULL, an initialized DString for 				 * error reporting. */
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
name|char
modifier|*
name|source
decl_stmt|,
modifier|*
name|target
decl_stmt|,
modifier|*
name|errfile
decl_stmt|;
name|int
name|result
decl_stmt|,
name|sourceLen
decl_stmt|;
name|int
name|targetLen
init|=
literal|0
decl_stmt|;
comment|/* Initialization needed only to prevent 				 * warning in gcc. */
name|struct
name|dirent
modifier|*
name|dirp
decl_stmt|;
name|DIR
modifier|*
name|dp
decl_stmt|;
name|result
operator|=
name|TCL_OK
expr_stmt|;
name|source
operator|=
name|Tcl_DStringValue
argument_list|(
name|sourcePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetPtr
operator|!=
name|NULL
condition|)
block|{
name|target
operator|=
name|Tcl_DStringValue
argument_list|(
name|targetPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|target
operator|=
name|NULL
expr_stmt|;
block|}
name|errfile
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|source
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|errfile
operator|=
name|source
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* 	 * Process the regular file 	 */
return|return
call|(
modifier|*
name|traverseProc
call|)
argument_list|(
name|source
argument_list|,
name|target
argument_list|,
operator|&
name|statbuf
argument_list|,
name|DOTREE_F
argument_list|,
name|errorPtr
argument_list|)
return|;
block|}
name|dp
operator|=
name|opendir
argument_list|(
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
block|{
comment|/*  	 * Can't read directory 	 */
name|errfile
operator|=
name|source
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|result
operator|=
call|(
modifier|*
name|traverseProc
call|)
argument_list|(
name|source
argument_list|,
name|target
argument_list|,
operator|&
name|statbuf
argument_list|,
name|DOTREE_PRED
argument_list|,
name|errorPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|closedir
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
name|Tcl_DStringAppend
argument_list|(
name|sourcePtr
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|source
operator|=
name|Tcl_DStringValue
argument_list|(
name|sourcePtr
argument_list|)
expr_stmt|;
name|sourceLen
operator|=
name|Tcl_DStringLength
argument_list|(
name|sourcePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|targetPtr
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|target
operator|=
name|Tcl_DStringValue
argument_list|(
name|targetPtr
argument_list|)
expr_stmt|;
name|targetLen
operator|=
name|Tcl_DStringLength
argument_list|(
name|targetPtr
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|dirp
operator|=
name|readdir
argument_list|(
name|dp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|dirp
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|dirp
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/*  	 * Append name after slash, and recurse on the file. 	 */
name|Tcl_DStringAppend
argument_list|(
name|sourcePtr
argument_list|,
name|dirp
operator|->
name|d_name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|targetPtr
argument_list|,
name|dirp
operator|->
name|d_name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|TraverseUnixTree
argument_list|(
name|traverseProc
argument_list|,
name|sourcePtr
argument_list|,
name|targetPtr
argument_list|,
name|errorPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
break|break;
block|}
comment|/* 	 * Remove name after slash. 	 */
name|Tcl_DStringSetLength
argument_list|(
name|sourcePtr
argument_list|,
name|sourceLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DStringSetLength
argument_list|(
name|targetPtr
argument_list|,
name|targetLen
argument_list|)
expr_stmt|;
block|}
block|}
name|closedir
argument_list|(
name|dp
argument_list|)
expr_stmt|;
comment|/*      * Strip off the trailing slash we added      */
name|Tcl_DStringSetLength
argument_list|(
name|sourcePtr
argument_list|,
name|sourceLen
operator|-
literal|1
argument_list|)
expr_stmt|;
name|source
operator|=
name|Tcl_DStringValue
argument_list|(
name|sourcePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DStringSetLength
argument_list|(
name|targetPtr
argument_list|,
name|targetLen
operator|-
literal|1
argument_list|)
expr_stmt|;
name|target
operator|=
name|Tcl_DStringValue
argument_list|(
name|targetPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
comment|/* 	 * Call traverseProc() on a directory after visiting all the 	 * files in that directory. 	 */
name|result
operator|=
call|(
modifier|*
name|traverseProc
call|)
argument_list|(
name|source
argument_list|,
name|target
argument_list|,
operator|&
name|statbuf
argument_list|,
name|DOTREE_POSTD
argument_list|,
name|errorPtr
argument_list|)
expr_stmt|;
block|}
name|end
label|:
if|if
condition|(
name|errfile
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|errorPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|errorPtr
argument_list|,
name|errfile
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TraversalCopy  *  *      Called from TraverseUnixTree in order to execute a recursive copy of a   *      directory.   *  * Results:  *      Standard Tcl result.  *  * Side effects:  *      The file or directory src may be copied to dst, depending on   *      the value of type.  *        *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TraversalCopy
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|sbPtr
parameter_list|,
name|type
parameter_list|,
name|errorPtr
parameter_list|)
name|char
modifier|*
name|src
decl_stmt|;
comment|/* Source pathname to copy. */
name|char
modifier|*
name|dst
decl_stmt|;
comment|/* Destination pathname of copy. */
name|struct
name|stat
modifier|*
name|sbPtr
decl_stmt|;
comment|/* Stat info for file specified by src. */
name|int
name|type
decl_stmt|;
comment|/* Reason for call - see TraverseUnixTree(). */
name|Tcl_DString
modifier|*
name|errorPtr
decl_stmt|;
comment|/* If non-NULL, initialized DString for 				 * error return. */
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DOTREE_F
case|:
if|if
condition|(
name|TclpCopyFile
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|==
name|TCL_OK
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
break|break;
case|case
name|DOTREE_PRED
case|:
if|if
condition|(
name|TclpCreateDirectory
argument_list|(
name|dst
argument_list|)
operator|==
name|TCL_OK
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
break|break;
case|case
name|DOTREE_POSTD
case|:
if|if
condition|(
name|CopyFileAtts
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|sbPtr
argument_list|)
operator|==
name|TCL_OK
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
break|break;
block|}
comment|/*      * There shouldn't be a problem with src, because we already      * checked it to get here.      */
if|if
condition|(
name|errorPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|errorPtr
argument_list|,
name|dst
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *---------------------------------------------------------------------------  *  * TraversalDelete --  *  *      Called by procedure TraverseUnixTree for every file and directory  *	that it encounters in a directory hierarchy. This procedure unlinks  *      files, and removes directories after all the containing files   *      have been processed.  *  * Results:  *      Standard Tcl result.  *  * Side effects:  *      Files or directory specified by src will be deleted.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TraversalDelete
parameter_list|(
name|src
parameter_list|,
name|ignore
parameter_list|,
name|sbPtr
parameter_list|,
name|type
parameter_list|,
name|errorPtr
parameter_list|)
name|char
modifier|*
name|src
decl_stmt|;
comment|/* Source pathname. */
name|char
modifier|*
name|ignore
decl_stmt|;
comment|/* Destination pathname (not used). */
name|struct
name|stat
modifier|*
name|sbPtr
decl_stmt|;
comment|/* Stat info for file specified by src. */
name|int
name|type
decl_stmt|;
comment|/* Reason for call - see TraverseUnixTree(). */
name|Tcl_DString
modifier|*
name|errorPtr
decl_stmt|;
comment|/* If non-NULL, initialized DString for 				 * error return. */
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DOTREE_F
case|:
if|if
condition|(
name|unlink
argument_list|(
name|src
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
break|break;
case|case
name|DOTREE_PRED
case|:
return|return
name|TCL_OK
return|;
case|case
name|DOTREE_POSTD
case|:
if|if
condition|(
name|rmdir
argument_list|(
name|src
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
break|break;
block|}
if|if
condition|(
name|errorPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|errorPtr
argument_list|,
name|src
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CopyFileAtts  *  *      Copy the file attributes such as owner, group, permissions, and  *      modification date from one file to another.  *  * Results:  *      Standard Tcl result.  *  * Side effects:  *      user id, group id, permission bits, last modification time, and   *      last access time are updated in the new file to reflect the old  *      file.  *        *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CopyFileAtts
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|statBufPtr
parameter_list|)
name|char
modifier|*
name|src
decl_stmt|;
comment|/* Path name of source file */
name|char
modifier|*
name|dst
decl_stmt|;
comment|/* Path name of target file */
name|struct
name|stat
modifier|*
name|statBufPtr
decl_stmt|;
comment|/* ptr to stat info for source file */
block|{
name|struct
name|utimbuf
name|tval
decl_stmt|;
name|mode_t
name|newMode
decl_stmt|;
name|newMode
operator|=
name|statBufPtr
operator|->
name|st_mode
operator|&
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator||
name|S_IRWXU
operator||
name|S_IRWXG
operator||
name|S_IRWXO
operator|)
expr_stmt|;
comment|/*       * Note that if you copy a setuid file that is owned by someone      * else, and you are not root, then the copy will be setuid to you.      * The most correct implementation would probably be to have the      * copy not setuid to anyone if the original file was owned by       * someone else, but this corner case isn't currently handled.      * It would require another lstat(), or getuid().      */
if|if
condition|(
name|chmod
argument_list|(
name|dst
argument_list|,
name|newMode
argument_list|)
condition|)
block|{
name|newMode
operator|&=
operator|~
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator|)
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|dst
argument_list|,
name|newMode
argument_list|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
name|tval
operator|.
name|actime
operator|=
name|statBufPtr
operator|->
name|st_atime
expr_stmt|;
name|tval
operator|.
name|modtime
operator|=
name|statBufPtr
operator|->
name|st_mtime
expr_stmt|;
if|if
condition|(
name|utime
argument_list|(
name|dst
argument_list|,
operator|&
name|tval
argument_list|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * GetGroupAttribute  *  *      Gets the group attribute of a file.  *  * Results:  *      Standard TCL result. Returns a new Tcl_Obj in attributePtrPtr  *	if there is no error.  *  * Side effects:  *      A new object is allocated.  *        *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|GetGroupAttribute
parameter_list|(
name|interp
parameter_list|,
name|objIndex
parameter_list|,
name|fileName
parameter_list|,
name|attributePtrPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interp we are using for errors. */
name|int
name|objIndex
decl_stmt|;
comment|/* The index of the attribute. */
name|char
modifier|*
name|fileName
decl_stmt|;
comment|/* The name of the file. */
name|Tcl_Obj
modifier|*
modifier|*
name|attributePtrPtr
decl_stmt|;
comment|/* A pointer to return the object with. */
block|{
name|struct
name|stat
name|statBuf
decl_stmt|;
name|struct
name|group
modifier|*
name|groupPtr
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|fileName
argument_list|,
operator|&
name|statBuf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"could not stat file \""
argument_list|,
name|fileName
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|groupPtr
operator|=
name|getgrgid
argument_list|(
name|statBuf
operator|.
name|st_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|groupPtr
operator|==
name|NULL
condition|)
block|{
operator|*
name|attributePtrPtr
operator|=
name|Tcl_NewIntObj
argument_list|(
name|statBuf
operator|.
name|st_gid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|attributePtrPtr
operator|=
name|Tcl_NewStringObj
argument_list|(
name|groupPtr
operator|->
name|gr_name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|endgrent
argument_list|()
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * GetOwnerAttribute  *  *      Gets the owner attribute of a file.  *  * Results:  *      Standard TCL result. Returns a new Tcl_Obj in attributePtrPtr  *	if there is no error.  *  * Side effects:  *      A new object is allocated.  *        *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|GetOwnerAttribute
parameter_list|(
name|interp
parameter_list|,
name|objIndex
parameter_list|,
name|fileName
parameter_list|,
name|attributePtrPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interp we are using for errors. */
name|int
name|objIndex
decl_stmt|;
comment|/* The index of the attribute. */
name|char
modifier|*
name|fileName
decl_stmt|;
comment|/* The name of the file. */
name|Tcl_Obj
modifier|*
modifier|*
name|attributePtrPtr
decl_stmt|;
comment|/* A pointer to return the object with. */
block|{
name|struct
name|stat
name|statBuf
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pwPtr
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|fileName
argument_list|,
operator|&
name|statBuf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"could not stat file \""
argument_list|,
name|fileName
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|pwPtr
operator|=
name|getpwuid
argument_list|(
name|statBuf
operator|.
name|st_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwPtr
operator|==
name|NULL
condition|)
block|{
operator|*
name|attributePtrPtr
operator|=
name|Tcl_NewIntObj
argument_list|(
name|statBuf
operator|.
name|st_uid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|attributePtrPtr
operator|=
name|Tcl_NewStringObj
argument_list|(
name|pwPtr
operator|->
name|pw_name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|endpwent
argument_list|()
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * GetPermissionsAttribute  *  *      Gets the group attribute of a file.  *  * Results:  *      Standard TCL result. Returns a new Tcl_Obj in attributePtrPtr  *	if there is no error. The object will have ref count 0.  *  * Side effects:  *      A new object is allocated.  *        *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|GetPermissionsAttribute
parameter_list|(
name|interp
parameter_list|,
name|objIndex
parameter_list|,
name|fileName
parameter_list|,
name|attributePtrPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interp we are using for errors. */
name|int
name|objIndex
decl_stmt|;
comment|/* The index of the attribute. */
name|char
modifier|*
name|fileName
decl_stmt|;
comment|/* The name of the file. */
name|Tcl_Obj
modifier|*
modifier|*
name|attributePtrPtr
decl_stmt|;
comment|/* A pointer to return the object with. */
block|{
name|struct
name|stat
name|statBuf
decl_stmt|;
name|char
name|returnString
index|[
literal|6
index|]
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|fileName
argument_list|,
operator|&
name|statBuf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"could not stat file \""
argument_list|,
name|fileName
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|sprintf
argument_list|(
name|returnString
argument_list|,
literal|"%0#5lo"
argument_list|,
operator|(
name|statBuf
operator|.
name|st_mode
operator|&
literal|0x00007FFF
operator|)
argument_list|)
expr_stmt|;
operator|*
name|attributePtrPtr
operator|=
name|Tcl_NewStringObj
argument_list|(
name|returnString
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SetGroupAttribute  *  *      Sets the file to the given group.  *  * Results:  *      Standard TCL result.  *  * Side effects:  *      The group of the file is changed.  *        *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SetGroupAttribute
parameter_list|(
name|interp
parameter_list|,
name|objIndex
parameter_list|,
name|fileName
parameter_list|,
name|attributePtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interp we are using for errors. */
name|int
name|objIndex
decl_stmt|;
comment|/* The index of the attribute. */
name|char
modifier|*
name|fileName
decl_stmt|;
comment|/* The name of the file. */
name|Tcl_Obj
modifier|*
name|attributePtr
decl_stmt|;
comment|/* The attribute to set. */
block|{
name|gid_t
name|groupNumber
decl_stmt|;
name|long
name|placeHolder
decl_stmt|;
if|if
condition|(
name|Tcl_GetLongFromObj
argument_list|(
name|interp
argument_list|,
name|attributePtr
argument_list|,
operator|&
name|placeHolder
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|struct
name|group
modifier|*
name|groupPtr
decl_stmt|;
name|char
modifier|*
name|groupString
init|=
name|Tcl_GetStringFromObj
argument_list|(
name|attributePtr
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|groupPtr
operator|=
name|getgrnam
argument_list|(
name|groupString
argument_list|)
expr_stmt|;
if|if
condition|(
name|groupPtr
operator|==
name|NULL
condition|)
block|{
name|endgrent
argument_list|()
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"could not set group for file \""
argument_list|,
name|fileName
argument_list|,
literal|"\": group \""
argument_list|,
name|groupString
argument_list|,
literal|"\" does not exist"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|groupNumber
operator|=
name|groupPtr
operator|->
name|gr_gid
expr_stmt|;
block|}
else|else
block|{
name|groupNumber
operator|=
operator|(
name|gid_t
operator|)
name|placeHolder
expr_stmt|;
block|}
if|if
condition|(
name|chown
argument_list|(
name|fileName
argument_list|,
operator|-
literal|1
argument_list|,
name|groupNumber
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|endgrent
argument_list|()
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"could not set group for file \""
argument_list|,
name|fileName
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|endgrent
argument_list|()
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SetOwnerAttribute  *  *      Sets the file to the given owner.  *  * Results:  *      Standard TCL result.  *  * Side effects:  *      The group of the file is changed.  *        *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SetOwnerAttribute
parameter_list|(
name|interp
parameter_list|,
name|objIndex
parameter_list|,
name|fileName
parameter_list|,
name|attributePtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interp we are using for errors. */
name|int
name|objIndex
decl_stmt|;
comment|/* The index of the attribute. */
name|char
modifier|*
name|fileName
decl_stmt|;
comment|/* The name of the file. */
name|Tcl_Obj
modifier|*
name|attributePtr
decl_stmt|;
comment|/* The attribute to set. */
block|{
name|uid_t
name|userNumber
decl_stmt|;
name|long
name|placeHolder
decl_stmt|;
if|if
condition|(
name|Tcl_GetLongFromObj
argument_list|(
name|interp
argument_list|,
name|attributePtr
argument_list|,
operator|&
name|placeHolder
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|struct
name|passwd
modifier|*
name|pwPtr
decl_stmt|;
name|char
modifier|*
name|ownerString
init|=
name|Tcl_GetStringFromObj
argument_list|(
name|attributePtr
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|pwPtr
operator|=
name|getpwnam
argument_list|(
name|ownerString
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"could not set owner for file \""
argument_list|,
name|fileName
argument_list|,
literal|"\": user \""
argument_list|,
name|ownerString
argument_list|,
literal|"\" does not exist"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|userNumber
operator|=
name|pwPtr
operator|->
name|pw_uid
expr_stmt|;
block|}
else|else
block|{
name|userNumber
operator|=
operator|(
name|uid_t
operator|)
name|placeHolder
expr_stmt|;
block|}
if|if
condition|(
name|chown
argument_list|(
name|fileName
argument_list|,
name|userNumber
argument_list|,
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"could not set owner for file \""
argument_list|,
name|fileName
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SetPermissionsAttribute  *  *      Sets the file to the given group.  *  * Results:  *      Standard TCL result.  *  * Side effects:  *      The group of the file is changed.  *        *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SetPermissionsAttribute
parameter_list|(
name|interp
parameter_list|,
name|objIndex
parameter_list|,
name|fileName
parameter_list|,
name|attributePtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interp we are using for errors. */
name|int
name|objIndex
decl_stmt|;
comment|/* The index of the attribute. */
name|char
modifier|*
name|fileName
decl_stmt|;
comment|/* The name of the file. */
name|Tcl_Obj
modifier|*
name|attributePtr
decl_stmt|;
comment|/* The attribute to set. */
block|{
name|long
name|modeInt
decl_stmt|;
name|mode_t
name|newMode
decl_stmt|;
comment|/*      * mode_t is a long under SPARC; an int under SunOS. Since we do not      * know how big it really is, we get the long and then cast it      * down to a mode_t.      */
if|if
condition|(
name|Tcl_GetLongFromObj
argument_list|(
name|interp
argument_list|,
name|attributePtr
argument_list|,
operator|&
name|modeInt
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|newMode
operator|=
operator|(
name|mode_t
operator|)
name|modeInt
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|fileName
argument_list|,
name|newMode
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"could not set permissions for file \""
argument_list|,
name|fileName
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------------  *  * TclpListVolumes --  *  *	Lists the currently mounted volumes, which on UNIX is just /.  *  * Results:  *	A standard Tcl result.  Will always be TCL_OK, since there is no way  *	that this command can fail.  Also, the interpreter's result is set to   *	the list of volumes.  *  * Side effects:  *	None.  *  *---------------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclpListVolumes
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to which to pass 					 * the volume list. */
block|{
name|Tcl_Obj
modifier|*
name|resultPtr
decl_stmt|;
name|resultPtr
operator|=
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_SetStringObj
argument_list|(
name|resultPtr
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

end_unit

