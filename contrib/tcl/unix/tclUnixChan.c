begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclUnixChan.c  *  *	Common channel driver for Unix channels based on files, command  *	pipes and TCP sockets.  *  * Copyright (c) 1995-1997 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclUnixChan.c 1.203 97/06/20 13:03:18  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_comment
comment|/* Internal definitions for Tcl. */
end_comment

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/* Portability features for Tcl. */
end_comment

begin_comment
comment|/*  * sys/ioctl.h has already been included by tclPort.h.  Including termios.h  * or termio.h causes a bunch of warning messages because some duplicate  * (but not contradictory) #defines exist in termios.h and/or termio.h  */
end_comment

begin_undef
undef|#
directive|undef
name|NL0
end_undef

begin_undef
undef|#
directive|undef
name|NL1
end_undef

begin_undef
undef|#
directive|undef
name|CR0
end_undef

begin_undef
undef|#
directive|undef
name|CR1
end_undef

begin_undef
undef|#
directive|undef
name|CR2
end_undef

begin_undef
undef|#
directive|undef
name|CR3
end_undef

begin_undef
undef|#
directive|undef
name|TAB0
end_undef

begin_undef
undef|#
directive|undef
name|TAB1
end_undef

begin_undef
undef|#
directive|undef
name|TAB2
end_undef

begin_undef
undef|#
directive|undef
name|XTABS
end_undef

begin_undef
undef|#
directive|undef
name|BS0
end_undef

begin_undef
undef|#
directive|undef
name|BS1
end_undef

begin_undef
undef|#
directive|undef
name|FF0
end_undef

begin_undef
undef|#
directive|undef
name|FF1
end_undef

begin_undef
undef|#
directive|undef
name|ECHO
end_undef

begin_undef
undef|#
directive|undef
name|NOFLSH
end_undef

begin_undef
undef|#
directive|undef
name|TOSTOP
end_undef

begin_undef
undef|#
directive|undef
name|FLUSHO
end_undef

begin_undef
undef|#
directive|undef
name|PENDIN
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|USE_TERMIOS
end_ifdef

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !USE_TERMIOS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_TERMIO
end_ifdef

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !USE_TERMIO */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_SGTTY
end_ifdef

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_SGTTY */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !USE_TERMIO */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !USE_TERMIOS */
end_comment

begin_comment
comment|/*  * The following structure is used to set or get the serial port  * attributes in a platform-independant manner.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|TtyAttrs
block|{
name|int
name|baud
decl_stmt|;
name|int
name|parity
decl_stmt|;
name|int
name|data
decl_stmt|;
name|int
name|stop
decl_stmt|;
block|}
name|TtyAttrs
typedef|;
end_typedef

begin_comment
comment|/*  * This structure describes per-instance state of a file based channel.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|FileState
block|{
name|Tcl_Channel
name|channel
decl_stmt|;
comment|/* Channel associated with this file. */
name|int
name|fd
decl_stmt|;
comment|/* File handle. */
name|int
name|validMask
decl_stmt|;
comment|/* OR'ed combination of TCL_READABLE, 				 * TCL_WRITABLE, or TCL_EXCEPTION: indicates 				 * which operations are valid on the file. */
name|struct
name|FileState
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Pointer to next file in list of all 				 * file channels. */
block|}
name|FileState
typedef|;
end_typedef

begin_comment
comment|/*  * List of all file channels currently open.  */
end_comment

begin_decl_stmt
specifier|static
name|FileState
modifier|*
name|firstFilePtr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This structure describes per-instance state of a tcp based channel.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|TcpState
block|{
name|Tcl_Channel
name|channel
decl_stmt|;
comment|/* Channel associated with this file. */
name|int
name|fd
decl_stmt|;
comment|/* The socket itself. */
name|int
name|flags
decl_stmt|;
comment|/* ORed combination of the bitfields 				 * defined below. */
name|Tcl_TcpAcceptProc
modifier|*
name|acceptProc
decl_stmt|;
comment|/* Proc to call on accept. */
name|ClientData
name|acceptProcData
decl_stmt|;
comment|/* The data for the accept proc. */
block|}
name|TcpState
typedef|;
end_typedef

begin_comment
comment|/*  * These bits may be ORed together into the "flags" field of a TcpState  * structure.  */
end_comment

begin_define
define|#
directive|define
name|TCP_ASYNC_SOCKET
value|(1<<0)
end_define

begin_comment
comment|/* Asynchronous socket. */
end_comment

begin_define
define|#
directive|define
name|TCP_ASYNC_CONNECT
value|(1<<1)
end_define

begin_comment
comment|/* Async connect in progress. */
end_comment

begin_comment
comment|/*  * The following defines the maximum length of the listen queue. This is  * the number of outstanding yet-to-be-serviced requests for a connection  * on a server socket, more than this number of outstanding requests and  * the connection request will fail.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SOMAXCONN
end_ifndef

begin_define
define|#
directive|define
name|SOMAXCONN
value|100
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|SOMAXCONN
operator|<
literal|100
operator|)
end_if

begin_undef
undef|#
directive|undef
name|SOMAXCONN
end_undef

begin_define
define|#
directive|define
name|SOMAXCONN
value|100
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The following defines how much buffer space the kernel should maintain  * for a socket.  */
end_comment

begin_define
define|#
directive|define
name|SOCKET_BUFSIZE
value|4096
end_define

begin_comment
comment|/*  * Static routines for this file:  */
end_comment

begin_decl_stmt
specifier|static
name|TcpState
modifier|*
name|CreateSocket
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|port
operator|,
name|char
operator|*
name|host
operator|,
name|int
name|server
operator|,
name|char
operator|*
name|myaddr
operator|,
name|int
name|myport
operator|,
name|int
name|async
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CreateSocketAddress
name|_ANSI_ARGS_
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
name|sockaddrPtr
operator|,
name|char
operator|*
name|host
operator|,
name|int
name|port
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|FileBlockModeProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|int
name|mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|FileCloseProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|FileGetHandleProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|int
name|direction
operator|,
name|ClientData
operator|*
name|handlePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|FileInputProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|char
operator|*
name|buf
operator|,
name|int
name|toRead
operator|,
name|int
operator|*
name|errorCode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|FileOutputProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|char
operator|*
name|buf
operator|,
name|int
name|toWrite
operator|,
name|int
operator|*
name|errorCode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|FileSeekProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|long
name|offset
operator|,
name|int
name|mode
operator|,
name|int
operator|*
name|errorCode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|FileWatchProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|int
name|mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|TcpAccept
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|data
operator|,
name|int
name|mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TcpBlockModeProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|data
operator|,
name|int
name|mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TcpCloseProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TcpGetHandleProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|int
name|direction
operator|,
name|ClientData
operator|*
name|handlePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TcpGetOptionProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|optionName
operator|,
name|Tcl_DString
operator|*
name|dsPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TcpInputProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|char
operator|*
name|buf
operator|,
name|int
name|toRead
operator|,
name|int
operator|*
name|errorCode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TcpOutputProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|char
operator|*
name|buf
operator|,
name|int
name|toWrite
operator|,
name|int
operator|*
name|errorCode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|TcpWatchProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|int
name|mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TtyParseMode
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|CONST
name|char
operator|*
name|mode
operator|,
name|int
operator|*
name|speedPtr
operator|,
name|int
operator|*
name|parityPtr
operator|,
name|int
operator|*
name|dataPtr
operator|,
name|int
operator|*
name|stopPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|TtyGetAttributes
name|_ANSI_ARGS_
argument_list|(
operator|(
name|int
name|fd
operator|,
name|TtyAttrs
operator|*
name|ttyPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TtyGetOptionProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|optionName
operator|,
name|Tcl_DString
operator|*
name|dsPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|TtyInit
name|_ANSI_ARGS_
argument_list|(
operator|(
name|int
name|fd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|TtySetAttributes
name|_ANSI_ARGS_
argument_list|(
operator|(
name|int
name|fd
operator|,
name|TtyAttrs
operator|*
name|ttyPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TtySetOptionProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|optionName
operator|,
name|char
operator|*
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|WaitForConnect
name|_ANSI_ARGS_
argument_list|(
operator|(
name|TcpState
operator|*
name|statePtr
operator|,
name|int
operator|*
name|errorCodePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This structure describes the channel type structure for file based IO:  */
end_comment

begin_decl_stmt
specifier|static
name|Tcl_ChannelType
name|fileChannelType
init|=
block|{
literal|"file"
block|,
comment|/* Type name. */
name|FileBlockModeProc
block|,
comment|/* Set blocking/nonblocking mode.*/
name|FileCloseProc
block|,
comment|/* Close proc. */
name|FileInputProc
block|,
comment|/* Input proc. */
name|FileOutputProc
block|,
comment|/* Output proc. */
name|FileSeekProc
block|,
comment|/* Seek proc. */
name|NULL
block|,
comment|/* Set option proc. */
name|NULL
block|,
comment|/* Get option proc. */
name|FileWatchProc
block|,
comment|/* Initialize notifier. */
name|FileGetHandleProc
block|,
comment|/* Get OS handles out of channel. */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This structure describes the channel type structure for serial IO.  * Note that this type is a subclass of the "file" type.  */
end_comment

begin_decl_stmt
specifier|static
name|Tcl_ChannelType
name|ttyChannelType
init|=
block|{
literal|"tty"
block|,
comment|/* Type name. */
name|FileBlockModeProc
block|,
comment|/* Set blocking/nonblocking mode.*/
name|FileCloseProc
block|,
comment|/* Close proc. */
name|FileInputProc
block|,
comment|/* Input proc. */
name|FileOutputProc
block|,
comment|/* Output proc. */
name|NULL
block|,
comment|/* Seek proc. */
name|TtySetOptionProc
block|,
comment|/* Set option proc. */
name|TtyGetOptionProc
block|,
comment|/* Get option proc. */
name|FileWatchProc
block|,
comment|/* Initialize notifier. */
name|FileGetHandleProc
block|,
comment|/* Get OS handles out of channel. */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This structure describes the channel type structure for TCP socket  * based IO:  */
end_comment

begin_decl_stmt
specifier|static
name|Tcl_ChannelType
name|tcpChannelType
init|=
block|{
literal|"tcp"
block|,
comment|/* Type name. */
name|TcpBlockModeProc
block|,
comment|/* Set blocking/nonblocking mode.*/
name|TcpCloseProc
block|,
comment|/* Close proc. */
name|TcpInputProc
block|,
comment|/* Input proc. */
name|TcpOutputProc
block|,
comment|/* Output proc. */
name|NULL
block|,
comment|/* Seek proc. */
name|NULL
block|,
comment|/* Set option proc. */
name|TcpGetOptionProc
block|,
comment|/* Get option proc. */
name|TcpWatchProc
block|,
comment|/* Initialize notifier. */
name|TcpGetHandleProc
block|,
comment|/* Get OS handles out of channel. */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FileBlockModeProc --  *  *	Helper procedure to set blocking and nonblocking modes on a  *	file based channel. Invoked by generic IO level code.  *  * Results:  *	0 if successful, errno when failed.  *  * Side effects:  *	Sets the device into blocking or non-blocking mode.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|FileBlockModeProc
parameter_list|(
name|instanceData
parameter_list|,
name|mode
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* File state. */
name|int
name|mode
decl_stmt|;
comment|/* The mode to set. Can be one of                                          * TCL_MODE_BLOCKING or                                          * TCL_MODE_NONBLOCKING. */
block|{
name|FileState
modifier|*
name|fsPtr
init|=
operator|(
name|FileState
operator|*
operator|)
name|instanceData
decl_stmt|;
name|int
name|curStatus
decl_stmt|;
ifndef|#
directive|ifndef
name|USE_FIONBIO
name|curStatus
operator|=
name|fcntl
argument_list|(
name|fsPtr
operator|->
name|fd
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|TCL_MODE_BLOCKING
condition|)
block|{
name|curStatus
operator|&=
operator|(
operator|~
operator|(
name|O_NONBLOCK
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|curStatus
operator||=
name|O_NONBLOCK
expr_stmt|;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|fsPtr
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|curStatus
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|errno
return|;
block|}
name|curStatus
operator|=
name|fcntl
argument_list|(
name|fsPtr
operator|->
name|fd
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|mode
operator|==
name|TCL_MODE_BLOCKING
condition|)
block|{
name|curStatus
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|curStatus
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fsPtr
operator|->
name|fd
argument_list|,
operator|(
name|int
operator|)
name|FIONBIO
argument_list|,
operator|&
name|curStatus
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|errno
return|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FileInputProc --  *  *	This procedure is invoked from the generic IO level to read  *	input from a file based channel.  *  * Results:  *	The number of bytes read is returned or -1 on error. An output  *	argument contains a POSIX error code if an error occurs, or zero.  *  * Side effects:  *	Reads input from the input device of the channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|FileInputProc
parameter_list|(
name|instanceData
parameter_list|,
name|buf
parameter_list|,
name|toRead
parameter_list|,
name|errorCodePtr
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* File state. */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Where to store data read. */
name|int
name|toRead
decl_stmt|;
comment|/* How much space is available                                          * in the buffer? */
name|int
modifier|*
name|errorCodePtr
decl_stmt|;
comment|/* Where to store error code. */
block|{
name|FileState
modifier|*
name|fsPtr
init|=
operator|(
name|FileState
operator|*
operator|)
name|instanceData
decl_stmt|;
name|int
name|bytesRead
decl_stmt|;
comment|/* How many bytes were actually                                          * read from the input device? */
operator|*
name|errorCodePtr
operator|=
literal|0
expr_stmt|;
comment|/*      * Assume there is always enough input available. This will block      * appropriately, and read will unblock as soon as a short read is      * possible, if the channel is in blocking mode. If the channel is      * nonblocking, the read will never block.      */
name|bytesRead
operator|=
name|read
argument_list|(
name|fsPtr
operator|->
name|fd
argument_list|,
name|buf
argument_list|,
operator|(
name|size_t
operator|)
name|toRead
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytesRead
operator|>
operator|-
literal|1
condition|)
block|{
return|return
name|bytesRead
return|;
block|}
operator|*
name|errorCodePtr
operator|=
name|errno
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FileOutputProc--  *  *	This procedure is invoked from the generic IO level to write  *	output to a file channel.  *  * Results:  *	The number of bytes written is returned or -1 on error. An  *	output argument	contains a POSIX error code if an error occurred,  *	or zero.  *  * Side effects:  *	Writes output on the output device of the channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|FileOutputProc
parameter_list|(
name|instanceData
parameter_list|,
name|buf
parameter_list|,
name|toWrite
parameter_list|,
name|errorCodePtr
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* File state. */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* The data buffer. */
name|int
name|toWrite
decl_stmt|;
comment|/* How many bytes to write? */
name|int
modifier|*
name|errorCodePtr
decl_stmt|;
comment|/* Where to store error code. */
block|{
name|FileState
modifier|*
name|fsPtr
init|=
operator|(
name|FileState
operator|*
operator|)
name|instanceData
decl_stmt|;
name|int
name|written
decl_stmt|;
operator|*
name|errorCodePtr
operator|=
literal|0
expr_stmt|;
name|written
operator|=
name|write
argument_list|(
name|fsPtr
operator|->
name|fd
argument_list|,
name|buf
argument_list|,
operator|(
name|size_t
operator|)
name|toWrite
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|>
operator|-
literal|1
condition|)
block|{
return|return
name|written
return|;
block|}
operator|*
name|errorCodePtr
operator|=
name|errno
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FileCloseProc --  *  *	This procedure is called from the generic IO level to perform  *	channel-type-specific cleanup when a file based channel is closed.  *  * Results:  *	0 if successful, errno if failed.  *  * Side effects:  *	Closes the device of the channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|FileCloseProc
parameter_list|(
name|instanceData
parameter_list|,
name|interp
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* File state. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* For error reporting - unused. */
block|{
name|FileState
modifier|*
name|fsPtr
init|=
operator|(
name|FileState
operator|*
operator|)
name|instanceData
decl_stmt|;
name|FileState
modifier|*
modifier|*
name|nextPtrPtr
decl_stmt|;
name|int
name|errorCode
init|=
literal|0
decl_stmt|;
name|Tcl_DeleteFileHandler
argument_list|(
name|fsPtr
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TclInExit
argument_list|()
operator|||
operator|(
operator|(
name|fsPtr
operator|->
name|fd
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|fsPtr
operator|->
name|fd
operator|!=
literal|1
operator|)
operator|&&
operator|(
name|fsPtr
operator|->
name|fd
operator|!=
literal|2
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|close
argument_list|(
name|fsPtr
operator|->
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|errorCode
operator|=
name|errno
expr_stmt|;
block|}
block|}
for|for
control|(
name|nextPtrPtr
operator|=
operator|&
name|firstFilePtr
init|;
operator|(
operator|*
name|nextPtrPtr
operator|)
operator|!=
name|NULL
condition|;
name|nextPtrPtr
operator|=
operator|&
operator|(
operator|(
operator|*
name|nextPtrPtr
operator|)
operator|->
name|nextPtr
operator|)
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|nextPtrPtr
operator|)
operator|==
name|fsPtr
condition|)
block|{
operator|(
operator|*
name|nextPtrPtr
operator|)
operator|=
name|fsPtr
operator|->
name|nextPtr
expr_stmt|;
break|break;
block|}
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fsPtr
argument_list|)
expr_stmt|;
return|return
name|errorCode
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FileSeekProc --  *  *	This procedure is called by the generic IO level to move the  *	access point in a file based channel.  *  * Results:  *	-1 if failed, the new position if successful. An output  *	argument contains the POSIX error code if an error occurred,  *	or zero.  *  * Side effects:  *	Moves the location at which the channel will be accessed in  *	future operations.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|FileSeekProc
parameter_list|(
name|instanceData
parameter_list|,
name|offset
parameter_list|,
name|mode
parameter_list|,
name|errorCodePtr
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* File state. */
name|long
name|offset
decl_stmt|;
comment|/* Offset to seek to. */
name|int
name|mode
decl_stmt|;
comment|/* Relative to where                                                  * should we seek? Can be                                                  * one of SEEK_START,                                                  * SEEK_SET or SEEK_END. */
name|int
modifier|*
name|errorCodePtr
decl_stmt|;
comment|/* To store error code. */
block|{
name|FileState
modifier|*
name|fsPtr
init|=
operator|(
name|FileState
operator|*
operator|)
name|instanceData
decl_stmt|;
name|int
name|newLoc
decl_stmt|;
name|newLoc
operator|=
name|lseek
argument_list|(
name|fsPtr
operator|->
name|fd
argument_list|,
name|offset
argument_list|,
name|mode
argument_list|)
expr_stmt|;
operator|*
name|errorCodePtr
operator|=
operator|(
name|newLoc
operator|==
operator|-
literal|1
operator|)
condition|?
name|errno
else|:
literal|0
expr_stmt|;
return|return
name|newLoc
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FileWatchProc --  *  *	Initialize the notifier to watch the fd from this channel.  *  * Results:  *	None.  *  * Side effects:  *	Sets up the notifier so that a future event on the channel will  *	be seen by Tcl.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|FileWatchProc
parameter_list|(
name|instanceData
parameter_list|,
name|mask
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* The file state. */
name|int
name|mask
decl_stmt|;
comment|/* Events of interest; an OR-ed                                          * combination of TCL_READABLE,                                          * TCL_WRITABLE and TCL_EXCEPTION. */
block|{
name|FileState
modifier|*
name|fsPtr
init|=
operator|(
name|FileState
operator|*
operator|)
name|instanceData
decl_stmt|;
comment|/*      * Make sure we only register for events that are valid on this file.      * Note that we are passing Tcl_NotifyChannel directly to      * Tcl_CreateFileHandler with the channel pointer as the client data.      */
name|mask
operator|&=
name|fsPtr
operator|->
name|validMask
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|Tcl_CreateFileHandler
argument_list|(
name|fsPtr
operator|->
name|fd
argument_list|,
name|mask
argument_list|,
operator|(
name|Tcl_FileProc
operator|*
operator|)
name|Tcl_NotifyChannel
argument_list|,
operator|(
name|ClientData
operator|)
name|fsPtr
operator|->
name|channel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_DeleteFileHandler
argument_list|(
name|fsPtr
operator|->
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FileGetHandleProc --  *  *	Called from Tcl_GetChannelFile to retrieve OS handles from  *	a file based channel.  *  * Results:  *	Returns TCL_OK with the fd in handlePtr, or TCL_ERROR if  *	there is no handle for the specified direction.   *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|FileGetHandleProc
parameter_list|(
name|instanceData
parameter_list|,
name|direction
parameter_list|,
name|handlePtr
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* The file state. */
name|int
name|direction
decl_stmt|;
comment|/* TCL_READABLE or TCL_WRITABLE */
name|ClientData
modifier|*
name|handlePtr
decl_stmt|;
comment|/* Where to store the handle.  */
block|{
name|FileState
modifier|*
name|fsPtr
init|=
operator|(
name|FileState
operator|*
operator|)
name|instanceData
decl_stmt|;
if|if
condition|(
name|direction
operator|&
name|fsPtr
operator|->
name|validMask
condition|)
block|{
operator|*
name|handlePtr
operator|=
operator|(
name|ClientData
operator|)
name|fsPtr
operator|->
name|fd
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
else|else
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TtySetOptionProc --  *  *	Sets an option on a channel.  *  * Results:  *	A standard Tcl result. Also sets interp->result on error if  *	interp is not NULL.  *  * Side effects:  *	May modify an option on a device.  *      Sets Error message if needed (by calling Tcl_BadChannelOption).  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TtySetOptionProc
parameter_list|(
name|instanceData
parameter_list|,
name|interp
parameter_list|,
name|optionName
parameter_list|,
name|value
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* File state. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* For error reporting - can be NULL. */
name|char
modifier|*
name|optionName
decl_stmt|;
comment|/* Which option to set? */
name|char
modifier|*
name|value
decl_stmt|;
comment|/* New value for option. */
block|{
name|FileState
modifier|*
name|fsPtr
init|=
operator|(
name|FileState
operator|*
operator|)
name|instanceData
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|TtyAttrs
name|tty
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|optionName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|>
literal|1
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|optionName
argument_list|,
literal|"-mode"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|TtyParseMode
argument_list|(
name|interp
argument_list|,
name|value
argument_list|,
operator|&
name|tty
operator|.
name|baud
argument_list|,
operator|&
name|tty
operator|.
name|parity
argument_list|,
operator|&
name|tty
operator|.
name|data
argument_list|,
operator|&
name|tty
operator|.
name|stop
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
comment|/* 	 * system calls results should be checked there. -- dl 	 */
name|TtySetAttributes
argument_list|(
name|fsPtr
operator|->
name|fd
argument_list|,
operator|&
name|tty
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
else|else
block|{
return|return
name|Tcl_BadChannelOption
argument_list|(
name|interp
argument_list|,
name|optionName
argument_list|,
literal|"mode"
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TtyGetOptionProc --  *  *	Gets a mode associated with an IO channel. If the optionName arg  *	is non NULL, retrieves the value of that option. If the optionName  *	arg is NULL, retrieves a list of alternating option names and  *	values for the given channel.  *  * Results:  *	A standard Tcl result. Also sets the supplied DString to the  *	string value of the option(s) returned.  *  * Side effects:  *	The string returned by this function is in static storage and  *	may be reused at any time subsequent to the call.  *      Sets Error message if needed (by calling Tcl_BadChannelOption).  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TtyGetOptionProc
parameter_list|(
name|instanceData
parameter_list|,
name|interp
parameter_list|,
name|optionName
parameter_list|,
name|dsPtr
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* File state. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* For error reporting - can be NULL. */
name|char
modifier|*
name|optionName
decl_stmt|;
comment|/* Option to get. */
name|Tcl_DString
modifier|*
name|dsPtr
decl_stmt|;
comment|/* Where to store value(s). */
block|{
name|FileState
modifier|*
name|fsPtr
init|=
operator|(
name|FileState
operator|*
operator|)
name|instanceData
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|TtyAttrs
name|tty
decl_stmt|;
if|if
condition|(
name|optionName
operator|==
name|NULL
condition|)
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
literal|"-mode"
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|optionName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|len
operator|>
literal|1
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|optionName
argument_list|,
literal|"-mode"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|TtyGetAttributes
argument_list|(
name|fsPtr
operator|->
name|fd
argument_list|,
operator|&
name|tty
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d,%c,%d,%d"
argument_list|,
name|tty
operator|.
name|baud
argument_list|,
name|tty
operator|.
name|parity
argument_list|,
name|tty
operator|.
name|data
argument_list|,
name|tty
operator|.
name|stop
argument_list|)
expr_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
else|else
block|{
return|return
name|Tcl_BadChannelOption
argument_list|(
name|interp
argument_list|,
name|optionName
argument_list|,
literal|"mode"
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_undef
undef|#
directive|undef
name|DIRECT_BAUD
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|B4800
end_ifdef

begin_if
if|#
directive|if
operator|(
name|B4800
operator|==
literal|4800
operator|)
end_if

begin_define
define|#
directive|define
name|DIRECT_BAUD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DIRECT_BAUD
end_ifdef

begin_define
define|#
directive|define
name|TtyGetSpeed
parameter_list|(
name|baud
parameter_list|)
value|((unsigned) (baud))
end_define

begin_define
define|#
directive|define
name|TtyGetBaud
parameter_list|(
name|speed
parameter_list|)
value|((int) (speed))
end_define

begin_else
else|#
directive|else
end_else

begin_struct
specifier|static
struct|struct
block|{
name|int
name|baud
decl_stmt|;
name|unsigned
name|long
name|speed
decl_stmt|;
block|}
name|speeds
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|B0
block|{
literal|0
block|,
name|B0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B50
block|{
literal|50
block|,
name|B50
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B75
block|{
literal|75
block|,
name|B75
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B110
block|{
literal|110
block|,
name|B110
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B134
block|{
literal|134
block|,
name|B134
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B150
block|{
literal|150
block|,
name|B150
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B200
block|{
literal|200
block|,
name|B200
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B300
block|{
literal|300
block|,
name|B300
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B600
block|{
literal|600
block|,
name|B600
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B1200
block|{
literal|1200
block|,
name|B1200
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B1800
block|{
literal|1800
block|,
name|B1800
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B2400
block|{
literal|2400
block|,
name|B2400
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B4800
block|{
literal|4800
block|,
name|B4800
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B9600
block|{
literal|9600
block|,
name|B9600
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B14400
block|{
literal|14400
block|,
name|B14400
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B19200
block|{
literal|19200
block|,
name|B19200
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EXTA
block|{
literal|19200
block|,
name|EXTA
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B28800
block|{
literal|28800
block|,
name|B28800
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B38400
block|{
literal|38400
block|,
name|B38400
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EXTB
block|{
literal|38400
block|,
name|EXTB
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B57600
block|{
literal|57600
block|,
name|B57600
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_B57600
block|{
literal|57600
block|,
name|_B57600
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B76800
block|{
literal|76800
block|,
name|B76800
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B115200
block|{
literal|115200
block|,
name|B115200
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_B115200
block|{
literal|115200
block|,
name|_B115200
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B153600
block|{
literal|153600
block|,
name|B153600
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B230400
block|{
literal|230400
block|,
name|B230400
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B307200
block|{
literal|307200
block|,
name|B307200
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B460800
block|{
literal|460800
block|,
name|B460800
block|}
block|,
endif|#
directive|endif
block|{
operator|-
literal|1
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  *---------------------------------------------------------------------------  *  * TtyGetSpeed --  *  *	Given a baud rate, get the mask value that should be stored in  *	the termios, termio, or sgttyb structure in order to select that  *	baud rate.  *  * Results:  *	As above.  *  * Side effects:  *	None.  *  *---------------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|TtyGetSpeed
parameter_list|(
name|baud
parameter_list|)
name|int
name|baud
decl_stmt|;
comment|/* The baud rate to look up. */
block|{
name|int
name|bestIdx
decl_stmt|,
name|bestDiff
decl_stmt|,
name|i
decl_stmt|,
name|diff
decl_stmt|;
name|bestIdx
operator|=
literal|0
expr_stmt|;
name|bestDiff
operator|=
literal|1000000
expr_stmt|;
comment|/*      * If the baud rate does not correspond to one of the known mask values,      * choose the mask value whose baud rate is closest to the specified      * baud rate.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|speeds
index|[
name|i
index|]
operator|.
name|baud
operator|>=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|diff
operator|=
name|speeds
index|[
name|i
index|]
operator|.
name|baud
operator|-
name|baud
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
block|{
name|diff
operator|=
operator|-
name|diff
expr_stmt|;
block|}
if|if
condition|(
name|diff
operator|<
name|bestDiff
condition|)
block|{
name|bestIdx
operator|=
name|i
expr_stmt|;
name|bestDiff
operator|=
name|diff
expr_stmt|;
block|}
block|}
return|return
name|speeds
index|[
name|bestIdx
index|]
operator|.
name|speed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *---------------------------------------------------------------------------  *  * TtyGetBaud --  *  *	Given a speed mask value from a termios, termio, or sgttyb  *	structure, get the baus rate that corresponds to that mask value.  *  * Results:  *	As above.  If the mask value was not recognized, 0 is returned.  *  * Side effects:  *	None.  *  *---------------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TtyGetBaud
parameter_list|(
name|speed
parameter_list|)
name|unsigned
name|long
name|speed
decl_stmt|;
comment|/* Speed mask value to look up. */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|speeds
index|[
name|i
index|]
operator|.
name|baud
operator|>=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|speeds
index|[
name|i
index|]
operator|.
name|speed
operator|==
name|speed
condition|)
block|{
return|return
name|speeds
index|[
name|i
index|]
operator|.
name|baud
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !DIRECT_BAUD */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *---------------------------------------------------------------------------  *  * TtyInit --  *  *	Given file descriptor that refers to a serial port,   *	initialize the serial port to a set of sane values so that  *	Tcl can talk to a device located on the serial port.  *  * Results:  *	None.  *  * Side effects:  *	Serial device initialized.  *  *---------------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|TtyInit
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
comment|/* Open file descriptor for serial port to 				 * be initialized. */
block|{
ifdef|#
directive|ifdef
name|USE_TERMIOS
name|struct
name|termios
name|termios
decl_stmt|;
name|tcgetattr
argument_list|(
name|fd
argument_list|,
operator|&
name|termios
argument_list|)
expr_stmt|;
name|termios
operator|.
name|c_iflag
operator|=
name|IGNBRK
expr_stmt|;
name|termios
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|termios
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|termios
operator|.
name|c_cflag
operator||=
name|CREAD
expr_stmt|;
name|termios
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|60
expr_stmt|;
name|termios
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|2
expr_stmt|;
name|tcsetattr
argument_list|(
name|fd
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|termios
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !USE_TERMIOS */
ifdef|#
directive|ifdef
name|USE_TERMIO
name|struct
name|termio
name|termio
decl_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|termio
argument_list|)
expr_stmt|;
name|termio
operator|.
name|c_iflag
operator|=
name|IGNBRK
expr_stmt|;
name|termio
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|termio
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|termio
operator|.
name|c_cflag
operator||=
name|CREAD
expr_stmt|;
name|termio
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|60
expr_stmt|;
name|termio
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|2
expr_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|termio
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !USE_TERMIO */
ifdef|#
directive|ifdef
name|USE_SGTTY
name|struct
name|sgttyb
name|sgttyb
decl_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|sgttyb
argument_list|)
expr_stmt|;
name|sgttyb
operator|.
name|sg_flags
operator|&=
operator|(
name|EVENP
operator||
name|ODDP
operator|)
expr_stmt|;
name|sgttyb
operator|.
name|sg_flags
operator||=
name|RAW
expr_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|sgttyb
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_SGTTY */
endif|#
directive|endif
comment|/* !USE_TERMIO */
endif|#
directive|endif
comment|/* !USE_TERMIOS */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *---------------------------------------------------------------------------  *  * TtyGetAttributes --  *  *	Get the current attributes of the specified serial device.  *  * Results:  *	None.  *  * Side effects:  *	None.  *  *---------------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|TtyGetAttributes
parameter_list|(
name|fd
parameter_list|,
name|ttyPtr
parameter_list|)
name|int
name|fd
decl_stmt|;
comment|/* Open file descriptor for serial port to 				 * be queried. */
name|TtyAttrs
modifier|*
name|ttyPtr
decl_stmt|;
comment|/* Buffer filled with serial port 				 * attributes. */
block|{
ifdef|#
directive|ifdef
name|USE_TERMIOS
name|int
name|parity
decl_stmt|,
name|data
decl_stmt|;
name|struct
name|termios
name|termios
decl_stmt|;
name|tcgetattr
argument_list|(
name|fd
argument_list|,
operator|&
name|termios
argument_list|)
expr_stmt|;
name|ttyPtr
operator|->
name|baud
operator|=
name|TtyGetBaud
argument_list|(
name|cfgetospeed
argument_list|(
operator|&
name|termios
argument_list|)
argument_list|)
expr_stmt|;
name|parity
operator|=
literal|'n'
expr_stmt|;
ifdef|#
directive|ifdef
name|PAREXT
switch|switch
condition|(
call|(
name|int
call|)
argument_list|(
name|termios
operator|.
name|c_cflag
operator|&
operator|(
name|PARENB
operator||
name|PARODD
operator||
name|PAREXT
operator|)
argument_list|)
condition|)
block|{
case|case
name|PARENB
case|:
name|parity
operator|=
literal|'e'
expr_stmt|;
break|break;
case|case
name|PARENB
operator||
name|PARODD
case|:
name|parity
operator|=
literal|'o'
expr_stmt|;
break|break;
case|case
name|PARENB
operator||
name|PAREXT
case|:
name|parity
operator|=
literal|'s'
expr_stmt|;
break|break;
case|case
name|PARENB
operator||
name|PARODD
operator||
name|PAREXT
case|:
name|parity
operator|=
literal|'m'
expr_stmt|;
break|break;
block|}
else|#
directive|else
comment|/* !PAREXT */
switch|switch
condition|(
call|(
name|int
call|)
argument_list|(
name|termios
operator|.
name|c_cflag
operator|&
operator|(
name|PARENB
operator||
name|PARODD
operator|)
argument_list|)
condition|)
block|{
case|case
name|PARENB
case|:
name|parity
operator|=
literal|'e'
expr_stmt|;
break|break;
case|case
name|PARENB
operator||
name|PARODD
case|:
name|parity
operator|=
literal|'o'
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* !PAREXT */
name|ttyPtr
operator|->
name|parity
operator|=
name|parity
expr_stmt|;
name|data
operator|=
name|termios
operator|.
name|c_cflag
operator|&
name|CSIZE
expr_stmt|;
name|ttyPtr
operator|->
name|data
operator|=
operator|(
name|data
operator|==
name|CS5
operator|)
condition|?
literal|5
else|:
operator|(
name|data
operator|==
name|CS6
operator|)
condition|?
literal|6
else|:
operator|(
name|data
operator|==
name|CS7
operator|)
condition|?
literal|7
else|:
literal|8
expr_stmt|;
name|ttyPtr
operator|->
name|stop
operator|=
operator|(
name|termios
operator|.
name|c_cflag
operator|&
name|CSTOPB
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
else|#
directive|else
comment|/* !USE_TERMIOS */
ifdef|#
directive|ifdef
name|USE_TERMIO
name|int
name|parity
decl_stmt|,
name|data
decl_stmt|;
name|struct
name|termio
name|termio
decl_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|termio
argument_list|)
expr_stmt|;
name|ttyPtr
operator|->
name|baud
operator|=
name|TtyGetBaud
argument_list|(
name|termio
operator|.
name|c_cflag
operator|&
name|CBAUD
argument_list|)
expr_stmt|;
name|parity
operator|=
literal|'n'
expr_stmt|;
switch|switch
condition|(
name|termio
operator|.
name|c_cflag
operator|&
operator|(
name|PARENB
operator||
name|PARODD
operator||
name|PAREXT
operator|)
condition|)
block|{
case|case
name|PARENB
case|:
name|parity
operator|=
literal|'e'
expr_stmt|;
break|break;
case|case
name|PARENB
operator||
name|PARODD
case|:
name|parity
operator|=
literal|'o'
expr_stmt|;
break|break;
case|case
name|PARENB
operator||
name|PAREXT
case|:
name|parity
operator|=
literal|'s'
expr_stmt|;
break|break;
case|case
name|PARENB
operator||
name|PARODD
operator||
name|PAREXT
case|:
name|parity
operator|=
literal|'m'
expr_stmt|;
break|break;
block|}
name|ttyPtr
operator|->
name|parity
operator|=
name|parity
expr_stmt|;
name|data
operator|=
name|termio
operator|.
name|c_cflag
operator|&
name|CSIZE
expr_stmt|;
name|ttyPtr
operator|->
name|data
operator|=
operator|(
name|data
operator|==
name|CS5
operator|)
condition|?
literal|5
else|:
operator|(
name|data
operator|==
name|CS6
operator|)
condition|?
literal|6
else|:
operator|(
name|data
operator|==
name|CS7
operator|)
condition|?
literal|7
else|:
literal|8
expr_stmt|;
name|ttyPtr
operator|->
name|stop
operator|=
operator|(
name|termio
operator|.
name|c_cflag
operator|&
name|CSTOPB
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
else|#
directive|else
comment|/* !USE_TERMIO */
ifdef|#
directive|ifdef
name|USE_SGTTY
name|int
name|parity
decl_stmt|;
name|struct
name|sgttyb
name|sgttyb
decl_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|sgttyb
argument_list|)
expr_stmt|;
name|ttyPtr
operator|->
name|baud
operator|=
name|TtyGetBaud
argument_list|(
name|sgttyb
operator|.
name|sg_ospeed
argument_list|)
expr_stmt|;
name|parity
operator|=
literal|'n'
expr_stmt|;
if|if
condition|(
name|sgttyb
operator|.
name|sg_flags
operator|&
name|EVENP
condition|)
block|{
name|parity
operator|=
literal|'e'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sgttyb
operator|.
name|sg_flags
operator|&
name|ODDP
condition|)
block|{
name|parity
operator|=
literal|'o'
expr_stmt|;
block|}
name|ttyPtr
operator|->
name|parity
operator|=
name|parity
expr_stmt|;
name|ttyPtr
operator|->
name|data
operator|=
operator|(
name|sgttyb
operator|.
name|sg_flags
operator|&
operator|(
name|EVENP
operator||
name|ODDP
operator|)
operator|)
condition|?
literal|7
else|:
literal|8
expr_stmt|;
name|ttyPtr
operator|->
name|stop
operator|=
literal|1
expr_stmt|;
else|#
directive|else
comment|/* !USE_SGTTY */
name|ttyPtr
operator|->
name|baud
operator|=
literal|0
expr_stmt|;
name|ttyPtr
operator|->
name|parity
operator|=
literal|'n'
expr_stmt|;
name|ttyPtr
operator|->
name|data
operator|=
literal|0
expr_stmt|;
name|ttyPtr
operator|->
name|stop
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* !USE_SGTTY */
endif|#
directive|endif
comment|/* !USE_TERMIO */
endif|#
directive|endif
comment|/* !USE_TERMIOS */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *---------------------------------------------------------------------------  *  * TtySetAttributes --  *  *	Set the current attributes of the specified serial device.   *  * Results:  *	None.  *  * Side effects:  *	None.  *  *---------------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|TtySetAttributes
parameter_list|(
name|fd
parameter_list|,
name|ttyPtr
parameter_list|)
name|int
name|fd
decl_stmt|;
comment|/* Open file descriptor for serial port to 				 * be modified. */
name|TtyAttrs
modifier|*
name|ttyPtr
decl_stmt|;
comment|/* Buffer containing new attributes for 				 * serial port. */
block|{
ifdef|#
directive|ifdef
name|USE_TERMIOS
name|int
name|parity
decl_stmt|,
name|data
decl_stmt|,
name|flag
decl_stmt|;
name|struct
name|termios
name|termios
decl_stmt|;
name|tcgetattr
argument_list|(
name|fd
argument_list|,
operator|&
name|termios
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|termios
argument_list|,
name|TtyGetSpeed
argument_list|(
name|ttyPtr
operator|->
name|baud
argument_list|)
argument_list|)
expr_stmt|;
name|cfsetispeed
argument_list|(
operator|&
name|termios
argument_list|,
name|TtyGetSpeed
argument_list|(
name|ttyPtr
operator|->
name|baud
argument_list|)
argument_list|)
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
name|parity
operator|=
name|ttyPtr
operator|->
name|parity
expr_stmt|;
if|if
condition|(
name|parity
operator|!=
literal|'n'
condition|)
block|{
name|flag
operator||=
name|PARENB
expr_stmt|;
ifdef|#
directive|ifdef
name|PAREXT
name|termios
operator|.
name|c_cflag
operator|&=
operator|~
name|PAREXT
expr_stmt|;
if|if
condition|(
operator|(
name|parity
operator|==
literal|'m'
operator|)
operator|||
operator|(
name|parity
operator|==
literal|'s'
operator|)
condition|)
block|{
name|flag
operator||=
name|PAREXT
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|parity
operator|==
literal|'m'
operator|)
operator|||
operator|(
name|parity
operator|==
literal|'o'
operator|)
condition|)
block|{
name|flag
operator||=
name|PARODD
expr_stmt|;
block|}
block|}
name|data
operator|=
name|ttyPtr
operator|->
name|data
expr_stmt|;
name|flag
operator||=
operator|(
name|data
operator|==
literal|5
operator|)
condition|?
name|CS5
else|:
operator|(
name|data
operator|==
literal|6
operator|)
condition|?
name|CS6
else|:
operator|(
name|data
operator|==
literal|7
operator|)
condition|?
name|CS7
else|:
name|CS8
expr_stmt|;
if|if
condition|(
name|ttyPtr
operator|->
name|stop
operator|==
literal|2
condition|)
block|{
name|flag
operator||=
name|CSTOPB
expr_stmt|;
block|}
name|termios
operator|.
name|c_cflag
operator|&=
operator|~
operator|(
name|PARENB
operator||
name|PARODD
operator||
name|CSIZE
operator||
name|CSTOPB
operator|)
expr_stmt|;
name|termios
operator|.
name|c_cflag
operator||=
name|flag
expr_stmt|;
name|tcsetattr
argument_list|(
name|fd
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|termios
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !USE_TERMIOS */
ifdef|#
directive|ifdef
name|USE_TERMIO
name|int
name|parity
decl_stmt|,
name|data
decl_stmt|,
name|flag
decl_stmt|;
name|struct
name|termio
name|termio
decl_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|termio
argument_list|)
expr_stmt|;
name|termio
operator|.
name|c_cflag
operator|&=
operator|~
name|CBAUD
expr_stmt|;
name|termio
operator|.
name|c_cflag
operator||=
name|TtyGetSpeed
argument_list|(
name|ttyPtr
operator|->
name|baud
argument_list|)
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
name|parity
operator|=
name|ttyPtr
operator|->
name|parity
expr_stmt|;
if|if
condition|(
name|parity
operator|!=
literal|'n'
condition|)
block|{
name|flag
operator||=
name|PARENB
expr_stmt|;
if|if
condition|(
operator|(
name|parity
operator|==
literal|'m'
operator|)
operator|||
operator|(
name|parity
operator|==
literal|'s'
operator|)
condition|)
block|{
name|flag
operator||=
name|PAREXT
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|parity
operator|==
literal|'m'
operator|)
operator|||
operator|(
name|parity
operator|==
literal|'o'
operator|)
condition|)
block|{
name|flag
operator||=
name|PARODD
expr_stmt|;
block|}
block|}
name|data
operator|=
name|ttyPtr
operator|->
name|data
expr_stmt|;
name|flag
operator||=
operator|(
name|data
operator|==
literal|5
operator|)
condition|?
name|CS5
else|:
operator|(
name|data
operator|==
literal|6
operator|)
condition|?
name|CS6
else|:
operator|(
name|data
operator|==
literal|7
operator|)
condition|?
name|CS7
else|:
name|CS8
expr_stmt|;
if|if
condition|(
name|ttyPtr
operator|->
name|stop
operator|==
literal|2
condition|)
block|{
name|flag
operator||=
name|CSTOPB
expr_stmt|;
block|}
name|termio
operator|.
name|c_cflag
operator|&=
operator|~
operator|(
name|PARENB
operator||
name|PARODD
operator||
name|PAREXT
operator||
name|CSIZE
operator||
name|CSTOPB
operator|)
expr_stmt|;
name|termio
operator|.
name|c_cflag
operator||=
name|flag
expr_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|termio
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !USE_TERMIO */
ifdef|#
directive|ifdef
name|USE_SGTTY
name|int
name|parity
decl_stmt|;
name|struct
name|sgttyb
name|sgttyb
decl_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|sgttyb
argument_list|)
expr_stmt|;
name|sgttyb
operator|.
name|sg_ospeed
operator|=
name|TtyGetSpeed
argument_list|(
name|ttyPtr
operator|->
name|baud
argument_list|)
expr_stmt|;
name|sgttyb
operator|.
name|sg_ispeed
operator|=
name|TtyGetSpeed
argument_list|(
name|ttyPtr
operator|->
name|baud
argument_list|)
expr_stmt|;
name|parity
operator|=
name|ttyPtr
operator|->
name|parity
expr_stmt|;
if|if
condition|(
name|parity
operator|==
literal|'e'
condition|)
block|{
name|sgttyb
operator|.
name|sg_flags
operator|&=
operator|~
name|ODDP
expr_stmt|;
name|sgttyb
operator|.
name|sg_flags
operator||=
name|EVENP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parity
operator|==
literal|'o'
condition|)
block|{
name|sgttyb
operator|.
name|sg_flags
operator|&=
operator|~
name|EVENP
expr_stmt|;
name|sgttyb
operator|.
name|sg_flags
operator||=
name|ODDP
expr_stmt|;
block|}
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|sgttyb
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_SGTTY */
endif|#
directive|endif
comment|/* !USE_TERMIO */
endif|#
directive|endif
comment|/* !USE_TERMIOS */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *---------------------------------------------------------------------------  *  * TtyParseMode --  *  *	Parse the "-mode" argument to the fconfigure command.  The argument  *	is of the form baud,parity,data,stop.  *  * Results:  *	The return value is TCL_OK if the argument was successfully  *	parsed, TCL_ERROR otherwise.  If TCL_ERROR is returned, an  *	error message is left in interp->result (if interp is non-NULL).  *  * Side effects:  *	None.  *  *---------------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TtyParseMode
parameter_list|(
name|interp
parameter_list|,
name|mode
parameter_list|,
name|speedPtr
parameter_list|,
name|parityPtr
parameter_list|,
name|dataPtr
parameter_list|,
name|stopPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* If non-NULL, interp for error return. */
name|CONST
name|char
modifier|*
name|mode
decl_stmt|;
comment|/* Mode string to be parsed. */
name|int
modifier|*
name|speedPtr
decl_stmt|;
comment|/* Filled with baud rate from mode string. */
name|int
modifier|*
name|parityPtr
decl_stmt|;
comment|/* Filled with parity from mode string. */
name|int
modifier|*
name|dataPtr
decl_stmt|;
comment|/* Filled with data bits from mode string. */
name|int
modifier|*
name|stopPtr
decl_stmt|;
comment|/* Filled with stop bits from mode string. */
block|{
name|int
name|i
decl_stmt|,
name|end
decl_stmt|;
name|char
name|parity
decl_stmt|;
specifier|static
name|char
modifier|*
name|bad
init|=
literal|"bad value for -mode"
decl_stmt|;
name|i
operator|=
name|sscanf
argument_list|(
name|mode
argument_list|,
literal|"%d,%c,%d,%d%n"
argument_list|,
name|speedPtr
argument_list|,
operator|&
name|parity
argument_list|,
name|dataPtr
argument_list|,
name|stopPtr
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|!=
literal|4
operator|)
operator|||
operator|(
name|mode
index|[
name|end
index|]
operator|!=
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|bad
argument_list|,
literal|": should be baud,parity,data,stop"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|strchr
argument_list|(
literal|"noems"
argument_list|,
name|parity
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|bad
argument_list|,
literal|" parity: should be n, o, e, m, or s"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
operator|*
name|parityPtr
operator|=
name|parity
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|dataPtr
operator|<
literal|5
operator|)
operator|||
operator|(
operator|*
name|dataPtr
operator|>
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|bad
argument_list|,
literal|" data: should be 5, 6, 7, or 8"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|stopPtr
operator|<
literal|0
operator|)
operator|||
operator|(
operator|*
name|stopPtr
operator|>
literal|2
operator|)
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|bad
argument_list|,
literal|" stop: should be 1 or 2"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_OpenFileChannel --  *  *	Open an file based channel on Unix systems.  *  * Results:  *	The new channel or NULL. If NULL, the output argument  *	errorCodePtr is set to a POSIX error and an error message is  *	left in interp->result if interp is not NULL.  *  * Side effects:  *	May open the channel and may cause creation of a file on the  *	file system.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Channel
name|Tcl_OpenFileChannel
parameter_list|(
name|interp
parameter_list|,
name|fileName
parameter_list|,
name|modeString
parameter_list|,
name|permissions
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter for error reporting;                                          * can be NULL. */
name|char
modifier|*
name|fileName
decl_stmt|;
comment|/* Name of file to open. */
name|char
modifier|*
name|modeString
decl_stmt|;
comment|/* A list of POSIX open modes or                                          * a string such as "rw". */
name|int
name|permissions
decl_stmt|;
comment|/* If the open involves creating a                                          * file, with what modes to create                                          * it? */
block|{
name|int
name|fd
decl_stmt|,
name|seekFlag
decl_stmt|,
name|mode
decl_stmt|,
name|channelPermissions
decl_stmt|;
name|FileState
modifier|*
name|fsPtr
decl_stmt|;
name|char
modifier|*
name|nativeName
decl_stmt|,
name|channelName
index|[
literal|20
index|]
decl_stmt|;
name|Tcl_DString
name|buffer
decl_stmt|;
name|Tcl_ChannelType
modifier|*
name|channelTypePtr
decl_stmt|;
name|mode
operator|=
name|TclGetOpenMode
argument_list|(
name|interp
argument_list|,
name|modeString
argument_list|,
operator|&
name|seekFlag
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|NULL
return|;
block|}
switch|switch
condition|(
name|mode
operator|&
operator|(
name|O_RDONLY
operator||
name|O_WRONLY
operator||
name|O_RDWR
operator|)
condition|)
block|{
case|case
name|O_RDONLY
case|:
name|channelPermissions
operator|=
name|TCL_READABLE
expr_stmt|;
break|break;
case|case
name|O_WRONLY
case|:
name|channelPermissions
operator|=
name|TCL_WRITABLE
expr_stmt|;
break|break;
case|case
name|O_RDWR
case|:
name|channelPermissions
operator|=
operator|(
name|TCL_READABLE
operator||
name|TCL_WRITABLE
operator|)
expr_stmt|;
break|break;
default|default:
comment|/*              * This may occurr if modeString was "", for example.              */
name|panic
argument_list|(
literal|"Tcl_OpenFileChannel: invalid mode value"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|nativeName
operator|=
name|Tcl_TranslateFileName
argument_list|(
name|interp
argument_list|,
name|fileName
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|nativeName
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|fd
operator|=
name|open
argument_list|(
name|nativeName
argument_list|,
name|mode
argument_list|,
name|permissions
argument_list|)
expr_stmt|;
comment|/*      * If nativeName is not NULL, the buffer is valid and we must free      * the storage.      */
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't open \""
argument_list|,
name|fileName
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
comment|/*      * Set close-on-exec flag on the fd so that child processes will not      * inherit this fd.      */
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|channelName
argument_list|,
literal|"file%d"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|fsPtr
operator|=
operator|(
name|FileState
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|FileState
argument_list|)
argument_list|)
expr_stmt|;
name|fsPtr
operator|->
name|nextPtr
operator|=
name|firstFilePtr
expr_stmt|;
name|firstFilePtr
operator|=
name|fsPtr
expr_stmt|;
name|fsPtr
operator|->
name|validMask
operator|=
name|channelPermissions
operator||
name|TCL_EXCEPTION
expr_stmt|;
name|fsPtr
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
name|isatty
argument_list|(
name|fd
argument_list|)
condition|)
block|{
comment|/* 	 * Initialize the serial port to a set of sane parameters. 	 * Especially important if the remote device is set to echo and 	 * the serial port driver was also set to echo -- as soon as a char 	 * were sent to the serial port, the remote device would echo it, 	 * then the serial driver would echo it back to the device, etc. 	 */
name|TtyInit
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|channelTypePtr
operator|=
operator|&
name|ttyChannelType
expr_stmt|;
block|}
else|else
block|{
name|channelTypePtr
operator|=
operator|&
name|fileChannelType
expr_stmt|;
block|}
name|fsPtr
operator|->
name|channel
operator|=
name|Tcl_CreateChannel
argument_list|(
name|channelTypePtr
argument_list|,
name|channelName
argument_list|,
operator|(
name|ClientData
operator|)
name|fsPtr
argument_list|,
name|channelPermissions
argument_list|)
expr_stmt|;
if|if
condition|(
name|seekFlag
condition|)
block|{
if|if
condition|(
name|Tcl_Seek
argument_list|(
name|fsPtr
operator|->
name|channel
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't seek to end of file on \""
argument_list|,
name|channelName
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|Tcl_Close
argument_list|(
name|NULL
argument_list|,
name|fsPtr
operator|->
name|channel
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|channelTypePtr
operator|==
operator|&
name|ttyChannelType
condition|)
block|{
comment|/* 	 * Gotcha.  Most modems need a "\r" at the end of the command 	 * sequence.  If you just send "at\n", the modem will not respond 	 * with "OK" because it never got a "\r" to actually invoke the 	 * command.  So, by default, newlines are translated to "\r\n" on 	 * output to avoid "bug" reports that the serial port isn't working. 	 */
if|if
condition|(
name|Tcl_SetChannelOption
argument_list|(
name|interp
argument_list|,
name|fsPtr
operator|->
name|channel
argument_list|,
literal|"-translation"
argument_list|,
literal|"auto crlf"
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_Close
argument_list|(
name|NULL
argument_list|,
name|fsPtr
operator|->
name|channel
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
name|fsPtr
operator|->
name|channel
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_MakeFileChannel --  *  *	Makes a Tcl_Channel from an existing OS level file handle.  *  * Results:  *	The Tcl_Channel created around the preexisting OS level file handle.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Channel
name|Tcl_MakeFileChannel
parameter_list|(
name|handle
parameter_list|,
name|mode
parameter_list|)
name|ClientData
name|handle
decl_stmt|;
comment|/* OS level handle. */
name|int
name|mode
decl_stmt|;
comment|/* ORed combination of TCL_READABLE and                                  * TCL_WRITABLE to indicate file mode. */
block|{
name|FileState
modifier|*
name|fsPtr
decl_stmt|;
name|char
name|channelName
index|[
literal|20
index|]
decl_stmt|;
name|int
name|fd
init|=
operator|(
name|int
operator|)
name|handle
decl_stmt|;
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|sprintf
argument_list|(
name|channelName
argument_list|,
literal|"file%d"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
comment|/*      * Look to see if a channel with this fd and the same mode already exists.      * If the fd is used, but the mode doesn't match, return NULL.      */
for|for
control|(
name|fsPtr
operator|=
name|firstFilePtr
init|;
name|fsPtr
operator|!=
name|NULL
condition|;
name|fsPtr
operator|=
name|fsPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|fsPtr
operator|->
name|fd
operator|==
name|fd
condition|)
block|{
return|return
operator|(
name|mode
operator|==
name|fsPtr
operator|->
name|validMask
operator|)
condition|?
name|fsPtr
operator|->
name|channel
else|:
name|NULL
return|;
block|}
block|}
name|fsPtr
operator|=
operator|(
name|FileState
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|FileState
argument_list|)
argument_list|)
expr_stmt|;
name|fsPtr
operator|->
name|nextPtr
operator|=
name|firstFilePtr
expr_stmt|;
name|firstFilePtr
operator|=
name|fsPtr
expr_stmt|;
name|fsPtr
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|fsPtr
operator|->
name|validMask
operator|=
name|mode
operator||
name|TCL_EXCEPTION
expr_stmt|;
name|fsPtr
operator|->
name|channel
operator|=
name|Tcl_CreateChannel
argument_list|(
operator|&
name|fileChannelType
argument_list|,
name|channelName
argument_list|,
operator|(
name|ClientData
operator|)
name|fsPtr
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|fsPtr
operator|->
name|channel
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TcpBlockModeProc --  *  *	This procedure is invoked by the generic IO level to set blocking  *	and nonblocking mode on a TCP socket based channel.  *  * Results:  *	0 if successful, errno when failed.  *  * Side effects:  *	Sets the device into blocking or nonblocking mode.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TcpBlockModeProc
parameter_list|(
name|instanceData
parameter_list|,
name|mode
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* Socket state. */
name|int
name|mode
decl_stmt|;
comment|/* The mode to set. Can be one of                                          * TCL_MODE_BLOCKING or                                          * TCL_MODE_NONBLOCKING. */
block|{
name|TcpState
modifier|*
name|statePtr
init|=
operator|(
name|TcpState
operator|*
operator|)
name|instanceData
decl_stmt|;
name|int
name|setting
decl_stmt|;
ifndef|#
directive|ifndef
name|USE_FIONBIO
name|setting
operator|=
name|fcntl
argument_list|(
name|statePtr
operator|->
name|fd
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|TCL_MODE_BLOCKING
condition|)
block|{
name|statePtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|TCP_ASYNC_SOCKET
operator|)
operator|)
expr_stmt|;
name|setting
operator|&=
operator|(
operator|~
operator|(
name|O_NONBLOCK
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|statePtr
operator|->
name|flags
operator||=
name|TCP_ASYNC_SOCKET
expr_stmt|;
name|setting
operator||=
name|O_NONBLOCK
expr_stmt|;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|statePtr
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|setting
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|errno
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_FIONBIO
if|if
condition|(
name|mode
operator|==
name|TCL_MODE_BLOCKING
condition|)
block|{
name|statePtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|TCP_ASYNC_SOCKET
operator|)
operator|)
expr_stmt|;
name|setting
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|statePtr
operator|->
name|fd
argument_list|,
operator|(
name|int
operator|)
name|FIONBIO
argument_list|,
operator|&
name|setting
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|errno
return|;
block|}
block|}
else|else
block|{
name|statePtr
operator|->
name|flags
operator||=
name|TCP_ASYNC_SOCKET
expr_stmt|;
name|setting
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|statePtr
operator|->
name|fd
argument_list|,
operator|(
name|int
operator|)
name|FIONBIO
argument_list|,
operator|&
name|setting
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|errno
return|;
block|}
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * WaitForConnect --  *  *	Waits for a connection on an asynchronously opened socket to  *	be completed.  *  * Results:  *	None.  *  * Side effects:  *	The socket is connected after this function returns.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|WaitForConnect
parameter_list|(
name|statePtr
parameter_list|,
name|errorCodePtr
parameter_list|)
name|TcpState
modifier|*
name|statePtr
decl_stmt|;
comment|/* State of the socket. */
name|int
modifier|*
name|errorCodePtr
decl_stmt|;
comment|/* Where to store errors? */
block|{
name|int
name|timeOut
decl_stmt|;
comment|/* How long to wait. */
name|int
name|state
decl_stmt|;
comment|/* Of calling TclWaitForFile. */
name|int
name|flags
decl_stmt|;
comment|/* fcntl flags for the socket. */
comment|/*      * If an asynchronous connect is in progress, attempt to wait for it      * to complete before reading.      */
if|if
condition|(
name|statePtr
operator|->
name|flags
operator|&
name|TCP_ASYNC_CONNECT
condition|)
block|{
if|if
condition|(
name|statePtr
operator|->
name|flags
operator|&
name|TCP_ASYNC_SOCKET
condition|)
block|{
name|timeOut
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|timeOut
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|TclUnixWaitForFile
argument_list|(
name|statePtr
operator|->
name|fd
argument_list|,
name|TCL_WRITABLE
operator||
name|TCL_EXCEPTION
argument_list|,
name|timeOut
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|statePtr
operator|->
name|flags
operator|&
name|TCP_ASYNC_SOCKET
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_FIONBIO
name|flags
operator|=
name|fcntl
argument_list|(
name|statePtr
operator|->
name|fd
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|(
operator|~
operator|(
name|O_NONBLOCK
operator|)
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|statePtr
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_FIONBIO
name|flags
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|statePtr
operator|->
name|fd
argument_list|,
name|FIONBIO
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|state
operator|&
name|TCL_EXCEPTION
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|state
operator|&
name|TCL_WRITABLE
condition|)
block|{
name|statePtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|TCP_ASYNC_CONNECT
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|timeOut
operator|==
literal|0
condition|)
block|{
operator|*
name|errorCodePtr
operator|=
name|errno
operator|=
name|EWOULDBLOCK
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TcpInputProc --  *  *	This procedure is invoked by the generic IO level to read input  *	from a TCP socket based channel.  *  *	NOTE: We cannot share code with FilePipeInputProc because here  *	we must use recv to obtain the input from the channel, not read.  *  * Results:  *	The number of bytes read is returned or -1 on error. An output  *	argument contains the POSIX error code on error, or zero if no  *	error occurred.  *  * Side effects:  *	Reads input from the input device of the channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TcpInputProc
parameter_list|(
name|instanceData
parameter_list|,
name|buf
parameter_list|,
name|bufSize
parameter_list|,
name|errorCodePtr
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* Socket state. */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Where to store data read. */
name|int
name|bufSize
decl_stmt|;
comment|/* How much space is available                                          * in the buffer? */
name|int
modifier|*
name|errorCodePtr
decl_stmt|;
comment|/* Where to store error code. */
block|{
name|TcpState
modifier|*
name|statePtr
init|=
operator|(
name|TcpState
operator|*
operator|)
name|instanceData
decl_stmt|;
name|int
name|bytesRead
decl_stmt|,
name|state
decl_stmt|;
operator|*
name|errorCodePtr
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|WaitForConnect
argument_list|(
name|statePtr
argument_list|,
name|errorCodePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|bytesRead
operator|=
name|recv
argument_list|(
name|statePtr
operator|->
name|fd
argument_list|,
name|buf
argument_list|,
name|bufSize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytesRead
operator|>
operator|-
literal|1
condition|)
block|{
return|return
name|bytesRead
return|;
block|}
if|if
condition|(
name|errno
operator|==
name|ECONNRESET
condition|)
block|{
comment|/*          * Turn ECONNRESET into a soft EOF condition.          */
return|return
literal|0
return|;
block|}
operator|*
name|errorCodePtr
operator|=
name|errno
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TcpOutputProc --  *  *	This procedure is invoked by the generic IO level to write output  *	to a TCP socket based channel.  *  *	NOTE: We cannot share code with FilePipeOutputProc because here  *	we must use send, not write, to get reliable error reporting.  *  * Results:  *	The number of bytes written is returned. An output argument is  *	set to a POSIX error code if an error occurred, or zero.  *  * Side effects:  *	Writes output on the output device of the channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TcpOutputProc
parameter_list|(
name|instanceData
parameter_list|,
name|buf
parameter_list|,
name|toWrite
parameter_list|,
name|errorCodePtr
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* Socket state. */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* The data buffer. */
name|int
name|toWrite
decl_stmt|;
comment|/* How many bytes to write? */
name|int
modifier|*
name|errorCodePtr
decl_stmt|;
comment|/* Where to store error code. */
block|{
name|TcpState
modifier|*
name|statePtr
init|=
operator|(
name|TcpState
operator|*
operator|)
name|instanceData
decl_stmt|;
name|int
name|written
decl_stmt|;
name|int
name|state
decl_stmt|;
comment|/* Of waiting for connection. */
operator|*
name|errorCodePtr
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|WaitForConnect
argument_list|(
name|statePtr
argument_list|,
name|errorCodePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|written
operator|=
name|send
argument_list|(
name|statePtr
operator|->
name|fd
argument_list|,
name|buf
argument_list|,
name|toWrite
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|>
operator|-
literal|1
condition|)
block|{
return|return
name|written
return|;
block|}
operator|*
name|errorCodePtr
operator|=
name|errno
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TcpCloseProc --  *  *	This procedure is invoked by the generic IO level to perform  *	channel-type-specific cleanup when a TCP socket based channel  *	is closed.  *  * Results:  *	0 if successful, the value of errno if failed.  *  * Side effects:  *	Closes the socket of the channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TcpCloseProc
parameter_list|(
name|instanceData
parameter_list|,
name|interp
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* The socket to close. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* For error reporting - unused. */
block|{
name|TcpState
modifier|*
name|statePtr
init|=
operator|(
name|TcpState
operator|*
operator|)
name|instanceData
decl_stmt|;
name|int
name|errorCode
init|=
literal|0
decl_stmt|;
comment|/*      * Delete a file handler that may be active for this socket if this      * is a server socket - the file handler was created automatically      * by Tcl as part of the mechanism to accept new client connections.      * Channel handlers are already deleted in the generic IO channel      * closing code that called this function, so we do not have to      * delete them here.      */
name|Tcl_DeleteFileHandler
argument_list|(
name|statePtr
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|statePtr
operator|->
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|errorCode
operator|=
name|errno
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|statePtr
argument_list|)
expr_stmt|;
return|return
name|errorCode
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TcpGetOptionProc --  *  *	Computes an option value for a TCP socket based channel, or a  *	list of all options and their values.  *  *	Note: This code is based on code contributed by John Haxby.  *  * Results:  *	A standard Tcl result. The value of the specified option or a  *	list of all options and	their values is returned in the  *	supplied DString. Sets Error message if needed.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TcpGetOptionProc
parameter_list|(
name|instanceData
parameter_list|,
name|interp
parameter_list|,
name|optionName
parameter_list|,
name|dsPtr
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* Socket state. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* For error reporting - can be NULL. */
name|char
modifier|*
name|optionName
decl_stmt|;
comment|/* Name of the option to 				  * retrieve the value for, or 				  * NULL to get all options and 				  * their values. */
name|Tcl_DString
modifier|*
name|dsPtr
decl_stmt|;
comment|/* Where to store the computed 				  * value; initialized by caller. */
block|{
name|TcpState
modifier|*
name|statePtr
init|=
operator|(
name|TcpState
operator|*
operator|)
name|instanceData
decl_stmt|;
name|struct
name|sockaddr_in
name|sockname
decl_stmt|;
name|struct
name|sockaddr_in
name|peername
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hostEntPtr
decl_stmt|;
name|int
name|size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
name|optionName
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|optionName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|len
operator|>
literal|1
operator|)
operator|&&
operator|(
name|optionName
index|[
literal|1
index|]
operator|==
literal|'p'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|optionName
argument_list|,
literal|"-peername"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|getpeername
argument_list|(
name|statePtr
operator|->
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|peername
argument_list|,
operator|&
name|size
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
literal|"-peername"
argument_list|)
expr_stmt|;
name|Tcl_DStringStartSublist
argument_list|(
name|dsPtr
argument_list|)
expr_stmt|;
block|}
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
name|inet_ntoa
argument_list|(
name|peername
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|hostEntPtr
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|peername
operator|.
name|sin_addr
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|peername
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostEntPtr
operator|!=
operator|(
expr|struct
name|hostent
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
name|hostEntPtr
operator|->
name|h_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
name|inet_ntoa
argument_list|(
name|peername
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|ntohs
argument_list|(
name|peername
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|Tcl_DStringEndSublist
argument_list|(
name|dsPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|TCL_OK
return|;
block|}
block|}
else|else
block|{
comment|/*              * getpeername failed - but if we were asked for all the options              * (len==0), don't flag an error at that point because it could              * be an fconfigure request on a server socket. (which have              * no peer). same must be done on win&mac.              */
if|if
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|interp
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"can't get peername: "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|len
operator|>
literal|1
operator|)
operator|&&
operator|(
name|optionName
index|[
literal|1
index|]
operator|==
literal|'s'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|optionName
argument_list|,
literal|"-sockname"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|getsockname
argument_list|(
name|statePtr
operator|->
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sockname
argument_list|,
operator|&
name|size
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
literal|"-sockname"
argument_list|)
expr_stmt|;
name|Tcl_DStringStartSublist
argument_list|(
name|dsPtr
argument_list|)
expr_stmt|;
block|}
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
name|inet_ntoa
argument_list|(
name|sockname
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|hostEntPtr
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|sockname
operator|.
name|sin_addr
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|peername
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostEntPtr
operator|!=
operator|(
expr|struct
name|hostent
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
name|hostEntPtr
operator|->
name|h_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
name|inet_ntoa
argument_list|(
name|sockname
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|ntohs
argument_list|(
name|sockname
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|Tcl_DStringEndSublist
argument_list|(
name|dsPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|TCL_OK
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|interp
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"can't get sockname: "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
return|return
name|Tcl_BadChannelOption
argument_list|(
name|interp
argument_list|,
name|optionName
argument_list|,
literal|"peername sockname"
argument_list|)
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TcpWatchProc --  *  *	Initialize the notifier to watch the fd from this channel.  *  * Results:  *	None.  *  * Side effects:  *	Sets up the notifier so that a future event on the channel will  *	be seen by Tcl.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|TcpWatchProc
parameter_list|(
name|instanceData
parameter_list|,
name|mask
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* The socket state. */
name|int
name|mask
decl_stmt|;
comment|/* Events of interest; an OR-ed                                          * combination of TCL_READABLE,                                          * TCL_WRITABLE and TCL_EXCEPTION. */
block|{
name|TcpState
modifier|*
name|statePtr
init|=
operator|(
name|TcpState
operator|*
operator|)
name|instanceData
decl_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|Tcl_CreateFileHandler
argument_list|(
name|statePtr
operator|->
name|fd
argument_list|,
name|mask
argument_list|,
operator|(
name|Tcl_FileProc
operator|*
operator|)
name|Tcl_NotifyChannel
argument_list|,
operator|(
name|ClientData
operator|)
name|statePtr
operator|->
name|channel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_DeleteFileHandler
argument_list|(
name|statePtr
operator|->
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TcpGetHandleProc --  *  *	Called from Tcl_GetChannelFile to retrieve OS handles from inside  *	a TCP socket based channel.  *  * Results:  *	Returns TCL_OK with the fd in handlePtr, or TCL_ERROR if  *	there is no handle for the specified direction.   *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TcpGetHandleProc
parameter_list|(
name|instanceData
parameter_list|,
name|direction
parameter_list|,
name|handlePtr
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* The socket state. */
name|int
name|direction
decl_stmt|;
comment|/* Not used. */
name|ClientData
modifier|*
name|handlePtr
decl_stmt|;
comment|/* Where to store the handle.  */
block|{
name|TcpState
modifier|*
name|statePtr
init|=
operator|(
name|TcpState
operator|*
operator|)
name|instanceData
decl_stmt|;
operator|*
name|handlePtr
operator|=
operator|(
name|ClientData
operator|)
name|statePtr
operator|->
name|fd
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CreateSocket --  *  *	This function opens a new socket in client or server mode  *	and initializes the TcpState structure.  *  * Results:  *	Returns a new TcpState, or NULL with an error in interp->result,  *	if interp is not NULL.  *  * Side effects:  *	Opens a socket.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|TcpState
modifier|*
name|CreateSocket
parameter_list|(
name|interp
parameter_list|,
name|port
parameter_list|,
name|host
parameter_list|,
name|server
parameter_list|,
name|myaddr
parameter_list|,
name|myport
parameter_list|,
name|async
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* For error reporting; can be NULL. */
name|int
name|port
decl_stmt|;
comment|/* Port number to open. */
name|char
modifier|*
name|host
decl_stmt|;
comment|/* Name of host on which to open port. 				 * NULL implies INADDR_ANY */
name|int
name|server
decl_stmt|;
comment|/* 1 if socket should be a server socket, 				 * else 0 for a client socket. */
name|char
modifier|*
name|myaddr
decl_stmt|;
comment|/* Optional client-side address */
name|int
name|myport
decl_stmt|;
comment|/* Optional client-side port */
name|int
name|async
decl_stmt|;
comment|/* If nonzero and creating a client socket,                                  * attempt to do an async connect. Otherwise                                  * do a synchronous connect or bind. */
block|{
name|int
name|status
decl_stmt|,
name|sock
decl_stmt|,
name|asyncConnect
decl_stmt|,
name|curState
decl_stmt|,
name|origState
decl_stmt|;
name|struct
name|sockaddr_in
name|sockaddr
decl_stmt|;
comment|/* socket address */
name|struct
name|sockaddr_in
name|mysockaddr
decl_stmt|;
comment|/* Socket address for client */
name|TcpState
modifier|*
name|statePtr
decl_stmt|;
name|sock
operator|=
operator|-
literal|1
expr_stmt|;
name|origState
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|CreateSocketAddress
argument_list|(
operator|&
name|sockaddr
argument_list|,
name|host
argument_list|,
name|port
argument_list|)
condition|)
block|{
goto|goto
name|addressError
goto|;
block|}
if|if
condition|(
operator|(
name|myaddr
operator|!=
name|NULL
operator|||
name|myport
operator|!=
literal|0
operator|)
operator|&&
operator|!
name|CreateSocketAddress
argument_list|(
operator|&
name|mysockaddr
argument_list|,
name|myaddr
argument_list|,
name|myport
argument_list|)
condition|)
block|{
goto|goto
name|addressError
goto|;
block|}
name|sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
block|{
goto|goto
name|addressError
goto|;
block|}
comment|/*      * Set the close-on-exec flag so that the socket will not get      * inherited by child processes.      */
name|fcntl
argument_list|(
name|sock
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
comment|/*      * Set kernel space buffering      */
name|TclSockMinimumBuffers
argument_list|(
name|sock
argument_list|,
name|SOCKET_BUFSIZE
argument_list|)
expr_stmt|;
name|asyncConnect
operator|=
literal|0
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|server
condition|)
block|{
comment|/* 	 * Set up to reuse server addresses automatically and bind to the 	 * specified port. 	 */
name|status
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|status
argument_list|,
sizeof|sizeof
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|bind
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sockaddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
operator|-
literal|1
condition|)
block|{
name|status
operator|=
name|listen
argument_list|(
name|sock
argument_list|,
name|SOMAXCONN
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|myaddr
operator|!=
name|NULL
operator|||
name|myport
operator|!=
literal|0
condition|)
block|{
name|curState
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|curState
argument_list|,
sizeof|sizeof
argument_list|(
name|curState
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|bind
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|mysockaddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
goto|goto
name|bindError
goto|;
block|}
block|}
comment|/* 	 * Attempt to connect. The connect may fail at present with an 	 * EINPROGRESS but at a later time it will complete. The caller 	 * will set up a file handler on the socket if she is interested in 	 * being informed when the connect completes. 	 */
if|if
condition|(
name|async
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_FIONBIO
name|origState
operator|=
name|fcntl
argument_list|(
name|sock
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
name|curState
operator|=
name|origState
operator||
name|O_NONBLOCK
expr_stmt|;
name|status
operator|=
name|fcntl
argument_list|(
name|sock
argument_list|,
name|F_SETFL
argument_list|,
name|curState
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_FIONBIO
name|curState
operator|=
literal|1
expr_stmt|;
name|status
operator|=
name|ioctl
argument_list|(
name|sock
argument_list|,
name|FIONBIO
argument_list|,
operator|&
name|curState
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|status
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|>
operator|-
literal|1
condition|)
block|{
name|status
operator|=
name|connect
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sockaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sockaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINPROGRESS
condition|)
block|{
name|asyncConnect
operator|=
literal|1
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
name|bindError
label|:
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't open socket: "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sock
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
comment|/*      * Allocate a new TcpState for this socket.      */
name|statePtr
operator|=
operator|(
name|TcpState
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|TcpState
argument_list|)
argument_list|)
expr_stmt|;
name|statePtr
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|asyncConnect
condition|)
block|{
name|statePtr
operator|->
name|flags
operator|=
name|TCP_ASYNC_CONNECT
expr_stmt|;
block|}
name|statePtr
operator|->
name|fd
operator|=
name|sock
expr_stmt|;
return|return
name|statePtr
return|;
name|addressError
label|:
if|if
condition|(
name|sock
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't open socket: "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CreateSocketAddress --  *  *	This function initializes a sockaddr structure for a host and port.  *  * Results:  *	1 if the host was valid, 0 if the host could not be converted to  *	an IP address.  *  * Side effects:  *	Fills in the *sockaddrPtr structure.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CreateSocketAddress
parameter_list|(
name|sockaddrPtr
parameter_list|,
name|host
parameter_list|,
name|port
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|sockaddrPtr
decl_stmt|;
comment|/* Socket address */
name|char
modifier|*
name|host
decl_stmt|;
comment|/* Host.  NULL implies INADDR_ANY */
name|int
name|port
decl_stmt|;
comment|/* Port number */
block|{
name|struct
name|hostent
modifier|*
name|hostent
decl_stmt|;
comment|/* Host database entry */
name|struct
name|in_addr
name|addr
decl_stmt|;
comment|/* For 64/32 bit madness */
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|sockaddrPtr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|sockaddrPtr
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sockaddrPtr
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
call|(
name|unsigned
name|short
call|)
argument_list|(
name|port
operator|&
literal|0xFFFF
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|host
operator|==
name|NULL
condition|)
block|{
name|addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|.
name|s_addr
operator|==
operator|-
literal|1
condition|)
block|{
name|hostent
operator|=
name|gethostbyname
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostent
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
operator|&
name|addr
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|hostent
operator|->
name|h_addr_list
index|[
literal|0
index|]
argument_list|,
operator|(
name|size_t
operator|)
name|hostent
operator|->
name|h_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|EHOSTUNREACH
name|errno
operator|=
name|EHOSTUNREACH
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|ENXIO
name|errno
operator|=
name|ENXIO
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
literal|0
return|;
comment|/* error */
block|}
block|}
block|}
comment|/*      * NOTE: On 64 bit machines the assignment below is rumored to not      * do the right thing. Please report errors related to this if you      * observe incorrect behavior on 64 bit machines such as DEC Alphas.      * Should we modify this code to do an explicit memcpy?      */
name|sockaddrPtr
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|addr
operator|.
name|s_addr
expr_stmt|;
return|return
literal|1
return|;
comment|/* Success. */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_OpenTcpClient --  *  *	Opens a TCP client socket and creates a channel around it.  *  * Results:  *	The channel or NULL if failed.  An error message is returned  *	in the interpreter on failure.  *  * Side effects:  *	Opens a client socket and creates a new channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Channel
name|Tcl_OpenTcpClient
parameter_list|(
name|interp
parameter_list|,
name|port
parameter_list|,
name|host
parameter_list|,
name|myaddr
parameter_list|,
name|myport
parameter_list|,
name|async
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* For error reporting; can be NULL. */
name|int
name|port
decl_stmt|;
comment|/* Port number to open. */
name|char
modifier|*
name|host
decl_stmt|;
comment|/* Host on which to open port. */
name|char
modifier|*
name|myaddr
decl_stmt|;
comment|/* Client-side address */
name|int
name|myport
decl_stmt|;
comment|/* Client-side port */
name|int
name|async
decl_stmt|;
comment|/* If nonzero, attempt to do an                                          * asynchronous connect. Otherwise                                          * we do a blocking connect. */
block|{
name|TcpState
modifier|*
name|statePtr
decl_stmt|;
name|char
name|channelName
index|[
literal|20
index|]
decl_stmt|;
comment|/*      * Create a new client socket and wrap it in a channel.      */
name|statePtr
operator|=
name|CreateSocket
argument_list|(
name|interp
argument_list|,
name|port
argument_list|,
name|host
argument_list|,
literal|0
argument_list|,
name|myaddr
argument_list|,
name|myport
argument_list|,
name|async
argument_list|)
expr_stmt|;
if|if
condition|(
name|statePtr
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|statePtr
operator|->
name|acceptProc
operator|=
name|NULL
expr_stmt|;
name|statePtr
operator|->
name|acceptProcData
operator|=
operator|(
name|ClientData
operator|)
name|NULL
expr_stmt|;
name|sprintf
argument_list|(
name|channelName
argument_list|,
literal|"sock%d"
argument_list|,
name|statePtr
operator|->
name|fd
argument_list|)
expr_stmt|;
name|statePtr
operator|->
name|channel
operator|=
name|Tcl_CreateChannel
argument_list|(
operator|&
name|tcpChannelType
argument_list|,
name|channelName
argument_list|,
operator|(
name|ClientData
operator|)
name|statePtr
argument_list|,
operator|(
name|TCL_READABLE
operator||
name|TCL_WRITABLE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_SetChannelOption
argument_list|(
name|interp
argument_list|,
name|statePtr
operator|->
name|channel
argument_list|,
literal|"-translation"
argument_list|,
literal|"auto crlf"
argument_list|)
operator|==
name|TCL_ERROR
condition|)
block|{
name|Tcl_Close
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|statePtr
operator|->
name|channel
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|statePtr
operator|->
name|channel
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_MakeTcpClientChannel --  *  *	Creates a Tcl_Channel from an existing client TCP socket.  *  * Results:  *	The Tcl_Channel wrapped around the preexisting TCP socket.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Channel
name|Tcl_MakeTcpClientChannel
parameter_list|(
name|sock
parameter_list|)
name|ClientData
name|sock
decl_stmt|;
comment|/* The socket to wrap up into a channel. */
block|{
name|TcpState
modifier|*
name|statePtr
decl_stmt|;
name|char
name|channelName
index|[
literal|20
index|]
decl_stmt|;
name|statePtr
operator|=
operator|(
name|TcpState
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|TcpState
argument_list|)
argument_list|)
expr_stmt|;
name|statePtr
operator|->
name|fd
operator|=
operator|(
name|int
operator|)
name|sock
expr_stmt|;
name|statePtr
operator|->
name|acceptProc
operator|=
name|NULL
expr_stmt|;
name|statePtr
operator|->
name|acceptProcData
operator|=
operator|(
name|ClientData
operator|)
name|NULL
expr_stmt|;
name|sprintf
argument_list|(
name|channelName
argument_list|,
literal|"sock%d"
argument_list|,
name|statePtr
operator|->
name|fd
argument_list|)
expr_stmt|;
name|statePtr
operator|->
name|channel
operator|=
name|Tcl_CreateChannel
argument_list|(
operator|&
name|tcpChannelType
argument_list|,
name|channelName
argument_list|,
operator|(
name|ClientData
operator|)
name|statePtr
argument_list|,
operator|(
name|TCL_READABLE
operator||
name|TCL_WRITABLE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_SetChannelOption
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|statePtr
operator|->
name|channel
argument_list|,
literal|"-translation"
argument_list|,
literal|"auto crlf"
argument_list|)
operator|==
name|TCL_ERROR
condition|)
block|{
name|Tcl_Close
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|statePtr
operator|->
name|channel
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|statePtr
operator|->
name|channel
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_OpenTcpServer --  *  *	Opens a TCP server socket and creates a channel around it.  *  * Results:  *	The channel or NULL if failed. If an error occurred, an  *	error message is left in interp->result if interp is  *	not NULL.  *  * Side effects:  *	Opens a server socket and creates a new channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Channel
name|Tcl_OpenTcpServer
parameter_list|(
name|interp
parameter_list|,
name|port
parameter_list|,
name|myHost
parameter_list|,
name|acceptProc
parameter_list|,
name|acceptProcData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* For error reporting - may be                                          * NULL. */
name|int
name|port
decl_stmt|;
comment|/* Port number to open. */
name|char
modifier|*
name|myHost
decl_stmt|;
comment|/* Name of local host. */
name|Tcl_TcpAcceptProc
modifier|*
name|acceptProc
decl_stmt|;
comment|/* Callback for accepting connections                                          * from new clients. */
name|ClientData
name|acceptProcData
decl_stmt|;
comment|/* Data for the callback. */
block|{
name|TcpState
modifier|*
name|statePtr
decl_stmt|;
name|char
name|channelName
index|[
literal|20
index|]
decl_stmt|;
comment|/*      * Create a new client socket and wrap it in a channel.      */
name|statePtr
operator|=
name|CreateSocket
argument_list|(
name|interp
argument_list|,
name|port
argument_list|,
name|myHost
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|statePtr
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|statePtr
operator|->
name|acceptProc
operator|=
name|acceptProc
expr_stmt|;
name|statePtr
operator|->
name|acceptProcData
operator|=
name|acceptProcData
expr_stmt|;
comment|/*      * Set up the callback mechanism for accepting connections      * from new clients.      */
name|Tcl_CreateFileHandler
argument_list|(
name|statePtr
operator|->
name|fd
argument_list|,
name|TCL_READABLE
argument_list|,
name|TcpAccept
argument_list|,
operator|(
name|ClientData
operator|)
name|statePtr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|channelName
argument_list|,
literal|"sock%d"
argument_list|,
name|statePtr
operator|->
name|fd
argument_list|)
expr_stmt|;
name|statePtr
operator|->
name|channel
operator|=
name|Tcl_CreateChannel
argument_list|(
operator|&
name|tcpChannelType
argument_list|,
name|channelName
argument_list|,
operator|(
name|ClientData
operator|)
name|statePtr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|statePtr
operator|->
name|channel
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TcpAccept --  *	Accept a TCP socket connection.  This is called by the event loop.  *  * Results:  *	None.  *  * Side effects:  *	Creates a new connection socket. Calls the registered callback  *	for the connection acceptance mechanism.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|TcpAccept
parameter_list|(
name|data
parameter_list|,
name|mask
parameter_list|)
name|ClientData
name|data
decl_stmt|;
comment|/* Callback token. */
name|int
name|mask
decl_stmt|;
comment|/* Not used. */
block|{
name|TcpState
modifier|*
name|sockState
decl_stmt|;
comment|/* Client data of server socket. */
name|int
name|newsock
decl_stmt|;
comment|/* The new client socket */
name|TcpState
modifier|*
name|newSockState
decl_stmt|;
comment|/* State for new socket. */
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
comment|/* The remote address */
name|int
name|len
decl_stmt|;
comment|/* For accept interface */
name|char
name|channelName
index|[
literal|20
index|]
decl_stmt|;
name|sockState
operator|=
operator|(
name|TcpState
operator|*
operator|)
name|data
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|newsock
operator|=
name|accept
argument_list|(
name|sockState
operator|->
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsock
operator|<
literal|0
condition|)
block|{
return|return;
block|}
comment|/*      * Set close-on-exec flag to prevent the newly accepted socket from      * being inherited by child processes.      */
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|newsock
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
name|newSockState
operator|=
operator|(
name|TcpState
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|TcpState
argument_list|)
argument_list|)
expr_stmt|;
name|newSockState
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|newSockState
operator|->
name|fd
operator|=
name|newsock
expr_stmt|;
name|newSockState
operator|->
name|acceptProc
operator|=
operator|(
name|Tcl_TcpAcceptProc
operator|*
operator|)
name|NULL
expr_stmt|;
name|newSockState
operator|->
name|acceptProcData
operator|=
operator|(
name|ClientData
operator|)
name|NULL
expr_stmt|;
name|sprintf
argument_list|(
name|channelName
argument_list|,
literal|"sock%d"
argument_list|,
name|newsock
argument_list|)
expr_stmt|;
name|newSockState
operator|->
name|channel
operator|=
name|Tcl_CreateChannel
argument_list|(
operator|&
name|tcpChannelType
argument_list|,
name|channelName
argument_list|,
operator|(
name|ClientData
operator|)
name|newSockState
argument_list|,
operator|(
name|TCL_READABLE
operator||
name|TCL_WRITABLE
operator|)
argument_list|)
expr_stmt|;
name|Tcl_SetChannelOption
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|newSockState
operator|->
name|channel
argument_list|,
literal|"-translation"
argument_list|,
literal|"auto crlf"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockState
operator|->
name|acceptProc
operator|!=
operator|(
name|Tcl_TcpAcceptProc
operator|*
operator|)
name|NULL
condition|)
block|{
call|(
name|sockState
operator|->
name|acceptProc
call|)
argument_list|(
name|sockState
operator|->
name|acceptProcData
argument_list|,
name|newSockState
operator|->
name|channel
argument_list|,
name|inet_ntoa
argument_list|(
name|addr
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|addr
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclGetDefaultStdChannel --  *  *	Creates channels for standard input, standard output or standard  *	error output if they do not already exist.  *  * Results:  *	Returns the specified default standard channel, or NULL.  *  * Side effects:  *	May cause the creation of a standard channel and the underlying  *	file.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Channel
name|TclGetDefaultStdChannel
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
comment|/* One of TCL_STDIN, TCL_STDOUT, TCL_STDERR. */
block|{
name|Tcl_Channel
name|channel
init|=
name|NULL
decl_stmt|;
name|int
name|fd
init|=
literal|0
decl_stmt|;
comment|/* Initializations needed to prevent */
name|int
name|mode
init|=
literal|0
decl_stmt|;
comment|/* compiler warning (used before set). */
name|char
modifier|*
name|bufMode
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TCL_STDIN
case|:
if|if
condition|(
operator|(
name|lseek
argument_list|(
literal|0
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EBADF
operator|)
condition|)
block|{
return|return
operator|(
name|Tcl_Channel
operator|)
name|NULL
return|;
block|}
name|fd
operator|=
literal|0
expr_stmt|;
name|mode
operator|=
name|TCL_READABLE
expr_stmt|;
name|bufMode
operator|=
literal|"line"
expr_stmt|;
break|break;
case|case
name|TCL_STDOUT
case|:
if|if
condition|(
operator|(
name|lseek
argument_list|(
literal|1
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EBADF
operator|)
condition|)
block|{
return|return
operator|(
name|Tcl_Channel
operator|)
name|NULL
return|;
block|}
name|fd
operator|=
literal|1
expr_stmt|;
name|mode
operator|=
name|TCL_WRITABLE
expr_stmt|;
name|bufMode
operator|=
literal|"line"
expr_stmt|;
break|break;
case|case
name|TCL_STDERR
case|:
if|if
condition|(
operator|(
name|lseek
argument_list|(
literal|2
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EBADF
operator|)
condition|)
block|{
return|return
operator|(
name|Tcl_Channel
operator|)
name|NULL
return|;
block|}
name|fd
operator|=
literal|2
expr_stmt|;
name|mode
operator|=
name|TCL_WRITABLE
expr_stmt|;
name|bufMode
operator|=
literal|"none"
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"TclGetDefaultStdChannel: Unexpected channel type"
argument_list|)
expr_stmt|;
break|break;
block|}
name|channel
operator|=
name|Tcl_MakeFileChannel
argument_list|(
operator|(
name|ClientData
operator|)
name|fd
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/*      * Set up the normal channel options for stdio handles.      */
name|Tcl_SetChannelOption
argument_list|(
name|NULL
argument_list|,
name|channel
argument_list|,
literal|"-translation"
argument_list|,
literal|"auto"
argument_list|)
expr_stmt|;
name|Tcl_SetChannelOption
argument_list|(
name|NULL
argument_list|,
name|channel
argument_list|,
literal|"-buffering"
argument_list|,
name|bufMode
argument_list|)
expr_stmt|;
return|return
name|channel
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetOpenFile --  *  *	Given a name of a channel registered in the given interpreter,  *	returns a FILE * for it.  *  * Results:  *	A standard Tcl result. If the channel is registered in the given  *	interpreter and it is managed by the "file" channel driver, and  *	it is open for the requested mode, then the output parameter  *	filePtr is set to a FILE * for the underlying file. On error, the  *	filePtr is not set, TCL_ERROR is returned and an error message is  *	left in interp->result.  *  * Side effects:  *	May invoke fdopen to create the FILE * for the requested file.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_GetOpenFile
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|forWriting
parameter_list|,
name|checkUsage
parameter_list|,
name|filePtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to find file. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String that identifies file. */
name|int
name|forWriting
decl_stmt|;
comment|/* 1 means the file is going to be used 				 * for writing, 0 means for reading. */
name|int
name|checkUsage
decl_stmt|;
comment|/* 1 means verify that the file was opened 				 * in a mode that allows the access specified 				 * by "forWriting". Ignored, we always                                  * check that the channel is open for the                                  * requested mode. */
name|ClientData
modifier|*
name|filePtr
decl_stmt|;
comment|/* Store pointer to FILE structure here. */
block|{
name|Tcl_Channel
name|chan
decl_stmt|;
name|int
name|chanMode
decl_stmt|;
name|Tcl_ChannelType
modifier|*
name|chanTypePtr
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|chan
operator|=
name|Tcl_GetChannel
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
operator|&
name|chanMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|forWriting
operator|)
operator|&&
operator|(
operator|(
name|chanMode
operator|&
name|TCL_WRITABLE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"\""
argument_list|,
name|string
argument_list|,
literal|"\" wasn't opened for writing"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
operator|(
name|forWriting
operator|)
operator|)
operator|&&
operator|(
operator|(
name|chanMode
operator|&
name|TCL_READABLE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"\""
argument_list|,
name|string
argument_list|,
literal|"\" wasn't opened for reading"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * We allow creating a FILE * out of file based, pipe based and socket      * based channels. We currently do not allow any other channel types,      * because it is likely that stdio will not know what to do with them.      */
name|chanTypePtr
operator|=
name|Tcl_GetChannelType
argument_list|(
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chanTypePtr
operator|==
operator|&
name|fileChannelType
operator|)
operator|||
operator|(
name|chanTypePtr
operator|==
operator|&
name|tcpChannelType
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|chanTypePtr
operator|->
name|typeName
argument_list|,
literal|"pipe"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|Tcl_GetChannelHandle
argument_list|(
name|chan
argument_list|,
operator|(
name|forWriting
condition|?
name|TCL_WRITABLE
else|:
name|TCL_READABLE
operator|)
argument_list|,
operator|(
name|ClientData
operator|*
operator|)
operator|&
name|fd
argument_list|)
operator|==
name|TCL_OK
condition|)
block|{
comment|/* 	     * The call to fdopen below is probably dangerous, since it will 	     * truncate an existing file if the file is being opened 	     * for writing.... 	     */
name|f
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
operator|(
name|forWriting
condition|?
literal|"w"
else|:
literal|"r"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"cannot get a FILE * for \""
argument_list|,
name|string
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
operator|*
name|filePtr
operator|=
operator|(
name|ClientData
operator|)
name|f
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"\""
argument_list|,
name|string
argument_list|,
literal|"\" cannot be used to get a FILE *"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclUnixWaitForFile --  *  *	This procedure waits synchronously for a file to become readable  *	or writable, with an optional timeout.  *  * Results:  *	The return value is an OR'ed combination of TCL_READABLE,  *	TCL_WRITABLE, and TCL_EXCEPTION, indicating the conditions  *	that are present on file at the time of the return.  This  *	procedure will not return until either "timeout" milliseconds  *	have elapsed or at least one of the conditions given by mask  *	has occurred for file (a return value of 0 means that a timeout  *	occurred).  No normal events will be serviced during the  *	execution of this procedure.  *  * Side effects:  *	Time passes.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclUnixWaitForFile
parameter_list|(
name|fd
parameter_list|,
name|mask
parameter_list|,
name|timeout
parameter_list|)
name|int
name|fd
decl_stmt|;
comment|/* Handle for file on which to wait. */
name|int
name|mask
decl_stmt|;
comment|/* What to wait for: OR'ed combination of 				 * TCL_READABLE, TCL_WRITABLE, and 				 * TCL_EXCEPTION. */
name|int
name|timeout
decl_stmt|;
comment|/* Maximum amount of time to wait for one 				 * of the conditions in mask to occur, in 				 * milliseconds.  A value of 0 means don't 				 * wait at all, and a value of -1 means 				 * wait forever. */
block|{
name|Tcl_Time
name|abortTime
decl_stmt|,
name|now
decl_stmt|;
name|struct
name|timeval
name|blockTime
decl_stmt|,
modifier|*
name|timeoutPtr
decl_stmt|;
name|int
name|index
decl_stmt|,
name|bit
decl_stmt|,
name|numFound
decl_stmt|,
name|result
init|=
literal|0
decl_stmt|;
specifier|static
name|fd_mask
name|readyMasks
index|[
literal|3
operator|*
name|MASK_SIZE
index|]
decl_stmt|;
comment|/* This array reflects the readable/writable 				 * conditions that were found to exist by the 				 * last call to select. */
comment|/*      * If there is a non-zero finite timeout, compute the time when      * we give up.      */
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
name|TclpGetTime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|abortTime
operator|.
name|sec
operator|=
name|now
operator|.
name|sec
operator|+
name|timeout
operator|/
literal|1000
expr_stmt|;
name|abortTime
operator|.
name|usec
operator|=
name|now
operator|.
name|usec
operator|+
operator|(
name|timeout
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
if|if
condition|(
name|abortTime
operator|.
name|usec
operator|>=
literal|1000000
condition|)
block|{
name|abortTime
operator|.
name|usec
operator|-=
literal|1000000
expr_stmt|;
name|abortTime
operator|.
name|sec
operator|+=
literal|1
expr_stmt|;
block|}
name|timeoutPtr
operator|=
operator|&
name|blockTime
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|timeoutPtr
operator|=
operator|&
name|blockTime
expr_stmt|;
name|blockTime
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|blockTime
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|timeoutPtr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*      * Initialize the ready masks and compute the mask offsets.      */
if|if
condition|(
name|fd
operator|>=
name|FD_SETSIZE
condition|)
block|{
name|panic
argument_list|(
literal|"TclWaitForFile can't handle file id %d"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|readyMasks
argument_list|,
literal|0
argument_list|,
literal|3
operator|*
name|MASK_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|=
name|fd
operator|/
operator|(
name|NBBY
operator|*
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
operator|)
expr_stmt|;
name|bit
operator|=
literal|1
operator|<<
operator|(
name|fd
operator|%
operator|(
name|NBBY
operator|*
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/*      * Loop in a mini-event loop of our own, waiting for either the      * file to become ready or a timeout to occur.      */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
name|blockTime
operator|.
name|tv_sec
operator|=
name|abortTime
operator|.
name|sec
operator|-
name|now
operator|.
name|sec
expr_stmt|;
name|blockTime
operator|.
name|tv_usec
operator|=
name|abortTime
operator|.
name|usec
operator|-
name|now
operator|.
name|usec
expr_stmt|;
if|if
condition|(
name|blockTime
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|blockTime
operator|.
name|tv_sec
operator|-=
literal|1
expr_stmt|;
name|blockTime
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
if|if
condition|(
name|blockTime
operator|.
name|tv_sec
operator|<
literal|0
condition|)
block|{
name|blockTime
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|blockTime
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * Set the appropriate bit in the ready masks for the fd. 	 */
if|if
condition|(
name|mask
operator|&
name|TCL_READABLE
condition|)
block|{
name|readyMasks
index|[
name|index
index|]
operator||=
name|bit
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|TCL_WRITABLE
condition|)
block|{
operator|(
name|readyMasks
operator|+
name|MASK_SIZE
operator|)
index|[
name|index
index|]
operator||=
name|bit
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|TCL_EXCEPTION
condition|)
block|{
operator|(
name|readyMasks
operator|+
literal|2
operator|*
operator|(
name|MASK_SIZE
operator|)
operator|)
index|[
name|index
index|]
operator||=
name|bit
expr_stmt|;
block|}
comment|/* 	 * Wait for the event or a timeout. 	 */
name|numFound
operator|=
name|select
argument_list|(
name|fd
operator|+
literal|1
argument_list|,
operator|(
name|SELECT_MASK
operator|*
operator|)
operator|&
name|readyMasks
index|[
literal|0
index|]
argument_list|,
operator|(
name|SELECT_MASK
operator|*
operator|)
operator|&
name|readyMasks
index|[
name|MASK_SIZE
index|]
argument_list|,
operator|(
name|SELECT_MASK
operator|*
operator|)
operator|&
name|readyMasks
index|[
literal|2
operator|*
name|MASK_SIZE
index|]
argument_list|,
name|timeoutPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|numFound
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|readyMasks
index|[
name|index
index|]
operator|&
name|bit
condition|)
block|{
name|result
operator||=
name|TCL_READABLE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|readyMasks
operator|+
name|MASK_SIZE
operator|)
index|[
name|index
index|]
operator|&
name|bit
condition|)
block|{
name|result
operator||=
name|TCL_WRITABLE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|readyMasks
operator|+
literal|2
operator|*
operator|(
name|MASK_SIZE
operator|)
operator|)
index|[
name|index
index|]
operator|&
name|bit
condition|)
block|{
name|result
operator||=
name|TCL_EXCEPTION
expr_stmt|;
block|}
name|result
operator|&=
name|mask
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
break|break;
block|}
comment|/* 	 * The select returned early, so we need to recompute the timeout. 	 */
name|TclpGetTime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|abortTime
operator|.
name|sec
operator|<
name|now
operator|.
name|sec
operator|)
operator|||
operator|(
operator|(
name|abortTime
operator|.
name|sec
operator|==
name|now
operator|.
name|sec
operator|)
operator|&&
operator|(
name|abortTime
operator|.
name|usec
operator|<=
name|now
operator|.
name|usec
operator|)
operator|)
condition|)
block|{
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

end_unit

