begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclUnixChan.c  *  *	Common channel driver for Unix channels based on files, command  *	pipes and TCP sockets.  *  * Copyright (c) 1995-1996 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclUnixChan.c 1.172 96/06/11 10:14:51  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_comment
comment|/* Internal definitions for Tcl. */
end_comment

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/* Portability features for Tcl. */
end_comment

begin_comment
comment|/*  * This structure describes per-instance state of a pipe based channel.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|PipeState
block|{
name|Tcl_File
name|readFile
decl_stmt|;
comment|/* Output from pipe. */
name|Tcl_File
name|writeFile
decl_stmt|;
comment|/* Input to pipe. */
name|Tcl_File
name|errorFile
decl_stmt|;
comment|/* Error output from pipe. */
name|int
name|numPids
decl_stmt|;
comment|/* How many processes are attached to this pipe? */
name|int
modifier|*
name|pidPtr
decl_stmt|;
comment|/* The process IDs themselves. Allocated by                          * the creator of the pipe. */
name|int
name|isNonBlocking
decl_stmt|;
comment|/* Nonzero when the pipe is in nonblocking mode.                          * Used to decide whether to wait for the children                          * at close time. */
block|}
name|PipeState
typedef|;
end_typedef

begin_comment
comment|/*  * This structure describes per-instance state of a tcp based channel.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|TcpState
block|{
name|int
name|flags
decl_stmt|;
comment|/* ORed combination of the                                          * bitfields defined below. */
name|Tcl_File
name|sock
decl_stmt|;
comment|/* The socket itself. */
name|Tcl_TcpAcceptProc
modifier|*
name|acceptProc
decl_stmt|;
comment|/* Proc to call on accept. */
name|ClientData
name|acceptProcData
decl_stmt|;
comment|/* The data for the accept proc. */
block|}
name|TcpState
typedef|;
end_typedef

begin_comment
comment|/*  * These bits may be ORed together into the "flags" field of a TcpState  * structure.  */
end_comment

begin_define
define|#
directive|define
name|TCP_ASYNC_SOCKET
value|(1<<0)
end_define

begin_comment
comment|/* Asynchronous socket. */
end_comment

begin_define
define|#
directive|define
name|TCP_ASYNC_CONNECT
value|(1<<1)
end_define

begin_comment
comment|/* Async connect in progress. */
end_comment

begin_comment
comment|/*  * The following defines the maximum length of the listen queue. This is  * the number of outstanding yet-to-be-serviced requests for a connection  * on a server socket, more than this number of outstanding requests and  * the connection request will fail.  */
end_comment

begin_define
define|#
directive|define
name|TCL_LISTEN_LIMIT
value|100
end_define

begin_comment
comment|/*  * The following defines how much buffer space the kernel should maintain  * for a socket.  */
end_comment

begin_define
define|#
directive|define
name|SOCKET_BUFSIZE
value|4096
end_define

begin_comment
comment|/*  * Static routines for this file:  */
end_comment

begin_decl_stmt
specifier|static
name|TcpState
modifier|*
name|CreateSocket
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|port
operator|,
name|char
operator|*
name|host
operator|,
name|int
name|server
operator|,
name|char
operator|*
name|myaddr
operator|,
name|int
name|myport
operator|,
name|int
name|async
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CreateSocketAddress
name|_ANSI_ARGS_
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
name|sockaddrPtr
operator|,
name|char
operator|*
name|host
operator|,
name|int
name|port
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|FileBlockModeProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|Tcl_File
name|inFile
operator|,
name|Tcl_File
name|outFile
operator|,
name|int
name|mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|FileCloseProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_File
name|inFile
operator|,
name|Tcl_File
name|outFile
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|FilePipeInputProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|Tcl_File
name|inFile
operator|,
name|char
operator|*
name|buf
operator|,
name|int
name|toRead
operator|,
name|int
operator|*
name|errorCode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|FilePipeOutputProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|Tcl_File
name|outFile
operator|,
name|char
operator|*
name|buf
operator|,
name|int
name|toWrite
operator|,
name|int
operator|*
name|errorCode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|FileSeekProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|Tcl_File
name|inFile
operator|,
name|Tcl_File
name|outFile
operator|,
name|long
name|offset
operator|,
name|int
name|mode
operator|,
name|int
operator|*
name|errorCode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|PipeBlockModeProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|Tcl_File
name|inFile
operator|,
name|Tcl_File
name|outFile
operator|,
name|int
name|mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|PipeCloseProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_File
name|inFile
operator|,
name|Tcl_File
name|outFile
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|TcpAccept
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|data
operator|,
name|int
name|mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TcpBlockModeProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|data
operator|,
name|Tcl_File
name|inFile
operator|,
name|Tcl_File
name|outFile
operator|,
name|int
name|mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TcpCloseProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_File
name|inFile
operator|,
name|Tcl_File
name|outFile
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TcpGetOptionProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|char
operator|*
name|optionName
operator|,
name|Tcl_DString
operator|*
name|dsPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TcpInputProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|Tcl_File
name|infile
operator|,
name|char
operator|*
name|buf
operator|,
name|int
name|toRead
operator|,
name|int
operator|*
name|errorCode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TcpOutputProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|instanceData
operator|,
name|Tcl_File
name|outFile
operator|,
name|char
operator|*
name|buf
operator|,
name|int
name|toWrite
operator|,
name|int
operator|*
name|errorCode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|WaitForConnect
name|_ANSI_ARGS_
argument_list|(
operator|(
name|TcpState
operator|*
name|statePtr
operator|,
name|Tcl_File
name|fileToWaitFor
operator|,
name|int
operator|*
name|errorCodePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This structure describes the channel type structure for file based IO:  */
end_comment

begin_decl_stmt
specifier|static
name|Tcl_ChannelType
name|fileChannelType
init|=
block|{
literal|"file"
block|,
comment|/* Type name. */
name|FileBlockModeProc
block|,
comment|/* Set blocking/nonblocking mode.*/
name|FileCloseProc
block|,
comment|/* Close proc. */
name|FilePipeInputProc
block|,
comment|/* Input proc. */
name|FilePipeOutputProc
block|,
comment|/* Output proc. */
name|FileSeekProc
block|,
comment|/* Seek proc. */
name|NULL
block|,
comment|/* Set option proc. */
name|NULL
block|,
comment|/* Get option proc. */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This structure describes the channel type structure for command pipe  * based IO:  */
end_comment

begin_decl_stmt
specifier|static
name|Tcl_ChannelType
name|pipeChannelType
init|=
block|{
literal|"pipe"
block|,
comment|/* Type name. */
name|PipeBlockModeProc
block|,
comment|/* Set blocking/nonblocking mode.*/
name|PipeCloseProc
block|,
comment|/* Close proc. */
name|FilePipeInputProc
block|,
comment|/* Input proc. */
name|FilePipeOutputProc
block|,
comment|/* Output proc. */
name|NULL
block|,
comment|/* Seek proc. */
name|NULL
block|,
comment|/* Set option proc. */
name|NULL
block|,
comment|/* Get option proc. */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This structure describes the channel type structure for TCP socket  * based IO:  */
end_comment

begin_decl_stmt
specifier|static
name|Tcl_ChannelType
name|tcpChannelType
init|=
block|{
literal|"tcp"
block|,
comment|/* Type name. */
name|TcpBlockModeProc
block|,
comment|/* Set blocking/nonblocking mode.*/
name|TcpCloseProc
block|,
comment|/* Close proc. */
name|TcpInputProc
block|,
comment|/* Input proc. */
name|TcpOutputProc
block|,
comment|/* Output proc. */
name|NULL
block|,
comment|/* Seek proc. */
name|NULL
block|,
comment|/* Set option proc. */
name|TcpGetOptionProc
block|,
comment|/* Get option proc. */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FileBlockModeProc --  *  *	Helper procedure to set blocking and nonblocking modes on a  *	channel. Invoked either by generic IO level code or by other  *	channel drivers after doing channel-type-specific inialization.  *  * Results:  *	0 if successful, errno when failed.  *  * Side effects:  *	Sets the device into blocking or non-blocking mode.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|FileBlockModeProc
parameter_list|(
name|instanceData
parameter_list|,
name|inFile
parameter_list|,
name|outFile
parameter_list|,
name|mode
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* Unused. */
name|Tcl_File
name|inFile
decl_stmt|,
name|outFile
decl_stmt|;
comment|/* Input, output files for channel. */
name|int
name|mode
decl_stmt|;
comment|/* The mode to set. Can be one of                                          * TCL_MODE_BLOCKING or                                          * TCL_MODE_NONBLOCKING. */
block|{
name|int
name|curStatus
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|inFile
operator|!=
name|NULL
condition|)
block|{
name|fd
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|inFile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|curStatus
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|TCL_MODE_BLOCKING
condition|)
block|{
name|curStatus
operator|&=
operator|(
operator|~
operator|(
name|O_NONBLOCK
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|curStatus
operator||=
name|O_NONBLOCK
expr_stmt|;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|curStatus
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|errno
return|;
block|}
name|curStatus
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outFile
operator|!=
name|NULL
condition|)
block|{
name|fd
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|outFile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|curStatus
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|TCL_MODE_BLOCKING
condition|)
block|{
name|curStatus
operator|&=
operator|(
operator|~
operator|(
name|O_NONBLOCK
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|curStatus
operator||=
name|O_NONBLOCK
expr_stmt|;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|curStatus
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|errno
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * PipeBlockModeProc --  *  *	Helper procedure to set blocking and nonblocking modes on a  *	channel. Invoked either by generic IO level code or by other  *	channel drivers after doing channel-type-specific inialization.  *  * Results:  *	0 if successful, errno when failed.  *  * Side effects:  *	Sets the device into blocking or non-blocking mode.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|PipeBlockModeProc
parameter_list|(
name|instanceData
parameter_list|,
name|inFile
parameter_list|,
name|outFile
parameter_list|,
name|mode
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* The pipe state. */
name|Tcl_File
name|inFile
decl_stmt|,
name|outFile
decl_stmt|;
comment|/* Input, output files for channel. */
name|int
name|mode
decl_stmt|;
comment|/* The mode to set. Can be one of                                          * TCL_MODE_BLOCKING or                                          * TCL_MODE_NONBLOCKING. */
block|{
name|PipeState
modifier|*
name|pipePtr
decl_stmt|;
name|int
name|curStatus
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|inFile
operator|!=
name|NULL
condition|)
block|{
name|fd
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|inFile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|curStatus
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|TCL_MODE_BLOCKING
condition|)
block|{
name|curStatus
operator|&=
operator|(
operator|~
operator|(
name|O_NONBLOCK
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|curStatus
operator||=
name|O_NONBLOCK
expr_stmt|;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|curStatus
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|errno
return|;
block|}
name|curStatus
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outFile
operator|!=
name|NULL
condition|)
block|{
name|fd
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|outFile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|curStatus
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|TCL_MODE_BLOCKING
condition|)
block|{
name|curStatus
operator|&=
operator|(
operator|~
operator|(
name|O_NONBLOCK
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|curStatus
operator||=
name|O_NONBLOCK
expr_stmt|;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|curStatus
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|errno
return|;
block|}
block|}
name|pipePtr
operator|=
operator|(
name|PipeState
operator|*
operator|)
name|instanceData
expr_stmt|;
name|pipePtr
operator|->
name|isNonBlocking
operator|=
operator|(
name|mode
operator|==
name|TCL_MODE_NONBLOCKING
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FilePipeInputProc --  *  *	This procedure is invoked from the generic IO level to read  *	input from a file or command pipeline channel.  *  * Results:  *	The number of bytes read is returned or -1 on error. An output  *	argument contains a POSIX error code if an error occurs, or zero.  *  * Side effects:  *	Reads input from the input device of the channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|FilePipeInputProc
parameter_list|(
name|instanceData
parameter_list|,
name|inFile
parameter_list|,
name|buf
parameter_list|,
name|toRead
parameter_list|,
name|errorCodePtr
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* Unused. */
name|Tcl_File
name|inFile
decl_stmt|;
comment|/* Input device for channel. */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Where to store data read. */
name|int
name|toRead
decl_stmt|;
comment|/* How much space is available                                          * in the buffer? */
name|int
modifier|*
name|errorCodePtr
decl_stmt|;
comment|/* Where to store error code. */
block|{
name|int
name|fd
decl_stmt|;
comment|/* The OS handle for reading. */
name|int
name|bytesRead
decl_stmt|;
comment|/* How many bytes were actually                                          * read from the input device? */
operator|*
name|errorCodePtr
operator|=
literal|0
expr_stmt|;
name|fd
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|inFile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*      * Assume there is always enough input available. This will block      * appropriately, and read will unblock as soon as a short read is      * possible, if the channel is in blocking mode. If the channel is      * nonblocking, the read will never block.      */
name|bytesRead
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
operator|(
name|size_t
operator|)
name|toRead
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytesRead
operator|>
operator|-
literal|1
condition|)
block|{
return|return
name|bytesRead
return|;
block|}
operator|*
name|errorCodePtr
operator|=
name|errno
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FilePipeOutputProc--  *  *	This procedure is invoked from the generic IO level to write  *	output to a file or command pipeline channel.  *  * Results:  *	The number of bytes written is returned or -1 on error. An  *	output argument	contains a POSIX error code if an error occurred,  *	or zero.  *  * Side effects:  *	Writes output on the output device of the channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|FilePipeOutputProc
parameter_list|(
name|instanceData
parameter_list|,
name|outFile
parameter_list|,
name|buf
parameter_list|,
name|toWrite
parameter_list|,
name|errorCodePtr
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* Unused. */
name|Tcl_File
name|outFile
decl_stmt|;
comment|/* Output device for channel. */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* The data buffer. */
name|int
name|toWrite
decl_stmt|;
comment|/* How many bytes to write? */
name|int
modifier|*
name|errorCodePtr
decl_stmt|;
comment|/* Where to store error code. */
block|{
name|int
name|written
decl_stmt|;
name|int
name|fd
decl_stmt|;
operator|*
name|errorCodePtr
operator|=
literal|0
expr_stmt|;
name|fd
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|outFile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|written
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
operator|(
name|size_t
operator|)
name|toWrite
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|>
operator|-
literal|1
condition|)
block|{
return|return
name|written
return|;
block|}
operator|*
name|errorCodePtr
operator|=
name|errno
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FileCloseProc --  *  *	This procedure is called from the generic IO level to perform  *	channel-type-specific cleanup when a file based channel is closed.  *  * Results:  *	0 if successful, errno if failed.  *  * Side effects:  *	Closes the device of the channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|FileCloseProc
parameter_list|(
name|instanceData
parameter_list|,
name|interp
parameter_list|,
name|inFile
parameter_list|,
name|outFile
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* Unused. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* For error reporting - unused. */
name|Tcl_File
name|inFile
decl_stmt|;
comment|/* Input file to close. */
name|Tcl_File
name|outFile
decl_stmt|;
comment|/* Output file to close. */
block|{
name|int
name|fd
decl_stmt|,
name|errorCode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|inFile
operator|!=
name|NULL
condition|)
block|{
comment|/* 	 * Check for read/write file so we only close it once. 	 */
if|if
condition|(
name|inFile
operator|==
name|outFile
condition|)
block|{
name|outFile
operator|=
name|NULL
expr_stmt|;
block|}
name|fd
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|inFile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_FreeFile
argument_list|(
name|inFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|tclInInterpreterDeletion
condition|)
block|{
if|if
condition|(
operator|(
name|fd
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|fd
operator|!=
literal|1
operator|)
operator|&&
operator|(
name|fd
operator|!=
literal|2
operator|)
condition|)
block|{
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|errorCode
operator|=
name|errno
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|errorCode
operator|=
name|errno
expr_stmt|;
block|}
block|}
if|if
condition|(
name|outFile
operator|!=
name|NULL
condition|)
block|{
name|fd
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|outFile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_FreeFile
argument_list|(
name|outFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|tclInInterpreterDeletion
condition|)
block|{
if|if
condition|(
operator|(
name|fd
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|fd
operator|!=
literal|1
operator|)
operator|&&
operator|(
name|fd
operator|!=
literal|2
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
operator|)
operator|&&
operator|(
name|errorCode
operator|==
literal|0
operator|)
condition|)
block|{
name|errorCode
operator|=
name|errno
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
operator|)
operator|&&
operator|(
name|errorCode
operator|==
literal|0
operator|)
condition|)
block|{
name|errorCode
operator|=
name|errno
expr_stmt|;
block|}
block|}
return|return
name|errorCode
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FileSeekProc --  *  *	This procedure is called by the generic IO level to move the  *	access point in a file based channel.  *  * Results:  *	-1 if failed, the new position if successful. An output  *	argument contains the POSIX error code if an error occurred,  *	or zero.  *  * Side effects:  *	Moves the location at which the channel will be accessed in  *	future operations.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|FileSeekProc
parameter_list|(
name|instanceData
parameter_list|,
name|inFile
parameter_list|,
name|outFile
parameter_list|,
name|offset
parameter_list|,
name|mode
parameter_list|,
name|errorCodePtr
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* Unused. */
name|Tcl_File
name|inFile
decl_stmt|,
name|outFile
decl_stmt|;
comment|/* Input and output                                                  * files for channel. */
name|long
name|offset
decl_stmt|;
comment|/* Offset to seek to. */
name|int
name|mode
decl_stmt|;
comment|/* Relative to where                                                  * should we seek? Can be                                                  * one of SEEK_START,                                                  * SEEK_SET or SEEK_END. */
name|int
modifier|*
name|errorCodePtr
decl_stmt|;
comment|/* To store error code. */
block|{
name|int
name|newLoc
decl_stmt|;
name|int
name|fd
decl_stmt|;
operator|*
name|errorCodePtr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inFile
operator|!=
operator|(
name|Tcl_File
operator|)
name|NULL
condition|)
block|{
name|fd
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|inFile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|outFile
operator|!=
operator|(
name|Tcl_File
operator|)
name|NULL
condition|)
block|{
name|fd
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|outFile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|errorCodePtr
operator|=
name|EFAULT
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|newLoc
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
name|offset
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|newLoc
operator|>
operator|-
literal|1
condition|)
block|{
return|return
name|newLoc
return|;
block|}
operator|*
name|errorCodePtr
operator|=
name|errno
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclGetAndDetachPids --  *  *	This procedure is invoked in the generic implementation of a  *	background "exec" (An exec when invoked with a terminating "&")  *	to store a list of the PIDs for processes in a command pipeline  *	in interp->result and to detach the processes.  *  * Results:  *	None.  *  * Side effects:  *	Modifies interp->result. Detaches processes.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclGetAndDetachPids
parameter_list|(
name|interp
parameter_list|,
name|chan
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
name|Tcl_Channel
name|chan
decl_stmt|;
block|{
name|PipeState
modifier|*
name|pipePtr
decl_stmt|;
name|Tcl_ChannelType
modifier|*
name|chanTypePtr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
comment|/*      * Punt if the channel is not a command channel.      */
name|chanTypePtr
operator|=
name|Tcl_GetChannelType
argument_list|(
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|chanTypePtr
operator|!=
operator|&
name|pipeChannelType
condition|)
block|{
return|return;
block|}
name|pipePtr
operator|=
operator|(
name|PipeState
operator|*
operator|)
name|Tcl_GetChannelInstanceData
argument_list|(
name|chan
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pipePtr
operator|->
name|numPids
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|pipePtr
operator|->
name|pidPtr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|Tcl_DetachPids
argument_list|(
literal|1
argument_list|,
operator|&
operator|(
name|pipePtr
operator|->
name|pidPtr
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pipePtr
operator|->
name|numPids
operator|>
literal|0
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pipePtr
operator|->
name|pidPtr
argument_list|)
expr_stmt|;
name|pipePtr
operator|->
name|numPids
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * PipeCloseProc --  *  *	This procedure is invoked by the generic IO level to perform  *	channel-type-specific cleanup when a command pipeline channel  *	is closed.  *  * Results:  *	0 on success, errno otherwise.  *  * Side effects:  *	Closes the command pipeline channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|PipeCloseProc
parameter_list|(
name|instanceData
parameter_list|,
name|interp
parameter_list|,
name|inFile
parameter_list|,
name|outFile
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* The pipe to close. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* For error reporting. */
name|Tcl_File
name|inFile
decl_stmt|,
name|outFile
decl_stmt|;
comment|/* Unused. */
block|{
name|PipeState
modifier|*
name|pipePtr
decl_stmt|;
name|Tcl_Channel
name|errChan
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|errorCode
decl_stmt|,
name|result
decl_stmt|;
name|errorCode
operator|=
literal|0
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|pipePtr
operator|=
operator|(
name|PipeState
operator|*
operator|)
name|instanceData
expr_stmt|;
if|if
condition|(
name|pipePtr
operator|->
name|readFile
operator|!=
name|NULL
condition|)
block|{
name|fd
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|pipePtr
operator|->
name|readFile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_FreeFile
argument_list|(
name|pipePtr
operator|->
name|readFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|errorCode
operator|=
name|errno
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pipePtr
operator|->
name|writeFile
operator|!=
name|NULL
condition|)
block|{
name|fd
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|pipePtr
operator|->
name|writeFile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_FreeFile
argument_list|(
name|pipePtr
operator|->
name|writeFile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
operator|)
operator|&&
operator|(
name|errorCode
operator|==
literal|0
operator|)
condition|)
block|{
name|errorCode
operator|=
name|errno
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pipePtr
operator|->
name|isNonBlocking
condition|)
block|{
comment|/*          * If the channel is non-blocking, just detach the children PIDs          * and discard the errorFile.          */
name|Tcl_DetachPids
argument_list|(
name|pipePtr
operator|->
name|numPids
argument_list|,
name|pipePtr
operator|->
name|pidPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipePtr
operator|->
name|errorFile
operator|!=
name|NULL
condition|)
block|{
name|Tcl_FreeFile
argument_list|(
name|pipePtr
operator|->
name|errorFile
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*          * Wrap the error file into a channel and give it to the cleanup          * routine.          */
if|if
condition|(
name|pipePtr
operator|->
name|errorFile
operator|!=
name|NULL
condition|)
block|{
name|errChan
operator|=
name|Tcl_CreateChannel
argument_list|(
operator|&
name|fileChannelType
argument_list|,
literal|"pipeError"
argument_list|,
name|pipePtr
operator|->
name|errorFile
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errChan
operator|=
name|NULL
expr_stmt|;
block|}
name|result
operator|=
name|TclCleanupChildren
argument_list|(
name|interp
argument_list|,
name|pipePtr
operator|->
name|numPids
argument_list|,
name|pipePtr
operator|->
name|pidPtr
argument_list|,
name|errChan
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pipePtr
operator|->
name|numPids
operator|!=
literal|0
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pipePtr
operator|->
name|pidPtr
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pipePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorCode
operator|==
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
return|return
name|errorCode
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_OpenFileChannel --  *  *	Open an file based channel on Unix systems.  *  * Results:  *	The new channel or NULL. If NULL, the output argument  *	errorCodePtr is set to a POSIX error and an error message is  *	left in interp->result if interp is not NULL.  *  * Side effects:  *	May open the channel and may cause creation of a file on the  *	file system.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Channel
name|Tcl_OpenFileChannel
parameter_list|(
name|interp
parameter_list|,
name|fileName
parameter_list|,
name|modeString
parameter_list|,
name|permissions
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter for error reporting;                                          * can be NULL. */
name|char
modifier|*
name|fileName
decl_stmt|;
comment|/* Name of file to open. */
name|char
modifier|*
name|modeString
decl_stmt|;
comment|/* A list of POSIX open modes or                                          * a string such as "rw". */
name|int
name|permissions
decl_stmt|;
comment|/* If the open involves creating a                                          * file, with what modes to create                                          * it? */
block|{
name|int
name|fd
decl_stmt|,
name|seekFlag
decl_stmt|,
name|mode
decl_stmt|,
name|channelPermissions
decl_stmt|;
name|Tcl_File
name|file
decl_stmt|;
name|Tcl_Channel
name|chan
decl_stmt|;
name|char
modifier|*
name|nativeName
decl_stmt|,
name|channelName
index|[
literal|20
index|]
decl_stmt|;
name|Tcl_DString
name|buffer
decl_stmt|;
name|mode
operator|=
name|TclGetOpenMode
argument_list|(
name|interp
argument_list|,
name|modeString
argument_list|,
operator|&
name|seekFlag
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|NULL
return|;
block|}
switch|switch
condition|(
name|mode
operator|&
operator|(
name|O_RDONLY
operator||
name|O_WRONLY
operator||
name|O_RDWR
operator|)
condition|)
block|{
case|case
name|O_RDONLY
case|:
name|channelPermissions
operator|=
name|TCL_READABLE
expr_stmt|;
break|break;
case|case
name|O_WRONLY
case|:
name|channelPermissions
operator|=
name|TCL_WRITABLE
expr_stmt|;
break|break;
case|case
name|O_RDWR
case|:
name|channelPermissions
operator|=
operator|(
name|TCL_READABLE
operator||
name|TCL_WRITABLE
operator|)
expr_stmt|;
break|break;
default|default:
comment|/*              * This may occurr if modeString was "", for example.              */
name|panic
argument_list|(
literal|"Tcl_OpenFileChannel: invalid mode value"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|nativeName
operator|=
name|Tcl_TranslateFileName
argument_list|(
name|interp
argument_list|,
name|fileName
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|nativeName
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|fd
operator|=
name|open
argument_list|(
name|nativeName
argument_list|,
name|mode
argument_list|,
name|permissions
argument_list|)
expr_stmt|;
comment|/*      * If nativeName is not NULL, the buffer is valid and we must free      * the storage.      */
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't open \""
argument_list|,
name|fileName
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
name|sprintf
argument_list|(
name|channelName
argument_list|,
literal|"file%d"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|file
operator|=
name|Tcl_GetFile
argument_list|(
operator|(
name|ClientData
operator|)
name|fd
argument_list|,
name|TCL_UNIX_FD
argument_list|)
expr_stmt|;
name|chan
operator|=
name|Tcl_CreateChannel
argument_list|(
operator|&
name|fileChannelType
argument_list|,
name|channelName
argument_list|,
operator|(
name|channelPermissions
operator|&
name|TCL_READABLE
operator|)
condition|?
name|file
else|:
name|NULL
argument_list|,
operator|(
name|channelPermissions
operator|&
name|TCL_WRITABLE
operator|)
condition|?
name|file
else|:
name|NULL
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/*      * The channel may not be open now, for example if we tried to      * open a file with permissions that cannot be satisfied.      */
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't create channel \""
argument_list|,
name|channelName
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|Tcl_FreeFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|seekFlag
condition|)
block|{
if|if
condition|(
name|Tcl_Seek
argument_list|(
name|chan
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't seek to end of file on \""
argument_list|,
name|channelName
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|Tcl_Close
argument_list|(
name|NULL
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
name|chan
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_MakeFileChannel --  *  *	Makes a Tcl_Channel from an existing OS level file handle.  *  * Results:  *	The Tcl_Channel created around the preexisting OS level file handle.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Channel
name|Tcl_MakeFileChannel
parameter_list|(
name|inFd
parameter_list|,
name|outFd
parameter_list|,
name|mode
parameter_list|)
name|ClientData
name|inFd
decl_stmt|;
comment|/* OS level handle used for input. */
name|ClientData
name|outFd
decl_stmt|;
comment|/* OS level handle used for output. */
name|int
name|mode
decl_stmt|;
comment|/* ORed combination of TCL_READABLE and                                  * TCL_WRITABLE to indicate whether inFile                                  * and/or outFile are valid. */
block|{
name|Tcl_Channel
name|chan
decl_stmt|;
name|int
name|fileUsed
decl_stmt|;
name|Tcl_File
name|inFile
decl_stmt|,
name|outFile
decl_stmt|;
name|char
name|channelName
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|Tcl_Channel
operator|)
name|NULL
return|;
block|}
name|inFile
operator|=
operator|(
name|Tcl_File
operator|)
name|NULL
expr_stmt|;
name|outFile
operator|=
operator|(
name|Tcl_File
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|TCL_READABLE
condition|)
block|{
name|sprintf
argument_list|(
name|channelName
argument_list|,
literal|"file%d"
argument_list|,
operator|(
name|int
operator|)
name|inFd
argument_list|)
expr_stmt|;
name|inFile
operator|=
name|Tcl_GetFile
argument_list|(
name|inFd
argument_list|,
name|TCL_UNIX_FD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|&
name|TCL_WRITABLE
condition|)
block|{
name|sprintf
argument_list|(
name|channelName
argument_list|,
literal|"file%d"
argument_list|,
operator|(
name|int
operator|)
name|outFd
argument_list|)
expr_stmt|;
name|outFile
operator|=
name|Tcl_GetFile
argument_list|(
name|outFd
argument_list|,
name|TCL_UNIX_FD
argument_list|)
expr_stmt|;
block|}
comment|/*      * Look to see if a channel with those two Tcl_Files already exists.      * If so, return it.      */
name|chan
operator|=
name|TclFindFileChannel
argument_list|(
name|inFile
argument_list|,
name|outFile
argument_list|,
operator|&
name|fileUsed
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|!=
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
return|return
name|chan
return|;
block|}
comment|/*      * If one of the Tcl_Files is used in another channel, do not      * create a new channel containing it; this avoids core dumps      * later, when the Tcl_File would be freed twice.      */
if|if
condition|(
name|fileUsed
condition|)
block|{
return|return
operator|(
name|Tcl_Channel
operator|)
name|NULL
return|;
block|}
return|return
name|Tcl_CreateChannel
argument_list|(
operator|&
name|fileChannelType
argument_list|,
name|channelName
argument_list|,
name|inFile
argument_list|,
name|outFile
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCreateCommandChannel --  *  *	This function is called by the generic IO level to perform  *	the platform specific channel initialization for a command  *	channel.  *  * Results:  *	Returns a new channel or NULL on failure.  *  * Side effects:  *	Allocates a new channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Channel
name|TclCreateCommandChannel
parameter_list|(
name|readFile
parameter_list|,
name|writeFile
parameter_list|,
name|errorFile
parameter_list|,
name|numPids
parameter_list|,
name|pidPtr
parameter_list|)
name|Tcl_File
name|readFile
decl_stmt|;
comment|/* If non-null, gives the file for reading. */
name|Tcl_File
name|writeFile
decl_stmt|;
comment|/* If non-null, gives the file for writing. */
name|Tcl_File
name|errorFile
decl_stmt|;
comment|/* If non-null, gives the file where errors 				 * can be read. */
name|int
name|numPids
decl_stmt|;
comment|/* The number of pids in the pid array. */
name|int
modifier|*
name|pidPtr
decl_stmt|;
comment|/* An array of process identifiers.                                  * Allocated by the caller, freed when                                  * the channel is closed or the processes                                  * are detached (in a background exec). */
block|{
name|Tcl_Channel
name|channel
decl_stmt|;
name|char
name|channelName
index|[
literal|20
index|]
decl_stmt|;
name|int
name|channelId
decl_stmt|;
name|PipeState
modifier|*
name|statePtr
init|=
operator|(
name|PipeState
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|PipeState
argument_list|)
argument_list|)
decl_stmt|;
name|statePtr
operator|->
name|readFile
operator|=
name|readFile
expr_stmt|;
name|statePtr
operator|->
name|writeFile
operator|=
name|writeFile
expr_stmt|;
name|statePtr
operator|->
name|errorFile
operator|=
name|errorFile
expr_stmt|;
name|statePtr
operator|->
name|numPids
operator|=
name|numPids
expr_stmt|;
name|statePtr
operator|->
name|pidPtr
operator|=
name|pidPtr
expr_stmt|;
name|statePtr
operator|->
name|isNonBlocking
operator|=
literal|0
expr_stmt|;
comment|/*      * Use one of the fds associated with the channel as the      * channel id.      */
if|if
condition|(
name|readFile
condition|)
block|{
name|channelId
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|readFile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|writeFile
condition|)
block|{
name|channelId
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|writeFile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errorFile
condition|)
block|{
name|channelId
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|errorFile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|channelId
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * For backward compatibility with previous versions of Tcl, we      * use "file%d" as the base name for pipes even though it would      * be more natural to use "pipe%d".      */
name|sprintf
argument_list|(
name|channelName
argument_list|,
literal|"file%d"
argument_list|,
name|channelId
argument_list|)
expr_stmt|;
name|channel
operator|=
name|Tcl_CreateChannel
argument_list|(
operator|&
name|pipeChannelType
argument_list|,
name|channelName
argument_list|,
name|readFile
argument_list|,
name|writeFile
argument_list|,
operator|(
name|ClientData
operator|)
name|statePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|NULL
condition|)
block|{
comment|/*          * pidPtr will be freed by the caller if the return value is NULL.          */
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|statePtr
argument_list|)
expr_stmt|;
block|}
return|return
name|channel
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_PidCmd --  *  *	This procedure is invoked to process the "pid" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_PidCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel to get pids for. */
name|Tcl_ChannelType
modifier|*
name|chanTypePtr
decl_stmt|;
comment|/* The type of that channel. */
name|PipeState
modifier|*
name|pipePtr
decl_stmt|;
comment|/* The pipe state. */
name|int
name|i
decl_stmt|;
comment|/* Loops over PIDs attached to the                                          * pipe. */
name|char
name|string
index|[
literal|50
index|]
decl_stmt|;
comment|/* Temp buffer for string rep. of                                          * PIDs attached to the pipe. */
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" ?channelId?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chan
operator|=
name|Tcl_GetChannel
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|chanTypePtr
operator|=
name|Tcl_GetChannelType
argument_list|(
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|chanTypePtr
operator|!=
operator|&
name|pipeChannelType
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
name|pipePtr
operator|=
operator|(
name|PipeState
operator|*
operator|)
name|Tcl_GetChannelInstanceData
argument_list|(
name|chan
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pipePtr
operator|->
name|numPids
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%d"
argument_list|,
name|pipePtr
operator|->
name|pidPtr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TcpBlockModeProc --  *  *	This procedure is invoked by the generic IO level to set blocking  *	and nonblocking mode on a TCP socket based channel.  *  * Results:  *	0 if successful, errno when failed.  *  * Side effects:  *	Sets the device into blocking or nonblocking mode.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TcpBlockModeProc
parameter_list|(
name|instanceData
parameter_list|,
name|inFile
parameter_list|,
name|outFile
parameter_list|,
name|mode
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* Socket state. */
name|Tcl_File
name|inFile
decl_stmt|,
name|outFile
decl_stmt|;
comment|/* Input, output files for channel. */
name|int
name|mode
decl_stmt|;
comment|/* The mode to set. Can be one of                                          * TCL_MODE_BLOCKING or                                          * TCL_MODE_NONBLOCKING. */
block|{
name|TcpState
modifier|*
name|statePtr
decl_stmt|;
name|statePtr
operator|=
operator|(
name|TcpState
operator|*
operator|)
name|instanceData
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|TCL_MODE_BLOCKING
condition|)
block|{
name|statePtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|TCP_ASYNC_SOCKET
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|statePtr
operator|->
name|flags
operator||=
name|TCP_ASYNC_SOCKET
expr_stmt|;
block|}
return|return
name|FileBlockModeProc
argument_list|(
name|instanceData
argument_list|,
name|inFile
argument_list|,
name|outFile
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * WaitForConnect --  *  *	Waits for a connection on an asynchronously opened socket to  *	be completed.  *  * Results:  *	None.  *  * Side effects:  *	The socket is connected after this function returns.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|WaitForConnect
parameter_list|(
name|statePtr
parameter_list|,
name|fileToWaitFor
parameter_list|,
name|errorCodePtr
parameter_list|)
name|TcpState
modifier|*
name|statePtr
decl_stmt|;
comment|/* State of the socket. */
name|Tcl_File
name|fileToWaitFor
decl_stmt|;
comment|/* File to wait on to become connected. */
name|int
modifier|*
name|errorCodePtr
decl_stmt|;
comment|/* Where to store errors? */
block|{
name|int
name|sock
decl_stmt|;
comment|/* The socket itself. */
name|int
name|timeOut
decl_stmt|;
comment|/* How long to wait. */
name|int
name|state
decl_stmt|;
comment|/* Of calling TclWaitForFile. */
name|int
name|flags
decl_stmt|;
comment|/* fcntl flags for the socket. */
comment|/*      * If an asynchronous connect is in progress, attempt to wait for it      * to complete before reading.      */
if|if
condition|(
name|statePtr
operator|->
name|flags
operator|&
name|TCP_ASYNC_CONNECT
condition|)
block|{
if|if
condition|(
name|statePtr
operator|->
name|flags
operator|&
name|TCP_ASYNC_SOCKET
condition|)
block|{
name|timeOut
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|timeOut
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|TclWaitForFile
argument_list|(
name|fileToWaitFor
argument_list|,
name|TCL_WRITABLE
operator||
name|TCL_EXCEPTION
argument_list|,
name|timeOut
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|statePtr
operator|->
name|flags
operator|&
name|TCP_ASYNC_SOCKET
operator|)
condition|)
block|{
name|sock
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|statePtr
operator|->
name|sock
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|flags
operator|=
name|fcntl
argument_list|(
name|sock
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|(
operator|~
operator|(
name|O_NONBLOCK
operator|)
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|sock
argument_list|,
name|F_SETFL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|&
name|TCL_EXCEPTION
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|state
operator|&
name|TCL_WRITABLE
condition|)
block|{
name|statePtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|TCP_ASYNC_CONNECT
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|timeOut
operator|==
literal|0
condition|)
block|{
operator|*
name|errorCodePtr
operator|=
name|errno
operator|=
name|EWOULDBLOCK
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TcpInputProc --  *  *	This procedure is invoked by the generic IO level to read input  *	from a TCP socket based channel.  *  *	NOTE: We cannot share code with FilePipeInputProc because here  *	we must use recv to obtain the input from the channel, not read.  *  * Results:  *	The number of bytes read is returned or -1 on error. An output  *	argument contains the POSIX error code on error, or zero if no  *	error occurred.  *  * Side effects:  *	Reads input from the input device of the channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TcpInputProc
parameter_list|(
name|instanceData
parameter_list|,
name|inFile
parameter_list|,
name|buf
parameter_list|,
name|bufSize
parameter_list|,
name|errorCodePtr
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* Socket state. */
name|Tcl_File
name|inFile
decl_stmt|;
comment|/* Input device for channel. */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Where to store data read. */
name|int
name|bufSize
decl_stmt|;
comment|/* How much space is available                                          * in the buffer? */
name|int
modifier|*
name|errorCodePtr
decl_stmt|;
comment|/* Where to store error code. */
block|{
name|TcpState
modifier|*
name|statePtr
decl_stmt|;
comment|/* The state of the socket. */
name|int
name|sock
decl_stmt|;
comment|/* The OS handle. */
name|int
name|bytesRead
decl_stmt|;
comment|/* How many bytes were read? */
name|int
name|state
decl_stmt|;
comment|/* Of waiting for connection. */
operator|*
name|errorCodePtr
operator|=
literal|0
expr_stmt|;
name|sock
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|inFile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|statePtr
operator|=
operator|(
name|TcpState
operator|*
operator|)
name|instanceData
expr_stmt|;
name|state
operator|=
name|WaitForConnect
argument_list|(
name|statePtr
argument_list|,
name|inFile
argument_list|,
name|errorCodePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|bytesRead
operator|=
name|recv
argument_list|(
name|sock
argument_list|,
name|buf
argument_list|,
name|bufSize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytesRead
operator|>
operator|-
literal|1
condition|)
block|{
return|return
name|bytesRead
return|;
block|}
if|if
condition|(
name|errno
operator|==
name|ECONNRESET
condition|)
block|{
comment|/*          * Turn ECONNRESET into a soft EOF condition.          */
return|return
literal|0
return|;
block|}
operator|*
name|errorCodePtr
operator|=
name|errno
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TcpOutputProc --  *  *	This procedure is invoked by the generic IO level to write output  *	to a TCP socket based channel.  *  *	NOTE: We cannot share code with FilePipeOutputProc because here  *	we must use send, not write, to get reliable error reporting.  *  * Results:  *	The number of bytes written is returned. An output argument is  *	set to a POSIX error code if an error occurred, or zero.  *  * Side effects:  *	Writes output on the output device of the channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TcpOutputProc
parameter_list|(
name|instanceData
parameter_list|,
name|outFile
parameter_list|,
name|buf
parameter_list|,
name|toWrite
parameter_list|,
name|errorCodePtr
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* Socket state. */
name|Tcl_File
name|outFile
decl_stmt|;
comment|/* Output device for channel. */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* The data buffer. */
name|int
name|toWrite
decl_stmt|;
comment|/* How many bytes to write? */
name|int
modifier|*
name|errorCodePtr
decl_stmt|;
comment|/* Where to store error code. */
block|{
name|TcpState
modifier|*
name|statePtr
decl_stmt|;
name|int
name|written
decl_stmt|;
name|int
name|sock
decl_stmt|;
comment|/* OS level socket. */
name|int
name|state
decl_stmt|;
comment|/* Of waiting for connection. */
operator|*
name|errorCodePtr
operator|=
literal|0
expr_stmt|;
name|sock
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|outFile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|statePtr
operator|=
operator|(
name|TcpState
operator|*
operator|)
name|instanceData
expr_stmt|;
name|state
operator|=
name|WaitForConnect
argument_list|(
name|statePtr
argument_list|,
name|outFile
argument_list|,
name|errorCodePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|written
operator|=
name|send
argument_list|(
name|sock
argument_list|,
name|buf
argument_list|,
name|toWrite
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|>
operator|-
literal|1
condition|)
block|{
return|return
name|written
return|;
block|}
operator|*
name|errorCodePtr
operator|=
name|errno
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TcpCloseProc --  *  *	This procedure is invoked by the generic IO level to perform  *	channel-type-specific cleanup when a TCP socket based channel  *	is closed.  *  * Results:  *	0 if successful, the value of errno if failed.  *  * Side effects:  *	Closes the socket of the channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TcpCloseProc
parameter_list|(
name|instanceData
parameter_list|,
name|interp
parameter_list|,
name|inFile
parameter_list|,
name|outFile
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* The socket to close. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* For error reporting - unused. */
name|Tcl_File
name|inFile
decl_stmt|,
name|outFile
decl_stmt|;
comment|/* Unused. */
block|{
name|TcpState
modifier|*
name|statePtr
decl_stmt|;
name|Tcl_File
name|sockFile
decl_stmt|;
name|int
name|sock
decl_stmt|;
name|int
name|errorCode
init|=
literal|0
decl_stmt|;
name|statePtr
operator|=
operator|(
name|TcpState
operator|*
operator|)
name|instanceData
expr_stmt|;
name|sockFile
operator|=
name|statePtr
operator|->
name|sock
expr_stmt|;
name|sock
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|sockFile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*      * Delete a file handler that may be active for this socket if this      * is a server socket - the file handler was created automatically      * by Tcl as part of the mechanism to accept new client connections.      * Channel handlers are already deleted in the generic IO channel      * closing code that called this function, so we do not have to      * delete them here.      */
name|Tcl_DeleteFileHandler
argument_list|(
name|sockFile
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|statePtr
argument_list|)
expr_stmt|;
comment|/*      * We assume that inFile==outFile==sockFile and so      * we only clean up sockFile.      */
name|Tcl_FreeFile
argument_list|(
name|sockFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|sock
argument_list|)
operator|<
literal|0
condition|)
block|{
name|errorCode
operator|=
name|errno
expr_stmt|;
block|}
return|return
name|errorCode
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TcpGetOptionProc --  *  *	Computes an option value for a TCP socket based channel, or a  *	list of all options and their values.  *  *	Note: This code is based on code contributed by John Haxby.  *  * Results:  *	A standard Tcl result. The value of the specified option or a  *	list of all options and	their values is returned in the  *	supplied DString.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TcpGetOptionProc
parameter_list|(
name|instanceData
parameter_list|,
name|optionName
parameter_list|,
name|dsPtr
parameter_list|)
name|ClientData
name|instanceData
decl_stmt|;
comment|/* Socket state. */
name|char
modifier|*
name|optionName
decl_stmt|;
comment|/* Name of the option to                                          * retrieve the value for, or                                          * NULL to get all options and                                          * their values. */
name|Tcl_DString
modifier|*
name|dsPtr
decl_stmt|;
comment|/* Where to store the computed                                          * value; initialized by caller. */
block|{
name|TcpState
modifier|*
name|statePtr
decl_stmt|;
name|struct
name|sockaddr_in
name|sockname
decl_stmt|;
name|struct
name|sockaddr_in
name|peername
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hostEntPtr
decl_stmt|;
name|int
name|sock
decl_stmt|;
name|int
name|size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|statePtr
operator|=
operator|(
name|TcpState
operator|*
operator|)
name|instanceData
expr_stmt|;
name|sock
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|statePtr
operator|->
name|sock
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|optionName
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|optionName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|len
operator|>
literal|1
operator|)
operator|&&
operator|(
name|optionName
index|[
literal|1
index|]
operator|==
literal|'p'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|optionName
argument_list|,
literal|"-peername"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|getpeername
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|peername
argument_list|,
operator|&
name|size
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
literal|"-peername"
argument_list|)
expr_stmt|;
name|Tcl_DStringStartSublist
argument_list|(
name|dsPtr
argument_list|)
expr_stmt|;
block|}
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
name|inet_ntoa
argument_list|(
name|peername
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|hostEntPtr
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|peername
operator|.
name|sin_addr
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|peername
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostEntPtr
operator|!=
operator|(
expr|struct
name|hostent
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
name|hostEntPtr
operator|->
name|h_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
name|inet_ntoa
argument_list|(
name|peername
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|ntohs
argument_list|(
name|peername
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|Tcl_DStringEndSublist
argument_list|(
name|dsPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|TCL_OK
return|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|len
operator|>
literal|1
operator|)
operator|&&
operator|(
name|optionName
index|[
literal|1
index|]
operator|==
literal|'s'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|optionName
argument_list|,
literal|"-sockname"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|getsockname
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sockname
argument_list|,
operator|&
name|size
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
literal|"-sockname"
argument_list|)
expr_stmt|;
name|Tcl_DStringStartSublist
argument_list|(
name|dsPtr
argument_list|)
expr_stmt|;
block|}
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
name|inet_ntoa
argument_list|(
name|sockname
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|hostEntPtr
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|sockname
operator|.
name|sin_addr
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|peername
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostEntPtr
operator|!=
operator|(
expr|struct
name|hostent
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
name|hostEntPtr
operator|->
name|h_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
name|inet_ntoa
argument_list|(
name|sockname
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|ntohs
argument_list|(
name|sockname
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|Tcl_DStringEndSublist
argument_list|(
name|dsPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|TCL_OK
return|;
block|}
block|}
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CreateSocket --  *  *	This function opens a new socket in client or server mode  *	and initializes the TcpState structure.  *  * Results:  *	Returns a new TcpState, or NULL with an error in interp->result,  *	if interp is not NULL.  *  * Side effects:  *	Opens a socket.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|TcpState
modifier|*
name|CreateSocket
parameter_list|(
name|interp
parameter_list|,
name|port
parameter_list|,
name|host
parameter_list|,
name|server
parameter_list|,
name|myaddr
parameter_list|,
name|myport
parameter_list|,
name|async
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* For error reporting; can be NULL. */
name|int
name|port
decl_stmt|;
comment|/* Port number to open. */
name|char
modifier|*
name|host
decl_stmt|;
comment|/* Name of host on which to open port. 				 * NULL implies INADDR_ANY */
name|int
name|server
decl_stmt|;
comment|/* 1 if socket should be a server socket, 				 * else 0 for a client socket. */
name|char
modifier|*
name|myaddr
decl_stmt|;
comment|/* Optional client-side address */
name|int
name|myport
decl_stmt|;
comment|/* Optional client-side port */
name|int
name|async
decl_stmt|;
comment|/* If nonzero and creating a client socket,                                  * attempt to do an async connect. Otherwise                                  * do a synchronous connect or bind. */
block|{
name|int
name|status
decl_stmt|,
name|sock
decl_stmt|,
name|asyncConnect
decl_stmt|,
name|curState
decl_stmt|,
name|origState
decl_stmt|;
name|struct
name|sockaddr_in
name|sockaddr
decl_stmt|;
comment|/* socket address */
name|struct
name|sockaddr_in
name|mysockaddr
decl_stmt|;
comment|/* Socket address for client */
name|TcpState
modifier|*
name|statePtr
decl_stmt|;
name|sock
operator|=
operator|-
literal|1
expr_stmt|;
name|origState
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|CreateSocketAddress
argument_list|(
operator|&
name|sockaddr
argument_list|,
name|host
argument_list|,
name|port
argument_list|)
condition|)
block|{
goto|goto
name|addressError
goto|;
block|}
if|if
condition|(
operator|(
name|myaddr
operator|!=
name|NULL
operator|||
name|myport
operator|!=
literal|0
operator|)
operator|&&
operator|!
name|CreateSocketAddress
argument_list|(
operator|&
name|mysockaddr
argument_list|,
name|myaddr
argument_list|,
name|myport
argument_list|)
condition|)
block|{
goto|goto
name|addressError
goto|;
block|}
name|sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
block|{
goto|goto
name|addressError
goto|;
block|}
comment|/*      * Set kernel space buffering      */
name|TclSockMinimumBuffers
argument_list|(
name|sock
argument_list|,
name|SOCKET_BUFSIZE
argument_list|)
expr_stmt|;
name|asyncConnect
operator|=
literal|0
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|server
condition|)
block|{
comment|/* 	 * Set up to reuse server addresses automatically and bind to the 	 * specified port. 	 */
name|status
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|status
argument_list|,
sizeof|sizeof
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|bind
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sockaddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
operator|-
literal|1
condition|)
block|{
name|status
operator|=
name|listen
argument_list|(
name|sock
argument_list|,
name|TCL_LISTEN_LIMIT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|myaddr
operator|!=
name|NULL
operator|||
name|myport
operator|!=
literal|0
condition|)
block|{
name|status
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|status
argument_list|,
sizeof|sizeof
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|bind
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|mysockaddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
goto|goto
name|bindError
goto|;
block|}
block|}
comment|/* 	 * Attempt to connect. The connect may fail at present with an 	 * EINPROGRESS but at a later time it will complete. The caller 	 * will set up a file handler on the socket if she is interested in 	 * being informed when the connect completes. 	 */
if|if
condition|(
name|async
condition|)
block|{
name|origState
operator|=
name|fcntl
argument_list|(
name|sock
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
name|curState
operator|=
name|origState
operator||
name|O_NONBLOCK
expr_stmt|;
name|status
operator|=
name|fcntl
argument_list|(
name|sock
argument_list|,
name|F_SETFL
argument_list|,
name|curState
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|>
operator|-
literal|1
condition|)
block|{
name|status
operator|=
name|connect
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sockaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sockaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINPROGRESS
condition|)
block|{
name|asyncConnect
operator|=
literal|1
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
name|bindError
label|:
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't open socket: "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sock
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
comment|/*      * Allocate a new TcpState for this socket.      */
name|statePtr
operator|=
operator|(
name|TcpState
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|TcpState
argument_list|)
argument_list|)
expr_stmt|;
name|statePtr
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|asyncConnect
condition|)
block|{
name|statePtr
operator|->
name|flags
operator|=
name|TCP_ASYNC_CONNECT
expr_stmt|;
block|}
name|statePtr
operator|->
name|sock
operator|=
name|Tcl_GetFile
argument_list|(
operator|(
name|ClientData
operator|)
name|sock
argument_list|,
name|TCL_UNIX_FD
argument_list|)
expr_stmt|;
return|return
name|statePtr
return|;
name|addressError
label|:
if|if
condition|(
name|sock
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't open socket: "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CreateSocketAddress --  *  *	This function initializes a sockaddr structure for a host and port.  *  * Results:  *	1 if the host was valid, 0 if the host could not be converted to  *	an IP address.  *  * Side effects:  *	Fills in the *sockaddrPtr structure.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CreateSocketAddress
parameter_list|(
name|sockaddrPtr
parameter_list|,
name|host
parameter_list|,
name|port
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|sockaddrPtr
decl_stmt|;
comment|/* Socket address */
name|char
modifier|*
name|host
decl_stmt|;
comment|/* Host.  NULL implies INADDR_ANY */
name|int
name|port
decl_stmt|;
comment|/* Port number */
block|{
name|struct
name|hostent
modifier|*
name|hostent
decl_stmt|;
comment|/* Host database entry */
name|struct
name|in_addr
name|addr
decl_stmt|;
comment|/* For 64/32 bit madness */
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|sockaddrPtr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|sockaddrPtr
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sockaddrPtr
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
call|(
name|unsigned
name|short
call|)
argument_list|(
name|port
operator|&
literal|0xFFFF
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|host
operator|==
name|NULL
condition|)
block|{
name|addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|.
name|s_addr
operator|==
operator|-
literal|1
condition|)
block|{
name|hostent
operator|=
name|gethostbyname
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostent
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
operator|&
name|addr
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|hostent
operator|->
name|h_addr_list
index|[
literal|0
index|]
argument_list|,
operator|(
name|size_t
operator|)
name|hostent
operator|->
name|h_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|EHOSTUNREACH
name|errno
operator|=
name|EHOSTUNREACH
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|ENXIO
name|errno
operator|=
name|ENXIO
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
literal|0
return|;
comment|/* error */
block|}
block|}
block|}
comment|/*      * NOTE: On 64 bit machines the assignment below is rumored to not      * do the right thing. Please report errors related to this if you      * observe incorrect behavior on 64 bit machines such as DEC Alphas.      * Should we modify this code to do an explicit memcpy?      */
name|sockaddrPtr
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|addr
operator|.
name|s_addr
expr_stmt|;
return|return
literal|1
return|;
comment|/* Success. */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_OpenTcpClient --  *  *	Opens a TCP client socket and creates a channel around it.  *  * Results:  *	The channel or NULL if failed.  An error message is returned  *	in the interpreter on failure.  *  * Side effects:  *	Opens a client socket and creates a new channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Channel
name|Tcl_OpenTcpClient
parameter_list|(
name|interp
parameter_list|,
name|port
parameter_list|,
name|host
parameter_list|,
name|myaddr
parameter_list|,
name|myport
parameter_list|,
name|async
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* For error reporting; can be NULL. */
name|int
name|port
decl_stmt|;
comment|/* Port number to open. */
name|char
modifier|*
name|host
decl_stmt|;
comment|/* Host on which to open port. */
name|char
modifier|*
name|myaddr
decl_stmt|;
comment|/* Client-side address */
name|int
name|myport
decl_stmt|;
comment|/* Client-side port */
name|int
name|async
decl_stmt|;
comment|/* If nonzero, attempt to do an                                          * asynchronous connect. Otherwise                                          * we do a blocking connect. */
block|{
name|Tcl_Channel
name|chan
decl_stmt|;
name|TcpState
modifier|*
name|statePtr
decl_stmt|;
name|char
name|channelName
index|[
literal|20
index|]
decl_stmt|;
comment|/*      * Create a new client socket and wrap it in a channel.      */
name|statePtr
operator|=
name|CreateSocket
argument_list|(
name|interp
argument_list|,
name|port
argument_list|,
name|host
argument_list|,
literal|0
argument_list|,
name|myaddr
argument_list|,
name|myport
argument_list|,
name|async
argument_list|)
expr_stmt|;
if|if
condition|(
name|statePtr
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|statePtr
operator|->
name|acceptProc
operator|=
name|NULL
expr_stmt|;
name|statePtr
operator|->
name|acceptProcData
operator|=
operator|(
name|ClientData
operator|)
name|NULL
expr_stmt|;
name|sprintf
argument_list|(
name|channelName
argument_list|,
literal|"sock%d"
argument_list|,
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|statePtr
operator|->
name|sock
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|chan
operator|=
name|Tcl_CreateChannel
argument_list|(
operator|&
name|tcpChannelType
argument_list|,
name|channelName
argument_list|,
name|statePtr
operator|->
name|sock
argument_list|,
name|statePtr
operator|->
name|sock
argument_list|,
operator|(
name|ClientData
operator|)
name|statePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_SetChannelOption
argument_list|(
name|interp
argument_list|,
name|chan
argument_list|,
literal|"-translation"
argument_list|,
literal|"auto crlf"
argument_list|)
operator|==
name|TCL_ERROR
condition|)
block|{
name|Tcl_Close
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|chan
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_MakeTcpClientChannel --  *  *	Creates a Tcl_Channel from an existing client TCP socket.  *  * Results:  *	The Tcl_Channel wrapped around the preexisting TCP socket.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Channel
name|Tcl_MakeTcpClientChannel
parameter_list|(
name|sock
parameter_list|)
name|ClientData
name|sock
decl_stmt|;
comment|/* The socket to wrap up into a channel. */
block|{
name|TcpState
modifier|*
name|statePtr
decl_stmt|;
name|Tcl_File
name|sockFile
decl_stmt|;
name|char
name|channelName
index|[
literal|20
index|]
decl_stmt|;
name|Tcl_Channel
name|chan
decl_stmt|;
name|sockFile
operator|=
name|Tcl_GetFile
argument_list|(
name|sock
argument_list|,
name|TCL_UNIX_FD
argument_list|)
expr_stmt|;
name|statePtr
operator|=
operator|(
name|TcpState
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|TcpState
argument_list|)
argument_list|)
expr_stmt|;
name|statePtr
operator|->
name|sock
operator|=
name|sockFile
expr_stmt|;
name|statePtr
operator|->
name|acceptProc
operator|=
name|NULL
expr_stmt|;
name|statePtr
operator|->
name|acceptProcData
operator|=
operator|(
name|ClientData
operator|)
name|NULL
expr_stmt|;
name|sprintf
argument_list|(
name|channelName
argument_list|,
literal|"sock%d"
argument_list|,
operator|(
name|int
operator|)
name|sock
argument_list|)
expr_stmt|;
name|chan
operator|=
name|Tcl_CreateChannel
argument_list|(
operator|&
name|tcpChannelType
argument_list|,
name|channelName
argument_list|,
name|sockFile
argument_list|,
name|sockFile
argument_list|,
operator|(
name|ClientData
operator|)
name|statePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_SetChannelOption
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|chan
argument_list|,
literal|"-translation"
argument_list|,
literal|"auto crlf"
argument_list|)
operator|==
name|TCL_ERROR
condition|)
block|{
name|Tcl_Close
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|chan
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_OpenTcpServer --  *  *	Opens a TCP server socket and creates a channel around it.  *  * Results:  *	The channel or NULL if failed. If an error occurred, an  *	error message is left in interp->result if interp is  *	not NULL.  *  * Side effects:  *	Opens a server socket and creates a new channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Channel
name|Tcl_OpenTcpServer
parameter_list|(
name|interp
parameter_list|,
name|port
parameter_list|,
name|myHost
parameter_list|,
name|acceptProc
parameter_list|,
name|acceptProcData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* For error reporting - may be                                          * NULL. */
name|int
name|port
decl_stmt|;
comment|/* Port number to open. */
name|char
modifier|*
name|myHost
decl_stmt|;
comment|/* Name of local host. */
name|Tcl_TcpAcceptProc
modifier|*
name|acceptProc
decl_stmt|;
comment|/* Callback for accepting connections                                          * from new clients. */
name|ClientData
name|acceptProcData
decl_stmt|;
comment|/* Data for the callback. */
block|{
name|Tcl_Channel
name|chan
decl_stmt|;
name|TcpState
modifier|*
name|statePtr
decl_stmt|;
name|char
name|channelName
index|[
literal|20
index|]
decl_stmt|;
comment|/*      * Create a new client socket and wrap it in a channel.      */
name|statePtr
operator|=
name|CreateSocket
argument_list|(
name|interp
argument_list|,
name|port
argument_list|,
name|myHost
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|statePtr
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|statePtr
operator|->
name|acceptProc
operator|=
name|acceptProc
expr_stmt|;
name|statePtr
operator|->
name|acceptProcData
operator|=
name|acceptProcData
expr_stmt|;
comment|/*      * Set up the callback mechanism for accepting connections      * from new clients.      */
name|Tcl_CreateFileHandler
argument_list|(
name|statePtr
operator|->
name|sock
argument_list|,
name|TCL_READABLE
argument_list|,
name|TcpAccept
argument_list|,
operator|(
name|ClientData
operator|)
name|statePtr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|channelName
argument_list|,
literal|"sock%d"
argument_list|,
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|statePtr
operator|->
name|sock
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|chan
operator|=
name|Tcl_CreateChannel
argument_list|(
operator|&
name|tcpChannelType
argument_list|,
name|channelName
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
name|ClientData
operator|)
name|statePtr
argument_list|)
expr_stmt|;
return|return
name|chan
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TcpAccept --  *	Accept a TCP socket connection.  This is called by the event loop.  *  * Results:  *	None.  *  * Side effects:  *	Creates a new connection socket. Calls the registered callback  *	for the connection acceptance mechanism.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|TcpAccept
parameter_list|(
name|data
parameter_list|,
name|mask
parameter_list|)
name|ClientData
name|data
decl_stmt|;
comment|/* Callback token. */
name|int
name|mask
decl_stmt|;
comment|/* Not used. */
block|{
name|TcpState
modifier|*
name|sockState
decl_stmt|;
comment|/* Client data of server socket. */
name|int
name|newsock
decl_stmt|;
comment|/* The new client socket */
name|Tcl_File
name|newFile
decl_stmt|;
comment|/* Its file. */
name|TcpState
modifier|*
name|newSockState
decl_stmt|;
comment|/* State for new socket. */
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
comment|/* The remote address */
name|int
name|len
decl_stmt|;
comment|/* For accept interface */
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* Channel instance created. */
name|char
name|channelName
index|[
literal|20
index|]
decl_stmt|;
name|sockState
operator|=
operator|(
name|TcpState
operator|*
operator|)
name|data
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|newsock
operator|=
name|accept
argument_list|(
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|sockState
operator|->
name|sock
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsock
operator|<
literal|0
condition|)
block|{
return|return;
block|}
name|newFile
operator|=
name|Tcl_GetFile
argument_list|(
operator|(
name|ClientData
operator|)
name|newsock
argument_list|,
name|TCL_UNIX_FD
argument_list|)
expr_stmt|;
if|if
condition|(
name|newFile
condition|)
block|{
name|newSockState
operator|=
operator|(
name|TcpState
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|TcpState
argument_list|)
argument_list|)
expr_stmt|;
name|newSockState
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|newSockState
operator|->
name|sock
operator|=
name|newFile
expr_stmt|;
name|newSockState
operator|->
name|acceptProc
operator|=
operator|(
name|Tcl_TcpAcceptProc
operator|*
operator|)
name|NULL
expr_stmt|;
name|newSockState
operator|->
name|acceptProcData
operator|=
operator|(
name|ClientData
operator|)
name|NULL
expr_stmt|;
name|sprintf
argument_list|(
name|channelName
argument_list|,
literal|"sock%d"
argument_list|,
operator|(
name|int
operator|)
name|newsock
argument_list|)
expr_stmt|;
name|chan
operator|=
name|Tcl_CreateChannel
argument_list|(
operator|&
name|tcpChannelType
argument_list|,
name|channelName
argument_list|,
name|newFile
argument_list|,
name|newFile
argument_list|,
operator|(
name|ClientData
operator|)
name|newSockState
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newSockState
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|newsock
argument_list|)
expr_stmt|;
name|Tcl_FreeFile
argument_list|(
name|newFile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Tcl_SetChannelOption
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|chan
argument_list|,
literal|"-translation"
argument_list|,
literal|"auto crlf"
argument_list|)
operator|==
name|TCL_ERROR
condition|)
block|{
name|Tcl_Close
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sockState
operator|->
name|acceptProc
operator|!=
operator|(
name|Tcl_TcpAcceptProc
operator|*
operator|)
name|NULL
condition|)
block|{
call|(
name|sockState
operator|->
name|acceptProc
call|)
argument_list|(
name|sockState
operator|->
name|acceptProcData
argument_list|,
name|chan
argument_list|,
name|inet_ntoa
argument_list|(
name|addr
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|addr
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclGetDefaultStdChannel --  *  *	Creates channels for standard input, standard output or standard  *	error output if they do not already exist.  *  * Results:  *	Returns the specified default standard channel, or NULL.  *  * Side effects:  *	May cause the creation of a standard channel and the underlying  *	file.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Channel
name|TclGetDefaultStdChannel
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
comment|/* One of TCL_STDIN, TCL_STDOUT, TCL_STDERR. */
block|{
name|Tcl_Channel
name|channel
init|=
name|NULL
decl_stmt|;
name|int
name|fd
init|=
literal|0
decl_stmt|;
comment|/* Initializations needed to prevent */
name|int
name|mode
init|=
literal|0
decl_stmt|;
comment|/* compiler warning (used before set). */
name|char
modifier|*
name|bufMode
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TCL_STDIN
case|:
if|if
condition|(
operator|(
name|lseek
argument_list|(
literal|0
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EBADF
operator|)
condition|)
block|{
return|return
operator|(
name|Tcl_Channel
operator|)
name|NULL
return|;
block|}
name|fd
operator|=
literal|0
expr_stmt|;
name|mode
operator|=
name|TCL_READABLE
expr_stmt|;
name|bufMode
operator|=
literal|"line"
expr_stmt|;
break|break;
case|case
name|TCL_STDOUT
case|:
if|if
condition|(
operator|(
name|lseek
argument_list|(
literal|1
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EBADF
operator|)
condition|)
block|{
return|return
operator|(
name|Tcl_Channel
operator|)
name|NULL
return|;
block|}
name|fd
operator|=
literal|1
expr_stmt|;
name|mode
operator|=
name|TCL_WRITABLE
expr_stmt|;
name|bufMode
operator|=
literal|"line"
expr_stmt|;
break|break;
case|case
name|TCL_STDERR
case|:
if|if
condition|(
operator|(
name|lseek
argument_list|(
literal|2
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EBADF
operator|)
condition|)
block|{
return|return
operator|(
name|Tcl_Channel
operator|)
name|NULL
return|;
block|}
name|fd
operator|=
literal|2
expr_stmt|;
name|mode
operator|=
name|TCL_WRITABLE
expr_stmt|;
name|bufMode
operator|=
literal|"none"
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"TclGetDefaultStdChannel: Unexpected channel type"
argument_list|)
expr_stmt|;
break|break;
block|}
name|channel
operator|=
name|Tcl_MakeFileChannel
argument_list|(
operator|(
name|ClientData
operator|)
name|fd
argument_list|,
operator|(
name|ClientData
operator|)
name|fd
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/*      * Set up the normal channel options for stdio handles.      */
if|if
condition|(
name|Tcl_SetChannelOption
argument_list|(
name|NULL
argument_list|,
name|channel
argument_list|,
literal|"-translation"
argument_list|,
literal|"auto"
argument_list|)
operator|==
name|TCL_ERROR
condition|)
block|{
name|Tcl_Close
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|channel
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|Tcl_SetChannelOption
argument_list|(
name|NULL
argument_list|,
name|channel
argument_list|,
literal|"-buffering"
argument_list|,
name|bufMode
argument_list|)
operator|==
name|TCL_ERROR
condition|)
block|{
name|Tcl_Close
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|channel
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|channel
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclClosePipeFile --  *  *	This function is a simple wrapper for close on a file or  *	pipe handle. Called in the generic command pipeline cleanup  *	code to do platform specific closing of the files associated  *	with the command channel.  *  * Results:  *	None.  *  * Side effects:  *	Closes the fd and frees the Tcl_File.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclClosePipeFile
parameter_list|(
name|file
parameter_list|)
name|Tcl_File
name|file
decl_stmt|;
block|{
name|int
name|fd
init|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|file
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|Tcl_FreeFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetOpenFile --  *  *	Given a name of a channel registered in the given interpreter,  *	returns a FILE * for it.  *  * Results:  *	A standard Tcl result. If the channel is registered in the given  *	interpreter and it is managed by the "file" channel driver, and  *	it is open for the requested mode, then the output parameter  *	filePtr is set to a FILE * for the underlying file. On error, the  *	filePtr is not set, TCL_ERROR is returned and an error message is  *	left in interp->result.  *  * Side effects:  *	May invoke fdopen to create the FILE * for the requested file.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_GetOpenFile
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|forWriting
parameter_list|,
name|checkUsage
parameter_list|,
name|filePtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to find file. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String that identifies file. */
name|int
name|forWriting
decl_stmt|;
comment|/* 1 means the file is going to be used 				 * for writing, 0 means for reading. */
name|int
name|checkUsage
decl_stmt|;
comment|/* 1 means verify that the file was opened 				 * in a mode that allows the access specified 				 * by "forWriting". Ignored, we always                                  * check that the channel is open for the                                  * requested mode. */
name|ClientData
modifier|*
name|filePtr
decl_stmt|;
comment|/* Store pointer to FILE structure here. */
block|{
name|Tcl_Channel
name|chan
decl_stmt|;
name|int
name|chanMode
decl_stmt|;
name|Tcl_ChannelType
modifier|*
name|chanTypePtr
decl_stmt|;
name|Tcl_File
name|tf
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|chan
operator|=
name|Tcl_GetChannel
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
operator|&
name|chanMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|forWriting
operator|)
operator|&&
operator|(
operator|(
name|chanMode
operator|&
name|TCL_WRITABLE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"\""
argument_list|,
name|string
argument_list|,
literal|"\" wasn't opened for writing"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
operator|(
name|forWriting
operator|)
operator|)
operator|&&
operator|(
operator|(
name|chanMode
operator|&
name|TCL_READABLE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"\""
argument_list|,
name|string
argument_list|,
literal|"\" wasn't opened for reading"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * We allow creating a FILE * out of file based, pipe based and socket      * based channels. We currently do not allow any other channel types,      * because it is likely that stdio will not know what to do with them.      */
name|chanTypePtr
operator|=
name|Tcl_GetChannelType
argument_list|(
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chanTypePtr
operator|==
operator|&
name|fileChannelType
operator|)
operator|||
operator|(
name|chanTypePtr
operator|==
operator|&
name|pipeChannelType
operator|)
operator|||
operator|(
name|chanTypePtr
operator|==
operator|&
name|tcpChannelType
operator|)
condition|)
block|{
name|tf
operator|=
name|Tcl_GetChannelFile
argument_list|(
name|chan
argument_list|,
operator|(
name|forWriting
condition|?
name|TCL_WRITABLE
else|:
name|TCL_READABLE
operator|)
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|(
name|int
operator|)
name|Tcl_GetFileInfo
argument_list|(
name|tf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*          * The call to fdopen below is probably dangerous, since it will          * truncate an existing file if the file is being opened          * for writing....          */
name|f
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
operator|(
name|forWriting
condition|?
literal|"w"
else|:
literal|"r"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"cannot get a FILE * for \""
argument_list|,
name|string
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
operator|*
name|filePtr
operator|=
operator|(
name|ClientData
operator|)
name|f
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"\""
argument_list|,
name|string
argument_list|,
literal|"\" cannot be used to get a FILE * - unsupported type"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

end_unit

