begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclTest.c --  *  *	This file contains C command procedures for a bunch of additional  *	Tcl commands that are used for testing out Tcl's C interfaces.  *	These commands are not normally included in Tcl applications;  *	they're only used for testing.  *  * Copyright (c) 1993-1994 The Regents of the University of California.  * Copyright (c) 1994-1997 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclTest.c 1.115 97/08/13 10:27:26  */
end_comment

begin_define
define|#
directive|define
name|TCL_TEST
end_define

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * Declare external functions used in Windows tests.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__WIN32__
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|TclPlatformType
modifier|*
name|TclWinGetPlatform
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Dynamic string shared by TestdcallCmd and DelCallbackProc;  used  * to collect the results of the various deletion callbacks.  */
end_comment

begin_decl_stmt
specifier|static
name|Tcl_DString
name|delString
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Tcl_Interp
modifier|*
name|delInterp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * One of the following structures exists for each asynchronous  * handler created by the "testasync" command".  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|TestAsyncHandler
block|{
name|int
name|id
decl_stmt|;
comment|/* Identifier for this handler. */
name|Tcl_AsyncHandler
name|handler
decl_stmt|;
comment|/* Tcl's token for the handler. */
name|char
modifier|*
name|command
decl_stmt|;
comment|/* Command to invoke when the 					 * handler is invoked. */
name|struct
name|TestAsyncHandler
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next is list of handlers. */
block|}
name|TestAsyncHandler
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|TestAsyncHandler
modifier|*
name|firstHandler
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The dynamic string below is used by the "testdstring" command  * to test the dynamic string facilities.  */
end_comment

begin_decl_stmt
specifier|static
name|Tcl_DString
name|dstring
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * One of the following structures exists for each command created  * by TestdelCmd:  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|DelCmd
block|{
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which command exists. */
name|char
modifier|*
name|deleteCmd
decl_stmt|;
comment|/* Script to execute when command is 				 * deleted.  Malloc'ed. */
block|}
name|DelCmd
typedef|;
end_typedef

begin_comment
comment|/*  * Forward declarations for procedures defined later in this file:  */
end_comment

begin_decl_stmt
name|int
name|Tcltest_Init
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|AsyncHandlerProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|CleanupTestSetassocdataTests
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|CmdDelProc1
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|CmdDelProc2
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CmdProc1
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CmdProc2
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|CmdTraceProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|level
operator|,
name|char
operator|*
name|command
operator|,
name|Tcl_CmdProc
operator|*
name|cmdProc
operator|,
name|ClientData
name|cmdClientData
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CreatedCommandProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CreatedCommandProc2
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DelCallbackProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DelCmdProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DelDeleteProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ExitProcEven
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ExitProcOdd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|GetTimesCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|NoopCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|NoopObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|SpecialFree
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|blockPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|StaticInitProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestasyncCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestcmdinfoCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestcmdtokenCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestcmdtraceCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestchmodCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestcreatecommandCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestdcallCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestdelCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestdelassocdataCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestdstringCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestexithandlerCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestexprlongCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestexprstringCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestfileCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestfeventCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestgetassocdataCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestgetplatformCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestgetvarfullnameCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestinterpdeleteCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestlinkCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestMathFunc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Value
operator|*
name|args
operator|,
name|Tcl_Value
operator|*
name|resultPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestMathFunc2
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Value
operator|*
name|args
operator|,
name|Tcl_Value
operator|*
name|resultPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestPanicCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestsetassocdataCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestsetnoerrCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestsetobjerrorcodeCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestsetplatformCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TeststaticpkgCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TesttranslatefilenameCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestupvarCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestwordendObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * External (platform specific) initialization routine:  */
end_comment

begin_decl_stmt
name|EXTERN
name|int
name|TclplatformtestInit
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcltest_Init --  *  *	This procedure performs application-specific initialization.  *	Most applications, especially those that incorporate additional  *	packages, will have their own version of this procedure.  *  * Results:  *	Returns a standard Tcl completion code, and leaves an error  *	message in interp->result if an error occurs.  *  * Side effects:  *	Depends on the startup script.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcltest_Init
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter for application. */
block|{
name|Tcl_ValueType
name|t3ArgTypes
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|Tcl_PkgProvide
argument_list|(
name|interp
argument_list|,
literal|"Tcltest"
argument_list|,
name|TCL_VERSION
argument_list|)
operator|==
name|TCL_ERROR
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Create additional commands and math functions for testing Tcl.      */
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"noop"
argument_list|,
name|NoopCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateObjCommand
argument_list|(
name|interp
argument_list|,
literal|"noop"
argument_list|,
name|NoopObjCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testasync"
argument_list|,
name|TestasyncCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testchannel"
argument_list|,
name|TclTestChannelCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testchannelevent"
argument_list|,
name|TclTestChannelEventCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testchmod"
argument_list|,
name|TestchmodCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testcmdtoken"
argument_list|,
name|TestcmdtokenCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testcmdinfo"
argument_list|,
name|TestcmdinfoCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testcmdtrace"
argument_list|,
name|TestcmdtraceCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testcreatecommand"
argument_list|,
name|TestcreatecommandCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testdcall"
argument_list|,
name|TestdcallCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testdel"
argument_list|,
name|TestdelCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testdelassocdata"
argument_list|,
name|TestdelassocdataCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|dstring
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testdstring"
argument_list|,
name|TestdstringCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testexithandler"
argument_list|,
name|TestexithandlerCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testexprlong"
argument_list|,
name|TestexprlongCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testexprstring"
argument_list|,
name|TestexprstringCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testfile"
argument_list|,
name|TestfileCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testgetassocdata"
argument_list|,
name|TestgetassocdataCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testgetplatform"
argument_list|,
name|TestgetplatformCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateObjCommand
argument_list|(
name|interp
argument_list|,
literal|"testgetvarfullname"
argument_list|,
name|TestgetvarfullnameCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testinterpdelete"
argument_list|,
name|TestinterpdeleteCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testlink"
argument_list|,
name|TestlinkCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testsetassocdata"
argument_list|,
name|TestsetassocdataCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testsetnoerr"
argument_list|,
name|TestsetnoerrCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateObjCommand
argument_list|(
name|interp
argument_list|,
literal|"testsetobjerrorcode"
argument_list|,
name|TestsetobjerrorcodeCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testsetplatform"
argument_list|,
name|TestsetplatformCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"teststaticpkg"
argument_list|,
name|TeststaticpkgCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testtranslatefilename"
argument_list|,
name|TesttranslatefilenameCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testupvar"
argument_list|,
name|TestupvarCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateObjCommand
argument_list|(
name|interp
argument_list|,
literal|"testwordend"
argument_list|,
name|TestwordendObjCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testfevent"
argument_list|,
name|TestfeventCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testpanic"
argument_list|,
name|TestPanicCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"gettimes"
argument_list|,
name|GetTimesCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateMathFunc
argument_list|(
name|interp
argument_list|,
literal|"T1"
argument_list|,
literal|0
argument_list|,
operator|(
name|Tcl_ValueType
operator|*
operator|)
name|NULL
argument_list|,
name|TestMathFunc
argument_list|,
operator|(
name|ClientData
operator|)
literal|123
argument_list|)
expr_stmt|;
name|Tcl_CreateMathFunc
argument_list|(
name|interp
argument_list|,
literal|"T2"
argument_list|,
literal|0
argument_list|,
operator|(
name|Tcl_ValueType
operator|*
operator|)
name|NULL
argument_list|,
name|TestMathFunc
argument_list|,
operator|(
name|ClientData
operator|)
literal|345
argument_list|)
expr_stmt|;
name|t3ArgTypes
index|[
literal|0
index|]
operator|=
name|TCL_EITHER
expr_stmt|;
name|t3ArgTypes
index|[
literal|1
index|]
operator|=
name|TCL_EITHER
expr_stmt|;
name|Tcl_CreateMathFunc
argument_list|(
name|interp
argument_list|,
literal|"T3"
argument_list|,
literal|2
argument_list|,
name|t3ArgTypes
argument_list|,
name|TestMathFunc2
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/*      * And finally add any platform specific test commands.      */
return|return
name|TclplatformtestInit
argument_list|(
name|interp
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestasyncCmd --  *  *	This procedure implements the "testasync" command.  It is used  *	to test the asynchronous handler facilities of Tcl.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Creates, deletes, and invokes handlers.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestasyncCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|TestAsyncHandler
modifier|*
name|asyncPtr
decl_stmt|,
modifier|*
name|prevPtr
decl_stmt|;
name|int
name|id
decl_stmt|,
name|code
decl_stmt|;
specifier|static
name|int
name|nextId
init|=
literal|1
decl_stmt|;
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|wrongNumArgs
label|:
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"create"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|asyncPtr
operator|=
operator|(
name|TestAsyncHandler
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TestAsyncHandler
argument_list|)
argument_list|)
expr_stmt|;
name|asyncPtr
operator|->
name|id
operator|=
name|nextId
expr_stmt|;
name|nextId
operator|++
expr_stmt|;
name|asyncPtr
operator|->
name|handler
operator|=
name|Tcl_AsyncCreate
argument_list|(
name|AsyncHandlerProc
argument_list|,
operator|(
name|ClientData
operator|)
name|asyncPtr
argument_list|)
expr_stmt|;
name|asyncPtr
operator|->
name|command
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|asyncPtr
operator|->
name|command
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|asyncPtr
operator|->
name|nextPtr
operator|=
name|firstHandler
expr_stmt|;
name|firstHandler
operator|=
name|asyncPtr
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|asyncPtr
operator|->
name|id
argument_list|)
expr_stmt|;
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"delete"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
while|while
condition|(
name|firstHandler
operator|!=
name|NULL
condition|)
block|{
name|asyncPtr
operator|=
name|firstHandler
expr_stmt|;
name|firstHandler
operator|=
name|asyncPtr
operator|->
name|nextPtr
expr_stmt|;
name|Tcl_AsyncDelete
argument_list|(
name|asyncPtr
operator|->
name|handler
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|asyncPtr
operator|->
name|command
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|asyncPtr
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|id
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
for|for
control|(
name|prevPtr
operator|=
name|NULL
operator|,
name|asyncPtr
operator|=
name|firstHandler
init|;
name|asyncPtr
operator|!=
name|NULL
condition|;
name|prevPtr
operator|=
name|asyncPtr
operator|,
name|asyncPtr
operator|=
name|asyncPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|asyncPtr
operator|->
name|id
operator|!=
name|id
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|prevPtr
operator|==
name|NULL
condition|)
block|{
name|firstHandler
operator|=
name|asyncPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
name|prevPtr
operator|->
name|nextPtr
operator|=
name|asyncPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
name|Tcl_AsyncDelete
argument_list|(
name|asyncPtr
operator|->
name|handler
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|asyncPtr
operator|->
name|command
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|asyncPtr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"mark"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|5
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
operator|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|id
argument_list|)
operator|!=
name|TCL_OK
operator|)
operator|||
operator|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
operator|&
name|code
argument_list|)
operator|!=
name|TCL_OK
operator|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
for|for
control|(
name|asyncPtr
operator|=
name|firstHandler
init|;
name|asyncPtr
operator|!=
name|NULL
condition|;
name|asyncPtr
operator|=
name|asyncPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|asyncPtr
operator|->
name|id
operator|==
name|id
condition|)
block|{
name|Tcl_AsyncMark
argument_list|(
name|asyncPtr
operator|->
name|handler
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": must be create, delete, int, or mark"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|AsyncHandlerProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|code
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Pointer to TestAsyncHandler structure. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which command was 				 * executed, or NULL. */
name|int
name|code
decl_stmt|;
comment|/* Current return code from command. */
block|{
name|TestAsyncHandler
modifier|*
name|asyncPtr
init|=
operator|(
name|TestAsyncHandler
operator|*
operator|)
name|clientData
decl_stmt|;
name|char
modifier|*
name|listArgv
index|[
literal|4
index|]
decl_stmt|;
name|char
name|string
index|[
literal|20
index|]
decl_stmt|,
modifier|*
name|cmd
decl_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%d"
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|listArgv
index|[
literal|0
index|]
operator|=
name|asyncPtr
operator|->
name|command
expr_stmt|;
name|listArgv
index|[
literal|1
index|]
operator|=
name|interp
operator|->
name|result
expr_stmt|;
name|listArgv
index|[
literal|2
index|]
operator|=
name|string
expr_stmt|;
name|listArgv
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|cmd
operator|=
name|Tcl_Merge
argument_list|(
literal|3
argument_list|,
name|listArgv
argument_list|)
expr_stmt|;
name|code
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestcmdinfoCmd --  *  *	This procedure implements the "testcmdinfo" command.  It is used  *	to test Tcl_GetCommandInfo, Tcl_SetCommandInfo, and command creation  *	and deletion.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Creates and deletes various commands and modifies their data.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestcmdinfoCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Tcl_CmdInfo
name|info
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" option cmdName\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"create"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|CmdProc1
argument_list|,
operator|(
name|ClientData
operator|)
literal|"original"
argument_list|,
name|CmdDelProc1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"delete"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_DStringInit
argument_list|(
operator|&
name|delString
argument_list|)
expr_stmt|;
name|Tcl_DeleteCommand
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|Tcl_DStringResult
argument_list|(
name|interp
argument_list|,
operator|&
name|delString
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"get"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|Tcl_GetCommandInfo
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|info
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"??"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|info
operator|.
name|proc
operator|==
name|CmdProc1
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"CmdProc1"
argument_list|,
literal|" "
argument_list|,
operator|(
name|char
operator|*
operator|)
name|info
operator|.
name|clientData
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|.
name|proc
operator|==
name|CmdProc2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"CmdProc2"
argument_list|,
literal|" "
argument_list|,
operator|(
name|char
operator|*
operator|)
name|info
operator|.
name|clientData
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"unknown"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|.
name|deleteProc
operator|==
name|CmdDelProc1
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|" CmdDelProc1"
argument_list|,
literal|" "
argument_list|,
operator|(
name|char
operator|*
operator|)
name|info
operator|.
name|deleteData
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|.
name|deleteProc
operator|==
name|CmdDelProc2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|" CmdDelProc2"
argument_list|,
literal|" "
argument_list|,
operator|(
name|char
operator|*
operator|)
name|info
operator|.
name|deleteData
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|" unknown"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|" "
argument_list|,
name|info
operator|.
name|namespacePtr
operator|->
name|fullName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|isNativeObjectProc
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|" nativeObjectProc"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|" stringProc"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"modify"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|info
operator|.
name|proc
operator|=
name|CmdProc2
expr_stmt|;
name|info
operator|.
name|clientData
operator|=
operator|(
name|ClientData
operator|)
literal|"new_command_data"
expr_stmt|;
name|info
operator|.
name|objProc
operator|=
name|NULL
expr_stmt|;
name|info
operator|.
name|objClientData
operator|=
operator|(
name|ClientData
operator|)
name|NULL
expr_stmt|;
name|info
operator|.
name|deleteProc
operator|=
name|CmdDelProc2
expr_stmt|;
name|info
operator|.
name|deleteData
operator|=
operator|(
name|ClientData
operator|)
literal|"new_delete_data"
expr_stmt|;
if|if
condition|(
name|Tcl_SetCommandInfo
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|info
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"0"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"1"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": must be create, delete, get, or modify"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|CmdProc1
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* String to return. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"CmdProc1 "
argument_list|,
operator|(
name|char
operator|*
operator|)
name|clientData
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|CmdProc2
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* String to return. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"CmdProc2 "
argument_list|,
operator|(
name|char
operator|*
operator|)
name|clientData
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|CmdDelProc1
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* String to save. */
block|{
name|Tcl_DStringInit
argument_list|(
operator|&
name|delString
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|delString
argument_list|,
literal|"CmdDelProc1 "
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|delString
argument_list|,
operator|(
name|char
operator|*
operator|)
name|clientData
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|CmdDelProc2
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* String to save. */
block|{
name|Tcl_DStringInit
argument_list|(
operator|&
name|delString
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|delString
argument_list|,
literal|"CmdDelProc2 "
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|delString
argument_list|,
operator|(
name|char
operator|*
operator|)
name|clientData
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestcmdtokenCmd --  *  *	This procedure implements the "testcmdtoken" command. It is used  *	to test Tcl_Command tokens and procedures such as  *	Tcl_GetCommandFullName.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Creates and deletes various commands and modifies their data.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestcmdtokenCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Tcl_Command
name|token
decl_stmt|;
name|long
name|int
name|l
decl_stmt|;
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" option arg\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"create"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|token
operator|=
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|CmdProc1
argument_list|,
operator|(
name|ClientData
operator|)
literal|"original"
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%lx"
argument_list|,
operator|(
name|long
name|int
operator|)
name|token
argument_list|)
expr_stmt|;
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"name"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"%lx"
argument_list|,
operator|&
name|l
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad command token \""
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|objPtr
operator|=
name|Tcl_NewObj
argument_list|()
expr_stmt|;
name|Tcl_GetCommandFullName
argument_list|(
name|interp
argument_list|,
operator|(
name|Tcl_Command
operator|)
name|l
argument_list|,
name|objPtr
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|Tcl_GetCommandName
argument_list|(
name|interp
argument_list|,
operator|(
name|Tcl_Command
operator|)
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": must be create or name"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestcmdtraceCmd --  *  *	This procedure implements the "testcmdtrace" command. It is used  *	to test Tcl_CreateTrace and Tcl_DeleteTrace.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Creates and deletes a command trace, and tests the invocation of  *	a procedure by the command trace.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestcmdtraceCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Tcl_Trace
name|trace
decl_stmt|;
name|Tcl_DString
name|buffer
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" script\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_DStringInit
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|trace
operator|=
name|Tcl_CreateTrace
argument_list|(
name|interp
argument_list|,
literal|50000
argument_list|,
operator|(
name|Tcl_CmdTraceProc
operator|*
operator|)
name|CmdTraceProc
argument_list|,
operator|(
name|ClientData
operator|)
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|buffer
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|Tcl_DeleteTrace
argument_list|(
name|interp
argument_list|,
name|trace
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|CmdTraceProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|level
parameter_list|,
name|command
parameter_list|,
name|cmdProc
parameter_list|,
name|cmdClientData
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Pointer to buffer in which the 				 * command and arguments are appended. 				 * Accumulates test result. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|level
decl_stmt|;
comment|/* Current trace level. */
name|char
modifier|*
name|command
decl_stmt|;
comment|/* The command being traced (after 				 * substitutions). */
name|Tcl_CmdProc
modifier|*
name|cmdProc
decl_stmt|;
comment|/* Points to command's command procedure. */
name|ClientData
name|cmdClientData
decl_stmt|;
comment|/* Client data associated with command 				 * procedure. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Tcl_DString
modifier|*
name|bufPtr
init|=
operator|(
name|Tcl_DString
operator|*
operator|)
name|clientData
decl_stmt|;
name|int
name|i
decl_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
name|bufPtr
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|Tcl_DStringStartSublist
argument_list|(
name|bufPtr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|bufPtr
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|Tcl_DStringEndSublist
argument_list|(
name|bufPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestcreatecommandCmd --  *  *	This procedure implements the "testcreatecommand" command. It is  *	used to test that the Tcl_CreateCommand creates a new command in  *	the namespace specified as part of its name, if any. It also  *	checks that the namespace code ignore single ":"s in the middle  *	or end of a command name.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Creates and deletes two commands ("test_ns_basic::createdcommand"  *	and "value:at:").  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestcreatecommandCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" option\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"create"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"test_ns_basic::createdcommand"
argument_list|,
name|CreatedCommandProc
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"delete"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_DeleteCommand
argument_list|(
name|interp
argument_list|,
literal|"test_ns_basic::createdcommand"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"create2"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"value:at:"
argument_list|,
name|CreatedCommandProc2
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"delete2"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_DeleteCommand
argument_list|(
name|interp
argument_list|,
literal|"value:at:"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": must be create, delete, create2, or delete2"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|CreatedCommandProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* String to return. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Tcl_CmdInfo
name|info
decl_stmt|;
name|int
name|found
decl_stmt|;
name|found
operator|=
name|Tcl_GetCommandInfo
argument_list|(
name|interp
argument_list|,
literal|"test_ns_basic::createdcommand"
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"CreatedCommandProc could not get command info for test_ns_basic::createdcommand"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"CreatedCommandProc in "
argument_list|,
name|info
operator|.
name|namespacePtr
operator|->
name|fullName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|CreatedCommandProc2
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* String to return. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Tcl_CmdInfo
name|info
decl_stmt|;
name|int
name|found
decl_stmt|;
name|found
operator|=
name|Tcl_GetCommandInfo
argument_list|(
name|interp
argument_list|,
literal|"value:at:"
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"CreatedCommandProc2 could not get command info for test_ns_basic::createdcommand"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"CreatedCommandProc2 in "
argument_list|,
name|info
operator|.
name|namespacePtr
operator|->
name|fullName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestdcallCmd --  *  *	This procedure implements the "testdcall" command.  It is used  *	to test Tcl_CallWhenDeleted.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Creates and deletes interpreters.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestdcallCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|i
decl_stmt|,
name|id
decl_stmt|;
name|delInterp
operator|=
name|Tcl_CreateInterp
argument_list|()
expr_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|delString
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
operator|&
name|id
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|id
operator|<
literal|0
condition|)
block|{
name|Tcl_DontCallWhenDeleted
argument_list|(
name|delInterp
argument_list|,
name|DelCallbackProc
argument_list|,
call|(
name|ClientData
call|)
argument_list|(
operator|-
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_CallWhenDeleted
argument_list|(
name|delInterp
argument_list|,
name|DelCallbackProc
argument_list|,
operator|(
name|ClientData
operator|)
name|id
argument_list|)
expr_stmt|;
block|}
block|}
name|Tcl_DeleteInterp
argument_list|(
name|delInterp
argument_list|)
expr_stmt|;
name|Tcl_DStringResult
argument_list|(
name|interp
argument_list|,
operator|&
name|delString
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * The deletion callback used by TestdcallCmd:  */
end_comment

begin_function
specifier|static
name|void
name|DelCallbackProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Numerical value to append to 					 * delString. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter being deleted. */
block|{
name|int
name|id
init|=
operator|(
name|int
operator|)
name|clientData
decl_stmt|;
name|char
name|buffer
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
operator|&
name|delString
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|interp
operator|!=
name|delInterp
condition|)
block|{
name|Tcl_DStringAppendElement
argument_list|(
operator|&
name|delString
argument_list|,
literal|"bogus interpreter argument!"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestdelCmd --  *  *	This procedure implements the "testdcall" command.  It is used  *	to test Tcl_CallWhenDeleted.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Creates and deletes interpreters.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestdelCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|DelCmd
modifier|*
name|dPtr
decl_stmt|;
name|Tcl_Interp
modifier|*
name|slave
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|slave
operator|=
name|Tcl_GetSlave
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|slave
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|dPtr
operator|=
operator|(
name|DelCmd
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DelCmd
argument_list|)
argument_list|)
expr_stmt|;
name|dPtr
operator|->
name|interp
operator|=
name|interp
expr_stmt|;
name|dPtr
operator|->
name|deleteCmd
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dPtr
operator|->
name|deleteCmd
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|slave
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|DelCmdProc
argument_list|,
operator|(
name|ClientData
operator|)
name|dPtr
argument_list|,
name|DelDeleteProc
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|DelCmdProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* String result to return. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|DelCmd
modifier|*
name|dPtr
init|=
operator|(
name|DelCmd
operator|*
operator|)
name|clientData
decl_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|dPtr
operator|->
name|deleteCmd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|dPtr
operator|->
name|deleteCmd
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|DelDeleteProc
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* String command to evaluate. */
block|{
name|DelCmd
modifier|*
name|dPtr
init|=
operator|(
name|DelCmd
operator|*
operator|)
name|clientData
decl_stmt|;
name|Tcl_Eval
argument_list|(
name|dPtr
operator|->
name|interp
argument_list|,
name|dPtr
operator|->
name|deleteCmd
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|dPtr
operator|->
name|interp
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|dPtr
operator|->
name|deleteCmd
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestdelassocdataCmd --  *  *	This procedure implements the "testdelassocdata" command. It is used  *	to test Tcl_DeleteAssocData.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Deletes an association between a key and associated data from an  *	interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestdelassocdataCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" data_key\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_DeleteAssocData
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestdstringCmd --  *  *	This procedure implements the "testdstring" command.  It is used  *	to test the dynamic string facilities of Tcl.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Creates, deletes, and invokes handlers.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestdstringCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|count
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|wrongNumArgs
label|:
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"append"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
operator|&
name|count
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_DStringAppend
argument_list|(
operator|&
name|dstring
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"element"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|Tcl_DStringAppendElement
argument_list|(
operator|&
name|dstring
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"end"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|Tcl_DStringEndSublist
argument_list|(
operator|&
name|dstring
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"free"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|Tcl_DStringFree
argument_list|(
operator|&
name|dstring
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"get"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|dstring
argument_list|)
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"gresult"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"staticsmall"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"short"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"staticlarge"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"first0 first1 first2 first3 first4 first5 first6 first7 first8 first9\nsecond0 second1 second2 second3 second4 second5 second6 second7 second8 second9\nthird0 third1 third2 third3 third4 third5 third6 third7 third8 third9\nfourth0 fourth1 fourth2 fourth3 fourth4 fourth5 fourth6 fourth7 fourth8 fourth9\nfifth0 fifth1 fifth2 fifth3 fifth4 fifth5 fifth6 fifth7 fifth8 fifth9\nsixth0 sixth1 sixth2 sixth3 sixth4 sixth5 sixth6 sixth7 sixth8 sixth9\nseventh0 seventh1 seventh2 seventh3 seventh4 seventh5 seventh6 seventh7 seventh8 seventh9\n"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"free"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
literal|100
argument_list|)
argument_list|,
name|TCL_DYNAMIC
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"This is a malloc-ed string"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"special"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|interp
operator|->
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|interp
operator|->
name|result
operator|+=
literal|4
expr_stmt|;
name|interp
operator|->
name|freeProc
operator|=
name|SpecialFree
expr_stmt|;
name|strcpy
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"This is a specially-allocated string"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad gresult option \""
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"\": must be staticsmall, staticlarge, free, or special"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_DStringGetResult
argument_list|(
name|interp
argument_list|,
operator|&
name|dstring
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"length"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|Tcl_DStringLength
argument_list|(
operator|&
name|dstring
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"result"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|Tcl_DStringResult
argument_list|(
name|interp
argument_list|,
operator|&
name|dstring
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"trunc"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|count
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_DStringTrunc
argument_list|(
operator|&
name|dstring
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"start"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|Tcl_DStringStartSublist
argument_list|(
operator|&
name|dstring
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": must be append, element, end, free, get, length, "
argument_list|,
literal|"result, trunc, or start"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * The procedure below is used as a special freeProc to test how well  * Tcl_DStringGetResult handles freeProc's other than free.  */
end_comment

begin_function
specifier|static
name|void
name|SpecialFree
parameter_list|(
name|blockPtr
parameter_list|)
name|char
modifier|*
name|blockPtr
decl_stmt|;
comment|/* Block to free. */
block|{
name|ckfree
argument_list|(
name|blockPtr
operator|-
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestexithandlerCmd --  *  *	This procedure implements the "testexithandler" command. It is  *	used to test Tcl_CreateExitHandler and Tcl_DeleteExitHandler.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestexithandlerCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|value
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" create|delete value\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|value
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"create"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_CreateExitHandler
argument_list|(
operator|(
name|value
operator|&
literal|1
operator|)
condition|?
name|ExitProcOdd
else|:
name|ExitProcEven
argument_list|,
operator|(
name|ClientData
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"delete"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_DeleteExitHandler
argument_list|(
operator|(
name|value
operator|&
literal|1
operator|)
condition|?
name|ExitProcOdd
else|:
name|ExitProcEven
argument_list|,
operator|(
name|ClientData
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": must be create or delete"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ExitProcOdd
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Integer value to print. */
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"odd %d\n"
argument_list|,
operator|(
name|int
operator|)
name|clientData
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|1
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ExitProcEven
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Integer value to print. */
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"even %d\n"
argument_list|,
operator|(
name|int
operator|)
name|clientData
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|1
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestexprlongCmd --  *  *	This procedure verifies that Tcl_ExprLong does not modify the  *	interpreter result if there is no error.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestexprlongCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|long
name|exprResult
decl_stmt|;
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|int
name|result
decl_stmt|;
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"This is a result"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_ExprLong
argument_list|(
name|interp
argument_list|,
literal|"4+1"
argument_list|,
operator|&
name|exprResult
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|": %ld"
argument_list|,
name|exprResult
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestexprstringCmd --  *  *	This procedure tests the basic operation of Tcl_ExprString.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestexprstringCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" expression\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|Tcl_ExprString
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestgetassocdataCmd --  *  *	This procedure implements the "testgetassocdata" command. It is  *	used to test Tcl_GetAssocData.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestgetassocdataCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|char
modifier|*
name|res
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" data_key\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|res
operator|=
operator|(
name|char
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|res
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestgetplatformCmd --  *  *	This procedure implements the "testgetplatform" command. It is  *	used to retrievel the value of the tclPlatform global variable.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestgetplatformCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
specifier|static
name|char
modifier|*
name|platformStrings
index|[]
init|=
block|{
literal|"unix"
block|,
literal|"mac"
block|,
literal|"windows"
block|}
decl_stmt|;
name|TclPlatformType
modifier|*
name|platform
decl_stmt|;
ifdef|#
directive|ifdef
name|__WIN32__
name|platform
operator|=
name|TclWinGetPlatform
argument_list|()
expr_stmt|;
else|#
directive|else
name|platform
operator|=
operator|&
name|tclPlatform
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|platformStrings
index|[
operator|*
name|platform
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestinterpdeleteCmd --  *  *	This procedure tests the code in tclInterp.c that deals with  *	interpreter deletion. It deletes a user-specified interpreter  *	from the hierarchy, and subsequent code checks integrity.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Deletes one or more interpreters.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestinterpdeleteCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Tcl_Interp
modifier|*
name|slaveToDelete
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" path\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"cannot delete current interpreter"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|slaveToDelete
operator|=
name|Tcl_GetSlave
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|slaveToDelete
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"could not find interpreter \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_DeleteInterp
argument_list|(
name|slaveToDelete
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestlinkCmd --  *  *	This procedure implements the "testlink" command.  It is used  *	to test Tcl_LinkVar and related library procedures.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Creates and deletes various variable links, plus returns  *	values of the linked variables.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestlinkCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
specifier|static
name|int
name|intVar
init|=
literal|43
decl_stmt|;
specifier|static
name|int
name|boolVar
init|=
literal|4
decl_stmt|;
specifier|static
name|double
name|realVar
init|=
literal|1.23
decl_stmt|;
specifier|static
name|char
modifier|*
name|stringVar
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|created
init|=
literal|0
decl_stmt|;
name|char
name|buffer
index|[
name|TCL_DOUBLE_SPACE
index|]
decl_stmt|;
name|int
name|writable
decl_stmt|,
name|flag
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" option ?arg arg arg?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"create"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|created
condition|)
block|{
name|Tcl_UnlinkVar
argument_list|(
name|interp
argument_list|,
literal|"int"
argument_list|)
expr_stmt|;
name|Tcl_UnlinkVar
argument_list|(
name|interp
argument_list|,
literal|"real"
argument_list|)
expr_stmt|;
name|Tcl_UnlinkVar
argument_list|(
name|interp
argument_list|,
literal|"bool"
argument_list|)
expr_stmt|;
name|Tcl_UnlinkVar
argument_list|(
name|interp
argument_list|,
literal|"string"
argument_list|)
expr_stmt|;
block|}
name|created
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|Tcl_GetBoolean
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|writable
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|flag
operator|=
operator|(
name|writable
operator|!=
literal|0
operator|)
condition|?
literal|0
else|:
name|TCL_LINK_READ_ONLY
expr_stmt|;
if|if
condition|(
name|Tcl_LinkVar
argument_list|(
name|interp
argument_list|,
literal|"int"
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|intVar
argument_list|,
name|TCL_LINK_INT
operator||
name|flag
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetBoolean
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
operator|&
name|writable
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|flag
operator|=
operator|(
name|writable
operator|!=
literal|0
operator|)
condition|?
literal|0
else|:
name|TCL_LINK_READ_ONLY
expr_stmt|;
if|if
condition|(
name|Tcl_LinkVar
argument_list|(
name|interp
argument_list|,
literal|"real"
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|realVar
argument_list|,
name|TCL_LINK_DOUBLE
operator||
name|flag
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetBoolean
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
operator|&
name|writable
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|flag
operator|=
operator|(
name|writable
operator|!=
literal|0
operator|)
condition|?
literal|0
else|:
name|TCL_LINK_READ_ONLY
expr_stmt|;
if|if
condition|(
name|Tcl_LinkVar
argument_list|(
name|interp
argument_list|,
literal|"bool"
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|boolVar
argument_list|,
name|TCL_LINK_BOOLEAN
operator||
name|flag
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetBoolean
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|5
index|]
argument_list|,
operator|&
name|writable
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|flag
operator|=
operator|(
name|writable
operator|!=
literal|0
operator|)
condition|?
literal|0
else|:
name|TCL_LINK_READ_ONLY
expr_stmt|;
if|if
condition|(
name|Tcl_LinkVar
argument_list|(
name|interp
argument_list|,
literal|"string"
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|stringVar
argument_list|,
name|TCL_LINK_STRING
operator||
name|flag
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"delete"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_UnlinkVar
argument_list|(
name|interp
argument_list|,
literal|"int"
argument_list|)
expr_stmt|;
name|Tcl_UnlinkVar
argument_list|(
name|interp
argument_list|,
literal|"real"
argument_list|)
expr_stmt|;
name|Tcl_UnlinkVar
argument_list|(
name|interp
argument_list|,
literal|"bool"
argument_list|)
expr_stmt|;
name|Tcl_UnlinkVar
argument_list|(
name|interp
argument_list|,
literal|"string"
argument_list|)
expr_stmt|;
name|created
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"get"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|intVar
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|Tcl_PrintDouble
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|realVar
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|boolVar
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
operator|(
name|stringVar
operator|==
name|NULL
operator|)
condition|?
literal|"-"
else|:
name|stringVar
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"set"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|6
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" "
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"intValue realValue boolValue stringValue\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|intVar
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
if|if
condition|(
name|argv
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Tcl_GetDouble
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
operator|&
name|realVar
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
if|if
condition|(
name|argv
index|[
literal|4
index|]
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
operator|&
name|boolVar
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
if|if
condition|(
name|argv
index|[
literal|5
index|]
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|stringVar
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|stringVar
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|5
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|stringVar
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|stringVar
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
literal|5
index|]
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|stringVar
argument_list|,
name|argv
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"update"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|6
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" "
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"intValue realValue boolValue stringValue\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|intVar
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_UpdateLinkedVar
argument_list|(
name|interp
argument_list|,
literal|"int"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argv
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Tcl_GetDouble
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
operator|&
name|realVar
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_UpdateLinkedVar
argument_list|(
name|interp
argument_list|,
literal|"real"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argv
index|[
literal|4
index|]
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
operator|&
name|boolVar
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_UpdateLinkedVar
argument_list|(
name|interp
argument_list|,
literal|"bool"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argv
index|[
literal|5
index|]
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|stringVar
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|stringVar
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|5
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|stringVar
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|stringVar
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
literal|5
index|]
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|stringVar
argument_list|,
name|argv
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
name|Tcl_UpdateLinkedVar
argument_list|(
name|interp
argument_list|,
literal|"string"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": should be create, delete, get, set, or update"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestMathFunc --  *  *	This is a user-defined math procedure to test out math procedures  *	with no arguments.  *  * Results:  *	A normal Tcl completion code.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestMathFunc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|args
parameter_list|,
name|resultPtr
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Integer value to return. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Not used. */
name|Tcl_Value
modifier|*
name|args
decl_stmt|;
comment|/* Not used. */
name|Tcl_Value
modifier|*
name|resultPtr
decl_stmt|;
comment|/* Where to store result. */
block|{
name|resultPtr
operator|->
name|type
operator|=
name|TCL_INT
expr_stmt|;
name|resultPtr
operator|->
name|intValue
operator|=
operator|(
name|int
operator|)
name|clientData
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestMathFunc2 --  *  *	This is a user-defined math procedure to test out math procedures  *	that do have arguments, in this case 2.  *  * Results:  *	A normal Tcl completion code.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestMathFunc2
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|args
parameter_list|,
name|resultPtr
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Integer value to return. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used to report errors. */
name|Tcl_Value
modifier|*
name|args
decl_stmt|;
comment|/* Points to an array of two 					 * Tcl_Values for the two 					 * arguments. */
name|Tcl_Value
modifier|*
name|resultPtr
decl_stmt|;
comment|/* Where to store the result. */
block|{
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
comment|/*      * Return the maximum of the two arguments with the correct type.      */
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|type
operator|==
name|TCL_INT
condition|)
block|{
name|int
name|i0
init|=
name|args
index|[
literal|0
index|]
operator|.
name|intValue
decl_stmt|;
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|.
name|type
operator|==
name|TCL_INT
condition|)
block|{
name|int
name|i1
init|=
name|args
index|[
literal|1
index|]
operator|.
name|intValue
decl_stmt|;
name|resultPtr
operator|->
name|type
operator|=
name|TCL_INT
expr_stmt|;
name|resultPtr
operator|->
name|intValue
operator|=
operator|(
operator|(
name|i0
operator|>
name|i1
operator|)
condition|?
name|i0
else|:
name|i1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|.
name|type
operator|==
name|TCL_DOUBLE
condition|)
block|{
name|double
name|d0
init|=
name|i0
decl_stmt|;
name|double
name|d1
init|=
name|args
index|[
literal|1
index|]
operator|.
name|doubleValue
decl_stmt|;
name|resultPtr
operator|->
name|type
operator|=
name|TCL_DOUBLE
expr_stmt|;
name|resultPtr
operator|->
name|doubleValue
operator|=
operator|(
operator|(
name|d0
operator|>
name|d1
operator|)
condition|?
name|d0
else|:
name|d1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"T2: wrong type for arg 2"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|type
operator|==
name|TCL_DOUBLE
condition|)
block|{
name|double
name|d0
init|=
name|args
index|[
literal|0
index|]
operator|.
name|doubleValue
decl_stmt|;
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|.
name|type
operator|==
name|TCL_INT
condition|)
block|{
name|double
name|d1
init|=
name|args
index|[
literal|1
index|]
operator|.
name|intValue
decl_stmt|;
name|resultPtr
operator|->
name|type
operator|=
name|TCL_DOUBLE
expr_stmt|;
name|resultPtr
operator|->
name|doubleValue
operator|=
operator|(
operator|(
name|d0
operator|>
name|d1
operator|)
condition|?
name|d0
else|:
name|d1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|.
name|type
operator|==
name|TCL_DOUBLE
condition|)
block|{
name|double
name|d1
init|=
name|args
index|[
literal|1
index|]
operator|.
name|doubleValue
decl_stmt|;
name|resultPtr
operator|->
name|type
operator|=
name|TCL_DOUBLE
expr_stmt|;
name|resultPtr
operator|->
name|doubleValue
operator|=
operator|(
operator|(
name|d0
operator|>
name|d1
operator|)
condition|?
name|d0
else|:
name|d1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"T2: wrong type for arg 2"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
block|}
else|else
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"T2: wrong type for arg 1"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CleanupTestSetassocdataTests --  *  *	This function is called when an interpreter is deleted to clean  *	up any data left over from running the testsetassocdata command.  *  * Results:  *	None.  *  * Side effects:  *	Releases storage.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|CleanupTestSetassocdataTests
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Data to be released. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter being deleted. */
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|clientData
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestsetassocdataCmd --  *  *	This procedure implements the "testsetassocdata" command. It is used  *	to test Tcl_SetAssocData.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Modifies or creates an association between a key and associated  *	data for this interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestsetassocdataCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|oldData
decl_stmt|;
name|Tcl_InterpDeleteProc
modifier|*
name|procPtr
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" data_key data_item\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|buf
operator|=
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/*      * If we previously associated a malloced value with the variable,      * free it before associating a new value.      */
name|oldData
operator|=
operator|(
name|char
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|procPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oldData
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|procPtr
operator|==
name|CleanupTestSetassocdataTests
operator|)
condition|)
block|{
name|ckfree
argument_list|(
name|oldData
argument_list|)
expr_stmt|;
block|}
name|Tcl_SetAssocData
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|CleanupTestSetassocdataTests
argument_list|,
operator|(
name|ClientData
operator|)
name|buf
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestsetplatformCmd --  *  *	This procedure implements the "testsetplatform" command. It is  *	used to change the tclPlatform global variable so all file  *	name conversions can be tested on a single platform.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Sets the tclPlatform global variable.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestsetplatformCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|size_t
name|length
decl_stmt|;
name|TclPlatformType
modifier|*
name|platform
decl_stmt|;
ifdef|#
directive|ifdef
name|__WIN32__
name|platform
operator|=
name|TclWinGetPlatform
argument_list|()
expr_stmt|;
else|#
directive|else
name|platform
operator|=
operator|&
name|tclPlatform
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" platform\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|length
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"unix"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|platform
operator|=
name|TCL_PLATFORM_UNIX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"mac"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|platform
operator|=
name|TCL_PLATFORM_MAC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"windows"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|platform
operator|=
name|TCL_PLATFORM_WINDOWS
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"unsupported platform: should be one of "
argument_list|,
literal|"unix, mac, or windows"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TeststaticpkgCmd --  *  *	This procedure implements the "teststaticpkg" command.  *	It is used to test the procedure Tcl_StaticPackage.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	When the packge given by argv[1] is loaded into an interpeter,  *	variable "x" in that interpreter is set to "loaded".  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TeststaticpkgCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|safe
decl_stmt|,
name|loaded
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" pkgName safe loaded\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|safe
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
operator|&
name|loaded
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_StaticPackage
argument_list|(
operator|(
name|loaded
operator|)
condition|?
name|interp
else|:
name|NULL
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|StaticInitProc
argument_list|,
operator|(
name|safe
operator|)
condition|?
name|StaticInitProc
else|:
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|StaticInitProc
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which package 					 * is supposedly being loaded. */
block|{
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
literal|"x"
argument_list|,
literal|"loaded"
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TesttranslatefilenameCmd --  *  *	This procedure implements the "testtranslatefilename" command.  *	It is used to test the Tcl_TranslateFileName command.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TesttranslatefilenameCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Tcl_DString
name|buffer
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" path\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|result
operator|=
name|Tcl_TranslateFileName
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|result
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestupvarCmd --  *  *	This procedure implements the "testupvar2" command.  It is used  *	to test Tcl_UpVar and Tcl_UpVar2.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Creates or modifies an "upvar" reference.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestupvarCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|argc
operator|!=
literal|5
operator|)
operator|&&
operator|(
name|argc
operator|!=
literal|6
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" level name ?name2? dest global\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|argc
operator|==
literal|5
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|,
literal|"global"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|flags
operator|=
name|TCL_GLOBAL_ONLY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|,
literal|"namespace"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|flags
operator|=
name|TCL_NAMESPACE_ONLY
expr_stmt|;
block|}
return|return
name|Tcl_UpVar
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
name|flags
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|5
index|]
argument_list|,
literal|"global"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|flags
operator|=
name|TCL_GLOBAL_ONLY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|5
index|]
argument_list|,
literal|"namespace"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|flags
operator|=
name|TCL_NAMESPACE_ONLY
expr_stmt|;
block|}
return|return
name|Tcl_UpVar2
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|(
name|argv
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|==
literal|0
operator|)
condition|?
operator|(
name|char
operator|*
operator|)
name|NULL
else|:
name|argv
index|[
literal|3
index|]
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
name|flags
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestwordendCmd --  *  *	This procedure implements the "testwordend" command.  It is used  *	to test TclWordEnd.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestwordendObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* The argument objects. */
block|{
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|length
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"string"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|objPtr
operator|=
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|string
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|end
operator|=
name|TclWordEnd
argument_list|(
name|string
argument_list|,
name|string
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|objPtr
argument_list|,
name|end
argument_list|,
name|length
operator|-
operator|(
name|end
operator|-
name|string
operator|)
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestsetobjerrorcodeCmd --  *  *	This procedure implements the "testsetobjerrorcodeCmd".  *	This tests up to five elements passed to the  *	Tcl_SetObjErrorCode command.  *  * Results:  *	A standard Tcl result. Always returns TCL_ERROR so that  *	the error code can be tested.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestsetobjerrorcodeCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* The argument objects. */
block|{
name|Tcl_Obj
modifier|*
name|listObjPtr
decl_stmt|;
if|if
condition|(
name|objc
operator|>
literal|1
condition|)
block|{
name|listObjPtr
operator|=
name|Tcl_ConcatObj
argument_list|(
name|objc
operator|-
literal|1
argument_list|,
name|objv
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|listObjPtr
operator|=
name|Tcl_NewObj
argument_list|()
expr_stmt|;
block|}
name|Tcl_IncrRefCount
argument_list|(
name|listObjPtr
argument_list|)
expr_stmt|;
name|Tcl_SetObjErrorCode
argument_list|(
name|interp
argument_list|,
name|listObjPtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|listObjPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestfeventCmd --  *  *	This procedure implements the "testfevent" command.  It is  *	used for testing the "fileevent" command.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Creates and deletes interpreters.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestfeventCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
specifier|static
name|Tcl_Interp
modifier|*
name|interp2
init|=
name|NULL
decl_stmt|;
name|int
name|code
decl_stmt|;
name|Tcl_Channel
name|chan
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" option ?arg arg ...?"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"cmd"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" cmd script"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|interp2
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|code
operator|=
name|Tcl_GlobalEval
argument_list|(
name|interp2
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|interp
operator|->
name|result
operator|=
name|interp2
operator|->
name|result
expr_stmt|;
return|return
name|code
return|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"called \"testfevent code\" before \"testfevent create\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"create"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|interp2
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DeleteInterp
argument_list|(
name|interp2
argument_list|)
expr_stmt|;
block|}
name|interp2
operator|=
name|Tcl_CreateInterp
argument_list|()
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"delete"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|interp2
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DeleteInterp
argument_list|(
name|interp2
argument_list|)
expr_stmt|;
block|}
name|interp2
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"share"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|interp2
operator|!=
name|NULL
condition|)
block|{
name|chan
operator|=
name|Tcl_GetChannel
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_RegisterChannel
argument_list|(
name|interp2
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestPanicCmd --  *  *	Calls the panic routine.  *  * Results:  *      Always returns TCL_OK.   *  * Side effects:  *	May exit application.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestPanicCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|char
modifier|*
name|argString
decl_stmt|;
comment|/*      *  Put the arguments into a var args structure      *  Append all of the arguments together separated by spaces      */
name|argString
operator|=
name|Tcl_Merge
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|)
expr_stmt|;
name|panic
argument_list|(
name|argString
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|argString
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *---------------------------------------------------------------------------  *  * TestchmodCmd --  *  *	Implements the "testchmod" cmd.  Used when testing "file"  *	command.  The only attribute used by the Mac and Windows platforms  *	is the user write flag; if this is not set, the file is  *	made read-only.  Otehrwise, the file is made read-write.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Changes permissions of specified files.  *  *---------------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestchmodCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|i
decl_stmt|,
name|mode
decl_stmt|;
name|char
modifier|*
name|rest
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|usage
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" mode file ?file ...?"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|mode
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|rest
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|rest
operator|!=
literal|'\0'
condition|)
block|{
goto|goto
name|usage
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|Tcl_DString
name|buffer
decl_stmt|;
name|argv
index|[
name|i
index|]
operator|=
name|Tcl_TranslateFileName
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|chmod
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
operator|(
name|unsigned
operator|)
name|mode
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
literal|": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|TestfileCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|force
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|result
decl_stmt|;
name|Tcl_DString
name|error
decl_stmt|,
name|name
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|force
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"-force"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|force
operator|=
literal|1
expr_stmt|;
name|i
operator|=
literal|3
expr_stmt|;
block|}
name|Tcl_DStringInit
argument_list|(
operator|&
name|name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|name
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|-
name|i
operator|>
literal|2
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|argc
condition|;
name|j
operator|++
control|)
block|{
name|argv
index|[
name|j
index|]
operator|=
name|Tcl_TranslateFileName
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|j
index|]
argument_list|,
operator|&
name|name
index|[
name|j
operator|-
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|j
index|]
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"mv"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|TclpRenameFile
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"cp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|TclpCopyFile
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"rm"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|TclpDeleteFile
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"mkdir"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|TclpCreateDirectory
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"cpdir"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|TclpCopyDirectory
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"rmdir"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|TclpRemoveDirectory
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|force
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|Tcl_DStringValue
argument_list|(
operator|&
name|error
argument_list|)
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|error
argument_list|)
argument_list|,
literal|" "
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|Tcl_ErrnoId
argument_list|()
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|end
label|:
name|Tcl_DStringFree
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|name
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestgetvarfullnameCmd --  *  *	Implements the "testgetvarfullname" cmd that is used when testing  *	the Tcl_GetVariableFullName procedure.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestgetvarfullnameCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* The argument objects. */
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|arg
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|Tcl_Namespace
modifier|*
name|namespacePtr
decl_stmt|;
name|Tcl_CallFrame
name|frame
decl_stmt|;
name|Tcl_Var
name|variable
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"name scope"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|name
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|arg
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"global"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|flags
operator|=
name|TCL_GLOBAL_ONLY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"namespace"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|flags
operator|=
name|TCL_NAMESPACE_ONLY
expr_stmt|;
block|}
comment|/*      * This command, like any other created with Tcl_Create[Obj]Command,      * runs in the global namespace. As a "namespace-aware" command that      * needs to run in a particular namespace, it must activate that      * namespace itself.      */
if|if
condition|(
name|flags
operator|==
name|TCL_NAMESPACE_ONLY
condition|)
block|{
name|namespacePtr
operator|=
name|Tcl_FindNamespace
argument_list|(
name|interp
argument_list|,
literal|"::test_ns_var"
argument_list|,
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|namespacePtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|result
operator|=
name|Tcl_PushCallFrame
argument_list|(
name|interp
argument_list|,
operator|&
name|frame
argument_list|,
name|namespacePtr
argument_list|,
comment|/*isProcCallFrame*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
name|variable
operator|=
name|Tcl_FindNamespaceVar
argument_list|(
name|interp
argument_list|,
name|name
argument_list|,
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|flags
operator||
name|TCL_LEAVE_ERR_MSG
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|==
name|TCL_NAMESPACE_ONLY
condition|)
block|{
name|Tcl_PopCallFrame
argument_list|(
name|interp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|variable
operator|==
operator|(
name|Tcl_Var
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_GetVariableFullName
argument_list|(
name|interp
argument_list|,
name|variable
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * GetTimesCmd --  *  *	This procedure implements the "gettimes" command.  It is  *	used for computing the time needed for various basic operations  *	such as reading variables, allocating memory, sprintf, converting  *	variables, etc.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Allocates and frees memory, sets a variable "a" in the interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|GetTimesCmd
parameter_list|(
name|unused
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|unused
decl_stmt|;
comment|/* Unused. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* The number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* The argument strings. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|double
name|timePer
decl_stmt|;
name|Tcl_Time
name|start
decl_stmt|,
name|stop
decl_stmt|;
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|Tcl_Obj
modifier|*
modifier|*
name|objv
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|newString
index|[
literal|30
index|]
decl_stmt|;
comment|/* alloc& free 100000 times */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"alloc& free 100000 6 word items\n"
argument_list|)
expr_stmt|;
name|TclpGetTime
argument_list|(
operator|&
name|start
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100000
condition|;
name|i
operator|++
control|)
block|{
name|objPtr
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Tcl_Obj
argument_list|)
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|objPtr
argument_list|)
expr_stmt|;
block|}
name|TclpGetTime
argument_list|(
operator|&
name|stop
argument_list|)
expr_stmt|;
name|timePer
operator|=
operator|(
name|stop
operator|.
name|sec
operator|-
name|start
operator|.
name|sec
operator|)
operator|*
literal|1000000
operator|+
operator|(
name|stop
operator|.
name|usec
operator|-
name|start
operator|.
name|usec
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   %.3f usec per alloc+free\n"
argument_list|,
name|timePer
operator|/
literal|100000
argument_list|)
expr_stmt|;
comment|/* alloc 5000 times */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"alloc 5000 6 word items\n"
argument_list|)
expr_stmt|;
name|objv
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
literal|5000
operator|*
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|TclpGetTime
argument_list|(
operator|&
name|start
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5000
condition|;
name|i
operator|++
control|)
block|{
name|objv
index|[
name|i
index|]
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Tcl_Obj
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|TclpGetTime
argument_list|(
operator|&
name|stop
argument_list|)
expr_stmt|;
name|timePer
operator|=
operator|(
name|stop
operator|.
name|sec
operator|-
name|start
operator|.
name|sec
operator|)
operator|*
literal|1000000
operator|+
operator|(
name|stop
operator|.
name|usec
operator|-
name|start
operator|.
name|usec
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   %.3f usec per alloc\n"
argument_list|,
name|timePer
operator|/
literal|5000
argument_list|)
expr_stmt|;
comment|/* free 5000 times */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"free 5000 6 word items\n"
argument_list|)
expr_stmt|;
name|TclpGetTime
argument_list|(
operator|&
name|start
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5000
condition|;
name|i
operator|++
control|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|objv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|TclpGetTime
argument_list|(
operator|&
name|stop
argument_list|)
expr_stmt|;
name|timePer
operator|=
operator|(
name|stop
operator|.
name|sec
operator|-
name|start
operator|.
name|sec
operator|)
operator|*
literal|1000000
operator|+
operator|(
name|stop
operator|.
name|usec
operator|-
name|start
operator|.
name|usec
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   %.3f usec per free\n"
argument_list|,
name|timePer
operator|/
literal|5000
argument_list|)
expr_stmt|;
comment|/* Tcl_NewObj 5000 times */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Tcl_NewObj 5000 times\n"
argument_list|)
expr_stmt|;
name|TclpGetTime
argument_list|(
operator|&
name|start
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5000
condition|;
name|i
operator|++
control|)
block|{
name|objv
index|[
name|i
index|]
operator|=
name|Tcl_NewObj
argument_list|()
expr_stmt|;
block|}
name|TclpGetTime
argument_list|(
operator|&
name|stop
argument_list|)
expr_stmt|;
name|timePer
operator|=
operator|(
name|stop
operator|.
name|sec
operator|-
name|start
operator|.
name|sec
operator|)
operator|*
literal|1000000
operator|+
operator|(
name|stop
operator|.
name|usec
operator|-
name|start
operator|.
name|usec
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   %.3f usec per Tcl_NewObj\n"
argument_list|,
name|timePer
operator|/
literal|5000
argument_list|)
expr_stmt|;
comment|/* Tcl_DecrRefCount 5000 times */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Tcl_DecrRefCount 5000 times\n"
argument_list|)
expr_stmt|;
name|TclpGetTime
argument_list|(
operator|&
name|start
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5000
condition|;
name|i
operator|++
control|)
block|{
name|objPtr
operator|=
name|objv
index|[
name|i
index|]
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
name|TclpGetTime
argument_list|(
operator|&
name|stop
argument_list|)
expr_stmt|;
name|timePer
operator|=
operator|(
name|stop
operator|.
name|sec
operator|-
name|start
operator|.
name|sec
operator|)
operator|*
literal|1000000
operator|+
operator|(
name|stop
operator|.
name|usec
operator|-
name|start
operator|.
name|usec
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   %.3f usec per Tcl_DecrRefCount\n"
argument_list|,
name|timePer
operator|/
literal|5000
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|objv
argument_list|)
expr_stmt|;
comment|/* TclGetStringFromObj 100000 times */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"TclGetStringFromObj of \"12345\" 100000 times\n"
argument_list|)
expr_stmt|;
name|objPtr
operator|=
name|Tcl_NewStringObj
argument_list|(
literal|"12345"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|TclpGetTime
argument_list|(
operator|&
name|start
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100000
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|TclGetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
block|}
name|TclpGetTime
argument_list|(
operator|&
name|stop
argument_list|)
expr_stmt|;
name|timePer
operator|=
operator|(
name|stop
operator|.
name|sec
operator|-
name|start
operator|.
name|sec
operator|)
operator|*
literal|1000000
operator|+
operator|(
name|stop
operator|.
name|usec
operator|-
name|start
operator|.
name|usec
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   %.3f usec per TclGetStringFromObj of \"12345\"\n"
argument_list|,
name|timePer
operator|/
literal|100000
argument_list|)
expr_stmt|;
comment|/* Tcl_GetIntFromObj 100000 times */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Tcl_GetIntFromObj of \"12345\" 100000 times\n"
argument_list|)
expr_stmt|;
name|TclpGetTime
argument_list|(
operator|&
name|start
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|objPtr
argument_list|,
operator|&
name|n
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
name|TclpGetTime
argument_list|(
operator|&
name|stop
argument_list|)
expr_stmt|;
name|timePer
operator|=
operator|(
name|stop
operator|.
name|sec
operator|-
name|start
operator|.
name|sec
operator|)
operator|*
literal|1000000
operator|+
operator|(
name|stop
operator|.
name|usec
operator|-
name|start
operator|.
name|usec
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   %.3f usec per Tcl_GetIntFromObj of \"12345\"\n"
argument_list|,
name|timePer
operator|/
literal|100000
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
comment|/* Tcl_GetInt 100000 times */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Tcl_GetInt of \"12345\" 100000 times\n"
argument_list|)
expr_stmt|;
name|TclpGetTime
argument_list|(
operator|&
name|start
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
literal|"12345"
argument_list|,
operator|&
name|n
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
name|TclpGetTime
argument_list|(
operator|&
name|stop
argument_list|)
expr_stmt|;
name|timePer
operator|=
operator|(
name|stop
operator|.
name|sec
operator|-
name|start
operator|.
name|sec
operator|)
operator|*
literal|1000000
operator|+
operator|(
name|stop
operator|.
name|usec
operator|-
name|start
operator|.
name|usec
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   %.3f usec per Tcl_GetInt of \"12345\"\n"
argument_list|,
name|timePer
operator|/
literal|100000
argument_list|)
expr_stmt|;
comment|/* sprintf 100000 times */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sprintf of 12345 100000 times\n"
argument_list|)
expr_stmt|;
name|TclpGetTime
argument_list|(
operator|&
name|start
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100000
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|newString
argument_list|,
literal|"%d"
argument_list|,
literal|12345
argument_list|)
expr_stmt|;
block|}
name|TclpGetTime
argument_list|(
operator|&
name|stop
argument_list|)
expr_stmt|;
name|timePer
operator|=
operator|(
name|stop
operator|.
name|sec
operator|-
name|start
operator|.
name|sec
operator|)
operator|*
literal|1000000
operator|+
operator|(
name|stop
operator|.
name|usec
operator|-
name|start
operator|.
name|usec
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   %.3f usec per sprintf of 12345\n"
argument_list|,
name|timePer
operator|/
literal|100000
argument_list|)
expr_stmt|;
comment|/* hashtable lookup 100000 times */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"hashtable lookup of \"gettimes\" 100000 times\n"
argument_list|)
expr_stmt|;
name|TclpGetTime
argument_list|(
operator|&
name|start
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100000
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|globalNsPtr
operator|->
name|cmdTable
argument_list|,
literal|"gettimes"
argument_list|)
expr_stmt|;
block|}
name|TclpGetTime
argument_list|(
operator|&
name|stop
argument_list|)
expr_stmt|;
name|timePer
operator|=
operator|(
name|stop
operator|.
name|sec
operator|-
name|start
operator|.
name|sec
operator|)
operator|*
literal|1000000
operator|+
operator|(
name|stop
operator|.
name|usec
operator|-
name|start
operator|.
name|usec
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   %.3f usec per hashtable lookup of \"gettimes\"\n"
argument_list|,
name|timePer
operator|/
literal|100000
argument_list|)
expr_stmt|;
comment|/* Tcl_SetVar 100000 times */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Tcl_SetVar of \"12345\" 100000 times\n"
argument_list|)
expr_stmt|;
name|TclpGetTime
argument_list|(
operator|&
name|start
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100000
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
literal|"a"
argument_list|,
literal|"12345"
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
name|TclpGetTime
argument_list|(
operator|&
name|stop
argument_list|)
expr_stmt|;
name|timePer
operator|=
operator|(
name|stop
operator|.
name|sec
operator|-
name|start
operator|.
name|sec
operator|)
operator|*
literal|1000000
operator|+
operator|(
name|stop
operator|.
name|usec
operator|-
name|start
operator|.
name|usec
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   %.3f usec per Tcl_SetVar of a to \"12345\"\n"
argument_list|,
name|timePer
operator|/
literal|100000
argument_list|)
expr_stmt|;
comment|/* Tcl_GetVar 100000 times */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Tcl_GetVar of a==\"12345\" 100000 times\n"
argument_list|)
expr_stmt|;
name|TclpGetTime
argument_list|(
operator|&
name|start
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100000
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|Tcl_GetVar
argument_list|(
name|interp
argument_list|,
literal|"a"
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
name|TclpGetTime
argument_list|(
operator|&
name|stop
argument_list|)
expr_stmt|;
name|timePer
operator|=
operator|(
name|stop
operator|.
name|sec
operator|-
name|start
operator|.
name|sec
operator|)
operator|*
literal|1000000
operator|+
operator|(
name|stop
operator|.
name|usec
operator|-
name|start
operator|.
name|usec
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   %.3f usec per Tcl_GetVar of a==\"12345\"\n"
argument_list|,
name|timePer
operator|/
literal|100000
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * NoopCmd --  *  *	This procedure is just used to time the overhead involved in  *	parsing and invoking a command.  *  * Results:  *	None.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|NoopCmd
parameter_list|(
name|unused
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|unused
decl_stmt|;
comment|/* Unused. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* The number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* The argument strings. */
block|{
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * NoopObjCmd --  *  *	This object-based procedure is just used to time the overhead  *	involved in parsing and invoking a command.  *  * Results:  *	Returns the TCL_OK result code.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|NoopObjCmd
parameter_list|(
name|unused
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|unused
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* The argument objects. */
block|{
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestsetnoerrCmd --  *  *	Implements the "testsetnoerr" cmd that is used when testing  *	the Tcl_Set/GetVar C Api without TCL_LEAVE_ERR_MSG flag  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestsetnoerrCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
specifier|register
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|char
modifier|*
name|value
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"before get"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
name|value
operator|=
name|Tcl_GetVar2
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_PARSE_PART1
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|value
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
block|{
name|char
modifier|*
name|m1
init|=
literal|"before set"
decl_stmt|;
name|char
modifier|*
name|message
init|=
name|Tcl_Alloc
argument_list|(
name|strlen
argument_list|(
name|m1
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|message
argument_list|,
name|m1
argument_list|)
expr_stmt|;
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|message
argument_list|,
name|TCL_DYNAMIC
argument_list|)
expr_stmt|;
name|value
operator|=
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|TCL_PARSE_PART1
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|value
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" varName ?newValue?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
end_function

end_unit

