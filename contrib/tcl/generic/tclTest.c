begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclTest.c --  *  *	This file contains C command procedures for a bunch of additional  *	Tcl commands that are used for testing out Tcl's C interfaces.  *	These commands are not normally included in Tcl applications;  *	they're only used for testing.  *  * Copyright (c) 1993-1994 The Regents of the University of California.  * Copyright (c) 1994-1996 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclTest.c 1.78 96/04/11 14:50:51  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * Declare external functions used in Windows tests.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__WIN32__
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|TclPlatformType
modifier|*
name|TclWinGetPlatform
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Dynamic string shared by TestdcallCmd and DelCallbackProc;  used  * to collect the results of the various deletion callbacks.  */
end_comment

begin_decl_stmt
specifier|static
name|Tcl_DString
name|delString
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Tcl_Interp
modifier|*
name|delInterp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * One of the following structures exists for each asynchronous  * handler created by the "testasync" command".  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|TestAsyncHandler
block|{
name|int
name|id
decl_stmt|;
comment|/* Identifier for this handler. */
name|Tcl_AsyncHandler
name|handler
decl_stmt|;
comment|/* Tcl's token for the handler. */
name|char
modifier|*
name|command
decl_stmt|;
comment|/* Command to invoke when the 					 * handler is invoked. */
name|struct
name|TestAsyncHandler
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next is list of handlers. */
block|}
name|TestAsyncHandler
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|TestAsyncHandler
modifier|*
name|firstHandler
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The dynamic string below is used by the "testdstring" command  * to test the dynamic string facilities.  */
end_comment

begin_decl_stmt
specifier|static
name|Tcl_DString
name|dstring
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * One of the following structures exists for each command created  * by TestdelCmd:  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|DelCmd
block|{
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which command exists. */
name|char
modifier|*
name|deleteCmd
decl_stmt|;
comment|/* Script to execute when command is 				 * deleted.  Malloc'ed. */
block|}
name|DelCmd
typedef|;
end_typedef

begin_comment
comment|/*  * The following structure is used to keep track of modal timeout  * handlers created by the "testmodal" command.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Modal
block|{
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to set variable 				 * "x" when timer fires. */
name|char
modifier|*
name|key
decl_stmt|;
comment|/* Null-terminated string to store in 				 * global variable "x" in interp when 				 * timer fires.  Malloc-ed. */
block|}
name|Modal
typedef|;
end_typedef

begin_comment
comment|/*  * Forward declarations for procedures defined later in this file:  */
end_comment

begin_decl_stmt
name|int
name|Tcltest_Init
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|AsyncHandlerProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|CleanupTestSetassocdataTests
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|CmdDelProc1
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|CmdDelProc2
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CmdProc1
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CmdProc2
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DelCallbackProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DelCmdProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DelDeleteProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ExitProcEven
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ExitProcOdd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ModalTimeoutProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|SpecialFree
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|blockPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|StaticInitProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestasyncCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestcmdinfoCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestcmdtokenCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestdcallCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestdelCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestdelassocdataCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestdstringCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestexithandlerCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestfilewaitCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestgetassocdataCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestgetplatformCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestfhandleCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestinterpdeleteCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestlinkCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestMathFunc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Value
operator|*
name|args
operator|,
name|Tcl_Value
operator|*
name|resultPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestmodalCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestsetassocdataCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestsetplatformCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TeststaticpkgCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TesttranslatefilenameCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestupvarCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestwordendCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestfeventCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestPanicCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * External (platform specific) initialization routine:  */
end_comment

begin_decl_stmt
name|EXTERN
name|int
name|TclplatformtestInit
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcltest_Init --  *  *	This procedure performs application-specific initialization.  *	Most applications, especially those that incorporate additional  *	packages, will have their own version of this procedure.  *  * Results:  *	Returns a standard Tcl completion code, and leaves an error  *	message in interp->result if an error occurs.  *  * Side effects:  *	Depends on the startup script.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcltest_Init
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter for application. */
block|{
if|if
condition|(
name|Tcl_PkgProvide
argument_list|(
name|interp
argument_list|,
literal|"Tcltest"
argument_list|,
literal|"7.5"
argument_list|)
operator|==
name|TCL_ERROR
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Create additional commands and math functions for testing Tcl.      */
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testasync"
argument_list|,
name|TestasyncCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testchannel"
argument_list|,
name|TclTestChannelCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testchannelevent"
argument_list|,
name|TclTestChannelEventCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testcmdtoken"
argument_list|,
name|TestcmdtokenCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testcmdinfo"
argument_list|,
name|TestcmdinfoCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testdcall"
argument_list|,
name|TestdcallCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testdel"
argument_list|,
name|TestdelCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testdelassocdata"
argument_list|,
name|TestdelassocdataCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|dstring
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testdstring"
argument_list|,
name|TestdstringCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testexithandler"
argument_list|,
name|TestexithandlerCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testfhandle"
argument_list|,
name|TestfhandleCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testfilewait"
argument_list|,
name|TestfilewaitCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testgetassocdata"
argument_list|,
name|TestgetassocdataCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testgetplatform"
argument_list|,
name|TestgetplatformCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testinterpdelete"
argument_list|,
name|TestinterpdeleteCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testlink"
argument_list|,
name|TestlinkCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testmodal"
argument_list|,
name|TestmodalCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testsetassocdata"
argument_list|,
name|TestsetassocdataCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testsetplatform"
argument_list|,
name|TestsetplatformCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"teststaticpkg"
argument_list|,
name|TeststaticpkgCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testtranslatefilename"
argument_list|,
name|TesttranslatefilenameCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testupvar"
argument_list|,
name|TestupvarCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testwordend"
argument_list|,
name|TestwordendCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testfevent"
argument_list|,
name|TestfeventCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"testpanic"
argument_list|,
name|TestPanicCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateMathFunc
argument_list|(
name|interp
argument_list|,
literal|"T1"
argument_list|,
literal|0
argument_list|,
operator|(
name|Tcl_ValueType
operator|*
operator|)
name|NULL
argument_list|,
name|TestMathFunc
argument_list|,
operator|(
name|ClientData
operator|)
literal|123
argument_list|)
expr_stmt|;
name|Tcl_CreateMathFunc
argument_list|(
name|interp
argument_list|,
literal|"T2"
argument_list|,
literal|0
argument_list|,
operator|(
name|Tcl_ValueType
operator|*
operator|)
name|NULL
argument_list|,
name|TestMathFunc
argument_list|,
operator|(
name|ClientData
operator|)
literal|345
argument_list|)
expr_stmt|;
comment|/*      * And finally add any platform specific test commands.      */
return|return
name|TclplatformtestInit
argument_list|(
name|interp
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestasyncCmd --  *  *	This procedure implements the "testasync" command.  It is used  *	to test the asynchronous handler facilities of Tcl.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Creates, deletes, and invokes handlers.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestasyncCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|TestAsyncHandler
modifier|*
name|asyncPtr
decl_stmt|,
modifier|*
name|prevPtr
decl_stmt|;
name|int
name|id
decl_stmt|,
name|code
decl_stmt|;
specifier|static
name|int
name|nextId
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|wrongNumArgs
label|:
name|interp
operator|->
name|result
operator|=
literal|"wrong # args"
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"create"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|asyncPtr
operator|=
operator|(
name|TestAsyncHandler
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TestAsyncHandler
argument_list|)
argument_list|)
expr_stmt|;
name|asyncPtr
operator|->
name|id
operator|=
name|nextId
expr_stmt|;
name|nextId
operator|++
expr_stmt|;
name|asyncPtr
operator|->
name|handler
operator|=
name|Tcl_AsyncCreate
argument_list|(
name|AsyncHandlerProc
argument_list|,
operator|(
name|ClientData
operator|)
name|asyncPtr
argument_list|)
expr_stmt|;
name|asyncPtr
operator|->
name|command
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|asyncPtr
operator|->
name|command
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|asyncPtr
operator|->
name|nextPtr
operator|=
name|firstHandler
expr_stmt|;
name|firstHandler
operator|=
name|asyncPtr
expr_stmt|;
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"%d"
argument_list|,
name|asyncPtr
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"delete"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
while|while
condition|(
name|firstHandler
operator|!=
name|NULL
condition|)
block|{
name|asyncPtr
operator|=
name|firstHandler
expr_stmt|;
name|firstHandler
operator|=
name|asyncPtr
operator|->
name|nextPtr
expr_stmt|;
name|Tcl_AsyncDelete
argument_list|(
name|asyncPtr
operator|->
name|handler
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|asyncPtr
operator|->
name|command
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|asyncPtr
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|id
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
for|for
control|(
name|prevPtr
operator|=
name|NULL
operator|,
name|asyncPtr
operator|=
name|firstHandler
init|;
name|asyncPtr
operator|!=
name|NULL
condition|;
name|prevPtr
operator|=
name|asyncPtr
operator|,
name|asyncPtr
operator|=
name|asyncPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|asyncPtr
operator|->
name|id
operator|!=
name|id
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|prevPtr
operator|==
name|NULL
condition|)
block|{
name|firstHandler
operator|=
name|asyncPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
name|prevPtr
operator|->
name|nextPtr
operator|=
name|asyncPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
name|Tcl_AsyncDelete
argument_list|(
name|asyncPtr
operator|->
name|handler
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|asyncPtr
operator|->
name|command
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|asyncPtr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"mark"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|5
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
operator|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|id
argument_list|)
operator|!=
name|TCL_OK
operator|)
operator|||
operator|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
operator|&
name|code
argument_list|)
operator|!=
name|TCL_OK
operator|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
for|for
control|(
name|asyncPtr
operator|=
name|firstHandler
init|;
name|asyncPtr
operator|!=
name|NULL
condition|;
name|asyncPtr
operator|=
name|asyncPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|asyncPtr
operator|->
name|id
operator|==
name|id
condition|)
block|{
name|Tcl_AsyncMark
argument_list|(
name|asyncPtr
operator|->
name|handler
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": must be create, delete, int, or mark"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|AsyncHandlerProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|code
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Pointer to TestAsyncHandler structure. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which command was 				 * executed, or NULL. */
name|int
name|code
decl_stmt|;
comment|/* Current return code from command. */
block|{
name|TestAsyncHandler
modifier|*
name|asyncPtr
init|=
operator|(
name|TestAsyncHandler
operator|*
operator|)
name|clientData
decl_stmt|;
name|char
modifier|*
name|listArgv
index|[
literal|4
index|]
decl_stmt|;
name|char
name|string
index|[
literal|20
index|]
decl_stmt|,
modifier|*
name|cmd
decl_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%d"
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|listArgv
index|[
literal|0
index|]
operator|=
name|asyncPtr
operator|->
name|command
expr_stmt|;
name|listArgv
index|[
literal|1
index|]
operator|=
name|interp
operator|->
name|result
expr_stmt|;
name|listArgv
index|[
literal|2
index|]
operator|=
name|string
expr_stmt|;
name|listArgv
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|cmd
operator|=
name|Tcl_Merge
argument_list|(
literal|3
argument_list|,
name|listArgv
argument_list|)
expr_stmt|;
name|code
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestcmdinfoCmd --  *  *	This procedure implements the "testcmdinfo" command.  It is used  *	to test Tcl_GetCommandInfo, Tcl_SetCommandInfo, and command creation  *	and deletion.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Creates and deletes various commands and modifies their data.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestcmdinfoCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Tcl_CmdInfo
name|info
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" option cmdName\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"create"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|CmdProc1
argument_list|,
operator|(
name|ClientData
operator|)
literal|"original"
argument_list|,
name|CmdDelProc1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"delete"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_DStringInit
argument_list|(
operator|&
name|delString
argument_list|)
expr_stmt|;
name|Tcl_DeleteCommand
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|Tcl_DStringResult
argument_list|(
name|interp
argument_list|,
operator|&
name|delString
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"get"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|Tcl_GetCommandInfo
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|info
argument_list|)
operator|==
literal|0
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"??"
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|info
operator|.
name|proc
operator|==
name|CmdProc1
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"CmdProc1"
argument_list|,
literal|" "
argument_list|,
operator|(
name|char
operator|*
operator|)
name|info
operator|.
name|clientData
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|.
name|proc
operator|==
name|CmdProc2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"CmdProc2"
argument_list|,
literal|" "
argument_list|,
operator|(
name|char
operator|*
operator|)
name|info
operator|.
name|clientData
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"unknown"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|.
name|deleteProc
operator|==
name|CmdDelProc1
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|" CmdDelProc1"
argument_list|,
literal|" "
argument_list|,
operator|(
name|char
operator|*
operator|)
name|info
operator|.
name|deleteData
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|.
name|deleteProc
operator|==
name|CmdDelProc2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|" CmdDelProc2"
argument_list|,
literal|" "
argument_list|,
operator|(
name|char
operator|*
operator|)
name|info
operator|.
name|deleteData
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|" unknown"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"modify"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|info
operator|.
name|proc
operator|=
name|CmdProc2
expr_stmt|;
name|info
operator|.
name|clientData
operator|=
operator|(
name|ClientData
operator|)
literal|"new_command_data"
expr_stmt|;
name|info
operator|.
name|deleteProc
operator|=
name|CmdDelProc2
expr_stmt|;
name|info
operator|.
name|deleteData
operator|=
operator|(
name|ClientData
operator|)
literal|"new_delete_data"
expr_stmt|;
if|if
condition|(
name|Tcl_SetCommandInfo
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|info
argument_list|)
operator|==
literal|0
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"0"
expr_stmt|;
block|}
else|else
block|{
name|interp
operator|->
name|result
operator|=
literal|"1"
expr_stmt|;
block|}
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": must be create, delete, get, or modify"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|CmdProc1
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* String to return. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"CmdProc1 "
argument_list|,
operator|(
name|char
operator|*
operator|)
name|clientData
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|CmdProc2
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* String to return. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"CmdProc2 "
argument_list|,
operator|(
name|char
operator|*
operator|)
name|clientData
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|CmdDelProc1
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* String to save. */
block|{
name|Tcl_DStringInit
argument_list|(
operator|&
name|delString
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|delString
argument_list|,
literal|"CmdDelProc1 "
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|delString
argument_list|,
operator|(
name|char
operator|*
operator|)
name|clientData
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|CmdDelProc2
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* String to save. */
block|{
name|Tcl_DStringInit
argument_list|(
operator|&
name|delString
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|delString
argument_list|,
literal|"CmdDelProc2 "
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|delString
argument_list|,
operator|(
name|char
operator|*
operator|)
name|clientData
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestcmdtokenCmd --  *  *	This procedure implements the "testcmdtoken" command.  It is used  *	to test Tcl_Command tokens and Tcl_GetCommandName.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Creates and deletes various commands and modifies their data.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestcmdtokenCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Tcl_Command
name|token
decl_stmt|;
name|long
name|int
name|l
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" option arg\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"create"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|token
operator|=
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|CmdProc1
argument_list|,
operator|(
name|ClientData
operator|)
literal|"original"
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"%lx"
argument_list|,
operator|(
name|long
name|int
operator|)
name|token
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"name"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"%lx"
argument_list|,
operator|&
name|l
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad command token \""
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|interp
operator|->
name|result
operator|=
name|Tcl_GetCommandName
argument_list|(
name|interp
argument_list|,
operator|(
name|Tcl_Command
operator|)
name|l
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": must be create or name"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestdcallCmd --  *  *	This procedure implements the "testdcall" command.  It is used  *	to test Tcl_CallWhenDeleted.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Creates and deletes interpreters.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestdcallCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|i
decl_stmt|,
name|id
decl_stmt|;
name|delInterp
operator|=
name|Tcl_CreateInterp
argument_list|()
expr_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|delString
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
operator|&
name|id
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|id
operator|<
literal|0
condition|)
block|{
name|Tcl_DontCallWhenDeleted
argument_list|(
name|delInterp
argument_list|,
name|DelCallbackProc
argument_list|,
call|(
name|ClientData
call|)
argument_list|(
operator|-
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_CallWhenDeleted
argument_list|(
name|delInterp
argument_list|,
name|DelCallbackProc
argument_list|,
operator|(
name|ClientData
operator|)
name|id
argument_list|)
expr_stmt|;
block|}
block|}
name|Tcl_DeleteInterp
argument_list|(
name|delInterp
argument_list|)
expr_stmt|;
name|Tcl_DStringResult
argument_list|(
name|interp
argument_list|,
operator|&
name|delString
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * The deletion callback used by TestdcallCmd:  */
end_comment

begin_function
specifier|static
name|void
name|DelCallbackProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Numerical value to append to 					 * delString. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter being deleted. */
block|{
name|int
name|id
init|=
operator|(
name|int
operator|)
name|clientData
decl_stmt|;
name|char
name|buffer
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
operator|&
name|delString
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|interp
operator|!=
name|delInterp
condition|)
block|{
name|Tcl_DStringAppendElement
argument_list|(
operator|&
name|delString
argument_list|,
literal|"bogus interpreter argument!"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestdelCmd --  *  *	This procedure implements the "testdcall" command.  It is used  *	to test Tcl_CallWhenDeleted.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Creates and deletes interpreters.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestdelCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|DelCmd
modifier|*
name|dPtr
decl_stmt|;
name|Tcl_Interp
modifier|*
name|slave
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"wrong # args"
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|slave
operator|=
name|Tcl_GetSlave
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|slave
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|dPtr
operator|=
operator|(
name|DelCmd
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DelCmd
argument_list|)
argument_list|)
expr_stmt|;
name|dPtr
operator|->
name|interp
operator|=
name|interp
expr_stmt|;
name|dPtr
operator|->
name|deleteCmd
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dPtr
operator|->
name|deleteCmd
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|slave
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|DelCmdProc
argument_list|,
operator|(
name|ClientData
operator|)
name|dPtr
argument_list|,
name|DelDeleteProc
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|DelCmdProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* String result to return. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|DelCmd
modifier|*
name|dPtr
init|=
operator|(
name|DelCmd
operator|*
operator|)
name|clientData
decl_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|dPtr
operator|->
name|deleteCmd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|dPtr
operator|->
name|deleteCmd
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|DelDeleteProc
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* String command to evaluate. */
block|{
name|DelCmd
modifier|*
name|dPtr
init|=
operator|(
name|DelCmd
operator|*
operator|)
name|clientData
decl_stmt|;
name|Tcl_Eval
argument_list|(
name|dPtr
operator|->
name|interp
argument_list|,
name|dPtr
operator|->
name|deleteCmd
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|dPtr
operator|->
name|interp
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|dPtr
operator|->
name|deleteCmd
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestdelassocdataCmd --  *  *	This procedure implements the "testdelassocdata" command. It is used  *	to test Tcl_DeleteAssocData.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Deletes an association between a key and associated data from an  *	interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestdelassocdataCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" data_key\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_DeleteAssocData
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestdstringCmd --  *  *	This procedure implements the "testdstring" command.  It is used  *	to test the dynamic string facilities of Tcl.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Creates, deletes, and invokes handlers.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestdstringCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|count
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|wrongNumArgs
label|:
name|interp
operator|->
name|result
operator|=
literal|"wrong # args"
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"append"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
operator|&
name|count
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_DStringAppend
argument_list|(
operator|&
name|dstring
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"element"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|Tcl_DStringAppendElement
argument_list|(
operator|&
name|dstring
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"end"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|Tcl_DStringEndSublist
argument_list|(
operator|&
name|dstring
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"free"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|Tcl_DStringFree
argument_list|(
operator|&
name|dstring
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"get"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|interp
operator|->
name|result
operator|=
name|Tcl_DStringValue
argument_list|(
operator|&
name|dstring
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"gresult"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"staticsmall"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"short"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"staticlarge"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"first0 first1 first2 first3 first4 first5 first6 first7 first8 first9\nsecond0 second1 second2 second3 second4 second5 second6 second7 second8 second9\nthird0 third1 third2 third3 third4 third5 third6 third7 third8 third9\nfourth0 fourth1 fourth2 fourth3 fourth4 fourth5 fourth6 fourth7 fourth8 fourth9\nfifth0 fifth1 fifth2 fifth3 fifth4 fifth5 fifth6 fifth7 fifth8 fifth9\nsixth0 sixth1 sixth2 sixth3 sixth4 sixth5 sixth6 sixth7 sixth8 sixth9\nseventh0 seventh1 seventh2 seventh3 seventh4 seventh5 seventh6 seventh7 seventh8 seventh9\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"free"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|interp
operator|->
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|interp
operator|->
name|freeProc
operator|=
name|TCL_DYNAMIC
expr_stmt|;
name|strcpy
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"This is a malloc-ed string"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"special"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|interp
operator|->
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|interp
operator|->
name|result
operator|+=
literal|4
expr_stmt|;
name|interp
operator|->
name|freeProc
operator|=
name|SpecialFree
expr_stmt|;
name|strcpy
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"This is a specially-allocated string"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad gresult option \""
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"\": must be staticsmall, staticlarge, free, or special"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_DStringGetResult
argument_list|(
name|interp
argument_list|,
operator|&
name|dstring
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"length"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"%d"
argument_list|,
name|Tcl_DStringLength
argument_list|(
operator|&
name|dstring
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"result"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|Tcl_DStringResult
argument_list|(
name|interp
argument_list|,
operator|&
name|dstring
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"trunc"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|count
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_DStringTrunc
argument_list|(
operator|&
name|dstring
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"start"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|Tcl_DStringStartSublist
argument_list|(
operator|&
name|dstring
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": must be append, element, end, free, get, length, "
argument_list|,
literal|"result, trunc, or start"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * The procedure below is used as a special freeProc to test how well  * Tcl_DStringGetResult handles freeProc's other than free.  */
end_comment

begin_function
specifier|static
name|void
name|SpecialFree
parameter_list|(
name|blockPtr
parameter_list|)
name|char
modifier|*
name|blockPtr
decl_stmt|;
comment|/* Block to free. */
block|{
name|ckfree
argument_list|(
name|blockPtr
operator|-
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestexithandlerCmd --  *  *	This procedure implements the "testexithandler" command. It is  *	used to test Tcl_CreateExitHandler and Tcl_DeleteExitHandler.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestexithandlerCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|value
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" create|delete value\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|value
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"create"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_CreateExitHandler
argument_list|(
operator|(
name|value
operator|&
literal|1
operator|)
condition|?
name|ExitProcOdd
else|:
name|ExitProcEven
argument_list|,
operator|(
name|ClientData
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"delete"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_DeleteExitHandler
argument_list|(
operator|(
name|value
operator|&
literal|1
operator|)
condition|?
name|ExitProcOdd
else|:
name|ExitProcEven
argument_list|,
operator|(
name|ClientData
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": must be create or delete"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ExitProcOdd
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Integer value to print. */
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"odd %d\n"
argument_list|,
operator|(
name|int
operator|)
name|clientData
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|1
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ExitProcEven
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Integer value to print. */
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"even %d\n"
argument_list|,
operator|(
name|int
operator|)
name|clientData
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|1
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestfhandleCmd --  *  *	This procedure implements the "testfhandle" command.  It is  *	used to test Tcl_GetFile, Tcl_FreeFile, and  *	Tcl_GetFileInfo.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestfhandleCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
define|#
directive|define
name|MAX_FHANDLES
value|10
specifier|static
name|Tcl_File
name|testHandles
index|[
name|MAX_FHANDLES
index|]
decl_stmt|;
specifier|static
name|initialized
operator|=
literal|0
expr_stmt|;
name|int
name|i
decl_stmt|,
name|index
decl_stmt|,
name|type
decl_stmt|;
name|ClientData
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_FHANDLES
condition|;
name|i
operator|++
control|)
block|{
name|testHandles
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" option ... \""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|index
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|argc
operator|>=
literal|3
condition|)
block|{
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|index
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|index
operator|>=
name|MAX_FHANDLES
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad index "
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"compare"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|index2
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" index index\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|index2
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|testHandles
index|[
name|index
index|]
operator|==
name|testHandles
index|[
name|index2
index|]
condition|)
block|{
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"equal"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"notequal"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"get"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|5
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" index data type\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|data
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
operator|&
name|type
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|testHandles
index|[
name|index
index|]
operator|=
name|Tcl_GetFile
argument_list|(
name|data
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"free"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" index\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_FreeFile
argument_list|(
name|testHandles
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"info1"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" index\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|data
operator|=
name|Tcl_GetFileInfo
argument_list|(
name|testHandles
index|[
name|index
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"info2"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" index\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|data
operator|=
name|Tcl_GetFileInfo
argument_list|(
name|testHandles
index|[
name|index
index|]
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"%d %d"
argument_list|,
operator|(
name|int
operator|)
name|data
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": must be compare, get, free, info1, or info2"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestfilewaitCmd --  *  *	This procedure implements the "testfilewait" command. It is  *	used to test TclWaitForFile.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestfilewaitCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|mask
decl_stmt|,
name|result
decl_stmt|,
name|timeout
decl_stmt|;
name|Tcl_Channel
name|channel
decl_stmt|;
name|Tcl_File
name|file
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" file readable|writable|both timeout\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|channel
operator|=
name|Tcl_GetChannel
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"readable"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mask
operator|=
name|TCL_READABLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"writable"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mask
operator|=
name|TCL_WRITABLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"both"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mask
operator|=
name|TCL_WRITABLE
operator||
name|TCL_READABLE
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad argument \""
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"\": must be readable, writable, or both"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|file
operator|=
name|Tcl_GetChannelFile
argument_list|(
name|channel
argument_list|,
operator|(
name|mask
operator|&
name|TCL_READABLE
operator|)
condition|?
name|TCL_READABLE
else|:
name|TCL_WRITABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"couldn't get channel file"
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
operator|&
name|timeout
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|result
operator|=
name|TclWaitForFile
argument_list|(
name|file
argument_list|,
name|mask
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|&
name|TCL_READABLE
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"readable"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|&
name|TCL_WRITABLE
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"writable"
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestgetassocdataCmd --  *  *	This procedure implements the "testgetassocdata" command. It is  *	used to test Tcl_GetAssocData.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestgetassocdataCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|char
modifier|*
name|res
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" data_key\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|res
operator|=
operator|(
name|char
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|res
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestgetplatformCmd --  *  *	This procedure implements the "testgetplatform" command. It is  *	used to retrievel the value of the tclPlatform global variable.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestgetplatformCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
specifier|static
name|char
modifier|*
name|platformStrings
index|[]
init|=
block|{
literal|"unix"
block|,
literal|"mac"
block|,
literal|"windows"
block|}
decl_stmt|;
name|TclPlatformType
modifier|*
name|platform
decl_stmt|;
ifdef|#
directive|ifdef
name|__WIN32__
name|platform
operator|=
name|TclWinGetPlatform
argument_list|()
expr_stmt|;
else|#
directive|else
name|platform
operator|=
operator|&
name|tclPlatform
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|platformStrings
index|[
operator|*
name|platform
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestinterpdeleteCmd --  *  *	This procedure tests the code in tclInterp.c that deals with  *	interpreter deletion. It deletes a user-specified interpreter  *	from the hierarchy, and subsequent code checks integrity.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Deletes one or more interpreters.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestinterpdeleteCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Tcl_Interp
modifier|*
name|slaveToDelete
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" path\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"cannot delete current interpreter"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|slaveToDelete
operator|=
name|Tcl_GetSlave
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|slaveToDelete
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"could not find interpreter \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_DeleteInterp
argument_list|(
name|slaveToDelete
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestlinkCmd --  *  *	This procedure implements the "testlink" command.  It is used  *	to test Tcl_LinkVar and related library procedures.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Creates and deletes various variable links, plus returns  *	values of the linked variables.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestlinkCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
specifier|static
name|int
name|intVar
init|=
literal|43
decl_stmt|;
specifier|static
name|int
name|boolVar
init|=
literal|4
decl_stmt|;
specifier|static
name|double
name|realVar
init|=
literal|1.23
decl_stmt|;
specifier|static
name|char
modifier|*
name|stringVar
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|created
init|=
literal|0
decl_stmt|;
name|char
name|buffer
index|[
name|TCL_DOUBLE_SPACE
index|]
decl_stmt|;
name|int
name|writable
decl_stmt|,
name|flag
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" option ?arg arg arg?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"create"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|created
condition|)
block|{
name|Tcl_UnlinkVar
argument_list|(
name|interp
argument_list|,
literal|"int"
argument_list|)
expr_stmt|;
name|Tcl_UnlinkVar
argument_list|(
name|interp
argument_list|,
literal|"real"
argument_list|)
expr_stmt|;
name|Tcl_UnlinkVar
argument_list|(
name|interp
argument_list|,
literal|"bool"
argument_list|)
expr_stmt|;
name|Tcl_UnlinkVar
argument_list|(
name|interp
argument_list|,
literal|"string"
argument_list|)
expr_stmt|;
block|}
name|created
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|Tcl_GetBoolean
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|writable
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|flag
operator|=
operator|(
name|writable
operator|!=
literal|0
operator|)
condition|?
literal|0
else|:
name|TCL_LINK_READ_ONLY
expr_stmt|;
if|if
condition|(
name|Tcl_LinkVar
argument_list|(
name|interp
argument_list|,
literal|"int"
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|intVar
argument_list|,
name|TCL_LINK_INT
operator||
name|flag
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetBoolean
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
operator|&
name|writable
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|flag
operator|=
operator|(
name|writable
operator|!=
literal|0
operator|)
condition|?
literal|0
else|:
name|TCL_LINK_READ_ONLY
expr_stmt|;
if|if
condition|(
name|Tcl_LinkVar
argument_list|(
name|interp
argument_list|,
literal|"real"
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|realVar
argument_list|,
name|TCL_LINK_DOUBLE
operator||
name|flag
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetBoolean
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
operator|&
name|writable
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|flag
operator|=
operator|(
name|writable
operator|!=
literal|0
operator|)
condition|?
literal|0
else|:
name|TCL_LINK_READ_ONLY
expr_stmt|;
if|if
condition|(
name|Tcl_LinkVar
argument_list|(
name|interp
argument_list|,
literal|"bool"
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|boolVar
argument_list|,
name|TCL_LINK_BOOLEAN
operator||
name|flag
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetBoolean
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|5
index|]
argument_list|,
operator|&
name|writable
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|flag
operator|=
operator|(
name|writable
operator|!=
literal|0
operator|)
condition|?
literal|0
else|:
name|TCL_LINK_READ_ONLY
expr_stmt|;
if|if
condition|(
name|Tcl_LinkVar
argument_list|(
name|interp
argument_list|,
literal|"string"
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|stringVar
argument_list|,
name|TCL_LINK_STRING
operator||
name|flag
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"delete"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_UnlinkVar
argument_list|(
name|interp
argument_list|,
literal|"int"
argument_list|)
expr_stmt|;
name|Tcl_UnlinkVar
argument_list|(
name|interp
argument_list|,
literal|"real"
argument_list|)
expr_stmt|;
name|Tcl_UnlinkVar
argument_list|(
name|interp
argument_list|,
literal|"bool"
argument_list|)
expr_stmt|;
name|Tcl_UnlinkVar
argument_list|(
name|interp
argument_list|,
literal|"string"
argument_list|)
expr_stmt|;
name|created
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"get"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|intVar
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|Tcl_PrintDouble
argument_list|(
name|interp
argument_list|,
name|realVar
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|boolVar
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
operator|(
name|stringVar
operator|==
name|NULL
operator|)
condition|?
literal|"-"
else|:
name|stringVar
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"set"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|6
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" "
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"intValue realValue boolValue stringValue\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|intVar
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
if|if
condition|(
name|argv
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Tcl_GetDouble
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
operator|&
name|realVar
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
if|if
condition|(
name|argv
index|[
literal|4
index|]
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
operator|&
name|boolVar
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
if|if
condition|(
name|argv
index|[
literal|5
index|]
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|stringVar
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|stringVar
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|5
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|stringVar
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|stringVar
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
literal|5
index|]
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|stringVar
argument_list|,
name|argv
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"update"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|6
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" "
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"intValue realValue boolValue stringValue\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|intVar
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_UpdateLinkedVar
argument_list|(
name|interp
argument_list|,
literal|"int"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argv
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Tcl_GetDouble
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
operator|&
name|realVar
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_UpdateLinkedVar
argument_list|(
name|interp
argument_list|,
literal|"real"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argv
index|[
literal|4
index|]
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
operator|&
name|boolVar
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_UpdateLinkedVar
argument_list|(
name|interp
argument_list|,
literal|"bool"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argv
index|[
literal|5
index|]
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|stringVar
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|stringVar
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|5
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|stringVar
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|stringVar
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
literal|5
index|]
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|stringVar
argument_list|,
name|argv
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
name|Tcl_UpdateLinkedVar
argument_list|(
name|interp
argument_list|,
literal|"string"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": should be create, delete, get, set, or update"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestMathFunc --  *  *	This is a user-defined math procedure to test out math procedures  *	with no arguments.  *  * Results:  *	A normal Tcl completion code.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestMathFunc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|args
parameter_list|,
name|resultPtr
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Integer value to return. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Not used. */
name|Tcl_Value
modifier|*
name|args
decl_stmt|;
comment|/* Not used. */
name|Tcl_Value
modifier|*
name|resultPtr
decl_stmt|;
comment|/* Where to store result. */
block|{
name|resultPtr
operator|->
name|type
operator|=
name|TCL_INT
expr_stmt|;
name|resultPtr
operator|->
name|intValue
operator|=
operator|(
name|int
operator|)
name|clientData
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CleanupTestSetassocdataTests --  *  *	This function is called when an interpreter is deleted to clean  *	up any data left over from running the testsetassocdata command.  *  * Results:  *	None.  *  * Side effects:  *	Releases storage.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|CleanupTestSetassocdataTests
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Data to be released. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter being deleted. */
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|clientData
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestmodalCmd --  *  *	This procedure implements the "testmodal" command. It is used  *	to test modal timeouts created by Tcl_CreateModalTimeout.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Modifies or creates an association between a key and associated  *	data for this interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestmodalCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
define|#
directive|define
name|NUM_MODALS
value|10
specifier|static
name|Modal
name|modals
index|[
name|NUM_MODALS
index|]
decl_stmt|;
specifier|static
name|int
name|numModals
init|=
literal|0
decl_stmt|;
name|int
name|ms
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" option ?arg arg ...?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"create"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" create ms key\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|numModals
operator|>=
name|NUM_MODALS
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"too many modal timeouts"
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|ms
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|modals
index|[
name|numModals
index|]
operator|.
name|interp
operator|=
name|interp
expr_stmt|;
name|modals
index|[
name|numModals
index|]
operator|.
name|key
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|modals
index|[
name|numModals
index|]
operator|.
name|key
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|Tcl_CreateModalTimeout
argument_list|(
name|ms
argument_list|,
name|ModalTimeoutProc
argument_list|,
operator|(
name|ClientData
operator|)
operator|&
name|modals
index|[
name|numModals
index|]
argument_list|)
expr_stmt|;
name|numModals
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"delete"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|numModals
operator|==
literal|0
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"no more modal timeouts"
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|numModals
operator|-=
literal|1
expr_stmt|;
name|ckfree
argument_list|(
name|modals
index|[
name|numModals
index|]
operator|.
name|key
argument_list|)
expr_stmt|;
name|Tcl_DeleteModalTimeout
argument_list|(
name|ModalTimeoutProc
argument_list|,
operator|(
name|ClientData
operator|)
operator|&
name|modals
index|[
name|numModals
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"event"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_DoOneEvent
argument_list|(
name|TCL_TIMER_EVENTS
operator||
name|TCL_DONT_WAIT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"eventnotimers"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_DoOneEvent
argument_list|(
literal|0x100000
operator||
name|TCL_DONT_WAIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": must be create, delete, event, or eventnotimers"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ModalTimeoutProc
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Pointer to Modal structure. */
block|{
name|Modal
modifier|*
name|modalPtr
init|=
operator|(
name|Modal
operator|*
operator|)
name|clientData
decl_stmt|;
name|Tcl_SetVar
argument_list|(
name|modalPtr
operator|->
name|interp
argument_list|,
literal|"x"
argument_list|,
name|modalPtr
operator|->
name|key
argument_list|,
name|TCL_GLOBAL_ONLY
operator||
name|TCL_APPEND_VALUE
operator||
name|TCL_LIST_ELEMENT
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestsetassocdataCmd --  *  *	This procedure implements the "testsetassocdata" command. It is used  *	to test Tcl_SetAssocData.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Modifies or creates an association between a key and associated  *	data for this interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestsetassocdataCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" data_key data_item\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|buf
operator|=
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|Tcl_SetAssocData
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|CleanupTestSetassocdataTests
argument_list|,
operator|(
name|ClientData
operator|)
name|buf
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestsetplatformCmd --  *  *	This procedure implements the "testsetplatform" command. It is  *	used to change the tclPlatform global variable so all file  *	name conversions can be tested on a single platform.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Sets the tclPlatform global variable.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestsetplatformCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|size_t
name|length
decl_stmt|;
name|TclPlatformType
modifier|*
name|platform
decl_stmt|;
ifdef|#
directive|ifdef
name|__WIN32__
name|platform
operator|=
name|TclWinGetPlatform
argument_list|()
expr_stmt|;
else|#
directive|else
name|platform
operator|=
operator|&
name|tclPlatform
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" platform\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|length
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"unix"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|platform
operator|=
name|TCL_PLATFORM_UNIX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"mac"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|platform
operator|=
name|TCL_PLATFORM_MAC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"windows"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|platform
operator|=
name|TCL_PLATFORM_WINDOWS
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"unsupported platform: should be one of "
argument_list|,
literal|"unix, mac, or windows"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TeststaticpkgCmd --  *  *	This procedure implements the "teststaticpkg" command.  *	It is used to test the procedure Tcl_StaticPackage.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	When the packge given by argv[1] is loaded into an interpeter,  *	variable "x" in that interpreter is set to "loaded".  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TeststaticpkgCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|safe
decl_stmt|,
name|loaded
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" pkgName safe loaded\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|safe
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
operator|&
name|loaded
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_StaticPackage
argument_list|(
operator|(
name|loaded
operator|)
condition|?
name|interp
else|:
name|NULL
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|StaticInitProc
argument_list|,
operator|(
name|safe
operator|)
condition|?
name|StaticInitProc
else|:
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|StaticInitProc
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which package 					 * is supposedly being loaded. */
block|{
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
literal|"x"
argument_list|,
literal|"loaded"
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TesttranslatefilenameCmd --  *  *	This procedure implements the "testtranslatefilename" command.  *	It is used to test the Tcl_TranslateFileName command.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TesttranslatefilenameCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Tcl_DString
name|buffer
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" path\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|result
operator|=
name|Tcl_TranslateFileName
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|result
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestupvarCmd --  *  *	This procedure implements the "testupvar2" command.  It is used  *	to test Tcl_UpVar and Tcl_UpVar2.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Creates or modifies an "upvar" reference.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestupvarCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
if|if
condition|(
operator|(
name|argc
operator|!=
literal|5
operator|)
operator|&&
operator|(
name|argc
operator|!=
literal|6
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" level name ?name2? dest global\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|argc
operator|==
literal|5
condition|)
block|{
return|return
name|Tcl_UpVar
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
operator|(
name|strcmp
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|,
literal|"global"
argument_list|)
operator|==
literal|0
operator|)
condition|?
name|TCL_GLOBAL_ONLY
else|:
literal|0
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Tcl_UpVar2
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|(
name|argv
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|==
literal|0
operator|)
condition|?
operator|(
name|char
operator|*
operator|)
name|NULL
else|:
name|argv
index|[
literal|3
index|]
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
operator|(
name|strcmp
argument_list|(
name|argv
index|[
literal|5
index|]
argument_list|,
literal|"global"
argument_list|)
operator|==
literal|0
operator|)
condition|?
name|TCL_GLOBAL_ONLY
else|:
literal|0
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestwordendCmd --  *  *	This procedure implements the "testwordend" command.  It is used  *	to test TclWordEnd.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestwordendCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # arguments: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" string\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|TclWordEnd
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestfeventCmd --  *  *	This procedure implements the "testfevent" command.  It is  *	used for testing the "fileevent" command.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Creates and deletes interpreters.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TestfeventCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
specifier|static
name|Tcl_Interp
modifier|*
name|interp2
init|=
name|NULL
decl_stmt|;
name|int
name|code
decl_stmt|;
name|Tcl_Channel
name|chan
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" option ?arg arg ...?"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"cmd"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" cmd script"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|interp2
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|code
operator|=
name|Tcl_GlobalEval
argument_list|(
name|interp2
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|interp
operator|->
name|result
operator|=
name|interp2
operator|->
name|result
expr_stmt|;
return|return
name|code
return|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"called \"testfevent code\" before \"testfevent create\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"create"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|interp2
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DeleteInterp
argument_list|(
name|interp2
argument_list|)
expr_stmt|;
block|}
name|interp2
operator|=
name|Tcl_CreateInterp
argument_list|()
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"delete"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|interp2
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DeleteInterp
argument_list|(
name|interp2
argument_list|)
expr_stmt|;
block|}
name|interp2
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"share"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|interp2
operator|!=
name|NULL
condition|)
block|{
name|chan
operator|=
name|Tcl_GetChannel
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_RegisterChannel
argument_list|(
name|interp2
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestPanicCmd --  *  *	Calls the panic routine.  *  * Results:  *      Always returns TCL_OK.   *  * Side effects:  *	May exit application.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestPanicCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|char
modifier|*
name|argString
decl_stmt|;
comment|/*      *  Put the arguments into a var args structure      *  Append all of the arguments together separated by spaces      */
name|argString
operator|=
name|Tcl_Merge
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|)
expr_stmt|;
name|panic
argument_list|(
name|argString
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|argString
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

end_unit

