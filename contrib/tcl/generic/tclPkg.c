begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclPkg.c --  *  *	This file implements package and version control for Tcl via  *	the "package" command and a few C APIs.  *  * Copyright (c) 1996 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclPkg.c 1.6 96/02/15 11:43:16  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_comment
comment|/*  * Each invocation of the "package ifneeded" command creates a structure  * of the following type, which is used to load the package into the  * interpreter if it is requested with a "package require" command.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|PkgAvail
block|{
name|char
modifier|*
name|version
decl_stmt|;
comment|/* Version string; malloc'ed. */
name|char
modifier|*
name|script
decl_stmt|;
comment|/* Script to invoke to provide this version 				 * of the package.  Malloc'ed and protected 				 * by Tcl_Preserve and Tcl_Release. */
name|struct
name|PkgAvail
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next in list of available versions of 				 * the same package. */
block|}
name|PkgAvail
typedef|;
end_typedef

begin_comment
comment|/*  * For each package that is known in any way to an interpreter, there  * is one record of the following type.  These records are stored in  * the "packageTable" hash table in the interpreter, keyed by  * package name such as "Tk" (no version number).  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Package
block|{
name|char
modifier|*
name|version
decl_stmt|;
comment|/* Version that has been supplied in this 				 * interpreter via "package provide" 				 * (malloc'ed).  NULL means the package doesn't 				 * exist in this interpreter yet. */
name|PkgAvail
modifier|*
name|availPtr
decl_stmt|;
comment|/* First in list of all available versions 				 * of this package. */
block|}
name|Package
typedef|;
end_typedef

begin_comment
comment|/*  * Prototypes for procedures defined in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|CheckVersion
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ComparePkgVersions
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|v1
operator|,
name|char
operator|*
name|v2
operator|,
name|int
operator|*
name|satPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Package
modifier|*
name|FindPackage
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_PkgProvide --  *  *	This procedure is invoked to declare that a particular version  *	of a particular package is now present in an interpreter.  There  *	must not be any other version of this package already  *	provided in the interpreter.  *  * Results:  *	Normally returns TCL_OK;  if there is already another version  *	of the package loaded then TCL_ERROR is returned and an error  *	message is left in interp->result.  *  * Side effects:  *	The interpreter remembers that this package is available,  *	so that no other version of the package may be provided for  *	the interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_PkgProvide
parameter_list|(
name|interp
parameter_list|,
name|name
parameter_list|,
name|version
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which package is now 				 * available. */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of package. */
name|char
modifier|*
name|version
decl_stmt|;
comment|/* Version string for package. */
block|{
name|Package
modifier|*
name|pkgPtr
decl_stmt|;
name|pkgPtr
operator|=
name|FindPackage
argument_list|(
name|interp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkgPtr
operator|->
name|version
operator|==
name|NULL
condition|)
block|{
name|pkgPtr
operator|->
name|version
operator|=
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|version
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|pkgPtr
operator|->
name|version
argument_list|,
name|version
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|ComparePkgVersions
argument_list|(
name|pkgPtr
operator|->
name|version
argument_list|,
name|version
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"conflicting versions provided for package \""
argument_list|,
name|name
argument_list|,
literal|"\": "
argument_list|,
name|pkgPtr
operator|->
name|version
argument_list|,
literal|", then "
argument_list|,
name|version
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_PkgRequire --  *  *	This procedure is called by code that depends on a particular  *	version of a particular package.  If the package is not already  *	provided in the interpreter, this procedure invokes a Tcl script  *	to provide it.  If the package is already provided, this  *	procedure makes sure that the caller's needs don't conflict with  *	the version that is present.  *  * Results:  *	If successful, returns the version string for the currently  *	provided version of the package, which may be different from  *	the "version" argument.  If the caller's requirements  *	cannot be met (e.g. the version requested conflicts with  *	a currently provided version, or the required version cannot  *	be found, or the script to provide the required version  *	generates an error), NULL is returned and an error  *	message is left in interp->result.  *  * Side effects:  *	The script from some previous "package ifneeded" command may  *	be invoked to provide the package.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_PkgRequire
parameter_list|(
name|interp
parameter_list|,
name|name
parameter_list|,
name|version
parameter_list|,
name|exact
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which package is now 				 * available. */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of desired package. */
name|char
modifier|*
name|version
decl_stmt|;
comment|/* Version string for desired version; 				 * NULL means use the latest version 				 * available. */
name|int
name|exact
decl_stmt|;
comment|/* Non-zero means that only the particular 				 * version given is acceptable. Zero means 				 * use the latest compatible version. */
block|{
name|Package
modifier|*
name|pkgPtr
decl_stmt|;
name|PkgAvail
modifier|*
name|availPtr
decl_stmt|,
modifier|*
name|bestPtr
decl_stmt|;
name|char
modifier|*
name|script
decl_stmt|;
name|int
name|code
decl_stmt|,
name|satisfies
decl_stmt|,
name|result
decl_stmt|,
name|pass
decl_stmt|;
name|Tcl_DString
name|command
decl_stmt|;
comment|/*      * It can take up to three passes to find the package:  one pass to      * run the "package unknown" script, one to run the "package ifneeded"      * script for a specific version, and a final pass to lookup the      * package loaded by the "package ifneeded" script.      */
for|for
control|(
name|pass
operator|=
literal|1
init|;
condition|;
name|pass
operator|++
control|)
block|{
name|pkgPtr
operator|=
name|FindPackage
argument_list|(
name|interp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkgPtr
operator|->
name|version
operator|!=
name|NULL
condition|)
block|{
break|break;
block|}
comment|/* 	 * The package isn't yet present.  Search the list of available 	 * versions and invoke the script for the best available version. 	 */
name|bestPtr
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|availPtr
operator|=
name|pkgPtr
operator|->
name|availPtr
init|;
name|availPtr
operator|!=
name|NULL
condition|;
name|availPtr
operator|=
name|availPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
operator|(
name|bestPtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ComparePkgVersions
argument_list|(
name|availPtr
operator|->
name|version
argument_list|,
name|bestPtr
operator|->
name|version
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
operator|<=
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|version
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|ComparePkgVersions
argument_list|(
name|availPtr
operator|->
name|version
argument_list|,
name|version
argument_list|,
operator|&
name|satisfies
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|!=
literal|0
operator|)
operator|&&
name|exact
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|satisfies
condition|)
block|{
continue|continue;
block|}
block|}
name|bestPtr
operator|=
name|availPtr
expr_stmt|;
block|}
if|if
condition|(
name|bestPtr
operator|!=
name|NULL
condition|)
block|{
comment|/* 	     * We found an ifneeded script for the package.  Be careful while 	     * executing it:  this could cause reentrancy, so (a) protect the 	     * script itself from deletion and (b) don't assume that bestPtr 	     * will still exist when the script completes. 	     */
name|script
operator|=
name|bestPtr
operator|->
name|script
expr_stmt|;
name|Tcl_Preserve
argument_list|(
operator|(
name|ClientData
operator|)
name|script
argument_list|)
expr_stmt|;
name|code
operator|=
name|Tcl_GlobalEval
argument_list|(
name|interp
argument_list|,
name|script
argument_list|)
expr_stmt|;
name|Tcl_Release
argument_list|(
operator|(
name|ClientData
operator|)
name|script
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|TCL_ERROR
condition|)
block|{
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
literal|"\n    (\"package ifneeded\" script)"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|pkgPtr
operator|=
name|FindPackage
argument_list|(
name|interp
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Package not in the database.  If there is a "package unknown" 	 * command, invoke it (but only on the first pass;  after that, 	 * we should not get here in the first place). 	 */
if|if
condition|(
name|pass
operator|>
literal|1
condition|)
block|{
break|break;
block|}
name|script
operator|=
operator|(
operator|(
name|Interp
operator|*
operator|)
name|interp
operator|)
operator|->
name|packageUnknown
expr_stmt|;
if|if
condition|(
name|script
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DStringInit
argument_list|(
operator|&
name|command
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|command
argument_list|,
name|script
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
operator|&
name|command
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|command
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|command
argument_list|,
operator|(
name|version
operator|!=
name|NULL
operator|)
condition|?
name|version
else|:
literal|"{}"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|exact
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|command
argument_list|,
literal|" -exact"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
block|}
name|code
operator|=
name|Tcl_GlobalEval
argument_list|(
name|interp
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|command
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|TCL_ERROR
condition|)
block|{
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
literal|"\n    (\"package unknown\" script)"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pkgPtr
operator|->
name|version
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"can't find package "
argument_list|,
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|" "
argument_list|,
name|version
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
comment|/*      * At this point we now that the package is present.  Make sure that the      * provided version meets the current requirement.      */
if|if
condition|(
name|version
operator|==
name|NULL
condition|)
block|{
return|return
name|pkgPtr
operator|->
name|version
return|;
block|}
name|result
operator|=
name|ComparePkgVersions
argument_list|(
name|pkgPtr
operator|->
name|version
argument_list|,
name|version
argument_list|,
operator|&
name|satisfies
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|satisfies
operator|&&
operator|!
name|exact
operator|)
operator|||
operator|(
name|result
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|pkgPtr
operator|->
name|version
return|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"version conflict for package \""
argument_list|,
name|name
argument_list|,
literal|"\": have "
argument_list|,
name|pkgPtr
operator|->
name|version
argument_list|,
literal|", need "
argument_list|,
name|version
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_PackageCmd --  *  *	This procedure is invoked to process the "package" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_PackageCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|size_t
name|length
decl_stmt|;
name|int
name|c
decl_stmt|,
name|exact
decl_stmt|,
name|i
decl_stmt|,
name|satisfies
decl_stmt|;
name|PkgAvail
modifier|*
name|availPtr
decl_stmt|,
modifier|*
name|prevPtr
decl_stmt|;
name|Package
modifier|*
name|pkgPtr
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|Tcl_HashSearch
name|search
decl_stmt|;
name|Tcl_HashTable
modifier|*
name|tablePtr
decl_stmt|;
name|char
modifier|*
name|version
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" option ?arg arg ...?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|c
operator|=
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'f'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"forget"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|packageTable
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
name|pkgPtr
operator|=
operator|(
name|Package
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
name|Tcl_DeleteHashEntry
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkgPtr
operator|->
name|version
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|pkgPtr
operator|->
name|version
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|pkgPtr
operator|->
name|availPtr
operator|!=
name|NULL
condition|)
block|{
name|availPtr
operator|=
name|pkgPtr
operator|->
name|availPtr
expr_stmt|;
name|pkgPtr
operator|->
name|availPtr
operator|=
name|availPtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
name|availPtr
operator|->
name|version
argument_list|)
expr_stmt|;
name|Tcl_EventuallyFree
argument_list|(
operator|(
name|ClientData
operator|)
name|availPtr
operator|->
name|script
argument_list|,
name|TCL_DYNAMIC
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|availPtr
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pkgPtr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'i'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"ifneeded"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|argc
operator|!=
literal|4
operator|)
operator|&&
operator|(
name|argc
operator|!=
literal|5
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" ifneeded package version ?script?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|CheckVersion
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|argc
operator|==
literal|4
condition|)
block|{
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|packageTable
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
name|pkgPtr
operator|=
operator|(
name|Package
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pkgPtr
operator|=
name|FindPackage
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|availPtr
operator|=
name|pkgPtr
operator|->
name|availPtr
operator|,
name|prevPtr
operator|=
name|NULL
init|;
name|availPtr
operator|!=
name|NULL
condition|;
name|prevPtr
operator|=
name|availPtr
operator|,
name|availPtr
operator|=
name|availPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|ComparePkgVersions
argument_list|(
name|availPtr
operator|->
name|version
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|4
condition|)
block|{
name|interp
operator|->
name|result
operator|=
name|availPtr
operator|->
name|script
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
name|Tcl_EventuallyFree
argument_list|(
operator|(
name|ClientData
operator|)
name|availPtr
operator|->
name|script
argument_list|,
name|TCL_DYNAMIC
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|argc
operator|==
literal|4
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|availPtr
operator|==
name|NULL
condition|)
block|{
name|availPtr
operator|=
operator|(
name|PkgAvail
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PkgAvail
argument_list|)
argument_list|)
expr_stmt|;
name|availPtr
operator|->
name|version
operator|=
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|availPtr
operator|->
name|version
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|prevPtr
operator|==
name|NULL
condition|)
block|{
name|availPtr
operator|->
name|nextPtr
operator|=
name|pkgPtr
operator|->
name|availPtr
expr_stmt|;
name|pkgPtr
operator|->
name|availPtr
operator|=
name|availPtr
expr_stmt|;
block|}
else|else
block|{
name|availPtr
operator|->
name|nextPtr
operator|=
name|prevPtr
operator|->
name|nextPtr
expr_stmt|;
name|prevPtr
operator|->
name|nextPtr
operator|=
name|availPtr
expr_stmt|;
block|}
block|}
name|availPtr
operator|->
name|script
operator|=
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|availPtr
operator|->
name|script
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'n'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"names"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" names\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|tablePtr
operator|=
operator|&
name|iPtr
operator|->
name|packageTable
expr_stmt|;
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|tablePtr
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
name|pkgPtr
operator|=
operator|(
name|Package
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pkgPtr
operator|->
name|version
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|pkgPtr
operator|->
name|availPtr
operator|!=
name|NULL
operator|)
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|Tcl_GetHashKey
argument_list|(
name|tablePtr
argument_list|,
name|hPtr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'p'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"provide"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|argc
operator|!=
literal|3
operator|)
operator|&&
operator|(
name|argc
operator|!=
literal|4
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" provide package ?version?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
block|{
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|packageTable
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|!=
name|NULL
condition|)
block|{
name|pkgPtr
operator|=
operator|(
name|Package
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkgPtr
operator|->
name|version
operator|!=
name|NULL
condition|)
block|{
name|interp
operator|->
name|result
operator|=
name|pkgPtr
operator|->
name|version
expr_stmt|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|CheckVersion
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|Tcl_PkgProvide
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'r'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"require"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|requireSyntax
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" require ?-exact? package ?version?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"-exact"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|exact
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|exact
operator|=
literal|0
expr_stmt|;
block|}
name|version
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|argc
operator|==
operator|(
literal|4
operator|+
name|exact
operator|)
condition|)
block|{
name|version
operator|=
name|argv
index|[
literal|3
operator|+
name|exact
index|]
expr_stmt|;
if|if
condition|(
name|CheckVersion
argument_list|(
name|interp
argument_list|,
name|version
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|argc
operator|!=
literal|3
operator|)
operator|||
name|exact
condition|)
block|{
goto|goto
name|requireSyntax
goto|;
block|}
name|version
operator|=
name|Tcl_PkgRequire
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
operator|+
name|exact
index|]
argument_list|,
name|version
argument_list|,
name|exact
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|interp
operator|->
name|result
operator|=
name|version
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'u'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"unknown"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|iPtr
operator|->
name|packageUnknown
operator|!=
name|NULL
condition|)
block|{
name|iPtr
operator|->
name|result
operator|=
name|iPtr
operator|->
name|packageUnknown
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|iPtr
operator|->
name|packageUnknown
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|iPtr
operator|->
name|packageUnknown
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|iPtr
operator|->
name|packageUnknown
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|iPtr
operator|->
name|packageUnknown
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|iPtr
operator|->
name|packageUnknown
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" unknown ?command?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'v'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"vcompare"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|2
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" vcompare version1 version2\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|CheckVersion
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
operator|!=
name|TCL_OK
operator|)
operator|||
operator|(
name|CheckVersion
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
operator|!=
name|TCL_OK
operator|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"%d"
argument_list|,
name|ComparePkgVersions
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'v'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"versions"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|2
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" versions package\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|packageTable
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|!=
name|NULL
condition|)
block|{
name|pkgPtr
operator|=
operator|(
name|Package
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
for|for
control|(
name|availPtr
operator|=
name|pkgPtr
operator|->
name|availPtr
init|;
name|availPtr
operator|!=
name|NULL
condition|;
name|availPtr
operator|=
name|availPtr
operator|->
name|nextPtr
control|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|availPtr
operator|->
name|version
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'v'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"vsatisfies"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|2
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" vsatisfies version1 version2\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|CheckVersion
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
operator|!=
name|TCL_OK
operator|)
operator|||
operator|(
name|CheckVersion
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
operator|!=
name|TCL_OK
operator|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|ComparePkgVersions
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
operator|&
name|satisfies
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"%d"
argument_list|,
name|satisfies
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": should be forget, ifneeded, names, "
argument_list|,
literal|"provide, require, unknown, vcompare, "
argument_list|,
literal|"versions, or vsatisfies"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FindPackage --  *  *	This procedure finds the Package record for a particular package  *	in a particular interpreter, creating a record if one doesn't  *	already exist.  *  * Results:  *	The return value is a pointer to the Package record for the  *	package.  *  * Side effects:  *	A new Package record may be created.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Package
modifier|*
name|FindPackage
parameter_list|(
name|interp
parameter_list|,
name|name
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for package lookup. */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of package to fine. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|int
name|new
decl_stmt|;
name|Package
modifier|*
name|pkgPtr
decl_stmt|;
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|packageTable
argument_list|,
name|name
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
name|pkgPtr
operator|=
operator|(
name|Package
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Package
argument_list|)
argument_list|)
expr_stmt|;
name|pkgPtr
operator|->
name|version
operator|=
name|NULL
expr_stmt|;
name|pkgPtr
operator|->
name|availPtr
operator|=
name|NULL
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
name|pkgPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pkgPtr
operator|=
operator|(
name|Package
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
block|}
return|return
name|pkgPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclFreePackageInfo --  *  *	This procedure is called during interpreter deletion to  *	free all of the package-related information for the  *	interpreter.  *  * Results:  *	None.  *  * Side effects:  *	Memory is freed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclFreePackageInfo
parameter_list|(
name|iPtr
parameter_list|)
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Interpereter that is being deleted. */
block|{
name|Package
modifier|*
name|pkgPtr
decl_stmt|;
name|Tcl_HashSearch
name|search
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|PkgAvail
modifier|*
name|availPtr
decl_stmt|;
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|packageTable
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
name|pkgPtr
operator|=
operator|(
name|Package
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkgPtr
operator|->
name|version
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|pkgPtr
operator|->
name|version
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|pkgPtr
operator|->
name|availPtr
operator|!=
name|NULL
condition|)
block|{
name|availPtr
operator|=
name|pkgPtr
operator|->
name|availPtr
expr_stmt|;
name|pkgPtr
operator|->
name|availPtr
operator|=
name|availPtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
name|availPtr
operator|->
name|version
argument_list|)
expr_stmt|;
name|Tcl_EventuallyFree
argument_list|(
operator|(
name|ClientData
operator|)
name|availPtr
operator|->
name|script
argument_list|,
name|TCL_DYNAMIC
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|availPtr
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pkgPtr
argument_list|)
expr_stmt|;
block|}
name|Tcl_DeleteHashTable
argument_list|(
operator|&
name|iPtr
operator|->
name|packageTable
argument_list|)
expr_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|packageUnknown
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|iPtr
operator|->
name|packageUnknown
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CheckVersion --  *  *	This procedure checks to see whether a version number has  *	valid syntax.  *  * Results:  *	If string is a properly formed version number the TCL_OK  *	is returned.  Otherwise TCL_ERROR is returned and an error  *	message is left in interp->result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CheckVersion
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Supposedly a version number, which is 				 * groups of decimal digits separated 				 * by dots. */
block|{
name|char
modifier|*
name|p
init|=
name|string
decl_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
goto|goto
name|error
goto|;
block|}
for|for
control|(
name|p
operator|++
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|'.'
operator|)
condition|)
block|{
goto|goto
name|error
goto|;
block|}
block|}
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'.'
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
name|error
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"expected version number but got \""
argument_list|,
name|string
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * ComparePkgVersions --  *  *	This procedure compares two version numbers.  *  * Results:  *	The return value is -1 if v1 is less than v2, 0 if the two  *	version numbers are the same, and 1 if v1 is greater than v2.  *	If *satPtr is non-NULL, the word it points to is filled in  *	with 1 if v2>= v1 and both numbers have the same major number  *	or 0 otherwise.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ComparePkgVersions
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|,
name|satPtr
parameter_list|)
name|char
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|;
end_function

begin_comment
comment|/* Versions strings, of form 2.1.3 (any 				 * number of version numbers). */
end_comment

begin_decl_stmt
name|int
modifier|*
name|satPtr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-null, the word pointed to is 				 * filled in with a 0/1 value.  1 means 				 * v1 "satisfies" v2:  v1 is greater than 				 * or equal to v2 and both version numbers 				 * have the same major number. */
end_comment

begin_block
block|{
name|int
name|thisIsMajor
decl_stmt|,
name|n1
decl_stmt|,
name|n2
decl_stmt|;
comment|/*      * Each iteration of the following loop processes one number from      * each string, terminated by a ".".  If those numbers don't match      * then the comparison is over;  otherwise, we loop back for the      * next number.      */
name|thisIsMajor
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* 	 * Parse one decimal number from the front of each string. 	 */
name|n1
operator|=
name|n2
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|v1
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|*
name|v1
operator|!=
literal|'.'
operator|)
condition|)
block|{
name|n1
operator|=
literal|10
operator|*
name|n1
operator|+
operator|(
operator|*
name|v1
operator|-
literal|'0'
operator|)
expr_stmt|;
name|v1
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|*
name|v2
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|*
name|v2
operator|!=
literal|'.'
operator|)
condition|)
block|{
name|n2
operator|=
literal|10
operator|*
name|n2
operator|+
operator|(
operator|*
name|v2
operator|-
literal|'0'
operator|)
expr_stmt|;
name|v2
operator|++
expr_stmt|;
block|}
comment|/* 	 * Compare and go on to the next version number if the 	 * current numbers match. 	 */
if|if
condition|(
name|n1
operator|!=
name|n2
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|*
name|v1
operator|!=
literal|0
condition|)
block|{
name|v1
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|v2
operator|==
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|*
name|v2
operator|!=
literal|0
condition|)
block|{
name|v2
operator|++
expr_stmt|;
block|}
name|thisIsMajor
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|satPtr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|satPtr
operator|=
operator|(
name|n1
operator|==
name|n2
operator|)
operator|||
operator|(
operator|(
name|n1
operator|>
name|n2
operator|)
operator|&&
operator|!
name|thisIsMajor
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|n1
operator|>
name|n2
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|n1
operator|==
name|n2
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
end_block

end_unit

