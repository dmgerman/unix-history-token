begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclPipe.c --  *  *	This file contains the generic portion of the command channel  *	driver as well as various utility routines used in managing  *	subprocesses.  *  * Copyright (c) 1997 by Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclPipe.c 1.8 97/06/20 13:26:45  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * A linked list of the following structures is used to keep track  * of child processes that have been detached but haven't exited  * yet, so we can make sure that they're properly "reaped" (officially  * waited for) and don't lie around as zombies cluttering the  * system.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Detached
block|{
name|Tcl_Pid
name|pid
decl_stmt|;
comment|/* Id of process that's been detached 					 * but isn't known to have exited. */
name|struct
name|Detached
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next in list of all detached 					 * processes. */
block|}
name|Detached
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|Detached
modifier|*
name|detList
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of all detached proceses. */
end_comment

begin_comment
comment|/*  * Declarations for local procedures defined in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|TclFile
name|FileForRedirect
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|spec
operator|,
name|int
name|atOk
operator|,
name|char
operator|*
name|arg
operator|,
name|char
operator|*
name|nextArg
operator|,
name|int
name|flags
operator|,
name|int
operator|*
name|skipPtr
operator|,
name|int
operator|*
name|closePtr
operator|,
name|int
operator|*
name|releasePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FileForRedirect --  *  *	This procedure does much of the work of parsing redirection  *	operators.  It handles "@" if specified and allowed, and a file  *	name, and opens the file if necessary.  *  * Results:  *	The return value is the descriptor number for the file.  If an  *	error occurs then NULL is returned and an error message is left  *	in interp->result.  Several arguments are side-effected; see  *	the argument list below for details.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|TclFile
name|FileForRedirect
parameter_list|(
name|interp
parameter_list|,
name|spec
parameter_list|,
name|atOK
parameter_list|,
name|arg
parameter_list|,
name|nextArg
parameter_list|,
name|flags
parameter_list|,
name|skipPtr
parameter_list|,
name|closePtr
parameter_list|,
name|releasePtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Intepreter to use for error reporting. */
name|char
modifier|*
name|spec
decl_stmt|;
comment|/* Points to character just after 				 * redirection character. */
name|char
modifier|*
name|arg
decl_stmt|;
comment|/* Pointer to entire argument containing  				 * spec:  used for error reporting. */
name|int
name|atOK
decl_stmt|;
comment|/* Non-zero means that '@' notation can be  				 * used to specify a channel, zero means that 				 * it isn't. */
name|char
modifier|*
name|nextArg
decl_stmt|;
comment|/* Next argument in argc/argv array, if needed  				 * for file name or channel name.  May be  				 * NULL. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to use for opening file or to  				 * specify mode for channel. */
name|int
modifier|*
name|skipPtr
decl_stmt|;
comment|/* Filled with 1 if redirection target was 				 * in spec, 2 if it was in nextArg. */
name|int
modifier|*
name|closePtr
decl_stmt|;
comment|/* Filled with one if the caller should  				 * close the file when done with it, zero 				 * otherwise. */
name|int
modifier|*
name|releasePtr
decl_stmt|;
block|{
name|int
name|writing
init|=
operator|(
name|flags
operator|&
name|O_WRONLY
operator|)
decl_stmt|;
name|Tcl_Channel
name|chan
decl_stmt|;
name|TclFile
name|file
decl_stmt|;
operator|*
name|skipPtr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|atOK
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|*
name|spec
operator|==
literal|'@'
operator|)
condition|)
block|{
name|spec
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|spec
operator|==
literal|'\0'
condition|)
block|{
name|spec
operator|=
name|nextArg
expr_stmt|;
if|if
condition|(
name|spec
operator|==
name|NULL
condition|)
block|{
goto|goto
name|badLastArg
goto|;
block|}
operator|*
name|skipPtr
operator|=
literal|2
expr_stmt|;
block|}
name|chan
operator|=
name|Tcl_GetChannel
argument_list|(
name|interp
argument_list|,
name|spec
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|file
operator|=
name|TclpMakeFile
argument_list|(
name|chan
argument_list|,
name|writing
condition|?
name|TCL_WRITABLE
else|:
name|TCL_READABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"channel \""
argument_list|,
name|Tcl_GetChannelName
argument_list|(
name|chan
argument_list|)
argument_list|,
literal|"\" wasn't opened for "
argument_list|,
operator|(
operator|(
name|writing
operator|)
condition|?
literal|"writing"
else|:
literal|"reading"
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|releasePtr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|writing
condition|)
block|{
comment|/* 	     * Be sure to flush output to the file, so that anything 	     * written by the child appears after stuff we've already 	     * written. 	     */
name|Tcl_Flush
argument_list|(
name|chan
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|Tcl_DString
name|nameString
decl_stmt|;
if|if
condition|(
operator|*
name|spec
operator|==
literal|'\0'
condition|)
block|{
name|spec
operator|=
name|nextArg
expr_stmt|;
if|if
condition|(
name|spec
operator|==
name|NULL
condition|)
block|{
goto|goto
name|badLastArg
goto|;
block|}
operator|*
name|skipPtr
operator|=
literal|2
expr_stmt|;
block|}
name|name
operator|=
name|Tcl_TranslateFileName
argument_list|(
name|interp
argument_list|,
name|spec
argument_list|,
operator|&
name|nameString
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|file
operator|=
name|TclpOpenFile
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|file
operator|=
name|NULL
expr_stmt|;
block|}
name|Tcl_DStringFree
argument_list|(
operator|&
name|nameString
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't "
argument_list|,
operator|(
operator|(
name|writing
operator|)
condition|?
literal|"write"
else|:
literal|"read"
operator|)
argument_list|,
literal|" file \""
argument_list|,
name|spec
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|closePtr
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|file
return|;
name|badLastArg
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"can't specify \""
argument_list|,
name|arg
argument_list|,
literal|"\" as last word in command"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DetachPids --  *  *	This procedure is called to indicate that one or more child  *	processes have been placed in background and will never be  *	waited for;  they should eventually be reaped by  *	Tcl_ReapDetachedProcs.  *  * Results:  *	None.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DetachPids
parameter_list|(
name|numPids
parameter_list|,
name|pidPtr
parameter_list|)
name|int
name|numPids
decl_stmt|;
comment|/* Number of pids to detach:  gives size 				 * of array pointed to by pidPtr. */
name|Tcl_Pid
modifier|*
name|pidPtr
decl_stmt|;
comment|/* Array of pids to detach. */
block|{
specifier|register
name|Detached
modifier|*
name|detPtr
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numPids
condition|;
name|i
operator|++
control|)
block|{
name|detPtr
operator|=
operator|(
name|Detached
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Detached
argument_list|)
argument_list|)
expr_stmt|;
name|detPtr
operator|->
name|pid
operator|=
name|pidPtr
index|[
name|i
index|]
expr_stmt|;
name|detPtr
operator|->
name|nextPtr
operator|=
name|detList
expr_stmt|;
name|detList
operator|=
name|detPtr
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ReapDetachedProcs --  *  *	This procedure checks to see if any detached processes have  *	exited and, if so, it "reaps" them by officially waiting on  *	them.  It should be called "occasionally" to make sure that  *	all detached processes are eventually reaped.  *  * Results:  *	None.  *  * Side effects:  *	Processes are waited on, so that they can be reaped by the  *	system.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_ReapDetachedProcs
parameter_list|()
block|{
specifier|register
name|Detached
modifier|*
name|detPtr
decl_stmt|;
name|Detached
modifier|*
name|nextPtr
decl_stmt|,
modifier|*
name|prevPtr
decl_stmt|;
name|int
name|status
decl_stmt|;
name|Tcl_Pid
name|pid
decl_stmt|;
for|for
control|(
name|detPtr
operator|=
name|detList
operator|,
name|prevPtr
operator|=
name|NULL
init|;
name|detPtr
operator|!=
name|NULL
condition|;
control|)
block|{
name|pid
operator|=
name|Tcl_WaitPid
argument_list|(
name|detPtr
operator|->
name|pid
argument_list|,
operator|&
name|status
argument_list|,
name|WNOHANG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pid
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|pid
operator|==
operator|(
name|Tcl_Pid
operator|)
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|!=
name|ECHILD
operator|)
operator|)
condition|)
block|{
name|prevPtr
operator|=
name|detPtr
expr_stmt|;
name|detPtr
operator|=
name|detPtr
operator|->
name|nextPtr
expr_stmt|;
continue|continue;
block|}
name|nextPtr
operator|=
name|detPtr
operator|->
name|nextPtr
expr_stmt|;
if|if
condition|(
name|prevPtr
operator|==
name|NULL
condition|)
block|{
name|detList
operator|=
name|detPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
name|prevPtr
operator|->
name|nextPtr
operator|=
name|detPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|detPtr
argument_list|)
expr_stmt|;
name|detPtr
operator|=
name|nextPtr
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCleanupChildren --  *  *	This is a utility procedure used to wait for child processes  *	to exit, record information about abnormal exits, and then  *	collect any stderr output generated by them.  *  * Results:  *	The return value is a standard Tcl result.  If anything at  *	weird happened with the child processes, TCL_ERROR is returned  *	and a message is left in interp->result.  *  * Side effects:  *	If the last character of interp->result is a newline, then it  *	is removed unless keepNewline is non-zero.  File errorId gets  *	closed, and pidPtr is freed back to the storage allocator.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclCleanupChildren
parameter_list|(
name|interp
parameter_list|,
name|numPids
parameter_list|,
name|pidPtr
parameter_list|,
name|errorChan
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error messages. */
name|int
name|numPids
decl_stmt|;
comment|/* Number of entries in pidPtr array. */
name|Tcl_Pid
modifier|*
name|pidPtr
decl_stmt|;
comment|/* Array of process ids of children. */
name|Tcl_Channel
name|errorChan
decl_stmt|;
comment|/* Channel for file containing stderr output 				 * from pipeline.  NULL means there isn't any 				 * stderr output. */
block|{
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
name|int
name|i
decl_stmt|,
name|abnormalExit
decl_stmt|,
name|anyErrorInfo
decl_stmt|;
name|Tcl_Pid
name|pid
decl_stmt|;
name|WAIT_STATUS_TYPE
name|waitStatus
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|abnormalExit
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numPids
condition|;
name|i
operator|++
control|)
block|{
name|pid
operator|=
name|Tcl_WaitPid
argument_list|(
name|pidPtr
index|[
name|i
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|waitStatus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|(
name|Tcl_Pid
operator|)
operator|-
literal|1
condition|)
block|{
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|msg
operator|=
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ECHILD
condition|)
block|{
comment|/*                      * This changeup in message suggested by Mark Diekhans                      * to remind people that ECHILD errors can occur on                      * some systems if SIGCHLD isn't in its default state.                      */
name|msg
operator|=
literal|"child process lost (is SIGCHLD ignored or trapped?)"
expr_stmt|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"error waiting for process to exit: "
argument_list|,
name|msg
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* 	 * Create error messages for unusual process exits.  An 	 * extra newline gets appended to each error message, but 	 * it gets removed below (in the same fashion that an 	 * extra newline in the command's output is removed). 	 */
if|if
condition|(
operator|!
name|WIFEXITED
argument_list|(
name|waitStatus
argument_list|)
operator|||
operator|(
name|WEXITSTATUS
argument_list|(
name|waitStatus
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|char
name|msg1
index|[
literal|20
index|]
decl_stmt|,
name|msg2
index|[
literal|20
index|]
decl_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
name|sprintf
argument_list|(
name|msg1
argument_list|,
literal|"%ld"
argument_list|,
name|TclpGetPid
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|WIFEXITED
argument_list|(
name|waitStatus
argument_list|)
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|msg2
argument_list|,
literal|"%d"
argument_list|,
name|WEXITSTATUS
argument_list|(
name|waitStatus
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"CHILDSTATUS"
argument_list|,
name|msg1
argument_list|,
name|msg2
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|abnormalExit
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|waitStatus
argument_list|)
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|Tcl_SignalMsg
argument_list|(
call|(
name|int
call|)
argument_list|(
name|WTERMSIG
argument_list|(
name|waitStatus
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"CHILDKILLED"
argument_list|,
name|msg1
argument_list|,
name|Tcl_SignalId
argument_list|(
call|(
name|int
call|)
argument_list|(
name|WTERMSIG
argument_list|(
name|waitStatus
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"child killed: "
argument_list|,
name|p
argument_list|,
literal|"\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|waitStatus
argument_list|)
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|Tcl_SignalMsg
argument_list|(
call|(
name|int
call|)
argument_list|(
name|WSTOPSIG
argument_list|(
name|waitStatus
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"CHILDSUSP"
argument_list|,
name|msg1
argument_list|,
name|Tcl_SignalId
argument_list|(
call|(
name|int
call|)
argument_list|(
name|WSTOPSIG
argument_list|(
name|waitStatus
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"child suspended: "
argument_list|,
name|p
argument_list|,
literal|"\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"child wait status didn't make sense\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/*      * Read the standard error file.  If there's anything there,      * then return an error and add the file's contents to the result      * string.      */
name|anyErrorInfo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|errorChan
operator|!=
name|NULL
condition|)
block|{
comment|/* 	 * Make sure we start at the beginning of the file. 	 */
name|Tcl_Seek
argument_list|(
name|errorChan
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
define|#
directive|define
name|BUFFER_SIZE
value|1000
name|char
name|buffer
index|[
name|BUFFER_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
name|count
operator|=
name|Tcl_Read
argument_list|(
name|errorChan
argument_list|,
name|buffer
argument_list|,
name|BUFFER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"error reading stderr output file: "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
break|break;
comment|/* out of the "while (1)" loop. */
block|}
name|buffer
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|buffer
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|anyErrorInfo
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|Tcl_Close
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|errorChan
argument_list|)
expr_stmt|;
block|}
comment|/*      * If a child exited abnormally but didn't output any error information      * at all, generate an error message here.      */
if|if
condition|(
name|abnormalExit
operator|&&
operator|!
name|anyErrorInfo
operator|&&
operator|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"child process exited abnormally"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCreatePipeline --  *  *	Given an argc/argv array, instantiate a pipeline of processes  *	as described by the argv.  *  *	This procedure is unofficially exported for use by BLT.  *  * Results:  *	The return value is a count of the number of new processes  *	created, or -1 if an error occurred while creating the pipeline.  *	*pidArrayPtr is filled in with the address of a dynamically  *	allocated array giving the ids of all of the processes.  It  *	is up to the caller to free this array when it isn't needed  *	anymore.  If inPipePtr is non-NULL, *inPipePtr is filled in  *	with the file id for the input pipe for the pipeline (if any):  *	the caller must eventually close this file.  If outPipePtr  *	isn't NULL, then *outPipePtr is filled in with the file id  *	for the output pipe from the pipeline:  the caller must close  *	this file.  If errFilePtr isn't NULL, then *errFilePtr is filled  *	with a file id that may be used to read error output after the  *	pipeline completes.  *  * Side effects:  *	Processes and pipes are created.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclCreatePipeline
parameter_list|(
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pidArrayPtr
parameter_list|,
name|inPipePtr
parameter_list|,
name|outPipePtr
parameter_list|,
name|errFilePtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for error reporting. */
name|int
name|argc
decl_stmt|;
comment|/* Number of entries in argv. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Array of strings describing commands in 				 * pipeline plus I/O redirection with<, 				 *<<,>, etc.  Argv[argc] must be NULL. */
name|Tcl_Pid
modifier|*
modifier|*
name|pidArrayPtr
decl_stmt|;
comment|/* Word at *pidArrayPtr gets filled in with 				 * address of array of pids for processes 				 * in pipeline (first pid is first process 				 * in pipeline). */
name|TclFile
modifier|*
name|inPipePtr
decl_stmt|;
comment|/* If non-NULL, input to the pipeline comes 				 * from a pipe (unless overridden by 				 * redirection in the command).  The file 				 * id with which to write to this pipe is 				 * stored at *inPipePtr.  NULL means command 				 * specified its own input source. */
name|TclFile
modifier|*
name|outPipePtr
decl_stmt|;
comment|/* If non-NULL, output to the pipeline goes 				 * to a pipe, unless overriden by redirection 				 * in the command.  The file id with which to 				 * read frome this pipe is stored at 				 * *outPipePtr.  NULL means command specified 				 * its own output sink. */
name|TclFile
modifier|*
name|errFilePtr
decl_stmt|;
comment|/* If non-NULL, all stderr output from the 				 * pipeline will go to a temporary file 				 * created here, and a descriptor to read 				 * the file will be left at *errFilePtr. 				 * The file will be removed already, so 				 * closing this descriptor will be the end 				 * of the file.  If this is NULL, then 				 * all stderr output goes to our stderr. 				 * If the pipeline specifies redirection 				 * then the file will still be created 				 * but it will never get any data. */
block|{
name|Tcl_Pid
modifier|*
name|pidPtr
init|=
name|NULL
decl_stmt|;
comment|/* Points to malloc-ed array holding all 				 * the pids of child processes. */
name|int
name|numPids
decl_stmt|;
comment|/* Actual number of processes that exist 				 * at *pidPtr right now. */
name|int
name|cmdCount
decl_stmt|;
comment|/* Count of number of distinct commands 				 * found in argc/argv. */
name|char
modifier|*
name|inputLiteral
init|=
name|NULL
decl_stmt|;
comment|/* If non-null, then this points to a 				 * string containing input data (specified 				 * via<<) to be piped to the first process 				 * in the pipeline. */
name|TclFile
name|inputFile
init|=
name|NULL
decl_stmt|;
comment|/* If != NULL, gives file to use as input for 				 * first process in pipeline (specified via< 				 * or<@). */
name|int
name|inputClose
init|=
literal|0
decl_stmt|;
comment|/* If non-zero, then inputFile should be      				 * closed when cleaning up. */
name|int
name|inputRelease
init|=
literal|0
decl_stmt|;
name|TclFile
name|outputFile
init|=
name|NULL
decl_stmt|;
comment|/* Writable file for output from last command 				 * in pipeline (could be file or pipe).  NULL 				 * means use stdout. */
name|int
name|outputClose
init|=
literal|0
decl_stmt|;
comment|/* If non-zero, then outputFile should be      				 * closed when cleaning up. */
name|int
name|outputRelease
init|=
literal|0
decl_stmt|;
name|TclFile
name|errorFile
init|=
name|NULL
decl_stmt|;
comment|/* Writable file for error output from all 				 * commands in pipeline.  NULL means use 				 * stderr. */
name|int
name|errorClose
init|=
literal|0
decl_stmt|;
comment|/* If non-zero, then errorFile should be      				 * closed when cleaning up. */
name|int
name|errorRelease
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|skip
decl_stmt|,
name|lastBar
decl_stmt|,
name|lastArg
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|atOK
decl_stmt|,
name|flags
decl_stmt|,
name|errorToOutput
decl_stmt|;
name|Tcl_DString
name|execBuffer
decl_stmt|;
name|TclFile
name|pipeIn
decl_stmt|;
name|TclFile
name|curInFile
decl_stmt|,
name|curOutFile
decl_stmt|,
name|curErrFile
decl_stmt|;
name|Tcl_Channel
name|channel
decl_stmt|;
if|if
condition|(
name|inPipePtr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|inPipePtr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|outPipePtr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|outPipePtr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|errFilePtr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|errFilePtr
operator|=
name|NULL
expr_stmt|;
block|}
name|Tcl_DStringInit
argument_list|(
operator|&
name|execBuffer
argument_list|)
expr_stmt|;
name|pipeIn
operator|=
name|NULL
expr_stmt|;
name|curInFile
operator|=
name|NULL
expr_stmt|;
name|curOutFile
operator|=
name|NULL
expr_stmt|;
name|numPids
operator|=
literal|0
expr_stmt|;
comment|/*      * First, scan through all the arguments to figure out the structure      * of the pipeline.  Process all of the input and output redirection      * arguments and remove them from the argument list in the pipeline.      * Count the number of distinct processes (it's the number of "|"      * arguments plus one) but don't remove the "|" arguments because       * they'll be used in the second pass to seperate the individual       * child processes.  Cannot start the child processes in this pass       * because the redirection symbols may appear anywhere in the       * command line -- e.g., the '<' that specifies the input to the       * entire pipe may appear at the very end of the argument list.      */
name|lastBar
operator|=
operator|-
literal|1
expr_stmt|;
name|cmdCount
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|skip
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|'|'
case|:
if|if
condition|(
operator|*
name|p
operator|==
literal|'&'
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|==
operator|(
name|lastBar
operator|+
literal|1
operator|)
operator|)
operator|||
operator|(
name|i
operator|==
operator|(
name|argc
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"illegal use of | or |& in command"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
name|lastBar
operator|=
name|i
expr_stmt|;
name|cmdCount
operator|++
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|inputClose
operator|!=
literal|0
condition|)
block|{
name|inputClose
operator|=
literal|0
expr_stmt|;
name|TclpCloseFile
argument_list|(
name|inputFile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inputRelease
operator|!=
literal|0
condition|)
block|{
name|inputRelease
operator|=
literal|0
expr_stmt|;
name|TclpReleaseFile
argument_list|(
name|inputFile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'<'
condition|)
block|{
name|inputFile
operator|=
name|NULL
expr_stmt|;
name|inputLiteral
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|skip
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|inputLiteral
operator|==
literal|'\0'
condition|)
block|{
name|inputLiteral
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|inputLiteral
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"can't specify \""
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
literal|"\" as last word in command"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|skip
operator|=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
name|inputLiteral
operator|=
name|NULL
expr_stmt|;
name|inputFile
operator|=
name|FileForRedirect
argument_list|(
name|interp
argument_list|,
name|p
argument_list|,
literal|1
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|O_RDONLY
argument_list|,
operator|&
name|skip
argument_list|,
operator|&
name|inputClose
argument_list|,
operator|&
name|inputRelease
argument_list|)
expr_stmt|;
if|if
condition|(
name|inputFile
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
block|}
break|break;
case|case
literal|'>'
case|:
name|atOK
operator|=
literal|1
expr_stmt|;
name|flags
operator|=
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
expr_stmt|;
name|errorToOutput
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'>'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|atOK
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
name|O_WRONLY
operator||
name|O_CREAT
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'&'
condition|)
block|{
if|if
condition|(
name|errorClose
operator|!=
literal|0
condition|)
block|{
name|errorClose
operator|=
literal|0
expr_stmt|;
name|TclpCloseFile
argument_list|(
name|errorFile
argument_list|)
expr_stmt|;
block|}
name|errorToOutput
operator|=
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
comment|/* 	     * Close the old output file, but only if the error file is 	     * not also using it. 	     */
if|if
condition|(
name|outputClose
operator|!=
literal|0
condition|)
block|{
name|outputClose
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|errorFile
operator|==
name|outputFile
condition|)
block|{
name|errorClose
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|TclpCloseFile
argument_list|(
name|outputFile
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|outputRelease
operator|!=
literal|0
condition|)
block|{
name|outputRelease
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|errorFile
operator|==
name|outputFile
condition|)
block|{
name|errorRelease
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|TclpReleaseFile
argument_list|(
name|outputFile
argument_list|)
expr_stmt|;
block|}
block|}
name|outputFile
operator|=
name|FileForRedirect
argument_list|(
name|interp
argument_list|,
name|p
argument_list|,
name|atOK
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|flags
argument_list|,
operator|&
name|skip
argument_list|,
operator|&
name|outputClose
argument_list|,
operator|&
name|outputRelease
argument_list|)
expr_stmt|;
if|if
condition|(
name|outputFile
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|errorToOutput
condition|)
block|{
if|if
condition|(
name|errorClose
operator|!=
literal|0
condition|)
block|{
name|errorClose
operator|=
literal|0
expr_stmt|;
name|TclpCloseFile
argument_list|(
name|errorFile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errorRelease
operator|!=
literal|0
condition|)
block|{
name|errorRelease
operator|=
literal|0
expr_stmt|;
name|TclpReleaseFile
argument_list|(
name|errorFile
argument_list|)
expr_stmt|;
block|}
name|errorFile
operator|=
name|outputFile
expr_stmt|;
block|}
break|break;
case|case
literal|'2'
case|:
if|if
condition|(
operator|*
name|p
operator|!=
literal|'>'
condition|)
block|{
break|break;
block|}
name|p
operator|++
expr_stmt|;
name|atOK
operator|=
literal|1
expr_stmt|;
name|flags
operator|=
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'>'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|atOK
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
name|O_WRONLY
operator||
name|O_CREAT
expr_stmt|;
block|}
if|if
condition|(
name|errorClose
operator|!=
literal|0
condition|)
block|{
name|errorClose
operator|=
literal|0
expr_stmt|;
name|TclpCloseFile
argument_list|(
name|errorFile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errorRelease
operator|!=
literal|0
condition|)
block|{
name|errorRelease
operator|=
literal|0
expr_stmt|;
name|TclpReleaseFile
argument_list|(
name|errorFile
argument_list|)
expr_stmt|;
block|}
name|errorFile
operator|=
name|FileForRedirect
argument_list|(
name|interp
argument_list|,
name|p
argument_list|,
name|atOK
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|flags
argument_list|,
operator|&
name|skip
argument_list|,
operator|&
name|errorClose
argument_list|,
operator|&
name|errorRelease
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorFile
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
break|break;
block|}
if|if
condition|(
name|skip
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
name|i
operator|+
name|skip
init|;
name|j
operator|<
name|argc
condition|;
name|j
operator|++
control|)
block|{
name|argv
index|[
name|j
operator|-
name|skip
index|]
operator|=
name|argv
index|[
name|j
index|]
expr_stmt|;
block|}
name|argc
operator|-=
name|skip
expr_stmt|;
name|i
operator|-=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|inputFile
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|inputLiteral
operator|!=
name|NULL
condition|)
block|{
comment|/* 	     * The input for the first process is immediate data coming from 	     * Tcl.  Create a temporary file for it and put the data into the 	     * file. 	     */
name|inputFile
operator|=
name|TclpCreateTempFile
argument_list|(
name|inputLiteral
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|inputFile
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't create input file for command: "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|inputClose
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inPipePtr
operator|!=
name|NULL
condition|)
block|{
comment|/* 	     * The input for the first process in the pipeline is to 	     * come from a pipe that can be written from by the caller. 	     */
if|if
condition|(
name|TclpCreatePipe
argument_list|(
operator|&
name|inputFile
argument_list|,
name|inPipePtr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't create input pipe for command: "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|inputClose
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * The input for the first process comes from stdin. 	     */
name|channel
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|!=
name|NULL
condition|)
block|{
name|inputFile
operator|=
name|TclpMakeFile
argument_list|(
name|channel
argument_list|,
name|TCL_READABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|inputFile
operator|!=
name|NULL
condition|)
block|{
name|inputRelease
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|outputFile
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|outPipePtr
operator|!=
name|NULL
condition|)
block|{
comment|/* 	     * Output from the last process in the pipeline is to go to a 	     * pipe that can be read by the caller. 	     */
if|if
condition|(
name|TclpCreatePipe
argument_list|(
name|outPipePtr
argument_list|,
operator|&
name|outputFile
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't create output pipe for command: "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|outputClose
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * The output for the last process goes to stdout. 	     */
name|channel
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
condition|)
block|{
name|outputFile
operator|=
name|TclpMakeFile
argument_list|(
name|channel
argument_list|,
name|TCL_WRITABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|outputFile
operator|!=
name|NULL
condition|)
block|{
name|outputRelease
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|errorFile
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|errFilePtr
operator|!=
name|NULL
condition|)
block|{
comment|/* 	     * Set up the standard error output sink for the pipeline, if 	     * requested.  Use a temporary file which is opened, then deleted. 	     * Could potentially just use pipe, but if it filled up it could 	     * cause the pipeline to deadlock:  we'd be waiting for processes 	     * to complete before reading stderr, and processes couldn't  	     * complete because stderr was backed up. 	     */
name|errorFile
operator|=
name|TclpCreateTempFile
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorFile
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't create error file for command: "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|errFilePtr
operator|=
name|errorFile
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * Errors from the pipeline go to stderr. 	     */
name|channel
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
condition|)
block|{
name|errorFile
operator|=
name|TclpMakeFile
argument_list|(
name|channel
argument_list|,
name|TCL_WRITABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorFile
operator|!=
name|NULL
condition|)
block|{
name|errorRelease
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/*      * Scan through the argc array, creating a process for each      * group of arguments between the "|" characters.      */
name|Tcl_ReapDetachedProcs
argument_list|()
expr_stmt|;
name|pidPtr
operator|=
operator|(
name|Tcl_Pid
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|cmdCount
operator|*
sizeof|sizeof
argument_list|(
name|Tcl_Pid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|curInFile
operator|=
name|inputFile
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|=
name|lastArg
operator|+
literal|1
control|)
block|{
name|int
name|joinThisError
decl_stmt|;
name|Tcl_Pid
name|pid
decl_stmt|;
comment|/* 	 * Convert the program name into native form.  	 */
name|argv
index|[
name|i
index|]
operator|=
name|Tcl_TranslateFileName
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
operator|&
name|execBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* 	 * Find the end of the current segment of the pipeline. 	 */
name|joinThisError
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|lastArg
operator|=
name|i
init|;
name|lastArg
operator|<
name|argc
condition|;
name|lastArg
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|lastArg
index|]
index|[
literal|0
index|]
operator|==
literal|'|'
condition|)
block|{
if|if
condition|(
name|argv
index|[
name|lastArg
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|(
name|argv
index|[
name|lastArg
index|]
index|[
literal|1
index|]
operator|==
literal|'&'
operator|)
operator|&&
operator|(
name|argv
index|[
name|lastArg
index|]
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|joinThisError
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
name|argv
index|[
name|lastArg
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If this is the last segment, use the specified outputFile. 	 * Otherwise create an intermediate pipe.  pipeIn will become the 	 * curInFile for the next segment of the pipe. 	 */
if|if
condition|(
name|lastArg
operator|==
name|argc
condition|)
block|{
name|curOutFile
operator|=
name|outputFile
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TclpCreatePipe
argument_list|(
operator|&
name|pipeIn
argument_list|,
operator|&
name|curOutFile
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't create pipe: "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
if|if
condition|(
name|joinThisError
operator|!=
literal|0
condition|)
block|{
name|curErrFile
operator|=
name|curOutFile
expr_stmt|;
block|}
else|else
block|{
name|curErrFile
operator|=
name|errorFile
expr_stmt|;
block|}
if|if
condition|(
name|TclpCreateProcess
argument_list|(
name|interp
argument_list|,
name|lastArg
operator|-
name|i
argument_list|,
name|argv
operator|+
name|i
argument_list|,
name|curInFile
argument_list|,
name|curOutFile
argument_list|,
name|curErrFile
argument_list|,
operator|&
name|pid
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|Tcl_DStringFree
argument_list|(
operator|&
name|execBuffer
argument_list|)
expr_stmt|;
name|pidPtr
index|[
name|numPids
index|]
operator|=
name|pid
expr_stmt|;
name|numPids
operator|++
expr_stmt|;
comment|/* 	 * Close off our copies of file descriptors that were set up for 	 * this child, then set up the input for the next child. 	 */
if|if
condition|(
operator|(
name|curInFile
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|curInFile
operator|!=
name|inputFile
operator|)
condition|)
block|{
name|TclpCloseFile
argument_list|(
name|curInFile
argument_list|)
expr_stmt|;
block|}
name|curInFile
operator|=
name|pipeIn
expr_stmt|;
name|pipeIn
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|curOutFile
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|curOutFile
operator|!=
name|outputFile
operator|)
condition|)
block|{
name|TclpCloseFile
argument_list|(
name|curOutFile
argument_list|)
expr_stmt|;
block|}
name|curOutFile
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|pidArrayPtr
operator|=
name|pidPtr
expr_stmt|;
comment|/*      * All done.  Cleanup open files lying around and then return.      */
name|cleanup
label|:
name|Tcl_DStringFree
argument_list|(
operator|&
name|execBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|inputClose
condition|)
block|{
name|TclpCloseFile
argument_list|(
name|inputFile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inputRelease
condition|)
block|{
name|TclpReleaseFile
argument_list|(
name|inputFile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outputClose
condition|)
block|{
name|TclpCloseFile
argument_list|(
name|outputFile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|outputRelease
condition|)
block|{
name|TclpReleaseFile
argument_list|(
name|outputFile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errorClose
condition|)
block|{
name|TclpCloseFile
argument_list|(
name|errorFile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errorRelease
condition|)
block|{
name|TclpReleaseFile
argument_list|(
name|errorFile
argument_list|)
expr_stmt|;
block|}
return|return
name|numPids
return|;
comment|/*      * An error occurred.  There could have been extra files open, such      * as pipes between children.  Clean them all up.  Detach any child      * processes that have been created.      */
name|error
label|:
if|if
condition|(
name|pipeIn
operator|!=
name|NULL
condition|)
block|{
name|TclpCloseFile
argument_list|(
name|pipeIn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|curOutFile
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|curOutFile
operator|!=
name|outputFile
operator|)
condition|)
block|{
name|TclpCloseFile
argument_list|(
name|curOutFile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|curInFile
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|curInFile
operator|!=
name|inputFile
operator|)
condition|)
block|{
name|TclpCloseFile
argument_list|(
name|curInFile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|inPipePtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|inPipePtr
operator|!=
name|NULL
operator|)
condition|)
block|{
name|TclpCloseFile
argument_list|(
operator|*
name|inPipePtr
argument_list|)
expr_stmt|;
operator|*
name|inPipePtr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|outPipePtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|outPipePtr
operator|!=
name|NULL
operator|)
condition|)
block|{
name|TclpCloseFile
argument_list|(
operator|*
name|outPipePtr
argument_list|)
expr_stmt|;
operator|*
name|outPipePtr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|errFilePtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|errFilePtr
operator|!=
name|NULL
operator|)
condition|)
block|{
name|TclpCloseFile
argument_list|(
operator|*
name|errFilePtr
argument_list|)
expr_stmt|;
operator|*
name|errFilePtr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pidPtr
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numPids
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pidPtr
index|[
name|i
index|]
operator|!=
operator|(
name|Tcl_Pid
operator|)
operator|-
literal|1
condition|)
block|{
name|Tcl_DetachPids
argument_list|(
literal|1
argument_list|,
operator|&
name|pidPtr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pidPtr
argument_list|)
expr_stmt|;
block|}
name|numPids
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_OpenCommandChannel --  *  *	Opens an I/O channel to one or more subprocesses specified  *	by argc and argv.  The flags argument determines the  *	disposition of the stdio handles.  If the TCL_STDIN flag is  *	set then the standard input for the first subprocess will  *	be tied to the channel:  writing to the channel will provide  *	input to the subprocess.  If TCL_STDIN is not set, then  *	standard input for the first subprocess will be the same as  *	this application's standard input.  If TCL_STDOUT is set then  *	standard output from the last subprocess can be read from the  *	channel;  otherwise it goes to this application's standard  *	output.  If TCL_STDERR is set, standard error output for all  *	subprocesses is returned to the channel and results in an error  *	when the channel is closed;  otherwise it goes to this  *	application's standard error.  If TCL_ENFORCE_MODE is not set,  *	then argc and argv can redirect the stdio handles to override  *	TCL_STDIN, TCL_STDOUT, and TCL_STDERR;  if it is set, then it   *	is an error for argc and argv to override stdio channels for  *	which TCL_STDIN, TCL_STDOUT, and TCL_STDERR have been set.  *  * Results:  *	A new command channel, or NULL on failure with an error  *	message left in interp.  *  * Side effects:  *	Creates processes, opens pipes.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Channel
name|Tcl_OpenCommandChannel
parameter_list|(
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter for error reporting. Can                                  * NOT be NULL. */
name|int
name|argc
decl_stmt|;
comment|/* How many arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Array of arguments for command pipe. */
name|int
name|flags
decl_stmt|;
comment|/* Or'ed combination of TCL_STDIN, TCL_STDOUT, 				 * TCL_STDERR, and TCL_ENFORCE_MODE. */
block|{
name|TclFile
modifier|*
name|inPipePtr
decl_stmt|,
modifier|*
name|outPipePtr
decl_stmt|,
modifier|*
name|errFilePtr
decl_stmt|;
name|TclFile
name|inPipe
decl_stmt|,
name|outPipe
decl_stmt|,
name|errFile
decl_stmt|;
name|int
name|numPids
decl_stmt|;
name|Tcl_Pid
modifier|*
name|pidPtr
decl_stmt|;
name|Tcl_Channel
name|channel
decl_stmt|;
name|inPipe
operator|=
name|outPipe
operator|=
name|errFile
operator|=
name|NULL
expr_stmt|;
name|inPipePtr
operator|=
operator|(
name|flags
operator|&
name|TCL_STDIN
operator|)
condition|?
operator|&
name|inPipe
else|:
name|NULL
expr_stmt|;
name|outPipePtr
operator|=
operator|(
name|flags
operator|&
name|TCL_STDOUT
operator|)
condition|?
operator|&
name|outPipe
else|:
name|NULL
expr_stmt|;
name|errFilePtr
operator|=
operator|(
name|flags
operator|&
name|TCL_STDERR
operator|)
condition|?
operator|&
name|errFile
else|:
name|NULL
expr_stmt|;
name|numPids
operator|=
name|TclCreatePipeline
argument_list|(
name|interp
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|pidPtr
argument_list|,
name|inPipePtr
argument_list|,
name|outPipePtr
argument_list|,
name|errFilePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|numPids
operator|<
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/*      * Verify that the pipes that were created satisfy the      * readable/writable constraints.       */
if|if
condition|(
name|flags
operator|&
name|TCL_ENFORCE_MODE
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|TCL_STDOUT
operator|)
operator|&&
operator|(
name|outPipe
operator|==
name|NULL
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"can't read output from command:"
argument_list|,
literal|" standard output was redirected"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|TCL_STDIN
operator|)
operator|&&
operator|(
name|inPipe
operator|==
name|NULL
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"can't write input to command:"
argument_list|,
literal|" standard input was redirected"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
name|channel
operator|=
name|TclpCreateCommandChannel
argument_list|(
name|outPipe
argument_list|,
name|inPipe
argument_list|,
name|errFile
argument_list|,
name|numPids
argument_list|,
name|pidPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"pipe for command could not be created"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
return|return
name|channel
return|;
name|error
label|:
if|if
condition|(
name|numPids
operator|>
literal|0
condition|)
block|{
name|Tcl_DetachPids
argument_list|(
name|numPids
argument_list|,
name|pidPtr
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pidPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inPipe
operator|!=
name|NULL
condition|)
block|{
name|TclpCloseFile
argument_list|(
name|inPipe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outPipe
operator|!=
name|NULL
condition|)
block|{
name|TclpCloseFile
argument_list|(
name|outPipe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errFile
operator|!=
name|NULL
condition|)
block|{
name|TclpCloseFile
argument_list|(
name|errFile
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

end_unit

