begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclBasic.c --  *  *	Contains the basic facilities for TCL command interpretation,  *	including interpreter creation and deletion, command creation  *	and deletion, and command parsing and execution.  *  * Copyright (c) 1987-1994 The Regents of the University of California.  * Copyright (c) 1994-1996 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclBasic.c 1.211 96/05/10 17:48:04  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TCL_GENERIC_ONLY
end_ifndef

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"patchlevel.h"
end_include

begin_comment
comment|/*  * This variable indicates to the close procedures of channel drivers that  * we are in the middle of an interpreter deletion, and hence in "implicit"  * close mode. In that mode, the close procedures should not close the  * OS handle for standard IO channels. Since interpreter deletion may be  * recursive, this variable is actually a counter of the levels of nesting.  */
end_comment

begin_decl_stmt
name|int
name|tclInInterpreterDeletion
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Static procedures in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DeleteInterpProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The following structure defines all of the commands in the Tcl core,  * and the C procedures that execute them.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of command. */
name|Tcl_CmdProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure that executes command. */
block|}
name|CmdInfo
typedef|;
end_typedef

begin_comment
comment|/*  * Built-in commands, and the procedures associated with them:  */
end_comment

begin_decl_stmt
specifier|static
name|CmdInfo
name|builtInCmds
index|[]
init|=
block|{
comment|/*      * Commands in the generic core:      */
block|{
literal|"append"
block|,
name|Tcl_AppendCmd
block|}
block|,
block|{
literal|"array"
block|,
name|Tcl_ArrayCmd
block|}
block|,
block|{
literal|"break"
block|,
name|Tcl_BreakCmd
block|}
block|,
block|{
literal|"case"
block|,
name|Tcl_CaseCmd
block|}
block|,
block|{
literal|"catch"
block|,
name|Tcl_CatchCmd
block|}
block|,
block|{
literal|"clock"
block|,
name|Tcl_ClockCmd
block|}
block|,
block|{
literal|"concat"
block|,
name|Tcl_ConcatCmd
block|}
block|,
block|{
literal|"continue"
block|,
name|Tcl_ContinueCmd
block|}
block|,
block|{
literal|"error"
block|,
name|Tcl_ErrorCmd
block|}
block|,
block|{
literal|"eval"
block|,
name|Tcl_EvalCmd
block|}
block|,
block|{
literal|"exit"
block|,
name|Tcl_ExitCmd
block|}
block|,
block|{
literal|"expr"
block|,
name|Tcl_ExprCmd
block|}
block|,
block|{
literal|"fileevent"
block|,
name|Tcl_FileEventCmd
block|}
block|,
block|{
literal|"for"
block|,
name|Tcl_ForCmd
block|}
block|,
block|{
literal|"foreach"
block|,
name|Tcl_ForeachCmd
block|}
block|,
block|{
literal|"format"
block|,
name|Tcl_FormatCmd
block|}
block|,
block|{
literal|"global"
block|,
name|Tcl_GlobalCmd
block|}
block|,
block|{
literal|"history"
block|,
name|Tcl_HistoryCmd
block|}
block|,
block|{
literal|"if"
block|,
name|Tcl_IfCmd
block|}
block|,
block|{
literal|"incr"
block|,
name|Tcl_IncrCmd
block|}
block|,
block|{
literal|"info"
block|,
name|Tcl_InfoCmd
block|}
block|,
block|{
literal|"interp"
block|,
name|Tcl_InterpCmd
block|}
block|,
block|{
literal|"join"
block|,
name|Tcl_JoinCmd
block|}
block|,
block|{
literal|"lappend"
block|,
name|Tcl_LappendCmd
block|}
block|,
block|{
literal|"lindex"
block|,
name|Tcl_LindexCmd
block|}
block|,
block|{
literal|"linsert"
block|,
name|Tcl_LinsertCmd
block|}
block|,
block|{
literal|"list"
block|,
name|Tcl_ListCmd
block|}
block|,
block|{
literal|"llength"
block|,
name|Tcl_LlengthCmd
block|}
block|,
block|{
literal|"load"
block|,
name|Tcl_LoadCmd
block|}
block|,
block|{
literal|"lrange"
block|,
name|Tcl_LrangeCmd
block|}
block|,
block|{
literal|"lreplace"
block|,
name|Tcl_LreplaceCmd
block|}
block|,
block|{
literal|"lsearch"
block|,
name|Tcl_LsearchCmd
block|}
block|,
block|{
literal|"lsort"
block|,
name|Tcl_LsortCmd
block|}
block|,
block|{
literal|"package"
block|,
name|Tcl_PackageCmd
block|}
block|,
block|{
literal|"proc"
block|,
name|Tcl_ProcCmd
block|}
block|,
block|{
literal|"regexp"
block|,
name|Tcl_RegexpCmd
block|}
block|,
block|{
literal|"regsub"
block|,
name|Tcl_RegsubCmd
block|}
block|,
block|{
literal|"rename"
block|,
name|Tcl_RenameCmd
block|}
block|,
block|{
literal|"return"
block|,
name|Tcl_ReturnCmd
block|}
block|,
block|{
literal|"scan"
block|,
name|Tcl_ScanCmd
block|}
block|,
block|{
literal|"set"
block|,
name|Tcl_SetCmd
block|}
block|,
block|{
literal|"split"
block|,
name|Tcl_SplitCmd
block|}
block|,
block|{
literal|"string"
block|,
name|Tcl_StringCmd
block|}
block|,
block|{
literal|"subst"
block|,
name|Tcl_SubstCmd
block|}
block|,
block|{
literal|"switch"
block|,
name|Tcl_SwitchCmd
block|}
block|,
block|{
literal|"trace"
block|,
name|Tcl_TraceCmd
block|}
block|,
block|{
literal|"unset"
block|,
name|Tcl_UnsetCmd
block|}
block|,
block|{
literal|"uplevel"
block|,
name|Tcl_UplevelCmd
block|}
block|,
block|{
literal|"upvar"
block|,
name|Tcl_UpvarCmd
block|}
block|,
block|{
literal|"while"
block|,
name|Tcl_WhileCmd
block|}
block|,
comment|/*      * Commands in the UNIX core:      */
ifndef|#
directive|ifndef
name|TCL_GENERIC_ONLY
block|{
literal|"after"
block|,
name|Tcl_AfterCmd
block|}
block|,
block|{
literal|"cd"
block|,
name|Tcl_CdCmd
block|}
block|,
block|{
literal|"close"
block|,
name|Tcl_CloseCmd
block|}
block|,
block|{
literal|"eof"
block|,
name|Tcl_EofCmd
block|}
block|,
block|{
literal|"fblocked"
block|,
name|Tcl_FblockedCmd
block|}
block|,
block|{
literal|"fconfigure"
block|,
name|Tcl_FconfigureCmd
block|}
block|,
block|{
literal|"file"
block|,
name|Tcl_FileCmd
block|}
block|,
block|{
literal|"flush"
block|,
name|Tcl_FlushCmd
block|}
block|,
block|{
literal|"gets"
block|,
name|Tcl_GetsCmd
block|}
block|,
block|{
literal|"glob"
block|,
name|Tcl_GlobCmd
block|}
block|,
block|{
literal|"open"
block|,
name|Tcl_OpenCmd
block|}
block|,
block|{
literal|"pid"
block|,
name|Tcl_PidCmd
block|}
block|,
block|{
literal|"puts"
block|,
name|Tcl_PutsCmd
block|}
block|,
block|{
literal|"pwd"
block|,
name|Tcl_PwdCmd
block|}
block|,
block|{
literal|"read"
block|,
name|Tcl_ReadCmd
block|}
block|,
block|{
literal|"seek"
block|,
name|Tcl_SeekCmd
block|}
block|,
block|{
literal|"socket"
block|,
name|Tcl_SocketCmd
block|}
block|,
block|{
literal|"tell"
block|,
name|Tcl_TellCmd
block|}
block|,
block|{
literal|"time"
block|,
name|Tcl_TimeCmd
block|}
block|,
block|{
literal|"update"
block|,
name|Tcl_UpdateCmd
block|}
block|,
block|{
literal|"vwait"
block|,
name|Tcl_VwaitCmd
block|}
block|,
block|{
literal|"unsupported0"
block|,
name|TclUnsupported0Cmd
block|}
block|,
ifndef|#
directive|ifndef
name|MAC_TCL
block|{
literal|"exec"
block|,
name|Tcl_ExecCmd
block|}
block|,
block|{
literal|"source"
block|,
name|Tcl_SourceCmd
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MAC_TCL
block|{
literal|"beep"
block|,
name|Tcl_MacBeepCmd
block|}
block|,
block|{
literal|"cp"
block|,
name|Tcl_CpCmd
block|}
block|,
block|{
literal|"echo"
block|,
name|Tcl_EchoCmd
block|}
block|,
block|{
literal|"ls"
block|,
name|Tcl_LsCmd
block|}
block|,
block|{
literal|"mkdir"
block|,
name|Tcl_MkdirCmd
block|}
block|,
block|{
literal|"mv"
block|,
name|Tcl_MvCmd
block|}
block|,
block|{
literal|"rm"
block|,
name|Tcl_RmCmd
block|}
block|,
block|{
literal|"rmdir"
block|,
name|Tcl_RmdirCmd
block|}
block|,
block|{
literal|"source"
block|,
name|Tcl_MacSourceCmd
block|}
block|,
endif|#
directive|endif
comment|/* MAC_TCL */
endif|#
directive|endif
comment|/* TCL_GENERIC_ONLY */
block|{
name|NULL
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CreateInterp --  *  *	Create a new TCL command interpreter.  *  * Results:  *	The return value is a token for the interpreter, which may be  *	used in calls to procedures like Tcl_CreateCmd, Tcl_Eval, or  *	Tcl_DeleteInterp.  *  * Side effects:  *	The command interpreter is initialized with an empty variable  *	table and the built-in commands.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Interp
modifier|*
name|Tcl_CreateInterp
parameter_list|()
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
decl_stmt|;
specifier|register
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
specifier|register
name|CmdInfo
modifier|*
name|cmdInfoPtr
decl_stmt|;
name|Tcl_Channel
name|chan
decl_stmt|;
name|int
name|i
decl_stmt|;
name|iPtr
operator|=
operator|(
name|Interp
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Interp
argument_list|)
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|result
operator|=
name|iPtr
operator|->
name|resultSpace
expr_stmt|;
name|iPtr
operator|->
name|freeProc
operator|=
literal|0
expr_stmt|;
name|iPtr
operator|->
name|errorLine
operator|=
literal|0
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
operator|&
name|iPtr
operator|->
name|commandTable
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
operator|&
name|iPtr
operator|->
name|mathFuncTable
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
operator|&
name|iPtr
operator|->
name|globalTable
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|numLevels
operator|=
literal|0
expr_stmt|;
name|iPtr
operator|->
name|maxNestingDepth
operator|=
literal|1000
expr_stmt|;
name|iPtr
operator|->
name|framePtr
operator|=
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|varFramePtr
operator|=
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|activeTracePtr
operator|=
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|returnCode
operator|=
name|TCL_OK
expr_stmt|;
name|iPtr
operator|->
name|errorInfo
operator|=
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|errorCode
operator|=
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|numEvents
operator|=
literal|0
expr_stmt|;
name|iPtr
operator|->
name|events
operator|=
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|curEvent
operator|=
literal|0
expr_stmt|;
name|iPtr
operator|->
name|curEventNum
operator|=
literal|0
expr_stmt|;
name|iPtr
operator|->
name|revPtr
operator|=
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|historyFirst
operator|=
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|revDisables
operator|=
literal|1
expr_stmt|;
name|iPtr
operator|->
name|evalFirst
operator|=
name|iPtr
operator|->
name|evalLast
operator|=
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|appendResult
operator|=
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|appendAvl
operator|=
literal|0
expr_stmt|;
name|iPtr
operator|->
name|appendUsed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGEXPS
condition|;
name|i
operator|++
control|)
block|{
name|iPtr
operator|->
name|patterns
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|patLengths
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|iPtr
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|Tcl_InitHashTable
argument_list|(
operator|&
name|iPtr
operator|->
name|packageTable
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|packageUnknown
operator|=
name|NULL
expr_stmt|;
name|strcpy
argument_list|(
name|iPtr
operator|->
name|pdFormat
argument_list|,
name|DEFAULT_PD_FORMAT
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|pdPrec
operator|=
name|DEFAULT_PD_PREC
expr_stmt|;
name|iPtr
operator|->
name|cmdCount
operator|=
literal|0
expr_stmt|;
name|iPtr
operator|->
name|noEval
operator|=
literal|0
expr_stmt|;
name|iPtr
operator|->
name|evalFlags
operator|=
literal|0
expr_stmt|;
name|iPtr
operator|->
name|scriptFile
operator|=
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|iPtr
operator|->
name|tracePtr
operator|=
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|assocData
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|resultSpace
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/*      * Create the built-in commands.  Do it here, rather than calling      * Tcl_CreateCommand, because it's faster (there's no need to      * check for a pre-existing command by the same name).      */
for|for
control|(
name|cmdInfoPtr
operator|=
name|builtInCmds
init|;
name|cmdInfoPtr
operator|->
name|name
operator|!=
name|NULL
condition|;
name|cmdInfoPtr
operator|++
control|)
block|{
name|int
name|new
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|commandTable
argument_list|,
name|cmdInfoPtr
operator|->
name|name
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Command
argument_list|)
argument_list|)
expr_stmt|;
name|cmdPtr
operator|->
name|hPtr
operator|=
name|hPtr
expr_stmt|;
name|cmdPtr
operator|->
name|proc
operator|=
name|cmdInfoPtr
operator|->
name|proc
expr_stmt|;
name|cmdPtr
operator|->
name|clientData
operator|=
operator|(
name|ClientData
operator|)
name|NULL
expr_stmt|;
name|cmdPtr
operator|->
name|deleteProc
operator|=
name|NULL
expr_stmt|;
name|cmdPtr
operator|->
name|deleteData
operator|=
operator|(
name|ClientData
operator|)
name|NULL
expr_stmt|;
name|cmdPtr
operator|->
name|deleted
operator|=
literal|0
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
name|cmdPtr
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|TCL_GENERIC_ONLY
name|TclSetupEnv
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * Do Safe-Tcl init stuff      */
operator|(
name|void
operator|)
name|TclInterpInit
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|)
expr_stmt|;
comment|/*      * Set up variables such as tcl_library and tcl_precision.      */
name|TclPlatformInit
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|)
expr_stmt|;
name|Tcl_SetVar
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"tcl_patchLevel"
argument_list|,
name|TCL_PATCH_LEVEL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|Tcl_SetVar
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"tcl_version"
argument_list|,
name|TCL_VERSION
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|Tcl_TraceVar2
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"tcl_precision"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
operator||
name|TCL_TRACE_WRITES
operator||
name|TCL_TRACE_UNSETS
argument_list|,
name|TclPrecTraceProc
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/*      * Register Tcl's version number.      */
name|Tcl_PkgProvide
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"Tcl"
argument_list|,
name|TCL_VERSION
argument_list|)
expr_stmt|;
comment|/*      * Add the standard channels.      */
name|chan
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|!=
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
name|Tcl_RegisterChannel
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
name|chan
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|!=
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
name|Tcl_RegisterChannel
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
name|chan
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|!=
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
name|Tcl_RegisterChannel
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * Tcl_CallWhenDeleted --  *  *	Arrange for a procedure to be called before a given  *	interpreter is deleted. The procedure is called as soon  *	as Tcl_DeleteInterp is called; if Tcl_CallWhenDeleted is  *	called on an interpreter that has already been deleted,  *	the procedure will be called when the last Tcl_Release is  *	done on the interpreter.  *  * Results:  *	None.  *  * Side effects:  *	When Tcl_DeleteInterp is invoked to delete interp,  *	proc will be invoked.  See the manual entry for  *	details.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_CallWhenDeleted
parameter_list|(
name|interp
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to watch. */
name|Tcl_InterpDeleteProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to call when interpreter 				 * is about to be deleted. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* One-word value to pass to proc. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
specifier|static
name|int
name|assocDataCounter
init|=
literal|0
decl_stmt|;
name|int
name|new
decl_stmt|;
name|char
name|buffer
index|[
literal|128
index|]
decl_stmt|;
name|AssocData
modifier|*
name|dPtr
init|=
operator|(
name|AssocData
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|AssocData
argument_list|)
argument_list|)
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"Assoc Data Key #%d"
argument_list|,
name|assocDataCounter
argument_list|)
expr_stmt|;
name|assocDataCounter
operator|++
expr_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|assocData
operator|==
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
condition|)
block|{
name|iPtr
operator|->
name|assocData
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Tcl_HashTable
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
name|iPtr
operator|->
name|assocData
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
block|}
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
name|iPtr
operator|->
name|assocData
argument_list|,
name|buffer
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
name|dPtr
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|dPtr
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
name|dPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * Tcl_DontCallWhenDeleted --  *  *	Cancel the arrangement for a procedure to be called when  *	a given interpreter is deleted.  *  * Results:  *	None.  *  * Side effects:  *	If proc and clientData were previously registered as a  *	callback via Tcl_CallWhenDeleted, they are unregistered.  *	If they weren't previously registered then nothing  *	happens.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DontCallWhenDeleted
parameter_list|(
name|interp
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to watch. */
name|Tcl_InterpDeleteProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to call when interpreter 				 * is about to be deleted. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* One-word value to pass to proc. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Tcl_HashTable
modifier|*
name|hTablePtr
decl_stmt|;
name|Tcl_HashSearch
name|hSearch
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|AssocData
modifier|*
name|dPtr
decl_stmt|;
name|hTablePtr
operator|=
name|iPtr
operator|->
name|assocData
expr_stmt|;
if|if
condition|(
name|hTablePtr
operator|==
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
condition|)
block|{
return|return;
block|}
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|hTablePtr
argument_list|,
operator|&
name|hSearch
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|hSearch
argument_list|)
control|)
block|{
name|dPtr
operator|=
operator|(
name|AssocData
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dPtr
operator|->
name|proc
operator|==
name|proc
operator|)
operator|&&
operator|(
name|dPtr
operator|->
name|clientData
operator|==
name|clientData
operator|)
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dPtr
argument_list|)
expr_stmt|;
name|Tcl_DeleteHashEntry
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetAssocData --  *  *	Creates a named association between user-specified data, a delete  *	function and this interpreter. If the association already exists  *	the data is overwritten with the new data. The delete function will  *	be invoked when the interpreter is deleted.  *  * Results:  *	None.  *  * Side effects:  *	Sets the associated data, creates the association if needed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_SetAssocData
parameter_list|(
name|interp
parameter_list|,
name|name
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to associate with. */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name for association. */
name|Tcl_InterpDeleteProc
modifier|*
name|proc
decl_stmt|;
comment|/* Proc to call when interpreter is                                  * about to be deleted. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* One-word value to pass to proc. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|AssocData
modifier|*
name|dPtr
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|int
name|new
decl_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|assocData
operator|==
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
condition|)
block|{
name|iPtr
operator|->
name|assocData
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Tcl_HashTable
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
name|iPtr
operator|->
name|assocData
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
block|}
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
name|iPtr
operator|->
name|assocData
argument_list|,
name|name
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
condition|)
block|{
name|dPtr
operator|=
operator|(
name|AssocData
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dPtr
operator|=
operator|(
name|AssocData
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|AssocData
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dPtr
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|dPtr
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
name|dPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DeleteAssocData --  *  *	Deletes a named association of user-specified data with  *	the specified interpreter.  *  * Results:  *	None.  *  * Side effects:  *	Deletes the association.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DeleteAssocData
parameter_list|(
name|interp
parameter_list|,
name|name
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to associate with. */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of association. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|AssocData
modifier|*
name|dPtr
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|assocData
operator|==
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
condition|)
block|{
return|return;
block|}
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
name|iPtr
operator|->
name|assocData
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|)
block|{
return|return;
block|}
name|dPtr
operator|=
operator|(
name|AssocData
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dPtr
operator|->
name|proc
operator|!=
name|NULL
condition|)
block|{
call|(
name|dPtr
operator|->
name|proc
call|)
argument_list|(
name|dPtr
operator|->
name|clientData
argument_list|,
name|interp
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dPtr
argument_list|)
expr_stmt|;
name|Tcl_DeleteHashEntry
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetAssocData --  *  *	Returns the client data associated with this name in the  *	specified interpreter.  *  * Results:  *	The client data in the AssocData record denoted by the named  *	association, or NULL.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|ClientData
name|Tcl_GetAssocData
parameter_list|(
name|interp
parameter_list|,
name|name
parameter_list|,
name|procPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter associated with. */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of association. */
name|Tcl_InterpDeleteProc
modifier|*
modifier|*
name|procPtr
decl_stmt|;
comment|/* Pointer to place to store address 					 * of current deletion callback. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|AssocData
modifier|*
name|dPtr
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|assocData
operator|==
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
operator|(
name|ClientData
operator|)
name|NULL
return|;
block|}
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
name|iPtr
operator|->
name|assocData
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
operator|(
name|ClientData
operator|)
name|NULL
return|;
block|}
name|dPtr
operator|=
operator|(
name|AssocData
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|procPtr
operator|!=
operator|(
name|Tcl_InterpDeleteProc
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
operator|*
name|procPtr
operator|=
name|dPtr
operator|->
name|proc
expr_stmt|;
block|}
return|return
name|dPtr
operator|->
name|clientData
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DeleteInterpProc --  *  *	Helper procedure to delete an interpreter. This procedure is  *	called when the last call to Tcl_Preserve on this interpreter  *	is matched by a call to Tcl_Release. The procedure cleans up  *	all resources used in the interpreter and calls all currently  *	registered interpreter deletion callbacks.  *  * Results:  *	None.  *  * Side effects:  *	Whatever the interpreter deletion callbacks do. Frees resources  *	used by the interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|DeleteInterpProc
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to delete. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|Tcl_HashSearch
name|search
decl_stmt|;
name|int
name|i
decl_stmt|;
name|Tcl_HashTable
modifier|*
name|hTablePtr
decl_stmt|;
name|AssocData
modifier|*
name|dPtr
decl_stmt|;
comment|/*      * Punt if there is an error in the Tcl_Release/Tcl_Preserve matchup.      */
if|if
condition|(
name|iPtr
operator|->
name|numLevels
operator|>
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"DeleteInterpProc called with active evals"
argument_list|)
expr_stmt|;
block|}
comment|/*      * The interpreter should already be marked deleted; otherwise how      * did we get here?      */
if|if
condition|(
operator|!
operator|(
name|iPtr
operator|->
name|flags
operator|&
name|DELETED
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"DeleteInterpProc called on interpreter not marked deleted"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Increment the interp deletion counter, so that close procedures      * for channel drivers can notice that we are in "implicit" close mode.      */
name|tclInInterpreterDeletion
operator|++
expr_stmt|;
comment|/*      * First delete all the commands.  There's a special hack here      * because "tkerror" is just a synonym for "bgerror" (they share      * a Command structure).  Just delete the hash table entry for      * "tkerror" without invoking its callback or cleaning up its      * Command structure.      */
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|commandTable
argument_list|,
literal|"tkerror"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DeleteHashEntry
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|commandTable
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|commandTable
argument_list|,
operator|&
name|search
argument_list|)
control|)
block|{
name|Tcl_DeleteCommand
argument_list|(
name|interp
argument_list|,
name|Tcl_GetHashKey
argument_list|(
operator|&
name|iPtr
operator|->
name|commandTable
argument_list|,
name|hPtr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Tcl_DeleteHashTable
argument_list|(
operator|&
name|iPtr
operator|->
name|commandTable
argument_list|)
expr_stmt|;
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|mathFuncTable
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Tcl_DeleteHashTable
argument_list|(
operator|&
name|iPtr
operator|->
name|mathFuncTable
argument_list|)
expr_stmt|;
comment|/*      * Invoke deletion callbacks; note that a callback can create new      * callbacks, so we iterate.      */
while|while
condition|(
name|iPtr
operator|->
name|assocData
operator|!=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
condition|)
block|{
name|hTablePtr
operator|=
name|iPtr
operator|->
name|assocData
expr_stmt|;
name|iPtr
operator|->
name|assocData
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|hTablePtr
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|hTablePtr
argument_list|,
operator|&
name|search
argument_list|)
control|)
block|{
name|dPtr
operator|=
operator|(
name|AssocData
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
name|Tcl_DeleteHashEntry
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dPtr
operator|->
name|proc
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|dPtr
operator|->
name|proc
call|)
argument_list|(
name|dPtr
operator|->
name|clientData
argument_list|,
name|interp
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dPtr
argument_list|)
expr_stmt|;
block|}
name|Tcl_DeleteHashTable
argument_list|(
name|hTablePtr
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hTablePtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * Delete all global variables:      */
name|TclDeleteVars
argument_list|(
name|iPtr
argument_list|,
operator|&
name|iPtr
operator|->
name|globalTable
argument_list|)
expr_stmt|;
comment|/*      * Free up the result *after* deleting variables, since variable      * deletion could have transferred ownership of the result string      * to Tcl.      */
name|Tcl_FreeResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|interp
operator|->
name|result
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|errorInfo
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|iPtr
operator|->
name|errorInfo
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|errorInfo
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|iPtr
operator|->
name|errorCode
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|iPtr
operator|->
name|errorCode
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|errorCode
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|iPtr
operator|->
name|events
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iPtr
operator|->
name|numEvents
condition|;
name|i
operator|++
control|)
block|{
name|ckfree
argument_list|(
name|iPtr
operator|->
name|events
index|[
name|i
index|]
operator|.
name|command
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iPtr
operator|->
name|events
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|events
operator|=
name|NULL
expr_stmt|;
block|}
while|while
condition|(
name|iPtr
operator|->
name|revPtr
operator|!=
name|NULL
condition|)
block|{
name|HistoryRev
modifier|*
name|nextPtr
init|=
name|iPtr
operator|->
name|revPtr
operator|->
name|nextPtr
decl_stmt|;
name|ckfree
argument_list|(
name|iPtr
operator|->
name|revPtr
operator|->
name|newBytes
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iPtr
operator|->
name|revPtr
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|revPtr
operator|=
name|nextPtr
expr_stmt|;
block|}
if|if
condition|(
name|iPtr
operator|->
name|appendResult
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|iPtr
operator|->
name|appendResult
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|appendResult
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGEXPS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|iPtr
operator|->
name|patterns
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|ckfree
argument_list|(
name|iPtr
operator|->
name|patterns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iPtr
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|TclFreePackageInfo
argument_list|(
name|iPtr
argument_list|)
expr_stmt|;
while|while
condition|(
name|iPtr
operator|->
name|tracePtr
operator|!=
name|NULL
condition|)
block|{
name|Trace
modifier|*
name|nextPtr
init|=
name|iPtr
operator|->
name|tracePtr
operator|->
name|nextPtr
decl_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iPtr
operator|->
name|tracePtr
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|tracePtr
operator|=
name|nextPtr
expr_stmt|;
block|}
comment|/*      * Finally decrement the nested interpreter deletion counter.      */
name|tclInInterpreterDeletion
operator|--
expr_stmt|;
if|if
condition|(
name|tclInInterpreterDeletion
operator|<
literal|0
condition|)
block|{
name|tclInInterpreterDeletion
operator|=
literal|0
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_InterpDeleted --  *  *	Returns nonzero if the interpreter has been deleted with a call  *	to Tcl_DeleteInterp.  *  * Results:  *	Nonzero if the interpreter is deleted, zero otherwise.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_InterpDeleted
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|(
name|Interp
operator|*
operator|)
name|interp
operator|)
operator|->
name|flags
operator|&
name|DELETED
operator|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DeleteInterp --  *  *	Ensures that the interpreter will be deleted eventually. If there  *	are no Tcl_Preserve calls in effect for this interpreter, it is  *	deleted immediately, otherwise the interpreter is deleted when  *	the last Tcl_Preserve is matched by a call to Tcl_Release. In either  *	case, the procedure runs the currently registered deletion callbacks.   *  * Results:  *	None.  *  * Side effects:  *	The interpreter is marked as deleted. The caller may still use it  *	safely if there are calls to Tcl_Preserve in effect for the  *	interpreter, but further calls to Tcl_Eval etc in this interpreter  *	will fail.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DeleteInterp
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Token for command interpreter (returned 				 * by a previous call to Tcl_CreateInterp). */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
comment|/*      * If the interpreter has already been marked deleted, just punt.      */
if|if
condition|(
name|iPtr
operator|->
name|flags
operator|&
name|DELETED
condition|)
block|{
return|return;
block|}
comment|/*      * Mark the interpreter as deleted. No further evals will be allowed.      */
name|iPtr
operator|->
name|flags
operator||=
name|DELETED
expr_stmt|;
comment|/*      * Ensure that the interpreter is eventually deleted.      */
name|Tcl_EventuallyFree
argument_list|(
operator|(
name|ClientData
operator|)
name|interp
argument_list|,
operator|(
name|Tcl_FreeProc
operator|*
operator|)
name|DeleteInterpProc
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CreateCommand --  *  *	Define a new command in a command table.  *  * Results:  *	The return value is a token for the command, which can  *	be used in future calls to Tcl_NameOfCommand.  *  * Side effects:  *	If a command named cmdName already exists for interp, it is  *	deleted.  In the future, when cmdName is seen as the name of  *	a command by Tcl_Eval, proc will be called.  When the command  *	is deleted from the table, deleteProc will be called.  See the  *	manual entry for details on the calling sequence.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Command
name|Tcl_CreateCommand
parameter_list|(
name|interp
parameter_list|,
name|cmdName
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|,
name|deleteProc
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Token for command interpreter (returned 				 * by a previous call to Tcl_CreateInterp). */
name|char
modifier|*
name|cmdName
decl_stmt|;
comment|/* Name of command. */
name|Tcl_CmdProc
modifier|*
name|proc
decl_stmt|;
comment|/* Command procedure to associate with 				 * cmdName. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary one-word value to pass to proc. */
name|Tcl_CmdDeleteProc
modifier|*
name|deleteProc
decl_stmt|;
comment|/* If not NULL, gives a procedure to call when 				 * this command is deleted. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|int
name|new
decl_stmt|;
comment|/*      * The code below was added in 11/95 to preserve backwards compatibility      * when "tkerror" was renamed "bgerror":  if anyone attempts to define      * "tkerror" as a command, it is actually created as "bgerror".  This      * code should eventually be removed.      */
if|if
condition|(
operator|(
name|cmdName
index|[
literal|0
index|]
operator|==
literal|'t'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|cmdName
argument_list|,
literal|"tkerror"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|cmdName
operator|=
literal|"bgerror"
expr_stmt|;
block|}
if|if
condition|(
name|iPtr
operator|->
name|flags
operator|&
name|DELETED
condition|)
block|{
comment|/* 	 * The interpreter is being deleted.  Don't create any new 	 * commands;  it's not safe to muck with the interpreter anymore. 	 */
return|return
operator|(
name|Tcl_Command
operator|)
name|NULL
return|;
block|}
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|commandTable
argument_list|,
name|cmdName
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
block|{
comment|/* 	 * Command already exists:  delete the old one. 	 */
name|Tcl_DeleteCommand
argument_list|(
name|interp
argument_list|,
name|Tcl_GetHashKey
argument_list|(
operator|&
name|iPtr
operator|->
name|commandTable
argument_list|,
name|hPtr
argument_list|)
argument_list|)
expr_stmt|;
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|commandTable
argument_list|,
name|cmdName
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
block|{
comment|/* 	     * Drat.  The stupid deletion callback recreated the command. 	     * Just throw away the new command (if we try to delete it again, 	     * we could get stuck in an infinite loop). 	     */
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Command
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
name|cmdPtr
argument_list|)
expr_stmt|;
name|cmdPtr
operator|->
name|hPtr
operator|=
name|hPtr
expr_stmt|;
name|cmdPtr
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|cmdPtr
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
name|cmdPtr
operator|->
name|deleteProc
operator|=
name|deleteProc
expr_stmt|;
name|cmdPtr
operator|->
name|deleteData
operator|=
name|clientData
expr_stmt|;
name|cmdPtr
operator|->
name|deleted
operator|=
literal|0
expr_stmt|;
comment|/*      * The code below provides more backwards compatibility for the      * renaming of "tkerror" to "bgerror".  Like the code above, this      * code should eventually become unnecessary.      */
if|if
condition|(
operator|(
name|cmdName
index|[
literal|0
index|]
operator|==
literal|'b'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|cmdName
argument_list|,
literal|"bgerror"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 	 * We're currently creating the "bgerror" command;  create 	 * a "tkerror" command that shares the same Command structure. 	 */
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|commandTable
argument_list|,
literal|"tkerror"
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
name|cmdPtr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|Tcl_Command
operator|)
name|cmdPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetCommandInfo --  *  *	Modifies various information about a Tcl command.  *  * Results:  *	If cmdName exists in interp, then the information at *infoPtr  *	is stored with the command in place of the current information  *	and 1 is returned.  If the command doesn't exist then 0 is  *	returned.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_SetCommandInfo
parameter_list|(
name|interp
parameter_list|,
name|cmdName
parameter_list|,
name|infoPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to look 					 * for command. */
name|char
modifier|*
name|cmdName
decl_stmt|;
comment|/* Name of desired command. */
name|Tcl_CmdInfo
modifier|*
name|infoPtr
decl_stmt|;
comment|/* Where to store information about 					 * command. */
block|{
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
operator|(
operator|(
name|Interp
operator|*
operator|)
name|interp
operator|)
operator|->
name|commandTable
argument_list|,
name|cmdName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
name|cmdPtr
operator|->
name|proc
operator|=
name|infoPtr
operator|->
name|proc
expr_stmt|;
name|cmdPtr
operator|->
name|clientData
operator|=
name|infoPtr
operator|->
name|clientData
expr_stmt|;
name|cmdPtr
operator|->
name|deleteProc
operator|=
name|infoPtr
operator|->
name|deleteProc
expr_stmt|;
name|cmdPtr
operator|->
name|deleteData
operator|=
name|infoPtr
operator|->
name|deleteData
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetCommandInfo --  *  *	Returns various information about a Tcl command.  *  * Results:  *	If cmdName exists in interp, then *infoPtr is modified to  *	hold information about cmdName and 1 is returned.  If the  *	command doesn't exist then 0 is returned and *infoPtr isn't  *	modified.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_GetCommandInfo
parameter_list|(
name|interp
parameter_list|,
name|cmdName
parameter_list|,
name|infoPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to look 					 * for command. */
name|char
modifier|*
name|cmdName
decl_stmt|;
comment|/* Name of desired command. */
name|Tcl_CmdInfo
modifier|*
name|infoPtr
decl_stmt|;
comment|/* Where to store information about 					 * command. */
block|{
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
operator|(
operator|(
name|Interp
operator|*
operator|)
name|interp
operator|)
operator|->
name|commandTable
argument_list|,
name|cmdName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
name|infoPtr
operator|->
name|proc
operator|=
name|cmdPtr
operator|->
name|proc
expr_stmt|;
name|infoPtr
operator|->
name|clientData
operator|=
name|cmdPtr
operator|->
name|clientData
expr_stmt|;
name|infoPtr
operator|->
name|deleteProc
operator|=
name|cmdPtr
operator|->
name|deleteProc
expr_stmt|;
name|infoPtr
operator|->
name|deleteData
operator|=
name|cmdPtr
operator|->
name|deleteData
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetCommandName --  *  *	Given a token returned by Tcl_CreateCommand, this procedure  *	returns the current name of the command (which may have changed  *	due to renaming).  *  * Results:  *	The return value is the name of the given command.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_GetCommandName
parameter_list|(
name|interp
parameter_list|,
name|command
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter containing the command. */
name|Tcl_Command
name|command
decl_stmt|;
comment|/* Token for the command, returned by a 				 * previous call to Tcl_CreateCommand. 				 * The command must not have been deleted. */
block|{
name|Command
modifier|*
name|cmdPtr
init|=
operator|(
name|Command
operator|*
operator|)
name|command
decl_stmt|;
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
if|if
condition|(
operator|(
name|cmdPtr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|cmdPtr
operator|->
name|hPtr
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* 	 * This should only happen if command was "created" after the 	 * interpreter began to be deleted, so there isn't really any 	 * command.  Just return an empty string. 	 */
return|return
literal|""
return|;
block|}
return|return
name|Tcl_GetHashKey
argument_list|(
operator|&
name|iPtr
operator|->
name|commandTable
argument_list|,
name|cmdPtr
operator|->
name|hPtr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DeleteCommand --  *  *	Remove the given command from the given interpreter.  *  * Results:  *	0 is returned if the command was deleted successfully.  *	-1 is returned if there didn't exist a command by that  *	name.  *  * Side effects:  *	CmdName will no longer be recognized as a valid command for  *	interp.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_DeleteCommand
parameter_list|(
name|interp
parameter_list|,
name|cmdName
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Token for command interpreter (returned 				 * by a previous call to Tcl_CreateInterp). */
name|char
modifier|*
name|cmdName
decl_stmt|;
comment|/* Name of command to remove. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|,
modifier|*
name|tkErrorHPtr
decl_stmt|;
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
comment|/*      * The code below was added in 11/95 to preserve backwards compatibility      * when "tkerror" was renamed "bgerror":  if anyone attempts to delete      * "tkerror", delete both it  and "bgerror".  This  code should      * eventually be removed.      */
if|if
condition|(
operator|(
name|cmdName
index|[
literal|0
index|]
operator|==
literal|'t'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|cmdName
argument_list|,
literal|"tkerror"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|cmdName
operator|=
literal|"bgerror"
expr_stmt|;
block|}
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|commandTable
argument_list|,
name|cmdName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
name|NULL
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
comment|/*      * The code here is tricky.  We can't delete the hash table entry      * before invoking the deletion callback because there are cases      * where the deletion callback needs to invoke the command (e.g.      * object systems such as OTcl).  However, this means that the      * callback could try to delete or rename the command.  The deleted      * flag allows us to detect these cases and skip nested deletes.      */
if|if
condition|(
name|cmdPtr
operator|->
name|deleted
condition|)
block|{
comment|/* 	 * Another deletion is already in progress.  Remove the hash 	 * table entry now, but don't invoke a callback or free the 	 * command structure. 	 */
name|Tcl_DeleteHashEntry
argument_list|(
name|cmdPtr
operator|->
name|hPtr
argument_list|)
expr_stmt|;
name|cmdPtr
operator|->
name|hPtr
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cmdPtr
operator|->
name|deleted
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cmdPtr
operator|->
name|deleteProc
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|cmdPtr
operator|->
name|deleteProc
call|)
argument_list|(
name|cmdPtr
operator|->
name|deleteData
argument_list|)
expr_stmt|;
block|}
comment|/*      * The code below provides more backwards compatibility for the      * renaming of "tkerror" to "bgerror".  Like the code above, this      * code should eventually become unnecessary.      */
if|if
condition|(
operator|(
name|cmdName
index|[
literal|0
index|]
operator|==
literal|'b'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|cmdName
argument_list|,
literal|"bgerror"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 	 * When the "bgerror" command is deleted, delete "tkerror" 	 * as well.  It shared the same Command structure as "bgerror", 	 * so all we have to do is throw away the hash table entry.          * NOTE: we have to be careful since tkerror may already have          * been deleted before bgerror. 	 */
name|tkErrorHPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|commandTable
argument_list|,
literal|"tkerror"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tkErrorHPtr
operator|!=
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_DeleteHashEntry
argument_list|(
name|tkErrorHPtr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Don't use hPtr to delete the hash entry here, because it's      * possible that the deletion callback renamed the command.      * Instead, use cmdPtr->hptr, and make sure that no-one else      * has already deleted the hash entry.      */
if|if
condition|(
name|cmdPtr
operator|->
name|hPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DeleteHashEntry
argument_list|(
name|cmdPtr
operator|->
name|hPtr
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cmdPtr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *-----------------------------------------------------------------  *  * Tcl_Eval --  *  *	Parse and execute a command in the Tcl language.  *  * Results:  *	The return value is one of the return codes defined in tcl.hd  *	(such as TCL_OK), and interp->result contains a string value  *	to supplement the return code.  The value of interp->result  *	will persist only until the next call to Tcl_Eval:  copy it or  *	lose it! *TermPtr is filled in with the character just after  *	the last one that was part of the command (usually a NULL  *	character or a closing bracket).  *  * Side effects:  *	Almost certainly;  depends on the command.  *  *-----------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_Eval
parameter_list|(
name|interp
parameter_list|,
name|cmd
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Token for command interpreter (returned 				 * by a previous call to Tcl_CreateInterp). */
name|char
modifier|*
name|cmd
decl_stmt|;
comment|/* Pointer to TCL command to interpret. */
block|{
comment|/*      * The storage immediately below is used to generate a copy      * of the command, after all argument substitutions.  Pv will      * contain the argv values passed to the command procedure.      */
define|#
directive|define
name|NUM_CHARS
value|200
name|char
name|copyStorage
index|[
name|NUM_CHARS
index|]
decl_stmt|;
name|ParseValue
name|pv
decl_stmt|;
name|char
modifier|*
name|oldBuffer
decl_stmt|;
comment|/*      * This procedure generates an (argv, argc) array for the command,      * It starts out with stack-allocated space but uses dynamically-      * allocated storage to increase it if needed.      */
define|#
directive|define
name|NUM_ARGS
value|10
name|char
argument_list|*
operator|(
name|argStorage
index|[
name|NUM_ARGS
index|]
operator|)
argument_list|;
name|char
operator|*
operator|*
name|argv
operator|=
name|argStorage
argument_list|;
name|int
name|argc
argument_list|;
name|int
name|argSize
operator|=
name|NUM_ARGS
argument_list|;
specifier|register
name|char
operator|*
name|src
argument_list|;
comment|/* Points to current character 					 * in cmd. */
name|char
name|termChar
argument_list|;
comment|/* Return when this character is found 					 * (either ']' or '\0').  Zero means 					 * that newlines terminate commands. */
name|int
name|flags
argument_list|;
comment|/* Interp->evalFlags value when the 					 * procedure was called. */
name|int
name|result
argument_list|;
comment|/* Return value. */
specifier|register
name|Interp
operator|*
name|iPtr
operator|=
operator|(
name|Interp
operator|*
operator|)
name|interp
argument_list|;
name|Tcl_HashEntry
operator|*
name|hPtr
argument_list|;
name|Command
operator|*
name|cmdPtr
argument_list|;
name|char
operator|*
name|termPtr
argument_list|;
comment|/* Contains character just after the 					 * last one in the command. */
name|char
operator|*
name|cmdStart
argument_list|;
comment|/* Points to first non-blank char. in 					 * command (used in calling trace 					 * procedures). */
name|char
operator|*
name|ellipsis
operator|=
literal|""
argument_list|;
comment|/* Used in setting errorInfo variable; 					 * set to "..." to indicate that not 					 * all of offending command is included 					 * in errorInfo.  "" means that the 					 * command is all there. */
specifier|register
name|Trace
operator|*
name|tracePtr
argument_list|;
name|int
name|oldCount
operator|=
name|iPtr
operator|->
name|cmdCount
argument_list|;
comment|/* Used to tell whether any commands 					 * at all were executed. */
comment|/*      * Initialize the result to an empty string and clear out any      * error information.  This makes sure that we return an empty      * result if there are no commands in the command string.      */
name|Tcl_FreeResult
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|)
argument_list|;
name|iPtr
operator|->
name|result
operator|=
name|iPtr
operator|->
name|resultSpace
argument_list|;
name|iPtr
operator|->
name|resultSpace
index|[
literal|0
index|]
operator|=
literal|0
argument_list|;
name|result
operator|=
name|TCL_OK
argument_list|;
comment|/*      * Initialize the area in which command copies will be assembled.      */
name|pv
operator|.
name|buffer
operator|=
name|copyStorage
argument_list|;
name|pv
operator|.
name|end
operator|=
name|copyStorage
operator|+
name|NUM_CHARS
operator|-
literal|1
argument_list|;
name|pv
operator|.
name|expandProc
operator|=
name|TclExpandParseValue
argument_list|;
name|pv
operator|.
name|clientData
operator|=
operator|(
name|ClientData
operator|)
name|NULL
argument_list|;
name|src
operator|=
name|cmd
argument_list|;
name|flags
operator|=
name|iPtr
operator|->
name|evalFlags
argument_list|;
name|iPtr
operator|->
name|evalFlags
operator|=
literal|0
argument_list|;     if
operator|(
name|flags
operator|&
name|TCL_BRACKET_TERM
operator|)
block|{
name|termChar
operator|=
literal|']'
block|;     }
else|else
block|{
name|termChar
operator|=
literal|0
expr_stmt|;
block|}
name|termPtr
operator|=
name|src
argument_list|;
name|cmdStart
operator|=
name|src
argument_list|;
comment|/*      * Check depth of nested calls to Tcl_Eval:  if this gets too large,      * it's probably because of an infinite loop somewhere.      */
name|iPtr
operator|->
name|numLevels
operator|++
argument_list|;     if
operator|(
name|iPtr
operator|->
name|numLevels
operator|>
name|iPtr
operator|->
name|maxNestingDepth
operator|)
block|{
name|iPtr
operator|->
name|numLevels
operator|--
block|;
name|iPtr
operator|->
name|result
operator|=
literal|"too many nested calls to Tcl_Eval (infinite loop?)"
block|;
name|iPtr
operator|->
name|termPtr
operator|=
name|termPtr
block|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * There can be many sub-commands (separated by semi-colons or      * newlines) in one command string.  This outer loop iterates over      * individual commands.      */
while|while
condition|(
operator|*
name|src
operator|!=
name|termChar
condition|)
block|{
comment|/*          * If we have been deleted, return an error preventing further          * evals.          */
if|if
condition|(
name|iPtr
operator|->
name|flags
operator|&
name|DELETED
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|interp
operator|->
name|result
operator|=
literal|"attempt to call eval in deleted interpreter"
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"CORE"
argument_list|,
literal|"IDELETE"
argument_list|,
name|interp
operator|->
name|result
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|numLevels
operator|--
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|iPtr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|ERR_IN_PROGRESS
operator||
name|ERROR_CODE_SET
operator|)
expr_stmt|;
comment|/* 	 * Skim off leading white space and semi-colons, and skip 	 * comments. 	 */
while|while
condition|(
literal|1
condition|)
block|{
specifier|register
name|char
name|c
init|=
operator|*
name|src
decl_stmt|;
if|if
condition|(
operator|(
name|CHAR_TYPE
argument_list|(
name|c
argument_list|)
operator|!=
name|TCL_SPACE
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|';'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\n'
operator|)
condition|)
block|{
break|break;
block|}
name|src
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|src
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
operator|*
name|src
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|src
operator|==
literal|'\\'
condition|)
block|{
name|int
name|length
decl_stmt|;
name|Tcl_Backslash
argument_list|(
name|src
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|src
operator|+=
name|length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|src
operator|==
literal|'\n'
condition|)
block|{
name|src
operator|++
expr_stmt|;
name|termPtr
operator|=
name|src
expr_stmt|;
break|break;
block|}
else|else
block|{
name|src
operator|++
expr_stmt|;
block|}
block|}
continue|continue;
block|}
name|cmdStart
operator|=
name|src
expr_stmt|;
comment|/* 	 * Parse the words of the command, generating the argc and 	 * argv for the command procedure.  May have to call 	 * TclParseWords several times, expanding the argv array 	 * between calls. 	 */
name|pv
operator|.
name|next
operator|=
name|oldBuffer
operator|=
name|pv
operator|.
name|buffer
expr_stmt|;
name|argc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|newArgs
decl_stmt|,
name|maxArgs
decl_stmt|;
name|char
modifier|*
modifier|*
name|newArgv
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	     * Note:  the "- 2" below guarantees that we won't use the 	     * last two argv slots here.  One is for a NULL pointer to 	     * mark the end of the list, and the other is to leave room 	     * for inserting the command name "unknown" as the first 	     * argument (see below). 	     */
name|maxArgs
operator|=
name|argSize
operator|-
name|argc
operator|-
literal|2
expr_stmt|;
name|result
operator|=
name|TclParseWords
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
name|src
argument_list|,
name|flags
argument_list|,
name|maxArgs
argument_list|,
operator|&
name|termPtr
argument_list|,
operator|&
name|newArgs
argument_list|,
operator|&
name|argv
index|[
name|argc
index|]
argument_list|,
operator|&
name|pv
argument_list|)
expr_stmt|;
name|src
operator|=
name|termPtr
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|ellipsis
operator|=
literal|"..."
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	     * Careful!  Buffer space may have gotten reallocated while 	     * parsing words.  If this happened, be sure to update all 	     * of the older argv pointers to refer to the new space. 	     */
if|if
condition|(
name|oldBuffer
operator|!=
name|pv
operator|.
name|buffer
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|argv
index|[
name|i
index|]
operator|=
name|pv
operator|.
name|buffer
operator|+
operator|(
name|argv
index|[
name|i
index|]
operator|-
name|oldBuffer
operator|)
expr_stmt|;
block|}
name|oldBuffer
operator|=
name|pv
operator|.
name|buffer
expr_stmt|;
block|}
name|argc
operator|+=
name|newArgs
expr_stmt|;
if|if
condition|(
name|newArgs
operator|<
name|maxArgs
condition|)
block|{
name|argv
index|[
name|argc
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* 	     * Args didn't all fit in the current array.  Make it bigger. 	     */
name|argSize
operator|*=
literal|2
expr_stmt|;
name|newArgv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|argSize
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|newArgv
index|[
name|i
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|argv
operator|!=
name|argStorage
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
block|}
name|argv
operator|=
name|newArgv
expr_stmt|;
block|}
comment|/* 	 * If this is an empty command (or if we're just parsing 	 * commands without evaluating them), then just skip to the 	 * next command. 	 */
if|if
condition|(
operator|(
name|argc
operator|==
literal|0
operator|)
operator|||
name|iPtr
operator|->
name|noEval
condition|)
block|{
continue|continue;
block|}
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Save information for the history module, if needed. 	 */
if|if
condition|(
name|flags
operator|&
name|TCL_RECORD_BOUNDS
condition|)
block|{
name|iPtr
operator|->
name|evalFirst
operator|=
name|cmdStart
expr_stmt|;
name|iPtr
operator|->
name|evalLast
operator|=
name|src
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 * Find the procedure to execute this command.  If there isn't 	 * one, then see if there is a command "unknown".  If so, 	 * invoke it instead, passing it the words of the original 	 * command as arguments. 	 */
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|commandTable
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|commandTable
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"invalid command name \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
for|for
control|(
name|i
operator|=
name|argc
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|argv
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
name|argv
index|[
literal|0
index|]
operator|=
literal|"unknown"
expr_stmt|;
name|argc
operator|++
expr_stmt|;
block|}
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
comment|/* 	 * Call trace procedures, if any. 	 */
for|for
control|(
name|tracePtr
operator|=
name|iPtr
operator|->
name|tracePtr
init|;
name|tracePtr
operator|!=
name|NULL
condition|;
name|tracePtr
operator|=
name|tracePtr
operator|->
name|nextPtr
control|)
block|{
name|char
name|saved
decl_stmt|;
if|if
condition|(
name|tracePtr
operator|->
name|level
operator|<
name|iPtr
operator|->
name|numLevels
condition|)
block|{
continue|continue;
block|}
name|saved
operator|=
operator|*
name|src
expr_stmt|;
operator|*
name|src
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|tracePtr
operator|->
name|proc
call|)
argument_list|(
name|tracePtr
operator|->
name|clientData
argument_list|,
name|interp
argument_list|,
name|iPtr
operator|->
name|numLevels
argument_list|,
name|cmdStart
argument_list|,
name|cmdPtr
operator|->
name|proc
argument_list|,
name|cmdPtr
operator|->
name|clientData
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
operator|*
name|src
operator|=
name|saved
expr_stmt|;
block|}
comment|/* 	 * At long last, invoke the command procedure.  Reset the 	 * result to its default empty value first (it could have 	 * gotten changed by earlier commands in the same command 	 * string). 	 */
name|iPtr
operator|->
name|cmdCount
operator|++
expr_stmt|;
name|Tcl_FreeResult
argument_list|(
name|iPtr
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|result
operator|=
name|iPtr
operator|->
name|resultSpace
expr_stmt|;
name|iPtr
operator|->
name|resultSpace
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|result
operator|=
call|(
modifier|*
name|cmdPtr
operator|->
name|proc
call|)
argument_list|(
name|cmdPtr
operator|->
name|clientData
argument_list|,
name|interp
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_AsyncReady
argument_list|()
condition|)
block|{
name|result
operator|=
name|Tcl_AsyncInvoke
argument_list|(
name|interp
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
break|break;
block|}
block|}
name|done
label|:
comment|/*      * If no commands at all were executed, check for asynchronous      * handlers so that they at least get one change to execute.      * This is needed to handle event loops written in Tcl with      * empty bodies (I'm not sure that loops like this are a good      * idea, * but...).      */
if|if
condition|(
operator|(
name|oldCount
operator|==
name|iPtr
operator|->
name|cmdCount
operator|)
operator|&&
operator|(
name|Tcl_AsyncReady
argument_list|()
operator|)
condition|)
block|{
name|result
operator|=
name|Tcl_AsyncInvoke
argument_list|(
name|interp
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
comment|/*      * Free up any extra resources that were allocated.      */
if|if
condition|(
name|pv
operator|.
name|buffer
operator|!=
name|copyStorage
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pv
operator|.
name|buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argv
operator|!=
name|argStorage
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
block|}
name|iPtr
operator|->
name|numLevels
operator|--
expr_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|numLevels
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_RETURN
condition|)
block|{
name|result
operator|=
name|TclUpdateReturnInfo
argument_list|(
name|iPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|result
operator|!=
name|TCL_OK
operator|)
operator|&&
operator|(
name|result
operator|!=
name|TCL_ERROR
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|TCL_ALLOW_EXCEPTIONS
operator|)
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_BREAK
condition|)
block|{
name|iPtr
operator|->
name|result
operator|=
literal|"invoked \"break\" outside of a loop"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|TCL_CONTINUE
condition|)
block|{
name|iPtr
operator|->
name|result
operator|=
literal|"invoked \"continue\" outside of a loop"
expr_stmt|;
block|}
else|else
block|{
name|iPtr
operator|->
name|result
operator|=
name|iPtr
operator|->
name|resultSpace
expr_stmt|;
name|sprintf
argument_list|(
name|iPtr
operator|->
name|resultSpace
argument_list|,
literal|"command returned bad code: %d"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
block|}
comment|/*      * If an error occurred, record information about what was being      * executed when the error occurred.      */
if|if
condition|(
operator|(
name|result
operator|==
name|TCL_ERROR
operator|)
operator|&&
operator|!
operator|(
name|iPtr
operator|->
name|flags
operator|&
name|ERR_ALREADY_LOGGED
operator|)
condition|)
block|{
name|int
name|numChars
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 	 * Compute the line number where the error occurred. 	 */
name|iPtr
operator|->
name|errorLine
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|cmd
init|;
name|p
operator|!=
name|cmdStart
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
name|iPtr
operator|->
name|errorLine
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|';'
operator|)
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
name|iPtr
operator|->
name|errorLine
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Figure out how much of the command to print in the error 	 * message (up to a certain number of characters, or up to 	 * the first new-line). 	 */
name|numChars
operator|=
name|src
operator|-
name|cmdStart
expr_stmt|;
if|if
condition|(
name|numChars
operator|>
operator|(
name|NUM_CHARS
operator|-
literal|50
operator|)
condition|)
block|{
name|numChars
operator|=
name|NUM_CHARS
operator|-
literal|50
expr_stmt|;
name|ellipsis
operator|=
literal|" ..."
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|iPtr
operator|->
name|flags
operator|&
name|ERR_IN_PROGRESS
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|copyStorage
argument_list|,
literal|"\n    while executing\n\"%.*s%s\""
argument_list|,
name|numChars
argument_list|,
name|cmdStart
argument_list|,
name|ellipsis
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|copyStorage
argument_list|,
literal|"\n    invoked from within\n\"%.*s%s\""
argument_list|,
name|numChars
argument_list|,
name|cmdStart
argument_list|,
name|ellipsis
argument_list|)
expr_stmt|;
block|}
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
name|copyStorage
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|flags
operator|&=
operator|~
name|ERR_ALREADY_LOGGED
expr_stmt|;
block|}
else|else
block|{
name|iPtr
operator|->
name|flags
operator|&=
operator|~
name|ERR_ALREADY_LOGGED
expr_stmt|;
block|}
name|iPtr
operator|->
name|termPtr
operator|=
name|termPtr
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CreateTrace --  *  *	Arrange for a procedure to be called to trace command execution.  *  * Results:  *	The return value is a token for the trace, which may be passed  *	to Tcl_DeleteTrace to eliminate the trace.  *  * Side effects:  *	From now on, proc will be called just before a command procedure  *	is called to execute a Tcl command.  Calls to proc will have the  *	following form:  *  *	void  *	proc(clientData, interp, level, command, cmdProc, cmdClientData,  *		argc, argv)  *	    ClientData clientData;  *	    Tcl_Interp *interp;  *	    int level;  *	    char *command;  *	    int (*cmdProc)();  *	    ClientData cmdClientData;  *	    int argc;  *	    char **argv;  *	{  *	}  *  *	The clientData and interp arguments to proc will be the same  *	as the corresponding arguments to this procedure.  Level gives  *	the nesting level of command interpretation for this interpreter  *	(0 corresponds to top level).  Command gives the ASCII text of  *	the raw command, cmdProc and cmdClientData give the procedure that  *	will be called to process the command and the ClientData value it  *	will receive, and argc and argv give the arguments to the  *	command, after any argument parsing and substitution.  Proc  *	does not return a value.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Trace
name|Tcl_CreateTrace
parameter_list|(
name|interp
parameter_list|,
name|level
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to create the trace. */
name|int
name|level
decl_stmt|;
comment|/* Only call proc for commands at nesting level 				 *<= level (1 => top level). */
name|Tcl_CmdTraceProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to call before executing each 				 * command. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary one-word value to pass to proc. */
block|{
specifier|register
name|Trace
modifier|*
name|tracePtr
decl_stmt|;
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|tracePtr
operator|=
operator|(
name|Trace
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Trace
argument_list|)
argument_list|)
expr_stmt|;
name|tracePtr
operator|->
name|level
operator|=
name|level
expr_stmt|;
name|tracePtr
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|tracePtr
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
name|tracePtr
operator|->
name|nextPtr
operator|=
name|iPtr
operator|->
name|tracePtr
expr_stmt|;
name|iPtr
operator|->
name|tracePtr
operator|=
name|tracePtr
expr_stmt|;
return|return
operator|(
name|Tcl_Trace
operator|)
name|tracePtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DeleteTrace --  *  *	Remove a trace.  *  * Results:  *	None.  *  * Side effects:  *	From now on there will be no more calls to the procedure given  *	in trace.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DeleteTrace
parameter_list|(
name|interp
parameter_list|,
name|trace
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter that contains trace. */
name|Tcl_Trace
name|trace
decl_stmt|;
comment|/* Token for trace (returned previously by 				 * Tcl_CreateTrace). */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
specifier|register
name|Trace
modifier|*
name|tracePtr
init|=
operator|(
name|Trace
operator|*
operator|)
name|trace
decl_stmt|;
specifier|register
name|Trace
modifier|*
name|tracePtr2
decl_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|tracePtr
operator|==
name|tracePtr
condition|)
block|{
name|iPtr
operator|->
name|tracePtr
operator|=
name|tracePtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tracePtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|tracePtr2
operator|=
name|iPtr
operator|->
name|tracePtr
init|;
name|tracePtr2
operator|!=
name|NULL
condition|;
name|tracePtr2
operator|=
name|tracePtr2
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|tracePtr2
operator|->
name|nextPtr
operator|==
name|tracePtr
condition|)
block|{
name|tracePtr2
operator|->
name|nextPtr
operator|=
name|tracePtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tracePtr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_AddErrorInfo --  *  *	Add information to a message being accumulated that describes  *	the current error.  *  * Results:  *	None.  *  * Side effects:  *	The contents of message are added to the "errorInfo" variable.  *	If Tcl_Eval has been called since the current value of errorInfo  *	was set, errorInfo is cleared before adding the new message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_AddErrorInfo
parameter_list|(
name|interp
parameter_list|,
name|message
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to which error information 				 * pertains. */
name|char
modifier|*
name|message
decl_stmt|;
comment|/* Message to record. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
comment|/*      * If an error is already being logged, then the new errorInfo      * is the concatenation of the old info and the new message.      * If this is the first piece of info for the error, then the      * new errorInfo is the concatenation of the message in      * interp->result and the new message.      */
if|if
condition|(
operator|!
operator|(
name|iPtr
operator|->
name|flags
operator|&
name|ERR_IN_PROGRESS
operator|)
condition|)
block|{
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
literal|"errorInfo"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|interp
operator|->
name|result
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|flags
operator||=
name|ERR_IN_PROGRESS
expr_stmt|;
comment|/* 	 * If the errorCode variable wasn't set by the code that generated 	 * the error, set it to "NONE". 	 */
if|if
condition|(
operator|!
operator|(
name|iPtr
operator|->
name|flags
operator|&
name|ERROR_CODE_SET
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|"NONE"
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
block|}
block|}
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
literal|"errorInfo"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|message
argument_list|,
name|TCL_GLOBAL_ONLY
operator||
name|TCL_APPEND_VALUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_VarEval --  *  *	Given a variable number of string arguments, concatenate them  *	all together and execute the result as a Tcl command.  *  * Results:  *	A standard Tcl return result.  An error message or other  *	result may be left in interp->result.  *  * Side effects:  *	Depends on what was done by the command.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* VARARGS2 */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_VarEval
name|TCL_VARARGS_DEF
parameter_list|(
name|Tcl_Interp
modifier|*
parameter_list|,
name|arg1
parameter_list|)
block|{
name|va_list
name|argList
decl_stmt|;
name|Tcl_DString
name|buf
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/*      * Copy the strings one after the other into a single larger      * string.  Use stack-allocated space for small commands, but if      * the command gets too large than call ckalloc to create the      * space.      */
name|interp
operator|=
name|TCL_VARARGS_START
argument_list|(
name|Tcl_Interp
operator|*
argument_list|,
name|arg1
argument_list|,
name|argList
argument_list|)
expr_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|string
operator|=
name|va_arg
argument_list|(
name|argList
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|Tcl_DStringAppend
argument_list|(
operator|&
name|buf
argument_list|,
name|string
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|argList
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GlobalEval --  *  *	Evaluate a command at global level in an interpreter.  *  * Results:  *	A standard Tcl result is returned, and interp->result is  *	modified accordingly.  *  * Side effects:  *	The command string is executed in interp, and the execution  *	is carried out in the variable context of global level (no  *	procedures active), just as if an "uplevel #0" command were  *	being executed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_GlobalEval
parameter_list|(
name|interp
parameter_list|,
name|command
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to evaluate command. */
name|char
modifier|*
name|command
decl_stmt|;
comment|/* Command to evaluate. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|int
name|result
decl_stmt|;
name|CallFrame
modifier|*
name|savedVarFramePtr
decl_stmt|;
name|savedVarFramePtr
operator|=
name|iPtr
operator|->
name|varFramePtr
expr_stmt|;
name|iPtr
operator|->
name|varFramePtr
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|varFramePtr
operator|=
name|savedVarFramePtr
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetRecursionLimit --  *  *	Set the maximum number of recursive calls that may be active  *	for an interpreter at once.  *  * Results:  *	The return value is the old limit on nesting for interp.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_SetRecursionLimit
parameter_list|(
name|interp
parameter_list|,
name|depth
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter whose nesting limit 					 * is to be set. */
name|int
name|depth
decl_stmt|;
comment|/* New value for maximimum depth. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|int
name|old
decl_stmt|;
name|old
operator|=
name|iPtr
operator|->
name|maxNestingDepth
expr_stmt|;
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
block|{
name|iPtr
operator|->
name|maxNestingDepth
operator|=
name|depth
expr_stmt|;
block|}
return|return
name|old
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_AllowExceptions --  *  *	Sets a flag in an interpreter so that exceptions can occur  *	in the next call to Tcl_Eval without them being turned into  *	errors.  *  * Results:  *	None.  *  * Side effects:  *	The TCL_ALLOW_EXCEPTIONS flag gets set in the interpreter's  *	evalFlags structure.  See the reference documentation for  *	more details.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_AllowExceptions
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to set flag. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|iPtr
operator|->
name|evalFlags
operator||=
name|TCL_ALLOW_EXCEPTIONS
expr_stmt|;
block|}
end_function

end_unit

