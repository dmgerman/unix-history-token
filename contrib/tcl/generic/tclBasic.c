begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclBasic.c --  *  *	Contains the basic facilities for TCL command interpretation,  *	including interpreter creation and deletion, command creation  *	and deletion, and command parsing and execution.  *  * Copyright (c) 1987-1994 The Regents of the University of California.  * Copyright (c) 1994-1997 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclBasic.c 1.305 97/08/13 10:34:43  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclCompile.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TCL_GENERIC_ONLY
end_ifndef

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Static procedures in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DeleteInterpProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|HiddenCmdsDeleteProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The following structure defines the commands in the Tcl core.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of object-based command. */
name|Tcl_CmdProc
modifier|*
name|proc
decl_stmt|;
comment|/* String-based procedure for command. */
name|Tcl_ObjCmdProc
modifier|*
name|objProc
decl_stmt|;
comment|/* Object-based procedure for command. */
name|CompileProc
modifier|*
name|compileProc
decl_stmt|;
comment|/* Procedure called to compile command. */
name|int
name|isSafe
decl_stmt|;
comment|/* If non-zero, command will be present                                  * in safe interpreter. Otherwise it will                                  * be hidden. */
block|}
name|CmdInfo
typedef|;
end_typedef

begin_comment
comment|/*  * The built-in commands, and the procedures that implement them:  */
end_comment

begin_decl_stmt
specifier|static
name|CmdInfo
name|builtInCmds
index|[]
init|=
block|{
comment|/*      * Commands in the generic core. Note that at least one of the proc or      * objProc members should be non-NULL. This avoids infinitely recursive      * calls between TclInvokeObjectCommand and TclInvokeStringCommand if a      * command name is computed at runtime and results in the name of a      * compiled command.      */
block|{
literal|"append"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_AppendObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"array"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_ArrayObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"binary"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_BinaryObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"break"
block|,
name|Tcl_BreakCmd
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
name|TclCompileBreakCmd
block|,
literal|1
block|}
block|,
block|{
literal|"case"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_CaseObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"catch"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_CatchObjCmd
block|,
name|TclCompileCatchCmd
block|,
literal|1
block|}
block|,
block|{
literal|"clock"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_ClockObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"concat"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_ConcatObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"continue"
block|,
name|Tcl_ContinueCmd
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
name|TclCompileContinueCmd
block|,
literal|1
block|}
block|,
block|{
literal|"error"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_ErrorObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"eval"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_EvalObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"exit"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_ExitObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|"expr"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_ExprObjCmd
block|,
name|TclCompileExprCmd
block|,
literal|1
block|}
block|,
block|{
literal|"fcopy"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_FcopyObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"fileevent"
block|,
name|Tcl_FileEventCmd
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"for"
block|,
name|Tcl_ForCmd
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
name|TclCompileForCmd
block|,
literal|1
block|}
block|,
block|{
literal|"foreach"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_ForeachObjCmd
block|,
name|TclCompileForeachCmd
block|,
literal|1
block|}
block|,
block|{
literal|"format"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_FormatObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"global"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_GlobalObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"if"
block|,
name|Tcl_IfCmd
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
name|TclCompileIfCmd
block|,
literal|1
block|}
block|,
block|{
literal|"incr"
block|,
name|Tcl_IncrCmd
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
name|TclCompileIncrCmd
block|,
literal|1
block|}
block|,
block|{
literal|"info"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_InfoObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"interp"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_InterpObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"join"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_JoinObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"lappend"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_LappendObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"lindex"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_LindexObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"linsert"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_LinsertObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"list"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_ListObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"llength"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_LlengthObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"load"
block|,
name|Tcl_LoadCmd
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|"lrange"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_LrangeObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"lreplace"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_LreplaceObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"lsearch"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_LsearchObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"lsort"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_LsortObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"namespace"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_NamespaceObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"package"
block|,
name|Tcl_PackageCmd
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"proc"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_ProcObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"regexp"
block|,
name|Tcl_RegexpCmd
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"regsub"
block|,
name|Tcl_RegsubCmd
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"rename"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_RenameObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"return"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_ReturnObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"scan"
block|,
name|Tcl_ScanCmd
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"set"
block|,
name|Tcl_SetCmd
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
name|TclCompileSetCmd
block|,
literal|1
block|}
block|,
block|{
literal|"split"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_SplitObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"string"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_StringObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"subst"
block|,
name|Tcl_SubstCmd
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"switch"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_SwitchObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"trace"
block|,
name|Tcl_TraceCmd
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"unset"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_UnsetObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"uplevel"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_UplevelObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"upvar"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_UpvarObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"variable"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_VariableObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"while"
block|,
name|Tcl_WhileCmd
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
name|TclCompileWhileCmd
block|,
literal|1
block|}
block|,
comment|/*      * Commands in the UNIX core:      */
ifndef|#
directive|ifndef
name|TCL_GENERIC_ONLY
block|{
literal|"after"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_AfterObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"cd"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_CdObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|"close"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_CloseObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"eof"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_EofObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"fblocked"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_FblockedObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"fconfigure"
block|,
name|Tcl_FconfigureCmd
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|"file"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_FileObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|"flush"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_FlushObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"gets"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_GetsObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"glob"
block|,
name|Tcl_GlobCmd
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|"open"
block|,
name|Tcl_OpenCmd
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|"pid"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_PidObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"puts"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_PutsObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"pwd"
block|,
name|Tcl_PwdCmd
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|"read"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_ReadObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"seek"
block|,
name|Tcl_SeekCmd
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"socket"
block|,
name|Tcl_SocketCmd
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|"tell"
block|,
name|Tcl_TellCmd
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"time"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_TimeObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"update"
block|,
name|Tcl_UpdateCmd
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"vwait"
block|,
name|Tcl_VwaitCmd
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
ifdef|#
directive|ifdef
name|MAC_TCL
block|{
literal|"beep"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_BeepObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|"echo"
block|,
name|Tcl_EchoCmd
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|"ls"
block|,
name|Tcl_LsCmd
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|"resource"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_ResourceObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"source"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_MacSourceObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|0
block|}
block|,
else|#
directive|else
block|{
literal|"exec"
block|,
name|Tcl_ExecCmd
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|"source"
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
name|Tcl_SourceObjCmd
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|0
block|}
block|,
endif|#
directive|endif
comment|/* MAC_TCL */
endif|#
directive|endif
comment|/* TCL_GENERIC_ONLY */
block|{
name|NULL
block|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
block|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
block|,
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CreateInterp --  *  *	Create a new TCL command interpreter.  *  * Results:  *	The return value is a token for the interpreter, which may be  *	used in calls to procedures like Tcl_CreateCmd, Tcl_Eval, or  *	Tcl_DeleteInterp.  *  * Side effects:  *	The command interpreter is initialized with an empty variable  *	table and the built-in commands.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Interp
modifier|*
name|Tcl_CreateInterp
parameter_list|()
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
decl_stmt|;
specifier|register
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
specifier|register
name|CmdInfo
modifier|*
name|cmdInfoPtr
decl_stmt|;
union|union
block|{
name|char
name|c
index|[
sizeof|sizeof
argument_list|(
name|short
argument_list|)
index|]
decl_stmt|;
name|short
name|s
decl_stmt|;
block|}
name|order
union|;
name|int
name|i
decl_stmt|;
comment|/*      * Panic if someone updated the CallFrame structure without      * also updating the Tcl_CallFrame structure (or vice versa).      */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|Tcl_CallFrame
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|CallFrame
argument_list|)
condition|)
block|{
comment|/*NOTREACHED*/
name|panic
argument_list|(
literal|"Tcl_CallFrame and CallFrame are not the same size"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Initialize support for namespaces and create the global namespace      * (whose name is ""; an alias is "::"). This also initializes the      * Tcl object type table and other object management code.      */
name|TclInitNamespaces
argument_list|()
expr_stmt|;
name|iPtr
operator|=
operator|(
name|Interp
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Interp
argument_list|)
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|result
operator|=
name|iPtr
operator|->
name|resultSpace
expr_stmt|;
name|iPtr
operator|->
name|freeProc
operator|=
literal|0
expr_stmt|;
name|iPtr
operator|->
name|objResultPtr
operator|=
name|Tcl_NewObj
argument_list|()
expr_stmt|;
comment|/* an empty object */
name|Tcl_IncrRefCount
argument_list|(
name|iPtr
operator|->
name|objResultPtr
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|errorLine
operator|=
literal|0
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
operator|&
name|iPtr
operator|->
name|mathFuncTable
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|numLevels
operator|=
literal|0
expr_stmt|;
name|iPtr
operator|->
name|maxNestingDepth
operator|=
literal|1000
expr_stmt|;
name|iPtr
operator|->
name|framePtr
operator|=
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|varFramePtr
operator|=
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|activeTracePtr
operator|=
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|returnCode
operator|=
name|TCL_OK
expr_stmt|;
name|iPtr
operator|->
name|errorInfo
operator|=
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|errorCode
operator|=
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|appendResult
operator|=
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|appendAvl
operator|=
literal|0
expr_stmt|;
name|iPtr
operator|->
name|appendUsed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGEXPS
condition|;
name|i
operator|++
control|)
block|{
name|iPtr
operator|->
name|patterns
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|patLengths
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|iPtr
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|Tcl_InitHashTable
argument_list|(
operator|&
name|iPtr
operator|->
name|packageTable
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|packageUnknown
operator|=
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|cmdCount
operator|=
literal|0
expr_stmt|;
name|iPtr
operator|->
name|termOffset
operator|=
literal|0
expr_stmt|;
name|iPtr
operator|->
name|compileEpoch
operator|=
literal|0
expr_stmt|;
name|iPtr
operator|->
name|compiledProcPtr
operator|=
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|evalFlags
operator|=
literal|0
expr_stmt|;
name|iPtr
operator|->
name|scriptFile
operator|=
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|iPtr
operator|->
name|tracePtr
operator|=
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|assocData
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|execEnvPtr
operator|=
name|NULL
expr_stmt|;
comment|/* set after namespaces initialized */
name|iPtr
operator|->
name|emptyObjPtr
operator|=
name|Tcl_NewObj
argument_list|()
expr_stmt|;
comment|/* another empty object */
name|Tcl_IncrRefCount
argument_list|(
name|iPtr
operator|->
name|emptyObjPtr
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|resultSpace
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|iPtr
operator|->
name|globalNsPtr
operator|=
name|NULL
expr_stmt|;
comment|/* force creation of global ns below */
name|iPtr
operator|->
name|globalNsPtr
operator|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_CreateNamespace
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|""
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|,
operator|(
name|Tcl_NamespaceDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|globalNsPtr
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_CreateInterp: can't create global namespace"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Initialize support for code compilation. Do this after initializing      * namespaces since TclCreateExecEnv will try to reference a Tcl      * variable (it links to the Tcl "tcl_traceExec" variable).      */
name|iPtr
operator|->
name|execEnvPtr
operator|=
name|TclCreateExecEnv
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|)
expr_stmt|;
comment|/*      * Create the core commands. Do it here, rather than calling      * Tcl_CreateCommand, because it's faster (there's no need to check for      * a pre-existing command by the same name). If a command has a      * Tcl_CmdProc but no Tcl_ObjCmdProc, set the Tcl_ObjCmdProc to      * TclInvokeStringCommand. This is an object-based wrapper procedure      * that extracts strings, calls the string procedure, and creates an      * object for the result. Similarly, if a command has a Tcl_ObjCmdProc      * but no Tcl_CmdProc, set the Tcl_CmdProc to TclInvokeObjectCommand.      */
for|for
control|(
name|cmdInfoPtr
operator|=
name|builtInCmds
init|;
name|cmdInfoPtr
operator|->
name|name
operator|!=
name|NULL
condition|;
name|cmdInfoPtr
operator|++
control|)
block|{
name|int
name|new
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
if|if
condition|(
operator|(
name|cmdInfoPtr
operator|->
name|proc
operator|==
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|cmdInfoPtr
operator|->
name|objProc
operator|==
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|cmdInfoPtr
operator|->
name|compileProc
operator|==
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_CreateInterp: builtin command with NULL string and object command procs and a NULL compile proc\n"
argument_list|)
expr_stmt|;
block|}
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|globalNsPtr
operator|->
name|cmdTable
argument_list|,
name|cmdInfoPtr
operator|->
name|name
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Command
argument_list|)
argument_list|)
expr_stmt|;
name|cmdPtr
operator|->
name|hPtr
operator|=
name|hPtr
expr_stmt|;
name|cmdPtr
operator|->
name|nsPtr
operator|=
name|iPtr
operator|->
name|globalNsPtr
expr_stmt|;
name|cmdPtr
operator|->
name|refCount
operator|=
literal|1
expr_stmt|;
name|cmdPtr
operator|->
name|cmdEpoch
operator|=
literal|0
expr_stmt|;
name|cmdPtr
operator|->
name|compileProc
operator|=
name|cmdInfoPtr
operator|->
name|compileProc
expr_stmt|;
if|if
condition|(
name|cmdInfoPtr
operator|->
name|proc
operator|==
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|NULL
condition|)
block|{
name|cmdPtr
operator|->
name|proc
operator|=
name|TclInvokeObjectCommand
expr_stmt|;
name|cmdPtr
operator|->
name|clientData
operator|=
operator|(
name|ClientData
operator|)
name|cmdPtr
expr_stmt|;
block|}
else|else
block|{
name|cmdPtr
operator|->
name|proc
operator|=
name|cmdInfoPtr
operator|->
name|proc
expr_stmt|;
name|cmdPtr
operator|->
name|clientData
operator|=
operator|(
name|ClientData
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cmdInfoPtr
operator|->
name|objProc
operator|==
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
condition|)
block|{
name|cmdPtr
operator|->
name|objProc
operator|=
name|TclInvokeStringCommand
expr_stmt|;
name|cmdPtr
operator|->
name|objClientData
operator|=
operator|(
name|ClientData
operator|)
name|cmdPtr
expr_stmt|;
block|}
else|else
block|{
name|cmdPtr
operator|->
name|objProc
operator|=
name|cmdInfoPtr
operator|->
name|objProc
expr_stmt|;
name|cmdPtr
operator|->
name|objClientData
operator|=
operator|(
name|ClientData
operator|)
name|NULL
expr_stmt|;
block|}
name|cmdPtr
operator|->
name|deleteProc
operator|=
name|NULL
expr_stmt|;
name|cmdPtr
operator|->
name|deleteData
operator|=
operator|(
name|ClientData
operator|)
name|NULL
expr_stmt|;
name|cmdPtr
operator|->
name|deleted
operator|=
literal|0
expr_stmt|;
name|cmdPtr
operator|->
name|importRefPtr
operator|=
name|NULL
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
name|cmdPtr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      *  Initialize/Create "errorInfo" and "errorCode" global vars      *  (because some part of the C code assume they exists      *   and we can get a seg fault otherwise (in multiple       *   interps loading of extensions for instance) --dl)      */
comment|/*       *  We can't assume that because we initialize        *  the variables here, they won't be unset later.       *  so we had 2 choices:       *    + Check every place where a GetVar of those is used        *      and the NULL result is not checked (like in tclLoad.c)       *    + Make SetVar,... NULL friendly       *  We choosed the second option because :       *    + It is easy and low cost to check for NULL pointer before       *      calling strlen()       *    + It can be helpfull to other people using those API       *    + Passing a NULL value to those closest 'meaning' is empty string       *      (specially with the new objects where 0 bytes strings are ok)       * So the following init is commented out:              -- dl       */
comment|/*       (void)Tcl_SetVar2((Tcl_Interp *)iPtr, "errorInfo", (char *) NULL, "",          TCL_GLOBAL_ONLY);       (void)Tcl_SetVar2((Tcl_Interp *)iPtr, "errorCode", (char *) NULL, "NONE", 	    TCL_GLOBAL_ONLY);      */
ifndef|#
directive|ifndef
name|TCL_GENERIC_ONLY
name|TclSetupEnv
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * Do Multiple/Safe Interps Tcl init stuff      */
operator|(
name|void
operator|)
name|TclInterpInit
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|)
expr_stmt|;
comment|/*      * Set up variables such as tcl_version.      */
name|TclPlatformInit
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|)
expr_stmt|;
name|Tcl_SetVar
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"tcl_patchLevel"
argument_list|,
name|TCL_PATCH_LEVEL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|Tcl_SetVar
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"tcl_version"
argument_list|,
name|TCL_VERSION
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|Tcl_TraceVar2
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"tcl_precision"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
operator||
name|TCL_TRACE_READS
operator||
name|TCL_TRACE_WRITES
operator||
name|TCL_TRACE_UNSETS
argument_list|,
name|TclPrecTraceProc
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/*      * Compute the byte order of this machine.      */
name|order
operator|.
name|s
operator|=
literal|1
expr_stmt|;
name|Tcl_SetVar2
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"tcl_platform"
argument_list|,
literal|"byteOrder"
argument_list|,
operator|(
name|order
operator|.
name|c
index|[
literal|0
index|]
operator|==
literal|1
operator|)
condition|?
literal|"littleEndian"
else|:
literal|"bigEndian"
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
comment|/*      * Register Tcl's version number.      */
name|Tcl_PkgProvide
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"Tcl"
argument_list|,
name|TCL_VERSION
argument_list|)
expr_stmt|;
return|return
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclHideUnsafeCommands --  *  *	Hides base commands that are not marked as safe from this  *	interpreter.  *  * Results:  *	TCL_OK if it succeeds, TCL_ERROR else.  *  * Side effects:  *	Hides functionality in an interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclHideUnsafeCommands
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Hide commands in this interpreter. */
block|{
specifier|register
name|CmdInfo
modifier|*
name|cmdInfoPtr
decl_stmt|;
if|if
condition|(
name|interp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
for|for
control|(
name|cmdInfoPtr
operator|=
name|builtInCmds
init|;
name|cmdInfoPtr
operator|->
name|name
operator|!=
name|NULL
condition|;
name|cmdInfoPtr
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|cmdInfoPtr
operator|->
name|isSafe
condition|)
block|{
name|Tcl_HideCommand
argument_list|(
name|interp
argument_list|,
name|cmdInfoPtr
operator|->
name|name
argument_list|,
name|cmdInfoPtr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * Tcl_CallWhenDeleted --  *  *	Arrange for a procedure to be called before a given  *	interpreter is deleted. The procedure is called as soon  *	as Tcl_DeleteInterp is called; if Tcl_CallWhenDeleted is  *	called on an interpreter that has already been deleted,  *	the procedure will be called when the last Tcl_Release is  *	done on the interpreter.  *  * Results:  *	None.  *  * Side effects:  *	When Tcl_DeleteInterp is invoked to delete interp,  *	proc will be invoked.  See the manual entry for  *	details.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_CallWhenDeleted
parameter_list|(
name|interp
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to watch. */
name|Tcl_InterpDeleteProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to call when interpreter 				 * is about to be deleted. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* One-word value to pass to proc. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
specifier|static
name|int
name|assocDataCounter
init|=
literal|0
decl_stmt|;
name|int
name|new
decl_stmt|;
name|char
name|buffer
index|[
literal|128
index|]
decl_stmt|;
name|AssocData
modifier|*
name|dPtr
init|=
operator|(
name|AssocData
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|AssocData
argument_list|)
argument_list|)
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"Assoc Data Key #%d"
argument_list|,
name|assocDataCounter
argument_list|)
expr_stmt|;
name|assocDataCounter
operator|++
expr_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|assocData
operator|==
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
condition|)
block|{
name|iPtr
operator|->
name|assocData
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Tcl_HashTable
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
name|iPtr
operator|->
name|assocData
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
block|}
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
name|iPtr
operator|->
name|assocData
argument_list|,
name|buffer
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
name|dPtr
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|dPtr
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
name|dPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * Tcl_DontCallWhenDeleted --  *  *	Cancel the arrangement for a procedure to be called when  *	a given interpreter is deleted.  *  * Results:  *	None.  *  * Side effects:  *	If proc and clientData were previously registered as a  *	callback via Tcl_CallWhenDeleted, they are unregistered.  *	If they weren't previously registered then nothing  *	happens.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DontCallWhenDeleted
parameter_list|(
name|interp
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to watch. */
name|Tcl_InterpDeleteProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to call when interpreter 				 * is about to be deleted. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* One-word value to pass to proc. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Tcl_HashTable
modifier|*
name|hTablePtr
decl_stmt|;
name|Tcl_HashSearch
name|hSearch
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|AssocData
modifier|*
name|dPtr
decl_stmt|;
name|hTablePtr
operator|=
name|iPtr
operator|->
name|assocData
expr_stmt|;
if|if
condition|(
name|hTablePtr
operator|==
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
condition|)
block|{
return|return;
block|}
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|hTablePtr
argument_list|,
operator|&
name|hSearch
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|hSearch
argument_list|)
control|)
block|{
name|dPtr
operator|=
operator|(
name|AssocData
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dPtr
operator|->
name|proc
operator|==
name|proc
operator|)
operator|&&
operator|(
name|dPtr
operator|->
name|clientData
operator|==
name|clientData
operator|)
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dPtr
argument_list|)
expr_stmt|;
name|Tcl_DeleteHashEntry
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetAssocData --  *  *	Creates a named association between user-specified data, a delete  *	function and this interpreter. If the association already exists  *	the data is overwritten with the new data. The delete function will  *	be invoked when the interpreter is deleted.  *  * Results:  *	None.  *  * Side effects:  *	Sets the associated data, creates the association if needed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_SetAssocData
parameter_list|(
name|interp
parameter_list|,
name|name
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to associate with. */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name for association. */
name|Tcl_InterpDeleteProc
modifier|*
name|proc
decl_stmt|;
comment|/* Proc to call when interpreter is                                  * about to be deleted. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* One-word value to pass to proc. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|AssocData
modifier|*
name|dPtr
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|int
name|new
decl_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|assocData
operator|==
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
condition|)
block|{
name|iPtr
operator|->
name|assocData
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Tcl_HashTable
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
name|iPtr
operator|->
name|assocData
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
block|}
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
name|iPtr
operator|->
name|assocData
argument_list|,
name|name
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
condition|)
block|{
name|dPtr
operator|=
operator|(
name|AssocData
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dPtr
operator|=
operator|(
name|AssocData
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|AssocData
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dPtr
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|dPtr
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
name|dPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DeleteAssocData --  *  *	Deletes a named association of user-specified data with  *	the specified interpreter.  *  * Results:  *	None.  *  * Side effects:  *	Deletes the association.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DeleteAssocData
parameter_list|(
name|interp
parameter_list|,
name|name
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to associate with. */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of association. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|AssocData
modifier|*
name|dPtr
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|assocData
operator|==
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
condition|)
block|{
return|return;
block|}
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
name|iPtr
operator|->
name|assocData
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|)
block|{
return|return;
block|}
name|dPtr
operator|=
operator|(
name|AssocData
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dPtr
operator|->
name|proc
operator|!=
name|NULL
condition|)
block|{
call|(
name|dPtr
operator|->
name|proc
call|)
argument_list|(
name|dPtr
operator|->
name|clientData
argument_list|,
name|interp
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dPtr
argument_list|)
expr_stmt|;
name|Tcl_DeleteHashEntry
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetAssocData --  *  *	Returns the client data associated with this name in the  *	specified interpreter.  *  * Results:  *	The client data in the AssocData record denoted by the named  *	association, or NULL.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|ClientData
name|Tcl_GetAssocData
parameter_list|(
name|interp
parameter_list|,
name|name
parameter_list|,
name|procPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter associated with. */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of association. */
name|Tcl_InterpDeleteProc
modifier|*
modifier|*
name|procPtr
decl_stmt|;
comment|/* Pointer to place to store address 					 * of current deletion callback. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|AssocData
modifier|*
name|dPtr
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|assocData
operator|==
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
operator|(
name|ClientData
operator|)
name|NULL
return|;
block|}
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
name|iPtr
operator|->
name|assocData
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
operator|(
name|ClientData
operator|)
name|NULL
return|;
block|}
name|dPtr
operator|=
operator|(
name|AssocData
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|procPtr
operator|!=
operator|(
name|Tcl_InterpDeleteProc
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
operator|*
name|procPtr
operator|=
name|dPtr
operator|->
name|proc
expr_stmt|;
block|}
return|return
name|dPtr
operator|->
name|clientData
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DeleteInterpProc --  *  *	Helper procedure to delete an interpreter. This procedure is  *	called when the last call to Tcl_Preserve on this interpreter  *	is matched by a call to Tcl_Release. The procedure cleans up  *	all resources used in the interpreter and calls all currently  *	registered interpreter deletion callbacks.  *  * Results:  *	None.  *  * Side effects:  *	Whatever the interpreter deletion callbacks do. Frees resources  *	used by the interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|DeleteInterpProc
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to delete. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|Tcl_HashSearch
name|search
decl_stmt|;
name|Tcl_HashTable
modifier|*
name|hTablePtr
decl_stmt|;
name|AssocData
modifier|*
name|dPtr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*      * Punt if there is an error in the Tcl_Release/Tcl_Preserve matchup.      */
if|if
condition|(
name|iPtr
operator|->
name|numLevels
operator|>
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"DeleteInterpProc called with active evals"
argument_list|)
expr_stmt|;
block|}
comment|/*      * The interpreter should already be marked deleted; otherwise how      * did we get here?      */
if|if
condition|(
operator|!
operator|(
name|iPtr
operator|->
name|flags
operator|&
name|DELETED
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"DeleteInterpProc called on interpreter not marked deleted"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Dismantle everything in the global namespace except for the      * "errorInfo" and "errorCode" variables. These remain until the      * namespace is actually destroyed, in case any errors occur.      *         * Dismantle the namespace here, before we clear the assocData. If any      * background errors occur here, they will be deleted below.      */
name|TclTeardownNamespace
argument_list|(
name|iPtr
operator|->
name|globalNsPtr
argument_list|)
expr_stmt|;
comment|/*      * Tear down the math function table.      */
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|mathFuncTable
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Tcl_DeleteHashTable
argument_list|(
operator|&
name|iPtr
operator|->
name|mathFuncTable
argument_list|)
expr_stmt|;
comment|/*      * Invoke deletion callbacks; note that a callback can create new      * callbacks, so we iterate.      */
while|while
condition|(
name|iPtr
operator|->
name|assocData
operator|!=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
condition|)
block|{
name|hTablePtr
operator|=
name|iPtr
operator|->
name|assocData
expr_stmt|;
name|iPtr
operator|->
name|assocData
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|hTablePtr
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|hTablePtr
argument_list|,
operator|&
name|search
argument_list|)
control|)
block|{
name|dPtr
operator|=
operator|(
name|AssocData
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
name|Tcl_DeleteHashEntry
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dPtr
operator|->
name|proc
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|dPtr
operator|->
name|proc
call|)
argument_list|(
name|dPtr
operator|->
name|clientData
argument_list|,
name|interp
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dPtr
argument_list|)
expr_stmt|;
block|}
name|Tcl_DeleteHashTable
argument_list|(
name|hTablePtr
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hTablePtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * Finish deleting the global namespace.      */
name|Tcl_DeleteNamespace
argument_list|(
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|iPtr
operator|->
name|globalNsPtr
argument_list|)
expr_stmt|;
comment|/*      * Free up the result *after* deleting variables, since variable      * deletion could have transferred ownership of the result string      * to Tcl.      */
name|Tcl_FreeResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|interp
operator|->
name|result
operator|=
name|NULL
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|iPtr
operator|->
name|objResultPtr
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|objResultPtr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|errorInfo
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|iPtr
operator|->
name|errorInfo
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|errorInfo
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|iPtr
operator|->
name|errorCode
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|iPtr
operator|->
name|errorCode
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|errorCode
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|iPtr
operator|->
name|appendResult
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|iPtr
operator|->
name|appendResult
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|appendResult
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGEXPS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|iPtr
operator|->
name|patterns
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|ckfree
argument_list|(
name|iPtr
operator|->
name|patterns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iPtr
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|TclFreePackageInfo
argument_list|(
name|iPtr
argument_list|)
expr_stmt|;
while|while
condition|(
name|iPtr
operator|->
name|tracePtr
operator|!=
name|NULL
condition|)
block|{
name|Trace
modifier|*
name|nextPtr
init|=
name|iPtr
operator|->
name|tracePtr
operator|->
name|nextPtr
decl_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iPtr
operator|->
name|tracePtr
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|tracePtr
operator|=
name|nextPtr
expr_stmt|;
block|}
if|if
condition|(
name|iPtr
operator|->
name|execEnvPtr
operator|!=
name|NULL
condition|)
block|{
name|TclDeleteExecEnv
argument_list|(
name|iPtr
operator|->
name|execEnvPtr
argument_list|)
expr_stmt|;
block|}
name|Tcl_DecrRefCount
argument_list|(
name|iPtr
operator|->
name|emptyObjPtr
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|emptyObjPtr
operator|=
name|NULL
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_InterpDeleted --  *  *	Returns nonzero if the interpreter has been deleted with a call  *	to Tcl_DeleteInterp.  *  * Results:  *	Nonzero if the interpreter is deleted, zero otherwise.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_InterpDeleted
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|(
name|Interp
operator|*
operator|)
name|interp
operator|)
operator|->
name|flags
operator|&
name|DELETED
operator|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DeleteInterp --  *  *	Ensures that the interpreter will be deleted eventually. If there  *	are no Tcl_Preserve calls in effect for this interpreter, it is  *	deleted immediately, otherwise the interpreter is deleted when  *	the last Tcl_Preserve is matched by a call to Tcl_Release. In either  *	case, the procedure runs the currently registered deletion callbacks.   *  * Results:  *	None.  *  * Side effects:  *	The interpreter is marked as deleted. The caller may still use it  *	safely if there are calls to Tcl_Preserve in effect for the  *	interpreter, but further calls to Tcl_Eval etc in this interpreter  *	will fail.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DeleteInterp
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Token for command interpreter (returned 				 * by a previous call to Tcl_CreateInterp). */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
comment|/*      * If the interpreter has already been marked deleted, just punt.      */
if|if
condition|(
name|iPtr
operator|->
name|flags
operator|&
name|DELETED
condition|)
block|{
return|return;
block|}
comment|/*      * Mark the interpreter as deleted. No further evals will be allowed.      */
name|iPtr
operator|->
name|flags
operator||=
name|DELETED
expr_stmt|;
comment|/*      * Ensure that the interpreter is eventually deleted.      */
name|Tcl_EventuallyFree
argument_list|(
operator|(
name|ClientData
operator|)
name|interp
argument_list|,
operator|(
name|Tcl_FreeProc
operator|*
operator|)
name|DeleteInterpProc
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * HiddenCmdsDeleteProc --  *  *	Called on interpreter deletion to delete all the hidden  *	commands in an interpreter.  *  * Results:  *	None.  *  * Side effects:  *	Frees up memory.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|HiddenCmdsDeleteProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* The hidden commands hash table. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interpreter being deleted. */
block|{
name|Tcl_HashTable
modifier|*
name|hiddenCmdTblPtr
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|Tcl_HashSearch
name|hSearch
decl_stmt|;
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
name|hiddenCmdTblPtr
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|clientData
expr_stmt|;
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|hiddenCmdTblPtr
argument_list|,
operator|&
name|hSearch
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|hiddenCmdTblPtr
argument_list|,
operator|&
name|hSearch
argument_list|)
control|)
block|{
comment|/*          * Cannot use Tcl_DeleteCommand because (a) the command is not          * in the command hash table, and (b) that table has already been          * deleted above. Hence we emulate what it does, below.          */
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
comment|/*          * The code here is tricky.  We can't delete the hash table entry          * before invoking the deletion callback because there are cases          * where the deletion callback needs to invoke the command (e.g.          * object systems such as OTcl).  However, this means that the          * callback could try to delete or rename the command.  The deleted          * flag allows us to detect these cases and skip nested deletes.          */
if|if
condition|(
name|cmdPtr
operator|->
name|deleted
condition|)
block|{
comment|/*              * Another deletion is already in progress.  Remove the hash              * table entry now, but don't invoke a callback or free the              * command structure.              */
name|Tcl_DeleteHashEntry
argument_list|(
name|cmdPtr
operator|->
name|hPtr
argument_list|)
expr_stmt|;
name|cmdPtr
operator|->
name|hPtr
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
name|cmdPtr
operator|->
name|deleted
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cmdPtr
operator|->
name|deleteProc
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|cmdPtr
operator|->
name|deleteProc
call|)
argument_list|(
name|cmdPtr
operator|->
name|deleteData
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Bump the command epoch counter. This will invalidate all cached          * references that refer to this command. 	 */
name|cmdPtr
operator|->
name|cmdEpoch
operator|++
expr_stmt|;
comment|/*          * Don't use hPtr to delete the hash entry here, because it's          * possible that the deletion callback renamed the command.          * Instead, use cmdPtr->hptr, and make sure that no-one else          * has already deleted the hash entry.          */
if|if
condition|(
name|cmdPtr
operator|->
name|hPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DeleteHashEntry
argument_list|(
name|cmdPtr
operator|->
name|hPtr
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now free the Command structure, unless there is another reference 	 * to it from a CmdName Tcl object in some ByteCode code 	 * sequence. In that case, delay the cleanup until all references 	 * are either discarded (when a ByteCode is freed) or replaced by a 	 * new reference (when a cached CmdName Command reference is found 	 * to be invalid and TclExecuteByteCode looks up the command in the 	 * command hashtable). 	 */
name|TclCleanupCommand
argument_list|(
name|cmdPtr
argument_list|)
expr_stmt|;
block|}
name|Tcl_DeleteHashTable
argument_list|(
name|hiddenCmdTblPtr
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hiddenCmdTblPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_HideCommand --  *  *	Makes a command hidden so that it cannot be invoked from within  *	an interpreter, only from within an ancestor.  *  * Results:  *	A standard Tcl result; also leaves a message in interp->result  *	if an error occurs.  *  * Side effects:  *	Removes a command from the command table and create an entry  *      into the hidden command table under the specified token name.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_HideCommand
parameter_list|(
name|interp
parameter_list|,
name|cmdName
parameter_list|,
name|hiddenCmdToken
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to hide command. */
name|char
modifier|*
name|cmdName
decl_stmt|;
comment|/* Name of command to hide. */
name|char
modifier|*
name|hiddenCmdToken
decl_stmt|;
comment|/* Token name of the to-be-hidden command. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Tcl_Command
name|cmd
decl_stmt|;
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
name|Tcl_HashTable
modifier|*
name|hTblPtr
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|int
name|new
decl_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|flags
operator|&
name|DELETED
condition|)
block|{
comment|/*          * The interpreter is being deleted. Do not create any new          * structures, because it is not safe to modify the interpreter.          */
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Disallow hiding of commands that are currently in a namespace or      * renaming (as part of hiding) into a namespace.      *      * (because the current implementation with a single global table      *  and the needed uniqueness of names cause problems with namespaces)      *      * we don't need to check for "::" in cmdName because the real check is      * on the nsPtr below.      *      * hiddenCmdToken is just a string which is not interpreted in any way.      * It may contain :: but the string is not interpreted as a namespace      * qualifier command name. Thus, hiding foo::bar to foo::bar and then      * trying to expose or invoke ::foo::bar will NOT work; but if the      * application always uses the same strings it will get consistent      * behaviour.      *      * But as we currently limit ourselves to the global namespace only      * for the source, in order to avoid potential confusion,      * lets prevent "::" in the token too.  --dl      */
if|if
condition|(
name|strstr
argument_list|(
name|hiddenCmdToken
argument_list|,
literal|"::"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"cannot use namespace qualifiers as hidden command"
argument_list|,
literal|"token (rename)"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Find the command to hide. An error is returned if cmdName can't      * be found. Look up the command only from the global namespace.      * Full path of the command must be given if using namespaces.      */
name|cmd
operator|=
name|Tcl_FindCommand
argument_list|(
name|interp
argument_list|,
name|cmdName
argument_list|,
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|NULL
argument_list|,
comment|/*flags*/
name|TCL_LEAVE_ERR_MSG
operator||
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
operator|(
name|Tcl_Command
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|cmd
expr_stmt|;
comment|/*      * Check that the command is really in global namespace      */
if|if
condition|(
name|cmdPtr
operator|->
name|nsPtr
operator|!=
name|iPtr
operator|->
name|globalNsPtr
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"can only hide global namespace commands"
argument_list|,
literal|" (use rename then hide)"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Initialize the hidden command table if necessary.      */
name|hTblPtr
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclHiddenCmds"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hTblPtr
operator|==
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
condition|)
block|{
name|hTblPtr
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|Tcl_HashTable
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
name|hTblPtr
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
name|Tcl_SetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclHiddenCmds"
argument_list|,
name|HiddenCmdsDeleteProc
argument_list|,
operator|(
name|ClientData
operator|)
name|hTblPtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * It is an error to move an exposed command to a hidden command with      * hiddenCmdToken if a hidden command with the name hiddenCmdToken already      * exists.      */
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
name|hTblPtr
argument_list|,
name|hiddenCmdToken
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"hidden command named \""
argument_list|,
name|hiddenCmdToken
argument_list|,
literal|"\" already exists"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Nb : This code is currently 'like' a rename to a specialy set apart      * name table. Changes here and in TclRenameCommand must      * be kept in synch untill the common parts are actually      * factorized out.      */
comment|/*      * Remove the hash entry for the command from the interpreter command      * table. This is like deleting the command, so bump its command epoch;      * this invalidates any cached references that point to the command.      */
if|if
condition|(
name|cmdPtr
operator|->
name|hPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DeleteHashEntry
argument_list|(
name|cmdPtr
operator|->
name|hPtr
argument_list|)
expr_stmt|;
name|cmdPtr
operator|->
name|hPtr
operator|=
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
expr_stmt|;
name|cmdPtr
operator|->
name|cmdEpoch
operator|++
expr_stmt|;
block|}
comment|/*      * Now link the hash table entry with the command structure.      * We ensured above that the nsPtr was right.      */
name|cmdPtr
operator|->
name|hPtr
operator|=
name|hPtr
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
operator|(
name|ClientData
operator|)
name|cmdPtr
argument_list|)
expr_stmt|;
comment|/*      * If the command being hidden has a compile procedure, increment the      * interpreter's compileEpoch to invalidate its compiled code. This      * makes sure that we don't later try to execute old code compiled with      * command-specific (i.e., inline) bytecodes for the now-hidden      * command. This field is checked in Tcl_EvalObj and ObjInterpProc,      * and code whose compilation epoch doesn't match is recompiled.      */
if|if
condition|(
name|cmdPtr
operator|->
name|compileProc
operator|!=
name|NULL
condition|)
block|{
name|iPtr
operator|->
name|compileEpoch
operator|++
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ExposeCommand --  *  *	Makes a previously hidden command callable from inside the  *	interpreter instead of only by its ancestors.  *  * Results:  *	A standard Tcl result. If an error occurs, a message is left  *	in interp->result.  *  * Side effects:  *	Moves commands from one hash table to another.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_ExposeCommand
parameter_list|(
name|interp
parameter_list|,
name|hiddenCmdToken
parameter_list|,
name|cmdName
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to make command                                  * callable. */
name|char
modifier|*
name|hiddenCmdToken
decl_stmt|;
comment|/* Name of hidden command. */
name|char
modifier|*
name|cmdName
decl_stmt|;
comment|/* Name of to-be-exposed command. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
name|Namespace
modifier|*
name|nsPtr
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|Tcl_HashTable
modifier|*
name|hTblPtr
decl_stmt|;
name|int
name|new
decl_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|flags
operator|&
name|DELETED
condition|)
block|{
comment|/*          * The interpreter is being deleted. Do not create any new          * structures, because it is not safe to modify the interpreter.          */
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Check that we have a regular name for the command      * (that the user is not trying to do an expose and a rename      *  (to another namespace) at the same time)      */
if|if
condition|(
name|strstr
argument_list|(
name|cmdName
argument_list|,
literal|"::"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"can not expose to a namespace "
argument_list|,
literal|"(use expose to toplevel, then rename)"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Find the hash table for the hidden commands; error out if there      * is none.      */
name|hTblPtr
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclHiddenCmds"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hTblPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"unknown hidden command \""
argument_list|,
name|hiddenCmdToken
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Get the command from the hidden command table:      */
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
name|hTblPtr
argument_list|,
name|hiddenCmdToken
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"unknown hidden command \""
argument_list|,
name|hiddenCmdToken
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
comment|/*      * Check that we have a true global namespace      * command (enforced by Tcl_HideCommand() but let's double      * check. (If it was not, we would not really know how to      * handle it).      */
if|if
condition|(
name|cmdPtr
operator|->
name|nsPtr
operator|!=
name|iPtr
operator|->
name|globalNsPtr
condition|)
block|{
comment|/*  	 * This case is theoritically impossible, 	 * we might rather panic() than 'nicely' erroring out ? 	 */
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"trying to expose a non global command name space command"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/* This is the global table */
name|nsPtr
operator|=
name|cmdPtr
operator|->
name|nsPtr
expr_stmt|;
comment|/*      * It is an error to overwrite an existing exposed command as a result      * of exposing a previously hidden command.      */
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
name|nsPtr
operator|->
name|cmdTable
argument_list|,
name|cmdName
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"exposed command \""
argument_list|,
name|cmdName
argument_list|,
literal|"\" already exists"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Remove the hash entry for the command from the interpreter hidden      * command table.      */
if|if
condition|(
name|cmdPtr
operator|->
name|hPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DeleteHashEntry
argument_list|(
name|cmdPtr
operator|->
name|hPtr
argument_list|)
expr_stmt|;
name|cmdPtr
operator|->
name|hPtr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*      * Now link the hash table entry with the command structure.      * This is like creating a new command, so deal with any shadowing      * of commands in the global namespace.      */
name|cmdPtr
operator|->
name|hPtr
operator|=
name|hPtr
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
operator|(
name|ClientData
operator|)
name|cmdPtr
argument_list|)
expr_stmt|;
comment|/*      * Not needed as we are only in the global namespace      * (but would be needed again if we supported namespace command hiding)      *      * TclResetShadowedCmdRefs(interp, cmdPtr);      */
comment|/*      * If the command being exposed has a compile procedure, increment      * interpreter's compileEpoch to invalidate its compiled code. This      * makes sure that we don't later try to execute old code compiled      * assuming the command is hidden. This field is checked in Tcl_EvalObj      * and ObjInterpProc, and code whose compilation epoch doesn't match is      * recompiled.      */
if|if
condition|(
name|cmdPtr
operator|->
name|compileProc
operator|!=
name|NULL
condition|)
block|{
name|iPtr
operator|->
name|compileEpoch
operator|++
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CreateCommand --  *  *	Define a new command in a command table.  *  * Results:  *	The return value is a token for the command, which can  *	be used in future calls to Tcl_GetCommandName.  *  * Side effects:  *	If a command named cmdName already exists for interp, it is deleted.  *	In the future, when cmdName is seen as the name of a command by  *	Tcl_Eval, proc will be called. To support the bytecode interpreter,  *	the command is created with a wrapper Tcl_ObjCmdProc  *	(TclInvokeStringCommand) that eventially calls proc. When the  *	command is deleted from the table, deleteProc will be called.  *	See the manual entry for details on the calling sequence.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Command
name|Tcl_CreateCommand
parameter_list|(
name|interp
parameter_list|,
name|cmdName
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|,
name|deleteProc
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Token for command interpreter returned by 				 * a previous call to Tcl_CreateInterp. */
name|char
modifier|*
name|cmdName
decl_stmt|;
comment|/* Name of command. If it contains namespace 				 * qualifiers, the new command is put in the 				 * specified namespace; otherwise it is put 				 * in the global namespace. */
name|Tcl_CmdProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to associate with cmdName. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary value passed to string proc. */
name|Tcl_CmdDeleteProc
modifier|*
name|deleteProc
decl_stmt|;
comment|/* If not NULL, gives a procedure to call 				 * when this command is deleted. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Namespace
modifier|*
name|nsPtr
decl_stmt|,
modifier|*
name|dummy1
decl_stmt|,
modifier|*
name|dummy2
decl_stmt|;
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|char
modifier|*
name|tail
decl_stmt|;
name|int
name|new
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|flags
operator|&
name|DELETED
condition|)
block|{
comment|/* 	 * The interpreter is being deleted.  Don't create any new 	 * commands; it's not safe to muck with the interpreter anymore. 	 */
return|return
operator|(
name|Tcl_Command
operator|)
name|NULL
return|;
block|}
comment|/*      * Determine where the command should reside. If its name contains       * namespace qualifiers, we put it in the specified namespace;       * otherwise, we always put it in the global namespace.      */
if|if
condition|(
name|strstr
argument_list|(
name|cmdName
argument_list|,
literal|"::"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|TclGetNamespaceForQualName
argument_list|(
name|interp
argument_list|,
name|cmdName
argument_list|,
operator|(
name|Namespace
operator|*
operator|)
name|NULL
argument_list|,
name|CREATE_NS_IF_UNKNOWN
argument_list|,
operator|&
name|nsPtr
argument_list|,
operator|&
name|dummy1
argument_list|,
operator|&
name|dummy2
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|!=
name|TCL_OK
operator|)
operator|||
operator|(
name|nsPtr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|tail
operator|==
name|NULL
operator|)
condition|)
block|{
return|return
operator|(
name|Tcl_Command
operator|)
name|NULL
return|;
block|}
block|}
else|else
block|{
name|nsPtr
operator|=
name|iPtr
operator|->
name|globalNsPtr
expr_stmt|;
name|tail
operator|=
name|cmdName
expr_stmt|;
block|}
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
name|nsPtr
operator|->
name|cmdTable
argument_list|,
name|tail
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
block|{
comment|/* 	 * Command already exists. Delete the old one. 	 */
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
name|Tcl_DeleteCommandFromToken
argument_list|(
name|interp
argument_list|,
operator|(
name|Tcl_Command
operator|)
name|cmdPtr
argument_list|)
expr_stmt|;
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
name|nsPtr
operator|->
name|cmdTable
argument_list|,
name|tail
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
block|{
comment|/* 	     * If the deletion callback recreated the command, just throw              * away the new command (if we try to delete it again, we              * could get stuck in an infinite loop). 	     */
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cmdPtr
argument_list|)
expr_stmt|;
block|}
block|}
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Command
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
name|cmdPtr
argument_list|)
expr_stmt|;
name|cmdPtr
operator|->
name|hPtr
operator|=
name|hPtr
expr_stmt|;
name|cmdPtr
operator|->
name|nsPtr
operator|=
name|nsPtr
expr_stmt|;
name|cmdPtr
operator|->
name|refCount
operator|=
literal|1
expr_stmt|;
name|cmdPtr
operator|->
name|cmdEpoch
operator|=
literal|0
expr_stmt|;
name|cmdPtr
operator|->
name|compileProc
operator|=
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
expr_stmt|;
name|cmdPtr
operator|->
name|objProc
operator|=
name|TclInvokeStringCommand
expr_stmt|;
name|cmdPtr
operator|->
name|objClientData
operator|=
operator|(
name|ClientData
operator|)
name|cmdPtr
expr_stmt|;
name|cmdPtr
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|cmdPtr
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
name|cmdPtr
operator|->
name|deleteProc
operator|=
name|deleteProc
expr_stmt|;
name|cmdPtr
operator|->
name|deleteData
operator|=
name|clientData
expr_stmt|;
name|cmdPtr
operator|->
name|deleted
operator|=
literal|0
expr_stmt|;
name|cmdPtr
operator|->
name|importRefPtr
operator|=
name|NULL
expr_stmt|;
comment|/*      * We just created a command, so in its namespace and all of its parent      * namespaces, it may shadow global commands with the same name. If any      * shadowed commands are found, invalidate all cached command references      * in the affected namespaces.      */
name|TclResetShadowedCmdRefs
argument_list|(
name|interp
argument_list|,
name|cmdPtr
argument_list|)
expr_stmt|;
return|return
operator|(
name|Tcl_Command
operator|)
name|cmdPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CreateObjCommand --  *  *	Define a new object-based command in a command table.  *  * Results:  *	The return value is a token for the command, which can  *	be used in future calls to Tcl_NameOfCommand.  *  * Side effects:  *	If no command named "cmdName" already exists for interp, one is  *	created. Otherwise, if a command does exist, then if the  *	object-based Tcl_ObjCmdProc is TclInvokeStringCommand, we assume  *	Tcl_CreateCommand was called previously for the same command and  *	just set its Tcl_ObjCmdProc to the argument "proc"; otherwise, we  *	delete the old command.  *  *	In the future, during bytecode evaluation when "cmdName" is seen as  *	the name of a command by Tcl_EvalObj or Tcl_Eval, the object-based  *	Tcl_ObjCmdProc proc will be called. When the command is deleted from  *	the table, deleteProc will be called. See the manual entry for  *	details on the calling sequence.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Command
name|Tcl_CreateObjCommand
parameter_list|(
name|interp
parameter_list|,
name|cmdName
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|,
name|deleteProc
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Token for command interpreter (returned 				 * by previous call to Tcl_CreateInterp). */
name|char
modifier|*
name|cmdName
decl_stmt|;
comment|/* Name of command. If it contains namespace 				 * qualifiers, the new command is put in the 				 * specified namespace; otherwise it is put 				 * in the global namespace. */
name|Tcl_ObjCmdProc
modifier|*
name|proc
decl_stmt|;
comment|/* Object-based procedure to associate with 				 * name. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary value to pass to object     				 * procedure. */
name|Tcl_CmdDeleteProc
modifier|*
name|deleteProc
decl_stmt|;
comment|/* If not NULL, gives a procedure to call 				 * when this command is deleted. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Namespace
modifier|*
name|nsPtr
decl_stmt|,
modifier|*
name|dummy1
decl_stmt|,
modifier|*
name|dummy2
decl_stmt|;
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|char
modifier|*
name|tail
decl_stmt|;
name|int
name|new
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|flags
operator|&
name|DELETED
condition|)
block|{
comment|/* 	 * The interpreter is being deleted.  Don't create any new 	 * commands;  it's not safe to muck with the interpreter anymore. 	 */
return|return
operator|(
name|Tcl_Command
operator|)
name|NULL
return|;
block|}
comment|/*      * Determine where the command should reside. If its name contains       * namespace qualifiers, we put it in the specified namespace;       * otherwise, we always put it in the global namespace.      */
if|if
condition|(
name|strstr
argument_list|(
name|cmdName
argument_list|,
literal|"::"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|TclGetNamespaceForQualName
argument_list|(
name|interp
argument_list|,
name|cmdName
argument_list|,
operator|(
name|Namespace
operator|*
operator|)
name|NULL
argument_list|,
name|CREATE_NS_IF_UNKNOWN
argument_list|,
operator|&
name|nsPtr
argument_list|,
operator|&
name|dummy1
argument_list|,
operator|&
name|dummy2
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|!=
name|TCL_OK
operator|)
operator|||
operator|(
name|nsPtr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|tail
operator|==
name|NULL
operator|)
condition|)
block|{
return|return
operator|(
name|Tcl_Command
operator|)
name|NULL
return|;
block|}
block|}
else|else
block|{
name|nsPtr
operator|=
name|iPtr
operator|->
name|globalNsPtr
expr_stmt|;
name|tail
operator|=
name|cmdName
expr_stmt|;
block|}
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
name|nsPtr
operator|->
name|cmdTable
argument_list|,
name|tail
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
block|{
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
comment|/* 	 * Command already exists. If its object-based Tcl_ObjCmdProc is 	 * TclInvokeStringCommand, we just set its Tcl_ObjCmdProc to the 	 * argument "proc". Otherwise, we delete the old command.  	 */
if|if
condition|(
name|cmdPtr
operator|->
name|objProc
operator|==
name|TclInvokeStringCommand
condition|)
block|{
name|cmdPtr
operator|->
name|objProc
operator|=
name|proc
expr_stmt|;
name|cmdPtr
operator|->
name|objClientData
operator|=
name|clientData
expr_stmt|;
name|cmdPtr
operator|->
name|deleteProc
operator|=
name|deleteProc
expr_stmt|;
name|cmdPtr
operator|->
name|deleteData
operator|=
name|clientData
expr_stmt|;
return|return
operator|(
name|Tcl_Command
operator|)
name|cmdPtr
return|;
block|}
name|Tcl_DeleteCommandFromToken
argument_list|(
name|interp
argument_list|,
operator|(
name|Tcl_Command
operator|)
name|cmdPtr
argument_list|)
expr_stmt|;
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
name|nsPtr
operator|->
name|cmdTable
argument_list|,
name|tail
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
block|{
comment|/* 	     * If the deletion callback recreated the command, just throw 	     * away the new command (if we try to delete it again, we 	     * could get stuck in an infinite loop). 	     */
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Command
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
name|cmdPtr
argument_list|)
expr_stmt|;
name|cmdPtr
operator|->
name|hPtr
operator|=
name|hPtr
expr_stmt|;
name|cmdPtr
operator|->
name|nsPtr
operator|=
name|nsPtr
expr_stmt|;
name|cmdPtr
operator|->
name|refCount
operator|=
literal|1
expr_stmt|;
name|cmdPtr
operator|->
name|cmdEpoch
operator|=
literal|0
expr_stmt|;
name|cmdPtr
operator|->
name|compileProc
operator|=
operator|(
name|CompileProc
operator|*
operator|)
name|NULL
expr_stmt|;
name|cmdPtr
operator|->
name|objProc
operator|=
name|proc
expr_stmt|;
name|cmdPtr
operator|->
name|objClientData
operator|=
name|clientData
expr_stmt|;
name|cmdPtr
operator|->
name|proc
operator|=
name|TclInvokeObjectCommand
expr_stmt|;
name|cmdPtr
operator|->
name|clientData
operator|=
operator|(
name|ClientData
operator|)
name|cmdPtr
expr_stmt|;
name|cmdPtr
operator|->
name|deleteProc
operator|=
name|deleteProc
expr_stmt|;
name|cmdPtr
operator|->
name|deleteData
operator|=
name|clientData
expr_stmt|;
name|cmdPtr
operator|->
name|deleted
operator|=
literal|0
expr_stmt|;
name|cmdPtr
operator|->
name|importRefPtr
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|Tcl_Command
operator|)
name|cmdPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclInvokeStringCommand --  *  *	"Wrapper" Tcl_ObjCmdProc used to call an existing string-based  *	Tcl_CmdProc if no object-based procedure exists for a command. A  *	pointer to this procedure is stored as the Tcl_ObjCmdProc in a  *	Command structure. It simply turns around and calls the string  *	Tcl_CmdProc in the Command structure.  *  * Results:  *	A standard Tcl object result value.  *  * Side effects:  *	Besides those side effects of the called Tcl_CmdProc,  *	TclInvokeStringCommand allocates and frees storage.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclInvokeStringCommand
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Points to command's Command structure. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
specifier|register
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
specifier|register
name|Command
modifier|*
name|cmdPtr
init|=
operator|(
name|Command
operator|*
operator|)
name|clientData
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/*      * This procedure generates an argv array for the string arguments. It      * starts out with stack-allocated space but uses dynamically-allocated      * storage if needed.      */
define|#
directive|define
name|NUM_ARGS
value|20
name|char
argument_list|*
operator|(
name|argStorage
index|[
name|NUM_ARGS
index|]
operator|)
argument_list|;
name|char
operator|*
operator|*
name|argv
operator|=
name|argStorage
argument_list|;
comment|/*      * Create the string argument array "argv". Make sure argv is large      * enough to hold the objc arguments plus 1 extra for the zero      * end-of-argv word.      * THIS FAILS IF ANY ARGUMENT OBJECT CONTAINS AN EMBEDDED NULL.      */
argument_list|if
operator|(
operator|(
name|objc
operator|+
literal|1
operator|)
operator|>
name|NUM_ARGS
operator|)
block|{
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|objc
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
block|;     }
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|argv
index|[
name|i
index|]
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|argv
index|[
name|objc
index|]
operator|=
literal|0
expr_stmt|;
comment|/*      * Invoke the command's string-based Tcl_CmdProc.      */
name|result
operator|=
call|(
modifier|*
name|cmdPtr
operator|->
name|proc
call|)
argument_list|(
name|cmdPtr
operator|->
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/*      * Free the argv array if malloc'ed storage was used.      */
if|if
condition|(
name|argv
operator|!=
name|argStorage
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
undef|#
directive|undef
name|NUM_ARGS
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclInvokeObjectCommand --  *  *	"Wrapper" Tcl_CmdProc used to call an existing object-based  *	Tcl_ObjCmdProc if no string-based procedure exists for a command.  *	A pointer to this procedure is stored as the Tcl_CmdProc in a  *	Command structure. It simply turns around and calls the object  *	Tcl_ObjCmdProc in the Command structure.  *  * Results:  *	A standard Tcl string result value.  *  * Side effects:  *	Besides those side effects of the called Tcl_CmdProc,  *	TclInvokeStringCommand allocates and frees storage.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclInvokeObjectCommand
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Points to command's Command structure. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Command
modifier|*
name|cmdPtr
init|=
operator|(
name|Command
operator|*
operator|)
name|clientData
decl_stmt|;
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|length
decl_stmt|,
name|result
decl_stmt|;
comment|/*      * This procedure generates an objv array for object arguments that hold      * the argv strings. It starts out with stack-allocated space but uses      * dynamically-allocated storage if needed.      */
define|#
directive|define
name|NUM_ARGS
value|20
name|Tcl_Obj
argument_list|*
operator|(
name|argStorage
index|[
name|NUM_ARGS
index|]
operator|)
argument_list|;
specifier|register
name|Tcl_Obj
operator|*
operator|*
name|objv
operator|=
name|argStorage
argument_list|;
comment|/*      * Create the object argument array "objv". Make sure objv is large      * enough to hold the objc arguments plus 1 extra for the zero      * end-of-objv word.      */
argument_list|if
operator|(
operator|(
name|argc
operator|+
literal|1
operator|)
operator|>
name|NUM_ARGS
operator|)
block|{
name|objv
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|argc
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
argument_list|)
block|;     }
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|length
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|TclNewObj
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|TclInitStringRep
argument_list|(
name|objPtr
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|objv
index|[
name|i
index|]
operator|=
name|objPtr
expr_stmt|;
block|}
name|objv
index|[
name|argc
index|]
operator|=
literal|0
expr_stmt|;
comment|/*      * Invoke the command's object-based Tcl_ObjCmdProc.      */
name|result
operator|=
call|(
modifier|*
name|cmdPtr
operator|->
name|objProc
call|)
argument_list|(
name|cmdPtr
operator|->
name|objClientData
argument_list|,
name|interp
argument_list|,
name|argc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
comment|/*      * Move the interpreter's object result to the string result,       * then reset the object result.      * FAILS IF OBJECT RESULT'S STRING REPRESENTATION CONTAINS NULL BYTES.      */
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|TclGetStringFromObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
comment|/*      * Decrement the ref counts for the argument objects created above,      * then free the objv array if malloc'ed storage was used.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|objPtr
operator|=
name|objv
index|[
name|i
index|]
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|objv
operator|!=
name|argStorage
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|objv
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
undef|#
directive|undef
name|NUM_ARGS
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclRenameCommand --  *  *      Called to give an existing Tcl command a different name. Both the  *      old command name and the new command name can have "::" namespace  *      qualifiers. If the new command has a different namespace context,  *      the command will be moved to that namespace and will execute in  *	the context of that new namespace.  *  *      If the new command name is NULL or the null string, the command is  *      deleted.  *  * Results:  *      Returns TCL_OK if successful, and TCL_ERROR if anything goes wrong.  *  * Side effects:  *      If anything goes wrong, an error message is returned in the  *      interpreter's result object.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclRenameCommand
parameter_list|(
name|interp
parameter_list|,
name|oldName
parameter_list|,
name|newName
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|char
modifier|*
name|oldName
decl_stmt|;
comment|/* Existing command name. */
name|char
modifier|*
name|newName
decl_stmt|;
comment|/* New command name. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|char
modifier|*
name|newTail
decl_stmt|;
name|Namespace
modifier|*
name|cmdNsPtr
decl_stmt|,
modifier|*
name|newNsPtr
decl_stmt|,
modifier|*
name|dummy1
decl_stmt|,
modifier|*
name|dummy2
decl_stmt|;
name|Tcl_Command
name|cmd
decl_stmt|;
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|,
modifier|*
name|oldHPtr
decl_stmt|;
name|int
name|new
decl_stmt|,
name|result
decl_stmt|;
comment|/*      * Find the existing command. An error is returned if cmdName can't      * be found.      */
name|cmd
operator|=
name|Tcl_FindCommand
argument_list|(
name|interp
argument_list|,
name|oldName
argument_list|,
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|NULL
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|cmd
expr_stmt|;
if|if
condition|(
name|cmdPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"can't "
argument_list|,
operator|(
operator|(
name|newName
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|newName
operator|==
literal|'\0'
operator|)
operator|)
condition|?
literal|"delete"
else|:
literal|"rename"
argument_list|,
literal|" \""
argument_list|,
name|oldName
argument_list|,
literal|"\": command doesn't exist"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|cmdNsPtr
operator|=
name|cmdPtr
operator|->
name|nsPtr
expr_stmt|;
comment|/*      * If the new command name is NULL or empty, delete the command. Do this      * with Tcl_DeleteCommandFromToken, since we already have the command.      */
if|if
condition|(
operator|(
name|newName
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|newName
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|Tcl_DeleteCommandFromToken
argument_list|(
name|interp
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
comment|/*      * Make sure that the destination command does not already exist.      * The rename operation is like creating a command, so we should      * automatically create the containing namespaces just like      * Tcl_CreateCommand would.      */
name|result
operator|=
name|TclGetNamespaceForQualName
argument_list|(
name|interp
argument_list|,
name|newName
argument_list|,
operator|(
name|Namespace
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|CREATE_NS_IF_UNKNOWN
operator||
name|TCL_LEAVE_ERR_MSG
operator|)
argument_list|,
operator|&
name|newNsPtr
argument_list|,
operator|&
name|dummy1
argument_list|,
operator|&
name|dummy2
argument_list|,
operator|&
name|newTail
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
if|if
condition|(
operator|(
name|newNsPtr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|newTail
operator|==
name|NULL
operator|)
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"can't rename to \""
argument_list|,
name|newName
argument_list|,
literal|"\": bad command name"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|newNsPtr
operator|->
name|cmdTable
argument_list|,
name|newTail
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"can't rename to \""
argument_list|,
name|newName
argument_list|,
literal|"\": command already exists"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Warning: any changes done in the code here are likely      * to be needed in Tcl_HideCommand() code too.      * (until the common parts are extracted out)     --dl      */
comment|/*      * Put the command in the new namespace so we can check for an alias      * loop. Since we are adding a new command to a namespace, we must      * handle any shadowing of the global commands that this might create.      */
name|oldHPtr
operator|=
name|cmdPtr
operator|->
name|hPtr
expr_stmt|;
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
name|newNsPtr
operator|->
name|cmdTable
argument_list|,
name|newTail
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
operator|(
name|ClientData
operator|)
name|cmdPtr
argument_list|)
expr_stmt|;
name|cmdPtr
operator|->
name|hPtr
operator|=
name|hPtr
expr_stmt|;
name|cmdPtr
operator|->
name|nsPtr
operator|=
name|newNsPtr
expr_stmt|;
name|TclResetShadowedCmdRefs
argument_list|(
name|interp
argument_list|,
name|cmdPtr
argument_list|)
expr_stmt|;
comment|/*      * Now check for an alias loop. If we detect one, put everything back      * the way it was and report the error.      */
name|result
operator|=
name|TclPreventAliasLoop
argument_list|(
name|interp
argument_list|,
name|interp
argument_list|,
operator|(
name|Tcl_Command
operator|)
name|cmdPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_DeleteHashEntry
argument_list|(
name|cmdPtr
operator|->
name|hPtr
argument_list|)
expr_stmt|;
name|cmdPtr
operator|->
name|hPtr
operator|=
name|oldHPtr
expr_stmt|;
name|cmdPtr
operator|->
name|nsPtr
operator|=
name|cmdNsPtr
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/*      * The new command name is okay, so remove the command from its      * current namespace. This is like deleting the command, so bump      * the cmdEpoch to invalidate any cached references to the command.      */
name|Tcl_DeleteHashEntry
argument_list|(
name|oldHPtr
argument_list|)
expr_stmt|;
name|cmdPtr
operator|->
name|cmdEpoch
operator|++
expr_stmt|;
comment|/*      * If the command being renamed has a compile procedure, increment the      * interpreter's compileEpoch to invalidate its compiled code. This      * makes sure that we don't later try to execute old code compiled for      * the now-renamed command.      */
if|if
condition|(
name|cmdPtr
operator|->
name|compileProc
operator|!=
name|NULL
condition|)
block|{
name|iPtr
operator|->
name|compileEpoch
operator|++
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetCommandInfo --  *  *	Modifies various information about a Tcl command. Note that  *	this procedure will not change a command's namespace; use  *	Tcl_RenameCommand to do that. Also, the isNativeObjectProc  *	member of *infoPtr is ignored.  *  * Results:  *	If cmdName exists in interp, then the information at *infoPtr  *	is stored with the command in place of the current information  *	and 1 is returned. If the command doesn't exist then 0 is  *	returned.   *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_SetCommandInfo
parameter_list|(
name|interp
parameter_list|,
name|cmdName
parameter_list|,
name|infoPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to look 					 * for command. */
name|char
modifier|*
name|cmdName
decl_stmt|;
comment|/* Name of desired command. */
name|Tcl_CmdInfo
modifier|*
name|infoPtr
decl_stmt|;
comment|/* Where to store information about 					 * command. */
block|{
name|Tcl_Command
name|cmd
decl_stmt|;
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
name|cmd
operator|=
name|Tcl_FindCommand
argument_list|(
name|interp
argument_list|,
name|cmdName
argument_list|,
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|NULL
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
operator|(
name|Tcl_Command
operator|)
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/*      * The isNativeObjectProc and nsPtr members of *infoPtr are ignored.      */
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|cmd
expr_stmt|;
name|cmdPtr
operator|->
name|proc
operator|=
name|infoPtr
operator|->
name|proc
expr_stmt|;
name|cmdPtr
operator|->
name|clientData
operator|=
name|infoPtr
operator|->
name|clientData
expr_stmt|;
if|if
condition|(
name|infoPtr
operator|->
name|objProc
operator|==
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|NULL
condition|)
block|{
name|cmdPtr
operator|->
name|objProc
operator|=
name|TclInvokeStringCommand
expr_stmt|;
name|cmdPtr
operator|->
name|objClientData
operator|=
operator|(
name|ClientData
operator|)
name|cmdPtr
expr_stmt|;
block|}
else|else
block|{
name|cmdPtr
operator|->
name|objProc
operator|=
name|infoPtr
operator|->
name|objProc
expr_stmt|;
name|cmdPtr
operator|->
name|objClientData
operator|=
name|infoPtr
operator|->
name|objClientData
expr_stmt|;
block|}
name|cmdPtr
operator|->
name|deleteProc
operator|=
name|infoPtr
operator|->
name|deleteProc
expr_stmt|;
name|cmdPtr
operator|->
name|deleteData
operator|=
name|infoPtr
operator|->
name|deleteData
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetCommandInfo --  *  *	Returns various information about a Tcl command.  *  * Results:  *	If cmdName exists in interp, then *infoPtr is modified to  *	hold information about cmdName and 1 is returned.  If the  *	command doesn't exist then 0 is returned and *infoPtr isn't  *	modified.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_GetCommandInfo
parameter_list|(
name|interp
parameter_list|,
name|cmdName
parameter_list|,
name|infoPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to look 					 * for command. */
name|char
modifier|*
name|cmdName
decl_stmt|;
comment|/* Name of desired command. */
name|Tcl_CmdInfo
modifier|*
name|infoPtr
decl_stmt|;
comment|/* Where to store information about 					 * command. */
block|{
name|Tcl_Command
name|cmd
decl_stmt|;
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
name|cmd
operator|=
name|Tcl_FindCommand
argument_list|(
name|interp
argument_list|,
name|cmdName
argument_list|,
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|NULL
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
operator|(
name|Tcl_Command
operator|)
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/*      * Set isNativeObjectProc 1 if objProc was registered by a call to      * Tcl_CreateObjCommand. Otherwise set it to 0.      */
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|cmd
expr_stmt|;
name|infoPtr
operator|->
name|isNativeObjectProc
operator|=
operator|(
name|cmdPtr
operator|->
name|objProc
operator|!=
name|TclInvokeStringCommand
operator|)
expr_stmt|;
name|infoPtr
operator|->
name|objProc
operator|=
name|cmdPtr
operator|->
name|objProc
expr_stmt|;
name|infoPtr
operator|->
name|objClientData
operator|=
name|cmdPtr
operator|->
name|objClientData
expr_stmt|;
name|infoPtr
operator|->
name|proc
operator|=
name|cmdPtr
operator|->
name|proc
expr_stmt|;
name|infoPtr
operator|->
name|clientData
operator|=
name|cmdPtr
operator|->
name|clientData
expr_stmt|;
name|infoPtr
operator|->
name|deleteProc
operator|=
name|cmdPtr
operator|->
name|deleteProc
expr_stmt|;
name|infoPtr
operator|->
name|deleteData
operator|=
name|cmdPtr
operator|->
name|deleteData
expr_stmt|;
name|infoPtr
operator|->
name|namespacePtr
operator|=
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|cmdPtr
operator|->
name|nsPtr
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetCommandName --  *  *	Given a token returned by Tcl_CreateCommand, this procedure  *	returns the current name of the command (which may have changed  *	due to renaming).  *  * Results:  *	The return value is the name of the given command.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_GetCommandName
parameter_list|(
name|interp
parameter_list|,
name|command
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter containing the command. */
name|Tcl_Command
name|command
decl_stmt|;
comment|/* Token for command returned by a previous 				 * call to Tcl_CreateCommand. The command 				 * must not have been deleted. */
block|{
name|Command
modifier|*
name|cmdPtr
init|=
operator|(
name|Command
operator|*
operator|)
name|command
decl_stmt|;
if|if
condition|(
operator|(
name|cmdPtr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|cmdPtr
operator|->
name|hPtr
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* 	 * This should only happen if command was "created" after the 	 * interpreter began to be deleted, so there isn't really any 	 * command. Just return an empty string. 	 */
return|return
literal|""
return|;
block|}
return|return
name|Tcl_GetHashKey
argument_list|(
name|cmdPtr
operator|->
name|hPtr
operator|->
name|tablePtr
argument_list|,
name|cmdPtr
operator|->
name|hPtr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetCommandFullName --  *  *	Given a token returned by, e.g., Tcl_CreateCommand or  *	Tcl_FindCommand, this procedure appends to an object the command's  *	full name, qualified by a sequence of parent namespace names. The  *	command's fully-qualified name may have changed due to renaming.  *  * Results:  *	None.  *  * Side effects:  *	The command's fully-qualified name is appended to the string  *	representation of objPtr.   *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_GetCommandFullName
parameter_list|(
name|interp
parameter_list|,
name|command
parameter_list|,
name|objPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter containing the command. */
name|Tcl_Command
name|command
decl_stmt|;
comment|/* Token for command returned by a previous 				 * call to Tcl_CreateCommand. The command 				 * must not have been deleted. */
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Points to the object onto which the 				 * command's full name is appended. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
specifier|register
name|Command
modifier|*
name|cmdPtr
init|=
operator|(
name|Command
operator|*
operator|)
name|command
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/*      * Add the full name of the containing namespace, followed by the "::"      * separator, and the command name.      */
if|if
condition|(
name|cmdPtr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cmdPtr
operator|->
name|nsPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendToObj
argument_list|(
name|objPtr
argument_list|,
name|cmdPtr
operator|->
name|nsPtr
operator|->
name|fullName
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdPtr
operator|->
name|nsPtr
operator|!=
name|iPtr
operator|->
name|globalNsPtr
condition|)
block|{
name|Tcl_AppendToObj
argument_list|(
name|objPtr
argument_list|,
literal|"::"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cmdPtr
operator|->
name|hPtr
operator|!=
name|NULL
condition|)
block|{
name|name
operator|=
name|Tcl_GetHashKey
argument_list|(
name|cmdPtr
operator|->
name|hPtr
operator|->
name|tablePtr
argument_list|,
name|cmdPtr
operator|->
name|hPtr
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|objPtr
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DeleteCommand --  *  *	Remove the given command from the given interpreter.  *  * Results:  *	0 is returned if the command was deleted successfully.  *	-1 is returned if there didn't exist a command by that name.  *  * Side effects:  *	cmdName will no longer be recognized as a valid command for  *	interp.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_DeleteCommand
parameter_list|(
name|interp
parameter_list|,
name|cmdName
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Token for command interpreter (returned 				 * by a previous Tcl_CreateInterp call). */
name|char
modifier|*
name|cmdName
decl_stmt|;
comment|/* Name of command to remove. */
block|{
name|Tcl_Command
name|cmd
decl_stmt|;
comment|/*      *  Find the desired command and delete it.      */
name|cmd
operator|=
name|Tcl_FindCommand
argument_list|(
name|interp
argument_list|,
name|cmdName
argument_list|,
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|NULL
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
operator|(
name|Tcl_Command
operator|)
name|NULL
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
name|Tcl_DeleteCommandFromToken
argument_list|(
name|interp
argument_list|,
name|cmd
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DeleteCommandFromToken --  *  *	Removes the given command from the given interpreter. This procedure  *	resembles Tcl_DeleteCommand, but takes a Tcl_Command token instead  *	of a command name for efficiency.  *  * Results:  *	0 is returned if the command was deleted successfully.  *	-1 is returned if there didn't exist a command by that name.  *  * Side effects:  *	The command specified by "cmd" will no longer be recognized as a  *	valid command for "interp".  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_DeleteCommandFromToken
parameter_list|(
name|interp
parameter_list|,
name|cmd
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Token for command interpreter returned by 				 * a previous call to Tcl_CreateInterp. */
name|Tcl_Command
name|cmd
decl_stmt|;
comment|/* Token for command to delete. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Command
modifier|*
name|cmdPtr
init|=
operator|(
name|Command
operator|*
operator|)
name|cmd
decl_stmt|;
name|ImportRef
modifier|*
name|refPtr
decl_stmt|,
modifier|*
name|nextRefPtr
decl_stmt|;
name|Tcl_Command
name|importCmd
decl_stmt|;
comment|/*      * The code here is tricky.  We can't delete the hash table entry      * before invoking the deletion callback because there are cases      * where the deletion callback needs to invoke the command (e.g.      * object systems such as OTcl). However, this means that the      * callback could try to delete or rename the command. The deleted      * flag allows us to detect these cases and skip nested deletes.      */
if|if
condition|(
name|cmdPtr
operator|->
name|deleted
condition|)
block|{
comment|/* 	 * Another deletion is already in progress.  Remove the hash 	 * table entry now, but don't invoke a callback or free the 	 * command structure. 	 */
name|Tcl_DeleteHashEntry
argument_list|(
name|cmdPtr
operator|->
name|hPtr
argument_list|)
expr_stmt|;
name|cmdPtr
operator|->
name|hPtr
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*      * If the command being deleted has a compile procedure, increment the      * interpreter's compileEpoch to invalidate its compiled code. This      * makes sure that we don't later try to execute old code compiled with      * command-specific (i.e., inline) bytecodes for the now-deleted      * command. This field is checked in Tcl_EvalObj and ObjInterpProc, and      * code whose compilation epoch doesn't match is recompiled.      */
if|if
condition|(
name|cmdPtr
operator|->
name|compileProc
operator|!=
name|NULL
condition|)
block|{
name|iPtr
operator|->
name|compileEpoch
operator|++
expr_stmt|;
block|}
name|cmdPtr
operator|->
name|deleted
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cmdPtr
operator|->
name|deleteProc
operator|!=
name|NULL
condition|)
block|{
comment|/* 	 * Delete the command's client data. If this was an imported command 	 * created when a command was imported into a namespace, this client 	 * data will be a pointer to a ImportedCmdData structure describing 	 * the "real" command that this imported command refers to. 	 */
call|(
modifier|*
name|cmdPtr
operator|->
name|deleteProc
call|)
argument_list|(
name|cmdPtr
operator|->
name|deleteData
argument_list|)
expr_stmt|;
block|}
comment|/*      * Bump the command epoch counter. This will invalidate all cached      * references that point to this command.      */
name|cmdPtr
operator|->
name|cmdEpoch
operator|++
expr_stmt|;
comment|/*      * If this command was imported into other namespaces, then imported      * commands were created that refer back to this command. Delete these      * imported commands now.      */
for|for
control|(
name|refPtr
operator|=
name|cmdPtr
operator|->
name|importRefPtr
init|;
name|refPtr
operator|!=
name|NULL
condition|;
name|refPtr
operator|=
name|nextRefPtr
control|)
block|{
name|nextRefPtr
operator|=
name|refPtr
operator|->
name|nextPtr
expr_stmt|;
name|importCmd
operator|=
operator|(
name|Tcl_Command
operator|)
name|refPtr
operator|->
name|importedCmdPtr
expr_stmt|;
name|Tcl_DeleteCommandFromToken
argument_list|(
name|interp
argument_list|,
name|importCmd
argument_list|)
expr_stmt|;
block|}
comment|/*      * Don't use hPtr to delete the hash entry here, because it's      * possible that the deletion callback renamed the command.      * Instead, use cmdPtr->hptr, and make sure that no-one else      * has already deleted the hash entry.      */
if|if
condition|(
name|cmdPtr
operator|->
name|hPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DeleteHashEntry
argument_list|(
name|cmdPtr
operator|->
name|hPtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * Mark the Command structure as no longer valid. This allows      * TclExecuteByteCode to recognize when a Command has logically been      * deleted and a pointer to this Command structure cached in a CmdName      * object is invalid. TclExecuteByteCode will look up the command again      * in the interpreter's command hashtable.      */
name|cmdPtr
operator|->
name|objProc
operator|=
name|NULL
expr_stmt|;
comment|/*      * Now free the Command structure, unless there is another reference to      * it from a CmdName Tcl object in some ByteCode code sequence. In that      * case, delay the cleanup until all references are either discarded      * (when a ByteCode is freed) or replaced by a new reference (when a      * cached CmdName Command reference is found to be invalid and      * TclExecuteByteCode looks up the command in the command hashtable).      */
name|TclCleanupCommand
argument_list|(
name|cmdPtr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCleanupCommand --  *  *	This procedure frees up a Command structure unless it is still  *	referenced from an interpreter's command hashtable or from a CmdName  *	Tcl object representing the name of a command in a ByteCode  *	instruction sequence.   *  * Results:  *	None.  *  * Side effects:  *	Memory gets freed unless a reference to the Command structure still  *	exists. In that case the cleanup is delayed until the command is  *	deleted or when the last ByteCode referring to it is freed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclCleanupCommand
parameter_list|(
name|cmdPtr
parameter_list|)
specifier|register
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
comment|/* Points to the Command structure to 				 * be freed. */
block|{
name|cmdPtr
operator|->
name|refCount
operator|--
expr_stmt|;
if|if
condition|(
name|cmdPtr
operator|->
name|refCount
operator|<=
literal|0
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cmdPtr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_Eval --  *  *	Execute a Tcl command in a string.  *  * Results:  *	The return value is one of the return codes defined in tcl.h  *	(such as TCL_OK), and interp->result contains a string value  *	to supplement the return code. The value of interp->result  *	will persist only until the next call to Tcl_Eval or Tcl_EvalObj:  *	you must copy it or lose it!  *  * Side effects:  *	The string is compiled to produce a ByteCode object that holds the  *	command's bytecode instructions. However, this ByteCode object is  *	lost after executing the command. The command's execution will  *	almost certainly have side effects. interp->termOffset is set to the  *	offset of the character in "string" just after the last one  *	successfully compiled or executed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_Eval
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Token for command interpreter (returned 				 * by previous call to Tcl_CreateInterp). */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Pointer to TCL command to execute. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|cmdPtr
decl_stmt|;
name|int
name|length
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
comment|/* 	 * Initialize a Tcl object from the command string. 	 */
name|TclNewObj
argument_list|(
name|cmdPtr
argument_list|)
expr_stmt|;
name|TclInitStringRep
argument_list|(
name|cmdPtr
argument_list|,
name|string
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|cmdPtr
argument_list|)
expr_stmt|;
comment|/* 	 * Compile and execute the bytecodes. 	 */
name|result
operator|=
name|Tcl_EvalObj
argument_list|(
name|interp
argument_list|,
name|cmdPtr
argument_list|)
expr_stmt|;
comment|/* 	 * Move the interpreter's object result to the string result,  	 * then reset the object result. 	 * FAILS IF OBJECT RESULT'S STRING REPRESENTATION CONTAINS NULLS. 	 */
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|TclGetStringFromObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
comment|/* 	 * Discard the Tcl object created to hold the command and its code. 	 */
name|Tcl_DecrRefCount
argument_list|(
name|cmdPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * An empty string. Just reset the interpreter's result. 	 */
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_OK
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_EvalObj --  *  *	Execute Tcl commands stored in a Tcl object. These commands are  *	compiled into bytecodes if necessary.  *  * Results:  *	The return value is one of the return codes defined in tcl.h  *	(such as TCL_OK), and the interpreter's result contains a value  *	to supplement the return code.  *  * Side effects:  *	The object is converted, if necessary, to a ByteCode object that  *	holds the bytecode instructions for the commands. Executing the  *	commands will almost certainly have side effects that depend  *	on those commands.  *  *	Just as in Tcl_Eval, interp->termOffset is set to the offset of the  *	last character executed in the objPtr's string.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_EvalObj
parameter_list|(
name|interp
parameter_list|,
name|objPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Token for command interpreter 					 * (returned by a previous call to 					 * Tcl_CreateInterp). */
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Pointer to object containing 					 * commands to execute. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/* Interp->evalFlags value when the 					 * procedure was called. */
specifier|register
name|ByteCode
modifier|*
name|codePtr
decl_stmt|;
comment|/* Tcl Internal type of bytecode. */
name|int
name|oldCount
init|=
name|iPtr
operator|->
name|cmdCount
decl_stmt|;
comment|/* Used to tell whether any commands 					 * at all were executed. */
name|int
name|numSrcChars
decl_stmt|;
specifier|register
name|int
name|result
decl_stmt|;
comment|/*      * Reset both the interpreter's string and object results and clear out      * any error information. This makes sure that we return an empty      * result if there are no commands in the command string.      */
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
comment|/*      * Check depth of nested calls to Tcl_Eval:  if this gets too large,      * it's probably because of an infinite loop somewhere.      */
name|iPtr
operator|->
name|numLevels
operator|++
expr_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|numLevels
operator|>
name|iPtr
operator|->
name|maxNestingDepth
condition|)
block|{
name|iPtr
operator|->
name|numLevels
operator|--
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"too many nested calls to Tcl_EvalObj (infinite loop?)"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * On the Mac, we will never reach the default recursion limit before blowing      * the stack. So we need to do a check here.      */
if|if
condition|(
name|TclpCheckStackSpace
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|/*NOTREACHED*/
name|iPtr
operator|->
name|numLevels
operator|--
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"too many nested calls to Tcl_EvalObj (infinite loop?)"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * If the interpreter has been deleted, return an error.      */
if|if
condition|(
name|iPtr
operator|->
name|flags
operator|&
name|DELETED
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"attempt to call eval in deleted interpreter"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"CORE"
argument_list|,
literal|"IDELETE"
argument_list|,
literal|"attempt to call eval in deleted interpreter"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|numLevels
operator|--
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Get the ByteCode from the object. If it exists, make sure it hasn't      * been invalidated by, e.g., someone redefining a command with a      * compile procedure (this might make the compiled code wrong). If      * necessary, convert the object to be a ByteCode object and compile it.      * Also, if the code was compiled in/for a different interpreter,      * we recompile it.      */
if|if
condition|(
name|objPtr
operator|->
name|typePtr
operator|==
operator|&
name|tclByteCodeType
condition|)
block|{
name|codePtr
operator|=
operator|(
name|ByteCode
operator|*
operator|)
name|objPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
expr_stmt|;
if|if
condition|(
operator|(
name|codePtr
operator|->
name|iPtr
operator|!=
name|iPtr
operator|)
operator|||
operator|(
name|codePtr
operator|->
name|compileEpoch
operator|!=
name|iPtr
operator|->
name|compileEpoch
operator|)
condition|)
block|{
name|tclByteCodeType
operator|.
name|freeIntRepProc
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|objPtr
operator|->
name|typePtr
operator|!=
operator|&
name|tclByteCodeType
condition|)
block|{
comment|/* 	 * First reset any error line number information. 	 */
name|iPtr
operator|->
name|errorLine
operator|=
literal|1
expr_stmt|;
comment|/* no correct line # information yet */
name|result
operator|=
name|tclByteCodeType
operator|.
name|setFromAnyProc
argument_list|(
name|interp
argument_list|,
name|objPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|iPtr
operator|->
name|numLevels
operator|--
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
name|codePtr
operator|=
operator|(
name|ByteCode
operator|*
operator|)
name|objPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
expr_stmt|;
comment|/*      * Extract then reset the compilation flags in the interpreter.      * Resetting the flags must be done after any compilation.      */
name|flags
operator|=
name|iPtr
operator|->
name|evalFlags
expr_stmt|;
name|iPtr
operator|->
name|evalFlags
operator|=
literal|0
expr_stmt|;
comment|/*      * Execute the commands. If the code was compiled from an empty string,      * don't bother executing the code.      */
name|numSrcChars
operator|=
name|codePtr
operator|->
name|numSrcChars
expr_stmt|;
if|if
condition|(
name|numSrcChars
operator|>
literal|0
condition|)
block|{
comment|/* 	 * Increment the code's ref count while it is being executed. If 	 * afterwards no references to it remain, free the code. 	 */
name|codePtr
operator|->
name|refCount
operator|++
expr_stmt|;
name|result
operator|=
name|TclExecuteByteCode
argument_list|(
name|interp
argument_list|,
name|codePtr
argument_list|)
expr_stmt|;
name|codePtr
operator|->
name|refCount
operator|--
expr_stmt|;
if|if
condition|(
name|codePtr
operator|->
name|refCount
operator|<=
literal|0
condition|)
block|{
name|TclCleanupByteCode
argument_list|(
name|codePtr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_OK
expr_stmt|;
block|}
comment|/*      * If no commands at all were executed, check for asynchronous      * handlers so that they at least get one change to execute.      * This is needed to handle event loops written in Tcl with      * empty bodies.      */
if|if
condition|(
operator|(
name|oldCount
operator|==
name|iPtr
operator|->
name|cmdCount
operator|)
operator|&&
operator|(
name|Tcl_AsyncReady
argument_list|()
operator|)
condition|)
block|{
name|result
operator|=
name|Tcl_AsyncInvoke
argument_list|(
name|interp
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
comment|/*      * Free up any extra resources that were allocated.      */
name|iPtr
operator|->
name|numLevels
operator|--
expr_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|numLevels
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_RETURN
condition|)
block|{
name|result
operator|=
name|TclUpdateReturnInfo
argument_list|(
name|iPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|result
operator|!=
name|TCL_OK
operator|)
operator|&&
operator|(
name|result
operator|!=
name|TCL_ERROR
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|TCL_ALLOW_EXCEPTIONS
operator|)
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_BREAK
condition|)
block|{
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"invoked \"break\" outside of a loop"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|TCL_CONTINUE
condition|)
block|{
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"invoked \"continue\" outside of a loop"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"command returned bad code: %d"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
block|}
comment|/*      * If an error occurred, record information about what was being      * executed when the error occurred.      */
if|if
condition|(
operator|(
name|result
operator|==
name|TCL_ERROR
operator|)
operator|&&
operator|!
operator|(
name|iPtr
operator|->
name|flags
operator|&
name|ERR_ALREADY_LOGGED
operator|)
condition|)
block|{
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
name|char
modifier|*
name|ellipsis
init|=
literal|""
decl_stmt|;
name|char
modifier|*
name|bytes
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* 	 * Figure out how much of the command to print in the error 	 * message (up to a certain number of characters, or up to 	 * the first new-line). 	 * THIS FAILS IF THE OBJECT'S STRING REP CONTAINS A NULL. 	 */
name|bytes
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|length
operator|=
name|TclMin
argument_list|(
name|numSrcChars
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|150
condition|)
block|{
name|length
operator|=
literal|150
expr_stmt|;
name|ellipsis
operator|=
literal|" ..."
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|iPtr
operator|->
name|flags
operator|&
name|ERR_IN_PROGRESS
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\n    while executing\n\"%.*s%s\""
argument_list|,
name|length
argument_list|,
name|bytes
argument_list|,
name|ellipsis
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\n    invoked from within\n\"%.*s%s\""
argument_list|,
name|length
argument_list|,
name|bytes
argument_list|,
name|ellipsis
argument_list|)
expr_stmt|;
block|}
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*      * Set the interpreter's termOffset member to the offset of the      * character just after the last one executed. We approximate the offset      * of the last character executed by using the number of characters      * compiled.      */
name|iPtr
operator|->
name|termOffset
operator|=
name|numSrcChars
expr_stmt|;
name|iPtr
operator|->
name|flags
operator|&=
operator|~
name|ERR_ALREADY_LOGGED
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * Tcl_ExprLong, Tcl_ExprDouble, Tcl_ExprBoolean --  *  *	Procedures to evaluate an expression and return its value in a  *	particular form.  *  * Results:  *	Each of the procedures below returns a standard Tcl result. If an  *	error occurs then an error message is left in interp->result.  *	Otherwise the value of the expression, in the appropriate form, is  *	stored at *ptr. If the expression had a result that was  *	incompatible with the desired form then an error is returned.  *  * Side effects:  *	None.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_ExprLong
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|ptr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Context in which to evaluate the 				 * expression. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Expression to evaluate. */
name|long
modifier|*
name|ptr
decl_stmt|;
comment|/* Where to store result. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|exprPtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|resultPtr
decl_stmt|;
name|int
name|length
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|exprPtr
operator|=
name|Tcl_NewStringObj
argument_list|(
name|string
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|exprPtr
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_ExprObj
argument_list|(
name|interp
argument_list|,
name|exprPtr
argument_list|,
operator|&
name|resultPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
comment|/* 	     * Store an integer based on the expression result. 	     */
if|if
condition|(
name|resultPtr
operator|->
name|typePtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
operator|*
name|ptr
operator|=
name|resultPtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|resultPtr
operator|->
name|typePtr
operator|==
operator|&
name|tclDoubleType
condition|)
block|{
operator|*
name|ptr
operator|=
operator|(
name|long
operator|)
name|resultPtr
operator|->
name|internalRep
operator|.
name|doubleValue
expr_stmt|;
block|}
else|else
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"expression didn't have numeric value"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
name|Tcl_DecrRefCount
argument_list|(
name|resultPtr
argument_list|)
expr_stmt|;
comment|/* discard the result object */
block|}
else|else
block|{
comment|/* 	     * Move the interpreter's object result to the string result,  	     * then reset the object result. 	     * FAILS IF OBJECT RESULT'S STRING REPRESENTATION HAS NULLS. 	     */
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|TclGetStringFromObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
name|Tcl_DecrRefCount
argument_list|(
name|exprPtr
argument_list|)
expr_stmt|;
comment|/* discard the expression object */
block|}
else|else
block|{
comment|/* 	 * An empty string. Just set the result integer to 0. 	 */
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|Tcl_ExprDouble
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|ptr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Context in which to evaluate the 				 * expression. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Expression to evaluate. */
name|double
modifier|*
name|ptr
decl_stmt|;
comment|/* Where to store result. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|exprPtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|resultPtr
decl_stmt|;
name|int
name|length
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|exprPtr
operator|=
name|Tcl_NewStringObj
argument_list|(
name|string
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|exprPtr
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_ExprObj
argument_list|(
name|interp
argument_list|,
name|exprPtr
argument_list|,
operator|&
name|resultPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
comment|/* 	     * Store a double  based on the expression result. 	     */
if|if
condition|(
name|resultPtr
operator|->
name|typePtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
operator|*
name|ptr
operator|=
operator|(
name|double
operator|)
name|resultPtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|resultPtr
operator|->
name|typePtr
operator|==
operator|&
name|tclDoubleType
condition|)
block|{
operator|*
name|ptr
operator|=
name|resultPtr
operator|->
name|internalRep
operator|.
name|doubleValue
expr_stmt|;
block|}
else|else
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"expression didn't have numeric value"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
name|Tcl_DecrRefCount
argument_list|(
name|resultPtr
argument_list|)
expr_stmt|;
comment|/* discard the result object */
block|}
else|else
block|{
comment|/* 	     * Move the interpreter's object result to the string result,  	     * then reset the object result. 	     * FAILS IF OBJECT RESULT'S STRING REPRESENTATION HAS NULLS. 	     */
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|TclGetStringFromObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
name|Tcl_DecrRefCount
argument_list|(
name|exprPtr
argument_list|)
expr_stmt|;
comment|/* discard the expression object */
block|}
else|else
block|{
comment|/* 	 * An empty string. Just set the result double to 0.0. 	 */
operator|*
name|ptr
operator|=
literal|0.0
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|Tcl_ExprBoolean
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|ptr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Context in which to evaluate the 			         * expression. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Expression to evaluate. */
name|int
modifier|*
name|ptr
decl_stmt|;
comment|/* Where to store 0/1 result. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|exprPtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|resultPtr
decl_stmt|;
name|int
name|length
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|exprPtr
operator|=
name|Tcl_NewStringObj
argument_list|(
name|string
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|exprPtr
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_ExprObj
argument_list|(
name|interp
argument_list|,
name|exprPtr
argument_list|,
operator|&
name|resultPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
comment|/* 	     * Store a boolean based on the expression result. 	     */
if|if
condition|(
name|resultPtr
operator|->
name|typePtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
operator|*
name|ptr
operator|=
operator|(
name|resultPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|resultPtr
operator|->
name|typePtr
operator|==
operator|&
name|tclDoubleType
condition|)
block|{
operator|*
name|ptr
operator|=
operator|(
name|resultPtr
operator|->
name|internalRep
operator|.
name|doubleValue
operator|!=
literal|0.0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_GetBooleanFromObj
argument_list|(
name|interp
argument_list|,
name|resultPtr
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
name|Tcl_DecrRefCount
argument_list|(
name|resultPtr
argument_list|)
expr_stmt|;
comment|/* discard the result object */
block|}
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
comment|/* 	     * Move the interpreter's object result to the string result,  	     * then reset the object result. 	     * FAILS IF OBJECT RESULT'S STRING REPRESENTATION HAS NULLS. 	     */
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|TclGetStringFromObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
name|Tcl_DecrRefCount
argument_list|(
name|exprPtr
argument_list|)
expr_stmt|;
comment|/* discard the expression object */
block|}
else|else
block|{
comment|/* 	 * An empty string. Just set the result boolean to 0 (false). 	 */
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * Tcl_ExprLongObj, Tcl_ExprDoubleObj, Tcl_ExprBooleanObj --  *  *	Procedures to evaluate an expression in an object and return its  *	value in a particular form.  *  * Results:  *	Each of the procedures below returns a standard Tcl result  *	object. If an error occurs then an error message is left in the  *	interpreter's result. Otherwise the value of the expression, in the  *	appropriate form, is stored at *ptr. If the expression had a result  *	that was incompatible with the desired form then an error is  *	returned.  *  * Side effects:  *	None.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_ExprLongObj
parameter_list|(
name|interp
parameter_list|,
name|objPtr
parameter_list|,
name|ptr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Context in which to evaluate the 					 * expression. */
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Expression to evaluate. */
name|long
modifier|*
name|ptr
decl_stmt|;
comment|/* Where to store long result. */
block|{
name|Tcl_Obj
modifier|*
name|resultPtr
decl_stmt|;
name|int
name|result
decl_stmt|;
name|result
operator|=
name|Tcl_ExprObj
argument_list|(
name|interp
argument_list|,
name|objPtr
argument_list|,
operator|&
name|resultPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|resultPtr
operator|->
name|typePtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
operator|*
name|ptr
operator|=
name|resultPtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|resultPtr
operator|->
name|typePtr
operator|==
operator|&
name|tclDoubleType
condition|)
block|{
operator|*
name|ptr
operator|=
operator|(
name|long
operator|)
name|resultPtr
operator|->
name|internalRep
operator|.
name|doubleValue
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_GetLongFromObj
argument_list|(
name|interp
argument_list|,
name|resultPtr
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
name|Tcl_DecrRefCount
argument_list|(
name|resultPtr
argument_list|)
expr_stmt|;
comment|/* discard the result object */
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|Tcl_ExprDoubleObj
parameter_list|(
name|interp
parameter_list|,
name|objPtr
parameter_list|,
name|ptr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Context in which to evaluate the 					 * expression. */
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Expression to evaluate. */
name|double
modifier|*
name|ptr
decl_stmt|;
comment|/* Where to store double result. */
block|{
name|Tcl_Obj
modifier|*
name|resultPtr
decl_stmt|;
name|int
name|result
decl_stmt|;
name|result
operator|=
name|Tcl_ExprObj
argument_list|(
name|interp
argument_list|,
name|objPtr
argument_list|,
operator|&
name|resultPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|resultPtr
operator|->
name|typePtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
operator|*
name|ptr
operator|=
operator|(
name|double
operator|)
name|resultPtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|resultPtr
operator|->
name|typePtr
operator|==
operator|&
name|tclDoubleType
condition|)
block|{
operator|*
name|ptr
operator|=
name|resultPtr
operator|->
name|internalRep
operator|.
name|doubleValue
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_GetDoubleFromObj
argument_list|(
name|interp
argument_list|,
name|resultPtr
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
name|Tcl_DecrRefCount
argument_list|(
name|resultPtr
argument_list|)
expr_stmt|;
comment|/* discard the result object */
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|Tcl_ExprBooleanObj
parameter_list|(
name|interp
parameter_list|,
name|objPtr
parameter_list|,
name|ptr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Context in which to evaluate the 					 * expression. */
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Expression to evaluate. */
name|int
modifier|*
name|ptr
decl_stmt|;
comment|/* Where to store 0/1 result. */
block|{
name|Tcl_Obj
modifier|*
name|resultPtr
decl_stmt|;
name|int
name|result
decl_stmt|;
name|result
operator|=
name|Tcl_ExprObj
argument_list|(
name|interp
argument_list|,
name|objPtr
argument_list|,
operator|&
name|resultPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|resultPtr
operator|->
name|typePtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
operator|*
name|ptr
operator|=
operator|(
name|resultPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|resultPtr
operator|->
name|typePtr
operator|==
operator|&
name|tclDoubleType
condition|)
block|{
operator|*
name|ptr
operator|=
operator|(
name|resultPtr
operator|->
name|internalRep
operator|.
name|doubleValue
operator|!=
literal|0.0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_GetBooleanFromObj
argument_list|(
name|interp
argument_list|,
name|resultPtr
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
name|Tcl_DecrRefCount
argument_list|(
name|resultPtr
argument_list|)
expr_stmt|;
comment|/* discard the result object */
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclInvoke --  *  *	Invokes a Tcl command, given an argv/argc, from either the  *	exposed or the hidden sets of commands in the given interpreter.  *	NOTE: The command is invoked in the current stack frame of  *	the interpreter, thus it can modify local variables.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Whatever the command does.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclInvoke
parameter_list|(
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Where to invoke the command. */
name|int
name|argc
decl_stmt|;
comment|/* Count of args. */
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* The arg strings; argv[0] is the name of                                  * the command to invoke. */
name|int
name|flags
decl_stmt|;
comment|/* Combination of flags controlling the 				 * call: TCL_INVOKE_HIDDEN and 				 * TCL_INVOKE_NO_UNKNOWN. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|length
decl_stmt|,
name|result
decl_stmt|;
comment|/*      * This procedure generates an objv array for object arguments that hold      * the argv strings. It starts out with stack-allocated space but uses      * dynamically-allocated storage if needed.      */
define|#
directive|define
name|NUM_ARGS
value|20
name|Tcl_Obj
argument_list|*
operator|(
name|objStorage
index|[
name|NUM_ARGS
index|]
operator|)
argument_list|;
specifier|register
name|Tcl_Obj
operator|*
operator|*
name|objv
operator|=
name|objStorage
argument_list|;
comment|/*      * Create the object argument array "objv". Make sure objv is large      * enough to hold the objc arguments plus 1 extra for the zero      * end-of-objv word.      */
argument_list|if
operator|(
operator|(
name|argc
operator|+
literal|1
operator|)
operator|>
name|NUM_ARGS
operator|)
block|{
name|objv
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|argc
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
argument_list|)
block|;     }
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|length
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|objv
index|[
name|i
index|]
operator|=
name|Tcl_NewStringObj
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|objv
index|[
name|argc
index|]
operator|=
literal|0
expr_stmt|;
comment|/*      * Use TclObjInterpProc to actually invoke the command.      */
name|result
operator|=
name|TclObjInvoke
argument_list|(
name|interp
argument_list|,
name|argc
argument_list|,
name|objv
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/*      * Move the interpreter's object result to the string result,       * then reset the object result.      * FAILS IF OBJECT RESULT'S STRING REPRESENTATION CONTAINS NULLS.      */
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|TclGetStringFromObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
comment|/*      * Decrement the ref counts on the objv elements since we are done      * with them.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|objPtr
operator|=
name|objv
index|[
name|i
index|]
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * Free the objv array if malloc'ed storage was used.      */
if|if
condition|(
name|objv
operator|!=
name|objStorage
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|objv
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
undef|#
directive|undef
name|NUM_ARGS
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclGlobalInvoke --  *  *	Invokes a Tcl command, given an argv/argc, from either the  *	exposed or hidden sets of commands in the given interpreter.  *	NOTE: The command is invoked in the global stack frame of  *	the interpreter, thus it cannot see any current state on  *	the stack for that interpreter.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Whatever the command does.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclGlobalInvoke
parameter_list|(
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Where to invoke the command. */
name|int
name|argc
decl_stmt|;
comment|/* Count of args. */
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* The arg strings; argv[0] is the name of                                  * the command to invoke. */
name|int
name|flags
decl_stmt|;
comment|/* Combination of flags controlling the 				 * call: TCL_INVOKE_HIDDEN and 				 * TCL_INVOKE_NO_UNKNOWN. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|int
name|result
decl_stmt|;
name|CallFrame
modifier|*
name|savedVarFramePtr
decl_stmt|;
name|savedVarFramePtr
operator|=
name|iPtr
operator|->
name|varFramePtr
expr_stmt|;
name|iPtr
operator|->
name|varFramePtr
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|TclInvoke
argument_list|(
name|interp
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|varFramePtr
operator|=
name|savedVarFramePtr
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclObjInvokeGlobal --  *  *	Object version: Invokes a Tcl command, given an objv/objc, from  *	either the exposed or hidden set of commands in the given  *	interpreter.  *	NOTE: The command is invoked in the global stack frame of the  *	interpreter, thus it cannot see any current state on the  *	stack of that interpreter.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Whatever the command does.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclObjInvokeGlobal
parameter_list|(
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which command is 				 * to be invoked. */
name|int
name|objc
decl_stmt|;
comment|/* Count of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument value objects; objv[0] 				 * points to the name of the 				 * command to invoke. */
name|int
name|flags
decl_stmt|;
comment|/* Combination of flags controlling                                  * the call: TCL_INVOKE_HIDDEN and                                  * TCL_INVOKE_NO_UNKNOWN. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|int
name|result
decl_stmt|;
name|CallFrame
modifier|*
name|savedVarFramePtr
decl_stmt|;
name|savedVarFramePtr
operator|=
name|iPtr
operator|->
name|varFramePtr
expr_stmt|;
name|iPtr
operator|->
name|varFramePtr
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|TclObjInvoke
argument_list|(
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|varFramePtr
operator|=
name|savedVarFramePtr
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclObjInvoke --  *  *	Invokes a Tcl command, given an objv/objc, from either the  *	exposed or the hidden sets of commands in the given interpreter.  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	Whatever the command does.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclObjInvoke
parameter_list|(
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which command is 				 * to be invoked. */
name|int
name|objc
decl_stmt|;
comment|/* Count of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument value objects; objv[0] 				 * points to the name of the 				 * command to invoke. */
name|int
name|flags
decl_stmt|;
comment|/* Combination of flags controlling                                  * the call: TCL_INVOKE_HIDDEN and                                  * TCL_INVOKE_NO_UNKNOWN. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Tcl_HashTable
modifier|*
name|hTblPtr
decl_stmt|;
comment|/* Table of hidden commands. */
name|char
modifier|*
name|cmdName
decl_stmt|;
comment|/* Name of the command from objv[0]. */
specifier|register
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|Tcl_Command
name|cmd
decl_stmt|;
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
name|int
name|localObjc
decl_stmt|;
comment|/* Used to invoke "unknown" if the */
name|Tcl_Obj
modifier|*
modifier|*
name|localObjv
init|=
name|NULL
decl_stmt|;
comment|/* command is not found. */
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|length
decl_stmt|,
name|result
decl_stmt|;
name|char
modifier|*
name|bytes
decl_stmt|;
if|if
condition|(
name|interp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|objc
operator|<
literal|1
operator|)
operator|||
operator|(
name|objv
operator|==
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"illegal argument vector"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * THE FOLLOWING CODE FAILS IF THE STRING REP CONTAINS NULLS.      */
name|cmdName
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|0
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TCL_INVOKE_HIDDEN
condition|)
block|{
comment|/*          * Find the table of hidden commands; error out if none.          */
name|hTblPtr
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclHiddenCmds"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hTblPtr
operator|==
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
condition|)
block|{
name|badhiddenCmdToken
label|:
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"invalid hidden command name \""
argument_list|,
name|cmdName
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
name|hTblPtr
argument_list|,
name|cmdName
argument_list|)
expr_stmt|;
comment|/*          * We never invoke "unknown" for hidden commands.          */
if|if
condition|(
name|hPtr
operator|==
name|NULL
condition|)
block|{
goto|goto
name|badhiddenCmdToken
goto|;
block|}
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmdPtr
operator|=
name|NULL
expr_stmt|;
name|cmd
operator|=
name|Tcl_FindCommand
argument_list|(
name|interp
argument_list|,
name|cmdName
argument_list|,
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|NULL
argument_list|,
comment|/*flags*/
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
operator|(
name|Tcl_Command
operator|)
name|NULL
condition|)
block|{
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|cmd
expr_stmt|;
block|}
if|if
condition|(
name|cmdPtr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TCL_INVOKE_NO_UNKNOWN
operator|)
condition|)
block|{
name|cmd
operator|=
name|Tcl_FindCommand
argument_list|(
name|interp
argument_list|,
literal|"unknown"
argument_list|,
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|NULL
argument_list|,
comment|/*flags*/
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
operator|(
name|Tcl_Command
operator|)
name|NULL
condition|)
block|{
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|cmd
expr_stmt|;
block|}
if|if
condition|(
name|cmdPtr
operator|!=
name|NULL
condition|)
block|{
name|localObjc
operator|=
operator|(
name|objc
operator|+
literal|1
operator|)
expr_stmt|;
name|localObjv
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
operator|*
name|localObjc
argument_list|)
argument_list|)
expr_stmt|;
name|localObjv
index|[
literal|0
index|]
operator|=
name|Tcl_NewStringObj
argument_list|(
literal|"unknown"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|localObjv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|localObjv
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|objv
index|[
name|i
index|]
expr_stmt|;
block|}
name|objc
operator|=
name|localObjc
expr_stmt|;
name|objv
operator|=
name|localObjv
expr_stmt|;
block|}
block|}
comment|/*              * Check again if we found the command. If not, "unknown" is              * not present and we cannot help, or the caller said not to              * call "unknown" (they specified TCL_INVOKE_NO_UNKNOWN).              */
if|if
condition|(
name|cmdPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"invalid command name \""
argument_list|,
name|cmdName
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
block|}
comment|/*      * Invoke the command procedure. First reset the interpreter's string      * and object results to their default empty values since they could      * have gotten changed by earlier invocations.      */
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|cmdCount
operator|++
expr_stmt|;
name|result
operator|=
call|(
modifier|*
name|cmdPtr
operator|->
name|objProc
call|)
argument_list|(
name|cmdPtr
operator|->
name|objClientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
comment|/*      * If an error occurred, record information about what was being      * executed when the error occurred.      */
if|if
condition|(
operator|(
name|result
operator|==
name|TCL_ERROR
operator|)
operator|&&
operator|!
operator|(
name|iPtr
operator|->
name|flags
operator|&
name|ERR_ALREADY_LOGGED
operator|)
condition|)
block|{
name|Tcl_DString
name|ds
decl_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|iPtr
operator|->
name|flags
operator|&
name|ERR_IN_PROGRESS
operator|)
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|ds
argument_list|,
literal|"\n    while invoking\n\""
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|ds
argument_list|,
literal|"\n    invoked from within\n\""
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|bytes
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|ds
argument_list|,
name|bytes
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
name|objc
operator|-
literal|1
operator|)
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|ds
argument_list|,
literal|" "
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Tcl_DStringLength
argument_list|(
operator|&
name|ds
argument_list|)
operator|>
literal|100
condition|)
block|{
name|Tcl_DStringSetLength
argument_list|(
operator|&
name|ds
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|ds
argument_list|,
literal|"..."
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|Tcl_DStringAppend
argument_list|(
operator|&
name|ds
argument_list|,
literal|"\""
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|ds
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|ds
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|flags
operator|&=
operator|~
name|ERR_ALREADY_LOGGED
expr_stmt|;
block|}
comment|/*      * Free any locally allocated storage used to call "unknown".      */
if|if
condition|(
name|localObjv
operator|!=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|localObjv
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * Tcl_ExprString --  *  *	Evaluate an expression in a string and return its value in string  *	form.  *  * Results:  *	A standard Tcl result. If the result is TCL_OK, then the  *	interpreter's result is set to the string value of the  *	expression. If the result is TCL_OK, then interp->result  *	contains an error message.  *  * Side effects:  *	A Tcl object is allocated to hold a copy of the expression string.  *	This expression object is passed to Tcl_ExprObj and then  *	deallocated.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_ExprString
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Context in which to evaluate the 				 * expression. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Expression to evaluate. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|exprPtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|resultPtr
decl_stmt|;
name|int
name|length
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|TclNewObj
argument_list|(
name|exprPtr
argument_list|)
expr_stmt|;
name|TclInitStringRep
argument_list|(
name|exprPtr
argument_list|,
name|string
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|exprPtr
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_ExprObj
argument_list|(
name|interp
argument_list|,
name|exprPtr
argument_list|,
operator|&
name|resultPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
comment|/* 	     * Set the interpreter's string result from the result object. 	     */
if|if
condition|(
name|resultPtr
operator|->
name|typePtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld"
argument_list|,
name|resultPtr
operator|->
name|internalRep
operator|.
name|longValue
argument_list|)
expr_stmt|;
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|resultPtr
operator|->
name|typePtr
operator|==
operator|&
name|tclDoubleType
condition|)
block|{
name|Tcl_PrintDouble
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|resultPtr
operator|->
name|internalRep
operator|.
name|doubleValue
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Set interpreter's string result from the result object. 		 * FAILS IF OBJECT RESULT'S STRING REPRESENTATION HAS NULLS. 		 */
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|TclGetStringFromObj
argument_list|(
name|resultPtr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
name|Tcl_DecrRefCount
argument_list|(
name|resultPtr
argument_list|)
expr_stmt|;
comment|/* discard the result object */
block|}
else|else
block|{
comment|/* 	     * Move the interpreter's object result to the string result,  	     * then reset the object result. 	     * FAILS IF OBJECT RESULT'S STRING REPRESENTATION HAS NULLS. 	     */
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|TclGetStringFromObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
name|Tcl_DecrRefCount
argument_list|(
name|exprPtr
argument_list|)
expr_stmt|;
comment|/* discard the expression object */
block|}
else|else
block|{
comment|/* 	 * An empty string. Just set the interpreter's result to 0. 	 */
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"0"
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * Tcl_ExprObj --  *  *	Evaluate an expression in a Tcl_Obj.  *  * Results:  *	A standard Tcl object result. If the result is other than TCL_OK,  *	then the interpreter's result contains an error message. If the  *	result is TCL_OK, then a pointer to the expression's result value  *	object is stored in resultPtrPtr. In that case, the object's ref  *	count is incremented to reflect the reference returned to the  *	caller; the caller is then responsible for the resulting object  *	and must, for example, decrement the ref count when it is finished  *	with the object.  *  * Side effects:  *	Any side effects caused by subcommands in the expression, if any.  *	The interpreter result is not modified unless there is an error.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_ExprObj
parameter_list|(
name|interp
parameter_list|,
name|objPtr
parameter_list|,
name|resultPtrPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Context in which to evaluate the 				 * expression. */
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Points to Tcl object containing 				 * expression to evaluate. */
name|Tcl_Obj
modifier|*
modifier|*
name|resultPtrPtr
decl_stmt|;
comment|/* Where the Tcl_Obj* that is the expression 				 * result is stored if no errors occur. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|CompileEnv
name|compEnv
decl_stmt|;
comment|/* Compilation environment structure 				 * allocated in frame. */
specifier|register
name|ByteCode
modifier|*
name|codePtr
init|=
name|NULL
decl_stmt|;
comment|/* Tcl Internal type of bytecode. 				 * Initialized to avoid compiler warning. */
name|AuxData
modifier|*
name|auxDataPtr
decl_stmt|;
name|Interp
name|dummy
decl_stmt|;
name|Tcl_Obj
modifier|*
name|saveObjPtr
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*      * Get the ByteCode from the object. If it exists, make sure it hasn't      * been invalidated by, e.g., someone redefining a command with a      * compile procedure (this might make the compiled code wrong). If      * necessary, convert the object to be a ByteCode object and compile it.      * Also, if the code was compiled in/for a different interpreter, we      * recompile it.      * THIS FAILS IF THE OBJECT'S STRING REP HAS A NULL BYTE.      */
if|if
condition|(
name|objPtr
operator|->
name|typePtr
operator|==
operator|&
name|tclByteCodeType
condition|)
block|{
name|codePtr
operator|=
operator|(
name|ByteCode
operator|*
operator|)
name|objPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
expr_stmt|;
if|if
condition|(
operator|(
name|codePtr
operator|->
name|iPtr
operator|!=
name|iPtr
operator|)
operator|||
operator|(
name|codePtr
operator|->
name|compileEpoch
operator|!=
name|iPtr
operator|->
name|compileEpoch
operator|)
condition|)
block|{
name|tclByteCodeType
operator|.
name|freeIntRepProc
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|(
name|Tcl_ObjType
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|objPtr
operator|->
name|typePtr
operator|!=
operator|&
name|tclByteCodeType
condition|)
block|{
name|int
name|length
decl_stmt|;
name|string
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|TclInitCompileEnv
argument_list|(
name|interp
argument_list|,
operator|&
name|compEnv
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|result
operator|=
name|TclCompileExpr
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
name|string
operator|+
name|length
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|compEnv
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
comment|/* 	     * If the expression yielded no instructions (e.g., was empty), 	     * push an integer zero object as the expressions's result. 	     */
if|if
condition|(
name|compEnv
operator|.
name|codeNext
operator|==
name|NULL
condition|)
block|{
name|int
name|objIndex
init|=
name|TclObjIndexForString
argument_list|(
literal|"0"
argument_list|,
literal|0
argument_list|,
comment|/*allocStrRep*/
literal|0
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
operator|&
name|compEnv
argument_list|)
decl_stmt|;
name|Tcl_Obj
modifier|*
name|objPtr
init|=
name|compEnv
operator|.
name|objArrayPtr
index|[
name|objIndex
index|]
decl_stmt|;
name|Tcl_InvalidateStringRep
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|=
literal|0
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclIntType
expr_stmt|;
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
operator|&
name|compEnv
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * Add done instruction at the end of the instruction sequence. 	     */
name|TclEmitOpcode
argument_list|(
name|INST_DONE
argument_list|,
operator|&
name|compEnv
argument_list|)
expr_stmt|;
name|TclInitByteCodeObj
argument_list|(
name|objPtr
argument_list|,
operator|&
name|compEnv
argument_list|)
expr_stmt|;
name|codePtr
operator|=
operator|(
name|ByteCode
operator|*
operator|)
name|objPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
expr_stmt|;
if|if
condition|(
name|tclTraceCompile
operator|==
literal|2
condition|)
block|{
name|TclPrintByteCodeObj
argument_list|(
name|interp
argument_list|,
name|objPtr
argument_list|)
expr_stmt|;
block|}
name|TclFreeCompileEnv
argument_list|(
operator|&
name|compEnv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * Compilation errors. Decrement the ref counts on any objects 	     * in the object array before freeing the compilation 	     * environment. 	     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|compEnv
operator|.
name|objArrayNext
condition|;
name|i
operator|++
control|)
block|{
name|Tcl_Obj
modifier|*
name|elemPtr
init|=
name|compEnv
operator|.
name|objArrayPtr
index|[
name|i
index|]
decl_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|elemPtr
argument_list|)
expr_stmt|;
block|}
name|auxDataPtr
operator|=
name|compEnv
operator|.
name|auxDataArrayPtr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|compEnv
operator|.
name|auxDataArrayNext
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|auxDataPtr
operator|->
name|freeProc
operator|!=
name|NULL
condition|)
block|{
name|auxDataPtr
operator|->
name|freeProc
argument_list|(
name|auxDataPtr
operator|->
name|clientData
argument_list|)
expr_stmt|;
block|}
name|auxDataPtr
operator|++
expr_stmt|;
block|}
name|TclFreeCompileEnv
argument_list|(
operator|&
name|compEnv
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
comment|/*      * Execute the expression after first saving the interpreter's result.      */
name|dummy
operator|.
name|objResultPtr
operator|=
name|Tcl_NewObj
argument_list|()
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|dummy
operator|.
name|objResultPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|interp
operator|->
name|freeProc
operator|==
literal|0
condition|)
block|{
name|dummy
operator|.
name|freeProc
operator|=
operator|(
name|Tcl_FreeProc
operator|*
operator|)
literal|0
expr_stmt|;
name|dummy
operator|.
name|result
operator|=
literal|""
expr_stmt|;
name|Tcl_SetResult
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
operator|&
name|dummy
argument_list|,
name|interp
operator|->
name|result
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dummy
operator|.
name|freeProc
operator|=
name|interp
operator|->
name|freeProc
expr_stmt|;
name|dummy
operator|.
name|result
operator|=
name|interp
operator|->
name|result
expr_stmt|;
name|interp
operator|->
name|freeProc
operator|=
operator|(
name|Tcl_FreeProc
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|saveObjPtr
operator|=
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|saveObjPtr
argument_list|)
expr_stmt|;
comment|/*      * Increment the code's ref count while it is being executed. If      * afterwards no references to it remain, free the code.      */
name|codePtr
operator|->
name|refCount
operator|++
expr_stmt|;
name|result
operator|=
name|TclExecuteByteCode
argument_list|(
name|interp
argument_list|,
name|codePtr
argument_list|)
expr_stmt|;
name|codePtr
operator|->
name|refCount
operator|--
expr_stmt|;
if|if
condition|(
name|codePtr
operator|->
name|refCount
operator|<=
literal|0
condition|)
block|{
name|TclCleanupByteCode
argument_list|(
name|codePtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * If the expression evaluated successfully, store a pointer to its      * value object in resultPtrPtr then restore the old interpreter result.      * We increment the object's ref count to reflect the reference that we      * are returning to the caller. We also decrement the ref count of the      * interpreter's result object after calling Tcl_SetResult since we      * next store into that field directly.      */
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
operator|*
name|resultPtrPtr
operator|=
name|iPtr
operator|->
name|objResultPtr
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|iPtr
operator|->
name|objResultPtr
argument_list|)
expr_stmt|;
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|dummy
operator|.
name|result
argument_list|,
operator|(
operator|(
name|dummy
operator|.
name|freeProc
operator|==
literal|0
operator|)
condition|?
name|TCL_VOLATILE
else|:
name|dummy
operator|.
name|freeProc
operator|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|iPtr
operator|->
name|objResultPtr
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|objResultPtr
operator|=
name|saveObjPtr
expr_stmt|;
block|}
else|else
block|{
name|Tcl_DecrRefCount
argument_list|(
name|saveObjPtr
argument_list|)
expr_stmt|;
name|Tcl_FreeResult
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
operator|&
name|dummy
argument_list|)
expr_stmt|;
block|}
name|Tcl_DecrRefCount
argument_list|(
name|dummy
operator|.
name|objResultPtr
argument_list|)
expr_stmt|;
name|dummy
operator|.
name|objResultPtr
operator|=
name|NULL
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CreateTrace --  *  *	Arrange for a procedure to be called to trace command execution.  *  * Results:  *	The return value is a token for the trace, which may be passed  *	to Tcl_DeleteTrace to eliminate the trace.  *  * Side effects:  *	From now on, proc will be called just before a command procedure  *	is called to execute a Tcl command.  Calls to proc will have the  *	following form:  *  *	void  *	proc(clientData, interp, level, command, cmdProc, cmdClientData,  *		argc, argv)  *	    ClientData clientData;  *	    Tcl_Interp *interp;  *	    int level;  *	    char *command;  *	    int (*cmdProc)();  *	    ClientData cmdClientData;  *	    int argc;  *	    char **argv;  *	{  *	}  *  *	The clientData and interp arguments to proc will be the same  *	as the corresponding arguments to this procedure.  Level gives  *	the nesting level of command interpretation for this interpreter  *	(0 corresponds to top level).  Command gives the ASCII text of  *	the raw command, cmdProc and cmdClientData give the procedure that  *	will be called to process the command and the ClientData value it  *	will receive, and argc and argv give the arguments to the  *	command, after any argument parsing and substitution.  Proc  *	does not return a value.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Trace
name|Tcl_CreateTrace
parameter_list|(
name|interp
parameter_list|,
name|level
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to create trace. */
name|int
name|level
decl_stmt|;
comment|/* Only call proc for commands at nesting 				 * level<=argument level (1=>top level). */
name|Tcl_CmdTraceProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to call before executing each 				 * command. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary value word to pass to proc. */
block|{
specifier|register
name|Trace
modifier|*
name|tracePtr
decl_stmt|;
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
comment|/*      * Invalidate existing compiled code for this interpreter and arrange      * (by setting the DONT_COMPILE_CMDS_INLINE flag) that when compiling      * new code, no commands will be compiled inline (i.e., into an inline      * sequence of instructions). We do this because commands that were      * compiled inline will never result in a command trace being called.      */
name|iPtr
operator|->
name|compileEpoch
operator|++
expr_stmt|;
name|iPtr
operator|->
name|flags
operator||=
name|DONT_COMPILE_CMDS_INLINE
expr_stmt|;
name|tracePtr
operator|=
operator|(
name|Trace
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Trace
argument_list|)
argument_list|)
expr_stmt|;
name|tracePtr
operator|->
name|level
operator|=
name|level
expr_stmt|;
name|tracePtr
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|tracePtr
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
name|tracePtr
operator|->
name|nextPtr
operator|=
name|iPtr
operator|->
name|tracePtr
expr_stmt|;
name|iPtr
operator|->
name|tracePtr
operator|=
name|tracePtr
expr_stmt|;
return|return
operator|(
name|Tcl_Trace
operator|)
name|tracePtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DeleteTrace --  *  *	Remove a trace.  *  * Results:  *	None.  *  * Side effects:  *	From now on there will be no more calls to the procedure given  *	in trace.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DeleteTrace
parameter_list|(
name|interp
parameter_list|,
name|trace
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter that contains trace. */
name|Tcl_Trace
name|trace
decl_stmt|;
comment|/* Token for trace (returned previously by 				 * Tcl_CreateTrace). */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
specifier|register
name|Trace
modifier|*
name|tracePtr
init|=
operator|(
name|Trace
operator|*
operator|)
name|trace
decl_stmt|;
specifier|register
name|Trace
modifier|*
name|tracePtr2
decl_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|tracePtr
operator|==
name|tracePtr
condition|)
block|{
name|iPtr
operator|->
name|tracePtr
operator|=
name|tracePtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tracePtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|tracePtr2
operator|=
name|iPtr
operator|->
name|tracePtr
init|;
name|tracePtr2
operator|!=
name|NULL
condition|;
name|tracePtr2
operator|=
name|tracePtr2
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|tracePtr2
operator|->
name|nextPtr
operator|==
name|tracePtr
condition|)
block|{
name|tracePtr2
operator|->
name|nextPtr
operator|=
name|tracePtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tracePtr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|iPtr
operator|->
name|tracePtr
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * When compiling new code, allow commands to be compiled inline. 	 */
name|iPtr
operator|->
name|flags
operator|&=
operator|~
name|DONT_COMPILE_CMDS_INLINE
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_AddErrorInfo --  *  *	Add information to the "errorInfo" variable that describes the  *	current error.  *  * Results:  *	None.  *  * Side effects:  *	The contents of message are added to the "errorInfo" variable.  *	If Tcl_Eval has been called since the current value of errorInfo  *	was set, errorInfo is cleared before adding the new message.  *	If we are just starting to log an error, errorInfo is initialized  *	from the error message in the interpreter's result.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_AddErrorInfo
parameter_list|(
name|interp
parameter_list|,
name|message
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to which error information 				 * pertains. */
name|char
modifier|*
name|message
decl_stmt|;
comment|/* Message to record. */
block|{
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|message
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_AddObjErrorInfo --  *  *	Add information to the "errorInfo" variable that describes the  *	current error. This routine differs from Tcl_AddErrorInfo by  *	taking a byte pointer and length.  *  * Results:  *	None.  *  * Side effects:  *	"length" bytes from "message" are added to the "errorInfo" variable.  *	If "length" is negative, use bytes up to the first NULL byte.  *	If Tcl_EvalObj has been called since the current value of errorInfo  *	was set, errorInfo is cleared before adding the new message.  *	If we are just starting to log an error, errorInfo is initialized  *	from the error message in the interpreter's result.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_AddObjErrorInfo
parameter_list|(
name|interp
parameter_list|,
name|message
parameter_list|,
name|length
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to which error information 				 * pertains. */
name|char
modifier|*
name|message
decl_stmt|;
comment|/* Points to the first byte of an array of 				 * bytes of the message. */
specifier|register
name|int
name|length
decl_stmt|;
comment|/* The number of bytes in the message. 				 * If< 0, then append all bytes up to a 				 * NULL byte. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Tcl_Obj
modifier|*
name|namePtr
decl_stmt|,
modifier|*
name|messagePtr
decl_stmt|;
comment|/*      * If we are just starting to log an error, errorInfo is initialized      * from the error message in the interpreter's result.      */
name|namePtr
operator|=
name|Tcl_NewStringObj
argument_list|(
literal|"errorInfo"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|iPtr
operator|->
name|flags
operator|&
name|ERR_IN_PROGRESS
operator|)
condition|)
block|{
comment|/* just starting to log error */
name|iPtr
operator|->
name|flags
operator||=
name|ERR_IN_PROGRESS
expr_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|result
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|Tcl_ObjSetVar2
argument_list|(
name|interp
argument_list|,
name|namePtr
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|)
name|NULL
argument_list|,
name|iPtr
operator|->
name|objResultPtr
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* use the string result */
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
literal|"errorInfo"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|interp
operator|->
name|result
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the errorCode variable wasn't set by the code that generated 	 * the error, set it to "NONE". 	 */
if|if
condition|(
operator|!
operator|(
name|iPtr
operator|->
name|flags
operator|&
name|ERROR_CODE_SET
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|"NONE"
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Now append "message" to the end of errorInfo.      */
if|if
condition|(
name|length
operator|!=
literal|0
condition|)
block|{
name|messagePtr
operator|=
name|Tcl_NewStringObj
argument_list|(
name|message
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|messagePtr
argument_list|)
expr_stmt|;
name|Tcl_ObjSetVar2
argument_list|(
name|interp
argument_list|,
name|namePtr
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|)
name|NULL
argument_list|,
name|messagePtr
argument_list|,
operator|(
name|TCL_GLOBAL_ONLY
operator||
name|TCL_APPEND_VALUE
operator|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|messagePtr
argument_list|)
expr_stmt|;
comment|/* free msg object appended above */
block|}
name|Tcl_DecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
comment|/* free the name object */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_VarEval --  *  *	Given a variable number of string arguments, concatenate them  *	all together and execute the result as a Tcl command.  *  * Results:  *	A standard Tcl return result.  An error message or other  *	result may be left in interp->result.  *  * Side effects:  *	Depends on what was done by the command.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* VARARGS2 */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_VarEval
name|TCL_VARARGS_DEF
parameter_list|(
name|Tcl_Interp
modifier|*
parameter_list|,
name|arg1
parameter_list|)
block|{
name|va_list
name|argList
decl_stmt|;
name|Tcl_DString
name|buf
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/*      * Copy the strings one after the other into a single larger      * string.  Use stack-allocated space for small commands, but if      * the command gets too large than call ckalloc to create the      * space.      */
name|interp
operator|=
name|TCL_VARARGS_START
argument_list|(
name|Tcl_Interp
operator|*
argument_list|,
name|arg1
argument_list|,
name|argList
argument_list|)
expr_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|string
operator|=
name|va_arg
argument_list|(
name|argList
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|Tcl_DStringAppend
argument_list|(
operator|&
name|buf
argument_list|,
name|string
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|argList
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GlobalEval --  *  *	Evaluate a command at global level in an interpreter.  *  * Results:  *	A standard Tcl result is returned, and interp->result is  *	modified accordingly.  *  * Side effects:  *	The command string is executed in interp, and the execution  *	is carried out in the variable context of global level (no  *	procedures active), just as if an "uplevel #0" command were  *	being executed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_GlobalEval
parameter_list|(
name|interp
parameter_list|,
name|command
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to evaluate command. */
name|char
modifier|*
name|command
decl_stmt|;
comment|/* Command to evaluate. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|int
name|result
decl_stmt|;
name|CallFrame
modifier|*
name|savedVarFramePtr
decl_stmt|;
name|savedVarFramePtr
operator|=
name|iPtr
operator|->
name|varFramePtr
expr_stmt|;
name|iPtr
operator|->
name|varFramePtr
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|varFramePtr
operator|=
name|savedVarFramePtr
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GlobalEvalObj --  *  *	Execute Tcl commands stored in a Tcl object at global level in  *	an interpreter. These commands are compiled into bytecodes if  *	necessary.  *  * Results:  *	A standard Tcl result is returned, and the interpreter's result  *	contains a Tcl object value to supplement the return code.  *  * Side effects:  *	The object is converted, if necessary, to a ByteCode object that  *	holds the bytecode instructions for the commands. Executing the  *	commands will almost certainly have side effects that depend on  *	those commands.  *  *	The commands are executed in interp, and the execution  *	is carried out in the variable context of global level (no  *	procedures active), just as if an "uplevel #0" command were  *	being executed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_GlobalEvalObj
parameter_list|(
name|interp
parameter_list|,
name|objPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to evaluate 				 * commands. */
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Pointer to object containing commands 				 * to execute. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|int
name|result
decl_stmt|;
name|CallFrame
modifier|*
name|savedVarFramePtr
decl_stmt|;
name|savedVarFramePtr
operator|=
name|iPtr
operator|->
name|varFramePtr
expr_stmt|;
name|iPtr
operator|->
name|varFramePtr
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|Tcl_EvalObj
argument_list|(
name|interp
argument_list|,
name|objPtr
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|varFramePtr
operator|=
name|savedVarFramePtr
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetRecursionLimit --  *  *	Set the maximum number of recursive calls that may be active  *	for an interpreter at once.  *  * Results:  *	The return value is the old limit on nesting for interp.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_SetRecursionLimit
parameter_list|(
name|interp
parameter_list|,
name|depth
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter whose nesting limit 					 * is to be set. */
name|int
name|depth
decl_stmt|;
comment|/* New value for maximimum depth. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|int
name|old
decl_stmt|;
name|old
operator|=
name|iPtr
operator|->
name|maxNestingDepth
expr_stmt|;
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
block|{
name|iPtr
operator|->
name|maxNestingDepth
operator|=
name|depth
expr_stmt|;
block|}
return|return
name|old
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_AllowExceptions --  *  *	Sets a flag in an interpreter so that exceptions can occur  *	in the next call to Tcl_Eval without them being turned into  *	errors.  *  * Results:  *	None.  *  * Side effects:  *	The TCL_ALLOW_EXCEPTIONS flag gets set in the interpreter's  *	evalFlags structure.  See the reference documentation for  *	more details.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_AllowExceptions
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to set flag. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|iPtr
operator|->
name|evalFlags
operator||=
name|TCL_ALLOW_EXCEPTIONS
expr_stmt|;
block|}
end_function

end_unit

