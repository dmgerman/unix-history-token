begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclBinary.c --  *  *	This file contains the implementation of the "binary" Tcl built-in  *	command .  *  * Copyright (c) 1997 by Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclBinary.c 1.26 97/11/05 13:02:05  */
end_comment

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * The following constants are used by GetFormatSpec to indicate various  * special conditions in the parsing of a format specifier.  */
end_comment

begin_define
define|#
directive|define
name|BINARY_ALL
value|-1
end_define

begin_comment
comment|/* Use all elements in the argument. */
end_comment

begin_define
define|#
directive|define
name|BINARY_NOCOUNT
value|-2
end_define

begin_comment
comment|/* No count was specified in format. */
end_comment

begin_comment
comment|/*  * Prototypes for local procedures defined in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|GetFormatSpec
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
operator|*
name|formatPtr
operator|,
name|char
operator|*
name|cmdPtr
operator|,
name|int
operator|*
name|countPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|FormatNumber
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|type
operator|,
name|Tcl_Obj
operator|*
name|src
operator|,
name|char
operator|*
operator|*
name|cursorPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Tcl_Obj
modifier|*
name|ScanNumber
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|buffer
operator|,
name|int
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_BinaryObjCmd --  *  *	This procedure implements the "binary" Tcl command.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_BinaryObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|int
name|arg
decl_stmt|;
comment|/* Index of next argument to consume. */
name|int
name|value
init|=
literal|0
decl_stmt|;
comment|/* Current integer value to be packed. 				 * Initialized to avoid compiler warning. */
name|char
name|cmd
decl_stmt|;
comment|/* Current format character. */
name|int
name|count
decl_stmt|;
comment|/* Count associated with current format 				 * character. */
name|char
modifier|*
name|format
decl_stmt|;
comment|/* Pointer to current position in format 				 * string. */
name|char
modifier|*
name|cursor
decl_stmt|;
comment|/* Current position within result buffer. */
name|char
modifier|*
name|maxPos
decl_stmt|;
comment|/* Greatest position within result buffer that 				 * cursor has visited.*/
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* Start of data buffer. */
name|char
modifier|*
name|errorString
decl_stmt|,
modifier|*
name|errorValue
decl_stmt|,
modifier|*
name|str
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|size
decl_stmt|,
name|length
decl_stmt|;
name|Tcl_Obj
modifier|*
name|resultPtr
decl_stmt|;
specifier|static
name|char
modifier|*
name|subCmds
index|[]
init|=
block|{
literal|"format"
block|,
literal|"scan"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
enum|enum
block|{
name|BinaryFormat
block|,
name|BinaryScan
block|}
name|index
enum|;
if|if
condition|(
name|objc
operator|<
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"option ?arg arg ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetIndexFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|,
name|subCmds
argument_list|,
literal|"option"
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|index
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|BinaryFormat
case|:
if|if
condition|(
name|objc
operator|<
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"formatString ?arg arg ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/* 	     * To avoid copying the data, we format the string in two passes. 	     * The first pass computes the size of the output buffer.  The 	     * second pass places the formatted data into the buffer. 	     */
name|format
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|arg
operator|=
literal|3
expr_stmt|;
name|offset
operator|=
name|length
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|format
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|GetFormatSpec
argument_list|(
operator|&
name|format
argument_list|,
operator|&
name|cmd
argument_list|,
operator|&
name|count
argument_list|)
condition|)
block|{
break|break;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
literal|'a'
case|:
case|case
literal|'A'
case|:
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
comment|/* 			 * For string-type specifiers, the count corresponds 			 * to the number of characters in a single argument. 			 */
if|if
condition|(
name|arg
operator|>=
name|objc
condition|)
block|{
goto|goto
name|badIndex
goto|;
block|}
if|if
condition|(
name|count
operator|==
name|BINARY_ALL
condition|)
block|{
operator|(
name|void
operator|)
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|arg
index|]
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|==
name|BINARY_NOCOUNT
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
block|}
name|arg
operator|++
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
literal|'a'
operator|||
name|cmd
operator|==
literal|'A'
condition|)
block|{
name|offset
operator|+=
name|count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
literal|'b'
operator|||
name|cmd
operator|==
literal|'B'
condition|)
block|{
name|offset
operator|+=
operator|(
name|count
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|+=
operator|(
name|count
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
block|}
break|break;
case|case
literal|'c'
case|:
name|size
operator|=
literal|1
expr_stmt|;
goto|goto
name|doNumbers
goto|;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|size
operator|=
literal|2
expr_stmt|;
goto|goto
name|doNumbers
goto|;
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
name|size
operator|=
literal|4
expr_stmt|;
goto|goto
name|doNumbers
goto|;
case|case
literal|'f'
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|float
argument_list|)
expr_stmt|;
goto|goto
name|doNumbers
goto|;
case|case
literal|'d'
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|double
argument_list|)
expr_stmt|;
name|doNumbers
label|:
if|if
condition|(
name|arg
operator|>=
name|objc
condition|)
block|{
goto|goto
name|badIndex
goto|;
block|}
comment|/* 			 * For number-type specifiers, the count corresponds 			 * to the number of elements in the list stored in 			 * a single argument.  If no count is specified, then 			 * the argument is taken as a single non-list value. 			 */
if|if
condition|(
name|count
operator|==
name|BINARY_NOCOUNT
condition|)
block|{
name|arg
operator|++
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|listc
decl_stmt|;
name|Tcl_Obj
modifier|*
modifier|*
name|listv
decl_stmt|;
if|if
condition|(
name|Tcl_ListObjGetElements
argument_list|(
name|interp
argument_list|,
name|objv
index|[
name|arg
operator|++
index|]
argument_list|,
operator|&
name|listc
argument_list|,
operator|&
name|listv
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|count
operator|==
name|BINARY_ALL
condition|)
block|{
name|count
operator|=
name|listc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|>
name|listc
condition|)
block|{
name|errorString
operator|=
literal|"number of elements in list does not match count"
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
name|offset
operator|+=
name|count
operator|*
name|size
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
name|count
operator|==
name|BINARY_ALL
condition|)
block|{
name|errorString
operator|=
literal|"cannot use \"*\" in format string with \"x\""
expr_stmt|;
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|count
operator|==
name|BINARY_NOCOUNT
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
block|}
name|offset
operator|+=
name|count
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
if|if
condition|(
name|count
operator|==
name|BINARY_NOCOUNT
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|count
operator|>
name|offset
operator|)
operator|||
operator|(
name|count
operator|==
name|BINARY_ALL
operator|)
condition|)
block|{
name|count
operator|=
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|>
name|length
condition|)
block|{
name|length
operator|=
name|offset
expr_stmt|;
block|}
name|offset
operator|-=
name|count
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
if|if
condition|(
name|offset
operator|>
name|length
condition|)
block|{
name|length
operator|=
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
name|BINARY_ALL
condition|)
block|{
name|offset
operator|=
name|length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|==
name|BINARY_NOCOUNT
condition|)
block|{
goto|goto
name|badCount
goto|;
block|}
else|else
block|{
name|offset
operator|=
name|count
expr_stmt|;
block|}
break|break;
default|default:
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|cmd
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"bad field specifier \""
argument_list|,
name|buf
argument_list|,
literal|"\""
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
block|}
if|if
condition|(
name|offset
operator|>
name|length
condition|)
block|{
name|length
operator|=
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
comment|/* 	     * Prepare the result object by preallocating the caclulated 	     * number of bytes and filling with nulls. 	     */
name|resultPtr
operator|=
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_SetObjLength
argument_list|(
name|resultPtr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|resultPtr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|)
name|length
argument_list|)
expr_stmt|;
comment|/* 	     * Pack the data into the result object.  Note that we can skip 	     * the error checking during this pass, since we have already 	     * parsed the string once. 	     */
name|arg
operator|=
literal|3
expr_stmt|;
name|format
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|buffer
expr_stmt|;
name|maxPos
operator|=
name|cursor
expr_stmt|;
while|while
condition|(
operator|*
name|format
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|GetFormatSpec
argument_list|(
operator|&
name|format
argument_list|,
operator|&
name|cmd
argument_list|,
operator|&
name|count
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|(
name|count
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cmd
operator|!=
literal|'@'
operator|)
condition|)
block|{
name|arg
operator|++
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
literal|'a'
case|:
case|case
literal|'A'
case|:
block|{
name|char
name|pad
init|=
call|(
name|char
call|)
argument_list|(
name|cmd
operator|==
literal|'a'
condition|?
literal|'\0'
else|:
literal|' '
argument_list|)
decl_stmt|;
name|str
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|arg
operator|++
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|BINARY_ALL
condition|)
block|{
name|count
operator|=
name|length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|==
name|BINARY_NOCOUNT
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|>=
name|count
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|cursor
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|str
argument_list|,
operator|(
name|size_t
operator|)
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|cursor
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|str
argument_list|,
operator|(
name|size_t
operator|)
name|length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|cursor
operator|+
name|length
argument_list|,
name|pad
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|count
operator|-
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cursor
operator|+=
name|count
expr_stmt|;
break|break;
block|}
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
block|{
name|char
modifier|*
name|last
decl_stmt|;
name|str
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|arg
operator|++
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|BINARY_ALL
condition|)
block|{
name|count
operator|=
name|length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|==
name|BINARY_NOCOUNT
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
block|}
name|last
operator|=
name|cursor
operator|+
operator|(
operator|(
name|count
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|length
condition|)
block|{
name|count
operator|=
name|length
expr_stmt|;
block|}
name|value
operator|=
literal|0
expr_stmt|;
name|errorString
operator|=
literal|"binary"
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
literal|'B'
condition|)
block|{
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|count
condition|;
name|offset
operator|++
control|)
block|{
name|value
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|str
index|[
name|offset
index|]
operator|==
literal|'1'
condition|)
block|{
name|value
operator||=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
name|offset
index|]
operator|!=
literal|'0'
condition|)
block|{
name|errorValue
operator|=
name|str
expr_stmt|;
goto|goto
name|badValue
goto|;
block|}
if|if
condition|(
operator|(
operator|(
name|offset
operator|+
literal|1
operator|)
operator|%
literal|8
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|cursor
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
name|value
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|count
condition|;
name|offset
operator|++
control|)
block|{
name|value
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|str
index|[
name|offset
index|]
operator|==
literal|'1'
condition|)
block|{
name|value
operator||=
literal|128
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
name|offset
index|]
operator|!=
literal|'0'
condition|)
block|{
name|errorValue
operator|=
name|str
expr_stmt|;
goto|goto
name|badValue
goto|;
block|}
if|if
condition|(
operator|!
operator|(
operator|(
name|offset
operator|+
literal|1
operator|)
operator|%
literal|8
operator|)
condition|)
block|{
operator|*
name|cursor
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
name|value
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|offset
operator|%
literal|8
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cmd
operator|==
literal|'B'
condition|)
block|{
name|value
operator|<<=
literal|8
operator|-
operator|(
name|offset
operator|%
literal|8
operator|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|>>=
literal|8
operator|-
operator|(
name|offset
operator|%
literal|8
operator|)
expr_stmt|;
block|}
operator|*
name|cursor
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
name|value
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|cursor
operator|<
name|last
condition|)
block|{
operator|*
name|cursor
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
block|{
name|char
modifier|*
name|last
decl_stmt|;
name|int
name|c
decl_stmt|;
name|str
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|arg
operator|++
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|BINARY_ALL
condition|)
block|{
name|count
operator|=
name|length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|==
name|BINARY_NOCOUNT
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
block|}
name|last
operator|=
name|cursor
operator|+
operator|(
operator|(
name|count
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|length
condition|)
block|{
name|count
operator|=
name|length
expr_stmt|;
block|}
name|value
operator|=
literal|0
expr_stmt|;
name|errorString
operator|=
literal|"hexadecimal"
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
literal|'H'
condition|)
block|{
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|count
condition|;
name|offset
operator|++
control|)
block|{
name|value
operator|<<=
literal|4
expr_stmt|;
name|c
operator|=
name|tolower
argument_list|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|str
operator|)
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'f'
operator|)
condition|)
block|{
name|value
operator||=
operator|(
operator|(
name|c
operator|-
literal|'a'
operator|+
literal|10
operator|)
operator|&
literal|0xf
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|value
operator||=
operator|(
name|c
operator|-
literal|'0'
operator|)
operator|&
literal|0xf
expr_stmt|;
block|}
else|else
block|{
name|errorValue
operator|=
name|str
expr_stmt|;
goto|goto
name|badValue
goto|;
block|}
if|if
condition|(
name|offset
operator|%
literal|2
condition|)
block|{
operator|*
name|cursor
operator|++
operator|=
operator|(
name|char
operator|)
name|value
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|count
condition|;
name|offset
operator|++
control|)
block|{
name|value
operator|>>=
literal|4
expr_stmt|;
name|c
operator|=
name|tolower
argument_list|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|str
operator|)
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'f'
operator|)
condition|)
block|{
name|value
operator||=
operator|(
operator|(
name|c
operator|-
literal|'a'
operator|+
literal|10
operator|)
operator|<<
literal|4
operator|)
operator|&
literal|0xf0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|value
operator||=
operator|(
operator|(
name|c
operator|-
literal|'0'
operator|)
operator|<<
literal|4
operator|)
operator|&
literal|0xf0
expr_stmt|;
block|}
else|else
block|{
name|errorValue
operator|=
name|str
expr_stmt|;
goto|goto
name|badValue
goto|;
block|}
if|if
condition|(
name|offset
operator|%
literal|2
condition|)
block|{
operator|*
name|cursor
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
name|value
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|offset
operator|%
literal|2
condition|)
block|{
if|if
condition|(
name|cmd
operator|==
literal|'H'
condition|)
block|{
name|value
operator|<<=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|value
operator|>>=
literal|4
expr_stmt|;
block|}
operator|*
name|cursor
operator|++
operator|=
operator|(
name|char
operator|)
name|value
expr_stmt|;
block|}
while|while
condition|(
name|cursor
operator|<
name|last
condition|)
block|{
operator|*
name|cursor
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'c'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
case|case
literal|'d'
case|:
case|case
literal|'f'
case|:
block|{
name|int
name|listc
decl_stmt|,
name|i
decl_stmt|;
name|Tcl_Obj
modifier|*
modifier|*
name|listv
decl_stmt|;
if|if
condition|(
name|count
operator|==
name|BINARY_NOCOUNT
condition|)
block|{
comment|/* 			     * Note that we are casting away the const-ness of 			     * objv, but this is safe since we aren't going to 			     * modify the array. 			     */
name|listv
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
operator|(
name|objv
operator|+
name|arg
operator|)
expr_stmt|;
name|listc
operator|=
literal|1
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|Tcl_ListObjGetElements
argument_list|(
name|interp
argument_list|,
name|objv
index|[
name|arg
index|]
argument_list|,
operator|&
name|listc
argument_list|,
operator|&
name|listv
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|BINARY_ALL
condition|)
block|{
name|count
operator|=
name|listc
expr_stmt|;
block|}
block|}
name|arg
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|FormatNumber
argument_list|(
name|interp
argument_list|,
name|cmd
argument_list|,
name|listv
index|[
name|i
index|]
argument_list|,
operator|&
name|cursor
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
break|break;
block|}
case|case
literal|'x'
case|:
if|if
condition|(
name|count
operator|==
name|BINARY_NOCOUNT
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
block|}
name|memset
argument_list|(
name|cursor
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|)
name|count
argument_list|)
expr_stmt|;
name|cursor
operator|+=
name|count
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
if|if
condition|(
name|cursor
operator|>
name|maxPos
condition|)
block|{
name|maxPos
operator|=
name|cursor
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
name|BINARY_NOCOUNT
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|count
operator|==
name|BINARY_ALL
operator|)
operator|||
operator|(
name|count
operator|>
operator|(
name|cursor
operator|-
name|buffer
operator|)
operator|)
condition|)
block|{
name|cursor
operator|=
name|buffer
expr_stmt|;
block|}
else|else
block|{
name|cursor
operator|-=
name|count
expr_stmt|;
block|}
break|break;
case|case
literal|'@'
case|:
if|if
condition|(
name|cursor
operator|>
name|maxPos
condition|)
block|{
name|maxPos
operator|=
name|cursor
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
name|BINARY_ALL
condition|)
block|{
name|cursor
operator|=
name|maxPos
expr_stmt|;
block|}
else|else
block|{
name|cursor
operator|=
name|buffer
operator|+
name|count
expr_stmt|;
block|}
break|break;
block|}
block|}
break|break;
case|case
name|BinaryScan
case|:
block|{
name|int
name|i
decl_stmt|;
name|Tcl_Obj
modifier|*
name|valuePtr
decl_stmt|,
modifier|*
name|elementPtr
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"value formatString ?varName varName ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|buffer
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|format
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|buffer
expr_stmt|;
name|arg
operator|=
literal|4
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|format
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|GetFormatSpec
argument_list|(
operator|&
name|format
argument_list|,
operator|&
name|cmd
argument_list|,
operator|&
name|count
argument_list|)
condition|)
block|{
goto|goto
name|done
goto|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
literal|'a'
case|:
case|case
literal|'A'
case|:
if|if
condition|(
name|arg
operator|>=
name|objc
condition|)
block|{
goto|goto
name|badIndex
goto|;
block|}
if|if
condition|(
name|count
operator|==
name|BINARY_ALL
condition|)
block|{
name|count
operator|=
name|length
operator|-
name|offset
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|count
operator|==
name|BINARY_NOCOUNT
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
operator|(
name|length
operator|-
name|offset
operator|)
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
name|str
operator|=
name|buffer
operator|+
name|offset
expr_stmt|;
name|size
operator|=
name|count
expr_stmt|;
comment|/* 			 * Trim trailing nulls and spaces, if necessary. 			 */
if|if
condition|(
name|cmd
operator|==
literal|'A'
condition|)
block|{
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|str
index|[
name|size
operator|-
literal|1
index|]
operator|!=
literal|'\0'
operator|&&
name|str
index|[
name|size
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
block|{
break|break;
block|}
name|size
operator|--
expr_stmt|;
block|}
block|}
name|valuePtr
operator|=
name|Tcl_NewStringObj
argument_list|(
name|str
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|resultPtr
operator|=
name|Tcl_ObjSetVar2
argument_list|(
name|interp
argument_list|,
name|objv
index|[
name|arg
operator|++
index|]
argument_list|,
name|NULL
argument_list|,
name|valuePtr
argument_list|,
name|TCL_LEAVE_ERR_MSG
operator||
name|TCL_PARSE_PART1
argument_list|)
expr_stmt|;
if|if
condition|(
name|resultPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
comment|/* unneeded */
return|return
name|TCL_ERROR
return|;
block|}
name|offset
operator|+=
name|count
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
block|{
name|char
modifier|*
name|dest
decl_stmt|;
if|if
condition|(
name|arg
operator|>=
name|objc
condition|)
block|{
goto|goto
name|badIndex
goto|;
block|}
if|if
condition|(
name|count
operator|==
name|BINARY_ALL
condition|)
block|{
name|count
operator|=
operator|(
name|length
operator|-
name|offset
operator|)
operator|*
literal|8
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|count
operator|==
name|BINARY_NOCOUNT
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
operator|(
name|length
operator|-
name|offset
operator|)
operator|*
literal|8
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
name|str
operator|=
name|buffer
operator|+
name|offset
expr_stmt|;
name|valuePtr
operator|=
name|Tcl_NewObj
argument_list|()
expr_stmt|;
name|Tcl_SetObjLength
argument_list|(
name|valuePtr
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|dest
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|valuePtr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
literal|'b'
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|8
condition|)
block|{
name|value
operator|>>=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
operator|*
name|str
operator|++
expr_stmt|;
block|}
operator|*
name|dest
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|value
operator|&
literal|1
operator|)
condition|?
literal|'1'
else|:
literal|'0'
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|8
condition|)
block|{
name|value
operator|<<=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
operator|*
name|str
operator|++
expr_stmt|;
block|}
operator|*
name|dest
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|value
operator|&
literal|0x80
operator|)
condition|?
literal|'1'
else|:
literal|'0'
argument_list|)
expr_stmt|;
block|}
block|}
name|resultPtr
operator|=
name|Tcl_ObjSetVar2
argument_list|(
name|interp
argument_list|,
name|objv
index|[
name|arg
operator|++
index|]
argument_list|,
name|NULL
argument_list|,
name|valuePtr
argument_list|,
name|TCL_LEAVE_ERR_MSG
operator||
name|TCL_PARSE_PART1
argument_list|)
expr_stmt|;
if|if
condition|(
name|resultPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
comment|/* unneeded */
return|return
name|TCL_ERROR
return|;
block|}
name|offset
operator|+=
operator|(
name|count
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
break|break;
block|}
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
block|{
name|char
modifier|*
name|dest
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|char
name|hexdigit
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
if|if
condition|(
name|arg
operator|>=
name|objc
condition|)
block|{
goto|goto
name|badIndex
goto|;
block|}
if|if
condition|(
name|count
operator|==
name|BINARY_ALL
condition|)
block|{
name|count
operator|=
operator|(
name|length
operator|-
name|offset
operator|)
operator|*
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|count
operator|==
name|BINARY_NOCOUNT
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
operator|(
name|length
operator|-
name|offset
operator|)
operator|*
literal|2
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
name|str
operator|=
name|buffer
operator|+
name|offset
expr_stmt|;
name|valuePtr
operator|=
name|Tcl_NewObj
argument_list|()
expr_stmt|;
name|Tcl_SetObjLength
argument_list|(
name|valuePtr
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|dest
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|valuePtr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
literal|'h'
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|2
condition|)
block|{
name|value
operator|>>=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
operator|*
name|str
operator|++
expr_stmt|;
block|}
operator|*
name|dest
operator|++
operator|=
name|hexdigit
index|[
name|value
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|2
condition|)
block|{
name|value
operator|<<=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
operator|*
name|str
operator|++
expr_stmt|;
block|}
operator|*
name|dest
operator|++
operator|=
name|hexdigit
index|[
operator|(
name|value
operator|>>
literal|4
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
block|}
name|resultPtr
operator|=
name|Tcl_ObjSetVar2
argument_list|(
name|interp
argument_list|,
name|objv
index|[
name|arg
operator|++
index|]
argument_list|,
name|NULL
argument_list|,
name|valuePtr
argument_list|,
name|TCL_LEAVE_ERR_MSG
operator||
name|TCL_PARSE_PART1
argument_list|)
expr_stmt|;
if|if
condition|(
name|resultPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
comment|/* unneeded */
return|return
name|TCL_ERROR
return|;
block|}
name|offset
operator|+=
operator|(
name|count
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
break|break;
block|}
case|case
literal|'c'
case|:
name|size
operator|=
literal|1
expr_stmt|;
goto|goto
name|scanNumber
goto|;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|size
operator|=
literal|2
expr_stmt|;
goto|goto
name|scanNumber
goto|;
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
name|size
operator|=
literal|4
expr_stmt|;
goto|goto
name|scanNumber
goto|;
case|case
literal|'f'
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|float
argument_list|)
expr_stmt|;
goto|goto
name|scanNumber
goto|;
case|case
literal|'d'
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|double
argument_list|)
expr_stmt|;
comment|/* fall through */
name|scanNumber
label|:
if|if
condition|(
name|arg
operator|>=
name|objc
condition|)
block|{
goto|goto
name|badIndex
goto|;
block|}
if|if
condition|(
name|count
operator|==
name|BINARY_NOCOUNT
condition|)
block|{
if|if
condition|(
operator|(
name|length
operator|-
name|offset
operator|)
operator|<
name|size
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|valuePtr
operator|=
name|ScanNumber
argument_list|(
name|buffer
operator|+
name|offset
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|size
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|count
operator|==
name|BINARY_ALL
condition|)
block|{
name|count
operator|=
operator|(
name|length
operator|-
name|offset
operator|)
operator|/
name|size
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|length
operator|-
name|offset
operator|)
operator|<
operator|(
name|count
operator|*
name|size
operator|)
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|valuePtr
operator|=
name|Tcl_NewObj
argument_list|()
expr_stmt|;
name|str
operator|=
name|buffer
operator|+
name|offset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|elementPtr
operator|=
name|ScanNumber
argument_list|(
name|str
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|str
operator|+=
name|size
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
name|NULL
argument_list|,
name|valuePtr
argument_list|,
name|elementPtr
argument_list|)
expr_stmt|;
block|}
name|offset
operator|+=
name|count
operator|*
name|size
expr_stmt|;
block|}
name|resultPtr
operator|=
name|Tcl_ObjSetVar2
argument_list|(
name|interp
argument_list|,
name|objv
index|[
name|arg
operator|++
index|]
argument_list|,
name|NULL
argument_list|,
name|valuePtr
argument_list|,
name|TCL_LEAVE_ERR_MSG
operator||
name|TCL_PARSE_PART1
argument_list|)
expr_stmt|;
if|if
condition|(
name|resultPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
comment|/* unneeded */
return|return
name|TCL_ERROR
return|;
block|}
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
name|count
operator|==
name|BINARY_NOCOUNT
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|count
operator|==
name|BINARY_ALL
operator|)
operator|||
operator|(
name|count
operator|>
operator|(
name|length
operator|-
name|offset
operator|)
operator|)
condition|)
block|{
name|offset
operator|=
name|length
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|+=
name|count
expr_stmt|;
block|}
break|break;
case|case
literal|'X'
case|:
if|if
condition|(
name|count
operator|==
name|BINARY_NOCOUNT
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|count
operator|==
name|BINARY_ALL
operator|)
operator|||
operator|(
name|count
operator|>
name|offset
operator|)
condition|)
block|{
name|offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|-=
name|count
expr_stmt|;
block|}
break|break;
case|case
literal|'@'
case|:
if|if
condition|(
name|count
operator|==
name|BINARY_NOCOUNT
condition|)
block|{
goto|goto
name|badCount
goto|;
block|}
if|if
condition|(
operator|(
name|count
operator|==
name|BINARY_ALL
operator|)
operator|||
operator|(
name|count
operator|>
name|length
operator|)
condition|)
block|{
name|offset
operator|=
name|length
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|count
expr_stmt|;
block|}
break|break;
default|default:
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|cmd
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"bad field specifier \""
argument_list|,
name|buf
argument_list|,
literal|"\""
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
block|}
comment|/* 	     * Set the result to the last position of the cursor. 	     */
name|done
label|:
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_SetLongObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|arg
operator|-
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|TCL_OK
return|;
name|badValue
label|:
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"expected "
argument_list|,
name|errorString
argument_list|,
literal|" string but got \""
argument_list|,
name|errorValue
argument_list|,
literal|"\" instead"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
name|badCount
label|:
name|errorString
operator|=
literal|"missing count for \"@\" field specifier"
expr_stmt|;
goto|goto
name|error
goto|;
name|badIndex
label|:
name|errorString
operator|=
literal|"not enough arguments for all format specifiers"
expr_stmt|;
goto|goto
name|error
goto|;
name|error
label|:
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|errorString
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * GetFormatSpec --  *  *	This function parses the format strings used in the binary  *	format and scan commands.  *  * Results:  *	Moves the formatPtr to the start of the next command. Returns  *	the current command character and count in cmdPtr and countPtr.  *	The count is set to BINARY_ALL if the count character was '*'  *	or BINARY_NOCOUNT if no count was specified.  Returns 1 on  *	success, or 0 if the string did not have a format specifier.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|GetFormatSpec
parameter_list|(
name|formatPtr
parameter_list|,
name|cmdPtr
parameter_list|,
name|countPtr
parameter_list|)
name|char
modifier|*
modifier|*
name|formatPtr
decl_stmt|;
comment|/* Pointer to format string. */
name|char
modifier|*
name|cmdPtr
decl_stmt|;
comment|/* Pointer to location of command char. */
name|int
modifier|*
name|countPtr
decl_stmt|;
comment|/* Pointer to repeat count value. */
block|{
comment|/*      * Skip any leading blanks.      */
while|while
condition|(
operator|*
operator|*
name|formatPtr
operator|==
literal|' '
condition|)
block|{
operator|(
operator|*
name|formatPtr
operator|)
operator|++
expr_stmt|;
block|}
comment|/*      * The string was empty, except for whitespace, so fail.      */
if|if
condition|(
operator|!
operator|(
operator|*
operator|*
name|formatPtr
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/*      * Extract the command character and any trailing digits or '*'.      */
operator|*
name|cmdPtr
operator|=
operator|*
operator|*
name|formatPtr
expr_stmt|;
operator|(
operator|*
name|formatPtr
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|formatPtr
operator|==
literal|'*'
condition|)
block|{
operator|(
operator|*
name|formatPtr
operator|)
operator|++
expr_stmt|;
operator|(
operator|*
name|countPtr
operator|)
operator|=
name|BINARY_ALL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
operator|*
operator|*
name|formatPtr
argument_list|)
condition|)
block|{
operator|(
operator|*
name|countPtr
operator|)
operator|=
name|strtoul
argument_list|(
operator|*
name|formatPtr
argument_list|,
name|formatPtr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|countPtr
operator|)
operator|=
name|BINARY_NOCOUNT
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FormatNumber --  *  *	This routine is called by Tcl_BinaryObjCmd to format a number  *	into a location pointed at by cursor.  *  * Results:  *	 A standard Tcl result.  *  * Side effects:  *	Moves the cursor to the next location to be written into.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|FormatNumber
parameter_list|(
name|interp
parameter_list|,
name|type
parameter_list|,
name|src
parameter_list|,
name|cursorPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter, used to report 				 * errors. */
name|int
name|type
decl_stmt|;
comment|/* Type of number to format. */
name|Tcl_Obj
modifier|*
name|src
decl_stmt|;
comment|/* Number to format. */
name|char
modifier|*
modifier|*
name|cursorPtr
decl_stmt|;
comment|/* Pointer to index into destination buffer. */
block|{
name|int
name|value
decl_stmt|;
name|double
name|dvalue
decl_stmt|;
name|char
name|cmd
init|=
operator|(
name|char
operator|)
name|type
decl_stmt|;
if|if
condition|(
name|cmd
operator|==
literal|'d'
operator|||
name|cmd
operator|==
literal|'f'
condition|)
block|{
comment|/* 	 * For floating point types, we need to copy the data using 	 * memcpy to avoid alignment issues. 	 */
if|if
condition|(
name|Tcl_GetDoubleFromObj
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
operator|&
name|dvalue
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|cmd
operator|==
literal|'d'
condition|)
block|{
name|memcpy
argument_list|(
operator|(
operator|*
name|cursorPtr
operator|)
argument_list|,
operator|&
name|dvalue
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|cursorPtr
operator|)
operator|+=
sizeof|sizeof
argument_list|(
name|double
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|float
name|fvalue
decl_stmt|;
comment|/* 	     * Because some compilers will generate floating point exceptions 	     * on an overflow cast (e.g. Borland), we restrict the values 	     * to the valid range for float. 	     */
if|if
condition|(
name|fabs
argument_list|(
name|dvalue
argument_list|)
operator|>
operator|(
name|double
operator|)
name|FLT_MAX
condition|)
block|{
name|fvalue
operator|=
operator|(
name|dvalue
operator|>=
literal|0.0
operator|)
condition|?
name|FLT_MAX
else|:
operator|-
name|FLT_MAX
expr_stmt|;
block|}
else|else
block|{
name|fvalue
operator|=
operator|(
name|float
operator|)
name|dvalue
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|(
operator|*
name|cursorPtr
operator|)
argument_list|,
operator|&
name|fvalue
argument_list|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|cursorPtr
operator|)
operator|+=
sizeof|sizeof
argument_list|(
name|float
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
operator|&
name|value
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|cmd
operator|==
literal|'c'
condition|)
block|{
operator|*
operator|(
operator|*
name|cursorPtr
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
name|value
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
literal|'s'
condition|)
block|{
operator|*
operator|(
operator|*
name|cursorPtr
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
name|value
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|*
name|cursorPtr
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
literal|'S'
condition|)
block|{
operator|*
operator|(
operator|*
name|cursorPtr
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|*
name|cursorPtr
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
name|value
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
literal|'i'
condition|)
block|{
operator|*
operator|(
operator|*
name|cursorPtr
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
name|value
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|*
name|cursorPtr
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|*
name|cursorPtr
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|*
name|cursorPtr
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
literal|'I'
condition|)
block|{
operator|*
operator|(
operator|*
name|cursorPtr
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|*
name|cursorPtr
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|*
name|cursorPtr
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|*
name|cursorPtr
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
name|value
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * ScanNumber --  *  *	This routine is called by Tcl_BinaryObjCmd to scan a number  *	out of a buffer.  *  * Results:  *	Returns a newly created object containing the scanned number.  *	This object has a ref count of zero.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Tcl_Obj
modifier|*
name|ScanNumber
parameter_list|(
name|buffer
parameter_list|,
name|type
parameter_list|)
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* Buffer to scan number from. */
name|int
name|type
decl_stmt|;
comment|/* Format character from "binary scan" */
block|{
name|int
name|value
decl_stmt|;
comment|/*      * We cannot rely on the compiler to properly sign extend integer values      * when we cast from smaller values to larger values because we don't know      * the exact size of the integer types.  So, we have to handle sign      * extension explicitly by checking the high bit and padding with 1's as      * needed.      */
switch|switch
condition|(
operator|(
name|char
operator|)
name|type
condition|)
block|{
case|case
literal|'c'
case|:
name|value
operator|=
name|buffer
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|value
operator|&
literal|0x80
condition|)
block|{
name|value
operator||=
operator|-
literal|0x100
expr_stmt|;
block|}
return|return
name|Tcl_NewLongObj
argument_list|(
operator|(
name|long
operator|)
name|value
argument_list|)
return|;
case|case
literal|'s'
case|:
name|value
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|char
operator|)
name|buffer
index|[
literal|0
index|]
operator|)
operator|+
operator|(
operator|(
name|unsigned
name|char
operator|)
name|buffer
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
goto|goto
name|shortValue
goto|;
case|case
literal|'S'
case|:
name|value
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|char
operator|)
name|buffer
index|[
literal|1
index|]
operator|)
operator|+
operator|(
operator|(
name|unsigned
name|char
operator|)
name|buffer
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
name|shortValue
label|:
if|if
condition|(
name|value
operator|&
literal|0x8000
condition|)
block|{
name|value
operator||=
operator|-
literal|0x10000
expr_stmt|;
block|}
return|return
name|Tcl_NewLongObj
argument_list|(
operator|(
name|long
operator|)
name|value
argument_list|)
return|;
case|case
literal|'i'
case|:
name|value
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|char
operator|)
name|buffer
index|[
literal|0
index|]
operator|)
operator|+
operator|(
operator|(
name|unsigned
name|char
operator|)
name|buffer
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|unsigned
name|char
operator|)
name|buffer
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|unsigned
name|char
operator|)
name|buffer
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
goto|goto
name|intValue
goto|;
case|case
literal|'I'
case|:
name|value
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|char
operator|)
name|buffer
index|[
literal|3
index|]
operator|)
operator|+
operator|(
operator|(
name|unsigned
name|char
operator|)
name|buffer
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|unsigned
name|char
operator|)
name|buffer
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|unsigned
name|char
operator|)
name|buffer
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
name|intValue
label|:
comment|/* 	     * Check to see if the value was sign extended properly on 	     * systems where an int is more than 32-bits. 	     */
if|if
condition|(
operator|(
name|value
operator|&
operator|(
operator|(
operator|(
name|unsigned
name|int
operator|)
literal|1
operator|)
operator|<<
literal|31
operator|)
operator|)
operator|&&
operator|(
name|value
operator|>
literal|0
operator|)
condition|)
block|{
name|value
operator|-=
operator|(
operator|(
operator|(
name|unsigned
name|int
operator|)
literal|1
operator|)
operator|<<
literal|31
operator|)
expr_stmt|;
name|value
operator|-=
operator|(
operator|(
operator|(
name|unsigned
name|int
operator|)
literal|1
operator|)
operator|<<
literal|31
operator|)
expr_stmt|;
block|}
return|return
name|Tcl_NewLongObj
argument_list|(
operator|(
name|long
operator|)
name|value
argument_list|)
return|;
case|case
literal|'f'
case|:
block|{
name|float
name|fvalue
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|fvalue
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Tcl_NewDoubleObj
argument_list|(
name|fvalue
argument_list|)
return|;
block|}
case|case
literal|'d'
case|:
block|{
name|double
name|dvalue
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|dvalue
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Tcl_NewDoubleObj
argument_list|(
name|dvalue
argument_list|)
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

end_unit

