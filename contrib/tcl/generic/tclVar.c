begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclVar.c --  *  *	This file contains routines that implement Tcl variables  *	(both scalars and arrays).  *  *	The implementation of arrays is modelled after an initial  *	implementation by Mark Diekhans and Karl Lehenbauer.  *  * Copyright (c) 1987-1994 The Regents of the University of California.  * Copyright (c) 1994-1995 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclVar.c 1.69 96/02/28 21:45:10  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * The strings below are used to indicate what went wrong when a  * variable access is denied.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|noSuchVar
init|=
literal|"no such variable"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|isArray
init|=
literal|"variable is array"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|needArray
init|=
literal|"variable isn't array"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|noSuchElement
init|=
literal|"no such element in array"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|danglingUpvar
init|=
literal|"upvar refers to element in deleted array"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Creation flag values passed in to LookupVar:  *  * CRT_PART1 -		1 means create hash table entry for part 1 of  *			name, if it doesn't already exist.  0 means  *			return an error if it doesn't exist.  * CRT_PART2 -		1 means create hash table entry for part 2 of  *			name, if it doesn't already exist.  0 means  *			return an error if it doesn't exist.  */
end_comment

begin_define
define|#
directive|define
name|CRT_PART1
value|1
end_define

begin_define
define|#
directive|define
name|CRT_PART2
value|2
end_define

begin_comment
comment|/*  * The following additional flag is used internally and passed through  * to LookupVar to indicate that a procedure like Tcl_GetVar was called  * instead of Tcl_GetVar2 and the single name value hasn't yet been  * parsed into an array name and index (if any).  */
end_comment

begin_define
define|#
directive|define
name|PART1_NOT_PARSED
value|0x10000
end_define

begin_comment
comment|/*  * Forward references to procedures defined later in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|CallTraces
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Interp
operator|*
name|iPtr
operator|,
name|Var
operator|*
name|arrayPtr
operator|,
name|Var
operator|*
name|varPtr
operator|,
name|char
operator|*
name|part1
operator|,
name|char
operator|*
name|part2
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|CleanupVar
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Var
operator|*
name|varPtr
operator|,
name|Var
operator|*
name|arrayPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DeleteSearches
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Var
operator|*
name|arrayVarPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DeleteArray
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Interp
operator|*
name|iPtr
operator|,
name|char
operator|*
name|arrayName
operator|,
name|Var
operator|*
name|varPtr
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Var
modifier|*
name|LookupVar
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|part1
operator|,
name|char
operator|*
name|part2
operator|,
name|int
name|flags
operator|,
name|char
operator|*
name|msg
operator|,
name|int
name|create
operator|,
name|Var
operator|*
operator|*
name|arrayPtrPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|MakeUpvar
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Interp
operator|*
name|iPtr
operator|,
name|CallFrame
operator|*
name|framePtr
operator|,
name|char
operator|*
name|otherP1
operator|,
name|char
operator|*
name|otherP2
operator|,
name|char
operator|*
name|myName
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Var
modifier|*
name|NewVar
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ArraySearch
modifier|*
name|ParseSearchId
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Var
operator|*
name|varPtr
operator|,
name|char
operator|*
name|varName
operator|,
name|char
operator|*
name|string
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|VarErrMsg
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|part1
operator|,
name|char
operator|*
name|part2
operator|,
name|char
operator|*
name|operation
operator|,
name|char
operator|*
name|reason
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * LookupVar --  *  *	This procedure is used by virtually all of the variable  *	code to locate a variable given its name(s).  *  * Results:  *	The return value is a pointer to the variable indicated by  *	part1 and part2, or NULL if the variable couldn't be found.  *	If the variable is found, *arrayPtrPtr is filled in with  *	the address of the array that contains the variable (or NULL  *	if the variable is a scalar).  Note:  it's possible that the  *	variable returned may be VAR_UNDEFINED, even if CRT_PART1 and  *	CRT_PART2 are specified (these only cause the hash table entry  *	and/or array to be created).  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Var
modifier|*
name|LookupVar
parameter_list|(
name|interp
parameter_list|,
name|part1
parameter_list|,
name|part2
parameter_list|,
name|flags
parameter_list|,
name|msg
parameter_list|,
name|create
parameter_list|,
name|arrayPtrPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for lookup. */
name|char
modifier|*
name|part1
decl_stmt|;
comment|/* If part2 isn't NULL, this is the name 				 * of an array.  Otherwise, if the 				 * PART1_NOT_PARSED flag bit is set this 				 * is a full variable name that could 				 * include a parenthesized array elemnt. 				 * If PART1_NOT_PARSED isn't present, then 				 * this is the name of a scalar variable. */
name|char
modifier|*
name|part2
decl_stmt|;
comment|/* Name of an element within array, or NULL. */
name|int
name|flags
decl_stmt|;
comment|/* Only the TCL_GLOBAL_ONLY, TCL_LEAVE_ERR_MSG, 				 * and PART1_NOT_PARSED bits matter. */
name|char
modifier|*
name|msg
decl_stmt|;
comment|/* Verb to use in error messages, e.g. 				 * "read" or "set".  Only needed if 				 * TCL_LEAVE_ERR_MSG is set in flags. */
name|int
name|create
decl_stmt|;
comment|/* OR'ed combination of CRT_PART1 and 				 * CRT_PART2.  Tells which entries to create 				 * if they don't already exist. */
name|Var
modifier|*
modifier|*
name|arrayPtrPtr
decl_stmt|;
comment|/* If the name refers to an element of an 				 * array, *arrayPtrPtr gets filled in with 				 * address of array variable.  Otherwise 				 * this is set to NULL. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Tcl_HashTable
modifier|*
name|tablePtr
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|Var
modifier|*
name|varPtr
decl_stmt|;
name|int
name|new
decl_stmt|;
name|char
modifier|*
name|openParen
decl_stmt|,
modifier|*
name|closeParen
decl_stmt|;
comment|/* If this procedure parses a name 					 * into array and index, these point 					 * to the parens around the index. 					 * Otherwise they are NULL.  These 					 * are needed to restore the parens 					 * after parsing the name. */
name|char
modifier|*
name|elName
decl_stmt|;
comment|/* Name of array element or NULL; 					 * may be same as part2, or may be 					 * openParen+1. */
name|char
modifier|*
name|p
decl_stmt|;
comment|/*      * If the name hasn't been parsed into array name and index yet,      * do it now.      */
name|openParen
operator|=
name|closeParen
operator|=
name|NULL
expr_stmt|;
name|elName
operator|=
name|part2
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PART1_NOT_PARSED
condition|)
block|{
for|for
control|(
name|p
operator|=
name|part1
init|;
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
name|elName
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
block|{
name|openParen
operator|=
name|p
expr_stmt|;
do|do
block|{
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
do|;
name|p
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|')'
condition|)
block|{
name|closeParen
operator|=
name|p
expr_stmt|;
operator|*
name|openParen
operator|=
literal|0
expr_stmt|;
name|elName
operator|=
name|openParen
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|openParen
operator|=
name|NULL
expr_stmt|;
name|elName
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
comment|/*      * Lookup part1.      */
operator|*
name|arrayPtrPtr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|TCL_GLOBAL_ONLY
operator|)
operator|||
operator|(
name|iPtr
operator|->
name|varFramePtr
operator|==
name|NULL
operator|)
condition|)
block|{
name|tablePtr
operator|=
operator|&
name|iPtr
operator|->
name|globalTable
expr_stmt|;
block|}
else|else
block|{
name|tablePtr
operator|=
operator|&
name|iPtr
operator|->
name|varFramePtr
operator|->
name|varTable
expr_stmt|;
block|}
if|if
condition|(
name|create
operator|&
name|CRT_PART1
condition|)
block|{
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
name|tablePtr
argument_list|,
name|part1
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|openParen
operator|!=
name|NULL
condition|)
block|{
operator|*
name|openParen
operator|=
literal|'('
expr_stmt|;
block|}
if|if
condition|(
name|new
condition|)
block|{
name|varPtr
operator|=
name|NewVar
argument_list|()
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
name|varPtr
argument_list|)
expr_stmt|;
name|varPtr
operator|->
name|hPtr
operator|=
name|hPtr
expr_stmt|;
block|}
block|}
else|else
block|{
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
name|tablePtr
argument_list|,
name|part1
argument_list|)
expr_stmt|;
if|if
condition|(
name|openParen
operator|!=
name|NULL
condition|)
block|{
operator|*
name|openParen
operator|=
literal|'('
expr_stmt|;
block|}
if|if
condition|(
name|hPtr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TCL_LEAVE_ERR_MSG
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
name|msg
argument_list|,
name|noSuchVar
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
block|}
name|varPtr
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_UPVAR
condition|)
block|{
name|varPtr
operator|=
name|varPtr
operator|->
name|value
operator|.
name|upvarPtr
expr_stmt|;
block|}
if|if
condition|(
name|elName
operator|==
name|NULL
condition|)
block|{
return|return
name|varPtr
return|;
block|}
comment|/*      * We're dealing with an array element, so make sure the variable      * is an array and lookup the element (create it if desired).      */
if|if
condition|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_UNDEFINED
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|create
operator|&
name|CRT_PART1
operator|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TCL_LEAVE_ERR_MSG
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
name|msg
argument_list|,
name|noSuchVar
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
name|varPtr
operator|->
name|flags
operator|=
name|VAR_ARRAY
expr_stmt|;
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Tcl_HashTable
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_ARRAY
operator|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TCL_LEAVE_ERR_MSG
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
name|msg
argument_list|,
name|needArray
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
operator|*
name|arrayPtrPtr
operator|=
name|varPtr
expr_stmt|;
if|if
condition|(
name|closeParen
operator|!=
name|NULL
condition|)
block|{
operator|*
name|closeParen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|create
operator|&
name|CRT_PART2
condition|)
block|{
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|,
name|elName
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|closeParen
operator|!=
name|NULL
condition|)
block|{
operator|*
name|closeParen
operator|=
literal|')'
expr_stmt|;
block|}
if|if
condition|(
name|new
condition|)
block|{
if|if
condition|(
name|varPtr
operator|->
name|searchPtr
operator|!=
name|NULL
condition|)
block|{
name|DeleteSearches
argument_list|(
name|varPtr
argument_list|)
expr_stmt|;
block|}
name|varPtr
operator|=
name|NewVar
argument_list|()
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
name|varPtr
argument_list|)
expr_stmt|;
name|varPtr
operator|->
name|hPtr
operator|=
name|hPtr
expr_stmt|;
block|}
block|}
else|else
block|{
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|,
name|elName
argument_list|)
expr_stmt|;
if|if
condition|(
name|closeParen
operator|!=
name|NULL
condition|)
block|{
operator|*
name|closeParen
operator|=
literal|')'
expr_stmt|;
block|}
if|if
condition|(
name|hPtr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TCL_LEAVE_ERR_MSG
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
name|msg
argument_list|,
name|noSuchElement
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
block|}
return|return
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetVar --  *  *	Return the value of a Tcl variable.  *  * Results:  *	The return value points to the current value of varName.  If  *	the variable is not defined or can't be read because of a clash  *	in array usage then a NULL pointer is returned and an error  *	message is left in interp->result if the TCL_LEAVE_ERR_MSG  *	flag is set.  Note:  the return value is only valid up until  *	the next call to Tcl_SetVar or Tcl_SetVar2;  if you depend on  *	the value lasting longer than that, then make yourself a private  *	copy.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_GetVar
parameter_list|(
name|interp
parameter_list|,
name|varName
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Command interpreter in which varName is 				 * to be looked up. */
name|char
modifier|*
name|varName
decl_stmt|;
comment|/* Name of a variable in interp. */
name|int
name|flags
decl_stmt|;
comment|/* OR-ed combination of TCL_GLOBAL_ONLY 				 * or TCL_LEAVE_ERR_MSG bits. */
block|{
return|return
name|Tcl_GetVar2
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|flags
operator||
name|PART1_NOT_PARSED
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetVar2 --  *  *	Return the value of a Tcl variable, given a two-part name  *	consisting of array name and element within array.  *  * Results:  *	The return value points to the current value of the variable  *	given by part1 and part2.  If the specified variable doesn't  *	exist, or if there is a clash in array usage, then NULL is  *	returned and a message will be left in interp->result if the  *	TCL_LEAVE_ERR_MSG flag is set.  Note:  the return value is  *	only valid up until the next call to Tcl_SetVar or Tcl_SetVar2;  *	if you depend on the value lasting longer than that, then make  *	yourself a private copy.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_GetVar2
parameter_list|(
name|interp
parameter_list|,
name|part1
parameter_list|,
name|part2
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Command interpreter in which variable is 				 * to be looked up. */
name|char
modifier|*
name|part1
decl_stmt|;
comment|/* Name of array (if part2 is NULL) or 				 * name of variable. */
name|char
modifier|*
name|part2
decl_stmt|;
comment|/* If non-null, gives name of element in 				 * array. */
name|int
name|flags
decl_stmt|;
comment|/* OR-ed combination of TCL_GLOBAL_ONLY, 				 * TCL_LEAVE_ERR_MSG, and PART1_NOT_PARSED 				 * bits. */
block|{
name|Var
modifier|*
name|varPtr
decl_stmt|,
modifier|*
name|arrayPtr
decl_stmt|;
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|varPtr
operator|=
name|LookupVar
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
name|flags
argument_list|,
literal|"read"
argument_list|,
name|CRT_PART2
argument_list|,
operator|&
name|arrayPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|varPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|/*      * Invoke any traces that have been set for the variable.      */
if|if
condition|(
operator|(
name|varPtr
operator|->
name|tracePtr
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
name|arrayPtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|arrayPtr
operator|->
name|tracePtr
operator|!=
name|NULL
operator|)
operator|)
condition|)
block|{
name|char
modifier|*
name|msg
decl_stmt|;
name|msg
operator|=
name|CallTraces
argument_list|(
name|iPtr
argument_list|,
name|arrayPtr
argument_list|,
name|varPtr
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
operator|(
name|flags
operator|&
operator|(
name|TCL_GLOBAL_ONLY
operator||
name|PART1_NOT_PARSED
operator|)
operator|)
operator||
name|TCL_TRACE_READS
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
literal|"read"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|varPtr
operator|->
name|flags
operator|&
operator|(
name|VAR_UNDEFINED
operator||
name|VAR_UPVAR
operator||
name|VAR_ARRAY
operator|)
operator|)
condition|)
block|{
return|return
name|varPtr
operator|->
name|value
operator|.
name|string
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|TCL_LEAVE_ERR_MSG
condition|)
block|{
name|char
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
operator|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_UNDEFINED
operator|)
operator|&&
operator|(
name|arrayPtr
operator|!=
name|NULL
operator|)
operator|&&
operator|!
operator|(
name|arrayPtr
operator|->
name|flags
operator|&
name|VAR_UNDEFINED
operator|)
condition|)
block|{
name|msg
operator|=
name|noSuchElement
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_ARRAY
condition|)
block|{
name|msg
operator|=
name|isArray
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|=
name|noSuchVar
expr_stmt|;
block|}
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
literal|"read"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
comment|/*      * If the variable doesn't exist anymore and no-one's using it,      * then free up the relevant structures and hash table entries.      */
name|cleanup
label|:
if|if
condition|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_UNDEFINED
condition|)
block|{
name|CleanupVar
argument_list|(
name|varPtr
argument_list|,
name|arrayPtr
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetVar --  *  *	Change the value of a variable.  *  * Results:  *	Returns a pointer to the malloc'ed string holding the new  *	value of the variable.  The caller should not modify this  *	string.  If the write operation was disallowed then NULL  *	is returned;  if the TCL_LEAVE_ERR_MSG flag is set, then  *	an explanatory message will be left in interp->result.  *  * Side effects:  *	If varName is defined as a local or global variable in interp,  *	its value is changed to newValue.  If varName isn't currently  *	defined, then a new global variable by that name is created.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_SetVar
parameter_list|(
name|interp
parameter_list|,
name|varName
parameter_list|,
name|newValue
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Command interpreter in which varName is 				 * to be looked up. */
name|char
modifier|*
name|varName
decl_stmt|;
comment|/* Name of a variable in interp. */
name|char
modifier|*
name|newValue
decl_stmt|;
comment|/* New value for varName. */
name|int
name|flags
decl_stmt|;
comment|/* Various flags that tell how to set value: 				 * any of TCL_GLOBAL_ONLY, TCL_APPEND_VALUE, 				 * TCL_LIST_ELEMENT, or TCL_LEAVE_ERR_MSG. */
block|{
return|return
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|newValue
argument_list|,
name|flags
operator||
name|PART1_NOT_PARSED
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetVar2 --  *  *	Given a two-part variable name, which may refer either to a  *	scalar variable or an element of an array, change the value  *	of the variable.  If the named scalar or array or element  *	doesn't exist then create one.  *  * Results:  *	Returns a pointer to the malloc'ed string holding the new  *	value of the variable.  The caller should not modify this  *	string.  If the write operation was disallowed because an  *	array was expected but not found (or vice versa), then NULL  *	is returned;  if the TCL_LEAVE_ERR_MSG flag is set, then  *	an explanatory message will be left in interp->result.  *  * Side effects:  *	The value of the given variable is set.  If either the array  *	or the entry didn't exist then a new one is created.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_SetVar2
parameter_list|(
name|interp
parameter_list|,
name|part1
parameter_list|,
name|part2
parameter_list|,
name|newValue
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Command interpreter in which variable is 				 * to be looked up. */
name|char
modifier|*
name|part1
decl_stmt|;
comment|/* If part2 is NULL, this is name of scalar 				 * variable.  Otherwise it is name of array. */
name|char
modifier|*
name|part2
decl_stmt|;
comment|/* Name of an element within array, or NULL. */
name|char
modifier|*
name|newValue
decl_stmt|;
comment|/* New value for variable. */
name|int
name|flags
decl_stmt|;
comment|/* Various flags that tell how to set value: 				 * any of TCL_GLOBAL_ONLY, TCL_APPEND_VALUE, 				 * TCL_LIST_ELEMENT, TCL_LEAVE_ERR_MSG, or 				 * PART1_NOT_PARSED. */
block|{
specifier|register
name|Var
modifier|*
name|varPtr
decl_stmt|;
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|int
name|length
decl_stmt|,
name|listFlags
decl_stmt|;
name|Var
modifier|*
name|arrayPtr
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|varPtr
operator|=
name|LookupVar
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
name|flags
argument_list|,
literal|"set"
argument_list|,
name|CRT_PART1
operator||
name|CRT_PART2
argument_list|,
operator|&
name|arrayPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|varPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|/*      * If the variable's hPtr field is NULL, it means that this is an      * upvar to an array element where the array was deleted, leaving      * the element dangling at the end of the upvar.  Generate an error      * (allowing the variable to be reset would screw up our storage      * allocation and is meaningless anyway).      */
if|if
condition|(
name|varPtr
operator|->
name|hPtr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TCL_LEAVE_ERR_MSG
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
literal|"set"
argument_list|,
name|danglingUpvar
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
comment|/*      * Clear the variable's current value unless this is an      * append operation.      */
if|if
condition|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_ARRAY
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TCL_LEAVE_ERR_MSG
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
literal|"set"
argument_list|,
name|isArray
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TCL_APPEND_VALUE
operator|)
operator|||
operator|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_UNDEFINED
operator|)
condition|)
block|{
name|varPtr
operator|->
name|valueLength
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * Call read trace if variable is being appended to.      */
if|if
condition|(
operator|(
name|flags
operator|&
name|TCL_APPEND_VALUE
operator|)
operator|&&
operator|(
operator|(
name|varPtr
operator|->
name|tracePtr
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
name|arrayPtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|arrayPtr
operator|->
name|tracePtr
operator|!=
name|NULL
operator|)
operator|)
operator|)
condition|)
block|{
name|char
modifier|*
name|msg
decl_stmt|;
name|msg
operator|=
name|CallTraces
argument_list|(
name|iPtr
argument_list|,
name|arrayPtr
argument_list|,
name|varPtr
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
operator|(
name|flags
operator|&
operator|(
name|TCL_GLOBAL_ONLY
operator||
name|PART1_NOT_PARSED
operator|)
operator|)
operator||
name|TCL_TRACE_READS
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
literal|"read"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|result
operator|=
name|NULL
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
comment|/*      * Compute how many total bytes will be needed for the variable's      * new value (leave space for a separating space between list      * elements).  Allocate new space for the value if needed.      */
if|if
condition|(
name|flags
operator|&
name|TCL_LIST_ELEMENT
condition|)
block|{
name|length
operator|=
name|Tcl_ScanElement
argument_list|(
name|newValue
argument_list|,
operator|&
name|listFlags
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|length
operator|=
name|strlen
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
block|}
name|length
operator|+=
name|varPtr
operator|->
name|valueLength
expr_stmt|;
if|if
condition|(
name|length
operator|>=
name|varPtr
operator|->
name|valueSpace
condition|)
block|{
name|char
modifier|*
name|newValue
decl_stmt|;
name|int
name|newSize
decl_stmt|;
name|newSize
operator|=
literal|2
operator|*
name|varPtr
operator|->
name|valueSpace
expr_stmt|;
if|if
condition|(
name|newSize
operator|<=
name|length
condition|)
block|{
name|newSize
operator|=
name|length
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|newSize
operator|<
literal|24
condition|)
block|{
comment|/* 	     * Don't waste time with teensy-tiny variables;  we'll 	     * just end up expanding them later. 	     */
name|newSize
operator|=
literal|24
expr_stmt|;
block|}
name|newValue
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|newSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|varPtr
operator|->
name|valueSpace
operator|>
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|newValue
argument_list|,
name|varPtr
operator|->
name|value
operator|.
name|string
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
name|varPtr
operator|->
name|valueSpace
operator|=
name|newSize
expr_stmt|;
name|varPtr
operator|->
name|value
operator|.
name|string
operator|=
name|newValue
expr_stmt|;
block|}
comment|/*      * Append the new value to the variable, either as a list      * element or as a string.      */
if|if
condition|(
name|flags
operator|&
name|TCL_LIST_ELEMENT
condition|)
block|{
name|char
modifier|*
name|dst
init|=
name|varPtr
operator|->
name|value
operator|.
name|string
operator|+
name|varPtr
operator|->
name|valueLength
decl_stmt|;
if|if
condition|(
name|TclNeedSpace
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|string
argument_list|,
name|dst
argument_list|)
condition|)
block|{
operator|*
name|dst
operator|=
literal|' '
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|varPtr
operator|->
name|valueLength
operator|++
expr_stmt|;
block|}
name|varPtr
operator|->
name|valueLength
operator|+=
name|Tcl_ConvertElement
argument_list|(
name|newValue
argument_list|,
name|dst
argument_list|,
name|listFlags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|string
operator|+
name|varPtr
operator|->
name|valueLength
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
name|varPtr
operator|->
name|valueLength
operator|=
name|length
expr_stmt|;
block|}
name|varPtr
operator|->
name|flags
operator|&=
operator|~
name|VAR_UNDEFINED
expr_stmt|;
comment|/*      * Invoke any write traces for the variable.      */
if|if
condition|(
operator|(
name|varPtr
operator|->
name|tracePtr
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
name|arrayPtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|arrayPtr
operator|->
name|tracePtr
operator|!=
name|NULL
operator|)
operator|)
condition|)
block|{
name|char
modifier|*
name|msg
decl_stmt|;
name|msg
operator|=
name|CallTraces
argument_list|(
name|iPtr
argument_list|,
name|arrayPtr
argument_list|,
name|varPtr
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
operator|(
name|flags
operator|&
operator|(
name|TCL_GLOBAL_ONLY
operator||
name|PART1_NOT_PARSED
operator|)
operator|)
operator||
name|TCL_TRACE_WRITES
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
literal|"set"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|result
operator|=
name|NULL
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
comment|/*      * If the variable was changed in some gross way by a trace (e.g.      * it was unset and then recreated as an array) then just return      * an empty string;  otherwise return the variable's current      * value.      */
if|if
condition|(
operator|!
operator|(
name|varPtr
operator|->
name|flags
operator|&
operator|(
name|VAR_UNDEFINED
operator||
name|VAR_UPVAR
operator||
name|VAR_ARRAY
operator|)
operator|)
condition|)
block|{
return|return
name|varPtr
operator|->
name|value
operator|.
name|string
return|;
block|}
name|result
operator|=
literal|""
expr_stmt|;
comment|/*      * If the variable doesn't exist anymore and no-one's using it,      * then free up the relevant structures and hash table entries.      */
name|cleanup
label|:
if|if
condition|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_UNDEFINED
condition|)
block|{
name|CleanupVar
argument_list|(
name|varPtr
argument_list|,
name|arrayPtr
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_UnsetVar --  *  *	Delete a variable, so that it may not be accessed anymore.  *  * Results:  *	Returns TCL_OK if the variable was successfully deleted, TCL_ERROR  *	if the variable can't be unset.  In the event of an error,  *	if the TCL_LEAVE_ERR_MSG flag is set then an error message  *	is left in interp->result.  *  * Side effects:  *	If varName is defined as a local or global variable in interp,  *	it is deleted.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_UnsetVar
parameter_list|(
name|interp
parameter_list|,
name|varName
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Command interpreter in which varName is 				 * to be looked up. */
name|char
modifier|*
name|varName
decl_stmt|;
comment|/* Name of a variable in interp.  May be 				 * either a scalar name or an array name 				 * or an element in an array. */
name|int
name|flags
decl_stmt|;
comment|/* OR-ed combination of any of 				 * TCL_GLOBAL_ONLY or TCL_LEAVE_ERR_MSG. */
block|{
return|return
name|Tcl_UnsetVar2
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|flags
operator||
name|PART1_NOT_PARSED
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_UnsetVar2 --  *  *	Delete a variable, given a 2-part name.  *  * Results:  *	Returns TCL_OK if the variable was successfully deleted, TCL_ERROR  *	if the variable can't be unset.  In the event of an error,  *	if the TCL_LEAVE_ERR_MSG flag is set then an error message  *	is left in interp->result.  *  * Side effects:  *	If part1 and part2 indicate a local or global variable in interp,  *	it is deleted.  If part1 is an array name and part2 is NULL, then  *	the whole array is deleted.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_UnsetVar2
parameter_list|(
name|interp
parameter_list|,
name|part1
parameter_list|,
name|part2
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Command interpreter in which varName is 				 * to be looked up. */
name|char
modifier|*
name|part1
decl_stmt|;
comment|/* Name of variable or array. */
name|char
modifier|*
name|part2
decl_stmt|;
comment|/* Name of element within array or NULL. */
name|int
name|flags
decl_stmt|;
comment|/* OR-ed combination of any of 				 * TCL_GLOBAL_ONLY, TCL_LEAVE_ERR_MSG, 				 * or PART1_NOT_PARSED. */
block|{
name|Var
modifier|*
name|varPtr
decl_stmt|,
name|dummyVar
decl_stmt|;
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Var
modifier|*
name|arrayPtr
decl_stmt|;
name|ActiveVarTrace
modifier|*
name|activePtr
decl_stmt|;
name|int
name|result
decl_stmt|;
name|varPtr
operator|=
name|LookupVar
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
name|flags
argument_list|,
literal|"unset"
argument_list|,
literal|0
argument_list|,
operator|&
name|arrayPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|varPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|result
operator|=
operator|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_UNDEFINED
operator|)
condition|?
name|TCL_ERROR
else|:
name|TCL_OK
expr_stmt|;
if|if
condition|(
operator|(
name|arrayPtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|arrayPtr
operator|->
name|searchPtr
operator|!=
name|NULL
operator|)
condition|)
block|{
name|DeleteSearches
argument_list|(
name|arrayPtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * The code below is tricky, because of the possibility that      * a trace procedure might try to access a variable being      * deleted.  To handle this situation gracefully, do things      * in three steps:      * 1. Copy the contents of the variable to a dummy variable      *    structure, and mark the original structure as undefined.      * 2. Invoke traces and clean up the variable, using the copy.      * 3. If at the end of this the original variable is still      *    undefined and has no outstanding references, then delete      *	  it (but it could have gotten recreated by a trace).      */
name|dummyVar
operator|=
operator|*
name|varPtr
expr_stmt|;
name|varPtr
operator|->
name|valueSpace
operator|=
literal|0
expr_stmt|;
name|varPtr
operator|->
name|flags
operator|=
name|VAR_UNDEFINED
expr_stmt|;
name|varPtr
operator|->
name|tracePtr
operator|=
name|NULL
expr_stmt|;
name|varPtr
operator|->
name|searchPtr
operator|=
name|NULL
expr_stmt|;
comment|/*      * Call trace procedures for the variable being deleted and delete      * its traces.  Be sure to abort any other traces for the variable      * that are still pending.  Special tricks:      * 1. Increment varPtr's refCount around this:  CallTraces will      *    use dummyVar so it won't increment varPtr's refCount.      * 2. Turn off the VAR_TRACE_ACTIVE flag in dummyVar: we want to      *    call unset traces even if other traces are pending.      */
if|if
condition|(
operator|(
name|dummyVar
operator|.
name|tracePtr
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
name|arrayPtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|arrayPtr
operator|->
name|tracePtr
operator|!=
name|NULL
operator|)
operator|)
condition|)
block|{
name|varPtr
operator|->
name|refCount
operator|++
expr_stmt|;
name|dummyVar
operator|.
name|flags
operator|&=
operator|~
name|VAR_TRACE_ACTIVE
expr_stmt|;
operator|(
name|void
operator|)
name|CallTraces
argument_list|(
name|iPtr
argument_list|,
name|arrayPtr
argument_list|,
operator|&
name|dummyVar
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
operator|(
name|flags
operator|&
operator|(
name|TCL_GLOBAL_ONLY
operator||
name|PART1_NOT_PARSED
operator|)
operator|)
operator||
name|TCL_TRACE_UNSETS
argument_list|)
expr_stmt|;
while|while
condition|(
name|dummyVar
operator|.
name|tracePtr
operator|!=
name|NULL
condition|)
block|{
name|VarTrace
modifier|*
name|tracePtr
init|=
name|dummyVar
operator|.
name|tracePtr
decl_stmt|;
name|dummyVar
operator|.
name|tracePtr
operator|=
name|tracePtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tracePtr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|activePtr
operator|=
name|iPtr
operator|->
name|activeTracePtr
init|;
name|activePtr
operator|!=
name|NULL
condition|;
name|activePtr
operator|=
name|activePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|activePtr
operator|->
name|varPtr
operator|==
name|varPtr
condition|)
block|{
name|activePtr
operator|->
name|nextTracePtr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|varPtr
operator|->
name|refCount
operator|--
expr_stmt|;
block|}
comment|/*      * If the variable is an array, delete all of its elements.  This      * must be done after calling the traces on the array, above (that's      * the way traces are defined).      */
if|if
condition|(
name|dummyVar
operator|.
name|flags
operator|&
name|VAR_ARRAY
condition|)
block|{
name|DeleteArray
argument_list|(
name|iPtr
argument_list|,
name|part1
argument_list|,
operator|&
name|dummyVar
argument_list|,
operator|(
name|flags
operator|&
name|TCL_GLOBAL_ONLY
operator|)
operator||
name|TCL_TRACE_UNSETS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dummyVar
operator|.
name|valueSpace
operator|>
literal|0
condition|)
block|{
name|ckfree
argument_list|(
name|dummyVar
operator|.
name|value
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TCL_LEAVE_ERR_MSG
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
literal|"unset"
argument_list|,
operator|(
name|arrayPtr
operator|==
name|NULL
operator|)
condition|?
name|noSuchVar
else|:
name|noSuchElement
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Finally, if the variable is truly not in use then free up its      * record and remove it from the hash table.      */
name|CleanupVar
argument_list|(
name|varPtr
argument_list|,
name|arrayPtr
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_TraceVar --  *  *	Arrange for reads and/or writes to a variable to cause a  *	procedure to be invoked, which can monitor the operations  *	and/or change their actions.  *  * Results:  *	A standard Tcl return value.  *  * Side effects:  *	A trace is set up on the variable given by varName, such that  *	future references to the variable will be intermediated by  *	proc.  See the manual entry for complete details on the calling  *	sequence for proc.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_TraceVar
parameter_list|(
name|interp
parameter_list|,
name|varName
parameter_list|,
name|flags
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which variable is 				 * to be traced. */
name|char
modifier|*
name|varName
decl_stmt|;
comment|/* Name of variable;  may end with "(index)" 				 * to signify an array reference. */
name|int
name|flags
decl_stmt|;
comment|/* OR-ed collection of bits, including any 				 * of TCL_TRACE_READS, TCL_TRACE_WRITES, 				 * TCL_TRACE_UNSETS, and TCL_GLOBAL_ONLY. */
name|Tcl_VarTraceProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to call when specified ops are 				 * invoked upon varName. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary argument to pass to proc. */
block|{
return|return
name|Tcl_TraceVar2
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|flags
operator||
name|PART1_NOT_PARSED
argument_list|,
name|proc
argument_list|,
name|clientData
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_TraceVar2 --  *  *	Arrange for reads and/or writes to a variable to cause a  *	procedure to be invoked, which can monitor the operations  *	and/or change their actions.  *  * Results:  *	A standard Tcl return value.  *  * Side effects:  *	A trace is set up on the variable given by part1 and part2, such  *	that future references to the variable will be intermediated by  *	proc.  See the manual entry for complete details on the calling  *	sequence for proc.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_TraceVar2
parameter_list|(
name|interp
parameter_list|,
name|part1
parameter_list|,
name|part2
parameter_list|,
name|flags
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which variable is 				 * to be traced. */
name|char
modifier|*
name|part1
decl_stmt|;
comment|/* Name of scalar variable or array. */
name|char
modifier|*
name|part2
decl_stmt|;
comment|/* Name of element within array;  NULL means 				 * trace applies to scalar variable or array 				 * as-a-whole. */
name|int
name|flags
decl_stmt|;
comment|/* OR-ed collection of bits, including any 				 * of TCL_TRACE_READS, TCL_TRACE_WRITES, 				 * TCL_TRACE_UNSETS, TCL_GLOBAL_ONLY, and 				 * PART1_NOT_PARSED. */
name|Tcl_VarTraceProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to call when specified ops are 				 * invoked upon varName. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary argument to pass to proc. */
block|{
name|Var
modifier|*
name|varPtr
decl_stmt|,
modifier|*
name|arrayPtr
decl_stmt|;
specifier|register
name|VarTrace
modifier|*
name|tracePtr
decl_stmt|;
name|varPtr
operator|=
name|LookupVar
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
operator|(
name|flags
operator||
name|TCL_LEAVE_ERR_MSG
operator|)
argument_list|,
literal|"trace"
argument_list|,
name|CRT_PART1
operator||
name|CRT_PART2
argument_list|,
operator|&
name|arrayPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|varPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Set up trace information.      */
name|tracePtr
operator|=
operator|(
name|VarTrace
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|VarTrace
argument_list|)
argument_list|)
expr_stmt|;
name|tracePtr
operator|->
name|traceProc
operator|=
name|proc
expr_stmt|;
name|tracePtr
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
name|tracePtr
operator|->
name|flags
operator|=
name|flags
operator|&
operator|(
name|TCL_TRACE_READS
operator||
name|TCL_TRACE_WRITES
operator||
name|TCL_TRACE_UNSETS
operator|)
expr_stmt|;
name|tracePtr
operator|->
name|nextPtr
operator|=
name|varPtr
operator|->
name|tracePtr
expr_stmt|;
name|varPtr
operator|->
name|tracePtr
operator|=
name|tracePtr
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_UntraceVar --  *  *	Remove a previously-created trace for a variable.  *  * Results:  *	None.  *  * Side effects:  *	If there exists a trace for the variable given by varName  *	with the given flags, proc, and clientData, then that trace  *	is removed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_UntraceVar
parameter_list|(
name|interp
parameter_list|,
name|varName
parameter_list|,
name|flags
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter containing traced variable. */
name|char
modifier|*
name|varName
decl_stmt|;
comment|/* Name of variable;  may end with "(index)" 				 * to signify an array reference. */
name|int
name|flags
decl_stmt|;
comment|/* OR-ed collection of bits describing 				 * current trace, including any of 				 * TCL_TRACE_READS, TCL_TRACE_WRITES, 				 * TCL_TRACE_UNSETS, and TCL_GLOBAL_ONLY. */
name|Tcl_VarTraceProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure assocated with trace. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary argument to pass to proc. */
block|{
name|Tcl_UntraceVar2
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|flags
operator||
name|PART1_NOT_PARSED
argument_list|,
name|proc
argument_list|,
name|clientData
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_UntraceVar2 --  *  *	Remove a previously-created trace for a variable.  *  * Results:  *	None.  *  * Side effects:  *	If there exists a trace for the variable given by part1  *	and part2 with the given flags, proc, and clientData, then  *	that trace is removed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_UntraceVar2
parameter_list|(
name|interp
parameter_list|,
name|part1
parameter_list|,
name|part2
parameter_list|,
name|flags
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter containing traced variable. */
name|char
modifier|*
name|part1
decl_stmt|;
comment|/* Name of variable or array. */
name|char
modifier|*
name|part2
decl_stmt|;
comment|/* Name of element within array;  NULL means 				 * trace applies to scalar variable or array 				 * as-a-whole. */
name|int
name|flags
decl_stmt|;
comment|/* OR-ed collection of bits describing 				 * current trace, including any of 				 * TCL_TRACE_READS, TCL_TRACE_WRITES, 				 * TCL_TRACE_UNSETS, TCL_GLOBAL_ONLY, and 				 * PART1_NOT_PARSED. */
name|Tcl_VarTraceProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure assocated with trace. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary argument to pass to proc. */
block|{
specifier|register
name|VarTrace
modifier|*
name|tracePtr
decl_stmt|;
name|VarTrace
modifier|*
name|prevPtr
decl_stmt|;
name|Var
modifier|*
name|varPtr
decl_stmt|,
modifier|*
name|arrayPtr
decl_stmt|;
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|ActiveVarTrace
modifier|*
name|activePtr
decl_stmt|;
name|varPtr
operator|=
name|LookupVar
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
name|flags
operator|&
operator|(
name|TCL_GLOBAL_ONLY
operator||
name|PART1_NOT_PARSED
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|arrayPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|varPtr
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|flags
operator|&=
operator|(
name|TCL_TRACE_READS
operator||
name|TCL_TRACE_WRITES
operator||
name|TCL_TRACE_UNSETS
operator|)
expr_stmt|;
for|for
control|(
name|tracePtr
operator|=
name|varPtr
operator|->
name|tracePtr
operator|,
name|prevPtr
operator|=
name|NULL
init|;
condition|;
name|prevPtr
operator|=
name|tracePtr
operator|,
name|tracePtr
operator|=
name|tracePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|tracePtr
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|(
name|tracePtr
operator|->
name|traceProc
operator|==
name|proc
operator|)
operator|&&
operator|(
name|tracePtr
operator|->
name|flags
operator|==
name|flags
operator|)
operator|&&
operator|(
name|tracePtr
operator|->
name|clientData
operator|==
name|clientData
operator|)
condition|)
block|{
break|break;
block|}
block|}
comment|/*      * The code below makes it possible to delete traces while traces      * are active:  it makes sure that the deleted trace won't be      * processed by CallTraces.      */
for|for
control|(
name|activePtr
operator|=
name|iPtr
operator|->
name|activeTracePtr
init|;
name|activePtr
operator|!=
name|NULL
condition|;
name|activePtr
operator|=
name|activePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|activePtr
operator|->
name|nextTracePtr
operator|==
name|tracePtr
condition|)
block|{
name|activePtr
operator|->
name|nextTracePtr
operator|=
name|tracePtr
operator|->
name|nextPtr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|prevPtr
operator|==
name|NULL
condition|)
block|{
name|varPtr
operator|->
name|tracePtr
operator|=
name|tracePtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
name|prevPtr
operator|->
name|nextPtr
operator|=
name|tracePtr
operator|->
name|nextPtr
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tracePtr
argument_list|)
expr_stmt|;
comment|/*      * If this is the last trace on the variable, and the variable is      * unset and unused, then free up the variable.      */
if|if
condition|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_UNDEFINED
condition|)
block|{
name|CleanupVar
argument_list|(
name|varPtr
argument_list|,
operator|(
name|Var
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_VarTraceInfo --  *  *	Return the clientData value associated with a trace on a  *	variable.  This procedure can also be used to step through  *	all of the traces on a particular variable that have the  *	same trace procedure.  *  * Results:  *	The return value is the clientData value associated with  *	a trace on the given variable.  Information will only be  *	returned for a trace with proc as trace procedure.  If  *	the clientData argument is NULL then the first such trace is  *	returned;  otherwise, the next relevant one after the one  *	given by clientData will be returned.  If the variable  *	doesn't exist, or if there are no (more) traces for it,  *	then NULL is returned.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|ClientData
name|Tcl_VarTraceInfo
parameter_list|(
name|interp
parameter_list|,
name|varName
parameter_list|,
name|flags
parameter_list|,
name|proc
parameter_list|,
name|prevClientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter containing variable. */
name|char
modifier|*
name|varName
decl_stmt|;
comment|/* Name of variable;  may end with "(index)" 				 * to signify an array reference. */
name|int
name|flags
decl_stmt|;
comment|/* 0 or TCL_GLOBAL_ONLY. */
name|Tcl_VarTraceProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure assocated with trace. */
name|ClientData
name|prevClientData
decl_stmt|;
comment|/* If non-NULL, gives last value returned 				 * by this procedure, so this call will 				 * return the next trace after that one. 				 * If NULL, this call will return the 				 * first trace. */
block|{
return|return
name|Tcl_VarTraceInfo2
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|flags
operator||
name|PART1_NOT_PARSED
argument_list|,
name|proc
argument_list|,
name|prevClientData
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_VarTraceInfo2 --  *  *	Same as Tcl_VarTraceInfo, except takes name in two pieces  *	instead of one.  *  * Results:  *	Same as Tcl_VarTraceInfo.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|ClientData
name|Tcl_VarTraceInfo2
parameter_list|(
name|interp
parameter_list|,
name|part1
parameter_list|,
name|part2
parameter_list|,
name|flags
parameter_list|,
name|proc
parameter_list|,
name|prevClientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter containing variable. */
name|char
modifier|*
name|part1
decl_stmt|;
comment|/* Name of variable or array. */
name|char
modifier|*
name|part2
decl_stmt|;
comment|/* Name of element within array;  NULL means 				 * trace applies to scalar variable or array 				 * as-a-whole. */
name|int
name|flags
decl_stmt|;
comment|/* OR-ed combination of TCL_GLOBAL_ONLY and 				 * PART1_NOT_PARSED. */
name|Tcl_VarTraceProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure assocated with trace. */
name|ClientData
name|prevClientData
decl_stmt|;
comment|/* If non-NULL, gives last value returned 				 * by this procedure, so this call will 				 * return the next trace after that one. 				 * If NULL, this call will return the 				 * first trace. */
block|{
specifier|register
name|VarTrace
modifier|*
name|tracePtr
decl_stmt|;
name|Var
modifier|*
name|varPtr
decl_stmt|,
modifier|*
name|arrayPtr
decl_stmt|;
name|varPtr
operator|=
name|LookupVar
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
name|flags
operator|&
operator|(
name|TCL_GLOBAL_ONLY
operator||
name|PART1_NOT_PARSED
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|arrayPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|varPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|/*      * Find the relevant trace, if any, and return its clientData.      */
name|tracePtr
operator|=
name|varPtr
operator|->
name|tracePtr
expr_stmt|;
if|if
condition|(
name|prevClientData
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
name|tracePtr
operator|!=
name|NULL
condition|;
name|tracePtr
operator|=
name|tracePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
operator|(
name|tracePtr
operator|->
name|clientData
operator|==
name|prevClientData
operator|)
operator|&&
operator|(
name|tracePtr
operator|->
name|traceProc
operator|==
name|proc
operator|)
condition|)
block|{
name|tracePtr
operator|=
name|tracePtr
operator|->
name|nextPtr
expr_stmt|;
break|break;
block|}
block|}
block|}
for|for
control|(
init|;
name|tracePtr
operator|!=
name|NULL
condition|;
name|tracePtr
operator|=
name|tracePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|tracePtr
operator|->
name|traceProc
operator|==
name|proc
condition|)
block|{
return|return
name|tracePtr
operator|->
name|clientData
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetCmd --  *  *	This procedure is invoked to process the "set" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result value.  *  * Side effects:  *	A variable's value may be changed.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_SetCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
specifier|register
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
name|char
modifier|*
name|value
decl_stmt|;
name|value
operator|=
name|Tcl_GetVar2
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_LEAVE_ERR_MSG
operator||
name|PART1_NOT_PARSED
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|interp
operator|->
name|result
operator|=
name|value
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
block|{
name|char
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|TCL_LEAVE_ERR_MSG
operator||
name|PART1_NOT_PARSED
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|interp
operator|->
name|result
operator|=
name|result
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" varName ?newValue?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_UnsetCmd --  *  *	This procedure is invoked to process the "unset" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result value.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_UnsetCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
specifier|register
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" varName ?varName ...?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Tcl_UnsetVar2
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_LEAVE_ERR_MSG
operator||
name|PART1_NOT_PARSED
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_AppendCmd --  *  *	This procedure is invoked to process the "append" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result value.  *  * Side effects:  *	A variable's value may be changed.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_AppendCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
specifier|register
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
comment|/* (Initialization only needed to keep 					 * the compiler from complaining) */
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" varName ?value value ...?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
name|result
operator|=
name|Tcl_GetVar2
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_LEAVE_ERR_MSG
operator||
name|PART1_NOT_PARSED
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|interp
operator|->
name|result
operator|=
name|result
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|TCL_APPEND_VALUE
operator||
name|TCL_LEAVE_ERR_MSG
operator||
name|PART1_NOT_PARSED
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
name|interp
operator|->
name|result
operator|=
name|result
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_LappendCmd --  *  *	This procedure is invoked to process the "lappend" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result value.  *  * Side effects:  *	A variable's value may be changed.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_LappendCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
specifier|register
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
comment|/* (Initialization only needed to keep 					 * the compiler from complaining) */
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" varName ?value value ...?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
name|result
operator|=
name|Tcl_GetVar2
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_LEAVE_ERR_MSG
operator||
name|PART1_NOT_PARSED
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|interp
operator|->
name|result
operator|=
name|result
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|TCL_APPEND_VALUE
operator||
name|TCL_LIST_ELEMENT
operator||
name|TCL_LEAVE_ERR_MSG
operator||
name|PART1_NOT_PARSED
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
name|interp
operator|->
name|result
operator|=
name|result
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ArrayCmd --  *  *	This procedure is invoked to process the "array" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result value.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_ArrayCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
specifier|register
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|c
decl_stmt|,
name|notArray
decl_stmt|;
name|size_t
name|length
decl_stmt|;
name|Var
modifier|*
name|varPtr
init|=
name|NULL
decl_stmt|;
comment|/* Initialization needed only to prevent 				 * compiler warning. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" option arrayName ?arg ...?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Locate the array variable (and it better be an array).      */
if|if
condition|(
name|iPtr
operator|->
name|varFramePtr
operator|==
name|NULL
condition|)
block|{
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|globalTable
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|varFramePtr
operator|->
name|varTable
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
name|notArray
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
name|NULL
condition|)
block|{
name|notArray
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|varPtr
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_UPVAR
condition|)
block|{
name|varPtr
operator|=
name|varPtr
operator|->
name|value
operator|.
name|upvarPtr
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_ARRAY
operator|)
condition|)
block|{
name|notArray
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/*      * Dispatch based on the option.      */
name|c
operator|=
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'a'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"anymore"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|ArraySearch
modifier|*
name|searchPtr
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" anymore arrayName searchId\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|notArray
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|searchPtr
operator|=
name|ParseSearchId
argument_list|(
name|interp
argument_list|,
name|varPtr
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|searchPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|Var
modifier|*
name|varPtr2
decl_stmt|;
if|if
condition|(
name|searchPtr
operator|->
name|nextEntry
operator|!=
name|NULL
condition|)
block|{
name|varPtr2
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|searchPtr
operator|->
name|nextEntry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|varPtr2
operator|->
name|flags
operator|&
name|VAR_UNDEFINED
operator|)
condition|)
block|{
break|break;
block|}
block|}
name|searchPtr
operator|->
name|nextEntry
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|searchPtr
operator|->
name|search
argument_list|)
expr_stmt|;
if|if
condition|(
name|searchPtr
operator|->
name|nextEntry
operator|==
name|NULL
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"0"
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
block|}
name|interp
operator|->
name|result
operator|=
literal|"1"
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'d'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"donesearch"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|ArraySearch
modifier|*
name|searchPtr
decl_stmt|,
modifier|*
name|prevPtr
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" donesearch arrayName searchId\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|notArray
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|searchPtr
operator|=
name|ParseSearchId
argument_list|(
name|interp
argument_list|,
name|varPtr
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|searchPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|varPtr
operator|->
name|searchPtr
operator|==
name|searchPtr
condition|)
block|{
name|varPtr
operator|->
name|searchPtr
operator|=
name|searchPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|prevPtr
operator|=
name|varPtr
operator|->
name|searchPtr
init|;
condition|;
name|prevPtr
operator|=
name|prevPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|prevPtr
operator|->
name|nextPtr
operator|==
name|searchPtr
condition|)
block|{
name|prevPtr
operator|->
name|nextPtr
operator|=
name|searchPtr
operator|->
name|nextPtr
expr_stmt|;
break|break;
block|}
block|}
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|searchPtr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"exists"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" exists arrayName\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|interp
operator|->
name|result
operator|=
operator|(
name|notArray
operator|)
condition|?
literal|"0"
else|:
literal|"1"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'g'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"get"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|Tcl_HashSearch
name|search
decl_stmt|;
name|Var
modifier|*
name|varPtr2
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|(
name|argc
operator|!=
literal|3
operator|)
operator|&&
operator|(
name|argc
operator|!=
literal|4
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" get arrayName ?pattern?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|notArray
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
name|varPtr2
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|varPtr2
operator|->
name|flags
operator|&
name|VAR_UNDEFINED
condition|)
block|{
continue|continue;
block|}
name|name
operator|=
name|Tcl_GetHashKey
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|,
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|argc
operator|==
literal|4
operator|)
operator|&&
operator|!
name|Tcl_StringMatch
argument_list|(
name|name
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|varPtr2
operator|->
name|value
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'n'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"names"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|2
operator|)
condition|)
block|{
name|Tcl_HashSearch
name|search
decl_stmt|;
name|Var
modifier|*
name|varPtr2
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|(
name|argc
operator|!=
literal|3
operator|)
operator|&&
operator|(
name|argc
operator|!=
literal|4
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" names arrayName ?pattern?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|notArray
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
name|varPtr2
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|varPtr2
operator|->
name|flags
operator|&
name|VAR_UNDEFINED
condition|)
block|{
continue|continue;
block|}
name|name
operator|=
name|Tcl_GetHashKey
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|,
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|argc
operator|==
literal|4
operator|)
operator|&&
operator|!
name|Tcl_StringMatch
argument_list|(
name|name
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'n'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"nextelement"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|2
operator|)
condition|)
block|{
name|ArraySearch
modifier|*
name|searchPtr
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" nextelement arrayName searchId\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|notArray
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|searchPtr
operator|=
name|ParseSearchId
argument_list|(
name|interp
argument_list|,
name|varPtr
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|searchPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|Var
modifier|*
name|varPtr2
decl_stmt|;
name|hPtr
operator|=
name|searchPtr
operator|->
name|nextEntry
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
name|NULL
condition|)
block|{
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|searchPtr
operator|->
name|search
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
block|}
else|else
block|{
name|searchPtr
operator|->
name|nextEntry
operator|=
name|NULL
expr_stmt|;
block|}
name|varPtr2
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|varPtr2
operator|->
name|flags
operator|&
name|VAR_UNDEFINED
operator|)
condition|)
block|{
break|break;
block|}
block|}
name|interp
operator|->
name|result
operator|=
name|Tcl_GetHashKey
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|,
name|hPtr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'s'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"set"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|2
operator|)
condition|)
block|{
name|char
modifier|*
modifier|*
name|valueArgv
decl_stmt|;
name|int
name|valueArgc
decl_stmt|,
name|i
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" set arrayName list\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_SplitList
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
operator|&
name|valueArgc
argument_list|,
operator|&
name|valueArgv
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|result
operator|=
name|TCL_OK
expr_stmt|;
if|if
condition|(
name|valueArgc
operator|&
literal|1
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"list must have an even number of elements"
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|setDone
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|valueArgc
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|valueArgv
index|[
name|i
index|]
argument_list|,
name|valueArgv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
break|break;
block|}
block|}
name|setDone
label|:
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|valueArgv
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'s'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"size"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|2
operator|)
condition|)
block|{
name|Tcl_HashSearch
name|search
decl_stmt|;
name|Var
modifier|*
name|varPtr2
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" size arrayName\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|notArray
condition|)
block|{
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
name|varPtr2
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|varPtr2
operator|->
name|flags
operator|&
name|VAR_UNDEFINED
condition|)
block|{
continue|continue;
block|}
name|size
operator|++
expr_stmt|;
block|}
block|}
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"%d"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'s'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"startsearch"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|2
operator|)
condition|)
block|{
name|ArraySearch
modifier|*
name|searchPtr
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" startsearch arrayName\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|notArray
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|searchPtr
operator|=
operator|(
name|ArraySearch
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ArraySearch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|varPtr
operator|->
name|searchPtr
operator|==
name|NULL
condition|)
block|{
name|searchPtr
operator|->
name|id
operator|=
literal|1
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"s-1-"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|string
index|[
literal|20
index|]
decl_stmt|;
name|searchPtr
operator|->
name|id
operator|=
name|varPtr
operator|->
name|searchPtr
operator|->
name|id
operator|+
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%d"
argument_list|,
name|searchPtr
operator|->
name|id
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"s-"
argument_list|,
name|string
argument_list|,
literal|"-"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|searchPtr
operator|->
name|varPtr
operator|=
name|varPtr
expr_stmt|;
name|searchPtr
operator|->
name|nextEntry
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|,
operator|&
name|searchPtr
operator|->
name|search
argument_list|)
expr_stmt|;
name|searchPtr
operator|->
name|nextPtr
operator|=
name|varPtr
operator|->
name|searchPtr
expr_stmt|;
name|varPtr
operator|->
name|searchPtr
operator|=
name|searchPtr
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": should be anymore, donesearch, exists, "
argument_list|,
literal|"get, names, nextelement, "
argument_list|,
literal|"set, size, or startsearch"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
name|error
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"\""
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"\" isn't an array"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * MakeUpvar --  *  *	This procedure does all of the work of the "global" and "upvar"  *	commands.  *  * Results:  *	A standard Tcl completion code.  If an error occurs then an  *	error message is left in iPtr->result.  *  * Side effects:  *	The variable given by myName is linked to the variable in  *	framePtr given by otherP1 and otherP2, so that references to  *	myName are redirected to the other variable like a symbolic *	link.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|MakeUpvar
parameter_list|(
name|iPtr
parameter_list|,
name|framePtr
parameter_list|,
name|otherP1
parameter_list|,
name|otherP2
parameter_list|,
name|myName
parameter_list|,
name|flags
parameter_list|)
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Interpreter containing variables.  Used 				 * for error messages, too. */
name|CallFrame
modifier|*
name|framePtr
decl_stmt|;
comment|/* Call frame containing "other" variable. 				 * NULL means use global context. */
name|char
modifier|*
name|otherP1
decl_stmt|,
decl|*
name|otherP2
decl_stmt|;
end_function

begin_comment
comment|/* Two-part name of variable in framePtr. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|myName
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of variable in local table, which 				 * will refer to otherP1/P2.  Must be a 				 * scalar. */
end_comment

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 or TCL_GLOBAL_ONLY: indicates scope of 				 * myName. */
end_comment

begin_block
block|{
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|Var
modifier|*
name|otherPtr
decl_stmt|,
modifier|*
name|varPtr
decl_stmt|,
modifier|*
name|arrayPtr
decl_stmt|;
name|CallFrame
modifier|*
name|savedFramePtr
decl_stmt|;
name|int
name|new
decl_stmt|;
comment|/*      * In order to use LookupVar to find "other", temporarily replace      * the current frame pointer in the interpreter.      */
name|savedFramePtr
operator|=
name|iPtr
operator|->
name|varFramePtr
expr_stmt|;
name|iPtr
operator|->
name|varFramePtr
operator|=
name|framePtr
expr_stmt|;
name|otherPtr
operator|=
name|LookupVar
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
name|otherP1
argument_list|,
name|otherP2
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|,
literal|"access"
argument_list|,
name|CRT_PART1
operator||
name|CRT_PART2
argument_list|,
operator|&
name|arrayPtr
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|varFramePtr
operator|=
name|savedFramePtr
expr_stmt|;
if|if
condition|(
name|otherPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|TCL_GLOBAL_ONLY
operator|)
operator|||
operator|(
name|iPtr
operator|->
name|varFramePtr
operator|==
name|NULL
operator|)
condition|)
block|{
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|globalTable
argument_list|,
name|myName
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|varFramePtr
operator|->
name|varTable
argument_list|,
name|myName
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new
condition|)
block|{
name|varPtr
operator|=
name|NewVar
argument_list|()
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
name|varPtr
argument_list|)
expr_stmt|;
name|varPtr
operator|->
name|hPtr
operator|=
name|hPtr
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * The variable already exists.  Make sure that this variable 	 * isn't also "otherVar" (avoid circular links).  Also, if it's 	 * not an upvar then it's an error.  If it is an upvar, then 	 * just disconnect it from the thing it currently refers to. 	 */
name|varPtr
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|varPtr
operator|==
name|otherPtr
condition|)
block|{
name|iPtr
operator|->
name|result
operator|=
literal|"can't upvar from variable to itself"
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_UPVAR
condition|)
block|{
name|Var
modifier|*
name|upvarPtr
decl_stmt|;
name|upvarPtr
operator|=
name|varPtr
operator|->
name|value
operator|.
name|upvarPtr
expr_stmt|;
if|if
condition|(
name|upvarPtr
operator|==
name|otherPtr
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
name|upvarPtr
operator|->
name|refCount
operator|--
expr_stmt|;
if|if
condition|(
name|upvarPtr
operator|->
name|flags
operator|&
name|VAR_UNDEFINED
condition|)
block|{
name|CleanupVar
argument_list|(
name|upvarPtr
argument_list|,
operator|(
name|Var
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_UNDEFINED
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"variable \""
argument_list|,
name|myName
argument_list|,
literal|"\" already exists"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|varPtr
operator|->
name|tracePtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"variable \""
argument_list|,
name|myName
argument_list|,
literal|"\" has traces: can't use for upvar"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
name|varPtr
operator|->
name|flags
operator|=
operator|(
name|varPtr
operator|->
name|flags
operator|&
operator|~
name|VAR_UNDEFINED
operator|)
operator||
name|VAR_UPVAR
expr_stmt|;
name|varPtr
operator|->
name|value
operator|.
name|upvarPtr
operator|=
name|otherPtr
expr_stmt|;
name|otherPtr
operator|->
name|refCount
operator|++
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_UpVar --  *  *	Delete a variable, so that it may not be accessed anymore.  *  * Results:  *	Returns TCL_OK if the variable was successfully deleted, TCL_ERROR  *	if the variable can't be unset.  In the event of an error,  *	if the TCL_LEAVE_ERR_MSG flag is set then an error message  *	is left in interp->result.  *  * Side effects:  *	If varName is defined as a local or global variable in interp,  *	it is deleted.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_UpVar
parameter_list|(
name|interp
parameter_list|,
name|frameName
parameter_list|,
name|varName
parameter_list|,
name|localName
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Command interpreter in which varName is 				 * to be looked up. */
name|char
modifier|*
name|frameName
decl_stmt|;
comment|/* Name of the frame containing the source 				 * variable, such as "1" or "#0". */
name|char
modifier|*
name|varName
decl_stmt|;
comment|/* Name of a variable in interp.  May be 				 * either a scalar name or an element 				 * in an array. */
name|char
modifier|*
name|localName
decl_stmt|;
comment|/* Destination variable name. */
name|int
name|flags
decl_stmt|;
comment|/* Either 0 or TCL_GLOBAL_ONLY;  indicates 				 * whether localName is local or global. */
block|{
name|int
name|result
decl_stmt|;
name|CallFrame
modifier|*
name|framePtr
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|result
operator|=
name|TclGetFrame
argument_list|(
name|interp
argument_list|,
name|frameName
argument_list|,
operator|&
name|framePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Figure out whether this is an array reference, then call      * Tcl_UpVar2 to do all the real work.      */
for|for
control|(
name|p
operator|=
name|varName
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
block|{
name|char
modifier|*
name|openParen
init|=
name|p
decl_stmt|;
do|do
block|{
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
do|;
name|p
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|')'
condition|)
block|{
goto|goto
name|scalar
goto|;
block|}
operator|*
name|openParen
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|result
operator|=
name|MakeUpvar
argument_list|(
operator|(
name|Interp
operator|*
operator|)
name|interp
argument_list|,
name|framePtr
argument_list|,
name|varName
argument_list|,
name|openParen
operator|+
literal|1
argument_list|,
name|localName
argument_list|,
name|flags
argument_list|)
expr_stmt|;
operator|*
name|openParen
operator|=
literal|'('
expr_stmt|;
operator|*
name|p
operator|=
literal|')'
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
name|scalar
label|:
return|return
name|MakeUpvar
argument_list|(
operator|(
name|Interp
operator|*
operator|)
name|interp
argument_list|,
name|framePtr
argument_list|,
name|varName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|localName
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_UpVar2 --  *  *	This procedure links one variable to another, just like  *	the "upvar" command.  *  * Results:  *	A standard Tcl completion code.  If an error occurs then  *	an error message is left in interp->result.  *  * Side effects:  *	The variable in frameName whose name is given by part1 and  *	part2 becomes accessible under the name newName, so that  *	references to newName are redirected to the other variable  *	like a symbolic link.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_UpVar2
parameter_list|(
name|interp
parameter_list|,
name|frameName
parameter_list|,
name|part1
parameter_list|,
name|part2
parameter_list|,
name|localName
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter containing variables.  Used 				 * for error messages too. */
name|char
modifier|*
name|frameName
decl_stmt|;
comment|/* Name of the frame containing the source 				 * variable, such as "1" or "#0". */
name|char
modifier|*
name|part1
decl_stmt|,
decl|*
name|part2
decl_stmt|;
end_function

begin_comment
comment|/* Two parts of source variable name. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|localName
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Destination variable name. */
end_comment

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TCL_GLOBAL_ONLY or 0. */
end_comment

begin_block
block|{
name|int
name|result
decl_stmt|;
name|CallFrame
modifier|*
name|framePtr
decl_stmt|;
name|result
operator|=
name|TclGetFrame
argument_list|(
name|interp
argument_list|,
name|frameName
argument_list|,
operator|&
name|framePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|MakeUpvar
argument_list|(
operator|(
name|Interp
operator|*
operator|)
name|interp
argument_list|,
name|framePtr
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
name|localName
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GlobalCmd --  *  *	This procedure is invoked to process the "global" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result value.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_GlobalCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" varName ?varName ...?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|iPtr
operator|->
name|varFramePtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
for|for
control|(
name|argc
operator|--
operator|,
name|argv
operator|++
init|;
name|argc
operator|>
literal|0
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
if|if
condition|(
name|MakeUpvar
argument_list|(
name|iPtr
argument_list|,
operator|(
name|CallFrame
operator|*
operator|)
name|NULL
argument_list|,
operator|*
name|argv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|*
name|argv
argument_list|,
literal|0
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_UpvarCmd --  *  *	This procedure is invoked to process the "upvar" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result value.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_UpvarCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|int
name|result
decl_stmt|;
name|CallFrame
modifier|*
name|framePtr
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|upvarSyntax
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" ?level? otherVar localVar ?otherVar localVar ...?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Find the hash table containing the variable being referenced.      */
name|result
operator|=
name|TclGetFrame
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|framePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|argc
operator|-=
name|result
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|argc
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|upvarSyntax
goto|;
block|}
name|argv
operator|+=
name|result
operator|+
literal|1
expr_stmt|;
comment|/*      * Iterate over all the pairs of (other variable, local variable)      * names.  For each pair, divide the other variable name into two      * parts, then call MakeUpvar to do all the work of creating linking      * it to the local variable.      */
for|for
control|(
init|;
name|argc
operator|>
literal|0
condition|;
name|argc
operator|-=
literal|2
operator|,
name|argv
operator|+=
literal|2
control|)
block|{
for|for
control|(
name|p
operator|=
name|argv
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
block|{
name|char
modifier|*
name|openParen
init|=
name|p
decl_stmt|;
do|do
block|{
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
do|;
name|p
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|')'
condition|)
block|{
goto|goto
name|scalar
goto|;
block|}
operator|*
name|openParen
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|result
operator|=
name|MakeUpvar
argument_list|(
name|iPtr
argument_list|,
name|framePtr
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|openParen
operator|+
literal|1
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|openParen
operator|=
literal|'('
expr_stmt|;
operator|*
name|p
operator|=
literal|')'
expr_stmt|;
goto|goto
name|checkResult
goto|;
block|}
block|}
name|scalar
label|:
name|result
operator|=
name|MakeUpvar
argument_list|(
name|iPtr
argument_list|,
name|framePtr
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|checkResult
label|:
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CallTraces --  *  *	This procedure is invoked to find and invoke relevant  *	trace procedures associated with a particular operation on  *	a variable.  This procedure invokes traces both on the  *	variable and on its containing array (where relevant).  *  * Results:  *	The return value is NULL if no trace procedures were invoked, or  *	if all the invoked trace procedures returned successfully.  *	The return value is non-zero if a trace procedure returned an  *	error (in this case no more trace procedures were invoked after  *	the error was returned).  In this case the return value is a  *	pointer to a static string describing the error.  *  * Side effects:  *	Almost anything can happen, depending on trace;  this procedure  *	itself doesn't have any side effects.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|CallTraces
parameter_list|(
name|iPtr
parameter_list|,
name|arrayPtr
parameter_list|,
name|varPtr
parameter_list|,
name|part1
parameter_list|,
name|part2
parameter_list|,
name|flags
parameter_list|)
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Interpreter containing variable. */
specifier|register
name|Var
modifier|*
name|arrayPtr
decl_stmt|;
comment|/* Pointer to array variable that 					 * contains the variable, or NULL if 					 * the variable isn't an element of an 					 * array. */
name|Var
modifier|*
name|varPtr
decl_stmt|;
comment|/* Variable whose traces are to be 					 * invoked. */
name|char
modifier|*
name|part1
decl_stmt|,
decl|*
name|part2
decl_stmt|;
end_function

begin_comment
comment|/* Variable's two-part name. */
end_comment

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flags to pass to trace procedures: 					 * indicates what's happening to 					 * variable, plus other stuff like 					 * TCL_GLOBAL_ONLY and 					 * TCL_INTERP_DESTROYED.   May also 					 * contain PART1_NOT_PARSEd, which 					 * should not be passed through 					 * to callbacks. */
end_comment

begin_block
block|{
specifier|register
name|VarTrace
modifier|*
name|tracePtr
decl_stmt|;
name|ActiveVarTrace
name|active
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|,
modifier|*
name|openParen
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|Tcl_DString
name|nameCopy
decl_stmt|;
name|int
name|copiedName
decl_stmt|;
comment|/*      * If there are already similar trace procedures active for the      * variable, don't call them again.      */
if|if
condition|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_TRACE_ACTIVE
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|varPtr
operator|->
name|flags
operator||=
name|VAR_TRACE_ACTIVE
expr_stmt|;
name|varPtr
operator|->
name|refCount
operator|++
expr_stmt|;
comment|/*      * If the variable name hasn't been parsed into array name and      * element, do it here.  If there really is an array element,      * make a copy of the original name so that NULLs can be      * inserted into it to separate the names (can't modify the name      * string in place, because the string might get used by the      * callbacks we invoke).      */
name|copiedName
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PART1_NOT_PARSED
condition|)
block|{
for|for
control|(
name|p
operator|=
name|part1
init|;
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
block|{
name|openParen
operator|=
name|p
expr_stmt|;
do|do
block|{
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
do|;
name|p
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|')'
condition|)
block|{
name|Tcl_DStringInit
argument_list|(
operator|&
name|nameCopy
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|nameCopy
argument_list|,
name|part1
argument_list|,
operator|(
name|p
operator|-
name|part1
operator|)
argument_list|)
expr_stmt|;
name|part2
operator|=
name|Tcl_DStringValue
argument_list|(
operator|&
name|nameCopy
argument_list|)
operator|+
operator|(
name|openParen
operator|+
literal|1
operator|-
name|part1
operator|)
expr_stmt|;
name|part2
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|part1
operator|=
name|Tcl_DStringValue
argument_list|(
operator|&
name|nameCopy
argument_list|)
expr_stmt|;
name|copiedName
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
name|flags
operator|&=
operator|~
name|PART1_NOT_PARSED
expr_stmt|;
comment|/*      * Invoke traces on the array containing the variable, if relevant.      */
name|result
operator|=
name|NULL
expr_stmt|;
name|active
operator|.
name|nextPtr
operator|=
name|iPtr
operator|->
name|activeTracePtr
expr_stmt|;
name|iPtr
operator|->
name|activeTracePtr
operator|=
operator|&
name|active
expr_stmt|;
if|if
condition|(
name|arrayPtr
operator|!=
name|NULL
condition|)
block|{
name|arrayPtr
operator|->
name|refCount
operator|++
expr_stmt|;
name|active
operator|.
name|varPtr
operator|=
name|arrayPtr
expr_stmt|;
for|for
control|(
name|tracePtr
operator|=
name|arrayPtr
operator|->
name|tracePtr
init|;
name|tracePtr
operator|!=
name|NULL
condition|;
name|tracePtr
operator|=
name|active
operator|.
name|nextTracePtr
control|)
block|{
name|active
operator|.
name|nextTracePtr
operator|=
name|tracePtr
operator|->
name|nextPtr
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tracePtr
operator|->
name|flags
operator|&
name|flags
operator|)
condition|)
block|{
continue|continue;
block|}
name|result
operator|=
call|(
modifier|*
name|tracePtr
operator|->
name|traceProc
call|)
argument_list|(
name|tracePtr
operator|->
name|clientData
argument_list|,
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TCL_TRACE_UNSETS
condition|)
block|{
name|result
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|done
goto|;
block|}
block|}
block|}
block|}
comment|/*      * Invoke traces on the variable itself.      */
if|if
condition|(
name|flags
operator|&
name|TCL_TRACE_UNSETS
condition|)
block|{
name|flags
operator||=
name|TCL_TRACE_DESTROYED
expr_stmt|;
block|}
name|active
operator|.
name|varPtr
operator|=
name|varPtr
expr_stmt|;
for|for
control|(
name|tracePtr
operator|=
name|varPtr
operator|->
name|tracePtr
init|;
name|tracePtr
operator|!=
name|NULL
condition|;
name|tracePtr
operator|=
name|active
operator|.
name|nextTracePtr
control|)
block|{
name|active
operator|.
name|nextTracePtr
operator|=
name|tracePtr
operator|->
name|nextPtr
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tracePtr
operator|->
name|flags
operator|&
name|flags
operator|)
condition|)
block|{
continue|continue;
block|}
name|result
operator|=
call|(
modifier|*
name|tracePtr
operator|->
name|traceProc
call|)
argument_list|(
name|tracePtr
operator|->
name|clientData
argument_list|,
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TCL_TRACE_UNSETS
condition|)
block|{
name|result
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|done
goto|;
block|}
block|}
block|}
comment|/*      * Restore the variable's flags, remove the record of our active      * traces, and then return.      */
name|done
label|:
if|if
condition|(
name|arrayPtr
operator|!=
name|NULL
condition|)
block|{
name|arrayPtr
operator|->
name|refCount
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|copiedName
condition|)
block|{
name|Tcl_DStringFree
argument_list|(
operator|&
name|nameCopy
argument_list|)
expr_stmt|;
block|}
name|varPtr
operator|->
name|flags
operator|&=
operator|~
name|VAR_TRACE_ACTIVE
expr_stmt|;
name|varPtr
operator|->
name|refCount
operator|--
expr_stmt|;
name|iPtr
operator|->
name|activeTracePtr
operator|=
name|active
operator|.
name|nextPtr
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * NewVar --  *  *	Create a new variable with a given amount of storage  *	space.  *  * Results:  *	The return value is a pointer to the new variable structure.  *	The variable will not be part of any hash table yet.  Its  *	initial value is empty.  *  * Side effects:  *	Storage gets allocated.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Var
modifier|*
name|NewVar
parameter_list|()
block|{
specifier|register
name|Var
modifier|*
name|varPtr
decl_stmt|;
name|varPtr
operator|=
operator|(
name|Var
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Var
argument_list|)
argument_list|)
expr_stmt|;
name|varPtr
operator|->
name|valueLength
operator|=
literal|0
expr_stmt|;
name|varPtr
operator|->
name|valueSpace
operator|=
literal|0
expr_stmt|;
name|varPtr
operator|->
name|value
operator|.
name|string
operator|=
name|NULL
expr_stmt|;
name|varPtr
operator|->
name|hPtr
operator|=
name|NULL
expr_stmt|;
name|varPtr
operator|->
name|refCount
operator|=
literal|0
expr_stmt|;
name|varPtr
operator|->
name|tracePtr
operator|=
name|NULL
expr_stmt|;
name|varPtr
operator|->
name|searchPtr
operator|=
name|NULL
expr_stmt|;
name|varPtr
operator|->
name|flags
operator|=
name|VAR_UNDEFINED
expr_stmt|;
return|return
name|varPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * ParseSearchId --  *  *	This procedure translates from a string to a pointer to an  *	active array search (if there is one that matches the string).  *  * Results:  *	The return value is a pointer to the array search indicated  *	by string, or NULL if there isn't one.  If NULL is returned,  *	interp->result contains an error message.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|ArraySearch
modifier|*
name|ParseSearchId
parameter_list|(
name|interp
parameter_list|,
name|varPtr
parameter_list|,
name|varName
parameter_list|,
name|string
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter containing variable. */
name|Var
modifier|*
name|varPtr
decl_stmt|;
comment|/* Array variable search is for. */
name|char
modifier|*
name|varName
decl_stmt|;
comment|/* Name of array variable that search is 				 * supposed to be for. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String containing id of search.  Must have 				 * form "search-num-var" where "num" is a 				 * decimal number and "var" is a variable 				 * name. */
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|id
decl_stmt|;
name|ArraySearch
modifier|*
name|searchPtr
decl_stmt|;
comment|/*      * Parse the id into the three parts separated by dashes.      */
if|if
condition|(
operator|(
name|string
index|[
literal|0
index|]
operator|!=
literal|'s'
operator|)
operator|||
operator|(
name|string
index|[
literal|1
index|]
operator|!=
literal|'-'
operator|)
condition|)
block|{
name|syntax
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"illegal search identifier \""
argument_list|,
name|string
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|id
operator|=
name|strtoul
argument_list|(
name|string
operator|+
literal|2
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|end
operator|==
operator|(
name|string
operator|+
literal|2
operator|)
operator|)
operator|||
operator|(
operator|*
name|end
operator|!=
literal|'-'
operator|)
condition|)
block|{
goto|goto
name|syntax
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|end
operator|+
literal|1
argument_list|,
name|varName
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"search identifier \""
argument_list|,
name|string
argument_list|,
literal|"\" isn't for variable \""
argument_list|,
name|varName
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*      * Search through the list of active searches on the interpreter      * to see if the desired one exists.      */
for|for
control|(
name|searchPtr
operator|=
name|varPtr
operator|->
name|searchPtr
init|;
name|searchPtr
operator|!=
name|NULL
condition|;
name|searchPtr
operator|=
name|searchPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|searchPtr
operator|->
name|id
operator|==
name|id
condition|)
block|{
return|return
name|searchPtr
return|;
block|}
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't find search \""
argument_list|,
name|string
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DeleteSearches --  *  *	This procedure is called to free up all of the searches  *	associated with an array variable.  *  * Results:  *	None.  *  * Side effects:  *	Memory is released to the storage allocator.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|DeleteSearches
parameter_list|(
name|arrayVarPtr
parameter_list|)
specifier|register
name|Var
modifier|*
name|arrayVarPtr
decl_stmt|;
comment|/* Variable whose searches are 					 * to be deleted. */
block|{
name|ArraySearch
modifier|*
name|searchPtr
decl_stmt|;
while|while
condition|(
name|arrayVarPtr
operator|->
name|searchPtr
operator|!=
name|NULL
condition|)
block|{
name|searchPtr
operator|=
name|arrayVarPtr
operator|->
name|searchPtr
expr_stmt|;
name|arrayVarPtr
operator|->
name|searchPtr
operator|=
name|searchPtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|searchPtr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclDeleteVars --  *  *	This procedure is called to recycle all the storage space  *	associated with a table of variables.  For this procedure  *	to work correctly, it must not be possible for any of the  *	variable in the table to be accessed from Tcl commands  *	(e.g. from trace procedures).  *  * Results:  *	None.  *  * Side effects:  *	Variables are deleted and trace procedures are invoked, if  *	any are declared.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclDeleteVars
parameter_list|(
name|iPtr
parameter_list|,
name|tablePtr
parameter_list|)
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Interpreter to which variables belong. */
name|Tcl_HashTable
modifier|*
name|tablePtr
decl_stmt|;
comment|/* Hash table containing variables to 				 * delete. */
block|{
name|Tcl_HashSearch
name|search
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
specifier|register
name|Var
modifier|*
name|varPtr
decl_stmt|;
name|Var
modifier|*
name|upvarPtr
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|ActiveVarTrace
modifier|*
name|activePtr
decl_stmt|;
name|flags
operator|=
name|TCL_TRACE_UNSETS
expr_stmt|;
if|if
condition|(
name|tablePtr
operator|==
operator|&
name|iPtr
operator|->
name|globalTable
condition|)
block|{
name|flags
operator||=
name|TCL_INTERP_DESTROYED
operator||
name|TCL_GLOBAL_ONLY
expr_stmt|;
block|}
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|tablePtr
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
name|varPtr
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
comment|/* 	 * For global/upvar variables referenced in procedures, decrement 	 * the reference count on the variable referred to, and free 	 * the referenced variable if it's no longer needed.  Don't delete 	 * the hash entry for the other variable if it's in the same table 	 * as us:  this will happen automatically later on. 	 */
if|if
condition|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_UPVAR
condition|)
block|{
name|upvarPtr
operator|=
name|varPtr
operator|->
name|value
operator|.
name|upvarPtr
expr_stmt|;
name|upvarPtr
operator|->
name|refCount
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|upvarPtr
operator|->
name|refCount
operator|==
literal|0
operator|)
operator|&&
operator|(
name|upvarPtr
operator|->
name|flags
operator|&
name|VAR_UNDEFINED
operator|)
operator|&&
operator|(
name|upvarPtr
operator|->
name|tracePtr
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|upvarPtr
operator|->
name|hPtr
operator|==
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|upvarPtr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|upvarPtr
operator|->
name|hPtr
operator|->
name|tablePtr
operator|!=
name|tablePtr
condition|)
block|{
name|Tcl_DeleteHashEntry
argument_list|(
name|upvarPtr
operator|->
name|hPtr
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|upvarPtr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Invoke traces on the variable that is being deleted, then 	 * free up the variable's space (no need to free the hash entry 	 * here, unless we're dealing with a global variable:  the 	 * hash entries will be deleted automatically when the whole 	 * table is deleted). 	 */
if|if
condition|(
name|varPtr
operator|->
name|tracePtr
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|CallTraces
argument_list|(
name|iPtr
argument_list|,
operator|(
name|Var
operator|*
operator|)
name|NULL
argument_list|,
name|varPtr
argument_list|,
name|Tcl_GetHashKey
argument_list|(
name|tablePtr
argument_list|,
name|hPtr
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
while|while
condition|(
name|varPtr
operator|->
name|tracePtr
operator|!=
name|NULL
condition|)
block|{
name|VarTrace
modifier|*
name|tracePtr
init|=
name|varPtr
operator|->
name|tracePtr
decl_stmt|;
name|varPtr
operator|->
name|tracePtr
operator|=
name|tracePtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tracePtr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|activePtr
operator|=
name|iPtr
operator|->
name|activeTracePtr
init|;
name|activePtr
operator|!=
name|NULL
condition|;
name|activePtr
operator|=
name|activePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|activePtr
operator|->
name|varPtr
operator|==
name|varPtr
condition|)
block|{
name|activePtr
operator|->
name|nextTracePtr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_ARRAY
condition|)
block|{
name|DeleteArray
argument_list|(
name|iPtr
argument_list|,
name|Tcl_GetHashKey
argument_list|(
name|tablePtr
argument_list|,
name|hPtr
argument_list|)
argument_list|,
name|varPtr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|varPtr
operator|->
name|valueSpace
operator|>
literal|0
condition|)
block|{
comment|/* 	     * SPECIAL TRICK:  it's possible that the interpreter's result 	     * currently points to this variable (for example, a "set" or 	     * "lappend" command was the last command in a procedure that's 	     * being returned from).  If this is the case, then just pass 	     * ownership of the value string to the Tcl interpreter. 	     */
if|if
condition|(
name|iPtr
operator|->
name|result
operator|==
name|varPtr
operator|->
name|value
operator|.
name|string
condition|)
block|{
name|iPtr
operator|->
name|freeProc
operator|=
name|TCL_DYNAMIC
expr_stmt|;
block|}
else|else
block|{
name|ckfree
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
name|varPtr
operator|->
name|valueSpace
operator|=
literal|0
expr_stmt|;
block|}
name|varPtr
operator|->
name|hPtr
operator|=
name|NULL
expr_stmt|;
name|varPtr
operator|->
name|tracePtr
operator|=
name|NULL
expr_stmt|;
name|varPtr
operator|->
name|flags
operator|=
name|VAR_UNDEFINED
expr_stmt|;
comment|/* 	 * Recycle the variable's memory space if there aren't any upvar's 	 * pointing to it.  If there are upvars, then the variable will 	 * get freed when the last upvar goes away. 	 */
if|if
condition|(
name|varPtr
operator|->
name|refCount
operator|==
literal|0
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|varPtr
argument_list|)
expr_stmt|;
block|}
block|}
name|Tcl_DeleteHashTable
argument_list|(
name|tablePtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DeleteArray --  *  *	This procedure is called to free up everything in an array  *	variable.  It's the caller's responsibility to make sure  *	that the array is no longer accessible before this procedure  *	is called.  *  * Results:  *	None.  *  * Side effects:  *	All storage associated with varPtr's array elements is deleted  *	(including the hash table).  Delete trace procedures for  *	array elements are invoked.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|DeleteArray
parameter_list|(
name|iPtr
parameter_list|,
name|arrayName
parameter_list|,
name|varPtr
parameter_list|,
name|flags
parameter_list|)
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Interpreter containing array. */
name|char
modifier|*
name|arrayName
decl_stmt|;
comment|/* Name of array (used for trace 					 * callbacks). */
name|Var
modifier|*
name|varPtr
decl_stmt|;
comment|/* Pointer to variable structure. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to pass to CallTraces: 					 * TCL_TRACE_UNSETS and sometimes 					 * TCL_INTERP_DESTROYED and/or 					 * TCL_GLOBAL_ONLY. */
block|{
name|Tcl_HashSearch
name|search
decl_stmt|;
specifier|register
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
specifier|register
name|Var
modifier|*
name|elPtr
decl_stmt|;
name|ActiveVarTrace
modifier|*
name|activePtr
decl_stmt|;
name|DeleteSearches
argument_list|(
name|varPtr
argument_list|)
expr_stmt|;
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
name|elPtr
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|elPtr
operator|->
name|valueSpace
operator|!=
literal|0
condition|)
block|{
comment|/* 	     * SPECIAL TRICK:  it's possible that the interpreter's result 	     * currently points to this element (for example, a "set" or 	     * "lappend" command was the last command in a procedure that's 	     * being returned from).  If this is the case, then just pass 	     * ownership of the value string to the Tcl interpreter. 	     */
if|if
condition|(
name|iPtr
operator|->
name|result
operator|==
name|elPtr
operator|->
name|value
operator|.
name|string
condition|)
block|{
name|iPtr
operator|->
name|freeProc
operator|=
name|TCL_DYNAMIC
expr_stmt|;
block|}
else|else
block|{
name|ckfree
argument_list|(
name|elPtr
operator|->
name|value
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
name|elPtr
operator|->
name|valueSpace
operator|=
literal|0
expr_stmt|;
block|}
name|elPtr
operator|->
name|hPtr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|elPtr
operator|->
name|tracePtr
operator|!=
name|NULL
condition|)
block|{
name|elPtr
operator|->
name|flags
operator|&=
operator|~
name|VAR_TRACE_ACTIVE
expr_stmt|;
operator|(
name|void
operator|)
name|CallTraces
argument_list|(
name|iPtr
argument_list|,
operator|(
name|Var
operator|*
operator|)
name|NULL
argument_list|,
name|elPtr
argument_list|,
name|arrayName
argument_list|,
name|Tcl_GetHashKey
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|,
name|hPtr
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
while|while
condition|(
name|elPtr
operator|->
name|tracePtr
operator|!=
name|NULL
condition|)
block|{
name|VarTrace
modifier|*
name|tracePtr
init|=
name|elPtr
operator|->
name|tracePtr
decl_stmt|;
name|elPtr
operator|->
name|tracePtr
operator|=
name|tracePtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tracePtr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|activePtr
operator|=
name|iPtr
operator|->
name|activeTracePtr
init|;
name|activePtr
operator|!=
name|NULL
condition|;
name|activePtr
operator|=
name|activePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|activePtr
operator|->
name|varPtr
operator|==
name|elPtr
condition|)
block|{
name|activePtr
operator|->
name|nextTracePtr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|elPtr
operator|->
name|flags
operator|=
name|VAR_UNDEFINED
expr_stmt|;
if|if
condition|(
name|elPtr
operator|->
name|refCount
operator|==
literal|0
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|elPtr
argument_list|)
expr_stmt|;
block|}
block|}
name|Tcl_DeleteHashTable
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CleanupVar --  *  *	This procedure is called when it looks like it may be OK  *	to free up the variable's record and hash table entry, and  *	those of its containing parent.  It's called, for example,  *	when a trace on a variable deletes the variable.  *  * Results:  *	None.  *  * Side effects:  *	If the variable (or its containing array) really is dead then  *	its record, and possibly its hash table entry, gets freed up.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|CleanupVar
parameter_list|(
name|varPtr
parameter_list|,
name|arrayPtr
parameter_list|)
name|Var
modifier|*
name|varPtr
decl_stmt|;
comment|/* Pointer to variable that may be a 				 * candidate for being expunged. */
name|Var
modifier|*
name|arrayPtr
decl_stmt|;
comment|/* Array that contains the variable, or 				 * NULL if this variable isn't an array 				 * element. */
block|{
if|if
condition|(
operator|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_UNDEFINED
operator|)
operator|&&
operator|(
name|varPtr
operator|->
name|refCount
operator|==
literal|0
operator|)
operator|&&
operator|(
name|varPtr
operator|->
name|tracePtr
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|varPtr
operator|->
name|hPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DeleteHashEntry
argument_list|(
name|varPtr
operator|->
name|hPtr
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|varPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arrayPtr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|arrayPtr
operator|->
name|flags
operator|&
name|VAR_UNDEFINED
operator|)
operator|&&
operator|(
name|arrayPtr
operator|->
name|refCount
operator|==
literal|0
operator|)
operator|&&
operator|(
name|arrayPtr
operator|->
name|tracePtr
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|arrayPtr
operator|->
name|hPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DeleteHashEntry
argument_list|(
name|arrayPtr
operator|->
name|hPtr
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arrayPtr
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * VarErrMsg --  *  *	Generate a reasonable error message describing why a variable  *	operation failed.  *  * Results:  *	None.  *  * Side effects:  *	Interp->result is reset to hold a message identifying the  *	variable given by part1 and part2 and describing why the  *	variable operation failed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|VarErrMsg
parameter_list|(
name|interp
parameter_list|,
name|part1
parameter_list|,
name|part2
parameter_list|,
name|operation
parameter_list|,
name|reason
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to record message. */
name|char
modifier|*
name|part1
decl_stmt|,
decl|*
name|part2
decl_stmt|;
end_function

begin_comment
comment|/* Variable's two-part name. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|operation
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String describing operation that failed, 				 * e.g. "read", "set", or "unset". */
end_comment

begin_decl_stmt
name|char
modifier|*
name|reason
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String describing why operation failed. */
end_comment

begin_block
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"can't "
argument_list|,
name|operation
argument_list|,
literal|" \""
argument_list|,
name|part1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|part2
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"("
argument_list|,
name|part2
argument_list|,
literal|")"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"\": "
argument_list|,
name|reason
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

