begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclVar.c --  *  *	This file contains routines that implement Tcl variables  *	(both scalars and arrays).  *  *	The implementation of arrays is modelled after an initial  *	implementation by Mark Diekhans and Karl Lehenbauer.  *  * Copyright (c) 1987-1994 The Regents of the University of California.  * Copyright (c) 1994-1997 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclVar.c 1.125 97/08/06 14:47:55  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * The strings below are used to indicate what went wrong when a  * variable access is denied.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|noSuchVar
init|=
literal|"no such variable"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|isArray
init|=
literal|"variable is array"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|needArray
init|=
literal|"variable isn't array"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|noSuchElement
init|=
literal|"no such element in array"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|danglingUpvar
init|=
literal|"upvar refers to element in deleted array"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|badNamespace
init|=
literal|"parent namespace doesn't exist"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|missingName
init|=
literal|"missing variable name"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Forward references to procedures defined later in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|CallTraces
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Interp
operator|*
name|iPtr
operator|,
name|Var
operator|*
name|arrayPtr
operator|,
name|Var
operator|*
name|varPtr
operator|,
name|char
operator|*
name|part1
operator|,
name|char
operator|*
name|part2
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|CleanupVar
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Var
operator|*
name|varPtr
operator|,
name|Var
operator|*
name|arrayPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DeleteSearches
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Var
operator|*
name|arrayVarPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DeleteArray
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Interp
operator|*
name|iPtr
operator|,
name|char
operator|*
name|arrayName
operator|,
name|Var
operator|*
name|varPtr
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|MakeUpvar
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Interp
operator|*
name|iPtr
operator|,
name|CallFrame
operator|*
name|framePtr
operator|,
name|char
operator|*
name|otherP1
operator|,
name|char
operator|*
name|otherP2
operator|,
name|int
name|otherFlags
operator|,
name|char
operator|*
name|myName
operator|,
name|int
name|myFlags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Var
modifier|*
name|NewVar
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ArraySearch
modifier|*
name|ParseSearchId
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Var
operator|*
name|varPtr
operator|,
name|char
operator|*
name|varName
operator|,
name|char
operator|*
name|string
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|VarErrMsg
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|part1
operator|,
name|char
operator|*
name|part2
operator|,
name|char
operator|*
name|operation
operator|,
name|char
operator|*
name|reason
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclLookupVar --  *  *	This procedure is used by virtually all of the variable code to  *	locate a variable given its name(s).  *  * Results:  *	The return value is a pointer to the variable structure indicated by  *	part1 and part2, or NULL if the variable couldn't be found. If the  *	variable is found, *arrayPtrPtr is filled in with the address of the  *	variable structure for the array that contains the variable (or NULL  *	if the variable is a scalar). If the variable can't be found and  *	either createPart1 or createPart2 are 1, a new as-yet-undefined  *	(VAR_UNDEFINED) variable structure is created, entered into a hash  *	table, and returned.  *  *	If the variable isn't found and creation wasn't specified, or some  *	other error occurs, NULL is returned and an error message is left in  *	interp->result if TCL_LEAVE_ERR_MSG is set in flags. (The result  *	isn't put in interp->objResultPtr because this procedure is used  *	by so many string-based routines.)  *  *	Note: it's possible for the variable returned to be VAR_UNDEFINED  *	even if createPart1 or createPart2 are 1 (these only cause the hash  *	table entry or array to be created). For example, the variable might  *	be a global that has been unset but is still referenced by a  *	procedure, or a variable that has been unset but it only being kept  *	in existence (if VAR_UNDEFINED) by a trace.  *  * Side effects:  *	New hashtable entries may be created if createPart1 or createPart2  *	are 1.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Var
modifier|*
name|TclLookupVar
parameter_list|(
name|interp
parameter_list|,
name|part1
parameter_list|,
name|part2
parameter_list|,
name|flags
parameter_list|,
name|msg
parameter_list|,
name|createPart1
parameter_list|,
name|createPart2
parameter_list|,
name|arrayPtrPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for lookup. */
name|char
modifier|*
name|part1
decl_stmt|;
comment|/* If part2 isn't NULL, this is the name of 				 * an array. Otherwise, if the 				 * TCL_PARSE_PART1 flag bit is set this 				 * is a full variable name that could 				 * include a parenthesized array elemnt. If 				 * TCL_PARSE_PART1 isn't present, then 				 * this is the name of a scalar variable. */
name|char
modifier|*
name|part2
decl_stmt|;
comment|/* Name of element within array, or NULL. */
name|int
name|flags
decl_stmt|;
comment|/* Only TCL_GLOBAL_ONLY, TCL_NAMESPACE_ONLY, 				 * TCL_LEAVE_ERR_MSG, and 				 * TCL_PARSE_PART1 bits matter. */
name|char
modifier|*
name|msg
decl_stmt|;
comment|/* Verb to use in error messages, e.g. 				 * "read" or "set". Only needed if 				 * TCL_LEAVE_ERR_MSG is set in flags. */
name|int
name|createPart1
decl_stmt|;
comment|/* If 1, create hash table entry for part 1 				 * of name, if it doesn't already exist. If 				 * 0, return error if it doesn't exist. */
name|int
name|createPart2
decl_stmt|;
comment|/* If 1, create hash table entry for part 2 				 * of name, if it doesn't already exist. If 				 * 0, return error if it doesn't exist. */
name|Var
modifier|*
modifier|*
name|arrayPtrPtr
decl_stmt|;
comment|/* If the name refers to an element of an 				 * array, *arrayPtrPtr gets filled in with 				 * address of array variable. Otherwise 				 * this is set to NULL. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|CallFrame
modifier|*
name|varFramePtr
init|=
name|iPtr
operator|->
name|varFramePtr
decl_stmt|;
comment|/* Points to the procedure call frame whose 				 * variables are currently in use. Same as 				 * the current procedure's frame, if any, 				 * unless an "uplevel" is executing. */
name|Tcl_HashTable
modifier|*
name|tablePtr
decl_stmt|;
comment|/* Points to the hashtable, if any, in which 				 * to look up the variable. */
name|Tcl_Var
name|var
decl_stmt|;
comment|/* Used to search for global names. */
name|Var
modifier|*
name|varPtr
decl_stmt|;
comment|/* Points to the Var structure returned for     				 * the variable. */
name|char
modifier|*
name|elName
decl_stmt|;
comment|/* Name of array element or NULL; may be 				 * same as part2, or may be openParen+1. */
name|char
modifier|*
name|openParen
decl_stmt|,
modifier|*
name|closeParen
decl_stmt|;
comment|/* If this procedure parses a name into 				 * array and index, these point to the 				 * parens around the index.  Otherwise they 				 * are NULL. These are needed to restore 				 * the parens after parsing the name. */
name|Namespace
modifier|*
name|varNsPtr
decl_stmt|,
modifier|*
name|dummy1Ptr
decl_stmt|,
modifier|*
name|dummy2Ptr
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|new
decl_stmt|,
name|i
decl_stmt|,
name|result
decl_stmt|;
name|varPtr
operator|=
name|NULL
expr_stmt|;
operator|*
name|arrayPtrPtr
operator|=
name|NULL
expr_stmt|;
name|openParen
operator|=
name|closeParen
operator|=
name|NULL
expr_stmt|;
name|varNsPtr
operator|=
name|NULL
expr_stmt|;
comment|/* set non-NULL if a nonlocal variable */
comment|/*      * If the name hasn't been parsed into array name and index yet,      * do it now.      */
name|elName
operator|=
name|part2
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TCL_PARSE_PART1
condition|)
block|{
for|for
control|(
name|p
operator|=
name|part1
init|;
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
name|elName
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
block|{
name|openParen
operator|=
name|p
expr_stmt|;
do|do
block|{
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
do|;
name|p
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|')'
condition|)
block|{
name|closeParen
operator|=
name|p
expr_stmt|;
operator|*
name|openParen
operator|=
literal|0
expr_stmt|;
name|elName
operator|=
name|openParen
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|openParen
operator|=
name|NULL
expr_stmt|;
name|elName
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
comment|/*      * Look up part1. Look it up as either a namespace variable or as a      * local variable in a procedure call frame (varFramePtr).      * Interpret part1 as a namespace variable if:      *    1) so requested by a TCL_GLOBAL_ONLY or TCL_NAMESPACE_ONLY flag,      *    2) there is no active frame (we're at the global :: scope),      *    3) the active frame was pushed to define the namespace context      *       for a "namespace eval" or "namespace inscope" command,      *    4) the name has namespace qualifiers ("::"s).      * Otherwise, if part1 is a local variable, search first in the      * frame's array of compiler-allocated local variables, then in its      * hashtable for runtime-created local variables.      *      * If createPart1 and the variable isn't found, create the variable and,      * if necessary, create varFramePtr's local var hashtable.      */
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
operator|(
name|TCL_GLOBAL_ONLY
operator||
name|TCL_NAMESPACE_ONLY
operator|)
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|varFramePtr
operator|==
name|NULL
operator|)
operator|||
operator|!
name|varFramePtr
operator|->
name|isProcCallFrame
operator|||
operator|(
name|strstr
argument_list|(
name|part1
argument_list|,
literal|"::"
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|char
modifier|*
name|tail
decl_stmt|;
name|var
operator|=
name|Tcl_FindNamespaceVar
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|NULL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
operator|!=
operator|(
name|Tcl_Var
operator|)
name|NULL
condition|)
block|{
name|varPtr
operator|=
operator|(
name|Var
operator|*
operator|)
name|var
expr_stmt|;
block|}
if|if
condition|(
name|varPtr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TCL_LEAVE_ERR_MSG
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|createPart1
condition|)
block|{
comment|/* var wasn't found so create it  */
name|result
operator|=
name|TclGetNamespaceForQualName
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
operator|(
name|Namespace
operator|*
operator|)
name|NULL
argument_list|,
name|flags
argument_list|,
operator|&
name|varNsPtr
argument_list|,
operator|&
name|dummy1Ptr
argument_list|,
operator|&
name|dummy2Ptr
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TCL_LEAVE_ERR_MSG
condition|)
block|{
comment|/* 			 * Move the interpreter's object result to the 			 * string result, then reset the object result. 			 * FAILS IF OBJECT RESULT'S STRING REP HAS NULLS. 			 */
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|TclGetStringFromObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|varNsPtr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TCL_LEAVE_ERR_MSG
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
name|msg
argument_list|,
name|badNamespace
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TCL_LEAVE_ERR_MSG
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
name|msg
argument_list|,
name|missingName
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
name|varNsPtr
operator|->
name|varTable
argument_list|,
name|tail
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
name|varPtr
operator|=
name|NewVar
argument_list|()
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
name|varPtr
argument_list|)
expr_stmt|;
name|varPtr
operator|->
name|hPtr
operator|=
name|hPtr
expr_stmt|;
name|varPtr
operator|->
name|nsPtr
operator|=
name|varNsPtr
expr_stmt|;
block|}
else|else
block|{
comment|/* var wasn't found and not to create it */
if|if
condition|(
name|flags
operator|&
name|TCL_LEAVE_ERR_MSG
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
name|msg
argument_list|,
name|noSuchVar
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
block|}
block|}
else|else
block|{
comment|/* local var: look in frame varFramePtr */
name|Proc
modifier|*
name|procPtr
init|=
name|varFramePtr
operator|->
name|procPtr
decl_stmt|;
name|int
name|localCt
init|=
name|procPtr
operator|->
name|numCompiledLocals
decl_stmt|;
name|CompiledLocal
modifier|*
name|localPtr
init|=
name|procPtr
operator|->
name|firstLocalPtr
decl_stmt|;
name|Var
modifier|*
name|localVarPtr
init|=
name|varFramePtr
operator|->
name|compiledLocals
decl_stmt|;
name|int
name|part1Len
init|=
name|strlen
argument_list|(
name|part1
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|localCt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|localPtr
operator|->
name|isTemp
condition|)
block|{
name|char
modifier|*
name|localName
init|=
name|localVarPtr
operator|->
name|name
decl_stmt|;
if|if
condition|(
operator|(
name|part1
index|[
literal|0
index|]
operator|==
name|localName
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
name|part1Len
operator|==
name|localPtr
operator|->
name|nameLength
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|part1
argument_list|,
name|localName
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|varPtr
operator|=
name|localVarPtr
expr_stmt|;
break|break;
block|}
block|}
name|localVarPtr
operator|++
expr_stmt|;
name|localPtr
operator|=
name|localPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
if|if
condition|(
name|varPtr
operator|==
name|NULL
condition|)
block|{
comment|/* look in the frame's var hash table */
name|tablePtr
operator|=
name|varFramePtr
operator|->
name|varTablePtr
expr_stmt|;
if|if
condition|(
name|createPart1
condition|)
block|{
if|if
condition|(
name|tablePtr
operator|==
name|NULL
condition|)
block|{
name|tablePtr
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Tcl_HashTable
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
name|tablePtr
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
name|varFramePtr
operator|->
name|varTablePtr
operator|=
name|tablePtr
expr_stmt|;
block|}
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
name|tablePtr
argument_list|,
name|part1
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
name|varPtr
operator|=
name|NewVar
argument_list|()
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
name|varPtr
argument_list|)
expr_stmt|;
name|varPtr
operator|->
name|hPtr
operator|=
name|hPtr
expr_stmt|;
name|varPtr
operator|->
name|nsPtr
operator|=
name|NULL
expr_stmt|;
comment|/* a local variable */
block|}
else|else
block|{
name|varPtr
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|hPtr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tablePtr
operator|!=
name|NULL
condition|)
block|{
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
name|tablePtr
argument_list|,
name|part1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hPtr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TCL_LEAVE_ERR_MSG
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
name|msg
argument_list|,
name|noSuchVar
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
name|varPtr
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|openParen
operator|!=
name|NULL
condition|)
block|{
operator|*
name|openParen
operator|=
literal|'('
expr_stmt|;
name|openParen
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*      * If varPtr is a link variable, we have a reference to some variable      * that was created through an "upvar" or "global" command. Traverse      * through any links until we find the referenced variable.      */
while|while
condition|(
name|TclIsVarLink
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
name|varPtr
operator|=
name|varPtr
operator|->
name|value
operator|.
name|linkPtr
expr_stmt|;
block|}
comment|/*      * If we're not dealing with an array element, return varPtr.      */
if|if
condition|(
name|elName
operator|==
name|NULL
condition|)
block|{
goto|goto
name|done
goto|;
block|}
comment|/*      * We're dealing with an array element. Make sure the variable is an      * array and look up the element (create the element if desired).      */
if|if
condition|(
name|TclIsVarUndefined
argument_list|(
name|varPtr
argument_list|)
operator|&&
operator|!
name|TclIsVarArrayElement
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|createPart1
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TCL_LEAVE_ERR_MSG
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
name|msg
argument_list|,
name|noSuchVar
argument_list|)
expr_stmt|;
block|}
name|varPtr
operator|=
name|NULL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|TclSetVarArray
argument_list|(
name|varPtr
argument_list|)
expr_stmt|;
name|TclClearVarUndefined
argument_list|(
name|varPtr
argument_list|)
expr_stmt|;
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Tcl_HashTable
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TclIsVarArray
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TCL_LEAVE_ERR_MSG
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
name|msg
argument_list|,
name|needArray
argument_list|)
expr_stmt|;
block|}
name|varPtr
operator|=
name|NULL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
operator|*
name|arrayPtrPtr
operator|=
name|varPtr
expr_stmt|;
if|if
condition|(
name|closeParen
operator|!=
name|NULL
condition|)
block|{
operator|*
name|closeParen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|createPart2
condition|)
block|{
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|,
name|elName
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|closeParen
operator|!=
name|NULL
condition|)
block|{
operator|*
name|closeParen
operator|=
literal|')'
expr_stmt|;
block|}
if|if
condition|(
name|new
condition|)
block|{
if|if
condition|(
name|varPtr
operator|->
name|searchPtr
operator|!=
name|NULL
condition|)
block|{
name|DeleteSearches
argument_list|(
name|varPtr
argument_list|)
expr_stmt|;
block|}
name|varPtr
operator|=
name|NewVar
argument_list|()
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
name|varPtr
argument_list|)
expr_stmt|;
name|varPtr
operator|->
name|hPtr
operator|=
name|hPtr
expr_stmt|;
name|varPtr
operator|->
name|nsPtr
operator|=
name|varNsPtr
expr_stmt|;
name|TclSetVarArrayElement
argument_list|(
name|varPtr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|,
name|elName
argument_list|)
expr_stmt|;
if|if
condition|(
name|closeParen
operator|!=
name|NULL
condition|)
block|{
operator|*
name|closeParen
operator|=
literal|')'
expr_stmt|;
block|}
if|if
condition|(
name|hPtr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TCL_LEAVE_ERR_MSG
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
name|msg
argument_list|,
name|noSuchElement
argument_list|)
expr_stmt|;
block|}
name|varPtr
operator|=
name|NULL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|varPtr
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|openParen
operator|!=
name|NULL
condition|)
block|{
operator|*
name|openParen
operator|=
literal|'('
expr_stmt|;
block|}
return|return
name|varPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetVar --  *  *	Return the value of a Tcl variable as a string.  *  * Results:  *	The return value points to the current value of varName as a string.  *	If the variable is not defined or can't be read because of a clash  *	in array usage then a NULL pointer is returned and an error message  *	is left in interp->result if the TCL_LEAVE_ERR_MSG flag is set.  *	Note: the return value is only valid up until the next change to the  *	variable; if you depend on the value lasting longer than that, then  *	make yourself a private copy.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_GetVar
parameter_list|(
name|interp
parameter_list|,
name|varName
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Command interpreter in which varName is 				 * to be looked up. */
name|char
modifier|*
name|varName
decl_stmt|;
comment|/* Name of a variable in interp. */
name|int
name|flags
decl_stmt|;
comment|/* OR-ed combination of TCL_GLOBAL_ONLY, 				 * TCL_NAMESPACE_ONLY or TCL_LEAVE_ERR_MSG 				 * bits. */
block|{
return|return
name|Tcl_GetVar2
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|flags
operator||
name|TCL_PARSE_PART1
operator|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetVar2 --  *  *	Return the value of a Tcl variable as a string, given a two-part  *	name consisting of array name and element within array.  *  * Results:  *	The return value points to the current value of the variable given  *	by part1 and part2 as a string. If the specified variable doesn't  *	exist, or if there is a clash in array usage, then NULL is returned  *	and a message will be left in interp->result if the  *	TCL_LEAVE_ERR_MSG flag is set. Note: the return value is only valid  *	up until the next change to the variable; if you depend on the value  *	lasting longer than that, then make yourself a private copy.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_GetVar2
parameter_list|(
name|interp
parameter_list|,
name|part1
parameter_list|,
name|part2
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Command interpreter in which variable is 				 * to be looked up. */
name|char
modifier|*
name|part1
decl_stmt|;
comment|/* Name of an array (if part2 is non-NULL) 				 * or the name of a variable. */
name|char
modifier|*
name|part2
decl_stmt|;
comment|/* If non-NULL, gives the name of an element 				 * in the array part1. */
name|int
name|flags
decl_stmt|;
comment|/* OR-ed combination of TCL_GLOBAL_ONLY, 				 * TCL_NAMESPACE_ONLY, TCL_LEAVE_ERR_MSG,                                  * and TCL_PARSE_PART1 bits. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|part1Ptr
decl_stmt|;
specifier|register
name|Tcl_Obj
modifier|*
name|part2Ptr
init|=
name|NULL
decl_stmt|;
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|int
name|length
decl_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|part1
argument_list|)
expr_stmt|;
name|TclNewObj
argument_list|(
name|part1Ptr
argument_list|)
expr_stmt|;
name|TclInitStringRep
argument_list|(
name|part1Ptr
argument_list|,
name|part1
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|part1Ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|part2
operator|!=
name|NULL
condition|)
block|{
name|length
operator|=
name|strlen
argument_list|(
name|part2
argument_list|)
expr_stmt|;
name|TclNewObj
argument_list|(
name|part2Ptr
argument_list|)
expr_stmt|;
name|TclInitStringRep
argument_list|(
name|part2Ptr
argument_list|,
name|part2
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|part2Ptr
argument_list|)
expr_stmt|;
block|}
name|objPtr
operator|=
name|Tcl_ObjGetVar2
argument_list|(
name|interp
argument_list|,
name|part1Ptr
argument_list|,
name|part2Ptr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|part1Ptr
argument_list|)
expr_stmt|;
comment|/* done with the part1 name object */
if|if
condition|(
name|part2Ptr
operator|!=
name|NULL
condition|)
block|{
name|TclDecrRefCount
argument_list|(
name|part2Ptr
argument_list|)
expr_stmt|;
comment|/* and the part2 name object */
block|}
if|if
condition|(
name|objPtr
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * Move the interpreter's object result to the string result,  	 * then reset the object result. 	 * FAILS IF OBJECT RESULT'S STRING REPRESENTATION CONTAINS NULLS. 	 */
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|TclGetStringFromObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*      * THIS FAILS IF Tcl_ObjGetVar2's RESULT'S STRING REP HAS A NULL BYTE.      */
return|return
name|TclGetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ObjGetVar2 --  *  *	Return the value of a Tcl variable as a Tcl object, given a  *	two-part name consisting of array name and element within array.  *  * Results:  *	The return value points to the current object value of the variable  *	given by part1Ptr and part2Ptr. If the specified variable doesn't  *	exist, or if there is a clash in array usage, then NULL is returned  *	and a message will be left in the interpreter's result if the  *	TCL_LEAVE_ERR_MSG flag is set.  *  * Side effects:  *	The ref count for the returned object is _not_ incremented to  *	reflect the returned reference; if you want to keep a reference to  *	the object you must increment its ref count yourself.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_ObjGetVar2
parameter_list|(
name|interp
parameter_list|,
name|part1Ptr
parameter_list|,
name|part2Ptr
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Command interpreter in which variable is 				 * to be looked up. */
specifier|register
name|Tcl_Obj
modifier|*
name|part1Ptr
decl_stmt|;
comment|/* Points to an object holding the name of 				 * an array (if part2 is non-NULL) or the 				 * name of a variable. */
specifier|register
name|Tcl_Obj
modifier|*
name|part2Ptr
decl_stmt|;
comment|/* If non-null, points to an object holding 				 * the name of an element in the array 				 * part1Ptr. */
name|int
name|flags
decl_stmt|;
comment|/* OR-ed combination of TCL_GLOBAL_ONLY, 				 * TCL_LEAVE_ERR_MSG, and 				 * TCL_PARSE_PART1 bits. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
specifier|register
name|Var
modifier|*
name|varPtr
decl_stmt|;
name|Var
modifier|*
name|arrayPtr
decl_stmt|;
name|char
modifier|*
name|part1
decl_stmt|,
modifier|*
name|msg
decl_stmt|;
name|char
modifier|*
name|part2
init|=
name|NULL
decl_stmt|;
comment|/*      * THIS FAILS IF A NAME OBJECT'S STRING REP HAS A NULL BYTE.      */
name|part1
operator|=
name|TclGetStringFromObj
argument_list|(
name|part1Ptr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|part2Ptr
operator|!=
name|NULL
condition|)
block|{
name|part2
operator|=
name|TclGetStringFromObj
argument_list|(
name|part2Ptr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|varPtr
operator|=
name|TclLookupVar
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
name|flags
argument_list|,
literal|"read"
argument_list|,
comment|/*createPart1*/
literal|0
argument_list|,
comment|/*createPart2*/
literal|1
argument_list|,
operator|&
name|arrayPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|varPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|/*      * Invoke any traces that have been set for the variable.      */
if|if
condition|(
operator|(
name|varPtr
operator|->
name|tracePtr
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
name|arrayPtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|arrayPtr
operator|->
name|tracePtr
operator|!=
name|NULL
operator|)
operator|)
condition|)
block|{
name|msg
operator|=
name|CallTraces
argument_list|(
name|iPtr
argument_list|,
name|arrayPtr
argument_list|,
name|varPtr
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
operator|(
name|flags
operator|&
operator|(
name|TCL_NAMESPACE_ONLY
operator||
name|TCL_GLOBAL_ONLY
operator||
name|TCL_PARSE_PART1
operator|)
operator|)
operator||
name|TCL_TRACE_READS
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TCL_LEAVE_ERR_MSG
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
literal|"read"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
goto|goto
name|errorReturn
goto|;
block|}
block|}
comment|/*      * Return the element if it's an existing scalar variable.      */
if|if
condition|(
name|TclIsVarScalar
argument_list|(
name|varPtr
argument_list|)
operator|&&
operator|!
name|TclIsVarUndefined
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
return|return
name|varPtr
operator|->
name|value
operator|.
name|objPtr
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|TCL_LEAVE_ERR_MSG
condition|)
block|{
if|if
condition|(
name|TclIsVarUndefined
argument_list|(
name|varPtr
argument_list|)
operator|&&
operator|(
name|arrayPtr
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|TclIsVarUndefined
argument_list|(
name|arrayPtr
argument_list|)
condition|)
block|{
name|msg
operator|=
name|noSuchElement
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TclIsVarArray
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
name|msg
operator|=
name|isArray
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|=
name|noSuchVar
expr_stmt|;
block|}
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
literal|"read"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
comment|/*      * An error. If the variable doesn't exist anymore and no-one's using      * it, then free up the relevant structures and hash table entries.      */
name|errorReturn
label|:
if|if
condition|(
name|TclIsVarUndefined
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
name|CleanupVar
argument_list|(
name|varPtr
argument_list|,
name|arrayPtr
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclGetIndexedScalar --  *  *	Return the Tcl object value of a local scalar variable in the active  *	procedure, given its index in the procedure's array of compiler  *	allocated local variables.  *  * Results:  *	The return value points to the current object value of the variable  *	given by localIndex. If the specified variable doesn't exist, or  *	there is a clash in array usage, or an error occurs while executing  *	variable traces, then NULL is returned and a message will be left in  *	the interpreter's result if leaveErrorMsg is 1.  *  * Side effects:  *	The ref count for the returned object is _not_ incremented to  *	reflect the returned reference; if you want to keep a reference to  *	the object you must increment its ref count yourself.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Obj
modifier|*
name|TclGetIndexedScalar
parameter_list|(
name|interp
parameter_list|,
name|localIndex
parameter_list|,
name|leaveErrorMsg
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Command interpreter in which variable is 				 * to be looked up. */
name|int
name|localIndex
decl_stmt|;
comment|/* Index of variable in procedure's array 				 * of local variables. */
name|int
name|leaveErrorMsg
decl_stmt|;
comment|/* 1 if to leave an error message in 				 * interpreter's result on an error. 				 * Otherwise no error message is left. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|CallFrame
modifier|*
name|varFramePtr
init|=
name|iPtr
operator|->
name|varFramePtr
decl_stmt|;
comment|/* Points to the procedure call frame whose 				 * variables are currently in use. Same as 				 * the current procedure's frame, if any, 				 * unless an "uplevel" is executing. */
name|Var
modifier|*
name|compiledLocals
init|=
name|varFramePtr
operator|->
name|compiledLocals
decl_stmt|;
name|Var
modifier|*
name|varPtr
decl_stmt|;
comment|/* Points to the variable's in-frame Var 				 * structure. */
name|char
modifier|*
name|varName
decl_stmt|;
comment|/* Name of the local variable. */
name|char
modifier|*
name|msg
decl_stmt|;
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
name|Proc
modifier|*
name|procPtr
init|=
name|varFramePtr
operator|->
name|procPtr
decl_stmt|;
name|int
name|localCt
init|=
name|procPtr
operator|->
name|numCompiledLocals
decl_stmt|;
if|if
condition|(
name|compiledLocals
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nTclGetIndexedScalar: can't get local %i in frame 0x%x, no compiled locals\n"
argument_list|,
name|localIndex
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|varFramePtr
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"TclGetIndexedScalar: no compiled locals in frame 0x%x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|varFramePtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|localIndex
operator|<
literal|0
operator|)
operator|||
operator|(
name|localIndex
operator|>=
name|localCt
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nTclGetIndexedScalar: can't get local %i in frame 0x%x with %i locals\n"
argument_list|,
name|localIndex
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|varFramePtr
argument_list|,
name|localCt
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"TclGetIndexedScalar: bad local index %i in frame 0x%x"
argument_list|,
name|localIndex
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|varFramePtr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TCL_COMPILE_DEBUG */
name|varPtr
operator|=
operator|&
operator|(
name|compiledLocals
index|[
name|localIndex
index|]
operator|)
expr_stmt|;
name|varName
operator|=
name|varPtr
operator|->
name|name
expr_stmt|;
comment|/*      * If varPtr is a link variable, we have a reference to some variable      * that was created through an "upvar" or "global" command, or we have a      * reference to a variable in an enclosing namespace. Traverse through      * any links until we find the referenced variable.      */
while|while
condition|(
name|TclIsVarLink
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
name|varPtr
operator|=
name|varPtr
operator|->
name|value
operator|.
name|linkPtr
expr_stmt|;
block|}
comment|/*      * Invoke any traces that have been set for the variable.      */
if|if
condition|(
name|varPtr
operator|->
name|tracePtr
operator|!=
name|NULL
condition|)
block|{
name|msg
operator|=
name|CallTraces
argument_list|(
name|iPtr
argument_list|,
comment|/*arrayPtr*/
name|NULL
argument_list|,
name|varPtr
argument_list|,
name|varName
argument_list|,
name|NULL
argument_list|,
name|TCL_TRACE_READS
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|leaveErrorMsg
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
name|NULL
argument_list|,
literal|"read"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
block|}
comment|/*      * Make sure we're dealing with a scalar variable and not an array, and      * that the variable exists (isn't undefined).      */
if|if
condition|(
operator|!
name|TclIsVarScalar
argument_list|(
name|varPtr
argument_list|)
operator|||
name|TclIsVarUndefined
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
if|if
condition|(
name|leaveErrorMsg
condition|)
block|{
if|if
condition|(
name|TclIsVarArray
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
name|msg
operator|=
name|isArray
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|=
name|noSuchVar
expr_stmt|;
block|}
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
name|NULL
argument_list|,
literal|"read"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
return|return
name|varPtr
operator|->
name|value
operator|.
name|objPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclGetElementOfIndexedArray --  *  *	Return the Tcl object value for an element in a local array  *	variable. The element is named by the object elemPtr while the   *	array is specified by its index in the active procedure's array  *	of compiler allocated local variables.  *  * Results:  *	The return value points to the current object value of the  *	element. If the specified array or element doesn't exist, or there  *	is a clash in array usage, or an error occurs while executing  *	variable traces, then NULL is returned and a message will be left in  *	the interpreter's result if leaveErrorMsg is 1.  *  * Side effects:  *	The ref count for the returned object is _not_ incremented to  *	reflect the returned reference; if you want to keep a reference to  *	the object you must increment its ref count yourself.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Obj
modifier|*
name|TclGetElementOfIndexedArray
parameter_list|(
name|interp
parameter_list|,
name|localIndex
parameter_list|,
name|elemPtr
parameter_list|,
name|leaveErrorMsg
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Command interpreter in which variable is 				 * to be looked up. */
name|int
name|localIndex
decl_stmt|;
comment|/* Index of array variable in procedure's 				 * array of local variables. */
name|Tcl_Obj
modifier|*
name|elemPtr
decl_stmt|;
comment|/* Points to an object holding the name of 				 * an element to get in the array. */
name|int
name|leaveErrorMsg
decl_stmt|;
comment|/* 1 if to leave an error message in 				 * the interpreter's result on an error. 				 * Otherwise no error message is left. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|CallFrame
modifier|*
name|varFramePtr
init|=
name|iPtr
operator|->
name|varFramePtr
decl_stmt|;
comment|/* Points to the procedure call frame whose 				 * variables are currently in use. Same as 				 * the current procedure's frame, if any, 				 * unless an "uplevel" is executing. */
name|Var
modifier|*
name|compiledLocals
init|=
name|varFramePtr
operator|->
name|compiledLocals
decl_stmt|;
name|Var
modifier|*
name|arrayPtr
decl_stmt|;
comment|/* Points to the array's in-frame Var 				 * structure. */
name|char
modifier|*
name|arrayName
decl_stmt|;
comment|/* Name of the local array. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|Var
modifier|*
name|varPtr
init|=
name|NULL
decl_stmt|;
comment|/* Points to the element's Var structure 				 * that we return. Initialized to avoid 				 * compiler warning. */
name|char
modifier|*
name|elem
decl_stmt|,
modifier|*
name|msg
decl_stmt|;
name|int
name|new
decl_stmt|;
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
name|Proc
modifier|*
name|procPtr
init|=
name|varFramePtr
operator|->
name|procPtr
decl_stmt|;
name|int
name|localCt
init|=
name|procPtr
operator|->
name|numCompiledLocals
decl_stmt|;
if|if
condition|(
name|compiledLocals
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nTclGetElementOfIndexedArray: can't get element of local %i in frame 0x%x, no compiled locals\n"
argument_list|,
name|localIndex
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|varFramePtr
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"TclGetIndexedScalar: no compiled locals in frame 0x%x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|varFramePtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|localIndex
operator|<
literal|0
operator|)
operator|||
operator|(
name|localIndex
operator|>=
name|localCt
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nTclGetIndexedScalar: can't get element of local %i in frame 0x%x with %i locals\n"
argument_list|,
name|localIndex
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|varFramePtr
argument_list|,
name|localCt
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"TclGetElementOfIndexedArray: bad local index %i in frame 0x%x"
argument_list|,
name|localIndex
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|varFramePtr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TCL_COMPILE_DEBUG */
comment|/*      * THIS FAILS IF THE ELEMENT NAME OBJECT'S STRING REP HAS A NULL BYTE.      */
name|elem
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|elemPtr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|arrayPtr
operator|=
operator|&
operator|(
name|compiledLocals
index|[
name|localIndex
index|]
operator|)
expr_stmt|;
name|arrayName
operator|=
name|arrayPtr
operator|->
name|name
expr_stmt|;
comment|/*      * If arrayPtr is a link variable, we have a reference to some variable      * that was created through an "upvar" or "global" command, or we have a      * reference to a variable in an enclosing namespace. Traverse through      * any links until we find the referenced variable.      */
while|while
condition|(
name|TclIsVarLink
argument_list|(
name|arrayPtr
argument_list|)
condition|)
block|{
name|arrayPtr
operator|=
name|arrayPtr
operator|->
name|value
operator|.
name|linkPtr
expr_stmt|;
block|}
comment|/*      * Make sure we're dealing with an array and that the array variable      * exists (isn't undefined).      */
if|if
condition|(
operator|!
name|TclIsVarArray
argument_list|(
name|arrayPtr
argument_list|)
operator|||
name|TclIsVarUndefined
argument_list|(
name|arrayPtr
argument_list|)
condition|)
block|{
if|if
condition|(
name|leaveErrorMsg
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|arrayName
argument_list|,
name|elem
argument_list|,
literal|"read"
argument_list|,
name|noSuchVar
argument_list|)
expr_stmt|;
block|}
goto|goto
name|errorReturn
goto|;
block|}
comment|/*      * Look up the element. Note that we must create the element (but leave      * it marked undefined) if it does not already exist. This allows a      * trace to create new array elements "on the fly" that did not exist      * before. A trace is always passed a variable for the array element. If      * the trace does not define the variable, it will be deleted below (at      * errorReturn) and an error returned.      */
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
name|arrayPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|,
name|elem
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
if|if
condition|(
name|arrayPtr
operator|->
name|searchPtr
operator|!=
name|NULL
condition|)
block|{
name|DeleteSearches
argument_list|(
name|arrayPtr
argument_list|)
expr_stmt|;
block|}
name|varPtr
operator|=
name|NewVar
argument_list|()
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
name|varPtr
argument_list|)
expr_stmt|;
name|varPtr
operator|->
name|hPtr
operator|=
name|hPtr
expr_stmt|;
name|varPtr
operator|->
name|nsPtr
operator|=
name|varFramePtr
operator|->
name|nsPtr
expr_stmt|;
name|TclSetVarArrayElement
argument_list|(
name|varPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|varPtr
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * Invoke any traces that have been set for the element variable.      */
if|if
condition|(
operator|(
name|varPtr
operator|->
name|tracePtr
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
name|arrayPtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|arrayPtr
operator|->
name|tracePtr
operator|!=
name|NULL
operator|)
operator|)
condition|)
block|{
name|msg
operator|=
name|CallTraces
argument_list|(
name|iPtr
argument_list|,
name|arrayPtr
argument_list|,
name|varPtr
argument_list|,
name|arrayName
argument_list|,
name|elem
argument_list|,
name|TCL_TRACE_READS
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|leaveErrorMsg
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|arrayName
argument_list|,
name|elem
argument_list|,
literal|"read"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
goto|goto
name|errorReturn
goto|;
block|}
block|}
comment|/*      * Return the element if it's an existing scalar variable.      */
if|if
condition|(
name|TclIsVarScalar
argument_list|(
name|varPtr
argument_list|)
operator|&&
operator|!
name|TclIsVarUndefined
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
return|return
name|varPtr
operator|->
name|value
operator|.
name|objPtr
return|;
block|}
if|if
condition|(
name|leaveErrorMsg
condition|)
block|{
if|if
condition|(
name|TclIsVarArray
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
name|msg
operator|=
name|isArray
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|=
name|noSuchVar
expr_stmt|;
block|}
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|arrayName
argument_list|,
name|elem
argument_list|,
literal|"read"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
comment|/*      * An error. If the variable doesn't exist anymore and no-one's using      * it, then free up the relevant structures and hash table entries.      */
name|errorReturn
label|:
if|if
condition|(
operator|(
name|varPtr
operator|!=
name|NULL
operator|)
operator|&&
name|TclIsVarUndefined
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
name|CleanupVar
argument_list|(
name|varPtr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* the array is not in a hashtable */
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetCmd --  *  *	This procedure is invoked to process the "set" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result value.  *  * Side effects:  *	A variable's value may be changed.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_SetCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
specifier|register
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
name|char
modifier|*
name|value
decl_stmt|;
name|value
operator|=
name|Tcl_GetVar2
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_LEAVE_ERR_MSG
operator||
name|TCL_PARSE_PART1
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|value
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
block|{
name|char
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|TCL_LEAVE_ERR_MSG
operator||
name|TCL_PARSE_PART1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|result
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" varName ?newValue?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetVar --  *  *	Change the value of a variable.  *  * Results:  *	Returns a pointer to the malloc'ed string which is the character  *	representation of the variable's new value. The caller must not  *	modify this string. If the write operation was disallowed then NULL  *	is returned; if the TCL_LEAVE_ERR_MSG flag is set, then an  *	explanatory message will be left in interp->result. Note that the  *	returned string may not be the same as newValue; this is because  *	variable traces may modify the variable's value.  *  * Side effects:  *	If varName is defined as a local or global variable in interp,  *	its value is changed to newValue. If varName isn't currently  *	defined, then a new global variable by that name is created.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_SetVar
parameter_list|(
name|interp
parameter_list|,
name|varName
parameter_list|,
name|newValue
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Command interpreter in which varName is 				 * to be looked up. */
name|char
modifier|*
name|varName
decl_stmt|;
comment|/* Name of a variable in interp. */
name|char
modifier|*
name|newValue
decl_stmt|;
comment|/* New value for varName. */
name|int
name|flags
decl_stmt|;
comment|/* Various flags that tell how to set value: 				 * any of TCL_GLOBAL_ONLY, 				 * TCL_NAMESPACE_ONLY, TCL_APPEND_VALUE, 				 * TCL_LIST_ELEMENT, TCL_LEAVE_ERR_MSG. */
block|{
return|return
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|newValue
argument_list|,
operator|(
name|flags
operator||
name|TCL_PARSE_PART1
operator|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetVar2 --  *  *      Given a two-part variable name, which may refer either to a  *      scalar variable or an element of an array, change the value  *      of the variable.  If the named scalar or array or element  *      doesn't exist then create one.  *  * Results:  *	Returns a pointer to the malloc'ed string which is the character  *	representation of the variable's new value. The caller must not  *	modify this string. If the write operation was disallowed because an  *	array was expected but not found (or vice versa), then NULL is  *	returned; if the TCL_LEAVE_ERR_MSG flag is set, then an explanatory  *	message will be left in interp->result. Note that the returned  *	string may not be the same as newValue; this is because variable  *	traces may modify the variable's value.  *  * Side effects:  *      The value of the given variable is set. If either the array  *      or the entry didn't exist then a new one is created.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_SetVar2
parameter_list|(
name|interp
parameter_list|,
name|part1
parameter_list|,
name|part2
parameter_list|,
name|newValue
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Command interpreter in which variable is                                  * to be looked up. */
name|char
modifier|*
name|part1
decl_stmt|;
comment|/* If part2 is NULL, this is name of scalar                                  * variable. Otherwise it is the name of                                  * an array. */
name|char
modifier|*
name|part2
decl_stmt|;
comment|/* Name of an element within an array, or 				 * NULL. */
name|char
modifier|*
name|newValue
decl_stmt|;
comment|/* New value for variable. */
name|int
name|flags
decl_stmt|;
comment|/* Various flags that tell how to set value: 				 * any of TCL_GLOBAL_ONLY, 				 * TCL_NAMESPACE_ONLY, TCL_APPEND_VALUE, 				 * TCL_LIST_ELEMENT, TCL_LEAVE_ERR_MSG, or  				 * TCL_PARSE_PART1. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|valuePtr
decl_stmt|;
specifier|register
name|Tcl_Obj
modifier|*
name|part1Ptr
decl_stmt|;
specifier|register
name|Tcl_Obj
modifier|*
name|part2Ptr
init|=
name|NULL
decl_stmt|;
name|Tcl_Obj
modifier|*
name|varValuePtr
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/*      * Create an object holding the variable's new value and use      * Tcl_ObjSetVar2 to actually set the variable.      */
name|length
operator|=
name|newValue
condition|?
name|strlen
argument_list|(
name|newValue
argument_list|)
else|:
literal|0
expr_stmt|;
name|TclNewObj
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|TclInitStringRep
argument_list|(
name|valuePtr
argument_list|,
name|newValue
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|part1
argument_list|)
expr_stmt|;
name|TclNewObj
argument_list|(
name|part1Ptr
argument_list|)
expr_stmt|;
name|TclInitStringRep
argument_list|(
name|part1Ptr
argument_list|,
name|part1
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|part1Ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|part2
operator|!=
name|NULL
condition|)
block|{
name|length
operator|=
name|strlen
argument_list|(
name|part2
argument_list|)
expr_stmt|;
name|TclNewObj
argument_list|(
name|part2Ptr
argument_list|)
expr_stmt|;
name|TclInitStringRep
argument_list|(
name|part2Ptr
argument_list|,
name|part2
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|part2Ptr
argument_list|)
expr_stmt|;
block|}
name|varValuePtr
operator|=
name|Tcl_ObjSetVar2
argument_list|(
name|interp
argument_list|,
name|part1Ptr
argument_list|,
name|part2Ptr
argument_list|,
name|valuePtr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|part1Ptr
argument_list|)
expr_stmt|;
comment|/* done with the part1 name object */
if|if
condition|(
name|part2Ptr
operator|!=
name|NULL
condition|)
block|{
name|TclDecrRefCount
argument_list|(
name|part2Ptr
argument_list|)
expr_stmt|;
comment|/* and the part2 name object */
block|}
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
comment|/* done with the object */
if|if
condition|(
name|varValuePtr
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * Move the interpreter's object result to the string result,  	 * then reset the object result. 	 * FAILS IF OBJECT RESULT'S STRING REPRESENTATION CONTAINS NULLS. 	 */
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|TclGetStringFromObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*      * THIS FAILS IF Tcl_ObjSetVar2's RESULT'S STRING REP HAS A NULL BYTE.      */
return|return
name|TclGetStringFromObj
argument_list|(
name|varValuePtr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ObjSetVar2 --  *  *	Given a two-part variable name, which may refer either to a scalar  *	variable or an element of an array, change the value of the variable  *	to a new Tcl object value. If the named scalar or array or element  *	doesn't exist then create one.  *  * Results:  *	Returns a pointer to the Tcl_Obj holding the new value of the  *	variable. If the write operation was disallowed because an array was  *	expected but not found (or vice versa), then NULL is returned; if  *	the TCL_LEAVE_ERR_MSG flag is set, then an explanatory message will  *	be left in the interpreter's result. Note that the returned object  *	may not be the same one referenced by newValuePtr; this is because  *	variable traces may modify the variable's value.  *  * Side effects:  *	The value of the given variable is set. If either the array or the  *	entry didn't exist then a new variable is created.  *  *	The reference count is decremented for any old value of the variable  *	and incremented for its new value. If the new value for the variable  *	is not the same one referenced by newValuePtr (perhaps as a result  *	of a variable trace), then newValuePtr's ref count is left unchanged  *	by Tcl_ObjSetVar2. newValuePtr's ref count is also left unchanged if  *	we are appending it as a string value: that is, if "flags" includes  *	TCL_APPEND_VALUE but not TCL_LIST_ELEMENT.  *  *	The reference count for the returned object is _not_ incremented: if  *	you want to keep a reference to the object you must increment its  *	ref count yourself.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_ObjSetVar2
parameter_list|(
name|interp
parameter_list|,
name|part1Ptr
parameter_list|,
name|part2Ptr
parameter_list|,
name|newValuePtr
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Command interpreter in which variable is 				 * to be found. */
specifier|register
name|Tcl_Obj
modifier|*
name|part1Ptr
decl_stmt|;
comment|/* Points to an object holding the name of 				 * an array (if part2 is non-NULL) or the 				 * name of a variable. */
specifier|register
name|Tcl_Obj
modifier|*
name|part2Ptr
decl_stmt|;
comment|/* If non-null, points to an object holding 				 * the name of an element in the array 				 * part1Ptr. */
name|Tcl_Obj
modifier|*
name|newValuePtr
decl_stmt|;
comment|/* New value for variable. */
name|int
name|flags
decl_stmt|;
comment|/* Various flags that tell how to set value: 				 * any of TCL_GLOBAL_ONLY, 				 * TCL_NAMESPACE_ONLY, TCL_APPEND_VALUE, 				 * TCL_LIST_ELEMENT, TCL_LEAVE_ERR_MSG, or 				 * TCL_PARSE_PART1. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
specifier|register
name|Var
modifier|*
name|varPtr
decl_stmt|;
name|Var
modifier|*
name|arrayPtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|oldValuePtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|resultPtr
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|part1
decl_stmt|,
modifier|*
name|bytes
decl_stmt|;
name|char
modifier|*
name|part2
init|=
name|NULL
decl_stmt|;
name|int
name|length
decl_stmt|,
name|result
decl_stmt|;
comment|/*      * THIS FAILS IF A NAME OBJECT'S STRING REP HAS A NULL BYTE.      */
name|part1
operator|=
name|TclGetStringFromObj
argument_list|(
name|part1Ptr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|part2Ptr
operator|!=
name|NULL
condition|)
block|{
name|part2
operator|=
name|TclGetStringFromObj
argument_list|(
name|part2Ptr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|varPtr
operator|=
name|TclLookupVar
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
name|flags
argument_list|,
literal|"set"
argument_list|,
comment|/*createPart1*/
literal|1
argument_list|,
comment|/*createPart2*/
literal|1
argument_list|,
operator|&
name|arrayPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|varPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|/*      * If the variable is in a hashtable and its hPtr field is NULL, then we      * have an upvar to an array element where the array was deleted,      * leaving the element dangling at the end of the upvar. Generate an      * error (allowing the variable to be reset would screw up our storage      * allocation and is meaningless anyway).      */
if|if
condition|(
operator|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_IN_HASHTABLE
operator|)
operator|&&
operator|(
name|varPtr
operator|->
name|hPtr
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TCL_LEAVE_ERR_MSG
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
literal|"set"
argument_list|,
name|danglingUpvar
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
comment|/*      * It's an error to try to set an array variable itself.      */
if|if
condition|(
name|TclIsVarArray
argument_list|(
name|varPtr
argument_list|)
operator|&&
operator|!
name|TclIsVarUndefined
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TCL_LEAVE_ERR_MSG
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
literal|"set"
argument_list|,
name|isArray
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
comment|/*      * At this point, if we were appending, we used to call read traces: we      * treated append as a read-modify-write. However, it seemed unlikely to      * us that a real program would be interested in such reads being done      * during a set operation.      */
comment|/*      * Set the variable's new value. If appending, append the new value to      * the variable, either as a list element or as a string. Also, if      * appending, then if the variable's old value is unshared we can modify      * it directly, otherwise we must create a new copy to modify: this is      * "copy on write".      */
name|oldValuePtr
operator|=
name|varPtr
operator|->
name|value
operator|.
name|objPtr
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TCL_APPEND_VALUE
condition|)
block|{
if|if
condition|(
name|TclIsVarUndefined
argument_list|(
name|varPtr
argument_list|)
operator|&&
operator|(
name|oldValuePtr
operator|!=
name|NULL
operator|)
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|oldValuePtr
argument_list|)
expr_stmt|;
comment|/* discard old value */
name|varPtr
operator|->
name|value
operator|.
name|objPtr
operator|=
name|NULL
expr_stmt|;
name|oldValuePtr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|TCL_LIST_ELEMENT
condition|)
block|{
comment|/* append list element */
if|if
condition|(
name|oldValuePtr
operator|==
name|NULL
condition|)
block|{
name|TclNewObj
argument_list|(
name|oldValuePtr
argument_list|)
expr_stmt|;
name|varPtr
operator|->
name|value
operator|.
name|objPtr
operator|=
name|oldValuePtr
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|oldValuePtr
argument_list|)
expr_stmt|;
comment|/* since var is reference */
block|}
elseif|else
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|oldValuePtr
argument_list|)
condition|)
block|{
name|varPtr
operator|->
name|value
operator|.
name|objPtr
operator|=
name|Tcl_DuplicateObj
argument_list|(
name|oldValuePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|oldValuePtr
argument_list|)
expr_stmt|;
name|oldValuePtr
operator|=
name|varPtr
operator|->
name|value
operator|.
name|objPtr
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|oldValuePtr
argument_list|)
expr_stmt|;
comment|/* since var is reference */
block|}
name|result
operator|=
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|oldValuePtr
argument_list|,
name|newValuePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
comment|/* append string */
comment|/* 	     * We append newValuePtr's bytes but don't change its ref count. 	     */
name|bytes
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|newValuePtr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldValuePtr
operator|==
name|NULL
condition|)
block|{
name|varPtr
operator|->
name|value
operator|.
name|objPtr
operator|=
name|Tcl_NewStringObj
argument_list|(
name|bytes
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|objPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|oldValuePtr
argument_list|)
condition|)
block|{
comment|/* append to copy */
name|varPtr
operator|->
name|value
operator|.
name|objPtr
operator|=
name|Tcl_DuplicateObj
argument_list|(
name|oldValuePtr
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|oldValuePtr
argument_list|)
expr_stmt|;
name|oldValuePtr
operator|=
name|varPtr
operator|->
name|value
operator|.
name|objPtr
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|oldValuePtr
argument_list|)
expr_stmt|;
comment|/* since var is ref */
block|}
name|Tcl_AppendToObj
argument_list|(
name|oldValuePtr
argument_list|,
name|bytes
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|&
name|TCL_LIST_ELEMENT
condition|)
block|{
comment|/* set var to list element */
name|int
name|neededBytes
decl_stmt|,
name|listFlags
decl_stmt|;
comment|/* 	     * We set the variable to the result of converting newValuePtr's 	     * string rep to a list element. We do not change newValuePtr's 	     * ref count. 	     */
if|if
condition|(
name|oldValuePtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|oldValuePtr
argument_list|)
expr_stmt|;
comment|/* discard old value */
block|}
name|bytes
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|newValuePtr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|neededBytes
operator|=
name|Tcl_ScanElement
argument_list|(
name|bytes
argument_list|,
operator|&
name|listFlags
argument_list|)
expr_stmt|;
name|oldValuePtr
operator|=
name|Tcl_NewObj
argument_list|()
expr_stmt|;
name|oldValuePtr
operator|->
name|bytes
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|neededBytes
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|oldValuePtr
operator|->
name|length
operator|=
name|Tcl_ConvertElement
argument_list|(
name|bytes
argument_list|,
name|oldValuePtr
operator|->
name|bytes
argument_list|,
name|listFlags
argument_list|)
expr_stmt|;
name|varPtr
operator|->
name|value
operator|.
name|objPtr
operator|=
name|oldValuePtr
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|objPtr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newValuePtr
operator|!=
name|oldValuePtr
condition|)
block|{
name|varPtr
operator|->
name|value
operator|.
name|objPtr
operator|=
name|newValuePtr
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|newValuePtr
argument_list|)
expr_stmt|;
comment|/* var is another ref */
if|if
condition|(
name|oldValuePtr
operator|!=
name|NULL
condition|)
block|{
name|TclDecrRefCount
argument_list|(
name|oldValuePtr
argument_list|)
expr_stmt|;
comment|/* discard old value */
block|}
block|}
block|}
name|TclSetVarScalar
argument_list|(
name|varPtr
argument_list|)
expr_stmt|;
name|TclClearVarUndefined
argument_list|(
name|varPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|arrayPtr
operator|!=
name|NULL
condition|)
block|{
name|TclClearVarUndefined
argument_list|(
name|arrayPtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * Invoke any write traces for the variable.      */
if|if
condition|(
operator|(
name|varPtr
operator|->
name|tracePtr
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
name|arrayPtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|arrayPtr
operator|->
name|tracePtr
operator|!=
name|NULL
operator|)
operator|)
condition|)
block|{
name|char
modifier|*
name|msg
init|=
name|CallTraces
argument_list|(
name|iPtr
argument_list|,
name|arrayPtr
argument_list|,
name|varPtr
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
operator|(
name|flags
operator|&
operator|(
name|TCL_GLOBAL_ONLY
operator||
name|TCL_NAMESPACE_ONLY
operator||
name|TCL_PARSE_PART1
operator|)
operator|)
operator||
name|TCL_TRACE_WRITES
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TCL_LEAVE_ERR_MSG
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
literal|"set"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
goto|goto
name|cleanup
goto|;
block|}
block|}
comment|/*      * Return the variable's value unless the variable was changed in some      * gross way by a trace (e.g. it was unset and then recreated as an      * array).       */
if|if
condition|(
name|TclIsVarScalar
argument_list|(
name|varPtr
argument_list|)
operator|&&
operator|!
name|TclIsVarUndefined
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
return|return
name|varPtr
operator|->
name|value
operator|.
name|objPtr
return|;
block|}
comment|/*      * A trace changed the value in some gross way. Return an empty string      * object.      */
name|resultPtr
operator|=
name|iPtr
operator|->
name|emptyObjPtr
expr_stmt|;
comment|/*      * If the variable doesn't exist anymore and no-one's using it, then      * free up the relevant structures and hash table entries.      */
name|cleanup
label|:
if|if
condition|(
name|TclIsVarUndefined
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
name|CleanupVar
argument_list|(
name|varPtr
argument_list|,
name|arrayPtr
argument_list|)
expr_stmt|;
block|}
return|return
name|resultPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclSetIndexedScalar --  *  *	Change the Tcl object value of a local scalar variable in the active  *	procedure, given its compile-time allocated index in the procedure's  *	array of local variables.  *  * Results:  *	Returns a pointer to the Tcl_Obj holding the new value of the  *	variable given by localIndex. If the specified variable doesn't  *	exist, or there is a clash in array usage, or an error occurs while  *	executing variable traces, then NULL is returned and a message will  *	be left in the interpreter's result if leaveErrorMsg is 1. Note  *	that the returned object may not be the same one referenced by  *	newValuePtr; this is because variable traces may modify the  *	variable's value.  *  * Side effects:  *	The value of the given variable is set. The reference count is  *	decremented for any old value of the variable and incremented for  *	its new value. If as a result of a variable trace the new value for  *	the variable is not the same one referenced by newValuePtr, then  *	newValuePtr's ref count is left unchanged. The ref count for the  *	returned object is _not_ incremented to reflect the returned  *	reference; if you want to keep a reference to the object you must  *	increment its ref count yourself. This procedure does not create  *	new variables, but only sets those recognized at compile time.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Obj
modifier|*
name|TclSetIndexedScalar
parameter_list|(
name|interp
parameter_list|,
name|localIndex
parameter_list|,
name|newValuePtr
parameter_list|,
name|leaveErrorMsg
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Command interpreter in which variable is 				 * to be found. */
name|int
name|localIndex
decl_stmt|;
comment|/* Index of variable in procedure's array 				 * of local variables. */
name|Tcl_Obj
modifier|*
name|newValuePtr
decl_stmt|;
comment|/* New value for variable. */
name|int
name|leaveErrorMsg
decl_stmt|;
comment|/* 1 if to leave an error message in 				 * the interpreter's result on an error. 				 * Otherwise no error message is left. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|CallFrame
modifier|*
name|varFramePtr
init|=
name|iPtr
operator|->
name|varFramePtr
decl_stmt|;
comment|/* Points to the procedure call frame whose 				 * variables are currently in use. Same as 				 * the current procedure's frame, if any, 				 * unless an "uplevel" is executing. */
name|Var
modifier|*
name|compiledLocals
init|=
name|varFramePtr
operator|->
name|compiledLocals
decl_stmt|;
specifier|register
name|Var
modifier|*
name|varPtr
decl_stmt|;
comment|/* Points to the variable's in-frame Var 				 * structure. */
name|char
modifier|*
name|varName
decl_stmt|;
comment|/* Name of the local variable. */
name|Tcl_Obj
modifier|*
name|oldValuePtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|resultPtr
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
name|Proc
modifier|*
name|procPtr
init|=
name|varFramePtr
operator|->
name|procPtr
decl_stmt|;
name|int
name|localCt
init|=
name|procPtr
operator|->
name|numCompiledLocals
decl_stmt|;
if|if
condition|(
name|compiledLocals
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nTclSetIndexedScalar: can't set local %i in frame 0x%x, no compiled locals\n"
argument_list|,
name|localIndex
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|varFramePtr
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"TclSetIndexedScalar: no compiled locals in frame 0x%x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|varFramePtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|localIndex
operator|<
literal|0
operator|)
operator|||
operator|(
name|localIndex
operator|>=
name|localCt
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nTclSetIndexedScalar: can't set local %i in frame 0x%x with %i locals\n"
argument_list|,
name|localIndex
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|varFramePtr
argument_list|,
name|localCt
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"TclSetIndexedScalar: bad local index %i in frame 0x%x"
argument_list|,
name|localIndex
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|varFramePtr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TCL_COMPILE_DEBUG */
name|varPtr
operator|=
operator|&
operator|(
name|compiledLocals
index|[
name|localIndex
index|]
operator|)
expr_stmt|;
name|varName
operator|=
name|varPtr
operator|->
name|name
expr_stmt|;
comment|/*      * If varPtr is a link variable, we have a reference to some variable      * that was created through an "upvar" or "global" command, or we have a      * reference to a variable in an enclosing namespace. Traverse through      * any links until we find the referenced variable.      */
while|while
condition|(
name|TclIsVarLink
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
name|varPtr
operator|=
name|varPtr
operator|->
name|value
operator|.
name|linkPtr
expr_stmt|;
block|}
comment|/*      * If the variable is in a hashtable and its hPtr field is NULL, then we      * have an upvar to an array element where the array was deleted,      * leaving the element dangling at the end of the upvar. Generate an      * error (allowing the variable to be reset would screw up our storage      * allocation and is meaningless anyway).      */
if|if
condition|(
operator|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_IN_HASHTABLE
operator|)
operator|&&
operator|(
name|varPtr
operator|->
name|hPtr
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|leaveErrorMsg
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
name|NULL
argument_list|,
literal|"set"
argument_list|,
name|danglingUpvar
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
comment|/*      * It's an error to try to set an array variable itself.      */
if|if
condition|(
name|TclIsVarArray
argument_list|(
name|varPtr
argument_list|)
operator|&&
operator|!
name|TclIsVarUndefined
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
if|if
condition|(
name|leaveErrorMsg
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
name|NULL
argument_list|,
literal|"set"
argument_list|,
name|isArray
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
comment|/*      * Set the variable's new value and discard its old value. We don't      * append with this "set" procedure so the old value isn't needed.      */
name|oldValuePtr
operator|=
name|varPtr
operator|->
name|value
operator|.
name|objPtr
expr_stmt|;
if|if
condition|(
name|newValuePtr
operator|!=
name|oldValuePtr
condition|)
block|{
comment|/* set new value */
name|varPtr
operator|->
name|value
operator|.
name|objPtr
operator|=
name|newValuePtr
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|newValuePtr
argument_list|)
expr_stmt|;
comment|/* var is another ref to obj */
if|if
condition|(
name|oldValuePtr
operator|!=
name|NULL
condition|)
block|{
name|TclDecrRefCount
argument_list|(
name|oldValuePtr
argument_list|)
expr_stmt|;
comment|/* discard old value */
block|}
block|}
name|TclSetVarScalar
argument_list|(
name|varPtr
argument_list|)
expr_stmt|;
name|TclClearVarUndefined
argument_list|(
name|varPtr
argument_list|)
expr_stmt|;
comment|/*      * Invoke any write traces for the variable.      */
if|if
condition|(
name|varPtr
operator|->
name|tracePtr
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|msg
init|=
name|CallTraces
argument_list|(
name|iPtr
argument_list|,
comment|/*arrayPtr*/
name|NULL
argument_list|,
name|varPtr
argument_list|,
name|varName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_TRACE_WRITES
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|leaveErrorMsg
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
name|NULL
argument_list|,
literal|"set"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
goto|goto
name|cleanup
goto|;
block|}
block|}
comment|/*      * Return the variable's value unless the variable was changed in some      * gross way by a trace (e.g. it was unset and then recreated as an      * array). If it was changed is a gross way, just return an empty string      * object.      */
if|if
condition|(
name|TclIsVarScalar
argument_list|(
name|varPtr
argument_list|)
operator|&&
operator|!
name|TclIsVarUndefined
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
return|return
name|varPtr
operator|->
name|value
operator|.
name|objPtr
return|;
block|}
name|resultPtr
operator|=
name|Tcl_NewObj
argument_list|()
expr_stmt|;
comment|/*      * If the variable doesn't exist anymore and no-one's using it, then      * free up the relevant structures and hash table entries.      */
name|cleanup
label|:
if|if
condition|(
name|TclIsVarUndefined
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
name|CleanupVar
argument_list|(
name|varPtr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|resultPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclSetElementOfIndexedArray --  *  *	Change the Tcl object value of an element in a local array  *	variable. The element is named by the object elemPtr while the array  *	is specified by its index in the active procedure's array of  *	compiler allocated local variables.  *  * Results:  *	Returns a pointer to the Tcl_Obj holding the new value of the  *	element. If the specified array or element doesn't exist, or there  *	is a clash in array usage, or an error occurs while executing  *	variable traces, then NULL is returned and a message will be left in  *	the interpreter's result if leaveErrorMsg is 1. Note that the  *	returned object may not be the same one referenced by newValuePtr;  *	this is because variable traces may modify the variable's value.  *  * Side effects:  *	The value of the given array element is set. The reference count is  *	decremented for any old value of the element and incremented for its  *	new value. If as a result of a variable trace the new value for the  *	element is not the same one referenced by newValuePtr, then  *	newValuePtr's ref count is left unchanged. The ref count for the  *	returned object is _not_ incremented to reflect the returned  *	reference; if you want to keep a reference to the object you must  *	increment its ref count yourself. This procedure will not create new  *	array variables, but only sets elements of those arrays recognized  *	at compile time. However, if the entry doesn't exist then a new  *	variable is created.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Obj
modifier|*
name|TclSetElementOfIndexedArray
parameter_list|(
name|interp
parameter_list|,
name|localIndex
parameter_list|,
name|elemPtr
parameter_list|,
name|newValuePtr
parameter_list|,
name|leaveErrorMsg
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Command interpreter in which the array is 				 * to be found. */
name|int
name|localIndex
decl_stmt|;
comment|/* Index of array variable in procedure's 				 * array of local variables. */
name|Tcl_Obj
modifier|*
name|elemPtr
decl_stmt|;
comment|/* Points to an object holding the name of 				 * an element to set in the array. */
name|Tcl_Obj
modifier|*
name|newValuePtr
decl_stmt|;
comment|/* New value for variable. */
name|int
name|leaveErrorMsg
decl_stmt|;
comment|/* 1 if to leave an error message in 				 * the interpreter's result on an error. 				 * Otherwise no error message is left. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|CallFrame
modifier|*
name|varFramePtr
init|=
name|iPtr
operator|->
name|varFramePtr
decl_stmt|;
comment|/* Points to the procedure call frame whose 				 * variables are currently in use. Same as 				 * the current procedure's frame, if any, 				 * unless an "uplevel" is executing. */
name|Var
modifier|*
name|compiledLocals
init|=
name|varFramePtr
operator|->
name|compiledLocals
decl_stmt|;
name|Var
modifier|*
name|arrayPtr
decl_stmt|;
comment|/* Points to the array's in-frame Var 				 * structure. */
name|char
modifier|*
name|arrayName
decl_stmt|;
comment|/* Name of the local array. */
name|char
modifier|*
name|elem
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|Var
modifier|*
name|varPtr
init|=
name|NULL
decl_stmt|;
comment|/* Points to the element's Var structure 				 * that we return. */
name|Tcl_Obj
modifier|*
name|resultPtr
init|=
name|NULL
decl_stmt|;
name|Tcl_Obj
modifier|*
name|oldValuePtr
decl_stmt|;
name|int
name|new
decl_stmt|;
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
name|Proc
modifier|*
name|procPtr
init|=
name|varFramePtr
operator|->
name|procPtr
decl_stmt|;
name|int
name|localCt
init|=
name|procPtr
operator|->
name|numCompiledLocals
decl_stmt|;
if|if
condition|(
name|compiledLocals
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nTclSetElementOfIndexedArray: can't set element of local %i in frame 0x%x, no compiled locals\n"
argument_list|,
name|localIndex
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|varFramePtr
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"TclSetIndexedScalar: no compiled locals in frame 0x%x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|varFramePtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|localIndex
operator|<
literal|0
operator|)
operator|||
operator|(
name|localIndex
operator|>=
name|localCt
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nTclSetIndexedScalar: can't set elememt of local %i in frame 0x%x with %i locals\n"
argument_list|,
name|localIndex
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|varFramePtr
argument_list|,
name|localCt
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"TclSetElementOfIndexedArray: bad local index %i in frame 0x%x"
argument_list|,
name|localIndex
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|varFramePtr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TCL_COMPILE_DEBUG */
comment|/*      * THIS FAILS IF THE ELEMENT NAME OBJECT'S STRING REP HAS A NULL BYTE.      */
name|elem
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|elemPtr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|arrayPtr
operator|=
operator|&
operator|(
name|compiledLocals
index|[
name|localIndex
index|]
operator|)
expr_stmt|;
name|arrayName
operator|=
name|arrayPtr
operator|->
name|name
expr_stmt|;
comment|/*      * If arrayPtr is a link variable, we have a reference to some variable      * that was created through an "upvar" or "global" command, or we have a      * reference to a variable in an enclosing namespace. Traverse through      * any links until we find the referenced variable.      */
while|while
condition|(
name|TclIsVarLink
argument_list|(
name|arrayPtr
argument_list|)
condition|)
block|{
name|arrayPtr
operator|=
name|arrayPtr
operator|->
name|value
operator|.
name|linkPtr
expr_stmt|;
block|}
comment|/*      * Make sure we're dealing with an array.      */
if|if
condition|(
name|TclIsVarUndefined
argument_list|(
name|arrayPtr
argument_list|)
operator|&&
operator|!
name|TclIsVarArrayElement
argument_list|(
name|arrayPtr
argument_list|)
condition|)
block|{
name|TclSetVarArray
argument_list|(
name|arrayPtr
argument_list|)
expr_stmt|;
name|arrayPtr
operator|->
name|value
operator|.
name|tablePtr
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Tcl_HashTable
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
name|arrayPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
name|TclClearVarUndefined
argument_list|(
name|arrayPtr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TclIsVarArray
argument_list|(
name|arrayPtr
argument_list|)
condition|)
block|{
if|if
condition|(
name|leaveErrorMsg
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|arrayName
argument_list|,
name|elem
argument_list|,
literal|"set"
argument_list|,
name|needArray
argument_list|)
expr_stmt|;
block|}
goto|goto
name|errorReturn
goto|;
block|}
comment|/*      * Look up the element.      */
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
name|arrayPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|,
name|elem
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
if|if
condition|(
name|arrayPtr
operator|->
name|searchPtr
operator|!=
name|NULL
condition|)
block|{
name|DeleteSearches
argument_list|(
name|arrayPtr
argument_list|)
expr_stmt|;
block|}
name|varPtr
operator|=
name|NewVar
argument_list|()
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
name|varPtr
argument_list|)
expr_stmt|;
name|varPtr
operator|->
name|hPtr
operator|=
name|hPtr
expr_stmt|;
name|varPtr
operator|->
name|nsPtr
operator|=
name|varFramePtr
operator|->
name|nsPtr
expr_stmt|;
name|TclSetVarArrayElement
argument_list|(
name|varPtr
argument_list|)
expr_stmt|;
block|}
name|varPtr
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
comment|/*      * It's an error to try to set an array variable itself.      */
if|if
condition|(
name|TclIsVarArray
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
if|if
condition|(
name|leaveErrorMsg
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|arrayName
argument_list|,
name|elem
argument_list|,
literal|"set"
argument_list|,
name|isArray
argument_list|)
expr_stmt|;
block|}
goto|goto
name|errorReturn
goto|;
block|}
comment|/*      * Set the variable's new value and discard the old one. We don't      * append with this "set" procedure so the old value isn't needed.      */
name|oldValuePtr
operator|=
name|varPtr
operator|->
name|value
operator|.
name|objPtr
expr_stmt|;
if|if
condition|(
name|newValuePtr
operator|!=
name|oldValuePtr
condition|)
block|{
comment|/* set new value */
name|varPtr
operator|->
name|value
operator|.
name|objPtr
operator|=
name|newValuePtr
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|newValuePtr
argument_list|)
expr_stmt|;
comment|/* var is another ref to obj */
if|if
condition|(
name|oldValuePtr
operator|!=
name|NULL
condition|)
block|{
name|TclDecrRefCount
argument_list|(
name|oldValuePtr
argument_list|)
expr_stmt|;
comment|/* discard old value */
block|}
block|}
name|TclSetVarScalar
argument_list|(
name|varPtr
argument_list|)
expr_stmt|;
name|TclClearVarUndefined
argument_list|(
name|varPtr
argument_list|)
expr_stmt|;
comment|/*      * Invoke any write traces for the element variable.      */
if|if
condition|(
operator|(
name|varPtr
operator|->
name|tracePtr
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
name|arrayPtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|arrayPtr
operator|->
name|tracePtr
operator|!=
name|NULL
operator|)
operator|)
condition|)
block|{
name|char
modifier|*
name|msg
init|=
name|CallTraces
argument_list|(
name|iPtr
argument_list|,
name|arrayPtr
argument_list|,
name|varPtr
argument_list|,
name|arrayName
argument_list|,
name|elem
argument_list|,
name|TCL_TRACE_WRITES
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|leaveErrorMsg
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|arrayName
argument_list|,
name|elem
argument_list|,
literal|"set"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
goto|goto
name|errorReturn
goto|;
block|}
block|}
comment|/*      * Return the element's value unless it was changed in some gross way by      * a trace (e.g. it was unset and then recreated as an array). If it was      * changed is a gross way, just return an empty string object.      */
if|if
condition|(
name|TclIsVarScalar
argument_list|(
name|varPtr
argument_list|)
operator|&&
operator|!
name|TclIsVarUndefined
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
return|return
name|varPtr
operator|->
name|value
operator|.
name|objPtr
return|;
block|}
name|resultPtr
operator|=
name|Tcl_NewObj
argument_list|()
expr_stmt|;
comment|/*      * An error. If the variable doesn't exist anymore and no-one's using      * it, then free up the relevant structures and hash table entries.      */
name|errorReturn
label|:
if|if
condition|(
name|varPtr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|TclIsVarUndefined
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
name|CleanupVar
argument_list|(
name|varPtr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* note: array isn't in hashtable */
block|}
block|}
return|return
name|resultPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclIncrVar2 --  *  *	Given a two-part variable name, which may refer either to a scalar  *	variable or an element of an array, increment the Tcl object value  *	of the variable by a specified amount.  *  * Results:  *	Returns a pointer to the Tcl_Obj holding the new value of the  *	variable. If the specified variable doesn't exist, or there is a  *	clash in array usage, or an error occurs while executing variable  *	traces, then NULL is returned and a message will be left in  *	the interpreter's result.  *  * Side effects:  *	The value of the given variable is incremented by the specified  *	amount. If either the array or the entry didn't exist then a new  *	variable is created. The ref count for the returned object is _not_  *	incremented to reflect the returned reference; if you want to keep a  *	reference to the object you must increment its ref count yourself.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Obj
modifier|*
name|TclIncrVar2
parameter_list|(
name|interp
parameter_list|,
name|part1Ptr
parameter_list|,
name|part2Ptr
parameter_list|,
name|incrAmount
parameter_list|,
name|part1NotParsed
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Command interpreter in which variable is 				 * to be found. */
name|Tcl_Obj
modifier|*
name|part1Ptr
decl_stmt|;
comment|/* Points to an object holding the name of 				 * an array (if part2 is non-NULL) or the 				 * name of a variable. */
name|Tcl_Obj
modifier|*
name|part2Ptr
decl_stmt|;
comment|/* If non-null, points to an object holding 				 * the name of an element in the array 				 * part1Ptr. */
name|long
name|incrAmount
decl_stmt|;
comment|/* Amount to be added to variable. */
name|int
name|part1NotParsed
decl_stmt|;
comment|/* 1 if part1 hasn't yet been parsed into 				 * an array name and index (if any). */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|varValuePtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|resultPtr
decl_stmt|;
name|int
name|createdNewObj
decl_stmt|;
comment|/* Set 1 if var's value object is shared 				 * so we must increment a copy (i.e. copy 				 * on write). */
name|long
name|i
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|result
decl_stmt|;
name|flags
operator|=
name|TCL_LEAVE_ERR_MSG
expr_stmt|;
if|if
condition|(
name|part1NotParsed
condition|)
block|{
name|flags
operator||=
name|TCL_PARSE_PART1
expr_stmt|;
block|}
name|varValuePtr
operator|=
name|Tcl_ObjGetVar2
argument_list|(
name|interp
argument_list|,
name|part1Ptr
argument_list|,
name|part2Ptr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|varValuePtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
literal|"\n    (reading value of variable to increment)"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*      * Increment the variable's value. If the object is unshared we can      * modify it directly, otherwise we must create a new copy to modify:      * this is "copy on write". Then free the variable's old string      * representation, if any, since it will no longer be valid.      */
name|createdNewObj
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|varValuePtr
argument_list|)
condition|)
block|{
name|varValuePtr
operator|=
name|Tcl_DuplicateObj
argument_list|(
name|varValuePtr
argument_list|)
expr_stmt|;
name|createdNewObj
operator|=
literal|1
expr_stmt|;
block|}
name|result
operator|=
name|Tcl_GetLongFromObj
argument_list|(
name|interp
argument_list|,
name|varValuePtr
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|createdNewObj
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|varValuePtr
argument_list|)
expr_stmt|;
comment|/* free unneeded copy */
block|}
return|return
name|NULL
return|;
block|}
name|Tcl_SetLongObj
argument_list|(
name|varValuePtr
argument_list|,
operator|(
name|i
operator|+
name|incrAmount
operator|)
argument_list|)
expr_stmt|;
comment|/*      * Store the variable's new value and run any write traces.      */
name|resultPtr
operator|=
name|Tcl_ObjSetVar2
argument_list|(
name|interp
argument_list|,
name|part1Ptr
argument_list|,
name|part2Ptr
argument_list|,
name|varValuePtr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|resultPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|resultPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclIncrIndexedScalar --  *  *	Increments the Tcl object value of a local scalar variable in the  *	active procedure, given its compile-time allocated index in the  *	procedure's array of local variables.  *  * Results:  *	Returns a pointer to the Tcl_Obj holding the new value of the  *	variable given by localIndex. If the specified variable doesn't  *	exist, or there is a clash in array usage, or an error occurs while  *	executing variable traces, then NULL is returned and a message will  *	be left in the interpreter's result.   *  * Side effects:  *	The value of the given variable is incremented by the specified  *	amount. The ref count for the returned object is _not_ incremented  *	to reflect the returned reference; if you want to keep a reference  *	to the object you must increment its ref count yourself.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Obj
modifier|*
name|TclIncrIndexedScalar
parameter_list|(
name|interp
parameter_list|,
name|localIndex
parameter_list|,
name|incrAmount
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Command interpreter in which variable is 				 * to be found. */
name|int
name|localIndex
decl_stmt|;
comment|/* Index of variable in procedure's array 				 * of local variables. */
name|long
name|incrAmount
decl_stmt|;
comment|/* Amount to be added to variable. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|varValuePtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|resultPtr
decl_stmt|;
name|int
name|createdNewObj
decl_stmt|;
comment|/* Set 1 if var's value object is shared 				 * so we must increment a copy (i.e. copy 				 * on write). */
name|long
name|i
decl_stmt|;
name|int
name|result
decl_stmt|;
name|varValuePtr
operator|=
name|TclGetIndexedScalar
argument_list|(
name|interp
argument_list|,
name|localIndex
argument_list|,
comment|/*leaveErrorMsg*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|varValuePtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
literal|"\n    (reading value of variable to increment)"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*      * Reach into the object's representation to extract and increment the      * variable's value. If the object is unshared we can modify it      * directly, otherwise we must create a new copy to modify: this is      * "copy on write". Then free the variable's old string representation,      * if any, since it will no longer be valid.      */
name|createdNewObj
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|varValuePtr
argument_list|)
condition|)
block|{
name|createdNewObj
operator|=
literal|1
expr_stmt|;
name|varValuePtr
operator|=
name|Tcl_DuplicateObj
argument_list|(
name|varValuePtr
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|Tcl_GetLongFromObj
argument_list|(
name|interp
argument_list|,
name|varValuePtr
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|createdNewObj
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|varValuePtr
argument_list|)
expr_stmt|;
comment|/* free unneeded copy */
block|}
return|return
name|NULL
return|;
block|}
name|Tcl_SetLongObj
argument_list|(
name|varValuePtr
argument_list|,
operator|(
name|i
operator|+
name|incrAmount
operator|)
argument_list|)
expr_stmt|;
comment|/*      * Store the variable's new value and run any write traces.      */
name|resultPtr
operator|=
name|TclSetIndexedScalar
argument_list|(
name|interp
argument_list|,
name|localIndex
argument_list|,
name|varValuePtr
argument_list|,
comment|/*leaveErrorMsg*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|resultPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|resultPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclIncrElementOfIndexedArray --  *  *	Increments the Tcl object value of an element in a local array  *	variable. The element is named by the object elemPtr while the array  *	is specified by its index in the active procedure's array of  *	compiler allocated local variables.  *  * Results:  *	Returns a pointer to the Tcl_Obj holding the new value of the  *	element. If the specified array or element doesn't exist, or there  *	is a clash in array usage, or an error occurs while executing  *	variable traces, then NULL is returned and a message will be left in  *	the interpreter's result.  *  * Side effects:  *	The value of the given array element is incremented by the specified  *	amount. The ref count for the returned object is _not_ incremented  *	to reflect the returned reference; if you want to keep a reference  *	to the object you must increment its ref count yourself. If the  *	entry doesn't exist then a new variable is created.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Obj
modifier|*
name|TclIncrElementOfIndexedArray
parameter_list|(
name|interp
parameter_list|,
name|localIndex
parameter_list|,
name|elemPtr
parameter_list|,
name|incrAmount
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Command interpreter in which the array is 				 * to be found. */
name|int
name|localIndex
decl_stmt|;
comment|/* Index of array variable in procedure's 				 * array of local variables. */
name|Tcl_Obj
modifier|*
name|elemPtr
decl_stmt|;
comment|/* Points to an object holding the name of 				 * an element to increment in the array. */
name|long
name|incrAmount
decl_stmt|;
comment|/* Amount to be added to variable. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|varValuePtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|resultPtr
decl_stmt|;
name|int
name|createdNewObj
decl_stmt|;
comment|/* Set 1 if var's value object is shared 				 * so we must increment a copy (i.e. copy 				 * on write). */
name|long
name|i
decl_stmt|;
name|int
name|result
decl_stmt|;
name|varValuePtr
operator|=
name|TclGetElementOfIndexedArray
argument_list|(
name|interp
argument_list|,
name|localIndex
argument_list|,
name|elemPtr
argument_list|,
comment|/*leaveErrorMsg*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|varValuePtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
literal|"\n    (reading value of variable to increment)"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*      * Reach into the object's representation to extract and increment the      * variable's value. If the object is unshared we can modify it      * directly, otherwise we must create a new copy to modify: this is      * "copy on write". Then free the variable's old string representation,      * if any, since it will no longer be valid.      */
name|createdNewObj
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|varValuePtr
argument_list|)
condition|)
block|{
name|createdNewObj
operator|=
literal|1
expr_stmt|;
name|varValuePtr
operator|=
name|Tcl_DuplicateObj
argument_list|(
name|varValuePtr
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|Tcl_GetLongFromObj
argument_list|(
name|interp
argument_list|,
name|varValuePtr
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|createdNewObj
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|varValuePtr
argument_list|)
expr_stmt|;
comment|/* free unneeded copy */
block|}
return|return
name|NULL
return|;
block|}
name|Tcl_SetLongObj
argument_list|(
name|varValuePtr
argument_list|,
operator|(
name|i
operator|+
name|incrAmount
operator|)
argument_list|)
expr_stmt|;
comment|/*      * Store the variable's new value and run any write traces.      */
name|resultPtr
operator|=
name|TclSetElementOfIndexedArray
argument_list|(
name|interp
argument_list|,
name|localIndex
argument_list|,
name|elemPtr
argument_list|,
name|varValuePtr
argument_list|,
comment|/*leaveErrorMsg*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|resultPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|resultPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_UnsetVar --  *  *	Delete a variable, so that it may not be accessed anymore.  *  * Results:  *	Returns TCL_OK if the variable was successfully deleted, TCL_ERROR  *	if the variable can't be unset.  In the event of an error,  *	if the TCL_LEAVE_ERR_MSG flag is set then an error message  *	is left in interp->result.  *  * Side effects:  *	If varName is defined as a local or global variable in interp,  *	it is deleted.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_UnsetVar
parameter_list|(
name|interp
parameter_list|,
name|varName
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Command interpreter in which varName is 				 * to be looked up. */
name|char
modifier|*
name|varName
decl_stmt|;
comment|/* Name of a variable in interp.  May be 				 * either a scalar name or an array name 				 * or an element in an array. */
name|int
name|flags
decl_stmt|;
comment|/* OR-ed combination of any of 				 * TCL_GLOBAL_ONLY, TCL_NAMESPACE_ONLY or 				 * TCL_LEAVE_ERR_MSG. */
block|{
return|return
name|Tcl_UnsetVar2
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|flags
operator||
name|TCL_PARSE_PART1
operator|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_UnsetVar2 --  *  *	Delete a variable, given a 2-part name.  *  * Results:  *	Returns TCL_OK if the variable was successfully deleted, TCL_ERROR  *	if the variable can't be unset.  In the event of an error,  *	if the TCL_LEAVE_ERR_MSG flag is set then an error message  *	is left in interp->result.  *  * Side effects:  *	If part1 and part2 indicate a local or global variable in interp,  *	it is deleted.  If part1 is an array name and part2 is NULL, then  *	the whole array is deleted.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_UnsetVar2
parameter_list|(
name|interp
parameter_list|,
name|part1
parameter_list|,
name|part2
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Command interpreter in which varName is 				 * to be looked up. */
name|char
modifier|*
name|part1
decl_stmt|;
comment|/* Name of variable or array. */
name|char
modifier|*
name|part2
decl_stmt|;
comment|/* Name of element within array or NULL. */
name|int
name|flags
decl_stmt|;
comment|/* OR-ed combination of any of 				 * TCL_GLOBAL_ONLY, TCL_NAMESPACE_ONLY, 				 * TCL_LEAVE_ERR_MSG, or 				 * TCL_PARSE_PART1. */
block|{
name|Var
name|dummyVar
decl_stmt|;
name|Var
modifier|*
name|varPtr
decl_stmt|,
modifier|*
name|dummyVarPtr
decl_stmt|;
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Var
modifier|*
name|arrayPtr
decl_stmt|;
name|ActiveVarTrace
modifier|*
name|activePtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|int
name|result
decl_stmt|;
name|varPtr
operator|=
name|TclLookupVar
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
name|flags
argument_list|,
literal|"unset"
argument_list|,
comment|/*createPart1*/
literal|0
argument_list|,
comment|/*createPart2*/
literal|0
argument_list|,
operator|&
name|arrayPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|varPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|result
operator|=
operator|(
name|TclIsVarUndefined
argument_list|(
name|varPtr
argument_list|)
condition|?
name|TCL_ERROR
else|:
name|TCL_OK
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|arrayPtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|arrayPtr
operator|->
name|searchPtr
operator|!=
name|NULL
operator|)
condition|)
block|{
name|DeleteSearches
argument_list|(
name|arrayPtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * The code below is tricky, because of the possibility that      * a trace procedure might try to access a variable being      * deleted. To handle this situation gracefully, do things      * in three steps:      * 1. Copy the contents of the variable to a dummy variable      *    structure, and mark the original Var structure as undefined.      * 2. Invoke traces and clean up the variable, using the dummy copy.      * 3. If at the end of this the original variable is still      *    undefined and has no outstanding references, then delete      *	  it (but it could have gotten recreated by a trace).      */
name|dummyVar
operator|=
operator|*
name|varPtr
expr_stmt|;
name|TclSetVarUndefined
argument_list|(
name|varPtr
argument_list|)
expr_stmt|;
name|TclSetVarScalar
argument_list|(
name|varPtr
argument_list|)
expr_stmt|;
name|varPtr
operator|->
name|value
operator|.
name|objPtr
operator|=
name|NULL
expr_stmt|;
comment|/* dummyVar points to any value object */
name|varPtr
operator|->
name|tracePtr
operator|=
name|NULL
expr_stmt|;
name|varPtr
operator|->
name|searchPtr
operator|=
name|NULL
expr_stmt|;
comment|/*      * Call trace procedures for the variable being deleted. Then delete      * its traces. Be sure to abort any other traces for the variable      * that are still pending. Special tricks:      * 1. We need to increment varPtr's refCount around this: CallTraces      *    will use dummyVar so it won't increment varPtr's refCount itself.      * 2. Turn off the VAR_TRACE_ACTIVE flag in dummyVar: we want to      *    call unset traces even if other traces are pending.      */
if|if
condition|(
operator|(
name|dummyVar
operator|.
name|tracePtr
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
name|arrayPtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|arrayPtr
operator|->
name|tracePtr
operator|!=
name|NULL
operator|)
operator|)
condition|)
block|{
name|varPtr
operator|->
name|refCount
operator|++
expr_stmt|;
name|dummyVar
operator|.
name|flags
operator|&=
operator|~
name|VAR_TRACE_ACTIVE
expr_stmt|;
operator|(
name|void
operator|)
name|CallTraces
argument_list|(
name|iPtr
argument_list|,
name|arrayPtr
argument_list|,
operator|&
name|dummyVar
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
operator|(
name|flags
operator|&
operator|(
name|TCL_GLOBAL_ONLY
operator||
name|TCL_NAMESPACE_ONLY
operator||
name|TCL_PARSE_PART1
operator|)
operator|)
operator||
name|TCL_TRACE_UNSETS
argument_list|)
expr_stmt|;
while|while
condition|(
name|dummyVar
operator|.
name|tracePtr
operator|!=
name|NULL
condition|)
block|{
name|VarTrace
modifier|*
name|tracePtr
init|=
name|dummyVar
operator|.
name|tracePtr
decl_stmt|;
name|dummyVar
operator|.
name|tracePtr
operator|=
name|tracePtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tracePtr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|activePtr
operator|=
name|iPtr
operator|->
name|activeTracePtr
init|;
name|activePtr
operator|!=
name|NULL
condition|;
name|activePtr
operator|=
name|activePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|activePtr
operator|->
name|varPtr
operator|==
name|varPtr
condition|)
block|{
name|activePtr
operator|->
name|nextTracePtr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|varPtr
operator|->
name|refCount
operator|--
expr_stmt|;
block|}
comment|/*      * If the variable is an array, delete all of its elements. This must be      * done after calling the traces on the array, above (that's the way      * traces are defined). If it is a scalar, "discard" its object      * (decrement the ref count of its object, if any).      */
name|dummyVarPtr
operator|=
operator|&
name|dummyVar
expr_stmt|;
if|if
condition|(
name|TclIsVarArray
argument_list|(
name|dummyVarPtr
argument_list|)
operator|&&
operator|!
name|TclIsVarUndefined
argument_list|(
name|dummyVarPtr
argument_list|)
condition|)
block|{
name|DeleteArray
argument_list|(
name|iPtr
argument_list|,
name|part1
argument_list|,
name|dummyVarPtr
argument_list|,
operator|(
name|flags
operator|&
operator|(
name|TCL_GLOBAL_ONLY
operator||
name|TCL_NAMESPACE_ONLY
operator|)
operator|)
operator||
name|TCL_TRACE_UNSETS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TclIsVarScalar
argument_list|(
name|dummyVarPtr
argument_list|)
operator|&&
operator|(
name|dummyVarPtr
operator|->
name|value
operator|.
name|objPtr
operator|!=
name|NULL
operator|)
condition|)
block|{
name|objPtr
operator|=
name|dummyVarPtr
operator|->
name|value
operator|.
name|objPtr
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|dummyVarPtr
operator|->
name|value
operator|.
name|objPtr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*      * If the variable was a namespace variable, decrement its reference      * count. We are in the process of destroying its namespace so that      * namespace will no longer "refer" to the variable.      */
if|if
condition|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_NAMESPACE_VAR
condition|)
block|{
name|varPtr
operator|->
name|flags
operator|&=
operator|~
name|VAR_NAMESPACE_VAR
expr_stmt|;
name|varPtr
operator|->
name|refCount
operator|--
expr_stmt|;
block|}
comment|/*      * It's an error to unset an undefined variable.      */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TCL_LEAVE_ERR_MSG
condition|)
block|{
name|VarErrMsg
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
literal|"unset"
argument_list|,
operator|(
operator|(
name|arrayPtr
operator|==
name|NULL
operator|)
condition|?
name|noSuchVar
else|:
name|noSuchElement
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Finally, if the variable is truly not in use then free up its Var      * structure and remove it from its hash table, if any. The ref count of      * its value object, if any, was decremented above.      */
name|CleanupVar
argument_list|(
name|varPtr
argument_list|,
name|arrayPtr
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_TraceVar --  *  *	Arrange for reads and/or writes to a variable to cause a  *	procedure to be invoked, which can monitor the operations  *	and/or change their actions.  *  * Results:  *	A standard Tcl return value.  *  * Side effects:  *	A trace is set up on the variable given by varName, such that  *	future references to the variable will be intermediated by  *	proc.  See the manual entry for complete details on the calling  *	sequence for proc.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_TraceVar
parameter_list|(
name|interp
parameter_list|,
name|varName
parameter_list|,
name|flags
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which variable is 				 * to be traced. */
name|char
modifier|*
name|varName
decl_stmt|;
comment|/* Name of variable;  may end with "(index)" 				 * to signify an array reference. */
name|int
name|flags
decl_stmt|;
comment|/* OR-ed collection of bits, including any 				 * of TCL_TRACE_READS, TCL_TRACE_WRITES, 				 * TCL_TRACE_UNSETS, TCL_GLOBAL_ONLY, and 				 * TCL_NAMESPACE_ONLY. */
name|Tcl_VarTraceProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to call when specified ops are 				 * invoked upon varName. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary argument to pass to proc. */
block|{
return|return
name|Tcl_TraceVar2
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|flags
operator||
name|TCL_PARSE_PART1
operator|)
argument_list|,
name|proc
argument_list|,
name|clientData
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_TraceVar2 --  *  *	Arrange for reads and/or writes to a variable to cause a  *	procedure to be invoked, which can monitor the operations  *	and/or change their actions.  *  * Results:  *	A standard Tcl return value.  *  * Side effects:  *	A trace is set up on the variable given by part1 and part2, such  *	that future references to the variable will be intermediated by  *	proc.  See the manual entry for complete details on the calling  *	sequence for proc.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_TraceVar2
parameter_list|(
name|interp
parameter_list|,
name|part1
parameter_list|,
name|part2
parameter_list|,
name|flags
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which variable is 				 * to be traced. */
name|char
modifier|*
name|part1
decl_stmt|;
comment|/* Name of scalar variable or array. */
name|char
modifier|*
name|part2
decl_stmt|;
comment|/* Name of element within array;  NULL means 				 * trace applies to scalar variable or array 				 * as-a-whole. */
name|int
name|flags
decl_stmt|;
comment|/* OR-ed collection of bits, including any 				 * of TCL_TRACE_READS, TCL_TRACE_WRITES, 				 * TCL_TRACE_UNSETS, TCL_GLOBAL_ONLY, 				 * TCL_NAMESPACE_ONLY and 				 * TCL_PARSE_PART1. */
name|Tcl_VarTraceProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to call when specified ops are 				 * invoked upon varName. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary argument to pass to proc. */
block|{
name|Var
modifier|*
name|varPtr
decl_stmt|,
modifier|*
name|arrayPtr
decl_stmt|;
specifier|register
name|VarTrace
modifier|*
name|tracePtr
decl_stmt|;
name|varPtr
operator|=
name|TclLookupVar
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
operator|(
name|flags
operator||
name|TCL_LEAVE_ERR_MSG
operator|)
argument_list|,
literal|"trace"
argument_list|,
comment|/*createPart1*/
literal|1
argument_list|,
comment|/*createPart2*/
literal|1
argument_list|,
operator|&
name|arrayPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|varPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Set up trace information.      */
name|tracePtr
operator|=
operator|(
name|VarTrace
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|VarTrace
argument_list|)
argument_list|)
expr_stmt|;
name|tracePtr
operator|->
name|traceProc
operator|=
name|proc
expr_stmt|;
name|tracePtr
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
name|tracePtr
operator|->
name|flags
operator|=
name|flags
operator|&
operator|(
name|TCL_TRACE_READS
operator||
name|TCL_TRACE_WRITES
operator||
name|TCL_TRACE_UNSETS
operator|)
expr_stmt|;
name|tracePtr
operator|->
name|nextPtr
operator|=
name|varPtr
operator|->
name|tracePtr
expr_stmt|;
name|varPtr
operator|->
name|tracePtr
operator|=
name|tracePtr
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_UntraceVar --  *  *	Remove a previously-created trace for a variable.  *  * Results:  *	None.  *  * Side effects:  *	If there exists a trace for the variable given by varName  *	with the given flags, proc, and clientData, then that trace  *	is removed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_UntraceVar
parameter_list|(
name|interp
parameter_list|,
name|varName
parameter_list|,
name|flags
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter containing variable. */
name|char
modifier|*
name|varName
decl_stmt|;
comment|/* Name of variable; may end with "(index)" 				 * to signify an array reference. */
name|int
name|flags
decl_stmt|;
comment|/* OR-ed collection of bits describing 				 * current trace, including any of 				 * TCL_TRACE_READS, TCL_TRACE_WRITES, 				 * TCL_TRACE_UNSETS, TCL_GLOBAL_ONLY 				 * and TCL_NAMESPACE_ONLY. */
name|Tcl_VarTraceProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure assocated with trace. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary argument to pass to proc. */
block|{
name|Tcl_UntraceVar2
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|flags
operator||
name|TCL_PARSE_PART1
operator|)
argument_list|,
name|proc
argument_list|,
name|clientData
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_UntraceVar2 --  *  *	Remove a previously-created trace for a variable.  *  * Results:  *	None.  *  * Side effects:  *	If there exists a trace for the variable given by part1  *	and part2 with the given flags, proc, and clientData, then  *	that trace is removed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_UntraceVar2
parameter_list|(
name|interp
parameter_list|,
name|part1
parameter_list|,
name|part2
parameter_list|,
name|flags
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter containing variable. */
name|char
modifier|*
name|part1
decl_stmt|;
comment|/* Name of variable or array. */
name|char
modifier|*
name|part2
decl_stmt|;
comment|/* Name of element within array;  NULL means 				 * trace applies to scalar variable or array 				 * as-a-whole. */
name|int
name|flags
decl_stmt|;
comment|/* OR-ed collection of bits describing 				 * current trace, including any of 				 * TCL_TRACE_READS, TCL_TRACE_WRITES, 				 * TCL_TRACE_UNSETS, TCL_GLOBAL_ONLY, 				 * TCL_NAMESPACE_ONLY and 				 * TCL_PARSE_PART1. */
name|Tcl_VarTraceProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure assocated with trace. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary argument to pass to proc. */
block|{
specifier|register
name|VarTrace
modifier|*
name|tracePtr
decl_stmt|;
name|VarTrace
modifier|*
name|prevPtr
decl_stmt|;
name|Var
modifier|*
name|varPtr
decl_stmt|,
modifier|*
name|arrayPtr
decl_stmt|;
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|ActiveVarTrace
modifier|*
name|activePtr
decl_stmt|;
name|varPtr
operator|=
name|TclLookupVar
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
name|flags
operator|&
operator|(
name|TCL_GLOBAL_ONLY
operator||
name|TCL_NAMESPACE_ONLY
operator||
name|TCL_PARSE_PART1
operator|)
argument_list|,
comment|/*msg*/
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
comment|/*createPart1*/
literal|0
argument_list|,
comment|/*createPart2*/
literal|0
argument_list|,
operator|&
name|arrayPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|varPtr
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|flags
operator|&=
operator|(
name|TCL_TRACE_READS
operator||
name|TCL_TRACE_WRITES
operator||
name|TCL_TRACE_UNSETS
operator|)
expr_stmt|;
for|for
control|(
name|tracePtr
operator|=
name|varPtr
operator|->
name|tracePtr
operator|,
name|prevPtr
operator|=
name|NULL
init|;
condition|;
name|prevPtr
operator|=
name|tracePtr
operator|,
name|tracePtr
operator|=
name|tracePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|tracePtr
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|(
name|tracePtr
operator|->
name|traceProc
operator|==
name|proc
operator|)
operator|&&
operator|(
name|tracePtr
operator|->
name|flags
operator|==
name|flags
operator|)
operator|&&
operator|(
name|tracePtr
operator|->
name|clientData
operator|==
name|clientData
operator|)
condition|)
block|{
break|break;
block|}
block|}
comment|/*      * The code below makes it possible to delete traces while traces      * are active: it makes sure that the deleted trace won't be      * processed by CallTraces.      */
for|for
control|(
name|activePtr
operator|=
name|iPtr
operator|->
name|activeTracePtr
init|;
name|activePtr
operator|!=
name|NULL
condition|;
name|activePtr
operator|=
name|activePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|activePtr
operator|->
name|nextTracePtr
operator|==
name|tracePtr
condition|)
block|{
name|activePtr
operator|->
name|nextTracePtr
operator|=
name|tracePtr
operator|->
name|nextPtr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|prevPtr
operator|==
name|NULL
condition|)
block|{
name|varPtr
operator|->
name|tracePtr
operator|=
name|tracePtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
name|prevPtr
operator|->
name|nextPtr
operator|=
name|tracePtr
operator|->
name|nextPtr
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tracePtr
argument_list|)
expr_stmt|;
comment|/*      * If this is the last trace on the variable, and the variable is      * unset and unused, then free up the variable.      */
if|if
condition|(
name|TclIsVarUndefined
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
name|CleanupVar
argument_list|(
name|varPtr
argument_list|,
operator|(
name|Var
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_VarTraceInfo --  *  *	Return the clientData value associated with a trace on a  *	variable.  This procedure can also be used to step through  *	all of the traces on a particular variable that have the  *	same trace procedure.  *  * Results:  *	The return value is the clientData value associated with  *	a trace on the given variable.  Information will only be  *	returned for a trace with proc as trace procedure.  If  *	the clientData argument is NULL then the first such trace is  *	returned;  otherwise, the next relevant one after the one  *	given by clientData will be returned.  If the variable  *	doesn't exist, or if there are no (more) traces for it,  *	then NULL is returned.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|ClientData
name|Tcl_VarTraceInfo
parameter_list|(
name|interp
parameter_list|,
name|varName
parameter_list|,
name|flags
parameter_list|,
name|proc
parameter_list|,
name|prevClientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter containing variable. */
name|char
modifier|*
name|varName
decl_stmt|;
comment|/* Name of variable;  may end with "(index)" 				 * to signify an array reference. */
name|int
name|flags
decl_stmt|;
comment|/* 0, TCL_GLOBAL_ONLY, or 				 * TCL_NAMESPACE_ONLY. */
name|Tcl_VarTraceProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure assocated with trace. */
name|ClientData
name|prevClientData
decl_stmt|;
comment|/* If non-NULL, gives last value returned 				 * by this procedure, so this call will 				 * return the next trace after that one. 				 * If NULL, this call will return the 				 * first trace. */
block|{
return|return
name|Tcl_VarTraceInfo2
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|flags
operator||
name|TCL_PARSE_PART1
operator|)
argument_list|,
name|proc
argument_list|,
name|prevClientData
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_VarTraceInfo2 --  *  *	Same as Tcl_VarTraceInfo, except takes name in two pieces  *	instead of one.  *  * Results:  *	Same as Tcl_VarTraceInfo.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|ClientData
name|Tcl_VarTraceInfo2
parameter_list|(
name|interp
parameter_list|,
name|part1
parameter_list|,
name|part2
parameter_list|,
name|flags
parameter_list|,
name|proc
parameter_list|,
name|prevClientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter containing variable. */
name|char
modifier|*
name|part1
decl_stmt|;
comment|/* Name of variable or array. */
name|char
modifier|*
name|part2
decl_stmt|;
comment|/* Name of element within array;  NULL means 				 * trace applies to scalar variable or array 				 * as-a-whole. */
name|int
name|flags
decl_stmt|;
comment|/* OR-ed combination of TCL_GLOBAL_ONLY, 				 * TCL_NAMESPACE_ONLY, and 				 * TCL_PARSE_PART1. */
name|Tcl_VarTraceProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure assocated with trace. */
name|ClientData
name|prevClientData
decl_stmt|;
comment|/* If non-NULL, gives last value returned 				 * by this procedure, so this call will 				 * return the next trace after that one. 				 * If NULL, this call will return the 				 * first trace. */
block|{
specifier|register
name|VarTrace
modifier|*
name|tracePtr
decl_stmt|;
name|Var
modifier|*
name|varPtr
decl_stmt|,
modifier|*
name|arrayPtr
decl_stmt|;
name|varPtr
operator|=
name|TclLookupVar
argument_list|(
name|interp
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
name|flags
operator|&
operator|(
name|TCL_GLOBAL_ONLY
operator||
name|TCL_NAMESPACE_ONLY
operator||
name|TCL_PARSE_PART1
operator|)
argument_list|,
comment|/*msg*/
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
comment|/*createPart1*/
literal|0
argument_list|,
comment|/*createPart2*/
literal|0
argument_list|,
operator|&
name|arrayPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|varPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|/*      * Find the relevant trace, if any, and return its clientData.      */
name|tracePtr
operator|=
name|varPtr
operator|->
name|tracePtr
expr_stmt|;
if|if
condition|(
name|prevClientData
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
name|tracePtr
operator|!=
name|NULL
condition|;
name|tracePtr
operator|=
name|tracePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
operator|(
name|tracePtr
operator|->
name|clientData
operator|==
name|prevClientData
operator|)
operator|&&
operator|(
name|tracePtr
operator|->
name|traceProc
operator|==
name|proc
operator|)
condition|)
block|{
name|tracePtr
operator|=
name|tracePtr
operator|->
name|nextPtr
expr_stmt|;
break|break;
block|}
block|}
block|}
for|for
control|(
init|;
name|tracePtr
operator|!=
name|NULL
condition|;
name|tracePtr
operator|=
name|tracePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|tracePtr
operator|->
name|traceProc
operator|==
name|proc
condition|)
block|{
return|return
name|tracePtr
operator|->
name|clientData
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_UnsetObjCmd --  *  *	This object-based procedure is invoked to process the "unset" Tcl  *	command. See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl object result value.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_UnsetObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"varName ?varName ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
comment|/* 	 * THIS FAILS IF A NAME OBJECT'S STRING REP HAS A NULL BYTE. 	 */
name|name
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_UnsetVar2
argument_list|(
name|interp
argument_list|,
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|TCL_LEAVE_ERR_MSG
operator||
name|TCL_PARSE_PART1
operator|)
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_AppendObjCmd --  *  *	This object-based procedure is invoked to process the "append"   *	Tcl command. See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl object result value.  *  * Side effects:  *	A variable's value may be changed.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_AppendObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|varValuePtr
init|=
name|NULL
decl_stmt|;
comment|/* Initialized to avoid compiler 				         * warning. */
name|int
name|i
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"varName ?value value ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|objc
operator|==
literal|2
condition|)
block|{
name|varValuePtr
operator|=
name|Tcl_ObjGetVar2
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|TCL_LEAVE_ERR_MSG
operator||
name|TCL_PARSE_PART1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|varValuePtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|varValuePtr
operator|=
name|Tcl_ObjSetVar2
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|)
name|NULL
argument_list|,
name|objv
index|[
name|i
index|]
argument_list|,
operator|(
name|TCL_APPEND_VALUE
operator||
name|TCL_LEAVE_ERR_MSG
operator||
name|TCL_PARSE_PART1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|varValuePtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|varValuePtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_LappendObjCmd --  *  *	This object-based procedure is invoked to process the "lappend"   *	Tcl command. See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl object result value.  *  * Side effects:  *	A variable's value may be changed.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_LappendObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Obj
modifier|*
name|varValuePtr
decl_stmt|,
modifier|*
name|newValuePtr
decl_stmt|;
specifier|register
name|List
modifier|*
name|listRepPtr
decl_stmt|;
specifier|register
name|Tcl_Obj
modifier|*
modifier|*
name|elemPtrs
decl_stmt|;
name|int
name|numElems
decl_stmt|,
name|numRequired
decl_stmt|,
name|createdNewObj
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"varName ?value value ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|objc
operator|==
literal|2
condition|)
block|{
name|newValuePtr
operator|=
name|Tcl_ObjGetVar2
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|TCL_LEAVE_ERR_MSG
operator||
name|TCL_PARSE_PART1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newValuePtr
operator|==
name|NULL
condition|)
block|{
comment|/* 	     * The variable doesn't exist yet. Just create it with an empty 	     * initial value. 	     */
name|Tcl_Obj
modifier|*
name|nullObjPtr
init|=
name|Tcl_NewObj
argument_list|()
decl_stmt|;
name|newValuePtr
operator|=
name|Tcl_ObjSetVar2
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
name|nullObjPtr
argument_list|,
operator|(
name|TCL_LEAVE_ERR_MSG
operator||
name|TCL_PARSE_PART1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newValuePtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|nullObjPtr
argument_list|)
expr_stmt|;
comment|/* free unneeded object */
return|return
name|TCL_ERROR
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* 	 * We have arguments to append. We used to call Tcl_ObjSetVar2 to 	 * append each argument one at a time to ensure that traces were run 	 * for each append step. We now append the arguments all at once 	 * because it's faster. Note that a read trace and a write trace for 	 * the variable will now each only be called once. Also, if the 	 * variable's old value is unshared we modify it directly, otherwise 	 * we create a new copy to modify: this is "copy on write". 	 */
name|createdNewObj
operator|=
literal|0
expr_stmt|;
name|varValuePtr
operator|=
name|Tcl_ObjGetVar2
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_PARSE_PART1
argument_list|)
expr_stmt|;
if|if
condition|(
name|varValuePtr
operator|==
name|NULL
condition|)
block|{
comment|/* no old value: append to new obj */
name|varValuePtr
operator|=
name|Tcl_NewObj
argument_list|()
expr_stmt|;
name|createdNewObj
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|varValuePtr
argument_list|)
condition|)
block|{
name|varValuePtr
operator|=
name|Tcl_DuplicateObj
argument_list|(
name|varValuePtr
argument_list|)
expr_stmt|;
name|createdNewObj
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Convert the variable's old value to a list object if necessary. 	 */
if|if
condition|(
name|varValuePtr
operator|->
name|typePtr
operator|!=
operator|&
name|tclListType
condition|)
block|{
name|int
name|result
init|=
name|tclListType
operator|.
name|setFromAnyProc
argument_list|(
name|interp
argument_list|,
name|varValuePtr
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|createdNewObj
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|varValuePtr
argument_list|)
expr_stmt|;
comment|/* free unneeded obj. */
block|}
return|return
name|result
return|;
block|}
block|}
name|listRepPtr
operator|=
operator|(
name|List
operator|*
operator|)
name|varValuePtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
expr_stmt|;
name|elemPtrs
operator|=
name|listRepPtr
operator|->
name|elements
expr_stmt|;
name|numElems
operator|=
name|listRepPtr
operator|->
name|elemCount
expr_stmt|;
comment|/* 	 * If there is no room in the current array of element pointers, 	 * allocate a new, larger array and copy the pointers to it. 	 */
name|numRequired
operator|=
name|numElems
operator|+
operator|(
name|objc
operator|-
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|numRequired
operator|>
name|listRepPtr
operator|->
name|maxElemCount
condition|)
block|{
name|int
name|newMax
init|=
operator|(
literal|2
operator|*
name|numRequired
operator|)
decl_stmt|;
name|Tcl_Obj
modifier|*
modifier|*
name|newElemPtrs
init|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|newMax
operator|*
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|newElemPtrs
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|elemPtrs
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|numElems
operator|*
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|listRepPtr
operator|->
name|maxElemCount
operator|=
name|newMax
expr_stmt|;
name|listRepPtr
operator|->
name|elements
operator|=
name|newElemPtrs
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|elemPtrs
argument_list|)
expr_stmt|;
name|elemPtrs
operator|=
name|newElemPtrs
expr_stmt|;
block|}
comment|/* 	 * Insert the new elements at the end of the list. 	 */
for|for
control|(
name|i
operator|=
literal|2
operator|,
name|j
operator|=
name|numElems
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|elemPtrs
index|[
name|j
index|]
operator|=
name|objv
index|[
name|i
index|]
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|listRepPtr
operator|->
name|elemCount
operator|=
name|numRequired
expr_stmt|;
comment|/* 	 * Invalidate and free any old string representation since it no 	 * longer reflects the list's internal representation. 	 */
name|Tcl_InvalidateStringRep
argument_list|(
name|varValuePtr
argument_list|)
expr_stmt|;
comment|/* 	 * Now store the list object back into the variable. If there is an 	 * error setting the new value, decrement its ref count if it 	 * was new. 	 */
name|newValuePtr
operator|=
name|Tcl_ObjSetVar2
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|)
name|NULL
argument_list|,
name|varValuePtr
argument_list|,
operator|(
name|TCL_LEAVE_ERR_MSG
operator||
name|TCL_PARSE_PART1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newValuePtr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|createdNewObj
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|varValuePtr
argument_list|)
expr_stmt|;
comment|/* free unneeded obj */
block|}
return|return
name|TCL_ERROR
return|;
block|}
block|}
comment|/*      * Set the interpreter's object result to refer to the variable's value      * object.      */
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|newValuePtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ArrayObjCmd --  *  *	This object-based procedure is invoked to process the "array" Tcl  *	command. See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result object.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_ArrayObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
specifier|static
name|char
modifier|*
name|arrayOptions
index|[]
init|=
block|{
literal|"anymore"
block|,
literal|"donesearch"
block|,
literal|"exists"
block|,
literal|"get"
block|,
literal|"names"
block|,
literal|"nextelement"
block|,
literal|"set"
block|,
literal|"size"
block|,
literal|"startsearch"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
name|Var
modifier|*
name|varPtr
decl_stmt|,
modifier|*
name|arrayPtr
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|resultPtr
init|=
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
decl_stmt|;
name|int
name|notArray
decl_stmt|;
name|char
modifier|*
name|varName
decl_stmt|;
name|int
name|index
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"option arrayName ?arg ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetIndexFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|,
name|arrayOptions
argument_list|,
literal|"option"
argument_list|,
literal|0
argument_list|,
operator|&
name|index
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Locate the array variable (and it better be an array).      * THIS FAILS IF A NAME OBJECT'S STRING REP HAS A NULL BYTE.      */
name|varName
operator|=
name|TclGetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|varPtr
operator|=
name|TclLookupVar
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
comment|/*msg*/
literal|0
argument_list|,
comment|/*createPart1*/
literal|0
argument_list|,
comment|/*createPart2*/
literal|0
argument_list|,
operator|&
name|arrayPtr
argument_list|)
expr_stmt|;
name|notArray
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|varPtr
operator|==
name|NULL
condition|)
block|{
name|notArray
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|TclIsVarArray
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
name|notArray
operator|=
literal|1
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|index
condition|)
block|{
case|case
literal|0
case|:
block|{
comment|/* anymore */
name|ArraySearch
modifier|*
name|searchPtr
decl_stmt|;
name|char
modifier|*
name|searchId
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"arrayName searchId"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|notArray
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|searchId
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|searchPtr
operator|=
name|ParseSearchId
argument_list|(
name|interp
argument_list|,
name|varPtr
argument_list|,
name|varName
argument_list|,
name|searchId
argument_list|)
expr_stmt|;
if|if
condition|(
name|searchPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|Var
modifier|*
name|varPtr2
decl_stmt|;
if|if
condition|(
name|searchPtr
operator|->
name|nextEntry
operator|!=
name|NULL
condition|)
block|{
name|varPtr2
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|searchPtr
operator|->
name|nextEntry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TclIsVarUndefined
argument_list|(
name|varPtr2
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
name|searchPtr
operator|->
name|nextEntry
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|searchPtr
operator|->
name|search
argument_list|)
expr_stmt|;
if|if
condition|(
name|searchPtr
operator|->
name|nextEntry
operator|==
name|NULL
condition|)
block|{
name|Tcl_SetIntObj
argument_list|(
name|resultPtr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
block|}
name|Tcl_SetIntObj
argument_list|(
name|resultPtr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|1
case|:
block|{
comment|/* donesearch */
name|ArraySearch
modifier|*
name|searchPtr
decl_stmt|,
modifier|*
name|prevPtr
decl_stmt|;
name|char
modifier|*
name|searchId
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"arrayName searchId"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|notArray
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|searchId
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|searchPtr
operator|=
name|ParseSearchId
argument_list|(
name|interp
argument_list|,
name|varPtr
argument_list|,
name|varName
argument_list|,
name|searchId
argument_list|)
expr_stmt|;
if|if
condition|(
name|searchPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|varPtr
operator|->
name|searchPtr
operator|==
name|searchPtr
condition|)
block|{
name|varPtr
operator|->
name|searchPtr
operator|=
name|searchPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|prevPtr
operator|=
name|varPtr
operator|->
name|searchPtr
init|;
condition|;
name|prevPtr
operator|=
name|prevPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|prevPtr
operator|->
name|nextPtr
operator|==
name|searchPtr
condition|)
block|{
name|prevPtr
operator|->
name|nextPtr
operator|=
name|searchPtr
operator|->
name|nextPtr
expr_stmt|;
break|break;
block|}
block|}
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|searchPtr
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|2
case|:
block|{
comment|/* exists */
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"arrayName"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_SetIntObj
argument_list|(
name|resultPtr
argument_list|,
operator|!
name|notArray
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|3
case|:
block|{
comment|/*get*/
name|Tcl_HashSearch
name|search
decl_stmt|;
name|Var
modifier|*
name|varPtr2
decl_stmt|;
name|char
modifier|*
name|pattern
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|Tcl_Obj
modifier|*
name|namePtr
decl_stmt|,
modifier|*
name|valuePtr
decl_stmt|;
if|if
condition|(
operator|(
name|objc
operator|!=
literal|3
operator|)
operator|&&
operator|(
name|objc
operator|!=
literal|4
operator|)
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"arrayName ?pattern?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|notArray
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|objc
operator|==
literal|4
condition|)
block|{
name|pattern
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
name|varPtr2
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TclIsVarUndefined
argument_list|(
name|varPtr2
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|name
operator|=
name|Tcl_GetHashKey
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|,
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|objc
operator|==
literal|4
operator|)
operator|&&
operator|!
name|Tcl_StringMatch
argument_list|(
name|name
argument_list|,
name|pattern
argument_list|)
condition|)
block|{
continue|continue;
comment|/* element name doesn't match pattern */
block|}
name|namePtr
operator|=
name|Tcl_NewStringObj
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|resultPtr
argument_list|,
name|namePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
comment|/* free unneeded name object */
return|return
name|result
return|;
block|}
if|if
condition|(
name|varPtr2
operator|->
name|value
operator|.
name|objPtr
operator|==
name|NULL
condition|)
block|{
name|TclNewObj
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|valuePtr
operator|=
name|varPtr2
operator|->
name|value
operator|.
name|objPtr
expr_stmt|;
block|}
name|result
operator|=
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|resultPtr
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|varPtr2
operator|->
name|value
operator|.
name|objPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
comment|/* free unneeded object */
block|}
return|return
name|result
return|;
block|}
block|}
break|break;
block|}
case|case
literal|4
case|:
block|{
comment|/* names */
name|Tcl_HashSearch
name|search
decl_stmt|;
name|Var
modifier|*
name|varPtr2
decl_stmt|;
name|char
modifier|*
name|pattern
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|Tcl_Obj
modifier|*
name|namePtr
decl_stmt|;
if|if
condition|(
operator|(
name|objc
operator|!=
literal|3
operator|)
operator|&&
operator|(
name|objc
operator|!=
literal|4
operator|)
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"arrayName ?pattern?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|notArray
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|objc
operator|==
literal|4
condition|)
block|{
name|pattern
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
name|varPtr2
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TclIsVarUndefined
argument_list|(
name|varPtr2
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|name
operator|=
name|Tcl_GetHashKey
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|,
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|objc
operator|==
literal|4
operator|)
operator|&&
operator|!
name|Tcl_StringMatch
argument_list|(
name|name
argument_list|,
name|pattern
argument_list|)
condition|)
block|{
continue|continue;
comment|/* element name doesn't match pattern */
block|}
name|namePtr
operator|=
name|Tcl_NewStringObj
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|resultPtr
argument_list|,
name|namePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
comment|/* free unneeded name object */
return|return
name|result
return|;
block|}
block|}
break|break;
block|}
case|case
literal|5
case|:
block|{
comment|/*nextelement*/
name|ArraySearch
modifier|*
name|searchPtr
decl_stmt|;
name|char
modifier|*
name|searchId
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"arrayName searchId"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|notArray
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|searchId
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|searchPtr
operator|=
name|ParseSearchId
argument_list|(
name|interp
argument_list|,
name|varPtr
argument_list|,
name|varName
argument_list|,
name|searchId
argument_list|)
expr_stmt|;
if|if
condition|(
name|searchPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|Var
modifier|*
name|varPtr2
decl_stmt|;
name|hPtr
operator|=
name|searchPtr
operator|->
name|nextEntry
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
name|NULL
condition|)
block|{
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|searchPtr
operator|->
name|search
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
block|}
else|else
block|{
name|searchPtr
operator|->
name|nextEntry
operator|=
name|NULL
expr_stmt|;
block|}
name|varPtr2
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TclIsVarUndefined
argument_list|(
name|varPtr2
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
name|Tcl_SetStringObj
argument_list|(
name|resultPtr
argument_list|,
name|Tcl_GetHashKey
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|,
name|hPtr
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|6
case|:
block|{
comment|/*set*/
name|Tcl_Obj
modifier|*
modifier|*
name|elemPtrs
decl_stmt|;
name|int
name|listLen
decl_stmt|,
name|i
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"arrayName list"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|result
operator|=
name|Tcl_ListObjGetElements
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|listLen
argument_list|,
operator|&
name|elemPtrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
if|if
condition|(
name|listLen
operator|&
literal|1
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"list must have an even number of elements"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|listLen
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|Tcl_ObjSetVar2
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|,
name|elemPtrs
index|[
name|i
index|]
argument_list|,
name|elemPtrs
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
case|case
literal|7
case|:
block|{
comment|/*size*/
name|Tcl_HashSearch
name|search
decl_stmt|;
name|Var
modifier|*
name|varPtr2
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"arrayName"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|notArray
condition|)
block|{
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
name|varPtr2
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TclIsVarUndefined
argument_list|(
name|varPtr2
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|size
operator|++
expr_stmt|;
block|}
block|}
name|Tcl_SetIntObj
argument_list|(
name|resultPtr
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|8
case|:
block|{
comment|/*startsearch*/
name|ArraySearch
modifier|*
name|searchPtr
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"arrayName"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|notArray
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|searchPtr
operator|=
operator|(
name|ArraySearch
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ArraySearch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|varPtr
operator|->
name|searchPtr
operator|==
name|NULL
condition|)
block|{
name|searchPtr
operator|->
name|id
operator|=
literal|1
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|resultPtr
argument_list|,
literal|"s-1-"
argument_list|,
name|varName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|string
index|[
literal|20
index|]
decl_stmt|;
name|searchPtr
operator|->
name|id
operator|=
name|varPtr
operator|->
name|searchPtr
operator|->
name|id
operator|+
literal|1
expr_stmt|;
name|TclFormatInt
argument_list|(
name|string
argument_list|,
name|searchPtr
operator|->
name|id
argument_list|)
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|resultPtr
argument_list|,
literal|"s-"
argument_list|,
name|string
argument_list|,
literal|"-"
argument_list|,
name|varName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|searchPtr
operator|->
name|varPtr
operator|=
name|varPtr
expr_stmt|;
name|searchPtr
operator|->
name|nextEntry
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|,
operator|&
name|searchPtr
operator|->
name|search
argument_list|)
expr_stmt|;
name|searchPtr
operator|->
name|nextPtr
operator|=
name|varPtr
operator|->
name|searchPtr
expr_stmt|;
name|varPtr
operator|->
name|searchPtr
operator|=
name|searchPtr
expr_stmt|;
break|break;
block|}
block|}
return|return
name|TCL_OK
return|;
name|error
label|:
name|Tcl_AppendStringsToObj
argument_list|(
name|resultPtr
argument_list|,
literal|"\""
argument_list|,
name|varName
argument_list|,
literal|"\" isn't an array"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * MakeUpvar --  *  *	This procedure does all of the work of the "global" and "upvar"  *	commands.  *  * Results:  *	A standard Tcl completion code. If an error occurs then an  *	error message is left in iPtr->result.  *  * Side effects:  *	The variable given by myName is linked to the variable in framePtr  *	given by otherP1 and otherP2, so that references to myName are  *	redirected to the other variable like a symbolic link.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|MakeUpvar
parameter_list|(
name|iPtr
parameter_list|,
name|framePtr
parameter_list|,
name|otherP1
parameter_list|,
name|otherP2
parameter_list|,
name|otherFlags
parameter_list|,
name|myName
parameter_list|,
name|myFlags
parameter_list|)
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Interpreter containing variables. Used 				 * for error messages, too. */
name|CallFrame
modifier|*
name|framePtr
decl_stmt|;
comment|/* Call frame containing "other" variable. 				 * NULL means use global :: context. */
name|char
modifier|*
name|otherP1
decl_stmt|,
decl|*
name|otherP2
decl_stmt|;
end_function

begin_comment
comment|/* Two-part name of variable in framePtr. */
end_comment

begin_decl_stmt
name|int
name|otherFlags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0, TCL_GLOBAL_ONLY or TCL_NAMESPACE_ONLY: 				 * indicates scope of "other" variable. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|myName
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of variable which will refer to 				 * otherP1/otherP2. Must be a scalar. */
end_comment

begin_decl_stmt
name|int
name|myFlags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0, TCL_GLOBAL_ONLY or TCL_NAMESPACE_ONLY: 				 * indicates scope of myName. */
end_comment

begin_block
block|{
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|Var
modifier|*
name|otherPtr
decl_stmt|,
modifier|*
name|varPtr
decl_stmt|,
modifier|*
name|arrayPtr
decl_stmt|;
name|CallFrame
modifier|*
name|varFramePtr
decl_stmt|;
name|CallFrame
modifier|*
name|savedFramePtr
init|=
name|NULL
decl_stmt|;
comment|/* Init. to avoid compiler warning. */
name|Tcl_HashTable
modifier|*
name|tablePtr
decl_stmt|;
name|Namespace
modifier|*
name|nsPtr
decl_stmt|,
modifier|*
name|altNsPtr
decl_stmt|,
modifier|*
name|dummyNsPtr
decl_stmt|;
name|char
modifier|*
name|tail
decl_stmt|;
name|int
name|new
decl_stmt|,
name|result
decl_stmt|;
comment|/*      * Find "other" in "framePtr". If not looking up other in just the      * current namespace, temporarily replace the current var frame      * pointer in the interpreter in order to use TclLookupVar.      */
if|if
condition|(
operator|!
operator|(
name|otherFlags
operator|&
name|TCL_NAMESPACE_ONLY
operator|)
condition|)
block|{
name|savedFramePtr
operator|=
name|iPtr
operator|->
name|varFramePtr
expr_stmt|;
name|iPtr
operator|->
name|varFramePtr
operator|=
name|framePtr
expr_stmt|;
block|}
name|otherPtr
operator|=
name|TclLookupVar
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
name|otherP1
argument_list|,
name|otherP2
argument_list|,
operator|(
name|otherFlags
operator||
name|TCL_LEAVE_ERR_MSG
operator|)
argument_list|,
literal|"access"
argument_list|,
comment|/*createPart1*/
literal|1
argument_list|,
comment|/*createPart2*/
literal|1
argument_list|,
operator|&
name|arrayPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|otherFlags
operator|&
name|TCL_NAMESPACE_ONLY
operator|)
condition|)
block|{
name|iPtr
operator|->
name|varFramePtr
operator|=
name|savedFramePtr
expr_stmt|;
block|}
if|if
condition|(
name|otherPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Now create a hashtable entry for "myName". Create it as either a      * namespace variable or as a local variable in a procedure call      * frame. Interpret myName as a namespace variable if:      *    1) so requested by a TCL_GLOBAL_ONLY or TCL_NAMESPACE_ONLY flag,      *    2) there is no active frame (we're at the global :: scope),      *    3) the active frame was pushed to define the namespace context      *       for a "namespace eval" or "namespace inscope" command,      *    4) the name has namespace qualifiers ("::"s).      * If creating myName in the active procedure, look first in the      * frame's array of compiler-allocated local variables, then in its      * hashtable for runtime-created local variables. Create that      * procedure's local variable hashtable if necessary.      */
name|varFramePtr
operator|=
name|iPtr
operator|->
name|varFramePtr
expr_stmt|;
if|if
condition|(
operator|(
name|myFlags
operator|&
operator|(
name|TCL_GLOBAL_ONLY
operator||
name|TCL_NAMESPACE_ONLY
operator|)
operator|)
operator|||
operator|(
name|varFramePtr
operator|==
name|NULL
operator|)
operator|||
operator|!
name|varFramePtr
operator|->
name|isProcCallFrame
operator|||
operator|(
name|strstr
argument_list|(
name|myName
argument_list|,
literal|"::"
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|result
operator|=
name|TclGetNamespaceForQualName
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
name|myName
argument_list|,
operator|(
name|Namespace
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|myFlags
operator||
name|TCL_LEAVE_ERR_MSG
operator|)
argument_list|,
operator|&
name|nsPtr
argument_list|,
operator|&
name|altNsPtr
argument_list|,
operator|&
name|dummyNsPtr
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
if|if
condition|(
name|nsPtr
operator|==
name|NULL
condition|)
block|{
name|nsPtr
operator|=
name|altNsPtr
expr_stmt|;
block|}
if|if
condition|(
name|nsPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"bad variable name \""
argument_list|,
name|myName
argument_list|,
literal|"\": unknown namespace"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
name|nsPtr
operator|->
name|varTable
argument_list|,
name|tail
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
name|varPtr
operator|=
name|NewVar
argument_list|()
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
name|varPtr
argument_list|)
expr_stmt|;
name|varPtr
operator|->
name|hPtr
operator|=
name|hPtr
expr_stmt|;
name|varPtr
operator|->
name|nsPtr
operator|=
name|nsPtr
expr_stmt|;
block|}
else|else
block|{
name|varPtr
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* look in the call frame */
name|Proc
modifier|*
name|procPtr
init|=
name|varFramePtr
operator|->
name|procPtr
decl_stmt|;
name|int
name|localCt
init|=
name|procPtr
operator|->
name|numCompiledLocals
decl_stmt|;
name|CompiledLocal
modifier|*
name|localPtr
init|=
name|procPtr
operator|->
name|firstLocalPtr
decl_stmt|;
name|Var
modifier|*
name|localVarPtr
init|=
name|varFramePtr
operator|->
name|compiledLocals
decl_stmt|;
name|int
name|nameLen
init|=
name|strlen
argument_list|(
name|myName
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|varPtr
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|localCt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|localPtr
operator|->
name|isTemp
condition|)
block|{
name|char
modifier|*
name|localName
init|=
name|localVarPtr
operator|->
name|name
decl_stmt|;
if|if
condition|(
operator|(
name|myName
index|[
literal|0
index|]
operator|==
name|localName
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
name|nameLen
operator|==
name|localPtr
operator|->
name|nameLength
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|myName
argument_list|,
name|localName
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|varPtr
operator|=
name|localVarPtr
expr_stmt|;
name|new
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|localVarPtr
operator|++
expr_stmt|;
name|localPtr
operator|=
name|localPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
if|if
condition|(
name|varPtr
operator|==
name|NULL
condition|)
block|{
comment|/* look in frame's local var hashtable */
name|tablePtr
operator|=
name|varFramePtr
operator|->
name|varTablePtr
expr_stmt|;
if|if
condition|(
name|tablePtr
operator|==
name|NULL
condition|)
block|{
name|tablePtr
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Tcl_HashTable
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
name|tablePtr
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
name|varFramePtr
operator|->
name|varTablePtr
operator|=
name|tablePtr
expr_stmt|;
block|}
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
name|tablePtr
argument_list|,
name|myName
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
name|varPtr
operator|=
name|NewVar
argument_list|()
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
name|varPtr
argument_list|)
expr_stmt|;
name|varPtr
operator|->
name|hPtr
operator|=
name|hPtr
expr_stmt|;
name|varPtr
operator|->
name|nsPtr
operator|=
name|varFramePtr
operator|->
name|nsPtr
expr_stmt|;
block|}
else|else
block|{
name|varPtr
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|new
condition|)
block|{
comment|/* 	 * The variable already exists. Make sure this variable "varPtr" 	 * isn't the same as "otherPtr" (avoid circular links). Also, if 	 * it's not an upvar then it's an error. If it is an upvar, then 	 * just disconnect it from the thing it currently refers to. 	 */
if|if
condition|(
name|varPtr
operator|==
name|otherPtr
condition|)
block|{
name|Tcl_SetResult
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"can't upvar from variable to itself"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|TclIsVarLink
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
name|Var
modifier|*
name|linkPtr
init|=
name|varPtr
operator|->
name|value
operator|.
name|linkPtr
decl_stmt|;
if|if
condition|(
name|linkPtr
operator|==
name|otherPtr
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
name|linkPtr
operator|->
name|refCount
operator|--
expr_stmt|;
if|if
condition|(
name|TclIsVarUndefined
argument_list|(
name|linkPtr
argument_list|)
condition|)
block|{
name|CleanupVar
argument_list|(
name|linkPtr
argument_list|,
operator|(
name|Var
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|TclIsVarUndefined
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"variable \""
argument_list|,
name|myName
argument_list|,
literal|"\" already exists"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|varPtr
operator|->
name|tracePtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"variable \""
argument_list|,
name|myName
argument_list|,
literal|"\" has traces: can't use for upvar"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
name|TclSetVarLink
argument_list|(
name|varPtr
argument_list|)
expr_stmt|;
name|TclClearVarUndefined
argument_list|(
name|varPtr
argument_list|)
expr_stmt|;
name|varPtr
operator|->
name|value
operator|.
name|linkPtr
operator|=
name|otherPtr
expr_stmt|;
name|otherPtr
operator|->
name|refCount
operator|++
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_UpVar --  *  *	This procedure links one variable to another, just like  *	the "upvar" command.  *  * Results:  *	A standard Tcl completion code.  If an error occurs then  *	an error message is left in interp->result.  *  * Side effects:  *	The variable in frameName whose name is given by varName becomes  *	accessible under the name localName, so that references to  *	localName are redirected to the other variable like a symbolic  *	link.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_UpVar
parameter_list|(
name|interp
parameter_list|,
name|frameName
parameter_list|,
name|varName
parameter_list|,
name|localName
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Command interpreter in which varName is 				 * to be looked up. */
name|char
modifier|*
name|frameName
decl_stmt|;
comment|/* Name of the frame containing the source 				 * variable, such as "1" or "#0". */
name|char
modifier|*
name|varName
decl_stmt|;
comment|/* Name of a variable in interp to link to. 				 * May be either a scalar name or an 				 * element in an array. */
name|char
modifier|*
name|localName
decl_stmt|;
comment|/* Name of link variable. */
name|int
name|flags
decl_stmt|;
comment|/* 0, TCL_GLOBAL_ONLY or TCL_NAMESPACE_ONLY: 				 * indicates scope of localName. */
block|{
name|int
name|result
decl_stmt|;
name|CallFrame
modifier|*
name|framePtr
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|result
operator|=
name|TclGetFrame
argument_list|(
name|interp
argument_list|,
name|frameName
argument_list|,
operator|&
name|framePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Figure out whether varName is an array reference, then call      * MakeUpvar to do all the real work.      */
for|for
control|(
name|p
operator|=
name|varName
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
block|{
name|char
modifier|*
name|openParen
init|=
name|p
decl_stmt|;
do|do
block|{
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
do|;
name|p
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|')'
condition|)
block|{
goto|goto
name|scalar
goto|;
block|}
operator|*
name|openParen
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|result
operator|=
name|MakeUpvar
argument_list|(
operator|(
name|Interp
operator|*
operator|)
name|interp
argument_list|,
name|framePtr
argument_list|,
name|varName
argument_list|,
name|openParen
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|localName
argument_list|,
name|flags
argument_list|)
expr_stmt|;
operator|*
name|openParen
operator|=
literal|'('
expr_stmt|;
operator|*
name|p
operator|=
literal|')'
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
name|scalar
label|:
return|return
name|MakeUpvar
argument_list|(
operator|(
name|Interp
operator|*
operator|)
name|interp
argument_list|,
name|framePtr
argument_list|,
name|varName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|localName
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_UpVar2 --  *  *	This procedure links one variable to another, just like  *	the "upvar" command.  *  * Results:  *	A standard Tcl completion code.  If an error occurs then  *	an error message is left in interp->result.  *  * Side effects:  *	The variable in frameName whose name is given by part1 and  *	part2 becomes accessible under the name localName, so that  *	references to localName are redirected to the other variable  *	like a symbolic link.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_UpVar2
parameter_list|(
name|interp
parameter_list|,
name|frameName
parameter_list|,
name|part1
parameter_list|,
name|part2
parameter_list|,
name|localName
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter containing variables.  Used 				 * for error messages too. */
name|char
modifier|*
name|frameName
decl_stmt|;
comment|/* Name of the frame containing the source 				 * variable, such as "1" or "#0". */
name|char
modifier|*
name|part1
decl_stmt|,
decl|*
name|part2
decl_stmt|;
end_function

begin_comment
comment|/* Two parts of source variable name to 				 * link to. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|localName
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of link variable. */
end_comment

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0, TCL_GLOBAL_ONLY or TCL_NAMESPACE_ONLY: 				 * indicates scope of localName. */
end_comment

begin_block
block|{
name|int
name|result
decl_stmt|;
name|CallFrame
modifier|*
name|framePtr
decl_stmt|;
name|result
operator|=
name|TclGetFrame
argument_list|(
name|interp
argument_list|,
name|frameName
argument_list|,
operator|&
name|framePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|MakeUpvar
argument_list|(
operator|(
name|Interp
operator|*
operator|)
name|interp
argument_list|,
name|framePtr
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
literal|0
argument_list|,
name|localName
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetVariableFullName --  *  *	Given a Tcl_Var token returned by Tcl_FindNamespaceVar, this  *	procedure appends to an object the namespace variable's full  *	name, qualified by a sequence of parent namespace names.  *  * Results:  *      None.  *  * Side effects:  *      The variable's fully-qualified name is appended to the string  *	representation of objPtr.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_GetVariableFullName
parameter_list|(
name|interp
parameter_list|,
name|variable
parameter_list|,
name|objPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter containing the variable. */
name|Tcl_Var
name|variable
decl_stmt|;
comment|/* Token for the variable returned by a 				 * previous call to Tcl_FindNamespaceVar. */
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Points to the object onto which the 				 * variable's full name is appended. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
specifier|register
name|Var
modifier|*
name|varPtr
init|=
operator|(
name|Var
operator|*
operator|)
name|variable
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/*      * Add the full name of the containing namespace (if any), followed by      * the "::" separator, then the variable name.      */
if|if
condition|(
name|varPtr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|TclIsVarArrayElement
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
if|if
condition|(
name|varPtr
operator|->
name|nsPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendToObj
argument_list|(
name|objPtr
argument_list|,
name|varPtr
operator|->
name|nsPtr
operator|->
name|fullName
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|varPtr
operator|->
name|nsPtr
operator|!=
name|iPtr
operator|->
name|globalNsPtr
condition|)
block|{
name|Tcl_AppendToObj
argument_list|(
name|objPtr
argument_list|,
literal|"::"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|varPtr
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendToObj
argument_list|(
name|objPtr
argument_list|,
name|varPtr
operator|->
name|name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|varPtr
operator|->
name|hPtr
operator|!=
name|NULL
condition|)
block|{
name|name
operator|=
name|Tcl_GetHashKey
argument_list|(
name|varPtr
operator|->
name|hPtr
operator|->
name|tablePtr
argument_list|,
name|varPtr
operator|->
name|hPtr
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|objPtr
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GlobalObjCmd --  *  *	This object-based procedure is invoked to process the "global" Tcl  *	command. See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl object result value.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_GlobalObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|char
modifier|*
name|varName
decl_stmt|;
specifier|register
name|char
modifier|*
name|tail
decl_stmt|;
name|int
name|result
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"varName ?varName ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * If we are not executing inside a Tcl procedure, just return.      */
if|if
condition|(
operator|(
name|iPtr
operator|->
name|varFramePtr
operator|==
name|NULL
operator|)
operator|||
operator|!
name|iPtr
operator|->
name|varFramePtr
operator|->
name|isProcCallFrame
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
comment|/* 	 * Make a local variable linked to its counterpart in the global :: 	 * namespace. 	 */
name|objPtr
operator|=
name|objv
index|[
name|i
index|]
expr_stmt|;
name|varName
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * The variable name might have a scope qualifier, but the name for          * the local "link" variable must be the simple name at the tail. 	 */
for|for
control|(
name|tail
operator|=
name|varName
init|;
operator|*
name|tail
operator|!=
literal|'\0'
condition|;
name|tail
operator|++
control|)
block|{
comment|/* empty body */
block|}
while|while
condition|(
operator|(
name|tail
operator|>
name|varName
operator|)
operator|&&
operator|(
operator|(
operator|*
name|tail
operator|!=
literal|':'
operator|)
operator|||
operator|(
operator|*
operator|(
name|tail
operator|-
literal|1
operator|)
operator|!=
literal|':'
operator|)
operator|)
condition|)
block|{
name|tail
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|tail
operator|==
literal|':'
condition|)
block|{
name|tail
operator|++
expr_stmt|;
block|}
comment|/* 	 * Link to the variable "varName" in the global :: namespace. 	 */
name|result
operator|=
name|MakeUpvar
argument_list|(
name|iPtr
argument_list|,
operator|(
name|CallFrame
operator|*
operator|)
name|NULL
argument_list|,
name|varName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
comment|/*otherFlags*/
name|TCL_GLOBAL_ONLY
argument_list|,
comment|/*myName*/
name|tail
argument_list|,
comment|/*myFlags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_VariableObjCmd --  *  *	Invoked to implement the "variable" command that creates one or more  *	global variables. Handles the following syntax:  *  *	    variable ?name value...? name ?value?  *  *	One or more variables can be created. The variables are initialized  *	with the specified values. The value for the last variable is  *	optional.  *  *	If the variable does not exist, it is created and given the optional  *	value. If it already exists, it is simply set to the optional  *	value. Normally, "name" is an unqualified name, so it is created in  *	the current namespace. If it includes namespace qualifiers, it can  *	be created in another namespace.  *  *	If the variable command is executed inside a Tcl procedure, it  *	creates a local variable linked to the newly-created namespace  *	variable.  *  * Results:  *	Returns TCL_OK if the variable is found or created. Returns  *	TCL_ERROR if anything goes wrong.  *  * Side effects:  *	If anything goes wrong, this procedure returns an error message  *	as the result in the interpreter's result object.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_VariableObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|char
modifier|*
name|varName
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|Var
modifier|*
name|varPtr
decl_stmt|,
modifier|*
name|arrayPtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|varValuePtr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|result
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|=
name|i
operator|+
literal|2
control|)
block|{
comment|/* 	 * Look up each variable in the current namespace context, creating 	 * it if necessary. 	 */
name|varName
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|varPtr
operator|=
name|TclLookupVar
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|TCL_NAMESPACE_ONLY
operator||
name|TCL_LEAVE_ERR_MSG
operator|)
argument_list|,
literal|"define"
argument_list|,
comment|/*createPart1*/
literal|1
argument_list|,
comment|/*createPart2*/
literal|0
argument_list|,
operator|&
name|arrayPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|varPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
comment|/* 	 * Mark the variable as a namespace variable and increment its  	 * reference count so that it will persist until its namespace is 	 * destroyed or until the variable is unset. 	 */
if|if
condition|(
operator|!
operator|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_NAMESPACE_VAR
operator|)
condition|)
block|{
name|varPtr
operator|->
name|flags
operator||=
name|VAR_NAMESPACE_VAR
expr_stmt|;
name|varPtr
operator|->
name|refCount
operator|++
expr_stmt|;
block|}
comment|/* 	 * If a value was specified, set the variable to that value. 	 * Otherwise, if the variable is new, leave it undefined. 	 * (If the variable already exists and no value was specified, 	 * leave its value unchanged; just create the local link if 	 * we're in a Tcl procedure). 	 */
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|objc
condition|)
block|{
comment|/* a value was specified */
name|varValuePtr
operator|=
name|Tcl_ObjSetVar2
argument_list|(
name|interp
argument_list|,
name|objv
index|[
name|i
index|]
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|)
name|NULL
argument_list|,
name|objv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|(
name|TCL_NAMESPACE_ONLY
operator||
name|TCL_LEAVE_ERR_MSG
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|varValuePtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
comment|/* 	 * If we are executing inside a Tcl procedure, create a local 	 * variable linked to the new namespace variable "varName". 	 */
if|if
condition|(
operator|(
name|iPtr
operator|->
name|varFramePtr
operator|!=
name|NULL
operator|)
operator|&&
name|iPtr
operator|->
name|varFramePtr
operator|->
name|isProcCallFrame
condition|)
block|{
comment|/* 	     * varName might have a scope qualifier, but the name for the 	     * local "link" variable must be the simple name at the tail. 	     */
for|for
control|(
name|tail
operator|=
name|varName
init|;
operator|*
name|tail
operator|!=
literal|'\0'
condition|;
name|tail
operator|++
control|)
block|{
comment|/* empty body */
block|}
while|while
condition|(
operator|(
name|tail
operator|>
name|varName
operator|)
operator|&&
operator|(
operator|(
operator|*
name|tail
operator|!=
literal|':'
operator|)
operator|||
operator|(
operator|*
operator|(
name|tail
operator|-
literal|1
operator|)
operator|!=
literal|':'
operator|)
operator|)
condition|)
block|{
name|tail
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|tail
operator|==
literal|':'
condition|)
block|{
name|tail
operator|++
expr_stmt|;
block|}
comment|/* 	     * Create a local link "tail" to the variable "varName" in the 	     * current namespace. 	     */
name|result
operator|=
name|MakeUpvar
argument_list|(
name|iPtr
argument_list|,
operator|(
name|CallFrame
operator|*
operator|)
name|NULL
argument_list|,
comment|/*otherP1*/
name|varName
argument_list|,
comment|/*otherP2*/
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
comment|/*otherFlags*/
name|TCL_NAMESPACE_ONLY
argument_list|,
comment|/*myName*/
name|tail
argument_list|,
comment|/*myFlags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_UpvarObjCmd --  *  *	This object-based procedure is invoked to process the "upvar"  *	Tcl command. See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl object result value.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_UpvarObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|CallFrame
modifier|*
name|framePtr
decl_stmt|;
name|char
modifier|*
name|frameSpec
decl_stmt|,
modifier|*
name|otherVarName
decl_stmt|,
modifier|*
name|myVarName
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|3
condition|)
block|{
name|upvarSyntax
label|:
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"?level? otherVar localVar ?otherVar localVar ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Find the call frame containing each of the "other variables" to be      * linked to. FAILS IF objv[1]'s STRING REP CONTAINS NULLS.      */
name|frameSpec
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TclGetFrame
argument_list|(
name|interp
argument_list|,
name|frameSpec
argument_list|,
operator|&
name|framePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|objc
operator|-=
name|result
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|objc
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|upvarSyntax
goto|;
block|}
name|objv
operator|+=
name|result
operator|+
literal|1
expr_stmt|;
comment|/*      * Iterate over each (other variable, local variable) pair.      * Divide the other variable name into two parts, then call      * MakeUpvar to do all the work of linking it to the local variable.      */
for|for
control|(
init|;
name|objc
operator|>
literal|0
condition|;
name|objc
operator|-=
literal|2
operator|,
name|objv
operator|+=
literal|2
control|)
block|{
name|myVarName
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|otherVarName
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|0
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|otherVarName
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
block|{
name|char
modifier|*
name|openParen
init|=
name|p
decl_stmt|;
do|do
block|{
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
do|;
name|p
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|')'
condition|)
block|{
goto|goto
name|scalar
goto|;
block|}
operator|*
name|openParen
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|result
operator|=
name|MakeUpvar
argument_list|(
name|iPtr
argument_list|,
name|framePtr
argument_list|,
name|otherVarName
argument_list|,
name|openParen
operator|+
literal|1
argument_list|,
comment|/*otherFlags*/
literal|0
argument_list|,
name|myVarName
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
operator|*
name|openParen
operator|=
literal|'('
expr_stmt|;
operator|*
name|p
operator|=
literal|')'
expr_stmt|;
goto|goto
name|checkResult
goto|;
block|}
block|}
name|scalar
label|:
name|result
operator|=
name|MakeUpvar
argument_list|(
name|iPtr
argument_list|,
name|framePtr
argument_list|,
name|otherVarName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|myVarName
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|checkResult
label|:
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CallTraces --  *  *	This procedure is invoked to find and invoke relevant  *	trace procedures associated with a particular operation on  *	a variable. This procedure invokes traces both on the  *	variable and on its containing array (where relevant).  *  * Results:  *	The return value is NULL if no trace procedures were invoked, or  *	if all the invoked trace procedures returned successfully.  *	The return value is non-NULL if a trace procedure returned an  *	error (in this case no more trace procedures were invoked after  *	the error was returned). In this case the return value is a  *	pointer to a static string describing the error.  *  * Side effects:  *	Almost anything can happen, depending on trace; this procedure  *	itself doesn't have any side effects.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|CallTraces
parameter_list|(
name|iPtr
parameter_list|,
name|arrayPtr
parameter_list|,
name|varPtr
parameter_list|,
name|part1
parameter_list|,
name|part2
parameter_list|,
name|flags
parameter_list|)
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Interpreter containing variable. */
specifier|register
name|Var
modifier|*
name|arrayPtr
decl_stmt|;
comment|/* Pointer to array variable that contains 				 * the variable, or NULL if the variable 				 * isn't an element of an array. */
name|Var
modifier|*
name|varPtr
decl_stmt|;
comment|/* Variable whose traces are to be 				 * invoked. */
name|char
modifier|*
name|part1
decl_stmt|,
decl|*
name|part2
decl_stmt|;
end_function

begin_comment
comment|/* Variable's two-part name. */
end_comment

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flags passed to trace procedures: 				 * indicates what's happening to variable, 				 * plus other stuff like TCL_GLOBAL_ONLY, 				 * TCL_NAMESPACE_ONLY, and 				 * TCL_INTERP_DESTROYED. May also contain 				 * TCL_PARSE_PART1, which should not be 				 * passed through to callbacks. */
end_comment

begin_block
block|{
specifier|register
name|VarTrace
modifier|*
name|tracePtr
decl_stmt|;
name|ActiveVarTrace
name|active
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|,
modifier|*
name|openParen
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|Tcl_DString
name|nameCopy
decl_stmt|;
name|int
name|copiedName
decl_stmt|;
comment|/*      * If there are already similar trace procedures active for the      * variable, don't call them again.      */
if|if
condition|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_TRACE_ACTIVE
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|varPtr
operator|->
name|flags
operator||=
name|VAR_TRACE_ACTIVE
expr_stmt|;
name|varPtr
operator|->
name|refCount
operator|++
expr_stmt|;
comment|/*      * If the variable name hasn't been parsed into array name and      * element, do it here.  If there really is an array element,      * make a copy of the original name so that NULLs can be      * inserted into it to separate the names (can't modify the name      * string in place, because the string might get used by the      * callbacks we invoke).      */
name|copiedName
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TCL_PARSE_PART1
condition|)
block|{
for|for
control|(
name|p
operator|=
name|part1
init|;
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
block|{
name|openParen
operator|=
name|p
expr_stmt|;
do|do
block|{
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
do|;
name|p
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|')'
condition|)
block|{
name|Tcl_DStringInit
argument_list|(
operator|&
name|nameCopy
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|nameCopy
argument_list|,
name|part1
argument_list|,
operator|(
name|p
operator|-
name|part1
operator|)
argument_list|)
expr_stmt|;
name|part2
operator|=
name|Tcl_DStringValue
argument_list|(
operator|&
name|nameCopy
argument_list|)
operator|+
operator|(
name|openParen
operator|+
literal|1
operator|-
name|part1
operator|)
expr_stmt|;
name|part2
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|part1
operator|=
name|Tcl_DStringValue
argument_list|(
operator|&
name|nameCopy
argument_list|)
expr_stmt|;
name|copiedName
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
name|flags
operator|&=
operator|~
name|TCL_PARSE_PART1
expr_stmt|;
comment|/*      * Invoke traces on the array containing the variable, if relevant.      */
name|result
operator|=
name|NULL
expr_stmt|;
name|active
operator|.
name|nextPtr
operator|=
name|iPtr
operator|->
name|activeTracePtr
expr_stmt|;
name|iPtr
operator|->
name|activeTracePtr
operator|=
operator|&
name|active
expr_stmt|;
if|if
condition|(
name|arrayPtr
operator|!=
name|NULL
condition|)
block|{
name|arrayPtr
operator|->
name|refCount
operator|++
expr_stmt|;
name|active
operator|.
name|varPtr
operator|=
name|arrayPtr
expr_stmt|;
for|for
control|(
name|tracePtr
operator|=
name|arrayPtr
operator|->
name|tracePtr
init|;
name|tracePtr
operator|!=
name|NULL
condition|;
name|tracePtr
operator|=
name|active
operator|.
name|nextTracePtr
control|)
block|{
name|active
operator|.
name|nextTracePtr
operator|=
name|tracePtr
operator|->
name|nextPtr
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tracePtr
operator|->
name|flags
operator|&
name|flags
operator|)
condition|)
block|{
continue|continue;
block|}
name|result
operator|=
call|(
modifier|*
name|tracePtr
operator|->
name|traceProc
call|)
argument_list|(
name|tracePtr
operator|->
name|clientData
argument_list|,
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TCL_TRACE_UNSETS
condition|)
block|{
name|result
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|done
goto|;
block|}
block|}
block|}
block|}
comment|/*      * Invoke traces on the variable itself.      */
if|if
condition|(
name|flags
operator|&
name|TCL_TRACE_UNSETS
condition|)
block|{
name|flags
operator||=
name|TCL_TRACE_DESTROYED
expr_stmt|;
block|}
name|active
operator|.
name|varPtr
operator|=
name|varPtr
expr_stmt|;
for|for
control|(
name|tracePtr
operator|=
name|varPtr
operator|->
name|tracePtr
init|;
name|tracePtr
operator|!=
name|NULL
condition|;
name|tracePtr
operator|=
name|active
operator|.
name|nextTracePtr
control|)
block|{
name|active
operator|.
name|nextTracePtr
operator|=
name|tracePtr
operator|->
name|nextPtr
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tracePtr
operator|->
name|flags
operator|&
name|flags
operator|)
condition|)
block|{
continue|continue;
block|}
name|result
operator|=
call|(
modifier|*
name|tracePtr
operator|->
name|traceProc
call|)
argument_list|(
name|tracePtr
operator|->
name|clientData
argument_list|,
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TCL_TRACE_UNSETS
condition|)
block|{
name|result
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|done
goto|;
block|}
block|}
block|}
comment|/*      * Restore the variable's flags, remove the record of our active      * traces, and then return.      */
name|done
label|:
if|if
condition|(
name|arrayPtr
operator|!=
name|NULL
condition|)
block|{
name|arrayPtr
operator|->
name|refCount
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|copiedName
condition|)
block|{
name|Tcl_DStringFree
argument_list|(
operator|&
name|nameCopy
argument_list|)
expr_stmt|;
block|}
name|varPtr
operator|->
name|flags
operator|&=
operator|~
name|VAR_TRACE_ACTIVE
expr_stmt|;
name|varPtr
operator|->
name|refCount
operator|--
expr_stmt|;
name|iPtr
operator|->
name|activeTracePtr
operator|=
name|active
operator|.
name|nextPtr
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * NewVar --  *  *	Create a new heap-allocated variable that will eventually be  *	entered into a hashtable.  *  * Results:  *	The return value is a pointer to the new variable structure. It is  *	marked as a scalar variable (and not a link or array variable). Its  *	value initially is NULL. The variable is not part of any hash table  *	yet. Since it will be in a hashtable and not in a call frame, its  *	name field is set NULL. It is initially marked as undefined.  *  * Side effects:  *	Storage gets allocated.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Var
modifier|*
name|NewVar
parameter_list|()
block|{
specifier|register
name|Var
modifier|*
name|varPtr
decl_stmt|;
name|varPtr
operator|=
operator|(
name|Var
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Var
argument_list|)
argument_list|)
expr_stmt|;
name|varPtr
operator|->
name|value
operator|.
name|objPtr
operator|=
name|NULL
expr_stmt|;
name|varPtr
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|varPtr
operator|->
name|nsPtr
operator|=
name|NULL
expr_stmt|;
name|varPtr
operator|->
name|hPtr
operator|=
name|NULL
expr_stmt|;
name|varPtr
operator|->
name|refCount
operator|=
literal|0
expr_stmt|;
name|varPtr
operator|->
name|tracePtr
operator|=
name|NULL
expr_stmt|;
name|varPtr
operator|->
name|searchPtr
operator|=
name|NULL
expr_stmt|;
name|varPtr
operator|->
name|flags
operator|=
operator|(
name|VAR_SCALAR
operator||
name|VAR_UNDEFINED
operator||
name|VAR_IN_HASHTABLE
operator|)
expr_stmt|;
return|return
name|varPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * ParseSearchId --  *  *	This procedure translates from a string to a pointer to an  *	active array search (if there is one that matches the string).  *  * Results:  *	The return value is a pointer to the array search indicated  *	by string, or NULL if there isn't one.  If NULL is returned,  *	interp->result contains an error message.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|ArraySearch
modifier|*
name|ParseSearchId
parameter_list|(
name|interp
parameter_list|,
name|varPtr
parameter_list|,
name|varName
parameter_list|,
name|string
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter containing variable. */
name|Var
modifier|*
name|varPtr
decl_stmt|;
comment|/* Array variable search is for. */
name|char
modifier|*
name|varName
decl_stmt|;
comment|/* Name of array variable that search is 				 * supposed to be for. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String containing id of search. Must have 				 * form "search-num-var" where "num" is a 				 * decimal number and "var" is a variable 				 * name. */
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|id
decl_stmt|;
name|ArraySearch
modifier|*
name|searchPtr
decl_stmt|;
comment|/*      * Parse the id into the three parts separated by dashes.      */
if|if
condition|(
operator|(
name|string
index|[
literal|0
index|]
operator|!=
literal|'s'
operator|)
operator|||
operator|(
name|string
index|[
literal|1
index|]
operator|!=
literal|'-'
operator|)
condition|)
block|{
name|syntax
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"illegal search identifier \""
argument_list|,
name|string
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|id
operator|=
name|strtoul
argument_list|(
name|string
operator|+
literal|2
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|end
operator|==
operator|(
name|string
operator|+
literal|2
operator|)
operator|)
operator|||
operator|(
operator|*
name|end
operator|!=
literal|'-'
operator|)
condition|)
block|{
goto|goto
name|syntax
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|end
operator|+
literal|1
argument_list|,
name|varName
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"search identifier \""
argument_list|,
name|string
argument_list|,
literal|"\" isn't for variable \""
argument_list|,
name|varName
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*      * Search through the list of active searches on the interpreter      * to see if the desired one exists.      */
for|for
control|(
name|searchPtr
operator|=
name|varPtr
operator|->
name|searchPtr
init|;
name|searchPtr
operator|!=
name|NULL
condition|;
name|searchPtr
operator|=
name|searchPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|searchPtr
operator|->
name|id
operator|==
name|id
condition|)
block|{
return|return
name|searchPtr
return|;
block|}
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't find search \""
argument_list|,
name|string
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DeleteSearches --  *  *	This procedure is called to free up all of the searches  *	associated with an array variable.  *  * Results:  *	None.  *  * Side effects:  *	Memory is released to the storage allocator.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|DeleteSearches
parameter_list|(
name|arrayVarPtr
parameter_list|)
specifier|register
name|Var
modifier|*
name|arrayVarPtr
decl_stmt|;
comment|/* Variable whose searches are 					 * to be deleted. */
block|{
name|ArraySearch
modifier|*
name|searchPtr
decl_stmt|;
while|while
condition|(
name|arrayVarPtr
operator|->
name|searchPtr
operator|!=
name|NULL
condition|)
block|{
name|searchPtr
operator|=
name|arrayVarPtr
operator|->
name|searchPtr
expr_stmt|;
name|arrayVarPtr
operator|->
name|searchPtr
operator|=
name|searchPtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|searchPtr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclDeleteVars --  *  *	This procedure is called to recycle all the storage space  *	associated with a table of variables. For this procedure  *	to work correctly, it must not be possible for any of the  *	variables in the table to be accessed from Tcl commands  *	(e.g. from trace procedures).  *  * Results:  *	None.  *  * Side effects:  *	Variables are deleted and trace procedures are invoked, if  *	any are declared.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclDeleteVars
parameter_list|(
name|iPtr
parameter_list|,
name|tablePtr
parameter_list|)
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Interpreter to which variables belong. */
name|Tcl_HashTable
modifier|*
name|tablePtr
decl_stmt|;
comment|/* Hash table containing variables to 				 * delete. */
block|{
name|Tcl_Interp
modifier|*
name|interp
init|=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
decl_stmt|;
name|Tcl_HashSearch
name|search
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
specifier|register
name|Var
modifier|*
name|varPtr
decl_stmt|;
name|Var
modifier|*
name|linkPtr
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|ActiveVarTrace
modifier|*
name|activePtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|Namespace
modifier|*
name|currNsPtr
init|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetCurrentNamespace
argument_list|(
name|interp
argument_list|)
decl_stmt|;
comment|/*      * Determine what flags to pass to the trace callback procedures.      */
name|flags
operator|=
name|TCL_TRACE_UNSETS
expr_stmt|;
if|if
condition|(
name|tablePtr
operator|==
operator|&
name|iPtr
operator|->
name|globalNsPtr
operator|->
name|varTable
condition|)
block|{
name|flags
operator||=
operator|(
name|TCL_INTERP_DESTROYED
operator||
name|TCL_GLOBAL_ONLY
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tablePtr
operator|==
operator|&
name|currNsPtr
operator|->
name|varTable
condition|)
block|{
name|flags
operator||=
name|TCL_NAMESPACE_ONLY
expr_stmt|;
block|}
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|tablePtr
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
name|varPtr
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
comment|/* 	 * For global/upvar variables referenced in procedures, decrement 	 * the reference count on the variable referred to, and free 	 * the referenced variable if it's no longer needed. Don't delete 	 * the hash entry for the other variable if it's in the same table 	 * as us: this will happen automatically later on. 	 */
if|if
condition|(
name|TclIsVarLink
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
name|linkPtr
operator|=
name|varPtr
operator|->
name|value
operator|.
name|linkPtr
expr_stmt|;
name|linkPtr
operator|->
name|refCount
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|linkPtr
operator|->
name|refCount
operator|==
literal|0
operator|)
operator|&&
name|TclIsVarUndefined
argument_list|(
name|linkPtr
argument_list|)
operator|&&
operator|(
name|linkPtr
operator|->
name|tracePtr
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|linkPtr
operator|->
name|flags
operator|&
name|VAR_IN_HASHTABLE
operator|)
condition|)
block|{
if|if
condition|(
name|linkPtr
operator|->
name|hPtr
operator|==
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|linkPtr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|linkPtr
operator|->
name|hPtr
operator|->
name|tablePtr
operator|!=
name|tablePtr
condition|)
block|{
name|Tcl_DeleteHashEntry
argument_list|(
name|linkPtr
operator|->
name|hPtr
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|linkPtr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Invoke traces on the variable that is being deleted, then 	 * free up the variable's space (no need to free the hash entry 	 * here, unless we're dealing with a global variable: the 	 * hash entries will be deleted automatically when the whole 	 * table is deleted). Note that we give CallTraces the variable's 	 * fully-qualified name so that any called trace procedures can 	 * refer to these variables being deleted. 	 */
if|if
condition|(
name|varPtr
operator|->
name|tracePtr
operator|!=
name|NULL
condition|)
block|{
name|objPtr
operator|=
name|Tcl_NewObj
argument_list|()
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
comment|/* until done with traces */
name|Tcl_GetVariableFullName
argument_list|(
name|interp
argument_list|,
operator|(
name|Tcl_Var
operator|)
name|varPtr
argument_list|,
name|objPtr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|CallTraces
argument_list|(
name|iPtr
argument_list|,
operator|(
name|Var
operator|*
operator|)
name|NULL
argument_list|,
name|varPtr
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
comment|/* free no longer needed obj */
while|while
condition|(
name|varPtr
operator|->
name|tracePtr
operator|!=
name|NULL
condition|)
block|{
name|VarTrace
modifier|*
name|tracePtr
init|=
name|varPtr
operator|->
name|tracePtr
decl_stmt|;
name|varPtr
operator|->
name|tracePtr
operator|=
name|tracePtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tracePtr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|activePtr
operator|=
name|iPtr
operator|->
name|activeTracePtr
init|;
name|activePtr
operator|!=
name|NULL
condition|;
name|activePtr
operator|=
name|activePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|activePtr
operator|->
name|varPtr
operator|==
name|varPtr
condition|)
block|{
name|activePtr
operator|->
name|nextTracePtr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TclIsVarArray
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
name|DeleteArray
argument_list|(
name|iPtr
argument_list|,
name|Tcl_GetHashKey
argument_list|(
name|tablePtr
argument_list|,
name|hPtr
argument_list|)
argument_list|,
name|varPtr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TclIsVarScalar
argument_list|(
name|varPtr
argument_list|)
operator|&&
operator|(
name|varPtr
operator|->
name|value
operator|.
name|objPtr
operator|!=
name|NULL
operator|)
condition|)
block|{
name|objPtr
operator|=
name|varPtr
operator|->
name|value
operator|.
name|objPtr
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|varPtr
operator|->
name|value
operator|.
name|objPtr
operator|=
name|NULL
expr_stmt|;
block|}
name|varPtr
operator|->
name|hPtr
operator|=
name|NULL
expr_stmt|;
name|varPtr
operator|->
name|tracePtr
operator|=
name|NULL
expr_stmt|;
name|TclSetVarUndefined
argument_list|(
name|varPtr
argument_list|)
expr_stmt|;
name|TclSetVarScalar
argument_list|(
name|varPtr
argument_list|)
expr_stmt|;
comment|/* 	 * If the variable was a namespace variable, decrement its  	 * reference count. We are in the process of destroying its 	 * namespace so that namespace will no longer "refer" to the 	 * variable. 	 */
if|if
condition|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_NAMESPACE_VAR
condition|)
block|{
name|varPtr
operator|->
name|flags
operator|&=
operator|~
name|VAR_NAMESPACE_VAR
expr_stmt|;
name|varPtr
operator|->
name|refCount
operator|--
expr_stmt|;
block|}
comment|/* 	 * Recycle the variable's memory space if there aren't any upvar's 	 * pointing to it. If there are upvars to this variable, then the 	 * variable will get freed when the last upvar goes away. 	 */
if|if
condition|(
name|varPtr
operator|->
name|refCount
operator|==
literal|0
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|varPtr
argument_list|)
expr_stmt|;
comment|/* this Var must be VAR_IN_HASHTABLE */
block|}
block|}
name|Tcl_DeleteHashTable
argument_list|(
name|tablePtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclDeleteCompiledLocalVars --  *  *	This procedure is called to recycle storage space associated with  *	the compiler-allocated array of local variables in a procedure call  *	frame. This procedure resembles TclDeleteVars above except that each  *	variable is stored in a call frame and not a hash table. For this  *	procedure to work correctly, it must not be possible for any of the  *	variable in the table to be accessed from Tcl commands (e.g. from  *	trace procedures).  *  * Results:  *	None.  *  * Side effects:  *	Variables are deleted and trace procedures are invoked, if  *	any are declared.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclDeleteCompiledLocalVars
parameter_list|(
name|iPtr
parameter_list|,
name|framePtr
parameter_list|)
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Interpreter to which variables belong. */
name|CallFrame
modifier|*
name|framePtr
decl_stmt|;
comment|/* Procedure call frame containing 				 * compiler-assigned local variables to 				 * delete. */
block|{
specifier|register
name|Var
modifier|*
name|varPtr
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/* Flags passed to trace procedures. */
name|Var
modifier|*
name|linkPtr
decl_stmt|;
name|ActiveVarTrace
modifier|*
name|activePtr
decl_stmt|;
name|int
name|numLocals
decl_stmt|,
name|i
decl_stmt|;
name|flags
operator|=
name|TCL_TRACE_UNSETS
expr_stmt|;
name|numLocals
operator|=
name|framePtr
operator|->
name|numCompiledLocals
expr_stmt|;
name|varPtr
operator|=
name|framePtr
operator|->
name|compiledLocals
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numLocals
condition|;
name|i
operator|++
control|)
block|{
comment|/* 	 * For global/upvar variables referenced in procedures, decrement 	 * the reference count on the variable referred to, and free 	 * the referenced variable if it's no longer needed. Don't delete 	 * the hash entry for the other variable if it's in the same table 	 * as us: this will happen automatically later on. 	 */
if|if
condition|(
name|TclIsVarLink
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
name|linkPtr
operator|=
name|varPtr
operator|->
name|value
operator|.
name|linkPtr
expr_stmt|;
name|linkPtr
operator|->
name|refCount
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|linkPtr
operator|->
name|refCount
operator|==
literal|0
operator|)
operator|&&
name|TclIsVarUndefined
argument_list|(
name|linkPtr
argument_list|)
operator|&&
operator|(
name|linkPtr
operator|->
name|tracePtr
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|linkPtr
operator|->
name|flags
operator|&
name|VAR_IN_HASHTABLE
operator|)
condition|)
block|{
if|if
condition|(
name|linkPtr
operator|->
name|hPtr
operator|==
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|linkPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_DeleteHashEntry
argument_list|(
name|linkPtr
operator|->
name|hPtr
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|linkPtr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Invoke traces on the variable that is being deleted. Then delete 	 * the variable's trace records. 	 */
if|if
condition|(
name|varPtr
operator|->
name|tracePtr
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|CallTraces
argument_list|(
name|iPtr
argument_list|,
operator|(
name|Var
operator|*
operator|)
name|NULL
argument_list|,
name|varPtr
argument_list|,
name|varPtr
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
while|while
condition|(
name|varPtr
operator|->
name|tracePtr
operator|!=
name|NULL
condition|)
block|{
name|VarTrace
modifier|*
name|tracePtr
init|=
name|varPtr
operator|->
name|tracePtr
decl_stmt|;
name|varPtr
operator|->
name|tracePtr
operator|=
name|tracePtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tracePtr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|activePtr
operator|=
name|iPtr
operator|->
name|activeTracePtr
init|;
name|activePtr
operator|!=
name|NULL
condition|;
name|activePtr
operator|=
name|activePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|activePtr
operator|->
name|varPtr
operator|==
name|varPtr
condition|)
block|{
name|activePtr
operator|->
name|nextTracePtr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Now if the variable is an array, delete its element hash table. 	 * Otherwise, if it's a scalar variable, decrement the ref count 	 * of its value. 	 */
if|if
condition|(
name|TclIsVarArray
argument_list|(
name|varPtr
argument_list|)
operator|&&
operator|(
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
operator|!=
name|NULL
operator|)
condition|)
block|{
name|DeleteArray
argument_list|(
name|iPtr
argument_list|,
name|varPtr
operator|->
name|name
argument_list|,
name|varPtr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TclIsVarScalar
argument_list|(
name|varPtr
argument_list|)
operator|&&
operator|(
name|varPtr
operator|->
name|value
operator|.
name|objPtr
operator|!=
name|NULL
operator|)
condition|)
block|{
name|TclDecrRefCount
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|objPtr
argument_list|)
expr_stmt|;
name|varPtr
operator|->
name|value
operator|.
name|objPtr
operator|=
name|NULL
expr_stmt|;
block|}
name|varPtr
operator|->
name|hPtr
operator|=
name|NULL
expr_stmt|;
name|varPtr
operator|->
name|tracePtr
operator|=
name|NULL
expr_stmt|;
name|TclSetVarUndefined
argument_list|(
name|varPtr
argument_list|)
expr_stmt|;
name|TclSetVarScalar
argument_list|(
name|varPtr
argument_list|)
expr_stmt|;
name|varPtr
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DeleteArray --  *  *	This procedure is called to free up everything in an array  *	variable.  It's the caller's responsibility to make sure  *	that the array is no longer accessible before this procedure  *	is called.  *  * Results:  *	None.  *  * Side effects:  *	All storage associated with varPtr's array elements is deleted  *	(including the array's hash table). Deletion trace procedures for  *	array elements are invoked, then deleted. Any pending traces for  *	array elements are also deleted.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|DeleteArray
parameter_list|(
name|iPtr
parameter_list|,
name|arrayName
parameter_list|,
name|varPtr
parameter_list|,
name|flags
parameter_list|)
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Interpreter containing array. */
name|char
modifier|*
name|arrayName
decl_stmt|;
comment|/* Name of array (used for trace 					 * callbacks). */
name|Var
modifier|*
name|varPtr
decl_stmt|;
comment|/* Pointer to variable structure. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to pass to CallTraces: 					 * TCL_TRACE_UNSETS and sometimes 					 * TCL_INTERP_DESTROYED, 					 * TCL_NAMESPACE_ONLY, or 					 * TCL_GLOBAL_ONLY. */
block|{
name|Tcl_HashSearch
name|search
decl_stmt|;
specifier|register
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
specifier|register
name|Var
modifier|*
name|elPtr
decl_stmt|;
name|ActiveVarTrace
modifier|*
name|activePtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|DeleteSearches
argument_list|(
name|varPtr
argument_list|)
expr_stmt|;
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
name|elPtr
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TclIsVarScalar
argument_list|(
name|elPtr
argument_list|)
operator|&&
operator|(
name|elPtr
operator|->
name|value
operator|.
name|objPtr
operator|!=
name|NULL
operator|)
condition|)
block|{
name|objPtr
operator|=
name|elPtr
operator|->
name|value
operator|.
name|objPtr
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|elPtr
operator|->
name|value
operator|.
name|objPtr
operator|=
name|NULL
expr_stmt|;
block|}
name|elPtr
operator|->
name|hPtr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|elPtr
operator|->
name|tracePtr
operator|!=
name|NULL
condition|)
block|{
name|elPtr
operator|->
name|flags
operator|&=
operator|~
name|VAR_TRACE_ACTIVE
expr_stmt|;
operator|(
name|void
operator|)
name|CallTraces
argument_list|(
name|iPtr
argument_list|,
operator|(
name|Var
operator|*
operator|)
name|NULL
argument_list|,
name|elPtr
argument_list|,
name|arrayName
argument_list|,
name|Tcl_GetHashKey
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|,
name|hPtr
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
while|while
condition|(
name|elPtr
operator|->
name|tracePtr
operator|!=
name|NULL
condition|)
block|{
name|VarTrace
modifier|*
name|tracePtr
init|=
name|elPtr
operator|->
name|tracePtr
decl_stmt|;
name|elPtr
operator|->
name|tracePtr
operator|=
name|tracePtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tracePtr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|activePtr
operator|=
name|iPtr
operator|->
name|activeTracePtr
init|;
name|activePtr
operator|!=
name|NULL
condition|;
name|activePtr
operator|=
name|activePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|activePtr
operator|->
name|varPtr
operator|==
name|elPtr
condition|)
block|{
name|activePtr
operator|->
name|nextTracePtr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|TclSetVarUndefined
argument_list|(
name|elPtr
argument_list|)
expr_stmt|;
name|TclSetVarScalar
argument_list|(
name|elPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|elPtr
operator|->
name|refCount
operator|==
literal|0
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|elPtr
argument_list|)
expr_stmt|;
comment|/* element Vars are VAR_IN_HASHTABLE */
block|}
block|}
name|Tcl_DeleteHashTable
argument_list|(
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|varPtr
operator|->
name|value
operator|.
name|tablePtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CleanupVar --  *  *	This procedure is called when it looks like it may be OK to free up  *	a variable's storage. If the variable is in a hashtable, its Var  *	structure and hash table entry will be freed along with those of its  *	containing array, if any. This procedure is called, for example,  *	when a trace on a variable deletes a variable.  *  * Results:  *	None.  *  * Side effects:  *	If the variable (or its containing array) really is dead and in a  *	hashtable, then its Var structure, and possibly its hash table  *	entry, is freed up.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|CleanupVar
parameter_list|(
name|varPtr
parameter_list|,
name|arrayPtr
parameter_list|)
name|Var
modifier|*
name|varPtr
decl_stmt|;
comment|/* Pointer to variable that may be a 				 * candidate for being expunged. */
name|Var
modifier|*
name|arrayPtr
decl_stmt|;
comment|/* Array that contains the variable, or 				 * NULL if this variable isn't an array 				 * element. */
block|{
if|if
condition|(
name|TclIsVarUndefined
argument_list|(
name|varPtr
argument_list|)
operator|&&
operator|(
name|varPtr
operator|->
name|refCount
operator|==
literal|0
operator|)
operator|&&
operator|(
name|varPtr
operator|->
name|tracePtr
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_IN_HASHTABLE
operator|)
condition|)
block|{
if|if
condition|(
name|varPtr
operator|->
name|hPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DeleteHashEntry
argument_list|(
name|varPtr
operator|->
name|hPtr
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|varPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arrayPtr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|TclIsVarUndefined
argument_list|(
name|arrayPtr
argument_list|)
operator|&&
operator|(
name|arrayPtr
operator|->
name|refCount
operator|==
literal|0
operator|)
operator|&&
operator|(
name|arrayPtr
operator|->
name|tracePtr
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|arrayPtr
operator|->
name|flags
operator|&
name|VAR_IN_HASHTABLE
operator|)
condition|)
block|{
if|if
condition|(
name|arrayPtr
operator|->
name|hPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DeleteHashEntry
argument_list|(
name|arrayPtr
operator|->
name|hPtr
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arrayPtr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * VarErrMsg --  *  *      Generate a reasonable error message describing why a variable  *      operation failed.  *  * Results:  *      None.  *  * Side effects:  *      Interp->result is reset to hold a message identifying the  *      variable given by part1 and part2 and describing why the  *      variable operation failed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|VarErrMsg
parameter_list|(
name|interp
parameter_list|,
name|part1
parameter_list|,
name|part2
parameter_list|,
name|operation
parameter_list|,
name|reason
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to record message. */
name|char
modifier|*
name|part1
decl_stmt|,
decl|*
name|part2
decl_stmt|;
end_function

begin_comment
comment|/* Variable's two-part name. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|operation
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String describing operation that failed,                                  * e.g. "read", "set", or "unset". */
end_comment

begin_decl_stmt
name|char
modifier|*
name|reason
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String describing why operation failed. */
end_comment

begin_block
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"can't "
argument_list|,
name|operation
argument_list|,
literal|" \""
argument_list|,
name|part1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|part2
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"("
argument_list|,
name|part2
argument_list|,
literal|")"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"\": "
argument_list|,
name|reason
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

