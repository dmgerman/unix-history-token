begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclObj.c --  *  *	This file contains Tcl object-related procedures that are used by  * 	many Tcl commands.  *  * Copyright (c) 1995-1997 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclObj.c 1.47 97/10/30 13:39:00  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * Table of all object types.  */
end_comment

begin_decl_stmt
specifier|static
name|Tcl_HashTable
name|typeTable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|typeTableInitialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 means not yet initialized. */
end_comment

begin_comment
comment|/*  * Head of the list of free Tcl_Objs we maintain.  */
end_comment

begin_decl_stmt
name|Tcl_Obj
modifier|*
name|tclFreeObjList
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Pointer to a heap-allocated string of length zero that the Tcl core uses  * as the value of an empty string representation for an object. This value  * is shared by all new objects allocated by Tcl_NewObj.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|tclEmptyStringRep
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Count of the number of Tcl objects every allocated (by Tcl_NewObj) and  * freed (by TclFreeObj).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_COMPILE_STATS
end_ifdef

begin_decl_stmt
name|long
name|tclObjsAlloced
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|tclObjsFreed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_COMPILE_STATS */
end_comment

begin_comment
comment|/*  * Prototypes for procedures defined later in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DupBooleanInternalRep
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Obj
operator|*
name|srcPtr
operator|,
name|Tcl_Obj
operator|*
name|copyPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DupDoubleInternalRep
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Obj
operator|*
name|srcPtr
operator|,
name|Tcl_Obj
operator|*
name|copyPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DupIntInternalRep
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Obj
operator|*
name|srcPtr
operator|,
name|Tcl_Obj
operator|*
name|copyPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|FinalizeTypeTable
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|FinalizeFreeObjList
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|InitTypeTable
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SetBooleanFromAny
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Obj
operator|*
name|objPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SetDoubleFromAny
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Obj
operator|*
name|objPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SetIntFromAny
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Obj
operator|*
name|objPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|UpdateStringOfBoolean
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Obj
operator|*
name|objPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|UpdateStringOfDouble
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Obj
operator|*
name|objPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|UpdateStringOfInt
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Obj
operator|*
name|objPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The structures below defines the Tcl object types defined in this file by  * means of procedures that can be invoked by generic object code. See also  * tclStringObj.c, tclListObj.c, tclByteCode.c for other type manager  * implementations.  */
end_comment

begin_decl_stmt
name|Tcl_ObjType
name|tclBooleanType
init|=
block|{
literal|"boolean"
block|,
comment|/* name */
operator|(
name|Tcl_FreeInternalRepProc
operator|*
operator|)
name|NULL
block|,
comment|/* freeIntRepProc */
name|DupBooleanInternalRep
block|,
comment|/* dupIntRepProc */
name|UpdateStringOfBoolean
block|,
comment|/* updateStringProc */
name|SetBooleanFromAny
comment|/* setFromAnyProc */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Tcl_ObjType
name|tclDoubleType
init|=
block|{
literal|"double"
block|,
comment|/* name */
operator|(
name|Tcl_FreeInternalRepProc
operator|*
operator|)
name|NULL
block|,
comment|/* freeIntRepProc */
name|DupDoubleInternalRep
block|,
comment|/* dupIntRepProc */
name|UpdateStringOfDouble
block|,
comment|/* updateStringProc */
name|SetDoubleFromAny
comment|/* setFromAnyProc */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Tcl_ObjType
name|tclIntType
init|=
block|{
literal|"int"
block|,
comment|/* name */
operator|(
name|Tcl_FreeInternalRepProc
operator|*
operator|)
name|NULL
block|,
comment|/* freeIntRepProc */
name|DupIntInternalRep
block|,
comment|/* dupIntRepProc */
name|UpdateStringOfInt
block|,
comment|/* updateStringProc */
name|SetIntFromAny
comment|/* setFromAnyProc */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * InitTypeTable --  *  *	This procedure is invoked to perform once-only initialization of  *	the type table. It also registers the object types defined in   *	this file.  *  * Results:  *	None.  *  * Side effects:  *	Initializes the table of defined object types "typeTable" with  *	builtin object types defined in this file. It also initializes the  *	value of tclEmptyStringRep, which points to the heap-allocated  *	string of length zero used as the string representation for  *	newly-created objects.  *  *--------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|InitTypeTable
parameter_list|()
block|{
name|typeTableInitialized
operator|=
literal|1
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
operator|&
name|typeTable
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
name|Tcl_RegisterObjType
argument_list|(
operator|&
name|tclBooleanType
argument_list|)
expr_stmt|;
name|Tcl_RegisterObjType
argument_list|(
operator|&
name|tclDoubleType
argument_list|)
expr_stmt|;
name|Tcl_RegisterObjType
argument_list|(
operator|&
name|tclIntType
argument_list|)
expr_stmt|;
name|Tcl_RegisterObjType
argument_list|(
operator|&
name|tclStringType
argument_list|)
expr_stmt|;
name|Tcl_RegisterObjType
argument_list|(
operator|&
name|tclListType
argument_list|)
expr_stmt|;
name|Tcl_RegisterObjType
argument_list|(
operator|&
name|tclByteCodeType
argument_list|)
expr_stmt|;
name|tclEmptyStringRep
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|)
expr_stmt|;
name|tclEmptyStringRep
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FinalizeTypeTable --  *  *	This procedure is called by Tcl_Finalize after all exit handlers  *	have been run to free up storage associated with the table of Tcl  *	object types.  *  * Results:  *	None.  *  * Side effects:  *	Deletes all entries in the hash table of object types, "typeTable".  *	Then sets "typeTableInitialized" to 0 so that the Tcl type system  *	will be properly reinitialized if Tcl is restarted. Also deallocates  *	the storage for tclEmptyStringRep.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|FinalizeTypeTable
parameter_list|()
block|{
if|if
condition|(
name|typeTableInitialized
condition|)
block|{
name|Tcl_DeleteHashTable
argument_list|(
operator|&
name|typeTable
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|tclEmptyStringRep
argument_list|)
expr_stmt|;
name|typeTableInitialized
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FinalizeFreeObjList --  *  *	Resets the free object list so it can later be reinitialized.  *  * Results:  *	None.  *  * Side effects:  *	Resets the value of tclFreeObjList.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|FinalizeFreeObjList
parameter_list|()
block|{
name|tclFreeObjList
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclFinalizeCompExecEnv --  *  *	Clean up the compiler execution environment so it can later be  *	properly reinitialized.  *  * Results:  *	None.  *  * Side effects:  *	Cleans up the execution environment  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclFinalizeCompExecEnv
parameter_list|()
block|{
name|FinalizeTypeTable
argument_list|()
expr_stmt|;
name|FinalizeFreeObjList
argument_list|()
expr_stmt|;
name|TclFinalizeExecEnv
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * Tcl_RegisterObjType --  *  *	This procedure is called to register a new Tcl object type  *	in the table of all object types supported by Tcl.  *  * Results:  *	None.  *  * Side effects:  *	The type is registered in the Tcl type table. If there was already  *	a type with the same name as in typePtr, it is replaced with the  *	new type.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_RegisterObjType
parameter_list|(
name|typePtr
parameter_list|)
name|Tcl_ObjType
modifier|*
name|typePtr
decl_stmt|;
comment|/* Information about object type; 				 * storage must be statically 				 * allocated (must live forever). */
block|{
specifier|register
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|int
name|new
decl_stmt|;
if|if
condition|(
operator|!
name|typeTableInitialized
condition|)
block|{
name|InitTypeTable
argument_list|()
expr_stmt|;
block|}
comment|/*      * If there's already an object type with the given name, remove it.      */
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|typeTable
argument_list|,
name|typePtr
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|!=
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_DeleteHashEntry
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * Now insert the new object type.      */
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
name|typeTable
argument_list|,
name|typePtr
operator|->
name|name
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
name|typePtr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_AppendAllObjTypes --  *  *	This procedure appends onto the argument object the name of each  *	object type as a list element. This includes the builtin object  *	types (e.g. int, list) as well as those added using  *	Tcl_CreateObjType. These names can be used, for example, with  *	Tcl_GetObjType to get pointers to the corresponding Tcl_ObjType  *	structures.  *  * Results:  *	The return value is normally TCL_OK; in this case the object  *	referenced by objPtr has each type name appended to it. If an  *	error occurs, TCL_ERROR is returned and the interpreter's result  *	holds an error message.  *  * Side effects:  *	If necessary, the object referenced by objPtr is converted into  *	a list object.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_AppendAllObjTypes
parameter_list|(
name|interp
parameter_list|,
name|objPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter used for error reporting. */
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Points to the Tcl object onto which the 				 * name of each registered type is appended 				 * as a list element. */
block|{
specifier|register
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|Tcl_HashSearch
name|search
decl_stmt|;
name|Tcl_ObjType
modifier|*
name|typePtr
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|typeTableInitialized
condition|)
block|{
name|InitTypeTable
argument_list|()
expr_stmt|;
block|}
comment|/*      * This code assumes that types names do not contain embedded NULLs.      */
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
name|typeTable
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
name|typePtr
operator|=
operator|(
name|Tcl_ObjType
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|objPtr
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|typePtr
operator|->
name|name
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetObjType --  *  *	This procedure looks up an object type by name.  *  * Results:  *	If an object type with name matching "typeName" is found, a pointer  *	to its Tcl_ObjType structure is returned; otherwise, NULL is  *	returned.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_ObjType
modifier|*
name|Tcl_GetObjType
parameter_list|(
name|typeName
parameter_list|)
name|char
modifier|*
name|typeName
decl_stmt|;
comment|/* Name of Tcl object type to look up. */
block|{
specifier|register
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|Tcl_ObjType
modifier|*
name|typePtr
decl_stmt|;
if|if
condition|(
operator|!
name|typeTableInitialized
condition|)
block|{
name|InitTypeTable
argument_list|()
expr_stmt|;
block|}
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|typeTable
argument_list|,
name|typeName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|!=
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|)
block|{
name|typePtr
operator|=
operator|(
name|Tcl_ObjType
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
return|return
name|typePtr
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ConvertToType --  *  *	Convert the Tcl object "objPtr" to have type "typePtr" if possible.  *  * Results:  *	The return value is TCL_OK on success and TCL_ERROR on failure. If  *	TCL_ERROR is returned, then the interpreter's result contains an  *	error message unless "interp" is NULL. Passing a NULL "interp"  *	allows this procedure to be used as a test whether the conversion  *	could be done (and in fact was done).  *  * Side effects:  *	Any internal representation for the old type is freed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_ConvertToType
parameter_list|(
name|interp
parameter_list|,
name|objPtr
parameter_list|,
name|typePtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting if not NULL. */
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* The object to convert. */
name|Tcl_ObjType
modifier|*
name|typePtr
decl_stmt|;
comment|/* The target type. */
block|{
if|if
condition|(
name|objPtr
operator|->
name|typePtr
operator|==
name|typePtr
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
comment|/*      * Use the target type's Tcl_SetFromAnyProc to set "objPtr"s internal      * form as appropriate for the target type. This frees the old internal      * representation.      */
return|return
name|typePtr
operator|->
name|setFromAnyProc
argument_list|(
name|interp
argument_list|,
name|objPtr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_NewObj --  *  *	This procedure is normally called when not debugging: i.e., when  *	TCL_MEM_DEBUG is not defined. It creates new Tcl objects that denote  *	the empty string. These objects have a NULL object type and NULL  *	string representation byte pointer. Type managers call this routine  *	to allocate new objects that they further initialize.  *  *	When TCL_MEM_DEBUG is defined, this procedure just returns the  *	result of calling the debugging version Tcl_DbNewObj.  *  * Results:  *	The result is a newly allocated object that represents the empty  *	string. The new object's typePtr is set NULL and its ref count  *	is set to 0.  *  * Side effects:  *	If compiling with TCL_COMPILE_STATS, this procedure increments  *	the global count of allocated objects (tclObjsAlloced).  *  *----------------------------------------------------------------------  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
end_ifdef

begin_undef
undef|#
directive|undef
name|Tcl_NewObj
end_undef

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_NewObj
parameter_list|()
block|{
return|return
name|Tcl_DbNewObj
argument_list|(
literal|"unknown"
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* if not TCL_MEM_DEBUG */
end_comment

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_NewObj
parameter_list|()
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/*      * Allocate the object using the list of free Tcl_Objs we maintain.      */
if|if
condition|(
name|tclFreeObjList
operator|==
name|NULL
condition|)
block|{
name|TclAllocateFreeObjects
argument_list|()
expr_stmt|;
block|}
name|objPtr
operator|=
name|tclFreeObjList
expr_stmt|;
name|tclFreeObjList
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|)
name|tclFreeObjList
operator|->
name|internalRep
operator|.
name|otherValuePtr
expr_stmt|;
name|objPtr
operator|->
name|refCount
operator|=
literal|0
expr_stmt|;
name|objPtr
operator|->
name|bytes
operator|=
name|tclEmptyStringRep
expr_stmt|;
name|objPtr
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|TCL_COMPILE_STATS
name|tclObjsAlloced
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* TCL_COMPILE_STATS */
return|return
name|objPtr
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_MEM_DEBUG */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DbNewObj --  *  *	This procedure is normally called when debugging: i.e., when  *	TCL_MEM_DEBUG is defined. It creates new Tcl objects that denote the  *	empty string. It is the same as the Tcl_NewObj procedure above  *	except that it calls Tcl_DbCkalloc directly with the file name and  *	line number from its caller. This simplifies debugging since then  *	the checkmem command will report the correct file name and line  *	number when reporting objects that haven't been freed.  *  *	When TCL_MEM_DEBUG is not defined, this procedure just returns the  *	result of calling Tcl_NewObj.  *  * Results:  *	The result is a newly allocated that represents the empty string.  *	The new object's typePtr is set NULL and its ref count is set to 0.  *  * Side effects:  *	If compiling with TCL_COMPILE_STATS, this procedure increments  *	the global count of allocated objects (tclObjsAlloced).  *  *----------------------------------------------------------------------  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
end_ifdef

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_DbNewObj
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|)
specifier|register
name|char
modifier|*
name|file
decl_stmt|;
comment|/* The name of the source file calling this 				 * procedure; used for debugging. */
specifier|register
name|int
name|line
decl_stmt|;
comment|/* Line number in the source file; used 				 * for debugging. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/*      * If debugging Tcl's memory usage, allocate the object using ckalloc.      * Otherwise, allocate it using the list of free Tcl_Objs we maintain.      */
name|objPtr
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|)
name|Tcl_DbCkalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Tcl_Obj
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|refCount
operator|=
literal|0
expr_stmt|;
name|objPtr
operator|->
name|bytes
operator|=
name|tclEmptyStringRep
expr_stmt|;
name|objPtr
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|TCL_COMPILE_STATS
name|tclObjsAlloced
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* TCL_COMPILE_STATS */
return|return
name|objPtr
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* if not TCL_MEM_DEBUG */
end_comment

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_DbNewObj
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
comment|/* The name of the source file calling this 				 * procedure; used for debugging. */
name|int
name|line
decl_stmt|;
comment|/* Line number in the source file; used 				 * for debugging. */
block|{
return|return
name|Tcl_NewObj
argument_list|()
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_MEM_DEBUG */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclAllocateFreeObjects --  *  *	Procedure to allocate a number of free Tcl_Objs. This is done using  *	a single ckalloc to reduce the overhead for Tcl_Obj allocation.  *  * Results:  *	None.  *  * Side effects:  *	tclFreeObjList, the head of the list of free Tcl_Objs, is set to the  *	first of a number of free Tcl_Obj's linked together by their  *	internalRep.otherValuePtrs.  *  *----------------------------------------------------------------------  */
end_comment

begin_define
define|#
directive|define
name|OBJS_TO_ALLOC_EACH_TIME
value|100
end_define

begin_function
name|void
name|TclAllocateFreeObjects
parameter_list|()
block|{
name|Tcl_Obj
name|tmp
index|[
literal|2
index|]
decl_stmt|;
name|size_t
name|objSizePlusPadding
init|=
comment|/* NB: this assumes byte addressing. */
operator|(
call|(
name|int
call|)
argument_list|(
operator|&
operator|(
name|tmp
index|[
literal|1
index|]
operator|)
argument_list|)
operator|-
call|(
name|int
call|)
argument_list|(
operator|&
operator|(
name|tmp
index|[
literal|0
index|]
operator|)
argument_list|)
operator|)
decl_stmt|;
name|size_t
name|bytesToAlloc
init|=
operator|(
name|OBJS_TO_ALLOC_EACH_TIME
operator|*
name|objSizePlusPadding
operator|)
decl_stmt|;
name|char
modifier|*
name|basePtr
decl_stmt|;
specifier|register
name|Tcl_Obj
modifier|*
name|prevPtr
decl_stmt|,
modifier|*
name|objPtr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|basePtr
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
name|bytesToAlloc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|basePtr
argument_list|,
literal|0
argument_list|,
name|bytesToAlloc
argument_list|)
expr_stmt|;
name|prevPtr
operator|=
name|NULL
expr_stmt|;
name|objPtr
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|)
name|basePtr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OBJS_TO_ALLOC_EACH_TIME
condition|;
name|i
operator|++
control|)
block|{
name|objPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
operator|=
operator|(
name|VOID
operator|*
operator|)
name|prevPtr
expr_stmt|;
name|prevPtr
operator|=
name|objPtr
expr_stmt|;
name|objPtr
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|objPtr
operator|)
operator|+
name|objSizePlusPadding
operator|)
expr_stmt|;
block|}
name|tclFreeObjList
operator|=
name|prevPtr
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|OBJS_TO_ALLOC_EACH_TIME
end_undef

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclFreeObj --  *  *	This procedure frees the memory associated with the argument  *	object. It is called by the tcl.h macro Tcl_DecrRefCount when an  *	object's ref count is zero. It is only "public" since it must  *	be callable by that macro wherever the macro is used. It should not  *	be directly called by clients.  *  * Results:  *	None.  *  * Side effects:  *	Deallocates the storage for the object's Tcl_Obj structure  *	after deallocating the string representation and calling the  *	type-specific Tcl_FreeInternalRepProc to deallocate the object's  *	internal representation. If compiling with TCL_COMPILE_STATS,  *	this procedure increments the global count of freed objects  *	(tclObjsFreed).  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclFreeObj
parameter_list|(
name|objPtr
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* The object to be freed. */
block|{
specifier|register
name|Tcl_ObjType
modifier|*
name|typePtr
init|=
name|objPtr
operator|->
name|typePtr
decl_stmt|;
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
if|if
condition|(
operator|(
name|objPtr
operator|)
operator|->
name|refCount
operator|<
operator|-
literal|1
condition|)
block|{
name|panic
argument_list|(
literal|"Reference count for %lx was negative"
argument_list|,
name|objPtr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TCL_MEM_DEBUG */
name|Tcl_InvalidateStringRep
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|typePtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|typePtr
operator|->
name|freeIntRepProc
operator|!=
name|NULL
operator|)
condition|)
block|{
name|typePtr
operator|->
name|freeIntRepProc
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * If debugging Tcl's memory usage, deallocate the object using ckfree.      * Otherwise, deallocate it by adding it onto the list of free      * Tcl_Objs we maintain.      */
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|objPtr
argument_list|)
expr_stmt|;
else|#
directive|else
name|objPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
operator|=
operator|(
name|VOID
operator|*
operator|)
name|tclFreeObjList
expr_stmt|;
name|tclFreeObjList
operator|=
name|objPtr
expr_stmt|;
endif|#
directive|endif
comment|/* TCL_MEM_DEBUG */
ifdef|#
directive|ifdef
name|TCL_COMPILE_STATS
name|tclObjsFreed
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* TCL_COMPILE_STATS */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DuplicateObj --  *  *	Create and return a new object that is a duplicate of the argument  *	object.  *  * Results:  *	The return value is a pointer to a newly created Tcl_Obj. This  *	object has reference count 0 and the same type, if any, as the  *	source object objPtr. Also:  *	  1) If the source object has a valid string rep, we copy it;  *	     otherwise, the duplicate's string rep is set NULL to mark  *	     it invalid.  *	  2) If the source object has an internal representation (i.e. its  *	     typePtr is non-NULL), the new object's internal rep is set to  *	     a copy; otherwise the new internal rep is marked invalid.  *  * Side effects:  *      What constitutes "copying" the internal representation depends on  *	the type. For example, if the argument object is a list,  *	the element objects it points to will not actually be copied but  *	will be shared with the duplicate list. That is, the ref counts of  *	the element objects will be incremented.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_DuplicateObj
parameter_list|(
name|objPtr
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* The object to duplicate. */
block|{
specifier|register
name|Tcl_ObjType
modifier|*
name|typePtr
init|=
name|objPtr
operator|->
name|typePtr
decl_stmt|;
specifier|register
name|Tcl_Obj
modifier|*
name|dupPtr
decl_stmt|;
name|TclNewObj
argument_list|(
name|dupPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|objPtr
operator|->
name|bytes
operator|==
name|NULL
condition|)
block|{
name|dupPtr
operator|->
name|bytes
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|objPtr
operator|->
name|bytes
operator|!=
name|tclEmptyStringRep
condition|)
block|{
name|int
name|len
init|=
name|objPtr
operator|->
name|length
decl_stmt|;
name|dupPtr
operator|->
name|bytes
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|dupPtr
operator|->
name|bytes
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|objPtr
operator|->
name|bytes
argument_list|,
operator|(
name|unsigned
operator|)
name|len
argument_list|)
expr_stmt|;
block|}
name|dupPtr
operator|->
name|bytes
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dupPtr
operator|->
name|length
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|typePtr
operator|!=
name|NULL
condition|)
block|{
name|typePtr
operator|->
name|dupIntRepProc
argument_list|(
name|objPtr
argument_list|,
name|dupPtr
argument_list|)
expr_stmt|;
block|}
return|return
name|dupPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetStringFromObj --  *  *	Returns the string representation's byte array pointer and length  *	for an object.  *  * Results:  *	Returns a pointer to the string representation of objPtr. If  *	lengthPtr isn't NULL, the length of the string representation is  *	stored at *lengthPtr. The byte array referenced by the returned  *	pointer must not be modified by the caller. Furthermore, the  *	caller must copy the bytes if they need to retain them since the  *	object's string rep can change as a result of other operations.  *  * Side effects:  *	May call the object's updateStringProc to update the string  *	representation from the internal representation.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_GetStringFromObj
parameter_list|(
name|objPtr
parameter_list|,
name|lengthPtr
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Object whose string rep byte pointer 				 * should be returned. */
specifier|register
name|int
modifier|*
name|lengthPtr
decl_stmt|;
comment|/* If non-NULL, the location where the 				 * string rep's byte array length should be 				 * stored. If NULL, no length is stored. */
block|{
if|if
condition|(
name|objPtr
operator|->
name|bytes
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|lengthPtr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|lengthPtr
operator|=
name|objPtr
operator|->
name|length
expr_stmt|;
block|}
return|return
name|objPtr
operator|->
name|bytes
return|;
block|}
name|objPtr
operator|->
name|typePtr
operator|->
name|updateStringProc
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|lengthPtr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|lengthPtr
operator|=
name|objPtr
operator|->
name|length
expr_stmt|;
block|}
return|return
name|objPtr
operator|->
name|bytes
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_InvalidateStringRep --  *  *	This procedure is called to invalidate an object's string  *	representation.   *  * Results:  *	None.  *  * Side effects:  *	Deallocates the storage for any old string representation, then  *	sets the string representation NULL to mark it invalid.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_InvalidateStringRep
parameter_list|(
name|objPtr
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Object whose string rep byte pointer 				 * should be freed. */
block|{
if|if
condition|(
name|objPtr
operator|->
name|bytes
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|objPtr
operator|->
name|bytes
operator|!=
name|tclEmptyStringRep
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|objPtr
operator|->
name|bytes
argument_list|)
expr_stmt|;
block|}
name|objPtr
operator|->
name|bytes
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_NewBooleanObj --  *  *	This procedure is normally called when not debugging: i.e., when  *	TCL_MEM_DEBUG is not defined. It creates a new boolean object and  *	initializes it from the argument boolean value. A nonzero  *	"boolValue" is coerced to 1.  *  *	When TCL_MEM_DEBUG is defined, this procedure just returns the  *	result of calling the debugging version Tcl_DbNewBooleanObj.  *  * Results:  *	The newly created object is returned. This object will have an  *	invalid string representation. The returned object has ref count 0.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
end_ifdef

begin_undef
undef|#
directive|undef
name|Tcl_NewBooleanObj
end_undef

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_NewBooleanObj
parameter_list|(
name|boolValue
parameter_list|)
specifier|register
name|int
name|boolValue
decl_stmt|;
comment|/* Boolean used to initialize new object. */
block|{
return|return
name|Tcl_DbNewBooleanObj
argument_list|(
name|boolValue
argument_list|,
literal|"unknown"
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* if not TCL_MEM_DEBUG */
end_comment

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_NewBooleanObj
parameter_list|(
name|boolValue
parameter_list|)
specifier|register
name|int
name|boolValue
decl_stmt|;
comment|/* Boolean used to initialize new object. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|TclNewObj
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|bytes
operator|=
name|NULL
expr_stmt|;
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|=
operator|(
name|boolValue
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclBooleanType
expr_stmt|;
return|return
name|objPtr
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_MEM_DEBUG */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DbNewBooleanObj --  *  *	This procedure is normally called when debugging: i.e., when  *	TCL_MEM_DEBUG is defined. It creates new boolean objects. It is the  *	same as the Tcl_NewBooleanObj procedure above except that it calls  *	Tcl_DbCkalloc directly with the file name and line number from its  *	caller. This simplifies debugging since then the checkmem command  *	will report the correct file name and line number when reporting  *	objects that haven't been freed.  *  *	When TCL_MEM_DEBUG is not defined, this procedure just returns the  *	result of calling Tcl_NewBooleanObj.  *  * Results:  *	The newly created object is returned. This object will have an  *	invalid string representation. The returned object has ref count 0.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
end_ifdef

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_DbNewBooleanObj
parameter_list|(
name|boolValue
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
specifier|register
name|int
name|boolValue
decl_stmt|;
comment|/* Boolean used to initialize new object. */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* The name of the source file calling this 				 * procedure; used for debugging. */
name|int
name|line
decl_stmt|;
comment|/* Line number in the source file; used 				 * for debugging. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|TclDbNewObj
argument_list|(
name|objPtr
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|bytes
operator|=
name|NULL
expr_stmt|;
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|=
operator|(
name|boolValue
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclBooleanType
expr_stmt|;
return|return
name|objPtr
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* if not TCL_MEM_DEBUG */
end_comment

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_DbNewBooleanObj
parameter_list|(
name|boolValue
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
specifier|register
name|int
name|boolValue
decl_stmt|;
comment|/* Boolean used to initialize new object. */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* The name of the source file calling this 				 * procedure; used for debugging. */
name|int
name|line
decl_stmt|;
comment|/* Line number in the source file; used 				 * for debugging. */
block|{
return|return
name|Tcl_NewBooleanObj
argument_list|(
name|boolValue
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_MEM_DEBUG */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetBooleanObj --  *  *	Modify an object to be a boolean object and to have the specified  *	boolean value. A nonzero "boolValue" is coerced to 1.  *  * Results:  *	None.  *  * Side effects:  *	The object's old string rep, if any, is freed. Also, any old  *	internal rep is freed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_SetBooleanObj
parameter_list|(
name|objPtr
parameter_list|,
name|boolValue
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Object whose internal rep to init. */
specifier|register
name|int
name|boolValue
decl_stmt|;
comment|/* Boolean used to set object's value. */
block|{
specifier|register
name|Tcl_ObjType
modifier|*
name|oldTypePtr
init|=
name|objPtr
operator|->
name|typePtr
decl_stmt|;
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|objPtr
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_SetBooleanObj called with shared object"
argument_list|)
expr_stmt|;
block|}
name|Tcl_InvalidateStringRep
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oldTypePtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|oldTypePtr
operator|->
name|freeIntRepProc
operator|!=
name|NULL
operator|)
condition|)
block|{
name|oldTypePtr
operator|->
name|freeIntRepProc
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|=
operator|(
name|boolValue
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclBooleanType
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetBooleanFromObj --  *  *	Attempt to return a boolean from the Tcl object "objPtr". If the  *	object is not already a boolean, an attempt will be made to convert  *	it to one.  *  * Results:  *	The return value is a standard Tcl object result. If an error occurs  *	during conversion, an error message is left in the interpreter's  *	result unless "interp" is NULL.  *  * Side effects:  *	If the object is not already a boolean, the conversion will free  *	any old internal representation.   *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_GetBooleanFromObj
parameter_list|(
name|interp
parameter_list|,
name|objPtr
parameter_list|,
name|boolPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting if not NULL. */
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* The object from which to get boolean. */
specifier|register
name|int
modifier|*
name|boolPtr
decl_stmt|;
comment|/* Place to store resulting boolean. */
block|{
specifier|register
name|int
name|result
decl_stmt|;
name|result
operator|=
name|SetBooleanFromAny
argument_list|(
name|interp
argument_list|,
name|objPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
operator|*
name|boolPtr
operator|=
operator|(
name|int
operator|)
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DupBooleanInternalRep --  *  *	Initialize the internal representation of a boolean Tcl_Obj to a  *	copy of the internal representation of an existing boolean object.   *  * Results:  *	None.  *  * Side effects:  *	"copyPtr"s internal rep is set to the boolean (an integer)  *	corresponding to "srcPtr"s internal rep.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|DupBooleanInternalRep
parameter_list|(
name|srcPtr
parameter_list|,
name|copyPtr
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|srcPtr
decl_stmt|;
comment|/* Object with internal rep to copy. */
specifier|register
name|Tcl_Obj
modifier|*
name|copyPtr
decl_stmt|;
comment|/* Object with internal rep to set. */
block|{
name|copyPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|=
name|srcPtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
name|copyPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclBooleanType
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SetBooleanFromAny --  *  *	Attempt to generate a boolean internal form for the Tcl object  *	"objPtr".  *  * Results:  *	The return value is a standard Tcl result. If an error occurs during  *	conversion, an error message is left in the interpreter's result  *	unless "interp" is NULL.  *  * Side effects:  *	If no error occurs, an integer 1 or 0 is stored as "objPtr"s  *	internal representation and the type of "objPtr" is set to boolean.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SetBooleanFromAny
parameter_list|(
name|interp
parameter_list|,
name|objPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting if not NULL. */
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* The object to convert. */
block|{
name|Tcl_ObjType
modifier|*
name|oldTypePtr
init|=
name|objPtr
operator|->
name|typePtr
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|,
modifier|*
name|end
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|char
name|lowerCase
index|[
literal|10
index|]
decl_stmt|;
name|int
name|newBool
decl_stmt|,
name|length
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|double
name|dbl
decl_stmt|;
comment|/*      * Get the string representation. Make it up-to-date if necessary.      */
name|string
operator|=
name|TclGetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
comment|/*      * Copy the string converting its characters to lower case.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
literal|9
operator|)
operator|&&
operator|(
name|i
operator|<
name|length
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|string
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|UCHAR
argument_list|(
name|c
argument_list|)
argument_list|)
condition|)
block|{
name|c
operator|=
operator|(
name|char
operator|)
name|tolower
argument_list|(
name|UCHAR
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lowerCase
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
name|lowerCase
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/*      * Parse the string as a boolean. We use an implementation here that      * doesn't report errors in interp if interp is NULL.      */
name|c
operator|=
name|lowerCase
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'0'
operator|)
operator|&&
operator|(
name|lowerCase
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|newBool
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'1'
operator|)
operator|&&
operator|(
name|lowerCase
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|newBool
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'y'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|lowerCase
argument_list|,
literal|"yes"
argument_list|,
operator|(
name|size_t
operator|)
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|newBool
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'n'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|lowerCase
argument_list|,
literal|"no"
argument_list|,
operator|(
name|size_t
operator|)
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|newBool
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'t'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|lowerCase
argument_list|,
literal|"true"
argument_list|,
operator|(
name|size_t
operator|)
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|newBool
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'f'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|lowerCase
argument_list|,
literal|"false"
argument_list|,
operator|(
name|size_t
operator|)
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|newBool
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'o'
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|2
operator|)
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|lowerCase
argument_list|,
literal|"on"
argument_list|,
operator|(
name|size_t
operator|)
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newBool
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|lowerCase
argument_list|,
literal|"off"
argument_list|,
operator|(
name|size_t
operator|)
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newBool
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|badBoolean
goto|;
block|}
block|}
else|else
block|{
comment|/*          * Still might be a string containing the characters representing an          * int or double that wasn't handled above. This would be a string          * like "27" or "1.0" that is non-zero and not "1". Such a string          * whould result in the boolean value true. We try converting to          * double. If that succeeds and the resulting double is non-zero, we          * have a "true". Note that numbers can't have embedded NULLs. 	 */
name|dbl
operator|=
name|strtod
argument_list|(
name|string
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|string
condition|)
block|{
goto|goto
name|badBoolean
goto|;
block|}
comment|/* 	 * Make sure the string has no garbage after the end of the double. 	 */
while|while
condition|(
operator|(
name|end
operator|<
operator|(
name|string
operator|+
name|length
operator|)
operator|)
operator|&&
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|end
argument_list|)
argument_list|)
condition|)
block|{
name|end
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|!=
operator|(
name|string
operator|+
name|length
operator|)
condition|)
block|{
goto|goto
name|badBoolean
goto|;
block|}
name|newBool
operator|=
operator|(
name|dbl
operator|!=
literal|0.0
operator|)
expr_stmt|;
block|}
comment|/*      * Free the old internalRep before setting the new one. We do this as      * late as possible to allow the conversion code, in particular      * Tcl_GetStringFromObj, to use that old internalRep.      */
if|if
condition|(
operator|(
name|oldTypePtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|oldTypePtr
operator|->
name|freeIntRepProc
operator|!=
name|NULL
operator|)
condition|)
block|{
name|oldTypePtr
operator|->
name|freeIntRepProc
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|=
name|newBool
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclBooleanType
expr_stmt|;
return|return
name|TCL_OK
return|;
name|badBoolean
label|:
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
comment|/* 	 * Must copy string before resetting the result in case a caller 	 * is trying to convert the interpreter's result to a boolean. 	 */
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"expected boolean value but got \"%.50s\""
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * UpdateStringOfBoolean --  *  *	Update the string representation for a boolean object.  *	Note: This procedure does not free an existing old string rep  *	so storage will be lost if this has not already been done.   *  * Results:  *	None.  *  * Side effects:  *	The object's string is set to a valid string that results from  *	the boolean-to-string conversion.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|UpdateStringOfBoolean
parameter_list|(
name|objPtr
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Int object whose string rep to update. */
block|{
name|char
modifier|*
name|s
init|=
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
literal|2
argument_list|)
decl_stmt|;
name|s
index|[
literal|0
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
condition|?
literal|'1'
else|:
literal|'0'
argument_list|)
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|objPtr
operator|->
name|bytes
operator|=
name|s
expr_stmt|;
name|objPtr
operator|->
name|length
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_NewDoubleObj --  *  *	This procedure is normally called when not debugging: i.e., when  *	TCL_MEM_DEBUG is not defined. It creates a new double object and  *	initializes it from the argument double value.  *  *	When TCL_MEM_DEBUG is defined, this procedure just returns the  *	result of calling the debugging version Tcl_DbNewDoubleObj.  *  * Results:  *	The newly created object is returned. This object will have an  *	invalid string representation. The returned object has ref count 0.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
end_ifdef

begin_undef
undef|#
directive|undef
name|Tcl_NewDoubleObj
end_undef

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_NewDoubleObj
parameter_list|(
name|dblValue
parameter_list|)
specifier|register
name|double
name|dblValue
decl_stmt|;
comment|/* Double used to initialize the object. */
block|{
return|return
name|Tcl_DbNewDoubleObj
argument_list|(
name|dblValue
argument_list|,
literal|"unknown"
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* if not TCL_MEM_DEBUG */
end_comment

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_NewDoubleObj
parameter_list|(
name|dblValue
parameter_list|)
specifier|register
name|double
name|dblValue
decl_stmt|;
comment|/* Double used to initialize the object. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|TclNewObj
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|bytes
operator|=
name|NULL
expr_stmt|;
name|objPtr
operator|->
name|internalRep
operator|.
name|doubleValue
operator|=
name|dblValue
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclDoubleType
expr_stmt|;
return|return
name|objPtr
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* if TCL_MEM_DEBUG */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DbNewDoubleObj --  *  *	This procedure is normally called when debugging: i.e., when  *	TCL_MEM_DEBUG is defined. It creates new double objects. It is the  *	same as the Tcl_NewDoubleObj procedure above except that it calls  *	Tcl_DbCkalloc directly with the file name and line number from its  *	caller. This simplifies debugging since then the checkmem command  *	will report the correct file name and line number when reporting  *	objects that haven't been freed.  *  *	When TCL_MEM_DEBUG is not defined, this procedure just returns the  *	result of calling Tcl_NewDoubleObj.  *  * Results:  *	The newly created object is returned. This object will have an  *	invalid string representation. The returned object has ref count 0.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
end_ifdef

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_DbNewDoubleObj
parameter_list|(
name|dblValue
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
specifier|register
name|double
name|dblValue
decl_stmt|;
comment|/* Double used to initialize the object. */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* The name of the source file calling this 				 * procedure; used for debugging. */
name|int
name|line
decl_stmt|;
comment|/* Line number in the source file; used 				 * for debugging. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|TclDbNewObj
argument_list|(
name|objPtr
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|bytes
operator|=
name|NULL
expr_stmt|;
name|objPtr
operator|->
name|internalRep
operator|.
name|doubleValue
operator|=
name|dblValue
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclDoubleType
expr_stmt|;
return|return
name|objPtr
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* if not TCL_MEM_DEBUG */
end_comment

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_DbNewDoubleObj
parameter_list|(
name|dblValue
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
specifier|register
name|double
name|dblValue
decl_stmt|;
comment|/* Double used to initialize the object. */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* The name of the source file calling this 				 * procedure; used for debugging. */
name|int
name|line
decl_stmt|;
comment|/* Line number in the source file; used 				 * for debugging. */
block|{
return|return
name|Tcl_NewDoubleObj
argument_list|(
name|dblValue
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_MEM_DEBUG */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetDoubleObj --  *  *	Modify an object to be a double object and to have the specified  *	double value.  *  * Results:  *	None.  *  * Side effects:  *	The object's old string rep, if any, is freed. Also, any old  *	internal rep is freed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_SetDoubleObj
parameter_list|(
name|objPtr
parameter_list|,
name|dblValue
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Object whose internal rep to init. */
specifier|register
name|double
name|dblValue
decl_stmt|;
comment|/* Double used to set the object's value. */
block|{
specifier|register
name|Tcl_ObjType
modifier|*
name|oldTypePtr
init|=
name|objPtr
operator|->
name|typePtr
decl_stmt|;
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|objPtr
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_SetDoubleObj called with shared object"
argument_list|)
expr_stmt|;
block|}
name|Tcl_InvalidateStringRep
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oldTypePtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|oldTypePtr
operator|->
name|freeIntRepProc
operator|!=
name|NULL
operator|)
condition|)
block|{
name|oldTypePtr
operator|->
name|freeIntRepProc
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
name|objPtr
operator|->
name|internalRep
operator|.
name|doubleValue
operator|=
name|dblValue
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclDoubleType
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetDoubleFromObj --  *  *	Attempt to return a double from the Tcl object "objPtr". If the  *	object is not already a double, an attempt will be made to convert  *	it to one.  *  * Results:  *	The return value is a standard Tcl object result. If an error occurs  *	during conversion, an error message is left in the interpreter's  *	result unless "interp" is NULL.  *  * Side effects:  *	If the object is not already a double, the conversion will free  *	any old internal representation.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_GetDoubleFromObj
parameter_list|(
name|interp
parameter_list|,
name|objPtr
parameter_list|,
name|dblPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting if not NULL. */
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* The object from which to get a double. */
specifier|register
name|double
modifier|*
name|dblPtr
decl_stmt|;
comment|/* Place to store resulting double. */
block|{
specifier|register
name|int
name|result
decl_stmt|;
if|if
condition|(
name|objPtr
operator|->
name|typePtr
operator|==
operator|&
name|tclDoubleType
condition|)
block|{
operator|*
name|dblPtr
operator|=
name|objPtr
operator|->
name|internalRep
operator|.
name|doubleValue
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
name|result
operator|=
name|SetDoubleFromAny
argument_list|(
name|interp
argument_list|,
name|objPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
operator|*
name|dblPtr
operator|=
name|objPtr
operator|->
name|internalRep
operator|.
name|doubleValue
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DupDoubleInternalRep --  *  *	Initialize the internal representation of a double Tcl_Obj to a  *	copy of the internal representation of an existing double object.   *  * Results:  *	None.  *  * Side effects:  *	"copyPtr"s internal rep is set to the double precision floating   *	point number corresponding to "srcPtr"s internal rep.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|DupDoubleInternalRep
parameter_list|(
name|srcPtr
parameter_list|,
name|copyPtr
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|srcPtr
decl_stmt|;
comment|/* Object with internal rep to copy. */
specifier|register
name|Tcl_Obj
modifier|*
name|copyPtr
decl_stmt|;
comment|/* Object with internal rep to set. */
block|{
name|copyPtr
operator|->
name|internalRep
operator|.
name|doubleValue
operator|=
name|srcPtr
operator|->
name|internalRep
operator|.
name|doubleValue
expr_stmt|;
name|copyPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclDoubleType
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SetDoubleFromAny --  *  *	Attempt to generate an double-precision floating point internal form  *	for the Tcl object "objPtr".  *  * Results:  *	The return value is a standard Tcl object result. If an error occurs  *	during conversion, an error message is left in the interpreter's  *	result unless "interp" is NULL.  *  * Side effects:  *	If no error occurs, a double is stored as "objPtr"s internal  *	representation.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SetDoubleFromAny
parameter_list|(
name|interp
parameter_list|,
name|objPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting if not NULL. */
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* The object to convert. */
block|{
name|Tcl_ObjType
modifier|*
name|oldTypePtr
init|=
name|objPtr
operator|->
name|typePtr
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|double
name|newDouble
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/*      * Get the string representation. Make it up-to-date if necessary.      */
name|string
operator|=
name|TclGetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
comment|/*      * Now parse "objPtr"s string as an double. Numbers can't have embedded      * NULLs. We use an implementation here that doesn't report errors in      * interp if interp is NULL.      */
name|errno
operator|=
literal|0
expr_stmt|;
name|newDouble
operator|=
name|strtod
argument_list|(
name|string
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|string
condition|)
block|{
name|badDouble
label|:
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
comment|/* 	     * Must copy string before resetting the result in case a caller 	     * is trying to convert the interpreter's result to an int. 	     */
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"expected floating-point number but got \"%.50s\""
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|TclExprFloatError
argument_list|(
name|interp
argument_list|,
name|newDouble
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Make sure that the string has no garbage after the end of the double.      */
while|while
condition|(
operator|(
name|end
operator|<
operator|(
name|string
operator|+
name|length
operator|)
operator|)
operator|&&
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|end
argument_list|)
argument_list|)
condition|)
block|{
name|end
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|!=
operator|(
name|string
operator|+
name|length
operator|)
condition|)
block|{
goto|goto
name|badDouble
goto|;
block|}
comment|/*      * The conversion to double succeeded. Free the old internalRep before      * setting the new one. We do this as late as possible to allow the      * conversion code, in particular Tcl_GetStringFromObj, to use that old      * internalRep.      */
if|if
condition|(
operator|(
name|oldTypePtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|oldTypePtr
operator|->
name|freeIntRepProc
operator|!=
name|NULL
operator|)
condition|)
block|{
name|oldTypePtr
operator|->
name|freeIntRepProc
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
name|objPtr
operator|->
name|internalRep
operator|.
name|doubleValue
operator|=
name|newDouble
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclDoubleType
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * UpdateStringOfDouble --  *  *	Update the string representation for a double-precision floating  *	point object. This must obey the current tcl_precision value for  *	double-to-string conversions. Note: This procedure does not free an  *	existing old string rep so storage will be lost if this has not  *	already been done.  *  * Results:  *	None.  *  * Side effects:  *	The object's string is set to a valid string that results from  *	the double-to-string conversion.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|UpdateStringOfDouble
parameter_list|(
name|objPtr
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Double obj with string rep to update. */
block|{
name|char
name|buffer
index|[
name|TCL_DOUBLE_SPACE
index|]
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|Tcl_PrintDouble
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|objPtr
operator|->
name|internalRep
operator|.
name|doubleValue
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|bytes
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|objPtr
operator|->
name|bytes
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|length
operator|=
name|len
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_NewIntObj --  *  *	If a client is compiled with TCL_MEM_DEBUG defined, calls to  *	Tcl_NewIntObj to create a new integer object end up calling the  *	debugging procedure Tcl_DbNewLongObj instead.  *  *	Otherwise, if the client is compiled without TCL_MEM_DEBUG defined,  *	calls to Tcl_NewIntObj result in a call to one of the two  *	Tcl_NewIntObj implementations below. We provide two implementations  *	so that the Tcl core can be compiled to do memory debugging of the   *	core even if a client does not request it for itself.  *  *	Integer and long integer objects share the same "integer" type  *	implementation. We store all integers as longs and Tcl_GetIntFromObj  *	checks whether the current value of the long can be represented by  *	an int.  *  * Results:  *	The newly created object is returned. This object will have an  *	invalid string representation. The returned object has ref count 0.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
end_ifdef

begin_undef
undef|#
directive|undef
name|Tcl_NewIntObj
end_undef

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_NewIntObj
parameter_list|(
name|intValue
parameter_list|)
specifier|register
name|int
name|intValue
decl_stmt|;
comment|/* Int used to initialize the new object. */
block|{
return|return
name|Tcl_DbNewLongObj
argument_list|(
operator|(
name|long
operator|)
name|intValue
argument_list|,
literal|"unknown"
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* if not TCL_MEM_DEBUG */
end_comment

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_NewIntObj
parameter_list|(
name|intValue
parameter_list|)
specifier|register
name|int
name|intValue
decl_stmt|;
comment|/* Int used to initialize the new object. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|TclNewObj
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|bytes
operator|=
name|NULL
expr_stmt|;
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|=
operator|(
name|long
operator|)
name|intValue
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclIntType
expr_stmt|;
return|return
name|objPtr
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* if TCL_MEM_DEBUG */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetIntObj --  *  *	Modify an object to be an integer and to have the specified integer  *	value.  *  * Results:  *	None.  *  * Side effects:  *	The object's old string rep, if any, is freed. Also, any old  *	internal rep is freed.   *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_SetIntObj
parameter_list|(
name|objPtr
parameter_list|,
name|intValue
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Object whose internal rep to init. */
specifier|register
name|int
name|intValue
decl_stmt|;
comment|/* Integer used to set object's value. */
block|{
specifier|register
name|Tcl_ObjType
modifier|*
name|oldTypePtr
init|=
name|objPtr
operator|->
name|typePtr
decl_stmt|;
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|objPtr
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_SetIntObj called with shared object"
argument_list|)
expr_stmt|;
block|}
name|Tcl_InvalidateStringRep
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oldTypePtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|oldTypePtr
operator|->
name|freeIntRepProc
operator|!=
name|NULL
operator|)
condition|)
block|{
name|oldTypePtr
operator|->
name|freeIntRepProc
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|=
operator|(
name|long
operator|)
name|intValue
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclIntType
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetIntFromObj --  *  *	Attempt to return an int from the Tcl object "objPtr". If the object  *	is not already an int, an attempt will be made to convert it to one.  *  *	Integer and long integer objects share the same "integer" type  *	implementation. We store all integers as longs and Tcl_GetIntFromObj  *	checks whether the current value of the long can be represented by  *	an int.  *  * Results:  *	The return value is a standard Tcl object result. If an error occurs  *	during conversion or if the long integer held by the object  *	can not be represented by an int, an error message is left in  *	the interpreter's result unless "interp" is NULL.  *  * Side effects:  *	If the object is not already an int, the conversion will free  *	any old internal representation.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_GetIntFromObj
parameter_list|(
name|interp
parameter_list|,
name|objPtr
parameter_list|,
name|intPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting if not NULL. */
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* The object from which to get a int. */
specifier|register
name|int
modifier|*
name|intPtr
decl_stmt|;
comment|/* Place to store resulting int. */
block|{
specifier|register
name|long
name|l
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|objPtr
operator|->
name|typePtr
operator|!=
operator|&
name|tclIntType
condition|)
block|{
name|result
operator|=
name|SetIntFromAny
argument_list|(
name|interp
argument_list|,
name|objPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
name|l
operator|=
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
if|if
condition|(
operator|(
call|(
name|long
call|)
argument_list|(
operator|(
name|int
operator|)
name|l
argument_list|)
operator|)
operator|==
name|l
condition|)
block|{
operator|*
name|intPtr
operator|=
operator|(
name|int
operator|)
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"integer value too large to represent as non-long integer"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DupIntInternalRep --  *  *	Initialize the internal representation of an int Tcl_Obj to a  *	copy of the internal representation of an existing int object.   *  * Results:  *	None.  *  * Side effects:  *	"copyPtr"s internal rep is set to the integer corresponding to  *	"srcPtr"s internal rep.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|DupIntInternalRep
parameter_list|(
name|srcPtr
parameter_list|,
name|copyPtr
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|srcPtr
decl_stmt|;
comment|/* Object with internal rep to copy. */
specifier|register
name|Tcl_Obj
modifier|*
name|copyPtr
decl_stmt|;
comment|/* Object with internal rep to set. */
block|{
name|copyPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|=
name|srcPtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
name|copyPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclIntType
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SetIntFromAny --  *  *	Attempt to generate an integer internal form for the Tcl object  *	"objPtr".  *  * Results:  *	The return value is a standard object Tcl result. If an error occurs  *	during conversion, an error message is left in the interpreter's  *	result unless "interp" is NULL.  *  * Side effects:  *	If no error occurs, an int is stored as "objPtr"s internal  *	representation.   *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SetIntFromAny
parameter_list|(
name|interp
parameter_list|,
name|objPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting if not NULL. */
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* The object to convert. */
block|{
name|Tcl_ObjType
modifier|*
name|oldTypePtr
init|=
name|objPtr
operator|->
name|typePtr
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|length
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|long
name|newLong
decl_stmt|;
comment|/*      * Get the string representation. Make it up-to-date if necessary.      */
name|string
operator|=
name|TclGetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
comment|/*      * Now parse "objPtr"s string as an int. We use an implementation here      * that doesn't report errors in interp if interp is NULL. Note: use      * strtoul instead of strtol for integer conversions to allow full-size      * unsigned numbers, but don't depend on strtoul to handle sign      * characters; it won't in some implementations.      */
name|errno
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|string
init|;
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|;
name|p
operator|++
control|)
block|{
comment|/* Empty loop body. */
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|newLong
operator|=
operator|-
operator|(
operator|(
name|long
operator|)
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'+'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|newLong
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newLong
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|==
name|p
condition|)
block|{
name|badInteger
label|:
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
comment|/* 	     * Must copy string before resetting the result in case a caller 	     * is trying to convert the interpreter's result to an int. 	     */
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"expected integer but got \"%.50s\""
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|errno
operator|==
name|ERANGE
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|s
init|=
literal|"integer value too large to represent"
decl_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|s
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"ARITH"
argument_list|,
literal|"IOVERFLOW"
argument_list|,
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Make sure that the string has no garbage after the end of the int.      */
while|while
condition|(
operator|(
name|end
operator|<
operator|(
name|string
operator|+
name|length
operator|)
operator|)
operator|&&
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|end
argument_list|)
argument_list|)
condition|)
block|{
name|end
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|!=
operator|(
name|string
operator|+
name|length
operator|)
condition|)
block|{
goto|goto
name|badInteger
goto|;
block|}
comment|/*      * The conversion to int succeeded. Free the old internalRep before      * setting the new one. We do this as late as possible to allow the      * conversion code, in particular Tcl_GetStringFromObj, to use that old      * internalRep.      */
if|if
condition|(
operator|(
name|oldTypePtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|oldTypePtr
operator|->
name|freeIntRepProc
operator|!=
name|NULL
operator|)
condition|)
block|{
name|oldTypePtr
operator|->
name|freeIntRepProc
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|=
name|newLong
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclIntType
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * UpdateStringOfInt --  *  *	Update the string representation for an integer object.  *	Note: This procedure does not free an existing old string rep  *	so storage will be lost if this has not already been done.   *  * Results:  *	None.  *  * Side effects:  *	The object's string is set to a valid string that results from  *	the int-to-string conversion.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|UpdateStringOfInt
parameter_list|(
name|objPtr
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Int object whose string rep to update. */
block|{
name|char
name|buffer
index|[
name|TCL_DOUBLE_SPACE
index|]
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|len
operator|=
name|TclFormatInt
argument_list|(
name|buffer
argument_list|,
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|bytes
operator|=
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|objPtr
operator|->
name|bytes
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|length
operator|=
name|len
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_NewLongObj --  *  *	If a client is compiled with TCL_MEM_DEBUG defined, calls to  *	Tcl_NewLongObj to create a new long integer object end up calling  *	the debugging procedure Tcl_DbNewLongObj instead.  *  *	Otherwise, if the client is compiled without TCL_MEM_DEBUG defined,  *	calls to Tcl_NewLongObj result in a call to one of the two  *	Tcl_NewLongObj implementations below. We provide two implementations  *	so that the Tcl core can be compiled to do memory debugging of the   *	core even if a client does not request it for itself.  *  *	Integer and long integer objects share the same "integer" type  *	implementation. We store all integers as longs and Tcl_GetIntFromObj  *	checks whether the current value of the long can be represented by  *	an int.  *  * Results:  *	The newly created object is returned. This object will have an  *	invalid string representation. The returned object has ref count 0.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
end_ifdef

begin_undef
undef|#
directive|undef
name|Tcl_NewLongObj
end_undef

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_NewLongObj
parameter_list|(
name|longValue
parameter_list|)
specifier|register
name|long
name|longValue
decl_stmt|;
comment|/* Long integer used to initialize the 				 * new object. */
block|{
return|return
name|Tcl_DbNewLongObj
argument_list|(
name|longValue
argument_list|,
literal|"unknown"
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* if not TCL_MEM_DEBUG */
end_comment

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_NewLongObj
parameter_list|(
name|longValue
parameter_list|)
specifier|register
name|long
name|longValue
decl_stmt|;
comment|/* Long integer used to initialize the 				 * new object. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|TclNewObj
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|bytes
operator|=
name|NULL
expr_stmt|;
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|=
name|longValue
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclIntType
expr_stmt|;
return|return
name|objPtr
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* if TCL_MEM_DEBUG */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DbNewLongObj --  *  *	If a client is compiled with TCL_MEM_DEBUG defined, calls to  *	Tcl_NewIntObj and Tcl_NewLongObj to create new integer or  *	long integer objects end up calling the debugging procedure  *	Tcl_DbNewLongObj instead. We provide two implementations of  *	Tcl_DbNewLongObj so that whether the Tcl core is compiled to do  *	memory debugging of the core is independent of whether a client  *	requests debugging for itself.  *  *	When the core is compiled with TCL_MEM_DEBUG defined,  *	Tcl_DbNewLongObj calls Tcl_DbCkalloc directly with the file name and  *	line number from its caller. This simplifies debugging since then  *	the checkmem command will report the caller's file name and line  *	number when reporting objects that haven't been freed.  *  *	Otherwise, when the core is compiled without TCL_MEM_DEBUG defined,  *	this procedure just returns the result of calling Tcl_NewLongObj.  *  * Results:  *	The newly created long integer object is returned. This object  *	will have an invalid string representation. The returned object has  *	ref count 0.  *  * Side effects:  *	Allocates memory.  *  *----------------------------------------------------------------------  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
end_ifdef

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_DbNewLongObj
parameter_list|(
name|longValue
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
specifier|register
name|long
name|longValue
decl_stmt|;
comment|/* Long integer used to initialize the 				 * new object. */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* The name of the source file calling this 				 * procedure; used for debugging. */
name|int
name|line
decl_stmt|;
comment|/* Line number in the source file; used 				 * for debugging. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|TclDbNewObj
argument_list|(
name|objPtr
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|bytes
operator|=
name|NULL
expr_stmt|;
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|=
name|longValue
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclIntType
expr_stmt|;
return|return
name|objPtr
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* if not TCL_MEM_DEBUG */
end_comment

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_DbNewLongObj
parameter_list|(
name|longValue
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
specifier|register
name|long
name|longValue
decl_stmt|;
comment|/* Long integer used to initialize the 				 * new object. */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* The name of the source file calling this 				 * procedure; used for debugging. */
name|int
name|line
decl_stmt|;
comment|/* Line number in the source file; used 				 * for debugging. */
block|{
return|return
name|Tcl_NewLongObj
argument_list|(
name|longValue
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_MEM_DEBUG */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetLongObj --  *  *	Modify an object to be an integer object and to have the specified  *	long integer value.  *  * Results:  *	None.  *  * Side effects:  *	The object's old string rep, if any, is freed. Also, any old  *	internal rep is freed.   *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_SetLongObj
parameter_list|(
name|objPtr
parameter_list|,
name|longValue
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Object whose internal rep to init. */
specifier|register
name|long
name|longValue
decl_stmt|;
comment|/* Long integer used to initialize the 				 * object's value. */
block|{
specifier|register
name|Tcl_ObjType
modifier|*
name|oldTypePtr
init|=
name|objPtr
operator|->
name|typePtr
decl_stmt|;
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|objPtr
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_SetLongObj called with shared object"
argument_list|)
expr_stmt|;
block|}
name|Tcl_InvalidateStringRep
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oldTypePtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|oldTypePtr
operator|->
name|freeIntRepProc
operator|!=
name|NULL
operator|)
condition|)
block|{
name|oldTypePtr
operator|->
name|freeIntRepProc
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|=
name|longValue
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclIntType
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetLongFromObj --  *  *	Attempt to return an long integer from the Tcl object "objPtr". If  *	the object is not already an int object, an attempt will be made to  *	convert it to one.  *  * Results:  *	The return value is a standard Tcl object result. If an error occurs  *	during conversion, an error message is left in the interpreter's  *	result unless "interp" is NULL.  *  * Side effects:  *	If the object is not already an int object, the conversion will free  *	any old internal representation.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_GetLongFromObj
parameter_list|(
name|interp
parameter_list|,
name|objPtr
parameter_list|,
name|longPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting if not NULL. */
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* The object from which to get a long. */
specifier|register
name|long
modifier|*
name|longPtr
decl_stmt|;
comment|/* Place to store resulting long. */
block|{
specifier|register
name|int
name|result
decl_stmt|;
if|if
condition|(
name|objPtr
operator|->
name|typePtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
operator|*
name|longPtr
operator|=
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
name|result
operator|=
name|SetIntFromAny
argument_list|(
name|interp
argument_list|,
name|objPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
operator|*
name|longPtr
operator|=
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DbIncrRefCount --  *  *	This procedure is normally called when debugging: i.e., when  *	TCL_MEM_DEBUG is defined. This checks to see whether or not  *	the memory has been freed before incrementing the ref count.  *  *	When TCL_MEM_DEBUG is not defined, this procedure just increments  *	the reference count of the object.  *  * Results:  *	None.  *  * Side effects:  *	The object's ref count is incremented.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DbIncrRefCount
parameter_list|(
name|objPtr
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* The object we are adding a reference to. */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* The name of the source file calling this 				 * procedure; used for debugging. */
name|int
name|line
decl_stmt|;
comment|/* Line number in the source file; used 				 * for debugging. */
block|{
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
if|if
condition|(
name|objPtr
operator|->
name|refCount
operator|==
literal|0x61616161
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"file = %s, line = %d\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Trying to increment refCount of previously disposed object."
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|++
operator|(
name|objPtr
operator|)
operator|->
name|refCount
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DbDecrRefCount --  *  *	This procedure is normally called when debugging: i.e., when  *	TCL_MEM_DEBUG is defined. This checks to see whether or not  *	the memory has been freed before incrementing the ref count.  *  *	When TCL_MEM_DEBUG is not defined, this procedure just increments  *	the reference count of the object.  *  * Results:  *	None.  *  * Side effects:  *	The object's ref count is incremented.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DbDecrRefCount
parameter_list|(
name|objPtr
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* The object we are adding a reference to. */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* The name of the source file calling this 				 * procedure; used for debugging. */
name|int
name|line
decl_stmt|;
comment|/* Line number in the source file; used 				 * for debugging. */
block|{
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
if|if
condition|(
name|objPtr
operator|->
name|refCount
operator|==
literal|0x61616161
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"file = %s, line = %d\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Trying to decrement refCount of previously disposed object."
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|--
operator|(
name|objPtr
operator|)
operator|->
name|refCount
operator|<=
literal|0
condition|)
block|{
name|TclFreeObj
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DbIsShared --  *  *	This procedure is normally called when debugging: i.e., when  *	TCL_MEM_DEBUG is defined. This checks to see whether or not  *	the memory has been freed before incrementing the ref count.  *  *	When TCL_MEM_DEBUG is not defined, this procedure just decrements  *	the reference count of the object and throws it away if the count  *	is 0 or less.  *  * Results:  *	None.  *  * Side effects:  *	The object's ref count is incremented.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_DbIsShared
parameter_list|(
name|objPtr
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* The object we are adding a reference to. */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* The name of the source file calling this 				 * procedure; used for debugging. */
name|int
name|line
decl_stmt|;
comment|/* Line number in the source file; used 				 * for debugging. */
block|{
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
if|if
condition|(
name|objPtr
operator|->
name|refCount
operator|==
literal|0x61616161
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"file = %s, line = %d\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Trying to check whether previously disposed object is shared."
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
operator|(
name|objPtr
operator|)
operator|->
name|refCount
operator|>
literal|1
operator|)
return|;
block|}
end_function

end_unit

