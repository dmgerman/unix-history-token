begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclStringObj.c --  *  *	This file contains procedures that implement string operations  *	on Tcl objects.  To do this efficiently (i.e. to allow many  *	appends to be done to an object without constantly reallocating  *	the space for the string representation) we overallocate the  *	space for the string and use the internal representation to keep  *	track of the extra space.  Objects with this internal  *	representation are called "expandable string objects".  *  * Copyright (c) 1995-1997 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclStringObj.c 1.30 97/07/24 18:53:30  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_comment
comment|/*  * Prototypes for procedures defined later in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ConvertToStringType
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Obj
operator|*
name|objPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DupStringInternalRep
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Obj
operator|*
name|objPtr
operator|,
name|Tcl_Obj
operator|*
name|copyPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SetStringFromAny
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Obj
operator|*
name|objPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|UpdateStringOfString
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Obj
operator|*
name|objPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The structure below defines the string Tcl object type by means of  * procedures that can be invoked by generic object code.  */
end_comment

begin_decl_stmt
name|Tcl_ObjType
name|tclStringType
init|=
block|{
literal|"string"
block|,
comment|/* name */
operator|(
name|Tcl_FreeInternalRepProc
operator|*
operator|)
name|NULL
block|,
comment|/* freeIntRepProc */
name|DupStringInternalRep
block|,
comment|/* dupIntRepProc */
name|UpdateStringOfString
block|,
comment|/* updateStringProc */
name|SetStringFromAny
comment|/* setFromAnyProc */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_NewStringObj --  *  *	This procedure is normally called when not debugging: i.e., when  *	TCL_MEM_DEBUG is not defined. It creates a new string object and  *	initializes it from the byte pointer and length arguments.  *  *	When TCL_MEM_DEBUG is defined, this procedure just returns the  *	result of calling the debugging version Tcl_DbNewStringObj.  *  * Results:  *	A newly created string object is returned that has ref count zero.  *  * Side effects:  *	The new object's internal string representation will be set to a  *	copy of the length bytes starting at "bytes". If "length" is  *	negative, use bytes up to the first NULL byte; i.e., assume "bytes"  *	points to a C-style NULL-terminated string. The object's type is set  *	to NULL. An extra NULL is added to the end of the new object's byte  *	array.  *  *----------------------------------------------------------------------  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
end_ifdef

begin_undef
undef|#
directive|undef
name|Tcl_NewStringObj
end_undef

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_NewStringObj
parameter_list|(
name|bytes
parameter_list|,
name|length
parameter_list|)
specifier|register
name|char
modifier|*
name|bytes
decl_stmt|;
comment|/* Points to the first of the length bytes 				 * used to initialize the new object. */
specifier|register
name|int
name|length
decl_stmt|;
comment|/* The number of bytes to copy from "bytes" 				 * when initializing the new object. If  				 * negative, use bytes up to the first 				 * NULL byte. */
block|{
return|return
name|Tcl_DbNewStringObj
argument_list|(
name|bytes
argument_list|,
name|length
argument_list|,
literal|"unknown"
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* if not TCL_MEM_DEBUG */
end_comment

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_NewStringObj
parameter_list|(
name|bytes
parameter_list|,
name|length
parameter_list|)
specifier|register
name|char
modifier|*
name|bytes
decl_stmt|;
comment|/* Points to the first of the length bytes 				 * used to initialize the new object. */
specifier|register
name|int
name|length
decl_stmt|;
comment|/* The number of bytes to copy from "bytes" 				 * when initializing the new object. If  				 * negative, use bytes up to the first 				 * NULL byte. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
name|length
operator|=
name|bytes
condition|?
name|strlen
argument_list|(
name|bytes
argument_list|)
else|:
literal|0
expr_stmt|;
block|}
name|TclNewObj
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|TclInitStringRep
argument_list|(
name|objPtr
argument_list|,
name|bytes
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|objPtr
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_MEM_DEBUG */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DbNewStringObj --  *  *	This procedure is normally called when debugging: i.e., when  *	TCL_MEM_DEBUG is defined. It creates new string objects. It is the  *	same as the Tcl_NewStringObj procedure above except that it calls  *	Tcl_DbCkalloc directly with the file name and line number from its  *	caller. This simplifies debugging since then the checkmem command  *	will report the correct file name and line number when reporting  *	objects that haven't been freed.  *  *	When TCL_MEM_DEBUG is not defined, this procedure just returns the  *	result of calling Tcl_NewStringObj.  *  * Results:  *	A newly created string object is returned that has ref count zero.  *  * Side effects:  *	The new object's internal string representation will be set to a  *	copy of the length bytes starting at "bytes". If "length" is  *	negative, use bytes up to the first NULL byte; i.e., assume "bytes"  *	points to a C-style NULL-terminated string. The object's type is set  *	to NULL. An extra NULL is added to the end of the new object's byte  *	array.  *  *----------------------------------------------------------------------  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
end_ifdef

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_DbNewStringObj
parameter_list|(
name|bytes
parameter_list|,
name|length
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
specifier|register
name|char
modifier|*
name|bytes
decl_stmt|;
comment|/* Points to the first of the length bytes 				 * used to initialize the new object. */
specifier|register
name|int
name|length
decl_stmt|;
comment|/* The number of bytes to copy from "bytes" 				 * when initializing the new object. If  				 * negative, use bytes up to the first 				 * NULL byte. */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* The name of the source file calling this 				 * procedure; used for debugging. */
name|int
name|line
decl_stmt|;
comment|/* Line number in the source file; used 				 * for debugging. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
name|length
operator|=
name|strlen
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
name|TclDbNewObj
argument_list|(
name|objPtr
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|TclInitStringRep
argument_list|(
name|objPtr
argument_list|,
name|bytes
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|objPtr
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* if not TCL_MEM_DEBUG */
end_comment

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_DbNewStringObj
parameter_list|(
name|bytes
parameter_list|,
name|length
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
specifier|register
name|char
modifier|*
name|bytes
decl_stmt|;
comment|/* Points to the first of the length bytes 				 * used to initialize the new object. */
specifier|register
name|int
name|length
decl_stmt|;
comment|/* The number of bytes to copy from "bytes" 				 * when initializing the new object. If  				 * negative, use bytes up to the first 				 * NULL byte. */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* The name of the source file calling this 				 * procedure; used for debugging. */
name|int
name|line
decl_stmt|;
comment|/* Line number in the source file; used 				 * for debugging. */
block|{
return|return
name|Tcl_NewStringObj
argument_list|(
name|bytes
argument_list|,
name|length
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_MEM_DEBUG */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetStringObj --  *  *	Modify an object to hold a string that is a copy of the bytes  *	indicated by the byte pointer and length arguments.   *  * Results:  *	None.  *  * Side effects:  *	The object's string representation will be set to a copy of  *	the "length" bytes starting at "bytes". If "length" is negative, use  *	bytes up to the first NULL byte; i.e., assume "bytes" points to a  *	C-style NULL-terminated string. The object's old string and internal  *	representations are freed and the object's type is set NULL.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_SetStringObj
parameter_list|(
name|objPtr
parameter_list|,
name|bytes
parameter_list|,
name|length
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Object whose internal rep to init. */
name|char
modifier|*
name|bytes
decl_stmt|;
comment|/* Points to the first of the length bytes 				 * used to initialize the object. */
specifier|register
name|int
name|length
decl_stmt|;
comment|/* The number of bytes to copy from "bytes" 				 * when initializing the object. If  				 * negative, use bytes up to the first 				 * NULL byte.*/
block|{
specifier|register
name|Tcl_ObjType
modifier|*
name|oldTypePtr
init|=
name|objPtr
operator|->
name|typePtr
decl_stmt|;
comment|/*      * Free any old string rep, then set the string rep to a copy of      * the length bytes starting at "bytes".      */
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|objPtr
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_SetStringObj called with shared object"
argument_list|)
expr_stmt|;
block|}
name|Tcl_InvalidateStringRep
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
name|length
operator|=
name|strlen
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
name|TclInitStringRep
argument_list|(
name|objPtr
argument_list|,
name|bytes
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/*      * Set the type to NULL and free any internal rep for the old type.      */
if|if
condition|(
operator|(
name|oldTypePtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|oldTypePtr
operator|->
name|freeIntRepProc
operator|!=
name|NULL
operator|)
condition|)
block|{
name|oldTypePtr
operator|->
name|freeIntRepProc
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
name|objPtr
operator|->
name|typePtr
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetObjLength --  *  *	This procedure changes the length of the string representation  *	of an object.  *  * Results:  *	None.  *  * Side effects:  *	If the size of objPtr's string representation is greater than  *	length, then it is reduced to length and a new terminating null  *	byte is stored in the strength.  If the length of the string  *	representation is greater than length, the storage space is  *	reallocated to the given length; a null byte is stored at the  *	end, but other bytes past the end of the original string  *	representation are undefined.  The object's internal  *	representation is changed to "expendable string".  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_SetObjLength
parameter_list|(
name|objPtr
parameter_list|,
name|length
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Pointer to object.  This object must 				 * not currently be shared. */
specifier|register
name|int
name|length
decl_stmt|;
comment|/* Number of bytes desired for string 				 * representation of object, not including 				 * terminating null byte. */
block|{
name|char
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|objPtr
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_SetObjLength called with shared object"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|objPtr
operator|->
name|typePtr
operator|!=
operator|&
name|tclStringType
condition|)
block|{
name|ConvertToStringType
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|long
operator|)
name|length
operator|>
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
condition|)
block|{
comment|/* 	 * Not enough space in current string. Reallocate the string 	 * space and free the old string. 	 */
name|new
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|length
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|objPtr
operator|->
name|bytes
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|new
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|objPtr
operator|->
name|bytes
argument_list|,
operator|(
name|size_t
operator|)
name|objPtr
operator|->
name|length
argument_list|)
expr_stmt|;
name|Tcl_InvalidateStringRep
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
name|objPtr
operator|->
name|bytes
operator|=
name|new
expr_stmt|;
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|=
operator|(
name|long
operator|)
name|length
expr_stmt|;
block|}
name|objPtr
operator|->
name|length
operator|=
name|length
expr_stmt|;
if|if
condition|(
operator|(
name|objPtr
operator|->
name|bytes
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|objPtr
operator|->
name|bytes
operator|!=
name|tclEmptyStringRep
operator|)
condition|)
block|{
name|objPtr
operator|->
name|bytes
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_AppendToObj --  *  *	This procedure appends a sequence of bytes to an object.  *  * Results:  *	None.  *  * Side effects:  *	The bytes at *bytes are appended to the string representation  *	of objPtr.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_AppendToObj
parameter_list|(
name|objPtr
parameter_list|,
name|bytes
parameter_list|,
name|length
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Points to the object to append to. */
name|char
modifier|*
name|bytes
decl_stmt|;
comment|/* Points to the bytes to append to the 				 * object. */
specifier|register
name|int
name|length
decl_stmt|;
comment|/* The number of bytes to append from 				 * "bytes". If< 0, then append all bytes 				 * up to NULL byte. */
block|{
name|int
name|newLength
decl_stmt|,
name|oldLength
decl_stmt|;
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|objPtr
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_AppendToObj called with shared object"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|objPtr
operator|->
name|typePtr
operator|!=
operator|&
name|tclStringType
condition|)
block|{
name|ConvertToStringType
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
name|length
operator|=
name|strlen
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|oldLength
operator|=
name|objPtr
operator|->
name|length
expr_stmt|;
name|newLength
operator|=
name|length
operator|+
name|oldLength
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|newLength
operator|>
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
condition|)
block|{
comment|/* 	 * There isn't currently enough space in the string 	 * representation so allocate additional space.  In fact, 	 * overallocate so that there is room for future growth without 	 * having to reallocate again. 	 */
name|Tcl_SetObjLength
argument_list|(
name|objPtr
argument_list|,
literal|2
operator|*
name|newLength
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
operator|(
name|objPtr
operator|->
name|bytes
operator|+
name|oldLength
operator|)
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|bytes
argument_list|,
operator|(
name|size_t
operator|)
name|length
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|length
operator|=
name|newLength
expr_stmt|;
name|objPtr
operator|->
name|bytes
index|[
name|objPtr
operator|->
name|length
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_AppendStringsToObj --  *  *	This procedure appends one or more null-terminated strings  *	to an object.  *  * Results:  *	None.  *  * Side effects:  *	The contents of all the string arguments are appended to the  *	string representation of objPtr.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_AppendStringsToObj
name|TCL_VARARGS_DEF
parameter_list|(
name|Tcl_Obj
modifier|*
parameter_list|,
name|arg1
parameter_list|)
block|{
name|va_list
name|argList
decl_stmt|;
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|int
name|newLength
decl_stmt|,
name|oldLength
decl_stmt|;
specifier|register
name|char
modifier|*
name|string
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|objPtr
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|)
name|TCL_VARARGS_START
argument_list|(
name|Tcl_Obj
operator|*
argument_list|,
name|arg1
argument_list|,
name|argList
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|objPtr
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_AppendStringsToObj called with shared object"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|objPtr
operator|->
name|typePtr
operator|!=
operator|&
name|tclStringType
condition|)
block|{
name|ConvertToStringType
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * Figure out how much space is needed for all the strings, and      * expand the string representation if it isn't big enough. If no      * bytes would be appended, just return.      */
name|newLength
operator|=
name|oldLength
operator|=
name|objPtr
operator|->
name|length
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|string
operator|=
name|va_arg
argument_list|(
name|argList
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|newLength
operator|+=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newLength
operator|==
name|oldLength
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|(
name|long
operator|)
name|newLength
operator|>
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
condition|)
block|{
comment|/* 	 * There isn't currently enough space in the string 	 * representation so allocate additional space.  If the current 	 * string representation isn't empty (i.e. it looks like we're 	 * doing a series of appends) then overallocate the space so 	 * that we won't have to do as much reallocation in the future. 	 */
name|Tcl_SetObjLength
argument_list|(
name|objPtr
argument_list|,
operator|(
name|objPtr
operator|->
name|length
operator|==
literal|0
operator|)
condition|?
name|newLength
else|:
literal|2
operator|*
name|newLength
argument_list|)
expr_stmt|;
block|}
comment|/*      * Make a second pass through the arguments, appending all the      * strings to the object.      */
name|TCL_VARARGS_START
argument_list|(
name|Tcl_Obj
operator|*
argument_list|,
name|arg1
argument_list|,
name|argList
argument_list|)
expr_stmt|;
name|dst
operator|=
name|objPtr
operator|->
name|bytes
operator|+
name|oldLength
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|string
operator|=
name|va_arg
argument_list|(
name|argList
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
while|while
condition|(
operator|*
name|string
operator|!=
literal|0
condition|)
block|{
operator|*
name|dst
operator|=
operator|*
name|string
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|string
operator|++
expr_stmt|;
block|}
block|}
comment|/*      * Add a null byte to terminate the string.  However, be careful:      * it's possible that the object is totally empty (if it was empty      * originally and there was nothing to append).  In this case dst is      * NULL; just leave everything alone.      */
if|if
condition|(
name|dst
operator|!=
name|NULL
condition|)
block|{
operator|*
name|dst
operator|=
literal|0
expr_stmt|;
block|}
name|objPtr
operator|->
name|length
operator|=
name|newLength
expr_stmt|;
name|va_end
argument_list|(
name|argList
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * ConvertToStringType --  *  *	This procedure converts the internal representation of an object  *	to "expandable string" type.  *  * Results:  *	None.  *  * Side effects:  *	Any old internal reputation for objPtr is freed and the  *	internal representation is set to that for an expandable string  *	(the field internalRep.longValue holds 1 less than the allocated  *	length of objPtr's string representation).  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ConvertToStringType
parameter_list|(
name|objPtr
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Pointer to object.  Must have a 				 * typePtr that isn't&tclStringType. */
block|{
if|if
condition|(
name|objPtr
operator|->
name|typePtr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|objPtr
operator|->
name|bytes
operator|==
name|NULL
condition|)
block|{
name|objPtr
operator|->
name|typePtr
operator|->
name|updateStringProc
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|objPtr
operator|->
name|typePtr
operator|->
name|freeIntRepProc
operator|!=
name|NULL
condition|)
block|{
name|objPtr
operator|->
name|typePtr
operator|->
name|freeIntRepProc
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
block|}
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclStringType
expr_stmt|;
if|if
condition|(
name|objPtr
operator|->
name|bytes
operator|!=
name|NULL
condition|)
block|{
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|=
operator|(
name|long
operator|)
name|objPtr
operator|->
name|length
expr_stmt|;
block|}
else|else
block|{
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|=
literal|0
expr_stmt|;
name|objPtr
operator|->
name|length
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DupStringInternalRep --  *  *	Initialize the internal representation of a new Tcl_Obj to a  *	copy of the internal representation of an existing string object.  *  * Results:  *	None.  *  * Side effects:  *	copyPtr's internal rep is set to a copy of srcPtr's internal  *	representation.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|DupStringInternalRep
parameter_list|(
name|srcPtr
parameter_list|,
name|copyPtr
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|srcPtr
decl_stmt|;
comment|/* Object with internal rep to copy.  Must 				 * have an internal representation of type 				 * "expandable string". */
specifier|register
name|Tcl_Obj
modifier|*
name|copyPtr
decl_stmt|;
comment|/* Object with internal rep to set.  Must 				 * not currently have an internal rep.*/
block|{
comment|/*      * Tricky point: the string value was copied by generic object      * management code, so it doesn't contain any extra bytes that      * might exist in the source object.      */
name|copyPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|=
operator|(
name|long
operator|)
name|copyPtr
operator|->
name|length
expr_stmt|;
name|copyPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclStringType
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SetStringFromAny --  *  *	Create an internal representation of type "expandable string"  *	for an object.  *  * Results:  *	This operation always succeeds and returns TCL_OK.  *  * Side effects:  *	This procedure does nothing; there is no advantage in converting  *	the internal representation now, so we just defer it.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SetStringFromAny
parameter_list|(
name|interp
parameter_list|,
name|objPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting if not NULL. */
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* The object to convert. */
block|{
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * UpdateStringOfString --  *  *	Update the string representation for an object whose internal  *	representation is "expandable string".  *  * Results:  *	None.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|UpdateStringOfString
parameter_list|(
name|objPtr
parameter_list|)
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Object with string rep to update. */
block|{
comment|/*      * The string is almost always valid already, in which case there's      * nothing for us to do. The only case we have to worry about is if      * the object is totally null. In this case, set the string rep to      * an empty string.      */
if|if
condition|(
name|objPtr
operator|->
name|bytes
operator|==
name|NULL
condition|)
block|{
name|objPtr
operator|->
name|bytes
operator|=
name|tclEmptyStringRep
expr_stmt|;
name|objPtr
operator|->
name|length
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
end_function

end_unit

