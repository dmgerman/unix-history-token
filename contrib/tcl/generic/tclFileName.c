begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclFileName.c --  *  *	This file contains routines for converting file names betwen  *	native and network form.  *  * Copyright (c) 1995-1996 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclFileName.c 1.31 97/08/05 15:23:04  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_include
include|#
directive|include
file|"tclRegexp.h"
end_include

begin_comment
comment|/*  * This variable indicates whether the cleanup procedure has been  * registered for this file yet.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The following regular expression matches the root portion of a Windows  * absolute or volume relative path.  It will match both UNC and drive relative  * paths.  */
end_comment

begin_define
define|#
directive|define
name|WIN_ROOT_PATTERN
value|"^(([a-zA-Z]:)|[/\\][/\\]+([^/\\]+)[/\\]+([^/\\]+)|([/\\]))([/\\])*"
end_define

begin_comment
comment|/*  * The following regular expression matches the root portion of a Macintosh  * absolute path.  It will match degenerate Unix-style paths, tilde paths,  * Unix-style paths, and Mac paths.  */
end_comment

begin_define
define|#
directive|define
name|MAC_ROOT_PATTERN
value|"^((/+([.][.]?/+)*([.][.]?)?)|(~[^:/]*)(/[^:]*)?|(~[^:]*)(:.*)?|/+([.][.]?/+)*([^:/]+)(/[^:]*)?|([^:]+):.*)$"
end_define

begin_comment
comment|/*  * The following variables are used to hold precompiled regular expressions  * for use in filename matching.  */
end_comment

begin_decl_stmt
specifier|static
name|regexp
modifier|*
name|winRootPatternPtr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regexp
modifier|*
name|macRootPatternPtr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The following variable is set in the TclPlatformInit call to one  * of: TCL_PLATFORM_UNIX, TCL_PLATFORM_MAC, or TCL_PLATFORM_WINDOWS.  */
end_comment

begin_decl_stmt
name|TclPlatformType
name|tclPlatform
init|=
name|TCL_PLATFORM_UNIX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Prototypes for local procedures defined in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|DoTildeSubst
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|user
operator|,
name|Tcl_DString
operator|*
name|resultPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ExtractWinRoot
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|path
operator|,
name|Tcl_DString
operator|*
name|resultPtr
operator|,
name|int
name|offset
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|FileNameCleanup
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SkipToChar
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
operator|*
name|stringPtr
operator|,
name|char
operator|*
name|match
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SplitMacPath
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|path
operator|,
name|Tcl_DString
operator|*
name|bufPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SplitWinPath
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|path
operator|,
name|Tcl_DString
operator|*
name|bufPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SplitUnixPath
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|path
operator|,
name|Tcl_DString
operator|*
name|bufPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FileNameCleanup --  *  *	This procedure is a Tcl_ExitProc used to clean up the static  *	data structures used in this file.  *  * Results:  *	None.  *  * Side effects:  *	Deallocates storage used by the procedures in this file.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|FileNameCleanup
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
block|{
if|if
condition|(
name|winRootPatternPtr
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|winRootPatternPtr
argument_list|)
expr_stmt|;
name|winRootPatternPtr
operator|=
operator|(
name|regexp
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|macRootPatternPtr
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|macRootPatternPtr
argument_list|)
expr_stmt|;
name|macRootPatternPtr
operator|=
operator|(
name|regexp
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * ExtractWinRoot --  *  *	Matches the root portion of a Windows path and appends it  *	to the specified Tcl_DString.  *	  * Results:  *	Returns the position in the path immediately after the root  *	including any trailing slashes.  *	Appends a cleaned up version of the root to the Tcl_DString  *	at the specified offest.  *  * Side effects:  *	Modifies the specified Tcl_DString.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ExtractWinRoot
parameter_list|(
name|path
parameter_list|,
name|resultPtr
parameter_list|,
name|offset
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Path to parse. */
name|Tcl_DString
modifier|*
name|resultPtr
decl_stmt|;
comment|/* Buffer to hold result. */
name|int
name|offset
decl_stmt|;
comment|/* Offset in buffer where result should be 				 * stored. */
block|{
name|int
name|length
decl_stmt|;
comment|/*      * Initialize the path name parser for Windows path names.      */
if|if
condition|(
name|winRootPatternPtr
operator|==
name|NULL
condition|)
block|{
name|winRootPatternPtr
operator|=
name|TclRegComp
argument_list|(
name|WIN_ROOT_PATTERN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|Tcl_CreateExitHandler
argument_list|(
name|FileNameCleanup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/*      * Match the root portion of a Windows path name.      */
if|if
condition|(
operator|!
name|TclRegExec
argument_list|(
name|winRootPatternPtr
argument_list|,
name|path
argument_list|,
name|path
argument_list|)
condition|)
block|{
return|return
name|path
return|;
block|}
name|Tcl_DStringSetLength
argument_list|(
name|resultPtr
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|winRootPatternPtr
operator|->
name|startp
index|[
literal|2
index|]
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|resultPtr
argument_list|,
name|winRootPatternPtr
operator|->
name|startp
index|[
literal|2
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|winRootPatternPtr
operator|->
name|startp
index|[
literal|6
index|]
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|resultPtr
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|winRootPatternPtr
operator|->
name|startp
index|[
literal|4
index|]
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|resultPtr
argument_list|,
literal|"//"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|length
operator|=
name|winRootPatternPtr
operator|->
name|endp
index|[
literal|3
index|]
operator|-
name|winRootPatternPtr
operator|->
name|startp
index|[
literal|3
index|]
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
name|resultPtr
argument_list|,
name|winRootPatternPtr
operator|->
name|startp
index|[
literal|3
index|]
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
name|resultPtr
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|length
operator|=
name|winRootPatternPtr
operator|->
name|endp
index|[
literal|4
index|]
operator|-
name|winRootPatternPtr
operator|->
name|startp
index|[
literal|4
index|]
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
name|resultPtr
argument_list|,
name|winRootPatternPtr
operator|->
name|startp
index|[
literal|4
index|]
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_DStringAppend
argument_list|(
name|resultPtr
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|winRootPatternPtr
operator|->
name|endp
index|[
literal|0
index|]
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetPathType --  *  *	Determines whether a given path is relative to the current  *	directory, relative to the current volume, or absolute.  *  * Results:  *	Returns one of TCL_PATH_ABSOLUTE, TCL_PATH_RELATIVE, or  *	TCL_PATH_VOLUME_RELATIVE.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_PathType
name|Tcl_GetPathType
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|Tcl_PathType
name|type
init|=
name|TCL_PATH_ABSOLUTE
decl_stmt|;
switch|switch
condition|(
name|tclPlatform
condition|)
block|{
case|case
name|TCL_PLATFORM_UNIX
case|:
comment|/* 	     * Paths that begin with / or ~ are absolute. 	     */
if|if
condition|(
operator|(
name|path
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|)
operator|&&
operator|(
name|path
index|[
literal|0
index|]
operator|!=
literal|'~'
operator|)
condition|)
block|{
name|type
operator|=
name|TCL_PATH_RELATIVE
expr_stmt|;
block|}
break|break;
case|case
name|TCL_PLATFORM_MAC
case|:
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
block|{
name|type
operator|=
name|TCL_PATH_RELATIVE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|!=
literal|'~'
condition|)
block|{
comment|/* 		 * Since we have eliminated the easy cases, use the 		 * root pattern to look for the other types. 		 */
if|if
condition|(
operator|!
name|macRootPatternPtr
condition|)
block|{
name|macRootPatternPtr
operator|=
name|TclRegComp
argument_list|(
name|MAC_ROOT_PATTERN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|Tcl_CreateExitHandler
argument_list|(
name|FileNameCleanup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|TclRegExec
argument_list|(
name|macRootPatternPtr
argument_list|,
name|path
argument_list|,
name|path
argument_list|)
operator|||
operator|(
name|macRootPatternPtr
operator|->
name|startp
index|[
literal|2
index|]
operator|!=
name|NULL
operator|)
condition|)
block|{
name|type
operator|=
name|TCL_PATH_RELATIVE
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TCL_PLATFORM_WINDOWS
case|:
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|!=
literal|'~'
condition|)
block|{
comment|/* 		 * Since we have eliminated the easy cases, check for 		 * drive relative paths using the regular expression. 		 */
if|if
condition|(
operator|!
name|winRootPatternPtr
condition|)
block|{
name|winRootPatternPtr
operator|=
name|TclRegComp
argument_list|(
name|WIN_ROOT_PATTERN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|Tcl_CreateExitHandler
argument_list|(
name|FileNameCleanup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TclRegExec
argument_list|(
name|winRootPatternPtr
argument_list|,
name|path
argument_list|,
name|path
argument_list|)
condition|)
block|{
if|if
condition|(
name|winRootPatternPtr
operator|->
name|startp
index|[
literal|5
index|]
operator|||
operator|(
name|winRootPatternPtr
operator|->
name|startp
index|[
literal|2
index|]
operator|&&
operator|!
operator|(
name|winRootPatternPtr
operator|->
name|startp
index|[
literal|6
index|]
operator|)
operator|)
condition|)
block|{
name|type
operator|=
name|TCL_PATH_VOLUME_RELATIVE
expr_stmt|;
block|}
block|}
else|else
block|{
name|type
operator|=
name|TCL_PATH_RELATIVE
expr_stmt|;
block|}
block|}
break|break;
block|}
return|return
name|type
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SplitPath --  *  *	Split a path into a list of path components.  The first element  *	of the list will have the same path type as the original path.  *  * Results:  *	Returns a standard Tcl result.  The interpreter result contains  *	a list of path components.  *	*argvPtr will be filled in with the address of an array  *	whose elements point to the elements of path, in order.  *	*argcPtr will get filled in with the number of valid elements  *	in the array.  A single block of memory is dynamically allocated  *	to hold both the argv array and a copy of the path elements.  *	The caller must eventually free this memory by calling ckfree()  *	on *argvPtr.  Note:  *argvPtr and *argcPtr are only modified  *	if the procedure returns normally.  *  * Side effects:  *	Allocates memory.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_SplitPath
parameter_list|(
name|path
parameter_list|,
name|argcPtr
parameter_list|,
name|argvPtr
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Pointer to string containing a path. */
name|int
modifier|*
name|argcPtr
decl_stmt|;
comment|/* Pointer to location to fill in with 				 * the number of elements in the path. */
name|char
modifier|*
modifier|*
modifier|*
name|argvPtr
decl_stmt|;
comment|/* Pointer to place to store pointer to array 				 * of pointers to path elements. */
block|{
name|int
name|i
decl_stmt|,
name|size
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|Tcl_DString
name|buffer
decl_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
comment|/*      * Perform platform specific splitting.  These routines will leave the      * result in the specified buffer.  Individual elements are terminated      * with a null character.      */
name|p
operator|=
name|NULL
expr_stmt|;
comment|/* Needed only to prevent gcc warnings. */
switch|switch
condition|(
name|tclPlatform
condition|)
block|{
case|case
name|TCL_PLATFORM_UNIX
case|:
name|p
operator|=
name|SplitUnixPath
argument_list|(
name|path
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCL_PLATFORM_WINDOWS
case|:
name|p
operator|=
name|SplitWinPath
argument_list|(
name|path
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCL_PLATFORM_MAC
case|:
name|p
operator|=
name|SplitMacPath
argument_list|(
name|path
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*      * Compute the number of elements in the result.      */
name|size
operator|=
name|Tcl_DStringLength
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
operator|*
name|argcPtr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|(
operator|*
name|argcPtr
operator|)
operator|++
expr_stmt|;
block|}
block|}
comment|/*      * Allocate a buffer large enough to hold the contents of the      * DString plus the argv pointers and the terminating NULL pointer.      */
operator|*
name|argvPtr
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
operator|(
operator|(
operator|(
operator|*
name|argcPtr
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
operator|+
name|size
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Position p after the last argv pointer and copy the contents of      * the DString.      */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|*
name|argvPtr
operator|)
index|[
operator|(
operator|*
name|argcPtr
operator|)
operator|+
literal|1
index|]
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|p
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|Tcl_DStringValue
argument_list|(
operator|&
name|buffer
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|size
argument_list|)
expr_stmt|;
comment|/*      * Now set up the argv pointers.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|argcPtr
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|*
name|argvPtr
operator|)
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{}
block|}
operator|(
operator|*
name|argvPtr
operator|)
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SplitUnixPath --  *  *	This routine is used by Tcl_SplitPath to handle splitting  *	Unix paths.  *  * Results:  *	Stores a null separated array of strings in the specified  *	Tcl_DString.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|SplitUnixPath
parameter_list|(
name|path
parameter_list|,
name|bufPtr
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Pointer to string containing a path. */
name|Tcl_DString
modifier|*
name|bufPtr
decl_stmt|;
comment|/* Pointer to DString to use for the result. */
block|{
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|elementStart
decl_stmt|;
comment|/*      * Deal with the root directory as a special case.      */
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|bufPtr
argument_list|,
literal|"/"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|path
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|path
expr_stmt|;
block|}
comment|/*      * Split on slashes.  Embedded elements that start with tilde will be      * prefixed with "./" so they are not affected by tilde substitution.      */
for|for
control|(
init|;
condition|;
control|)
block|{
name|elementStart
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|p
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|'/'
operator|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
name|length
operator|=
name|p
operator|-
name|elementStart
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|elementStart
index|[
literal|0
index|]
operator|==
literal|'~'
operator|)
operator|&&
operator|(
name|elementStart
operator|!=
name|path
operator|)
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|bufPtr
argument_list|,
literal|"./"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|Tcl_DStringAppend
argument_list|(
name|bufPtr
argument_list|,
name|elementStart
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
name|bufPtr
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\0'
condition|)
block|{
break|break;
block|}
block|}
return|return
name|Tcl_DStringValue
argument_list|(
name|bufPtr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SplitWinPath --  *  *	This routine is used by Tcl_SplitPath to handle splitting  *	Windows paths.  *  * Results:  *	Stores a null separated array of strings in the specified  *	Tcl_DString.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|SplitWinPath
parameter_list|(
name|path
parameter_list|,
name|bufPtr
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Pointer to string containing a path. */
name|Tcl_DString
modifier|*
name|bufPtr
decl_stmt|;
comment|/* Pointer to DString to use for the result. */
block|{
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|elementStart
decl_stmt|;
name|p
operator|=
name|ExtractWinRoot
argument_list|(
name|path
argument_list|,
name|bufPtr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * Terminate the root portion, if we matched something.      */
if|if
condition|(
name|p
operator|!=
name|path
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|bufPtr
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*      * Split on slashes.  Embedded elements that start with tilde will be      * prefixed with "./" so they are not affected by tilde substitution.      */
do|do
block|{
name|elementStart
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|p
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|'/'
operator|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|'\\'
operator|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
name|length
operator|=
name|p
operator|-
name|elementStart
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|elementStart
index|[
literal|0
index|]
operator|==
literal|'~'
operator|)
operator|&&
operator|(
name|elementStart
operator|!=
name|path
operator|)
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|bufPtr
argument_list|,
literal|"./"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|Tcl_DStringAppend
argument_list|(
name|bufPtr
argument_list|,
name|elementStart
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
name|bufPtr
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'\0'
condition|)
do|;
return|return
name|Tcl_DStringValue
argument_list|(
name|bufPtr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SplitMacPath --  *  *	This routine is used by Tcl_SplitPath to handle splitting  *	Macintosh paths.  *  * Results:  *	Returns a newly allocated argv array.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|SplitMacPath
parameter_list|(
name|path
parameter_list|,
name|bufPtr
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Pointer to string containing a path. */
name|Tcl_DString
modifier|*
name|bufPtr
decl_stmt|;
comment|/* Pointer to DString to use for the result. */
block|{
name|int
name|isMac
init|=
literal|0
decl_stmt|;
comment|/* 1 if is Mac-style, 0 if Unix-style path. */
name|int
name|i
decl_stmt|,
name|length
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|elementStart
decl_stmt|;
comment|/*      * Initialize the path name parser for Macintosh path names.      */
if|if
condition|(
name|macRootPatternPtr
operator|==
name|NULL
condition|)
block|{
name|macRootPatternPtr
operator|=
name|TclRegComp
argument_list|(
name|MAC_ROOT_PATTERN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|Tcl_CreateExitHandler
argument_list|(
name|FileNameCleanup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/*      * Match the root portion of a Mac path name.      */
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Needed only to prevent gcc warnings. */
if|if
condition|(
name|TclRegExec
argument_list|(
name|macRootPatternPtr
argument_list|,
name|path
argument_list|,
name|path
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* 	 * Treat degenerate absolute paths like / and /../.. as 	 * Mac relative file names for lack of anything else to do. 	 */
if|if
condition|(
name|macRootPatternPtr
operator|->
name|startp
index|[
literal|2
index|]
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|bufPtr
argument_list|,
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
name|bufPtr
argument_list|,
name|path
argument_list|,
name|macRootPatternPtr
operator|->
name|endp
index|[
literal|0
index|]
operator|-
name|macRootPatternPtr
operator|->
name|startp
index|[
literal|0
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|Tcl_DStringValue
argument_list|(
name|bufPtr
argument_list|)
return|;
block|}
if|if
condition|(
name|macRootPatternPtr
operator|->
name|startp
index|[
literal|5
index|]
operator|!=
name|NULL
condition|)
block|{
comment|/* 	     * Unix-style tilde prefixed paths. 	     */
name|isMac
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|macRootPatternPtr
operator|->
name|startp
index|[
literal|7
index|]
operator|!=
name|NULL
condition|)
block|{
comment|/* 	     * Mac-style tilde prefixed paths. 	     */
name|isMac
operator|=
literal|1
expr_stmt|;
name|i
operator|=
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|macRootPatternPtr
operator|->
name|startp
index|[
literal|10
index|]
operator|!=
name|NULL
condition|)
block|{
comment|/* 	     * Normal Unix style paths. 	     */
name|isMac
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|macRootPatternPtr
operator|->
name|startp
index|[
literal|12
index|]
operator|!=
name|NULL
condition|)
block|{
comment|/* 	     * Normal Mac style paths. 	     */
name|isMac
operator|=
literal|1
expr_stmt|;
name|i
operator|=
literal|12
expr_stmt|;
block|}
name|length
operator|=
name|macRootPatternPtr
operator|->
name|endp
index|[
name|i
index|]
operator|-
name|macRootPatternPtr
operator|->
name|startp
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * Append the element and terminate it with a : and a null.  Note that 	 * we are forcing the DString to contain an extra null at the end. 	 */
name|Tcl_DStringAppend
argument_list|(
name|bufPtr
argument_list|,
name|macRootPatternPtr
operator|->
name|startp
index|[
name|i
index|]
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
name|bufPtr
argument_list|,
literal|":"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|macRootPatternPtr
operator|->
name|endp
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|isMac
operator|=
operator|(
name|strchr
argument_list|(
name|path
argument_list|,
literal|':'
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
name|p
operator|=
name|path
expr_stmt|;
block|}
if|if
condition|(
name|isMac
condition|)
block|{
comment|/* 	 * p is pointing at the first colon in the path.  There 	 * will always be one, since this is a Mac-style path. 	 */
name|elementStart
operator|=
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|length
operator|=
name|p
operator|-
name|elementStart
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|1
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|bufPtr
argument_list|,
literal|"::"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|elementStart
operator|=
name|p
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * If this is a simple component, drop the leading colon. 		 */
if|if
condition|(
operator|(
name|elementStart
index|[
literal|1
index|]
operator|!=
literal|'~'
operator|)
operator|&&
operator|(
name|strchr
argument_list|(
name|elementStart
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|elementStart
operator|++
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
name|Tcl_DStringAppend
argument_list|(
name|bufPtr
argument_list|,
name|elementStart
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
name|bufPtr
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|elementStart
operator|=
name|p
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|elementStart
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|||
name|elementStart
operator|==
name|path
condition|)
block|{
if|if
condition|(
operator|(
name|elementStart
index|[
literal|1
index|]
operator|!=
literal|'~'
operator|)
operator|&&
operator|(
name|elementStart
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|strchr
argument_list|(
name|elementStart
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|elementStart
operator|++
expr_stmt|;
block|}
name|Tcl_DStringAppend
argument_list|(
name|bufPtr
argument_list|,
name|elementStart
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
name|bufPtr
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	 * Split on slashes, suppress extra /'s, and convert .. to ::.  	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|elementStart
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|p
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|'/'
operator|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
name|length
operator|=
name|p
operator|-
name|elementStart
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|length
operator|==
literal|1
operator|)
operator|&&
operator|(
name|elementStart
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|bufPtr
argument_list|,
literal|":"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|length
operator|==
literal|2
operator|)
operator|&&
operator|(
name|elementStart
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|elementStart
index|[
literal|1
index|]
operator|==
literal|'.'
operator|)
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|bufPtr
argument_list|,
literal|"::"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|elementStart
operator|==
literal|'~'
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|bufPtr
argument_list|,
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|Tcl_DStringAppend
argument_list|(
name|bufPtr
argument_list|,
name|elementStart
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
name|bufPtr
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\0'
condition|)
block|{
break|break;
block|}
block|}
block|}
return|return
name|Tcl_DStringValue
argument_list|(
name|bufPtr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_JoinPath --  *  *	Combine a list of paths in a platform specific manner.  *  * Results:  *	Appends the joined path to the end of the specified  *	returning a pointer to the resulting string.  Note that  *	the Tcl_DString must already be initialized.  *  * Side effects:  *	Modifies the Tcl_DString.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_JoinPath
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|resultPtr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|Tcl_DString
modifier|*
name|resultPtr
decl_stmt|;
comment|/* Pointer to previously initialized DString. */
block|{
name|int
name|oldLength
decl_stmt|,
name|length
decl_stmt|,
name|i
decl_stmt|,
name|needsSep
decl_stmt|;
name|Tcl_DString
name|buffer
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
name|c
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|oldLength
operator|=
name|Tcl_DStringLength
argument_list|(
name|resultPtr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tclPlatform
condition|)
block|{
case|case
name|TCL_PLATFORM_UNIX
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
comment|/* 		 * If the path is absolute, reset the result buffer. 		 * Consume any duplicate leading slashes or a ./ in 		 * front of a tilde prefixed path that isn't at the 		 * beginning of the path. 		 */
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
block|{
name|Tcl_DStringSetLength
argument_list|(
name|resultPtr
argument_list|,
name|oldLength
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
name|resultPtr
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'~'
condition|)
block|{
name|Tcl_DStringSetLength
argument_list|(
name|resultPtr
argument_list|,
name|oldLength
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|Tcl_DStringLength
argument_list|(
name|resultPtr
argument_list|)
operator|!=
name|oldLength
operator|)
operator|&&
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
operator|&&
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'~'
operator|)
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
continue|continue;
block|}
comment|/* 		 * Append a separator if needed. 		 */
name|length
operator|=
name|Tcl_DStringLength
argument_list|(
name|resultPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|length
operator|!=
name|oldLength
operator|)
operator|&&
operator|(
name|Tcl_DStringValue
argument_list|(
name|resultPtr
argument_list|)
index|[
name|length
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|)
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|resultPtr
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|length
operator|++
expr_stmt|;
block|}
comment|/* 		 * Append the element, eliminating duplicate and trailing 		 * slashes. 		 */
name|Tcl_DStringSetLength
argument_list|(
name|resultPtr
argument_list|,
call|(
name|int
call|)
argument_list|(
name|length
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|=
name|Tcl_DStringValue
argument_list|(
name|resultPtr
argument_list|)
operator|+
name|length
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
block|{
while|while
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|dest
operator|++
operator|=
literal|'/'
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|dest
operator|++
operator|=
operator|*
name|p
expr_stmt|;
block|}
block|}
name|length
operator|=
name|dest
operator|-
name|Tcl_DStringValue
argument_list|(
name|resultPtr
argument_list|)
expr_stmt|;
name|Tcl_DStringSetLength
argument_list|(
name|resultPtr
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TCL_PLATFORM_WINDOWS
case|:
comment|/* 	     * Iterate over all of the components.  If a component is 	     * absolute, then reset the result and start building the 	     * path from the current component on. 	     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|ExtractWinRoot
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|resultPtr
argument_list|,
name|oldLength
argument_list|)
expr_stmt|;
name|length
operator|=
name|Tcl_DStringLength
argument_list|(
name|resultPtr
argument_list|)
expr_stmt|;
comment|/* 		 * If the pointer didn't move, then this is a relative path 		 * or a tilde prefixed path. 		 */
if|if
condition|(
name|p
operator|==
name|argv
index|[
name|i
index|]
condition|)
block|{
comment|/* 		     * Remove the ./ from tilde prefixed elements unless 		     * it is the first component. 		     */
if|if
condition|(
operator|(
name|length
operator|!=
name|oldLength
operator|)
operator|&&
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
operator|||
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|)
operator|)
operator|&&
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'~'
operator|)
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'~'
condition|)
block|{
name|Tcl_DStringSetLength
argument_list|(
name|resultPtr
argument_list|,
name|oldLength
argument_list|)
expr_stmt|;
name|length
operator|=
name|oldLength
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
comment|/* 		     * Check to see if we need to append a separator. 		     */
if|if
condition|(
name|length
operator|!=
name|oldLength
condition|)
block|{
name|c
operator|=
name|Tcl_DStringValue
argument_list|(
name|resultPtr
argument_list|)
index|[
name|length
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|!=
literal|'/'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|':'
operator|)
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|resultPtr
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		     * Append the element, eliminating duplicate and 		     * trailing slashes. 		     */
name|length
operator|=
name|Tcl_DStringLength
argument_list|(
name|resultPtr
argument_list|)
expr_stmt|;
name|Tcl_DStringSetLength
argument_list|(
name|resultPtr
argument_list|,
call|(
name|int
call|)
argument_list|(
name|length
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|=
name|Tcl_DStringValue
argument_list|(
name|resultPtr
argument_list|)
operator|+
name|length
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'/'
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'\\'
operator|)
condition|)
block|{
while|while
condition|(
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
operator|||
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|dest
operator|++
operator|=
literal|'/'
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|dest
operator|++
operator|=
operator|*
name|p
expr_stmt|;
block|}
block|}
name|length
operator|=
name|dest
operator|-
name|Tcl_DStringValue
argument_list|(
name|resultPtr
argument_list|)
expr_stmt|;
name|Tcl_DStringSetLength
argument_list|(
name|resultPtr
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TCL_PLATFORM_MAC
case|:
name|needsSep
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|Tcl_DStringSetLength
argument_list|(
operator|&
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|SplitMacPath
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|p
operator|!=
literal|':'
operator|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|Tcl_DStringSetLength
argument_list|(
name|resultPtr
argument_list|,
name|oldLength
argument_list|)
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
name|resultPtr
argument_list|,
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|needsSep
operator|=
literal|0
expr_stmt|;
name|p
operator|+=
name|length
operator|+
literal|1
expr_stmt|;
block|}
comment|/* 		 * Now append the rest of the path elements, skipping 		 * : unless it is the first element of the path, and 		 * watching out for :: et al. so we don't end up with 		 * too many colons in the result. 		 */
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|+=
name|length
operator|+
literal|1
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|Tcl_DStringLength
argument_list|(
name|resultPtr
argument_list|)
operator|!=
name|oldLength
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
name|needsSep
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|c
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
operator|!
name|needsSep
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|needsSep
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|resultPtr
argument_list|,
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|needsSep
operator|=
operator|(
name|c
operator|==
literal|':'
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
block|}
name|length
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
name|resultPtr
argument_list|,
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
return|return
name|Tcl_DStringValue
argument_list|(
name|resultPtr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_TranslateFileName --  *  *	Converts a file name into a form usable by the native system  *	interfaces.  If the name starts with a tilde, it will produce  *	a name where the tilde and following characters have been  *	replaced by the home directory location for the named user.  *  * Results:  *	The result is a pointer to a static string containing  *	the new name.  If there was an error in processing the  *	name, then an error message is left in interp->result  *	and the return value is NULL.  The result will be stored  *	in bufferPtr; the caller must call Tcl_DStringFree(bufferPtr)  *	to free the name if the return value was not NULL.  *  * Side effects:  *	Information may be left in bufferPtr.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_TranslateFileName
parameter_list|(
name|interp
parameter_list|,
name|name
parameter_list|,
name|bufferPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to store error 				 * message (if necessary). */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* File name, which may begin with "~" 				 * (to indicate current user's home directory) 				 * or "~<user>" (to indicate any user's 				 * home directory). */
name|Tcl_DString
modifier|*
name|bufferPtr
decl_stmt|;
comment|/* May be used to hold result.  Must not hold 				 * anything at the time of the call, and need 				 * not even be initialized. */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/*      * Handle tilde substitutions, if needed.      */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'~'
condition|)
block|{
name|int
name|argc
decl_stmt|,
name|length
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|Tcl_DString
name|temp
decl_stmt|;
name|Tcl_SplitPath
argument_list|(
name|name
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
comment|/* 	 * Strip the trailing ':' off of a Mac path 	 * before passing the user name to DoTildeSubst. 	 */
if|if
condition|(
name|tclPlatform
operator|==
name|TCL_PLATFORM_MAC
condition|)
block|{
name|length
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
index|[
name|length
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|Tcl_DStringInit
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|DoTildeSubst
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|0
index|]
operator|+
literal|1
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|Tcl_DStringFree
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|Tcl_DStringInit
argument_list|(
name|bufferPtr
argument_list|)
expr_stmt|;
name|Tcl_JoinPath
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|bufferPtr
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_DStringInit
argument_list|(
name|bufferPtr
argument_list|)
expr_stmt|;
name|Tcl_JoinPath
argument_list|(
literal|1
argument_list|,
operator|&
name|name
argument_list|,
name|bufferPtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * Convert forward slashes to backslashes in Windows paths because      * some system interfaces don't accept forward slashes.      */
if|if
condition|(
name|tclPlatform
operator|==
name|TCL_PLATFORM_WINDOWS
condition|)
block|{
for|for
control|(
name|p
operator|=
name|Tcl_DStringValue
argument_list|(
name|bufferPtr
argument_list|)
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
block|{
operator|*
name|p
operator|=
literal|'\\'
expr_stmt|;
block|}
block|}
block|}
return|return
name|Tcl_DStringValue
argument_list|(
name|bufferPtr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclGetExtension --  *  *	This function returns a pointer to the beginning of the  *	extension part of a file name.  *  * Results:  *	Returns a pointer into name which indicates where the extension  *	starts.  If there is no extension, returns NULL.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|TclGetExtension
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* File name to parse. */
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|lastSep
decl_stmt|;
comment|/*      * First find the last directory separator.      */
name|lastSep
operator|=
name|NULL
expr_stmt|;
comment|/* Needed only to prevent gcc warnings. */
switch|switch
condition|(
name|tclPlatform
condition|)
block|{
case|case
name|TCL_PLATFORM_UNIX
case|:
name|lastSep
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCL_PLATFORM_MAC
case|:
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|lastSep
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lastSep
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TCL_PLATFORM_WINDOWS
case|:
name|lastSep
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|strchr
argument_list|(
literal|"/\\:"
argument_list|,
operator|*
name|p
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|lastSep
operator|=
name|p
expr_stmt|;
block|}
block|}
break|break;
block|}
name|p
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|lastSep
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|lastSep
operator|>
name|p
operator|)
condition|)
block|{
name|p
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*      * Back up to the first period in a series of contiguous dots.      * This is needed so foo..o will be split on the first dot.      */
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|p
operator|>
name|name
operator|)
operator|&&
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|==
literal|'.'
condition|)
block|{
name|p
operator|--
expr_stmt|;
block|}
block|}
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DoTildeSubst --  *  *	Given a string following a tilde, this routine returns the  *	corresponding home directory.  *  * Results:  *	The result is a pointer to a static string containing the home  *	directory in native format.  If there was an error in processing  *	the substitution, then an error message is left in interp->result  *	and the return value is NULL.  On success, the results are appended  * 	to resultPtr, and the contents of resultPtr are returned.  *  * Side effects:  *	Information may be left in resultPtr.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|DoTildeSubst
parameter_list|(
name|interp
parameter_list|,
name|user
parameter_list|,
name|resultPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to store error 				 * message (if necessary). */
name|char
modifier|*
name|user
decl_stmt|;
comment|/* Name of user whose home directory should be 				 * substituted, or "" for current user. */
name|Tcl_DString
modifier|*
name|resultPtr
decl_stmt|;
comment|/* May be used to hold result.  Must not hold 				 * anything at the time of the call, and need 				 * not even be initialized. */
block|{
name|char
modifier|*
name|dir
decl_stmt|;
if|if
condition|(
operator|*
name|user
operator|==
literal|'\0'
condition|)
block|{
name|dir
operator|=
name|TclGetEnv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|interp
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't find HOME environment "
argument_list|,
literal|"variable to expand path"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
name|Tcl_JoinPath
argument_list|(
literal|1
argument_list|,
operator|&
name|dir
argument_list|,
name|resultPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* lint, TclGetuserHome() always NULL under windows. */
if|if
condition|(
name|TclGetUserHome
argument_list|(
name|user
argument_list|,
name|resultPtr
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|interp
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"user \""
argument_list|,
name|user
argument_list|,
literal|"\" doesn't exist"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
block|}
return|return
name|resultPtr
operator|->
name|string
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GlobCmd --  *  *	This procedure is invoked to process the "glob" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_GlobCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|i
decl_stmt|,
name|noComplain
decl_stmt|,
name|firstArg
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
name|Tcl_DString
name|buffer
decl_stmt|;
name|char
modifier|*
name|separators
decl_stmt|,
modifier|*
name|head
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|noComplain
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|firstArg
operator|=
literal|1
init|;
operator|(
name|firstArg
operator|<
name|argc
operator|)
operator|&&
operator|(
name|argv
index|[
name|firstArg
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|;
name|firstArg
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|firstArg
index|]
argument_list|,
literal|"-nocomplain"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|noComplain
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|firstArg
index|]
argument_list|,
literal|"--"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|firstArg
operator|++
expr_stmt|;
break|break;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad switch \""
argument_list|,
name|argv
index|[
name|firstArg
index|]
argument_list|,
literal|"\": must be -nocomplain or --"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
if|if
condition|(
name|firstArg
operator|>=
name|argc
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" ?switches? name ?name ...?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_DStringInit
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|separators
operator|=
name|NULL
expr_stmt|;
comment|/* Needed only to prevent gcc warnings. */
for|for
control|(
name|i
operator|=
name|firstArg
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|tclPlatform
condition|)
block|{
case|case
name|TCL_PLATFORM_UNIX
case|:
name|separators
operator|=
literal|"/"
expr_stmt|;
break|break;
case|case
name|TCL_PLATFORM_WINDOWS
case|:
name|separators
operator|=
literal|"/\\:"
expr_stmt|;
break|break;
case|case
name|TCL_PLATFORM_MAC
case|:
name|separators
operator|=
operator|(
name|strchr
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|':'
argument_list|)
operator|==
name|NULL
operator|)
condition|?
literal|"/"
else|:
literal|":"
expr_stmt|;
break|break;
block|}
name|Tcl_DStringSetLength
argument_list|(
operator|&
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Perform tilde substitution, if needed. 	 */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'~'
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 	     * Find the first path separator after the tilde. 	     */
for|for
control|(
name|tail
operator|=
name|argv
index|[
name|i
index|]
init|;
operator|*
name|tail
operator|!=
literal|'\0'
condition|;
name|tail
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|tail
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|separators
argument_list|,
name|tail
index|[
literal|1
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|separators
argument_list|,
operator|*
name|tail
argument_list|)
operator|!=
name|NULL
condition|)
block|{
break|break;
block|}
block|}
comment|/* 	     * Determine the home directory for the specified user.  Note that 	     * we don't allow special characters in the user name. 	     */
name|c
operator|=
operator|*
name|tail
expr_stmt|;
operator|*
name|tail
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|strpbrk
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
literal|1
argument_list|,
literal|"\\[]*?{}"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|head
operator|=
name|DoTildeSubst
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
index|]
operator|+
literal|1
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|noComplain
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"globbing characters not "
argument_list|,
literal|"supported in user names"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|head
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|tail
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|noComplain
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|head
operator|!=
name|Tcl_DStringValue
argument_list|(
operator|&
name|buffer
argument_list|)
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|buffer
argument_list|,
name|head
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tail
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
name|result
operator|=
name|TclDoGlob
argument_list|(
name|interp
argument_list|,
name|separators
argument_list|,
operator|&
name|buffer
argument_list|,
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|noComplain
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
goto|goto
name|done
goto|;
block|}
block|}
block|}
if|if
condition|(
operator|(
operator|*
name|interp
operator|->
name|result
operator|==
literal|0
operator|)
operator|&&
operator|!
name|noComplain
condition|)
block|{
name|char
modifier|*
name|sep
init|=
literal|""
decl_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"no files matched glob pattern"
argument_list|,
operator|(
name|argc
operator|==
literal|2
operator|)
condition|?
literal|" \""
else|:
literal|"s \""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|firstArg
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|sep
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|" "
expr_stmt|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
name|done
label|:
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SkipToChar --  *  *	This function traverses a glob pattern looking for the next  *	unquoted occurance of the specified character at the same braces  *	nesting level.  *  * Results:  *	Updates stringPtr to point to the matching character, or to  *	the end of the string if nothing matched.  The return value  *	is 1 if a match was found at the top level, otherwise it is 0.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SkipToChar
parameter_list|(
name|stringPtr
parameter_list|,
name|match
parameter_list|)
name|char
modifier|*
modifier|*
name|stringPtr
decl_stmt|;
comment|/* Pointer string to check. */
name|char
modifier|*
name|match
decl_stmt|;
comment|/* Pointer to character to find. */
block|{
name|int
name|quoted
decl_stmt|,
name|level
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|quoted
operator|=
literal|0
expr_stmt|;
name|level
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|stringPtr
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|quoted
condition|)
block|{
name|quoted
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|level
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|*
name|p
operator|==
operator|*
name|match
operator|)
condition|)
block|{
operator|*
name|stringPtr
operator|=
name|p
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'{'
condition|)
block|{
name|level
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'}'
condition|)
block|{
name|level
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
name|quoted
operator|=
literal|1
expr_stmt|;
block|}
block|}
operator|*
name|stringPtr
operator|=
name|p
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclDoGlob --  *  *	This recursive procedure forms the heart of the globbing  *	code.  It performs a depth-first traversal of the tree  *	given by the path name to be globbed.  The directory and  *	remainder are assumed to be native format paths.  *  * Results:  *	The return value is a standard Tcl result indicating whether  *	an error occurred in globbing.  After a normal return the  *	result in interp will be set to hold all of the file names  *	given by the dir and rem arguments.  After an error the  *	result in interp will hold an error message.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclDoGlob
parameter_list|(
name|interp
parameter_list|,
name|separators
parameter_list|,
name|headPtr
parameter_list|,
name|tail
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for error reporting 				 * (e.g. unmatched brace). */
name|char
modifier|*
name|separators
decl_stmt|;
comment|/* String containing separator characters 				 * that should be used to identify globbing 				 * boundaries. */
name|Tcl_DString
modifier|*
name|headPtr
decl_stmt|;
comment|/* Completely expanded prefix. */
name|char
modifier|*
name|tail
decl_stmt|;
comment|/* The unexpanded remainder of the path. */
block|{
name|int
name|baseLength
decl_stmt|,
name|quoted
decl_stmt|,
name|count
decl_stmt|;
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|openBrace
decl_stmt|,
modifier|*
name|closeBrace
decl_stmt|,
modifier|*
name|name
decl_stmt|,
modifier|*
name|firstSpecialChar
decl_stmt|,
name|savedChar
decl_stmt|;
name|char
name|lastChar
init|=
literal|0
decl_stmt|;
name|int
name|length
init|=
name|Tcl_DStringLength
argument_list|(
name|headPtr
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|lastChar
operator|=
name|Tcl_DStringValue
argument_list|(
name|headPtr
argument_list|)
index|[
name|length
operator|-
literal|1
index|]
expr_stmt|;
block|}
comment|/*      * Consume any leading directory separators, leaving tail pointing      * just past the last initial separator.      */
name|count
operator|=
literal|0
expr_stmt|;
name|name
operator|=
name|tail
expr_stmt|;
for|for
control|(
init|;
operator|*
name|tail
operator|!=
literal|'\0'
condition|;
name|tail
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|tail
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
name|strchr
argument_list|(
name|separators
argument_list|,
name|tail
index|[
literal|1
index|]
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|tail
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|separators
argument_list|,
operator|*
name|tail
argument_list|)
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|count
operator|++
expr_stmt|;
block|}
comment|/*      * Deal with path separators.  On the Mac, we have to watch out      * for multiple separators, since they are special in Mac-style      * paths.      */
switch|switch
condition|(
name|tclPlatform
condition|)
block|{
case|case
name|TCL_PLATFORM_MAC
case|:
if|if
condition|(
operator|*
name|separators
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|length
operator|==
literal|0
operator|)
operator|&&
operator|(
name|count
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|length
operator|>
literal|0
operator|)
operator|&&
operator|(
name|lastChar
operator|!=
literal|':'
operator|)
operator|)
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|headPtr
argument_list|,
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|length
operator|>
literal|0
operator|)
operator|&&
operator|(
name|lastChar
operator|!=
literal|':'
operator|)
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|headPtr
argument_list|,
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|lastChar
operator|==
literal|':'
condition|)
block|{
name|count
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|headPtr
argument_list|,
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|TCL_PLATFORM_WINDOWS
case|:
comment|/* 	     * If this is a drive relative path, add the colon and the 	     * trailing slash if needed.  Otherwise add the slash if 	     * this is the first absolute element, or a later relative 	     * element.  Add an extra slash if this is a UNC path. 	     */
if|if
condition|(
operator|*
name|name
operator|==
literal|':'
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|headPtr
argument_list|,
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|headPtr
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|tail
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|(
operator|(
name|length
operator|>
literal|0
operator|)
operator|&&
operator|(
name|strchr
argument_list|(
name|separators
argument_list|,
name|lastChar
argument_list|)
operator|==
name|NULL
operator|)
operator|)
operator|||
operator|(
operator|(
name|length
operator|==
literal|0
operator|)
operator|&&
operator|(
name|count
operator|>
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|headPtr
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|length
operator|==
literal|0
operator|)
operator|&&
operator|(
name|count
operator|>
literal|1
operator|)
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|headPtr
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TCL_PLATFORM_UNIX
case|:
comment|/* 	     * Add a separator if this is the first absolute element, or 	     * a later relative element. 	     */
if|if
condition|(
operator|(
operator|*
name|tail
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|(
operator|(
name|length
operator|>
literal|0
operator|)
operator|&&
operator|(
name|strchr
argument_list|(
name|separators
argument_list|,
name|lastChar
argument_list|)
operator|==
name|NULL
operator|)
operator|)
operator|||
operator|(
operator|(
name|length
operator|==
literal|0
operator|)
operator|&&
operator|(
name|count
operator|>
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|headPtr
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/*      * Look for the first matching pair of braces or the first      * directory separator that is not inside a pair of braces.      */
name|openBrace
operator|=
name|closeBrace
operator|=
name|NULL
expr_stmt|;
name|quoted
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|tail
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|quoted
condition|)
block|{
name|quoted
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
name|quoted
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|separators
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
break|break;
comment|/* Quoted directory separator. */
block|}
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|separators
argument_list|,
operator|*
name|p
argument_list|)
operator|!=
name|NULL
condition|)
block|{
break|break;
comment|/* Unquoted directory separator. */
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'{'
condition|)
block|{
name|openBrace
operator|=
name|p
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|SkipToChar
argument_list|(
operator|&
name|p
argument_list|,
literal|"}"
argument_list|)
condition|)
block|{
name|closeBrace
operator|=
name|p
expr_stmt|;
comment|/* Balanced braces. */
break|break;
block|}
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"unmatched open-brace in file name"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'}'
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"unmatched close-brace in file name"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
comment|/*      * Substitute the alternate patterns from the braces and recurse.      */
if|if
condition|(
name|openBrace
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|element
decl_stmt|;
name|Tcl_DString
name|newName
decl_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|newName
argument_list|)
expr_stmt|;
comment|/* 	 * For each element within in the outermost pair of braces, 	 * append the element and the remainder to the fixed portion 	 * before the first brace and recursively call TclDoGlob. 	 */
name|Tcl_DStringAppend
argument_list|(
operator|&
name|newName
argument_list|,
name|tail
argument_list|,
name|openBrace
operator|-
name|tail
argument_list|)
expr_stmt|;
name|baseLength
operator|=
name|Tcl_DStringLength
argument_list|(
operator|&
name|newName
argument_list|)
expr_stmt|;
name|length
operator|=
name|Tcl_DStringLength
argument_list|(
name|headPtr
argument_list|)
expr_stmt|;
operator|*
name|closeBrace
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|p
operator|=
name|openBrace
init|;
name|p
operator|!=
name|closeBrace
condition|;
control|)
block|{
name|p
operator|++
expr_stmt|;
name|element
operator|=
name|p
expr_stmt|;
name|SkipToChar
argument_list|(
operator|&
name|p
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|Tcl_DStringSetLength
argument_list|(
name|headPtr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Tcl_DStringSetLength
argument_list|(
operator|&
name|newName
argument_list|,
name|baseLength
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|newName
argument_list|,
name|element
argument_list|,
name|p
operator|-
name|element
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|newName
argument_list|,
name|closeBrace
operator|+
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TclDoGlob
argument_list|(
name|interp
argument_list|,
name|separators
argument_list|,
name|headPtr
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|newName
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
break|break;
block|}
block|}
operator|*
name|closeBrace
operator|=
literal|'}'
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|newName
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/*      * At this point, there are no more brace substitutions to perform on      * this path component.  The variable p is pointing at a quoted or      * unquoted directory separator or the end of the string.  So we need      * to check for special globbing characters in the current pattern.      * We avoid modifying tail if p is pointing at the end of the string.      */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|savedChar
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|firstSpecialChar
operator|=
name|strpbrk
argument_list|(
name|tail
argument_list|,
literal|"*[]?\\"
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|savedChar
expr_stmt|;
block|}
else|else
block|{
name|firstSpecialChar
operator|=
name|strpbrk
argument_list|(
name|tail
argument_list|,
literal|"*[]?\\"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|firstSpecialChar
operator|!=
name|NULL
condition|)
block|{
comment|/* 	 * Look for matching files in the current directory.  The 	 * implementation of this function is platform specific, but may 	 * recursively call TclDoGlob.  For each file that matches, it will 	 * add the match onto the interp->result, or call TclDoGlob if there 	 * are more characters to be processed. 	 */
return|return
name|TclMatchFiles
argument_list|(
name|interp
argument_list|,
name|separators
argument_list|,
name|headPtr
argument_list|,
name|tail
argument_list|,
name|p
argument_list|)
return|;
block|}
name|Tcl_DStringAppend
argument_list|(
name|headPtr
argument_list|,
name|tail
argument_list|,
name|p
operator|-
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
return|return
name|TclDoGlob
argument_list|(
name|interp
argument_list|,
name|separators
argument_list|,
name|headPtr
argument_list|,
name|p
argument_list|)
return|;
block|}
comment|/*      * There are no more wildcards in the pattern and no more unprocessed      * characters in the tail, so now we can construct the path and verify      * the existence of the file.      */
switch|switch
condition|(
name|tclPlatform
condition|)
block|{
case|case
name|TCL_PLATFORM_MAC
case|:
if|if
condition|(
name|strchr
argument_list|(
name|Tcl_DStringValue
argument_list|(
name|headPtr
argument_list|)
argument_list|,
literal|':'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|headPtr
argument_list|,
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|Tcl_DStringValue
argument_list|(
name|headPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|name
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|name
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|strchr
argument_list|(
name|name
operator|+
literal|1
argument_list|,
literal|':'
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TCL_PLATFORM_WINDOWS
case|:
block|{
name|int
name|exists
decl_stmt|;
comment|/* 	     * We need to convert slashes to backslashes before checking 	     * for the existence of the file.  Once we are done, we need 	     * to convert the slashes back. 	     */
if|if
condition|(
name|Tcl_DStringLength
argument_list|(
name|headPtr
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
operator|*
name|name
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'/'
operator|||
name|name
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|)
operator|)
operator|||
operator|(
operator|*
name|name
operator|==
literal|'/'
operator|)
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|headPtr
argument_list|,
literal|"\\"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_DStringAppend
argument_list|(
name|headPtr
argument_list|,
literal|"."
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|Tcl_DStringValue
argument_list|(
name|headPtr
argument_list|)
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
block|{
operator|*
name|p
operator|=
literal|'\\'
expr_stmt|;
block|}
block|}
block|}
name|name
operator|=
name|Tcl_DStringValue
argument_list|(
name|headPtr
argument_list|)
expr_stmt|;
name|exists
operator|=
operator|(
name|access
argument_list|(
name|name
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|exists
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|TCL_PLATFORM_UNIX
case|:
if|if
condition|(
name|Tcl_DStringLength
argument_list|(
name|headPtr
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|name
operator|==
literal|'\\'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
operator|||
operator|(
operator|*
name|name
operator|==
literal|'/'
operator|)
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|headPtr
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_DStringAppend
argument_list|(
name|headPtr
argument_list|,
literal|"."
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|name
operator|=
name|Tcl_DStringValue
argument_list|(
name|headPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|name
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

end_unit

