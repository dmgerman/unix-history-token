begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclTestObj.c --  *  *	This file contains C command procedures for the additional Tcl  *	commands that are used for testing implementations of the Tcl object  *	types. These commands are not normally included in Tcl  *	applications; they're only used for testing.  *  * Copyright (c) 1995, 1996 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclTestObj.c 1.27 97/05/19 17:37:31  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_comment
comment|/*  * An array of Tcl_Obj pointers used in the commands that operate on or get  * the values of Tcl object-valued variables. varPtr[i] is the i-th  * variable's Tcl_Obj *.  */
end_comment

begin_define
define|#
directive|define
name|NUMBER_OF_OBJECT_VARS
value|20
end_define

begin_decl_stmt
specifier|static
name|Tcl_Obj
modifier|*
name|varPtr
index|[
name|NUMBER_OF_OBJECT_VARS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Forward declarations for procedures defined later in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|CheckIfVarUnset
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|varIndex
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|GetVariableIndex
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|int
operator|*
name|indexPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|SetVarToObj
name|_ANSI_ARGS_
argument_list|(
operator|(
name|int
name|varIndex
operator|,
name|Tcl_Obj
operator|*
name|objPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|TclObjTest_Init
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestbooleanobjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestconvertobjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestdoubleobjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestindexobjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestintobjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TestobjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TeststringobjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclObjTest_Init --  *  *	This procedure creates additional commands that are used to test the  *	Tcl object support.  *  * Results:  *	Returns a standard Tcl completion code, and leaves an error  *	message in interp->result if an error occurs.  *  * Side effects:  *	Creates and registers several new testing commands.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclObjTest_Init
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMBER_OF_OBJECT_VARS
condition|;
name|i
operator|++
control|)
block|{
name|varPtr
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|Tcl_CreateObjCommand
argument_list|(
name|interp
argument_list|,
literal|"testbooleanobj"
argument_list|,
name|TestbooleanobjCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateObjCommand
argument_list|(
name|interp
argument_list|,
literal|"testconvertobj"
argument_list|,
name|TestconvertobjCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateObjCommand
argument_list|(
name|interp
argument_list|,
literal|"testdoubleobj"
argument_list|,
name|TestdoubleobjCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateObjCommand
argument_list|(
name|interp
argument_list|,
literal|"testintobj"
argument_list|,
name|TestintobjCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateObjCommand
argument_list|(
name|interp
argument_list|,
literal|"testindexobj"
argument_list|,
name|TestindexobjCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateObjCommand
argument_list|(
name|interp
argument_list|,
literal|"testobj"
argument_list|,
name|TestobjCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateObjCommand
argument_list|(
name|interp
argument_list|,
literal|"teststringobj"
argument_list|,
name|TeststringobjCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestbooleanobjCmd --  *  *	This procedure implements the "testbooleanobj" command.  It is used  *	to test the boolean Tcl object type implementation.  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	Creates and frees boolean objects, and also converts objects to  *	have boolean type.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestbooleanobjCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|int
name|varIndex
decl_stmt|,
name|boolValue
decl_stmt|,
name|length
decl_stmt|;
name|char
modifier|*
name|index
decl_stmt|,
modifier|*
name|subCmd
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|3
condition|)
block|{
name|wrongNumArgs
label|:
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"option arg ?arg ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * THIS FAILS IF AN OBJECT'S STRING REP HAS A NULL BYTE.      */
name|index
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|GetVariableIndex
argument_list|(
name|interp
argument_list|,
name|index
argument_list|,
operator|&
name|varIndex
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|subCmd
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|subCmd
argument_list|,
literal|"set"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
name|Tcl_GetBooleanFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|boolValue
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
comment|/* 	 * If the object currently bound to the variable with index varIndex 	 * has ref count 1 (i.e. the object is unshared) we can modify that 	 * object directly. Otherwise, if RC>1 (i.e. the object is shared), 	 * we must create a new object to modify/set and decrement the old 	 * formerly-shared object's ref count. This is "copy on write". 	 */
if|if
condition|(
operator|(
name|varPtr
index|[
name|varIndex
index|]
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|Tcl_IsShared
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
condition|)
block|{
name|Tcl_SetBooleanObj
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|,
name|boolValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SetVarToObj
argument_list|(
name|varIndex
argument_list|,
name|Tcl_NewBooleanObj
argument_list|(
name|boolValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|subCmd
argument_list|,
literal|"get"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
name|CheckIfVarUnset
argument_list|(
name|interp
argument_list|,
name|varIndex
argument_list|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|subCmd
argument_list|,
literal|"not"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
name|CheckIfVarUnset
argument_list|(
name|interp
argument_list|,
name|varIndex
argument_list|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetBooleanFromObj
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
argument_list|,
operator|&
name|boolValue
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|!
name|Tcl_IsShared
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
condition|)
block|{
name|Tcl_SetBooleanObj
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|,
operator|!
name|boolValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SetVarToObj
argument_list|(
name|varIndex
argument_list|,
name|Tcl_NewBooleanObj
argument_list|(
operator|!
name|boolValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"bad option \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
literal|"\": must be set, get, or not"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestconvertobjCmd --  *  *	This procedure implements the "testconvertobj" command. It is used  *	to test converting objects to new types.  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	Converts objects to new types.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestconvertobjCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|subCmd
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|3
condition|)
block|{
name|wrongNumArgs
label|:
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"option arg ?arg ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * THIS FAILS IF AN OBJECT'S STRING REP HAS A NULL BYTE.      */
name|subCmd
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|subCmd
argument_list|,
literal|"double"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|double
name|d
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
name|Tcl_GetDoubleFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|d
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%f"
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"bad option \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
literal|"\": must be double"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestdoubleobjCmd --  *  *	This procedure implements the "testdoubleobj" command.  It is used  *	to test the double-precision floating point Tcl object type  *	implementation.  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	Creates and frees double objects, and also converts objects to  *	have double type.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestdoubleobjCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|int
name|varIndex
decl_stmt|,
name|length
decl_stmt|;
name|double
name|doubleValue
decl_stmt|;
name|char
modifier|*
name|index
decl_stmt|,
modifier|*
name|subCmd
decl_stmt|,
modifier|*
name|string
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|3
condition|)
block|{
name|wrongNumArgs
label|:
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"option arg ?arg ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * THIS FAILS IF AN OBJECT'S STRING REP HAS A NULL BYTE.      */
name|index
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|GetVariableIndex
argument_list|(
name|interp
argument_list|,
name|index
argument_list|,
operator|&
name|varIndex
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|subCmd
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|subCmd
argument_list|,
literal|"set"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|string
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_GetDouble
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
operator|&
name|doubleValue
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
comment|/* 	 * If the object currently bound to the variable with index varIndex 	 * has ref count 1 (i.e. the object is unshared) we can modify that 	 * object directly. Otherwise, if RC>1 (i.e. the object is shared), 	 * we must create a new object to modify/set and decrement the old 	 * formerly-shared object's ref count. This is "copy on write". 	 */
if|if
condition|(
operator|(
name|varPtr
index|[
name|varIndex
index|]
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|Tcl_IsShared
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
condition|)
block|{
name|Tcl_SetDoubleObj
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|,
name|doubleValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SetVarToObj
argument_list|(
name|varIndex
argument_list|,
name|Tcl_NewDoubleObj
argument_list|(
name|doubleValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|subCmd
argument_list|,
literal|"get"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
name|CheckIfVarUnset
argument_list|(
name|interp
argument_list|,
name|varIndex
argument_list|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|subCmd
argument_list|,
literal|"mult10"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
name|CheckIfVarUnset
argument_list|(
name|interp
argument_list|,
name|varIndex
argument_list|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetDoubleFromObj
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
argument_list|,
operator|&
name|doubleValue
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|!
name|Tcl_IsShared
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
condition|)
block|{
name|Tcl_SetDoubleObj
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|,
operator|(
name|doubleValue
operator|*
literal|10.0
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SetVarToObj
argument_list|(
name|varIndex
argument_list|,
name|Tcl_NewDoubleObj
argument_list|(
operator|(
name|doubleValue
operator|*
literal|10.0
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|subCmd
argument_list|,
literal|"div10"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
name|CheckIfVarUnset
argument_list|(
name|interp
argument_list|,
name|varIndex
argument_list|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetDoubleFromObj
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
argument_list|,
operator|&
name|doubleValue
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|!
name|Tcl_IsShared
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
condition|)
block|{
name|Tcl_SetDoubleObj
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|,
operator|(
name|doubleValue
operator|/
literal|10.0
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SetVarToObj
argument_list|(
name|varIndex
argument_list|,
name|Tcl_NewDoubleObj
argument_list|(
operator|(
name|doubleValue
operator|/
literal|10.0
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"bad option \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
literal|"\": must be set, get, mult10, or div10"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestindexobjCmd --  *  *	This procedure implements the "testindexobj" command. It is used to  *	test the index Tcl object type implementation.  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	Creates and frees int objects, and also converts objects to  *	have int type.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestindexobjCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|int
name|allowAbbrev
decl_stmt|,
name|index
decl_stmt|,
name|index2
decl_stmt|,
name|setError
decl_stmt|,
name|i
decl_stmt|,
name|dummy
decl_stmt|,
name|result
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
specifier|static
name|char
modifier|*
name|tablePtr
index|[]
init|=
block|{
literal|"a"
block|,
literal|"b"
block|,
literal|"check"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
if|if
condition|(
operator|(
name|objc
operator|==
literal|3
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
operator|&
name|dummy
argument_list|)
argument_list|,
literal|"check"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 	 * This code checks to be sure that the results of 	 * Tcl_GetIndexFromObj are properly cached in the object and 	 * returned on subsequent lookups. 	 */
name|Tcl_GetIndexFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|,
name|tablePtr
argument_list|,
literal|"token"
argument_list|,
literal|0
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|index2
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|objv
index|[
literal|1
index|]
operator|->
name|internalRep
operator|.
name|twoPtrValue
operator|.
name|ptr2
operator|=
operator|(
name|VOID
operator|*
operator|)
name|index2
expr_stmt|;
name|result
operator|=
name|Tcl_GetIndexFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|,
name|tablePtr
argument_list|,
literal|"token"
argument_list|,
literal|0
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
name|Tcl_SetIntObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
if|if
condition|(
name|objc
operator|<
literal|5
condition|)
block|{
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"wrong # args"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetBooleanFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|,
operator|&
name|setError
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetBooleanFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|allowAbbrev
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|objc
operator|-
literal|3
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|argv
index|[
name|i
operator|-
literal|4
index|]
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
block|}
name|argv
index|[
name|objc
operator|-
literal|4
index|]
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|Tcl_GetIndexFromObj
argument_list|(
name|setError
condition|?
name|interp
else|:
name|NULL
argument_list|,
name|objv
index|[
literal|3
index|]
argument_list|,
name|argv
argument_list|,
literal|"token"
argument_list|,
name|allowAbbrev
condition|?
literal|0
else|:
name|TCL_EXACT
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
name|Tcl_SetIntObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestintobjCmd --  *  *	This procedure implements the "testintobj" command. It is used to  *	test the int Tcl object type implementation.  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	Creates and frees int objects, and also converts objects to  *	have int type.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestintobjCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|int
name|intValue
decl_stmt|,
name|varIndex
decl_stmt|,
name|length
decl_stmt|,
name|i
decl_stmt|;
name|long
name|longValue
decl_stmt|;
name|char
modifier|*
name|index
decl_stmt|,
modifier|*
name|subCmd
decl_stmt|,
modifier|*
name|string
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|3
condition|)
block|{
name|wrongNumArgs
label|:
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"option arg ?arg ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * THIS FAILS IF AN OBJECT'S STRING REP HAS A NULL BYTE.      */
name|index
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|GetVariableIndex
argument_list|(
name|interp
argument_list|,
name|index
argument_list|,
operator|&
name|varIndex
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|subCmd
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|subCmd
argument_list|,
literal|"set"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|string
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
operator|&
name|i
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|intValue
operator|=
name|i
expr_stmt|;
comment|/* 	 * If the object currently bound to the variable with index varIndex 	 * has ref count 1 (i.e. the object is unshared) we can modify that 	 * object directly. Otherwise, if RC>1 (i.e. the object is shared), 	 * we must create a new object to modify/set and decrement the old 	 * formerly-shared object's ref count. This is "copy on write". 	 */
if|if
condition|(
operator|(
name|varPtr
index|[
name|varIndex
index|]
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|Tcl_IsShared
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
condition|)
block|{
name|Tcl_SetIntObj
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|,
name|intValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SetVarToObj
argument_list|(
name|varIndex
argument_list|,
name|Tcl_NewIntObj
argument_list|(
name|intValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|subCmd
argument_list|,
literal|"set2"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* doesn't set result */
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|string
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
operator|&
name|i
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|intValue
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|varPtr
index|[
name|varIndex
index|]
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|Tcl_IsShared
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
condition|)
block|{
name|Tcl_SetIntObj
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|,
name|intValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SetVarToObj
argument_list|(
name|varIndex
argument_list|,
name|Tcl_NewIntObj
argument_list|(
name|intValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|subCmd
argument_list|,
literal|"setlong"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|string
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
operator|&
name|i
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|intValue
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|varPtr
index|[
name|varIndex
index|]
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|Tcl_IsShared
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
condition|)
block|{
name|Tcl_SetLongObj
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|,
name|intValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SetVarToObj
argument_list|(
name|varIndex
argument_list|,
name|Tcl_NewLongObj
argument_list|(
name|intValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|subCmd
argument_list|,
literal|"setmaxlong"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|long
name|maxLong
init|=
name|LONG_MAX
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
operator|(
name|varPtr
index|[
name|varIndex
index|]
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|Tcl_IsShared
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
condition|)
block|{
name|Tcl_SetLongObj
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|,
name|maxLong
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SetVarToObj
argument_list|(
name|varIndex
argument_list|,
name|Tcl_NewLongObj
argument_list|(
name|maxLong
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|subCmd
argument_list|,
literal|"ismaxlong"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
name|CheckIfVarUnset
argument_list|(
name|interp
argument_list|,
name|varIndex
argument_list|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetLongFromObj
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
argument_list|,
operator|&
name|longValue
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
operator|(
name|longValue
operator|==
name|LONG_MAX
operator|)
condition|?
literal|"1"
else|:
literal|"0"
operator|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|subCmd
argument_list|,
literal|"get"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
name|CheckIfVarUnset
argument_list|(
name|interp
argument_list|,
name|varIndex
argument_list|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|subCmd
argument_list|,
literal|"inttoobigtest"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 	 * If long ints have more bits than ints on this platform, verify 	 * that Tcl_GetIntFromObj returns an error if the long int held 	 * in an integer object's internal representation is too large 	 * to fit in an int. 	 */
name|long
name|maxLong
init|=
name|LONG_MAX
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
name|INT_MAX
operator|==
name|LONG_MAX
condition|)
block|{
comment|/* int is same size as long int */
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"1"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|varPtr
index|[
name|varIndex
index|]
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|Tcl_IsShared
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
condition|)
block|{
name|Tcl_SetLongObj
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|,
name|maxLong
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SetVarToObj
argument_list|(
name|varIndex
argument_list|,
name|Tcl_NewLongObj
argument_list|(
name|maxLong
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
argument_list|,
operator|&
name|i
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"1"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"0"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|subCmd
argument_list|,
literal|"mult10"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
name|CheckIfVarUnset
argument_list|(
name|interp
argument_list|,
name|varIndex
argument_list|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
argument_list|,
operator|&
name|intValue
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|!
name|Tcl_IsShared
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
condition|)
block|{
name|Tcl_SetIntObj
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|,
operator|(
name|intValue
operator|*
literal|10
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SetVarToObj
argument_list|(
name|varIndex
argument_list|,
name|Tcl_NewIntObj
argument_list|(
operator|(
name|intValue
operator|*
literal|10
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|subCmd
argument_list|,
literal|"div10"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
name|CheckIfVarUnset
argument_list|(
name|interp
argument_list|,
name|varIndex
argument_list|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
argument_list|,
operator|&
name|intValue
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|!
name|Tcl_IsShared
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
condition|)
block|{
name|Tcl_SetIntObj
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|,
operator|(
name|intValue
operator|/
literal|10
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SetVarToObj
argument_list|(
name|varIndex
argument_list|,
name|Tcl_NewIntObj
argument_list|(
operator|(
name|intValue
operator|/
literal|10
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"bad option \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
literal|"\": must be set, get, mult10, or div10"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TestobjCmd --  *  *	This procedure implements the "testobj" command. It is used to test  *	the type-independent portions of the Tcl object type implementation.  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	Creates and frees objects.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TestobjCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|int
name|varIndex
decl_stmt|,
name|destIndex
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|index
decl_stmt|,
modifier|*
name|subCmd
decl_stmt|,
modifier|*
name|string
decl_stmt|;
name|Tcl_ObjType
modifier|*
name|targetType
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|int
name|length
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|2
condition|)
block|{
name|wrongNumArgs
label|:
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"option arg ?arg ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * THIS FAILS IF AN OBJECT'S STRING REP HAS A NULL BYTE.      */
name|subCmd
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|subCmd
argument_list|,
literal|"assign"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|index
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|GetVariableIndex
argument_list|(
name|interp
argument_list|,
name|index
argument_list|,
operator|&
name|varIndex
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|CheckIfVarUnset
argument_list|(
name|interp
argument_list|,
name|varIndex
argument_list|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|string
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|GetVariableIndex
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
operator|&
name|destIndex
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|SetVarToObj
argument_list|(
name|destIndex
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
expr_stmt|;
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|destIndex
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|subCmd
argument_list|,
literal|"convert"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|typeName
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|index
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|GetVariableIndex
argument_list|(
name|interp
argument_list|,
name|index
argument_list|,
operator|&
name|varIndex
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|CheckIfVarUnset
argument_list|(
name|interp
argument_list|,
name|varIndex
argument_list|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|typeName
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|targetType
operator|=
name|Tcl_GetObjType
argument_list|(
name|typeName
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"no type "
argument_list|,
name|typeName
argument_list|,
literal|" found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_ConvertToType
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
argument_list|,
name|targetType
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|subCmd
argument_list|,
literal|"duplicate"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|index
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|GetVariableIndex
argument_list|(
name|interp
argument_list|,
name|index
argument_list|,
operator|&
name|varIndex
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|CheckIfVarUnset
argument_list|(
name|interp
argument_list|,
name|varIndex
argument_list|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|string
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|GetVariableIndex
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
operator|&
name|destIndex
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|SetVarToObj
argument_list|(
name|destIndex
argument_list|,
name|Tcl_DuplicateObj
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|destIndex
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|subCmd
argument_list|,
literal|"freeallvars"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|objc
operator|!=
literal|2
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMBER_OF_OBJECT_VARS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|varPtr
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|varPtr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|varPtr
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|subCmd
argument_list|,
literal|"newobj"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|index
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|GetVariableIndex
argument_list|(
name|interp
argument_list|,
name|index
argument_list|,
operator|&
name|varIndex
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|SetVarToObj
argument_list|(
name|varIndex
argument_list|,
name|Tcl_NewObj
argument_list|()
argument_list|)
expr_stmt|;
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|subCmd
argument_list|,
literal|"refcount"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|index
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|GetVariableIndex
argument_list|(
name|interp
argument_list|,
name|index
argument_list|,
operator|&
name|varIndex
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|CheckIfVarUnset
argument_list|(
name|interp
argument_list|,
name|varIndex
argument_list|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
operator|->
name|refCount
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|subCmd
argument_list|,
literal|"type"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|index
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|GetVariableIndex
argument_list|(
name|interp
argument_list|,
name|index
argument_list|,
operator|&
name|varIndex
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|CheckIfVarUnset
argument_list|(
name|interp
argument_list|,
name|varIndex
argument_list|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|varPtr
index|[
name|varIndex
index|]
operator|->
name|typePtr
operator|==
name|NULL
condition|)
block|{
comment|/* a string! */
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"string"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
operator|->
name|typePtr
operator|->
name|name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|subCmd
argument_list|,
literal|"types"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|objc
operator|!=
literal|2
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
name|Tcl_AppendAllObjTypes
argument_list|(
name|interp
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
else|else
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"bad option \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
literal|"\": must be assign, convert, duplicate, freeallvars, "
argument_list|,
literal|"newobj, objcount, refcount, type, or types"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TeststringobjCmd --  *  *	This procedure implements the "teststringobj" command. It is used to  *	test the string Tcl object type implementation.  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	Creates and frees string objects, and also converts objects to  *	have string type.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TeststringobjCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|int
name|varIndex
decl_stmt|,
name|option
decl_stmt|,
name|i
decl_stmt|,
name|length
decl_stmt|;
define|#
directive|define
name|MAX_STRINGS
value|10
name|char
modifier|*
name|index
decl_stmt|,
modifier|*
name|string
decl_stmt|,
modifier|*
name|strings
index|[
name|MAX_STRINGS
operator|+
literal|1
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|options
index|[]
init|=
block|{
literal|"append"
block|,
literal|"appendstrings"
block|,
literal|"get"
block|,
literal|"length"
block|,
literal|"length2"
block|,
literal|"set"
block|,
literal|"set2"
block|,
literal|"setlength"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|3
condition|)
block|{
name|wrongNumArgs
label|:
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"option arg ?arg ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|index
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|GetVariableIndex
argument_list|(
name|interp
argument_list|,
name|index
argument_list|,
operator|&
name|varIndex
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetIndexFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|,
name|options
argument_list|,
literal|"option"
argument_list|,
literal|0
argument_list|,
operator|&
name|option
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
switch|switch
condition|(
name|option
condition|)
block|{
case|case
literal|0
case|:
comment|/* append */
if|if
condition|(
name|objc
operator|!=
literal|5
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|4
index|]
argument_list|,
operator|&
name|length
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|varPtr
index|[
name|varIndex
index|]
operator|==
name|NULL
condition|)
block|{
name|SetVarToObj
argument_list|(
name|varIndex
argument_list|,
name|Tcl_NewObj
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * If the object bound to variable "varIndex" is shared, we must 	     * "copy on write" and append to a copy of the object.  	     */
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
condition|)
block|{
name|SetVarToObj
argument_list|(
name|varIndex
argument_list|,
name|Tcl_DuplicateObj
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|string
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|,
name|string
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* appendstrings */
if|if
condition|(
name|objc
operator|>
operator|(
name|MAX_STRINGS
operator|+
literal|3
operator|)
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
name|varPtr
index|[
name|varIndex
index|]
operator|==
name|NULL
condition|)
block|{
name|SetVarToObj
argument_list|(
name|varIndex
argument_list|,
name|Tcl_NewObj
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * If the object bound to variable "varIndex" is shared, we must 	     * "copy on write" and append to a copy of the object.  	     */
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
condition|)
block|{
name|SetVarToObj
argument_list|(
name|varIndex
argument_list|,
name|Tcl_DuplicateObj
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|strings
index|[
name|i
operator|-
literal|3
index|]
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|strings
index|[
name|objc
operator|-
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|,
name|strings
index|[
literal|0
index|]
argument_list|,
name|strings
index|[
literal|1
index|]
argument_list|,
name|strings
index|[
literal|2
index|]
argument_list|,
name|strings
index|[
literal|3
index|]
argument_list|,
name|strings
index|[
literal|4
index|]
argument_list|,
name|strings
index|[
literal|5
index|]
argument_list|,
name|strings
index|[
literal|6
index|]
argument_list|,
name|strings
index|[
literal|7
index|]
argument_list|,
name|strings
index|[
literal|8
index|]
argument_list|,
name|strings
index|[
literal|9
index|]
argument_list|,
name|strings
index|[
literal|10
index|]
argument_list|,
name|strings
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* get */
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
name|CheckIfVarUnset
argument_list|(
name|interp
argument_list|,
name|varIndex
argument_list|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* length */
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|Tcl_SetIntObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|varPtr
index|[
name|varIndex
index|]
operator|!=
name|NULL
operator|)
condition|?
name|varPtr
index|[
name|varIndex
index|]
operator|->
name|length
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* length2 */
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|Tcl_SetIntObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|varPtr
index|[
name|varIndex
index|]
operator|!=
name|NULL
operator|)
condition|?
operator|(
name|int
operator|)
name|varPtr
index|[
name|varIndex
index|]
operator|->
name|internalRep
operator|.
name|longValue
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* set */
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
comment|/* 	     * If the object currently bound to the variable with index 	     * varIndex has ref count 1 (i.e. the object is unshared) we 	     * can modify that object directly. Otherwise, if RC>1 (i.e. 	     * the object is shared), we must create a new object to 	     * modify/set and decrement the old formerly-shared object's 	     * ref count. This is "copy on write". 	     */
name|string
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|varPtr
index|[
name|varIndex
index|]
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|Tcl_IsShared
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
condition|)
block|{
name|Tcl_SetStringObj
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|,
name|string
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SetVarToObj
argument_list|(
name|varIndex
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|string
argument_list|,
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* set2 */
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
name|SetVarToObj
argument_list|(
name|varIndex
argument_list|,
name|objv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* setlength */
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|length
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|varPtr
index|[
name|varIndex
index|]
operator|!=
name|NULL
condition|)
block|{
name|Tcl_SetObjLength
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SetVarToObj --  *  *	Utility routine to assign a Tcl_Obj* to a test variable. The  *	Tcl_Obj* can be NULL.  *  * Results:  *	None.  *  * Side effects:  *	This routine handles ref counting details for assignment:  *	i.e. the old value's ref count must be decremented (if not NULL) and  *	the new one incremented (also if not NULL).  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|SetVarToObj
parameter_list|(
name|varIndex
parameter_list|,
name|objPtr
parameter_list|)
name|int
name|varIndex
decl_stmt|;
comment|/* Designates the assignment variable. */
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Points to object to assign to var. */
block|{
if|if
condition|(
name|varPtr
index|[
name|varIndex
index|]
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|varPtr
index|[
name|varIndex
index|]
argument_list|)
expr_stmt|;
block|}
name|varPtr
index|[
name|varIndex
index|]
operator|=
name|objPtr
expr_stmt|;
if|if
condition|(
name|objPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_IncrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * GetVariableIndex --  *  *	Utility routine to get a test variable index from the command line.  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|GetVariableIndex
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|indexPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter for error reporting. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String containing a variable index 				 * specified as a nonnegative number less 				 * than NUMBER_OF_OBJECT_VARS. */
name|int
modifier|*
name|indexPtr
decl_stmt|;
comment|/* Place to store converted result. */
block|{
name|int
name|index
decl_stmt|;
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
operator|&
name|index
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|NUMBER_OF_OBJECT_VARS
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"bad variable index"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
operator|*
name|indexPtr
operator|=
name|index
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CheckIfVarUnset --  *  *	Utility procedure that checks whether a test variable is readable:  *	i.e., that varPtr[varIndex] is non-NULL.  *  * Results:  *	1 if the test variable is unset (NULL); 0 otherwise.  *  * Side effects:  *	Sets the interpreter result to an error message if the variable is  *	unset (NULL).  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CheckIfVarUnset
parameter_list|(
name|interp
parameter_list|,
name|varIndex
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter for error reporting. */
name|int
name|varIndex
decl_stmt|;
comment|/* Index of the test variable to check. */
block|{
if|if
condition|(
name|varPtr
index|[
name|varIndex
index|]
operator|==
name|NULL
condition|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"variable %d is unset (NULL)"
argument_list|,
name|varIndex
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

