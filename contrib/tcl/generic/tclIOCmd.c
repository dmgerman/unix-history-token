begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclIOCmd.c --  *  *	Contains the definitions of most of the Tcl commands relating to IO.  *  * Copyright (c) 1995-1996 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclIOCmd.c 1.119 97/07/25 20:49:23  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * Return at most this number of bytes in one call to Tcl_Read:  */
end_comment

begin_define
define|#
directive|define
name|TCL_READ_CHUNK_SIZE
value|4096
end_define

begin_comment
comment|/*  * Callback structure for accept callback in a TCP server.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|AcceptCallback
block|{
name|char
modifier|*
name|script
decl_stmt|;
comment|/* Script to invoke. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to run it. */
block|}
name|AcceptCallback
typedef|;
end_typedef

begin_comment
comment|/*  * Static functions for this file:  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|AcceptCallbackProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|callbackData
operator|,
name|Tcl_Channel
name|chan
operator|,
name|char
operator|*
name|address
operator|,
name|int
name|port
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|RegisterTcpServerInterpCleanup
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|AcceptCallback
operator|*
name|acceptCallbackPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|TcpAcceptCallbacksDeleteProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|TcpServerCloseProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|callbackData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|UnregisterTcpServerInterpCleanupProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|AcceptCallback
operator|*
name|acceptCallbackPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_PutsObjCmd --  *  *	This procedure is invoked to process the "puts" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Produces output on a channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_PutsObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel to puts on. */
name|int
name|i
decl_stmt|;
comment|/* Counter. */
name|int
name|newline
decl_stmt|;
comment|/* Add a newline at end? */
name|char
modifier|*
name|channelId
decl_stmt|;
comment|/* Name of channel for puts. */
name|int
name|result
decl_stmt|;
comment|/* Result of puts operation. */
name|int
name|mode
decl_stmt|;
comment|/* Mode in which channel is opened. */
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|length
decl_stmt|;
name|Tcl_Obj
modifier|*
name|resultPtr
decl_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|newline
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|objc
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"-nonewline"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|newline
operator|=
literal|0
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|<
operator|(
name|objc
operator|-
literal|3
operator|)
operator|)
operator|||
operator|(
name|i
operator|>=
name|objc
operator|)
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"?-nonewline? ?channelId? string"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * The code below provides backwards compatibility with an old      * form of the command that is no longer recommended or documented.      */
name|resultPtr
operator|=
name|Tcl_NewObj
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|(
name|objc
operator|-
literal|3
operator|)
condition|)
block|{
name|arg
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"nonewline"
argument_list|,
operator|(
name|size_t
operator|)
name|length
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|resultPtr
argument_list|,
literal|"bad argument \""
argument_list|,
name|arg
argument_list|,
literal|"\": should be \"nonewline\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|resultPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|newline
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
operator|(
name|objc
operator|-
literal|1
operator|)
condition|)
block|{
name|channelId
operator|=
literal|"stdout"
expr_stmt|;
block|}
else|else
block|{
name|channelId
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|chan
operator|=
name|Tcl_GetChannel
argument_list|(
name|interp
argument_list|,
name|channelId
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|resultPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|mode
operator|&
name|TCL_WRITABLE
operator|)
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|resultPtr
argument_list|,
literal|"channel \""
argument_list|,
name|channelId
argument_list|,
literal|"\" wasn't opened for writing"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|resultPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|arg
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_Write
argument_list|(
name|chan
argument_list|,
name|arg
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|newline
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|Tcl_Write
argument_list|(
name|chan
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|resultPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
name|error
label|:
name|Tcl_AppendStringsToObj
argument_list|(
name|resultPtr
argument_list|,
literal|"error writing \""
argument_list|,
name|Tcl_GetChannelName
argument_list|(
name|chan
argument_list|)
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|resultPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_FlushObjCmd --  *  *	This procedure is called to process the Tcl "flush" command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	May cause output to appear on the specified channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_FlushObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel to flush on. */
name|char
modifier|*
name|arg
decl_stmt|;
name|Tcl_Obj
modifier|*
name|resultPtr
decl_stmt|;
name|int
name|mode
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"channelId"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|arg
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|chan
operator|=
name|Tcl_GetChannel
argument_list|(
name|interp
argument_list|,
name|arg
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|resultPtr
operator|=
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
name|TCL_WRITABLE
operator|)
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|resultPtr
argument_list|,
literal|"channel \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"\" wasn't opened for writing"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_Flush
argument_list|(
name|chan
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|resultPtr
argument_list|,
literal|"error flushing \""
argument_list|,
name|Tcl_GetChannelName
argument_list|(
name|chan
argument_list|)
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetsObjCmd --  *  *	This procedure is called to process the Tcl "gets" command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	May consume input from channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_GetsObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel to read from. */
name|int
name|lineLen
decl_stmt|;
comment|/* Length of line just read. */
name|int
name|mode
decl_stmt|;
comment|/* Mode in which channel is opened. */
name|char
modifier|*
name|arg
decl_stmt|;
name|Tcl_Obj
modifier|*
name|resultPtr
decl_stmt|,
modifier|*
name|objPtr
decl_stmt|;
if|if
condition|(
operator|(
name|objc
operator|!=
literal|2
operator|)
operator|&&
operator|(
name|objc
operator|!=
literal|3
operator|)
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"channelId ?varName?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|arg
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|chan
operator|=
name|Tcl_GetChannel
argument_list|(
name|interp
argument_list|,
name|arg
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|resultPtr
operator|=
name|Tcl_NewObj
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
name|TCL_READABLE
operator|)
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|resultPtr
argument_list|,
literal|"channel \""
argument_list|,
name|arg
argument_list|,
literal|"\" wasn't opened for reading"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|resultPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|lineLen
operator|=
name|Tcl_GetsObj
argument_list|(
name|chan
argument_list|,
name|resultPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|lineLen
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|Tcl_Eof
argument_list|(
name|chan
argument_list|)
operator|&&
operator|!
name|Tcl_InputBlocked
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|Tcl_SetObjLength
argument_list|(
name|resultPtr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|resultPtr
argument_list|,
literal|"error reading \""
argument_list|,
name|Tcl_GetChannelName
argument_list|(
name|chan
argument_list|)
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|resultPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|lineLen
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|objc
operator|==
literal|3
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|objPtr
operator|=
name|Tcl_ObjSetVar2
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|,
name|resultPtr
argument_list|,
name|TCL_LEAVE_ERR_MSG
operator||
name|TCL_PARSE_PART1
argument_list|)
expr_stmt|;
if|if
condition|(
name|objPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|resultPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_SetIntObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|lineLen
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|resultPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ReadObjCmd --  *  *	This procedure is invoked to process the Tcl "read" command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	May consume input from channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_ReadObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel to read from. */
name|int
name|newline
decl_stmt|,
name|i
decl_stmt|;
comment|/* Discard newline at end? */
name|int
name|toRead
decl_stmt|;
comment|/* How many bytes to read? */
name|int
name|toReadNow
decl_stmt|;
comment|/* How many bytes to attempt to                                          * read in the current iteration? */
name|int
name|charactersRead
decl_stmt|;
comment|/* How many characters were read? */
name|int
name|charactersReadNow
decl_stmt|;
comment|/* How many characters were read                                          * in this iteration? */
name|int
name|mode
decl_stmt|;
comment|/* Mode in which channel is opened. */
name|int
name|bufSize
decl_stmt|;
comment|/* Channel buffer size; used to decide                                          * in what chunk sizes to read from                                          * the channel. */
name|char
modifier|*
name|arg
decl_stmt|;
name|Tcl_Obj
modifier|*
name|resultPtr
decl_stmt|;
if|if
condition|(
operator|(
name|objc
operator|!=
literal|2
operator|)
operator|&&
operator|(
name|objc
operator|!=
literal|3
operator|)
condition|)
block|{
name|argerror
label|:
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"channelId ?numBytes?"
argument_list|)
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|" or \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|" ?-nonewline? channelId\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|i
operator|=
literal|1
expr_stmt|;
name|newline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"-nonewline"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newline
operator|=
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|objc
condition|)
block|{
goto|goto
name|argerror
goto|;
block|}
name|arg
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|chan
operator|=
name|Tcl_GetChannel
argument_list|(
name|interp
argument_list|,
name|arg
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|mode
operator|&
name|TCL_READABLE
operator|)
operator|==
literal|0
condition|)
block|{
name|resultPtr
operator|=
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|resultPtr
argument_list|,
literal|"channel \""
argument_list|,
name|arg
argument_list|,
literal|"\" wasn't opened for reading"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|i
operator|++
expr_stmt|;
comment|/* Consumed channel name. */
comment|/*      * Compute how many bytes to read, and see whether the final      * newline should be dropped.      */
name|toRead
operator|=
name|INT_MAX
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|objc
condition|)
block|{
name|arg
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
name|i
index|]
argument_list|,
operator|&
name|toRead
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"nonewline"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newline
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|resultPtr
operator|=
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|resultPtr
argument_list|,
literal|"bad argument \""
argument_list|,
name|arg
argument_list|,
literal|"\": should be \"nonewline\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
comment|/*      * Create a new object and use that instead of the interpreter      * result. We cannot use the interpreter's result object because      * it may get smashed at any time by recursive calls.      */
name|resultPtr
operator|=
name|Tcl_NewObj
argument_list|()
expr_stmt|;
name|bufSize
operator|=
name|Tcl_GetChannelBufferSize
argument_list|(
name|chan
argument_list|)
expr_stmt|;
comment|/*      * If the caller specified a maximum length to read, then that is      * a good size to preallocate.      */
if|if
condition|(
operator|(
name|toRead
operator|!=
name|INT_MAX
operator|)
operator|&&
operator|(
name|toRead
operator|>
name|bufSize
operator|)
condition|)
block|{
name|Tcl_SetObjLength
argument_list|(
name|resultPtr
argument_list|,
name|toRead
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|charactersRead
operator|=
literal|0
init|;
name|charactersRead
operator|<
name|toRead
condition|;
control|)
block|{
name|toReadNow
operator|=
name|toRead
operator|-
name|charactersRead
expr_stmt|;
if|if
condition|(
name|toReadNow
operator|>
name|bufSize
condition|)
block|{
name|toReadNow
operator|=
name|bufSize
expr_stmt|;
block|}
comment|/*          * NOTE: This is a NOOP if we set the size (above) to the          * number of bytes we expect to read. In the degenerate          * case, however, it will grow the buffer by the channel          * buffersize, which is 4K in most cases. This will result          * in inefficient copying for large files. This will be          * fixed in a future release.          */
name|Tcl_SetObjLength
argument_list|(
name|resultPtr
argument_list|,
name|charactersRead
operator|+
name|toReadNow
argument_list|)
expr_stmt|;
name|charactersReadNow
operator|=
name|Tcl_Read
argument_list|(
name|chan
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|resultPtr
argument_list|,
name|NULL
argument_list|)
operator|+
name|charactersRead
argument_list|,
name|toReadNow
argument_list|)
expr_stmt|;
if|if
condition|(
name|charactersReadNow
operator|<
literal|0
condition|)
block|{
name|Tcl_SetObjLength
argument_list|(
name|resultPtr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|resultPtr
argument_list|,
literal|"error reading \""
argument_list|,
name|Tcl_GetChannelName
argument_list|(
name|chan
argument_list|)
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|resultPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*          * If we had a short read it means that we have either EOF          * or BLOCKED on the channel, so break out.          */
name|charactersRead
operator|+=
name|charactersReadNow
expr_stmt|;
comment|/*          * Do not call the driver again if we got a short read          */
if|if
condition|(
name|charactersReadNow
operator|<
name|toReadNow
condition|)
block|{
break|break;
comment|/* Out of "for" loop. */
block|}
block|}
comment|/*      * If requested, remove the last newline in the channel if at EOF.      */
if|if
condition|(
operator|(
name|charactersRead
operator|>
literal|0
operator|)
operator|&&
operator|(
name|newline
operator|)
operator|&&
operator|(
name|Tcl_GetStringFromObj
argument_list|(
name|resultPtr
argument_list|,
name|NULL
argument_list|)
index|[
name|charactersRead
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|charactersRead
operator|--
expr_stmt|;
block|}
name|Tcl_SetObjLength
argument_list|(
name|resultPtr
argument_list|,
name|charactersRead
argument_list|)
expr_stmt|;
comment|/*      * Now set the object into the interpreter result and release our      * hold on it by decrrefing it.      */
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|resultPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SeekCmd --  *  *	This procedure is invoked to process the Tcl "seek" command. See  *	the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Moves the position of the access point on the specified channel.  *	May flush queued output.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_SeekCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel to tell on. */
name|int
name|offset
decl_stmt|,
name|mode
decl_stmt|;
comment|/* Where to seek? */
name|int
name|result
decl_stmt|;
comment|/* Of calling Tcl_Seek. */
if|if
condition|(
operator|(
name|argc
operator|!=
literal|3
operator|)
operator|&&
operator|(
name|argc
operator|!=
literal|4
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" channelId offset ?origin?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|chan
operator|=
name|Tcl_GetChannel
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|offset
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|mode
operator|=
name|SEEK_SET
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|4
condition|)
block|{
name|size_t
name|length
decl_stmt|;
name|int
name|c
decl_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|c
operator|=
name|argv
index|[
literal|3
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'s'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|,
literal|"start"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mode
operator|=
name|SEEK_SET
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'c'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|,
literal|"current"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mode
operator|=
name|SEEK_CUR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|,
literal|"end"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mode
operator|=
name|SEEK_END
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad origin \""
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
literal|"\": should be start, current, or end"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
name|result
operator|=
name|Tcl_Seek
argument_list|(
name|chan
argument_list|,
name|offset
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"error during seek on \""
argument_list|,
name|Tcl_GetChannelName
argument_list|(
name|chan
argument_list|)
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_TellCmd --  *  *	This procedure is invoked to process the Tcl "tell" command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_TellCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel to tell on. */
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" channelId\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Try to find a channel with the right name and permissions in      * the IO channel table of this interpreter.      */
name|chan
operator|=
name|Tcl_GetChannel
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|TclFormatInt
argument_list|(
name|buf
argument_list|,
name|Tcl_Tell
argument_list|(
name|chan
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CloseObjCmd --  *  *	This procedure is invoked to process the Tcl "close" command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	May discard queued input; may flush queued output.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_CloseObjCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel to close. */
name|int
name|len
decl_stmt|;
comment|/* Length of error output. */
name|char
modifier|*
name|arg
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"channelId"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|arg
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|chan
operator|=
name|Tcl_GetChannel
argument_list|(
name|interp
argument_list|,
name|arg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_UnregisterChannel
argument_list|(
name|interp
argument_list|,
name|chan
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
comment|/*          * If there is an error message and it ends with a newline, remove          * the newline. This is done for command pipeline channels where the          * error output from the subprocesses is stored in interp->result.          *          * NOTE: This is likely to not have any effect on regular error          * messages produced by drivers during the closing of a channel,          * because the Tcl convention is that such error messages do not          * have a terminating newline.          */
name|len
operator|=
name|strlen
argument_list|(
name|interp
operator|->
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|>
literal|0
operator|)
operator|&&
operator|(
name|interp
operator|->
name|result
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|interp
operator|->
name|result
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_FconfigureCmd --  *  *	This procedure is invoked to process the Tcl "fconfigure" command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	May modify the behavior of an IO channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_FconfigureCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel to set a mode on. */
name|int
name|i
decl_stmt|;
comment|/* Iterate over arg-value pairs. */
name|Tcl_DString
name|ds
decl_stmt|;
comment|/* DString to hold result of                                          * calling Tcl_GetChannelOption. */
if|if
condition|(
operator|(
name|argc
operator|<
literal|2
operator|)
operator|||
operator|(
operator|(
operator|(
name|argc
operator|%
literal|2
operator|)
operator|==
literal|1
operator|)
operator|&&
operator|(
name|argc
operator|!=
literal|3
operator|)
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" channelId ?optionName? ?value? ?optionName value?...\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|chan
operator|=
name|Tcl_GetChannel
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
name|Tcl_DStringInit
argument_list|(
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_GetChannelOption
argument_list|(
name|interp
argument_list|,
name|chan
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|ds
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_DStringFree
argument_list|(
operator|&
name|ds
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_DStringResult
argument_list|(
name|interp
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
block|{
name|Tcl_DStringInit
argument_list|(
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_GetChannelOption
argument_list|(
name|interp
argument_list|,
name|chan
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|ds
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_DStringFree
argument_list|(
operator|&
name|ds
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_DStringResult
argument_list|(
name|interp
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|Tcl_SetChannelOption
argument_list|(
name|interp
argument_list|,
name|chan
argument_list|,
name|argv
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_EofObjCmd --  *  *	This procedure is invoked to process the Tcl "eof" command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Sets interp->result to "0" or "1" depending on whether the  *	specified channel has an EOF condition.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_EofObjCmd
parameter_list|(
name|unused
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|unused
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel to query for EOF. */
name|int
name|mode
decl_stmt|;
comment|/* Mode in which channel is opened. */
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"channelId"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|arg
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|chan
operator|=
name|Tcl_GetChannel
argument_list|(
name|interp
argument_list|,
name|arg
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|TclFormatInt
argument_list|(
name|buf
argument_list|,
name|Tcl_Eof
argument_list|(
name|chan
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ExecCmd --  *  *	This procedure is invoked to process the "exec" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_ExecCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
ifdef|#
directive|ifdef
name|MAC_TCL
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"exec not implemented under Mac OS"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
else|#
directive|else
comment|/* !MAC_TCL */
name|int
name|keepNewline
decl_stmt|,
name|firstWord
decl_stmt|,
name|background
decl_stmt|,
name|length
decl_stmt|,
name|result
decl_stmt|;
name|Tcl_Channel
name|chan
decl_stmt|;
name|Tcl_DString
name|ds
decl_stmt|;
name|int
name|readSoFar
decl_stmt|,
name|readNow
decl_stmt|,
name|bufSize
decl_stmt|;
comment|/*      * Check for a leading "-keepnewline" argument.      */
name|keepNewline
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|firstWord
operator|=
literal|1
init|;
operator|(
name|firstWord
operator|<
name|argc
operator|)
operator|&&
operator|(
name|argv
index|[
name|firstWord
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|;
name|firstWord
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|firstWord
index|]
argument_list|,
literal|"-keepnewline"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|keepNewline
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|firstWord
index|]
argument_list|,
literal|"--"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|firstWord
operator|++
expr_stmt|;
break|break;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad switch \""
argument_list|,
name|argv
index|[
name|firstWord
index|]
argument_list|,
literal|"\": must be -keepnewline or --"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
if|if
condition|(
name|argc
operator|<=
name|firstWord
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" ?switches? arg ?arg ...?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * See if the command is to be run in background.      */
name|background
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|argv
index|[
name|argc
operator|-
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'&'
operator|)
operator|&&
operator|(
name|argv
index|[
name|argc
operator|-
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|argc
operator|--
expr_stmt|;
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
name|background
operator|=
literal|1
expr_stmt|;
block|}
name|chan
operator|=
name|Tcl_OpenCommandChannel
argument_list|(
name|interp
argument_list|,
name|argc
operator|-
name|firstWord
argument_list|,
name|argv
operator|+
name|firstWord
argument_list|,
operator|(
name|background
condition|?
literal|0
else|:
name|TCL_STDOUT
operator||
name|TCL_STDERR
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|background
condition|)
block|{
comment|/*          * Get the list of PIDs from the pipeline into interp->result and          * detach the PIDs (instead of waiting for them).          */
name|TclGetAndDetachPids
argument_list|(
name|interp
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_Close
argument_list|(
name|interp
argument_list|,
name|chan
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|Tcl_GetChannelHandle
argument_list|(
name|chan
argument_list|,
name|TCL_READABLE
argument_list|,
name|NULL
argument_list|)
operator|==
name|TCL_OK
condition|)
block|{
define|#
directive|define
name|EXEC_BUFFER_SIZE
value|4096
name|Tcl_DStringInit
argument_list|(
operator|&
name|ds
argument_list|)
expr_stmt|;
name|readSoFar
operator|=
literal|0
expr_stmt|;
name|bufSize
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|bufSize
operator|+=
name|EXEC_BUFFER_SIZE
expr_stmt|;
name|Tcl_DStringSetLength
argument_list|(
operator|&
name|ds
argument_list|,
name|bufSize
argument_list|)
expr_stmt|;
name|readNow
operator|=
name|Tcl_Read
argument_list|(
name|chan
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|ds
argument_list|)
operator|+
name|readSoFar
argument_list|,
name|EXEC_BUFFER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|readNow
operator|<
literal|0
condition|)
block|{
name|Tcl_DStringFree
argument_list|(
operator|&
name|ds
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"error reading output from command: "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|readSoFar
operator|+=
name|readNow
expr_stmt|;
if|if
condition|(
name|readNow
operator|<
name|EXEC_BUFFER_SIZE
condition|)
block|{
break|break;
comment|/* Out of "while (1)" loop. */
block|}
block|}
name|Tcl_DStringSetLength
argument_list|(
operator|&
name|ds
argument_list|,
name|readSoFar
argument_list|)
expr_stmt|;
name|Tcl_DStringResult
argument_list|(
name|interp
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|Tcl_Close
argument_list|(
name|interp
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/*      * If the last character of interp->result is a newline, then remove      * the newline character (the newline would just confuse things).      * Special hack: must replace the old terminating null character      * as a signal to Tcl_AppendResult et al. that we've mucked with      * the string.      */
name|length
operator|=
name|strlen
argument_list|(
name|interp
operator|->
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|keepNewline
operator|&&
operator|(
name|length
operator|>
literal|0
operator|)
operator|&&
operator|(
name|interp
operator|->
name|result
index|[
name|length
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|interp
operator|->
name|result
index|[
name|length
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|interp
operator|->
name|result
index|[
name|length
index|]
operator|=
literal|'x'
expr_stmt|;
block|}
return|return
name|result
return|;
endif|#
directive|endif
comment|/* !MAC_TCL */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_FblockedObjCmd --  *  *	This procedure is invoked to process the Tcl "fblocked" command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Sets interp->result to "0" or "1" depending on whether the  *	a preceding input operation on the channel would have blocked.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_FblockedObjCmd
parameter_list|(
name|unused
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|unused
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel to query for blocked. */
name|int
name|mode
decl_stmt|;
comment|/* Mode in which channel was opened. */
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"channelId"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|arg
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|chan
operator|=
name|Tcl_GetChannel
argument_list|(
name|interp
argument_list|,
name|arg
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|mode
operator|&
name|TCL_READABLE
operator|)
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"channel \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"\" wasn't opened for reading"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|TclFormatInt
argument_list|(
name|buf
argument_list|,
name|Tcl_InputBlocked
argument_list|(
name|chan
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_OpenCmd --  *  *	This procedure is invoked to process the "open" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_OpenCmd
parameter_list|(
name|notUsed
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|notUsed
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|pipeline
decl_stmt|,
name|prot
decl_stmt|;
name|char
modifier|*
name|modeString
decl_stmt|;
name|Tcl_Channel
name|chan
decl_stmt|;
if|if
condition|(
operator|(
name|argc
operator|<
literal|2
operator|)
operator|||
operator|(
name|argc
operator|>
literal|4
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" fileName ?access? ?permissions?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|prot
operator|=
literal|0666
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
name|modeString
operator|=
literal|"r"
expr_stmt|;
block|}
else|else
block|{
name|modeString
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
operator|&
name|prot
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
block|}
name|pipeline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'|'
condition|)
block|{
name|pipeline
operator|=
literal|1
expr_stmt|;
block|}
comment|/*      * Open the file or create a process pipeline.      */
if|if
condition|(
operator|!
name|pipeline
condition|)
block|{
name|chan
operator|=
name|Tcl_OpenFileChannel
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|modeString
argument_list|,
name|prot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MAC_TCL
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"command pipelines not supported on Macintosh OS"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
else|#
directive|else
name|int
name|mode
decl_stmt|,
name|seekFlag
decl_stmt|,
name|cmdArgc
decl_stmt|;
name|char
modifier|*
modifier|*
name|cmdArgv
decl_stmt|;
if|if
condition|(
name|Tcl_SplitList
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
operator|+
literal|1
argument_list|,
operator|&
name|cmdArgc
argument_list|,
operator|&
name|cmdArgv
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|mode
operator|=
name|TclGetOpenMode
argument_list|(
name|interp
argument_list|,
name|modeString
argument_list|,
operator|&
name|seekFlag
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
operator|-
literal|1
condition|)
block|{
name|chan
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|int
name|flags
init|=
name|TCL_STDERR
operator||
name|TCL_ENFORCE_MODE
decl_stmt|;
switch|switch
condition|(
name|mode
operator|&
operator|(
name|O_RDONLY
operator||
name|O_WRONLY
operator||
name|O_RDWR
operator|)
condition|)
block|{
case|case
name|O_RDONLY
case|:
name|flags
operator||=
name|TCL_STDOUT
expr_stmt|;
break|break;
case|case
name|O_WRONLY
case|:
name|flags
operator||=
name|TCL_STDIN
expr_stmt|;
break|break;
case|case
name|O_RDWR
case|:
name|flags
operator||=
operator|(
name|TCL_STDIN
operator||
name|TCL_STDOUT
operator|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Tcl_OpenCmd: invalid mode value"
argument_list|)
expr_stmt|;
break|break;
block|}
name|chan
operator|=
name|Tcl_OpenCommandChannel
argument_list|(
name|interp
argument_list|,
name|cmdArgc
argument_list|,
name|cmdArgv
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cmdArgv
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_RegisterChannel
argument_list|(
name|interp
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|Tcl_GetChannelName
argument_list|(
name|chan
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TcpAcceptCallbacksDeleteProc --  *  *	Assocdata cleanup routine called when an interpreter is being  *	deleted to set the interp field of all the accept callback records  *	registered with	the interpreter to NULL. This will prevent the  *	interpreter from being used in the future to eval accept scripts.  *  * Results:  *	None.  *  * Side effects:  *	Deallocates memory and sets the interp field of all the accept  *	callback records to NULL to prevent this interpreter from being  *	used subsequently to eval accept scripts.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|TcpAcceptCallbacksDeleteProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Data which was passed when the assocdata                                  * was registered. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter being deleted - not used. */
block|{
name|Tcl_HashTable
modifier|*
name|hTblPtr
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|Tcl_HashSearch
name|hSearch
decl_stmt|;
name|AcceptCallback
modifier|*
name|acceptCallbackPtr
decl_stmt|;
name|hTblPtr
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|clientData
expr_stmt|;
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|hTblPtr
argument_list|,
operator|&
name|hSearch
argument_list|)
init|;
name|hPtr
operator|!=
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|hSearch
argument_list|)
control|)
block|{
name|acceptCallbackPtr
operator|=
operator|(
name|AcceptCallback
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
name|acceptCallbackPtr
operator|->
name|interp
operator|=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|Tcl_DeleteHashTable
argument_list|(
name|hTblPtr
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hTblPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * RegisterTcpServerInterpCleanup --  *  *	Registers an accept callback record to have its interp  *	field set to NULL when the interpreter is deleted.  *  * Results:  *	None.  *  * Side effects:  *	When, in the future, the interpreter is deleted, the interp  *	field of the accept callback data structure will be set to  *	NULL. This will prevent attempts to eval the accept script  *	in a deleted interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|RegisterTcpServerInterpCleanup
parameter_list|(
name|interp
parameter_list|,
name|acceptCallbackPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter for which we want to be                                  * informed of deletion. */
name|AcceptCallback
modifier|*
name|acceptCallbackPtr
decl_stmt|;
comment|/* The accept callback record whose                                  * interp field we want set to NULL when                                  * the interpreter is deleted. */
block|{
name|Tcl_HashTable
modifier|*
name|hTblPtr
decl_stmt|;
comment|/* Hash table for accept callback                                  * records to smash when the interpreter                                  * will be deleted. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Entry for this record. */
name|int
name|new
decl_stmt|;
comment|/* Is the entry new? */
name|hTblPtr
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclTCPAcceptCallbacks"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hTblPtr
operator|==
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
condition|)
block|{
name|hTblPtr
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|Tcl_HashTable
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
name|hTblPtr
argument_list|,
name|TCL_ONE_WORD_KEYS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Tcl_SetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclTCPAcceptCallbacks"
argument_list|,
name|TcpAcceptCallbacksDeleteProc
argument_list|,
operator|(
name|ClientData
operator|)
name|hTblPtr
argument_list|)
expr_stmt|;
block|}
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
name|hTblPtr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|acceptCallbackPtr
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
block|{
name|panic
argument_list|(
literal|"RegisterTcpServerCleanup: damaged accept record table"
argument_list|)
expr_stmt|;
block|}
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
operator|(
name|ClientData
operator|)
name|acceptCallbackPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * UnregisterTcpServerInterpCleanupProc --  *  *	Unregister a previously registered accept callback record. The  *	interp field of this record will no longer be set to NULL in  *	the future when the interpreter is deleted.  *  * Results:  *	None.  *  * Side effects:  *	Prevents the interp field of the accept callback record from  *	being set to NULL in the future when the interpreter is deleted.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|UnregisterTcpServerInterpCleanupProc
parameter_list|(
name|interp
parameter_list|,
name|acceptCallbackPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which the accept callback                                  * record was registered. */
name|AcceptCallback
modifier|*
name|acceptCallbackPtr
decl_stmt|;
comment|/* The record for which to delete the                                  * registration. */
block|{
name|Tcl_HashTable
modifier|*
name|hTblPtr
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|hTblPtr
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclTCPAcceptCallbacks"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hTblPtr
operator|==
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
condition|)
block|{
return|return;
block|}
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
name|hTblPtr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|acceptCallbackPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|)
block|{
return|return;
block|}
name|Tcl_DeleteHashEntry
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * AcceptCallbackProc --  *  *	This callback is invoked by the TCP channel driver when it  *	accepts a new connection from a client on a server socket.  *  * Results:  *	None.  *  * Side effects:  *	Whatever the script does.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|AcceptCallbackProc
parameter_list|(
name|callbackData
parameter_list|,
name|chan
parameter_list|,
name|address
parameter_list|,
name|port
parameter_list|)
name|ClientData
name|callbackData
decl_stmt|;
comment|/* The data stored when the callback                                          * was created in the call to                                          * Tcl_OpenTcpServer. */
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* Channel for the newly accepted                                          * connection. */
name|char
modifier|*
name|address
decl_stmt|;
comment|/* Address of client that was                                          * accepted. */
name|int
name|port
decl_stmt|;
comment|/* Port of client that was accepted. */
block|{
name|AcceptCallback
modifier|*
name|acceptCallbackPtr
decl_stmt|;
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
name|char
modifier|*
name|script
decl_stmt|;
name|char
name|portBuf
index|[
literal|10
index|]
decl_stmt|;
name|int
name|result
decl_stmt|;
name|acceptCallbackPtr
operator|=
operator|(
name|AcceptCallback
operator|*
operator|)
name|callbackData
expr_stmt|;
comment|/*      * Check if the callback is still valid; the interpreter may have gone      * away, this is signalled by setting the interp field of the callback      * data to NULL.      */
if|if
condition|(
name|acceptCallbackPtr
operator|->
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|script
operator|=
name|acceptCallbackPtr
operator|->
name|script
expr_stmt|;
name|interp
operator|=
name|acceptCallbackPtr
operator|->
name|interp
expr_stmt|;
name|Tcl_Preserve
argument_list|(
operator|(
name|ClientData
operator|)
name|script
argument_list|)
expr_stmt|;
name|Tcl_Preserve
argument_list|(
operator|(
name|ClientData
operator|)
name|interp
argument_list|)
expr_stmt|;
name|TclFormatInt
argument_list|(
name|portBuf
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|Tcl_RegisterChannel
argument_list|(
name|interp
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_VarEval
argument_list|(
name|interp
argument_list|,
name|script
argument_list|,
literal|" "
argument_list|,
name|Tcl_GetChannelName
argument_list|(
name|chan
argument_list|)
argument_list|,
literal|" "
argument_list|,
name|address
argument_list|,
literal|" "
argument_list|,
name|portBuf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_BackgroundError
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_UnregisterChannel
argument_list|(
name|interp
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
name|Tcl_Release
argument_list|(
operator|(
name|ClientData
operator|)
name|interp
argument_list|)
expr_stmt|;
name|Tcl_Release
argument_list|(
operator|(
name|ClientData
operator|)
name|script
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*          * The interpreter has been deleted, so there is no useful          * way to utilize the client socket - just close it.          */
name|Tcl_Close
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TcpServerCloseProc --  *  *	This callback is called when the TCP server channel for which it  *	was registered is being closed. It informs the interpreter in  *	which the accept script is evaluated (if that interpreter still  *	exists) that this channel no longer needs to be informed if the  *	interpreter is deleted.  *  * Results:  *	None.  *  * Side effects:  *	In the future, if the interpreter is deleted this channel will  *	no longer be informed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|TcpServerCloseProc
parameter_list|(
name|callbackData
parameter_list|)
name|ClientData
name|callbackData
decl_stmt|;
comment|/* The data passed in the call to                                  * Tcl_CreateCloseHandler. */
block|{
name|AcceptCallback
modifier|*
name|acceptCallbackPtr
decl_stmt|;
comment|/* The actual data. */
name|acceptCallbackPtr
operator|=
operator|(
name|AcceptCallback
operator|*
operator|)
name|callbackData
expr_stmt|;
if|if
condition|(
name|acceptCallbackPtr
operator|->
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|UnregisterTcpServerInterpCleanupProc
argument_list|(
name|acceptCallbackPtr
operator|->
name|interp
argument_list|,
name|acceptCallbackPtr
argument_list|)
expr_stmt|;
block|}
name|Tcl_EventuallyFree
argument_list|(
operator|(
name|ClientData
operator|)
name|acceptCallbackPtr
operator|->
name|script
argument_list|,
name|TCL_DYNAMIC
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|acceptCallbackPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SocketCmd --  *  *	This procedure is invoked to process the "socket" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Creates a socket based channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_SocketCmd
parameter_list|(
name|notUsed
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|notUsed
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|a
decl_stmt|,
name|server
decl_stmt|,
name|port
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|,
modifier|*
name|copyScript
decl_stmt|,
modifier|*
name|host
decl_stmt|,
modifier|*
name|script
decl_stmt|;
name|char
modifier|*
name|myaddr
init|=
name|NULL
decl_stmt|;
name|int
name|myport
init|=
literal|0
decl_stmt|;
name|int
name|async
init|=
literal|0
decl_stmt|;
name|Tcl_Channel
name|chan
decl_stmt|;
name|AcceptCallback
modifier|*
name|acceptCallbackPtr
decl_stmt|;
name|server
operator|=
literal|0
expr_stmt|;
name|script
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|TclHasSockets
argument_list|(
name|interp
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
for|for
control|(
name|a
operator|=
literal|1
init|;
name|a
operator|<
name|argc
condition|;
name|a
operator|++
control|)
block|{
name|arg
operator|=
name|argv
index|[
name|a
index|]
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-server"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|async
operator|==
literal|1
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"cannot set -async option for server sockets"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|server
operator|=
literal|1
expr_stmt|;
name|a
operator|++
expr_stmt|;
if|if
condition|(
name|a
operator|>=
name|argc
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"no argument given for -server option"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|script
operator|=
name|argv
index|[
name|a
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-myaddr"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|a
operator|++
expr_stmt|;
if|if
condition|(
name|a
operator|>=
name|argc
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"no argument given for -myaddr option"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|myaddr
operator|=
name|argv
index|[
name|a
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-myport"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|a
operator|++
expr_stmt|;
if|if
condition|(
name|a
operator|>=
name|argc
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"no argument given for -myport option"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|TclSockGetPort
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|a
index|]
argument_list|,
literal|"tcp"
argument_list|,
operator|&
name|myport
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-async"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|server
operator|==
literal|1
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"cannot set -async option for server sockets"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|async
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|arg
argument_list|,
literal|"\", must be -async, -myaddr, -myport, or -server"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
if|if
condition|(
name|server
condition|)
block|{
name|host
operator|=
name|myaddr
expr_stmt|;
comment|/* NULL implies INADDR_ANY */
if|if
condition|(
name|myport
operator|!=
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"Option -myport is not valid for servers"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|a
operator|<
name|argc
condition|)
block|{
name|host
operator|=
name|argv
index|[
name|a
index|]
expr_stmt|;
name|a
operator|++
expr_stmt|;
block|}
else|else
block|{
name|wrongNumArgs
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be either:\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" ?-myaddr addr? ?-myport myport? ?-async? host port\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" -server command ?-myaddr addr? port"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|a
operator|==
name|argc
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|TclSockGetPort
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|a
index|]
argument_list|,
literal|"tcp"
argument_list|,
operator|&
name|port
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
else|else
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
if|if
condition|(
name|server
condition|)
block|{
name|acceptCallbackPtr
operator|=
operator|(
name|AcceptCallback
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|AcceptCallback
argument_list|)
argument_list|)
expr_stmt|;
name|copyScript
operator|=
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|script
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|copyScript
argument_list|,
name|script
argument_list|)
expr_stmt|;
name|acceptCallbackPtr
operator|->
name|script
operator|=
name|copyScript
expr_stmt|;
name|acceptCallbackPtr
operator|->
name|interp
operator|=
name|interp
expr_stmt|;
name|chan
operator|=
name|Tcl_OpenTcpServer
argument_list|(
name|interp
argument_list|,
name|port
argument_list|,
name|host
argument_list|,
name|AcceptCallbackProc
argument_list|,
operator|(
name|ClientData
operator|)
name|acceptCallbackPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|copyScript
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|acceptCallbackPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*          * Register with the interpreter to let us know when the          * interpreter is deleted (by having the callback set the          * acceptCallbackPtr->interp field to NULL). This is to          * avoid trying to eval the script in a deleted interpreter.          */
name|RegisterTcpServerInterpCleanup
argument_list|(
name|interp
argument_list|,
name|acceptCallbackPtr
argument_list|)
expr_stmt|;
comment|/*          * Register a close callback. This callback will inform the          * interpreter (if it still exists) that this channel does not          * need to be informed when the interpreter is deleted.          */
name|Tcl_CreateCloseHandler
argument_list|(
name|chan
argument_list|,
name|TcpServerCloseProc
argument_list|,
operator|(
name|ClientData
operator|)
name|acceptCallbackPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chan
operator|=
name|Tcl_OpenTcpClient
argument_list|(
name|interp
argument_list|,
name|port
argument_list|,
name|host
argument_list|,
name|myaddr
argument_list|,
name|myport
argument_list|,
name|async
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
name|Tcl_RegisterChannel
argument_list|(
name|interp
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|Tcl_GetChannelName
argument_list|(
name|chan
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_FcopyObjCmd --  *  *	This procedure is invoked to process the "fcopy" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Moves data between two channels and possibly sets up a  *	background copy handler.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_FcopyObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Channel
name|inChan
decl_stmt|,
name|outChan
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|i
decl_stmt|;
name|int
name|toRead
decl_stmt|;
name|Tcl_Obj
modifier|*
name|cmdPtr
decl_stmt|;
specifier|static
name|char
modifier|*
name|switches
index|[]
init|=
block|{
literal|"-size"
block|,
literal|"-command"
block|,
name|NULL
block|}
decl_stmt|;
enum|enum
block|{
name|FcopySize
block|,
name|FcopyCommand
block|}
name|index
enum|;
if|if
condition|(
operator|(
name|objc
operator|<
literal|3
operator|)
operator|||
operator|(
name|objc
operator|>
literal|7
operator|)
operator|||
operator|(
name|objc
operator|==
literal|4
operator|)
operator|||
operator|(
name|objc
operator|==
literal|6
operator|)
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"input output ?-size size? ?-command callback?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Parse the channel arguments and verify that they are readable      * or writable, as appropriate.      */
name|arg
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|inChan
operator|=
name|Tcl_GetChannel
argument_list|(
name|interp
argument_list|,
name|arg
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|inChan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|mode
operator|&
name|TCL_READABLE
operator|)
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"channel \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"\" wasn't opened for reading"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|arg
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|outChan
operator|=
name|Tcl_GetChannel
argument_list|(
name|interp
argument_list|,
name|arg
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|outChan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|mode
operator|&
name|TCL_WRITABLE
operator|)
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"channel \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"\" wasn't opened for writing"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|toRead
operator|=
operator|-
literal|1
expr_stmt|;
name|cmdPtr
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|Tcl_GetIndexFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
name|i
index|]
argument_list|,
name|switches
argument_list|,
literal|"switch"
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|index
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|FcopySize
case|:
if|if
condition|(
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|&
name|toRead
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
break|break;
case|case
name|FcopyCommand
case|:
name|cmdPtr
operator|=
name|objv
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
break|break;
block|}
block|}
return|return
name|TclCopyChannel
argument_list|(
name|interp
argument_list|,
name|inChan
argument_list|,
name|outChan
argument_list|,
name|toRead
argument_list|,
name|cmdPtr
argument_list|)
return|;
block|}
end_function

end_unit

