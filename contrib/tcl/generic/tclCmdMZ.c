begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclCmdMZ.c --  *  *	This file contains the top-level command routines for most of  *	the Tcl built-in commands whose names begin with the letters  *	M to Z.  It contains only commands in the generic core (i.e.  *	those that don't depend much upon UNIX facilities).  *  * Copyright (c) 1987-1993 The Regents of the University of California.  * Copyright (c) 1994-1996 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclCmdMZ.c 1.66 96/07/23 16:15:55  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * Structure used to hold information about variable traces:  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|flags
decl_stmt|;
comment|/* Operations for which Tcl command is 				 * to be invoked. */
name|char
modifier|*
name|errMsg
decl_stmt|;
comment|/* Error message returned from Tcl command, 				 * or NULL.  Malloc'ed. */
name|int
name|length
decl_stmt|;
comment|/* Number of non-NULL chars. in command. */
name|char
name|command
index|[
literal|4
index|]
decl_stmt|;
comment|/* Space for Tcl command to invoke.  Actual 				 * size will be as large as necessary to 				 * hold command.  This field must be the 				 * last in the structure, so that it can 				 * be larger than 4 bytes. */
block|}
name|TraceVarInfo
typedef|;
end_typedef

begin_comment
comment|/*  * Forward declarations for procedures defined in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|TraceVarProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|name1
operator|,
name|char
operator|*
name|name2
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_PwdCmd --  *  *	This procedure is invoked to process the "pwd" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_PwdCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|char
modifier|*
name|dirName
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|dirName
operator|=
name|TclGetCwd
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirName
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|interp
operator|->
name|result
operator|=
name|dirName
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_RegexpCmd --  *  *	This procedure is invoked to process the "regexp" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_RegexpCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|noCase
init|=
literal|0
decl_stmt|;
name|int
name|indices
init|=
literal|0
decl_stmt|;
name|Tcl_RegExp
name|regExpr
decl_stmt|;
name|char
modifier|*
modifier|*
name|argPtr
decl_stmt|,
modifier|*
name|string
decl_stmt|,
modifier|*
name|pattern
decl_stmt|,
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|match
init|=
literal|0
decl_stmt|;
comment|/* Initialization needed only to 					 * prevent compiler warning. */
name|int
name|i
decl_stmt|;
name|Tcl_DString
name|stringDString
decl_stmt|,
name|patternDString
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|wrongNumArgs
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" ?switches? exp string ?matchVar? ?subMatchVar "
argument_list|,
literal|"subMatchVar ...?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|argPtr
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
name|argc
operator|--
expr_stmt|;
while|while
condition|(
operator|(
name|argc
operator|>
literal|0
operator|)
operator|&&
operator|(
name|argPtr
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
index|[
literal|0
index|]
argument_list|,
literal|"-indices"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|indices
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
index|[
literal|0
index|]
argument_list|,
literal|"-nocase"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|noCase
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
index|[
literal|0
index|]
argument_list|,
literal|"--"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|argPtr
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
break|break;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad switch \""
argument_list|,
name|argPtr
index|[
literal|0
index|]
argument_list|,
literal|"\": must be -indices, -nocase, or --"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|argPtr
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
comment|/*      * Convert the string and pattern to lower case, if desired, and      * perform the matching operation.      */
if|if
condition|(
name|noCase
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|patternDString
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|patternDString
argument_list|,
name|argPtr
index|[
literal|0
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|Tcl_DStringValue
argument_list|(
operator|&
name|patternDString
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|pattern
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isupper
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|p
operator|=
operator|(
name|char
operator|)
name|tolower
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Tcl_DStringInit
argument_list|(
operator|&
name|stringDString
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|stringDString
argument_list|,
name|argPtr
index|[
literal|1
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|string
operator|=
name|Tcl_DStringValue
argument_list|(
operator|&
name|stringDString
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|string
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isupper
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|p
operator|=
operator|(
name|char
operator|)
name|tolower
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|pattern
operator|=
name|argPtr
index|[
literal|0
index|]
expr_stmt|;
name|string
operator|=
name|argPtr
index|[
literal|1
index|]
expr_stmt|;
block|}
name|regExpr
operator|=
name|Tcl_RegExpCompile
argument_list|(
name|interp
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|regExpr
operator|!=
name|NULL
condition|)
block|{
name|match
operator|=
name|Tcl_RegExpExec
argument_list|(
name|interp
argument_list|,
name|regExpr
argument_list|,
name|string
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noCase
condition|)
block|{
name|Tcl_DStringFree
argument_list|(
operator|&
name|stringDString
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|patternDString
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regExpr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|match
operator|<
literal|0
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|!
name|match
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"0"
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
comment|/*      * If additional variable names have been specified, return      * index information in those variables.      */
name|argc
operator|-=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|result
decl_stmt|,
name|info
index|[
literal|50
index|]
decl_stmt|;
name|Tcl_RegExpRange
argument_list|(
name|regExpr
argument_list|,
name|i
argument_list|,
operator|&
name|start
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|indices
condition|)
block|{
name|result
operator|=
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argPtr
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
literal|"-1 -1"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argPtr
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|indices
condition|)
block|{
name|sprintf
argument_list|(
name|info
argument_list|,
literal|"%d %d"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|start
operator|-
name|string
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|end
operator|-
name|string
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argPtr
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
name|info
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|savedChar
decl_stmt|,
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|first
operator|=
name|argPtr
index|[
literal|1
index|]
operator|+
operator|(
name|start
operator|-
name|string
operator|)
expr_stmt|;
name|last
operator|=
name|argPtr
index|[
literal|1
index|]
operator|+
operator|(
name|end
operator|-
name|string
operator|)
expr_stmt|;
name|savedChar
operator|=
operator|*
name|last
expr_stmt|;
operator|*
name|last
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argPtr
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
name|first
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|last
operator|=
name|savedChar
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't set variable \""
argument_list|,
name|argPtr
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
name|interp
operator|->
name|result
operator|=
literal|"1"
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_RegsubCmd --  *  *	This procedure is invoked to process the "regsub" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_RegsubCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|noCase
init|=
literal|0
decl_stmt|,
name|all
init|=
literal|0
decl_stmt|;
name|Tcl_RegExp
name|regExpr
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|,
modifier|*
name|pattern
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|firstChar
decl_stmt|,
modifier|*
name|newValue
decl_stmt|,
modifier|*
modifier|*
name|argPtr
decl_stmt|;
name|int
name|match
decl_stmt|,
name|flags
decl_stmt|,
name|code
decl_stmt|,
name|numMatches
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|subStart
decl_stmt|,
modifier|*
name|subEnd
decl_stmt|;
specifier|register
name|char
modifier|*
name|src
decl_stmt|,
name|c
decl_stmt|;
name|Tcl_DString
name|stringDString
decl_stmt|,
name|patternDString
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|5
condition|)
block|{
name|wrongNumArgs
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" ?switches? exp string subSpec varName\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|argPtr
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
name|argc
operator|--
expr_stmt|;
while|while
condition|(
name|argPtr
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
index|[
literal|0
index|]
argument_list|,
literal|"-nocase"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|noCase
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
index|[
literal|0
index|]
argument_list|,
literal|"-all"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|all
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
index|[
literal|0
index|]
argument_list|,
literal|"--"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|argPtr
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
break|break;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad switch \""
argument_list|,
name|argPtr
index|[
literal|0
index|]
argument_list|,
literal|"\": must be -all, -nocase, or --"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|argPtr
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
comment|/*      * Convert the string and pattern to lower case, if desired.      */
if|if
condition|(
name|noCase
condition|)
block|{
name|Tcl_DStringInit
argument_list|(
operator|&
name|patternDString
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|patternDString
argument_list|,
name|argPtr
index|[
literal|0
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|Tcl_DStringValue
argument_list|(
operator|&
name|patternDString
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|pattern
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isupper
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|p
operator|=
operator|(
name|char
operator|)
name|tolower
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Tcl_DStringInit
argument_list|(
operator|&
name|stringDString
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|stringDString
argument_list|,
name|argPtr
index|[
literal|1
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|string
operator|=
name|Tcl_DStringValue
argument_list|(
operator|&
name|stringDString
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|string
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isupper
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|p
operator|=
operator|(
name|char
operator|)
name|tolower
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|pattern
operator|=
name|argPtr
index|[
literal|0
index|]
expr_stmt|;
name|string
operator|=
name|argPtr
index|[
literal|1
index|]
expr_stmt|;
block|}
name|regExpr
operator|=
name|Tcl_RegExpCompile
argument_list|(
name|interp
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|regExpr
operator|==
name|NULL
condition|)
block|{
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*      * The following loop is to handle multiple matches within the      * same source string;  each iteration handles one match and its      * corresponding substitution.  If "-all" hasn't been specified      * then the loop body only gets executed once.      */
name|flags
operator|=
literal|0
expr_stmt|;
name|numMatches
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|string
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
control|)
block|{
name|match
operator|=
name|Tcl_RegExpExec
argument_list|(
name|interp
argument_list|,
name|regExpr
argument_list|,
name|p
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|<
literal|0
condition|)
block|{
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|!
name|match
condition|)
block|{
break|break;
block|}
name|numMatches
operator|+=
literal|1
expr_stmt|;
comment|/* 	 * Copy the portion of the source string before the match to the 	 * result variable. 	 */
name|Tcl_RegExpRange
argument_list|(
name|regExpr
argument_list|,
literal|0
argument_list|,
operator|&
name|start
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
name|src
operator|=
name|argPtr
index|[
literal|1
index|]
operator|+
operator|(
name|start
operator|-
name|string
operator|)
expr_stmt|;
name|c
operator|=
operator|*
name|src
expr_stmt|;
operator|*
name|src
operator|=
literal|0
expr_stmt|;
name|newValue
operator|=
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argPtr
index|[
literal|3
index|]
argument_list|,
name|argPtr
index|[
literal|1
index|]
operator|+
operator|(
name|p
operator|-
name|string
operator|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
operator|*
name|src
operator|=
name|c
expr_stmt|;
name|flags
operator|=
name|TCL_APPEND_VALUE
expr_stmt|;
if|if
condition|(
name|newValue
operator|==
name|NULL
condition|)
block|{
name|cantSet
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't set variable \""
argument_list|,
name|argPtr
index|[
literal|3
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Append the subSpec argument to the variable, making appropriate 	 * substitutions.  This code is a bit hairy because of the backslash 	 * conventions and because the code saves up ranges of characters in 	 * subSpec to reduce the number of calls to Tcl_SetVar. 	 */
for|for
control|(
name|src
operator|=
name|firstChar
operator|=
name|argPtr
index|[
literal|2
index|]
operator|,
name|c
operator|=
operator|*
name|src
init|;
name|c
operator|!=
literal|0
condition|;
name|src
operator|++
operator|,
name|c
operator|=
operator|*
name|src
control|)
block|{
name|int
name|index
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'&'
condition|)
block|{
name|index
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|src
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|index
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'\\'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'&'
operator|)
condition|)
block|{
operator|*
name|src
operator|=
name|c
expr_stmt|;
name|src
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|newValue
operator|=
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argPtr
index|[
literal|3
index|]
argument_list|,
name|firstChar
argument_list|,
name|TCL_APPEND_VALUE
argument_list|)
expr_stmt|;
operator|*
name|src
operator|=
literal|'\\'
expr_stmt|;
name|src
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|newValue
operator|==
name|NULL
condition|)
block|{
goto|goto
name|cantSet
goto|;
block|}
name|firstChar
operator|=
name|src
operator|+
literal|2
expr_stmt|;
name|src
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
block|{
continue|continue;
block|}
block|}
else|else
block|{
continue|continue;
block|}
if|if
condition|(
name|firstChar
operator|!=
name|src
condition|)
block|{
name|c
operator|=
operator|*
name|src
expr_stmt|;
operator|*
name|src
operator|=
literal|0
expr_stmt|;
name|newValue
operator|=
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argPtr
index|[
literal|3
index|]
argument_list|,
name|firstChar
argument_list|,
name|TCL_APPEND_VALUE
argument_list|)
expr_stmt|;
operator|*
name|src
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|newValue
operator|==
name|NULL
condition|)
block|{
goto|goto
name|cantSet
goto|;
block|}
block|}
name|Tcl_RegExpRange
argument_list|(
name|regExpr
argument_list|,
name|index
argument_list|,
operator|&
name|subStart
argument_list|,
operator|&
name|subEnd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|subStart
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|subEnd
operator|!=
name|NULL
operator|)
condition|)
block|{
name|char
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|,
name|saved
decl_stmt|;
name|first
operator|=
name|argPtr
index|[
literal|1
index|]
operator|+
operator|(
name|subStart
operator|-
name|string
operator|)
expr_stmt|;
name|last
operator|=
name|argPtr
index|[
literal|1
index|]
operator|+
operator|(
name|subEnd
operator|-
name|string
operator|)
expr_stmt|;
name|saved
operator|=
operator|*
name|last
expr_stmt|;
operator|*
name|last
operator|=
literal|0
expr_stmt|;
name|newValue
operator|=
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argPtr
index|[
literal|3
index|]
argument_list|,
name|first
argument_list|,
name|TCL_APPEND_VALUE
argument_list|)
expr_stmt|;
operator|*
name|last
operator|=
name|saved
expr_stmt|;
if|if
condition|(
name|newValue
operator|==
name|NULL
condition|)
block|{
goto|goto
name|cantSet
goto|;
block|}
block|}
if|if
condition|(
operator|*
name|src
operator|==
literal|'\\'
condition|)
block|{
name|src
operator|++
expr_stmt|;
block|}
name|firstChar
operator|=
name|src
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|firstChar
operator|!=
name|src
condition|)
block|{
if|if
condition|(
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argPtr
index|[
literal|3
index|]
argument_list|,
name|firstChar
argument_list|,
name|TCL_APPEND_VALUE
argument_list|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|cantSet
goto|;
block|}
block|}
if|if
condition|(
name|end
operator|==
name|p
condition|)
block|{
name|char
name|tmp
index|[
literal|2
index|]
decl_stmt|;
comment|/* 	     * Always consume at least one character of the input string 	     * in order to prevent infinite loops. 	     */
name|tmp
index|[
literal|0
index|]
operator|=
name|argPtr
index|[
literal|1
index|]
index|[
name|p
operator|-
name|string
index|]
expr_stmt|;
name|tmp
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|newValue
operator|=
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argPtr
index|[
literal|3
index|]
argument_list|,
name|tmp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|newValue
operator|==
name|NULL
condition|)
block|{
goto|goto
name|cantSet
goto|;
block|}
name|p
operator|=
name|end
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|end
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|all
condition|)
block|{
break|break;
block|}
block|}
comment|/*      * Copy the portion of the source string after the last match to the      * result variable.      */
if|if
condition|(
operator|(
operator|*
name|p
operator|!=
literal|0
operator|)
operator|||
operator|(
name|numMatches
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argPtr
index|[
literal|3
index|]
argument_list|,
name|argPtr
index|[
literal|1
index|]
operator|+
operator|(
name|p
operator|-
name|string
operator|)
argument_list|,
name|flags
argument_list|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|cantSet
goto|;
block|}
block|}
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"%d"
argument_list|,
name|numMatches
argument_list|)
expr_stmt|;
name|code
operator|=
name|TCL_OK
expr_stmt|;
name|done
label|:
if|if
condition|(
name|noCase
condition|)
block|{
name|Tcl_DStringFree
argument_list|(
operator|&
name|stringDString
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|patternDString
argument_list|)
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_RenameCmd --  *  *	This procedure is invoked to process the "rename" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_RenameCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
specifier|register
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|int
name|new
decl_stmt|;
name|char
modifier|*
name|srcName
decl_stmt|,
modifier|*
name|dstName
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" oldName newName\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|Tcl_DeleteCommand
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"can't delete \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": command doesn't exist"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
name|srcName
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|dstName
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|commandTable
argument_list|,
name|dstName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"can't rename to \""
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"\": command already exists"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * The code below was added in 11/95 to preserve backwards compatibility      * when "tkerror" was renamed "bgerror":  we guarantee that the hash      * table entries for both commands refer to a single shared Command      * structure.  This code should eventually become unnecessary.      */
if|if
condition|(
operator|(
name|srcName
index|[
literal|0
index|]
operator|==
literal|'t'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|srcName
argument_list|,
literal|"tkerror"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|srcName
operator|=
literal|"bgerror"
expr_stmt|;
block|}
name|dstName
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|dstName
index|[
literal|0
index|]
operator|==
literal|'t'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|dstName
argument_list|,
literal|"tkerror"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|dstName
operator|=
literal|"bgerror"
expr_stmt|;
block|}
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|commandTable
argument_list|,
name|srcName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"can't rename \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": command doesn't exist"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
comment|/*      * Prevent formation of alias loops through renaming.      */
if|if
condition|(
name|TclPreventAliasLoop
argument_list|(
name|interp
argument_list|,
name|interp
argument_list|,
name|dstName
argument_list|,
name|cmdPtr
operator|->
name|proc
argument_list|,
name|cmdPtr
operator|->
name|clientData
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_DeleteHashEntry
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|commandTable
argument_list|,
name|dstName
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
name|cmdPtr
argument_list|)
expr_stmt|;
name|cmdPtr
operator|->
name|hPtr
operator|=
name|hPtr
expr_stmt|;
comment|/*      * The code below provides more backwards compatibility for the      * "tkerror" => "bgerror" renaming.  As with the other compatibility      * code above, it should eventually be removed.      */
if|if
condition|(
operator|(
name|dstName
index|[
literal|0
index|]
operator|==
literal|'b'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|dstName
argument_list|,
literal|"bgerror"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 	 * The destination command is "bgerror";  create a "tkerror" 	 * command that shares the same Command structure. 	 */
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|commandTable
argument_list|,
literal|"tkerror"
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
name|cmdPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|srcName
index|[
literal|0
index|]
operator|==
literal|'b'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|srcName
argument_list|,
literal|"bgerror"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 	 * The source command is "bgerror":  delete the hash table 	 * entry for "tkerror" if it exists. 	 */
name|Tcl_DeleteHashEntry
argument_list|(
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|commandTable
argument_list|,
literal|"tkerror"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ReturnCmd --  *  *	This procedure is invoked to process the "return" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_ReturnCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|int
name|c
decl_stmt|,
name|code
decl_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|errorInfo
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|iPtr
operator|->
name|errorInfo
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|errorInfo
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|iPtr
operator|->
name|errorCode
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|iPtr
operator|->
name|errorCode
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|errorCode
operator|=
name|NULL
expr_stmt|;
block|}
name|code
operator|=
name|TCL_OK
expr_stmt|;
for|for
control|(
name|argv
operator|++
operator|,
name|argc
operator|--
init|;
name|argc
operator|>
literal|1
condition|;
name|argv
operator|+=
literal|2
operator|,
name|argc
operator|-=
literal|2
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"-code"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'o'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"ok"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|code
operator|=
name|TCL_OK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"error"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'r'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"return"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|code
operator|=
name|TCL_RETURN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'b'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"break"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|code
operator|=
name|TCL_BREAK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'c'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"continue"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|code
operator|=
name|TCL_CONTINUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|code
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad completion code \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": must be ok, error, return, break, "
argument_list|,
literal|"continue, or an integer"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"-errorinfo"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|iPtr
operator|->
name|errorInfo
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|iPtr
operator|->
name|errorInfo
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"-errorcode"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|iPtr
operator|->
name|errorCode
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|iPtr
operator|->
name|errorCode
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|": must be -code, -errorcode, or -errorinfo"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
name|iPtr
operator|->
name|returnCode
operator|=
name|code
expr_stmt|;
return|return
name|TCL_RETURN
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ScanCmd --  *  *	This procedure is invoked to process the "scan" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_ScanCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
define|#
directive|define
name|MAX_FIELDS
value|20
typedef|typedef
struct|struct
block|{
name|char
name|fmt
decl_stmt|;
comment|/* Format for field. */
name|int
name|size
decl_stmt|;
comment|/* How many bytes to allow for 					 * field. */
name|char
modifier|*
name|location
decl_stmt|;
comment|/* Where field will be stored. */
block|}
name|Field
typedef|;
name|Field
name|fields
index|[
name|MAX_FIELDS
index|]
decl_stmt|;
comment|/* Info about all the fields in the 					 * format string. */
specifier|register
name|Field
modifier|*
name|curField
decl_stmt|;
name|int
name|numFields
init|=
literal|0
decl_stmt|;
comment|/* Number of fields actually 					 * specified. */
name|int
name|suppress
decl_stmt|;
comment|/* Current field is assignment- 					 * suppressed. */
name|int
name|totalSize
init|=
literal|0
decl_stmt|;
comment|/* Number of bytes needed to store 					 * all results combined. */
name|char
modifier|*
name|results
decl_stmt|;
comment|/* Where scanned output goes. 					 * Malloced; NULL means not allocated 					 * yet. */
name|int
name|numScanned
decl_stmt|;
comment|/* sscanf's result. */
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|widthSpecified
decl_stmt|,
name|length
decl_stmt|,
name|code
decl_stmt|;
comment|/*      * The variables below are used to hold a copy of the format      * string, so that we can replace format specifiers like "%f"      * and "%F" with specifiers like "%lf"      */
define|#
directive|define
name|STATIC_SIZE
value|5
name|char
name|copyBuf
index|[
name|STATIC_SIZE
index|]
decl_stmt|,
modifier|*
name|fmtCopy
decl_stmt|;
specifier|register
name|char
modifier|*
name|dst
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" string format ?varName varName ...?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * This procedure operates in four stages:      * 1. Scan the format string, collecting information about each field.      * 2. Allocate an array to hold all of the scanned fields.      * 3. Call sscanf to do all the dirty work, and have it store the      *    parsed fields in the array.      * 4. Pick off the fields from the array and assign them to variables.      */
name|code
operator|=
name|TCL_OK
expr_stmt|;
name|results
operator|=
name|NULL
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|length
operator|<
name|STATIC_SIZE
condition|)
block|{
name|fmtCopy
operator|=
name|copyBuf
expr_stmt|;
block|}
else|else
block|{
name|fmtCopy
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|length
argument_list|)
expr_stmt|;
block|}
name|dst
operator|=
name|fmtCopy
expr_stmt|;
for|for
control|(
name|fmt
operator|=
name|argv
index|[
literal|2
index|]
init|;
operator|*
name|fmt
operator|!=
literal|0
condition|;
name|fmt
operator|++
control|)
block|{
operator|*
name|dst
operator|=
operator|*
name|fmt
expr_stmt|;
name|dst
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|fmt
operator|!=
literal|'%'
condition|)
block|{
continue|continue;
block|}
name|fmt
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'%'
condition|)
block|{
operator|*
name|dst
operator|=
operator|*
name|fmt
expr_stmt|;
name|dst
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'*'
condition|)
block|{
name|suppress
operator|=
literal|1
expr_stmt|;
operator|*
name|dst
operator|=
operator|*
name|fmt
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
else|else
block|{
name|suppress
operator|=
literal|0
expr_stmt|;
block|}
name|widthSpecified
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|fmt
argument_list|)
argument_list|)
condition|)
block|{
name|widthSpecified
operator|=
literal|1
expr_stmt|;
operator|*
name|dst
operator|=
operator|*
name|fmt
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|fmt
operator|==
literal|'l'
operator|)
operator|||
operator|(
operator|*
name|fmt
operator|==
literal|'h'
operator|)
operator|||
operator|(
operator|*
name|fmt
operator|==
literal|'L'
operator|)
condition|)
block|{
name|fmt
operator|++
expr_stmt|;
block|}
operator|*
name|dst
operator|=
operator|*
name|fmt
expr_stmt|;
name|dst
operator|++
expr_stmt|;
if|if
condition|(
name|suppress
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|numFields
operator|==
name|MAX_FIELDS
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"too many fields to scan"
expr_stmt|;
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|curField
operator|=
operator|&
name|fields
index|[
name|numFields
index|]
expr_stmt|;
name|numFields
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|fmt
condition|)
block|{
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
case|case
literal|'o'
case|:
case|case
literal|'x'
case|:
name|curField
operator|->
name|fmt
operator|=
literal|'d'
expr_stmt|;
name|curField
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|curField
operator|->
name|fmt
operator|=
literal|'u'
expr_stmt|;
name|curField
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|curField
operator|->
name|fmt
operator|=
literal|'s'
expr_stmt|;
name|curField
operator|->
name|size
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|widthSpecified
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"field width may not be specified in %c conversion"
expr_stmt|;
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|curField
operator|->
name|fmt
operator|=
literal|'c'
expr_stmt|;
name|curField
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
name|dst
index|[
operator|-
literal|1
index|]
operator|=
literal|'l'
expr_stmt|;
name|dst
index|[
literal|0
index|]
operator|=
literal|'f'
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|curField
operator|->
name|fmt
operator|=
literal|'f'
expr_stmt|;
name|curField
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
name|double
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|curField
operator|->
name|fmt
operator|=
literal|'s'
expr_stmt|;
name|curField
operator|->
name|size
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
do|do
block|{
name|fmt
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|fmt
operator|==
literal|0
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"unmatched [ in format string"
expr_stmt|;
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
operator|*
name|dst
operator|=
operator|*
name|fmt
expr_stmt|;
name|dst
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|fmt
operator|!=
literal|']'
condition|)
do|;
break|break;
default|default:
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"bad scan conversion character \"%c\""
argument_list|,
operator|*
name|fmt
argument_list|)
expr_stmt|;
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|curField
operator|->
name|size
operator|=
name|TCL_ALIGN
argument_list|(
name|curField
operator|->
name|size
argument_list|)
expr_stmt|;
name|totalSize
operator|+=
name|curField
operator|->
name|size
expr_stmt|;
block|}
operator|*
name|dst
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|numFields
operator|!=
operator|(
name|argc
operator|-
literal|3
operator|)
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"different numbers of variable names and field specifiers"
expr_stmt|;
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*      * Step 2:      */
name|results
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|totalSize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|totalSize
operator|=
literal|0
operator|,
name|curField
operator|=
name|fields
init|;
name|i
operator|<
name|numFields
condition|;
name|i
operator|++
operator|,
name|curField
operator|++
control|)
block|{
name|curField
operator|->
name|location
operator|=
name|results
operator|+
name|totalSize
expr_stmt|;
name|totalSize
operator|+=
name|curField
operator|->
name|size
expr_stmt|;
block|}
comment|/*      * Fill in the remaining fields with NULL;  the only purpose of      * this is to keep some memory analyzers, like Purify, from      * complaining.      */
for|for
control|(
init|;
name|i
operator|<
name|MAX_FIELDS
condition|;
name|i
operator|++
operator|,
name|curField
operator|++
control|)
block|{
name|curField
operator|->
name|location
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*      * Step 3:      */
name|numScanned
operator|=
name|sscanf
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|fmtCopy
argument_list|,
name|fields
index|[
literal|0
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|1
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|2
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|3
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|4
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|5
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|6
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|7
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|8
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|9
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|10
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|11
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|12
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|13
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|14
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|15
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|16
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|17
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|18
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|19
index|]
operator|.
name|location
argument_list|)
expr_stmt|;
comment|/*      * Step 4:      */
if|if
condition|(
name|numScanned
operator|<
name|numFields
condition|)
block|{
name|numFields
operator|=
name|numScanned
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|curField
operator|=
name|fields
init|;
name|i
operator|<
name|numFields
condition|;
name|i
operator|++
operator|,
name|curField
operator|++
control|)
block|{
switch|switch
condition|(
name|curField
operator|->
name|fmt
condition|)
block|{
name|char
name|string
index|[
name|TCL_DOUBLE_SPACE
index|]
decl_stmt|;
case|case
literal|'d'
case|:
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%d"
argument_list|,
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|curField
operator|->
name|location
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
operator|+
literal|3
index|]
argument_list|,
name|string
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|storeError
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't set variable \""
argument_list|,
name|argv
index|[
name|i
operator|+
literal|3
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
case|case
literal|'u'
case|:
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%u"
argument_list|,
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|curField
operator|->
name|location
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
operator|+
literal|3
index|]
argument_list|,
name|string
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|storeError
goto|;
block|}
break|break;
case|case
literal|'c'
case|:
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%d"
argument_list|,
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|curField
operator|->
name|location
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
operator|+
literal|3
index|]
argument_list|,
name|string
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|storeError
goto|;
block|}
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
operator|+
literal|3
index|]
argument_list|,
name|curField
operator|->
name|location
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|storeError
goto|;
block|}
break|break;
case|case
literal|'f'
case|:
name|Tcl_PrintDouble
argument_list|(
name|interp
argument_list|,
operator|*
operator|(
operator|(
name|double
operator|*
operator|)
name|curField
operator|->
name|location
operator|)
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
operator|+
literal|3
index|]
argument_list|,
name|string
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|storeError
goto|;
block|}
break|break;
block|}
block|}
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"%d"
argument_list|,
name|numScanned
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|results
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|results
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fmtCopy
operator|!=
name|copyBuf
condition|)
block|{
name|ckfree
argument_list|(
name|fmtCopy
argument_list|)
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SourceCmd --  *  *	This procedure is invoked to process the "source" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_SourceCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" fileName\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|Tcl_EvalFile
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SplitCmd --  *  *	This procedure is invoked to process the "split" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_SplitCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|char
modifier|*
name|splitChars
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|char
modifier|*
name|elementStart
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
name|splitChars
operator|=
literal|" \n\t\r"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
block|{
name|splitChars
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" string ?splitChars?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Handle the special case of splitting on every character.      */
if|if
condition|(
operator|*
name|splitChars
operator|==
literal|0
condition|)
block|{
name|char
name|string
index|[
literal|2
index|]
decl_stmt|;
name|string
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|argv
index|[
literal|1
index|]
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
name|string
index|[
literal|0
index|]
operator|=
operator|*
name|p
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
comment|/*      * Normal case: split on any of a given set of characters.      * Discard instances of the split characters.      */
for|for
control|(
name|p
operator|=
name|elementStart
operator|=
name|argv
index|[
literal|1
index|]
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
name|char
name|c
init|=
operator|*
name|p
decl_stmt|;
for|for
control|(
name|p2
operator|=
name|splitChars
init|;
operator|*
name|p2
operator|!=
literal|0
condition|;
name|p2
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p2
operator|==
name|c
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|elementStart
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|elementStart
operator|=
name|p
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|p
operator|!=
name|argv
index|[
literal|1
index|]
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|elementStart
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_StringCmd --  *  *	This procedure is invoked to process the "string" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_StringCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|size_t
name|length
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|match
decl_stmt|,
name|c
decl_stmt|,
name|first
decl_stmt|;
name|int
name|left
init|=
literal|0
decl_stmt|,
name|right
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" option arg ?arg ...?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|c
operator|=
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'c'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"compare"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" compare string1 string2\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|match
operator|=
name|strcmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|>
literal|0
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"1"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|match
operator|<
literal|0
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"-1"
expr_stmt|;
block|}
else|else
block|{
name|interp
operator|->
name|result
operator|=
literal|"0"
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'f'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"first"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" first string1 string2\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|first
operator|=
literal|1
expr_stmt|;
name|firstLast
label|:
name|match
operator|=
operator|-
literal|1
expr_stmt|;
name|c
operator|=
operator|*
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|argv
index|[
literal|3
index|]
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
name|c
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
name|p
argument_list|,
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|match
operator|=
name|p
operator|-
name|argv
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
break|break;
block|}
block|}
block|}
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"%d"
argument_list|,
name|match
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'i'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"index"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|int
name|index
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" index string charIndex\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
operator|&
name|index
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|index
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|index
operator|<
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
operator|)
condition|)
block|{
name|interp
operator|->
name|result
index|[
literal|0
index|]
operator|=
name|argv
index|[
literal|2
index|]
index|[
name|index
index|]
expr_stmt|;
name|interp
operator|->
name|result
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'l'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"last"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|2
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" last string1 string2\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|first
operator|=
literal|0
expr_stmt|;
goto|goto
name|firstLast
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'l'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"length"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|2
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" length string\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"%d"
argument_list|,
name|strlen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'m'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"match"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" match pattern string\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_StringMatch
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"1"
expr_stmt|;
block|}
else|else
block|{
name|interp
operator|->
name|result
operator|=
literal|"0"
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'r'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"range"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|int
name|first
decl_stmt|,
name|last
decl_stmt|,
name|stringLength
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|5
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" range string first last\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|stringLength
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
operator|&
name|first
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|argv
index|[
literal|4
index|]
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|,
literal|"end"
argument_list|,
name|strlen
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|last
operator|=
name|stringLength
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
operator|&
name|last
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"expected integer or \"end\" but got \""
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
if|if
condition|(
name|first
operator|<
literal|0
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|>=
name|stringLength
condition|)
block|{
name|last
operator|=
name|stringLength
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|>=
name|first
condition|)
block|{
name|char
name|saved
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|argv
index|[
literal|2
index|]
operator|+
name|last
operator|+
literal|1
expr_stmt|;
name|saved
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
operator|+
name|first
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|saved
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'t'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"tolower"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|3
operator|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" tolower string\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|interp
operator|->
name|result
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isupper
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|p
operator|=
operator|(
name|char
operator|)
name|tolower
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'t'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"toupper"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|3
operator|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" toupper string\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|interp
operator|->
name|result
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|islower
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|p
operator|=
operator|(
name|char
operator|)
name|toupper
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'t'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"trim"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|==
literal|4
operator|)
condition|)
block|{
name|char
modifier|*
name|trimChars
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|checkPtr
decl_stmt|;
name|left
operator|=
name|right
operator|=
literal|1
expr_stmt|;
name|trim
label|:
if|if
condition|(
name|argc
operator|==
literal|4
condition|)
block|{
name|trimChars
operator|=
name|argv
index|[
literal|3
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
block|{
name|trimChars
operator|=
literal|" \t\n\r"
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" "
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|" string ?chars?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|p
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|left
condition|)
block|{
for|for
control|(
name|c
operator|=
operator|*
name|p
init|;
name|c
operator|!=
literal|0
condition|;
name|p
operator|++
operator|,
name|c
operator|=
operator|*
name|p
control|)
block|{
for|for
control|(
name|checkPtr
operator|=
name|trimChars
init|;
operator|*
name|checkPtr
operator|!=
name|c
condition|;
name|checkPtr
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|checkPtr
operator|==
literal|0
condition|)
block|{
goto|goto
name|doneLeft
goto|;
block|}
block|}
block|}
block|}
name|doneLeft
label|:
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|p
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|right
condition|)
block|{
name|char
modifier|*
name|donePtr
decl_stmt|;
name|p
operator|=
name|interp
operator|->
name|result
operator|+
name|strlen
argument_list|(
name|interp
operator|->
name|result
argument_list|)
operator|-
literal|1
expr_stmt|;
name|donePtr
operator|=
operator|&
name|interp
operator|->
name|result
index|[
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|c
operator|=
operator|*
name|p
init|;
name|p
operator|!=
name|donePtr
condition|;
name|p
operator|--
operator|,
name|c
operator|=
operator|*
name|p
control|)
block|{
for|for
control|(
name|checkPtr
operator|=
name|trimChars
init|;
operator|*
name|checkPtr
operator|!=
name|c
condition|;
name|checkPtr
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|checkPtr
operator|==
literal|0
condition|)
block|{
goto|goto
name|doneRight
goto|;
block|}
block|}
block|}
name|doneRight
label|:
name|p
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'t'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"trimleft"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>
literal|4
operator|)
condition|)
block|{
name|left
operator|=
literal|1
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
literal|"trimleft"
expr_stmt|;
goto|goto
name|trim
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'t'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"trimright"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>
literal|4
operator|)
condition|)
block|{
name|right
operator|=
literal|1
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
literal|"trimright"
expr_stmt|;
goto|goto
name|trim
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'w'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"wordend"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>
literal|4
operator|)
condition|)
block|{
name|int
name|length
decl_stmt|,
name|index
decl_stmt|,
name|cur
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" "
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|" string index\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|string
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
operator|&
name|index
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|length
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
name|index
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|>=
name|length
condition|)
block|{
name|cur
operator|=
name|length
expr_stmt|;
goto|goto
name|wordendDone
goto|;
block|}
for|for
control|(
name|cur
operator|=
name|index
init|;
name|cur
operator|<
name|length
condition|;
name|cur
operator|++
control|)
block|{
name|c
operator|=
name|UCHAR
argument_list|(
name|string
index|[
name|cur
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|c
operator|!=
literal|'_'
operator|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|cur
operator|==
name|index
condition|)
block|{
name|cur
operator|=
name|index
operator|+
literal|1
expr_stmt|;
block|}
name|wordendDone
label|:
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"%d"
argument_list|,
name|cur
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'w'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"wordstart"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>
literal|4
operator|)
condition|)
block|{
name|int
name|length
decl_stmt|,
name|index
decl_stmt|,
name|cur
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" "
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|" string index\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|string
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
operator|&
name|index
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|length
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|length
condition|)
block|{
name|index
operator|=
name|length
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|<=
literal|0
condition|)
block|{
name|cur
operator|=
literal|0
expr_stmt|;
goto|goto
name|wordstartDone
goto|;
block|}
for|for
control|(
name|cur
operator|=
name|index
init|;
name|cur
operator|>=
literal|0
condition|;
name|cur
operator|--
control|)
block|{
name|c
operator|=
name|UCHAR
argument_list|(
name|string
index|[
name|cur
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|c
operator|!=
literal|'_'
operator|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|cur
operator|!=
name|index
condition|)
block|{
name|cur
operator|+=
literal|1
expr_stmt|;
block|}
name|wordstartDone
label|:
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"%d"
argument_list|,
name|cur
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": should be compare, first, index, last, length, match, "
argument_list|,
literal|"range, tolower, toupper, trim, trimleft, trimright, "
argument_list|,
literal|"wordend, or wordstart"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SubstCmd --  *  *	This procedure is invoked to process the "subst" Tcl command.  *	See the user documentation for details on what it does.  This  *	command is an almost direct copy of an implementation by  *	Andrew Payne.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_SubstCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Tcl_DString
name|result
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|old
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|int
name|code
decl_stmt|,
name|count
decl_stmt|,
name|doVars
decl_stmt|,
name|doCmds
decl_stmt|,
name|doBackslashes
decl_stmt|,
name|i
decl_stmt|;
name|size_t
name|length
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/*      * Parse command-line options.      */
name|doVars
operator|=
name|doCmds
operator|=
name|doBackslashes
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|(
name|argc
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'-'
condition|)
block|{
break|break;
block|}
name|length
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|4
condition|)
block|{
name|badSwitch
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad switch \""
argument_list|,
name|p
argument_list|,
literal|"\": must be -nobackslashes, -nocommands, "
argument_list|,
literal|"or -novariables"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|p
index|[
literal|3
index|]
operator|==
literal|'b'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"-nobackslashes"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|doBackslashes
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p
index|[
literal|3
index|]
operator|==
literal|'c'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"-nocommands"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|doCmds
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p
index|[
literal|3
index|]
operator|==
literal|'v'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"-novariables"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|doVars
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|badSwitch
goto|;
block|}
block|}
if|if
condition|(
name|i
operator|!=
operator|(
name|argc
operator|-
literal|1
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" ?-nobackslashes? ?-nocommands? ?-novariables? string\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Scan through the string one character at a time, performing      * command, variable, and backslash substitutions.      */
name|Tcl_DStringInit
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|old
operator|=
name|p
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
name|doBackslashes
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|old
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|result
argument_list|,
name|old
argument_list|,
name|p
operator|-
name|old
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|Tcl_Backslash
argument_list|(
name|p
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|result
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|+=
name|count
expr_stmt|;
name|old
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|p
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'$'
case|:
if|if
condition|(
name|doVars
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|old
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|result
argument_list|,
name|old
argument_list|,
name|p
operator|-
name|old
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|Tcl_ParseVar
argument_list|(
name|interp
argument_list|,
name|p
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
name|Tcl_DStringFree
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_DStringAppend
argument_list|(
operator|&
name|result
argument_list|,
name|value
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|old
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|p
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'['
case|:
if|if
condition|(
name|doCmds
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|old
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|result
argument_list|,
name|old
argument_list|,
name|p
operator|-
name|old
argument_list|)
expr_stmt|;
block|}
name|iPtr
operator|->
name|evalFlags
operator|=
name|TCL_BRACKET_TERM
expr_stmt|;
name|code
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TCL_ERROR
condition|)
block|{
name|Tcl_DStringFree
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
name|old
operator|=
name|p
operator|=
name|iPtr
operator|->
name|termPtr
operator|+
literal|1
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|result
argument_list|,
name|iPtr
operator|->
name|result
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|++
expr_stmt|;
block|}
break|break;
default|default:
name|p
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|p
operator|!=
name|old
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|result
argument_list|,
name|old
argument_list|,
name|p
operator|-
name|old
argument_list|)
expr_stmt|;
block|}
name|Tcl_DStringResult
argument_list|(
name|interp
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SwitchCmd --  *  *	This procedure is invoked to process the "switch" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_SwitchCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
define|#
directive|define
name|EXACT
value|0
define|#
directive|define
name|GLOB
value|1
define|#
directive|define
name|REGEXP
value|2
name|int
name|i
decl_stmt|,
name|code
decl_stmt|,
name|mode
decl_stmt|,
name|matched
decl_stmt|;
name|int
name|body
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|switchArgc
decl_stmt|,
name|splitArgs
decl_stmt|;
name|char
modifier|*
modifier|*
name|switchArgv
decl_stmt|;
name|switchArgc
operator|=
name|argc
operator|-
literal|1
expr_stmt|;
name|switchArgv
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
name|mode
operator|=
name|EXACT
expr_stmt|;
while|while
condition|(
operator|(
name|switchArgc
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|*
name|switchArgv
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|switchArgv
argument_list|,
literal|"-exact"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mode
operator|=
name|EXACT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|switchArgv
argument_list|,
literal|"-glob"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mode
operator|=
name|GLOB
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|switchArgv
argument_list|,
literal|"-regexp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mode
operator|=
name|REGEXP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|switchArgv
argument_list|,
literal|"--"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|switchArgc
operator|--
expr_stmt|;
name|switchArgv
operator|++
expr_stmt|;
break|break;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|switchArgv
index|[
literal|0
index|]
argument_list|,
literal|"\": should be -exact, -glob, -regexp, or --"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|switchArgc
operator|--
expr_stmt|;
name|switchArgv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|switchArgc
operator|<
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" ?switches? string pattern body ... ?default body?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|string
operator|=
operator|*
name|switchArgv
expr_stmt|;
name|switchArgc
operator|--
expr_stmt|;
name|switchArgv
operator|++
expr_stmt|;
comment|/*      * If all of the pattern/command pairs are lumped into a single      * argument, split them out again.      */
name|splitArgs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|switchArgc
operator|==
literal|1
condition|)
block|{
name|code
operator|=
name|Tcl_SplitList
argument_list|(
name|interp
argument_list|,
name|switchArgv
index|[
literal|0
index|]
argument_list|,
operator|&
name|switchArgc
argument_list|,
operator|&
name|switchArgv
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|code
return|;
block|}
name|splitArgs
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|switchArgc
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|i
operator|==
operator|(
name|switchArgc
operator|-
literal|1
operator|)
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"extra switch pattern with no body"
expr_stmt|;
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * See if the pattern matches the string. 	 */
name|matched
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|switchArgv
index|[
name|i
index|]
operator|==
literal|'d'
operator|)
operator|&&
operator|(
name|i
operator|==
name|switchArgc
operator|-
literal|2
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|switchArgv
index|[
name|i
index|]
argument_list|,
literal|"default"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|matched
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|EXACT
case|:
name|matched
operator|=
operator|(
name|strcmp
argument_list|(
name|string
argument_list|,
name|switchArgv
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|GLOB
case|:
name|matched
operator|=
name|Tcl_StringMatch
argument_list|(
name|string
argument_list|,
name|switchArgv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP
case|:
name|matched
operator|=
name|Tcl_RegExpMatch
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
name|switchArgv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|matched
operator|<
literal|0
condition|)
block|{
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|matched
condition|)
block|{
continue|continue;
block|}
comment|/* 	 * We've got a match.  Find a body to execute, skipping bodies 	 * that are "-". 	 */
for|for
control|(
name|body
operator|=
name|i
operator|+
literal|1
init|;
condition|;
name|body
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|body
operator|>=
name|switchArgc
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"no body specified for pattern \""
argument_list|,
name|switchArgv
index|[
name|i
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
operator|(
name|switchArgv
index|[
name|body
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|)
operator|||
operator|(
name|switchArgv
index|[
name|body
index|]
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
break|break;
block|}
block|}
name|code
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|switchArgv
index|[
name|body
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TCL_ERROR
condition|)
block|{
name|char
name|msg
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n    (\"%.50s\" arm line %d)"
argument_list|,
name|switchArgv
index|[
name|i
index|]
argument_list|,
name|interp
operator|->
name|errorLine
argument_list|)
expr_stmt|;
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
goto|goto
name|cleanup
goto|;
block|}
comment|/*      * Nothing matched:  return nothing.      */
name|code
operator|=
name|TCL_OK
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|splitArgs
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|switchArgv
argument_list|)
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_TimeCmd --  *  *	This procedure is invoked to process the "time" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_TimeCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|count
decl_stmt|,
name|i
decl_stmt|,
name|result
decl_stmt|;
name|double
name|timePer
decl_stmt|;
name|Tcl_Time
name|start
decl_stmt|,
name|stop
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|count
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" command ?count?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|TclpGetTime
argument_list|(
operator|&
name|start
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|count
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|result
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|char
name|msg
index|[
literal|60
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n    (\"time\" body line %d)"
argument_list|,
name|interp
operator|->
name|errorLine
argument_list|)
expr_stmt|;
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
name|TclpGetTime
argument_list|(
operator|&
name|stop
argument_list|)
expr_stmt|;
name|timePer
operator|=
operator|(
name|stop
operator|.
name|sec
operator|-
name|start
operator|.
name|sec
operator|)
operator|*
literal|1000000
operator|+
operator|(
name|stop
operator|.
name|usec
operator|-
name|start
operator|.
name|usec
operator|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"%.0f microseconds per iteration"
argument_list|,
operator|(
name|count
operator|<=
literal|0
operator|)
condition|?
literal|0
else|:
name|timePer
operator|/
name|count
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_TraceCmd --  *  *	This procedure is invoked to process the "trace" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_TraceCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|c
decl_stmt|;
name|size_t
name|length
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"too few args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" option [arg arg ...]\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|c
operator|=
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'a'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"variable"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|2
operator|)
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|length
decl_stmt|;
name|TraceVarInfo
modifier|*
name|tvarPtr
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|5
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" variable name ops command\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|flags
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|argv
index|[
literal|3
index|]
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'r'
condition|)
block|{
name|flags
operator||=
name|TCL_TRACE_READS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'w'
condition|)
block|{
name|flags
operator||=
name|TCL_TRACE_WRITES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'u'
condition|)
block|{
name|flags
operator||=
name|TCL_TRACE_UNSETS
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|badOps
goto|;
block|}
block|}
if|if
condition|(
name|flags
operator|==
literal|0
condition|)
block|{
goto|goto
name|badOps
goto|;
block|}
name|length
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|tvarPtr
operator|=
operator|(
name|TraceVarInfo
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|TraceVarInfo
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|tvarPtr
operator|->
name|command
argument_list|)
operator|+
name|length
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|tvarPtr
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|tvarPtr
operator|->
name|errMsg
operator|=
name|NULL
expr_stmt|;
name|tvarPtr
operator|->
name|length
operator|=
name|length
expr_stmt|;
name|flags
operator||=
name|TCL_TRACE_UNSETS
expr_stmt|;
name|strcpy
argument_list|(
name|tvarPtr
operator|->
name|command
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_TraceVar
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|flags
argument_list|,
name|TraceVarProc
argument_list|,
operator|(
name|ClientData
operator|)
name|tvarPtr
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tvarPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'d'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"vdelete"
argument_list|,
name|length
argument_list|)
operator|&&
operator|(
name|length
operator|>=
literal|2
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|length
decl_stmt|;
name|TraceVarInfo
modifier|*
name|tvarPtr
decl_stmt|;
name|ClientData
name|clientData
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|5
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" vdelete name ops command\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|flags
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|argv
index|[
literal|3
index|]
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'r'
condition|)
block|{
name|flags
operator||=
name|TCL_TRACE_READS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'w'
condition|)
block|{
name|flags
operator||=
name|TCL_TRACE_WRITES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'u'
condition|)
block|{
name|flags
operator||=
name|TCL_TRACE_UNSETS
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|badOps
goto|;
block|}
block|}
if|if
condition|(
name|flags
operator|==
literal|0
condition|)
block|{
goto|goto
name|badOps
goto|;
block|}
comment|/* 	 * Search through all of our traces on this variable to 	 * see if there's one with the given command.  If so, then 	 * delete the first one that matches. 	 */
name|length
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|clientData
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|clientData
operator|=
name|Tcl_VarTraceInfo
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
name|TraceVarProc
argument_list|,
name|clientData
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|tvarPtr
operator|=
operator|(
name|TraceVarInfo
operator|*
operator|)
name|clientData
expr_stmt|;
if|if
condition|(
operator|(
name|tvarPtr
operator|->
name|length
operator|==
name|length
operator|)
operator|&&
operator|(
name|tvarPtr
operator|->
name|flags
operator|==
name|flags
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|,
name|tvarPtr
operator|->
name|command
argument_list|,
operator|(
name|size_t
operator|)
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|Tcl_UntraceVar
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|flags
operator||
name|TCL_TRACE_UNSETS
argument_list|,
name|TraceVarProc
argument_list|,
name|clientData
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvarPtr
operator|->
name|errMsg
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|tvarPtr
operator|->
name|errMsg
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tvarPtr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'i'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"vinfo"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|2
operator|)
condition|)
block|{
name|ClientData
name|clientData
decl_stmt|;
name|char
name|ops
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|prefix
init|=
literal|"{"
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" vinfo name\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|clientData
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|clientData
operator|=
name|Tcl_VarTraceInfo
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
name|TraceVarProc
argument_list|,
name|clientData
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|TraceVarInfo
modifier|*
name|tvarPtr
init|=
operator|(
name|TraceVarInfo
operator|*
operator|)
name|clientData
decl_stmt|;
name|p
operator|=
name|ops
expr_stmt|;
if|if
condition|(
name|tvarPtr
operator|->
name|flags
operator|&
name|TCL_TRACE_READS
condition|)
block|{
operator|*
name|p
operator|=
literal|'r'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tvarPtr
operator|->
name|flags
operator|&
name|TCL_TRACE_WRITES
condition|)
block|{
operator|*
name|p
operator|=
literal|'w'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tvarPtr
operator|->
name|flags
operator|&
name|TCL_TRACE_UNSETS
condition|)
block|{
operator|*
name|p
operator|=
literal|'u'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|prefix
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|ops
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|tvarPtr
operator|->
name|command
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"}"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|prefix
operator|=
literal|" {"
expr_stmt|;
block|}
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": should be variable, vdelete, or vinfo"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
name|badOps
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad operations \""
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
literal|"\": should be one or more of rwu"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TraceVarProc --  *  *	This procedure is called to handle variable accesses that have  *	been traced using the "trace" command.  *  * Results:  *	Normally returns NULL.  If the trace command returns an error,  *	then this procedure returns an error string.  *  * Side effects:  *	Depends on the command associated with the trace.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|TraceVarProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|name1
parameter_list|,
name|name2
parameter_list|,
name|flags
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Information about the variable trace. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter containing variable. */
name|char
modifier|*
name|name1
decl_stmt|;
comment|/* Name of variable or array. */
name|char
modifier|*
name|name2
decl_stmt|;
comment|/* Name of element within array;  NULL means 				 * scalar variable is being referenced. */
name|int
name|flags
decl_stmt|;
comment|/* OR-ed bits giving operation and other 				 * information. */
block|{
name|TraceVarInfo
modifier|*
name|tvarPtr
init|=
operator|(
name|TraceVarInfo
operator|*
operator|)
name|clientData
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|int
name|code
decl_stmt|;
name|Interp
name|dummy
decl_stmt|;
name|Tcl_DString
name|cmd
decl_stmt|;
name|result
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tvarPtr
operator|->
name|errMsg
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|tvarPtr
operator|->
name|errMsg
argument_list|)
expr_stmt|;
name|tvarPtr
operator|->
name|errMsg
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tvarPtr
operator|->
name|flags
operator|&
name|flags
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|TCL_INTERP_DESTROYED
operator|)
condition|)
block|{
comment|/* 	 * Generate a command to execute by appending list elements 	 * for the two variable names and the operation.  The five 	 * extra characters are for three space, the opcode character, 	 * and the terminating null. 	 */
if|if
condition|(
name|name2
operator|==
name|NULL
condition|)
block|{
name|name2
operator|=
literal|""
expr_stmt|;
block|}
name|Tcl_DStringInit
argument_list|(
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|cmd
argument_list|,
name|tvarPtr
operator|->
name|command
argument_list|,
name|tvarPtr
operator|->
name|length
argument_list|)
expr_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
operator|&
name|cmd
argument_list|,
name|name1
argument_list|)
expr_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
operator|&
name|cmd
argument_list|,
name|name2
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TCL_TRACE_READS
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|cmd
argument_list|,
literal|" r"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|TCL_TRACE_WRITES
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|cmd
argument_list|,
literal|" w"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|TCL_TRACE_UNSETS
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|cmd
argument_list|,
literal|" u"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Execute the command.  Be careful to save and restore the 	 * result from the interpreter used for the command. 	 */
if|if
condition|(
name|interp
operator|->
name|freeProc
operator|==
literal|0
condition|)
block|{
name|dummy
operator|.
name|freeProc
operator|=
operator|(
name|Tcl_FreeProc
operator|*
operator|)
literal|0
expr_stmt|;
name|dummy
operator|.
name|result
operator|=
literal|""
expr_stmt|;
name|Tcl_SetResult
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
operator|&
name|dummy
argument_list|,
name|interp
operator|->
name|result
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dummy
operator|.
name|freeProc
operator|=
name|interp
operator|->
name|freeProc
expr_stmt|;
name|dummy
operator|.
name|result
operator|=
name|interp
operator|->
name|result
expr_stmt|;
name|interp
operator|->
name|freeProc
operator|=
operator|(
name|Tcl_FreeProc
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|code
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|TCL_OK
condition|)
block|{
name|tvarPtr
operator|->
name|errMsg
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|interp
operator|->
name|result
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tvarPtr
operator|->
name|errMsg
argument_list|,
name|interp
operator|->
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
name|tvarPtr
operator|->
name|errMsg
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
comment|/* Must clear error state. */
block|}
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|dummy
operator|.
name|result
argument_list|,
operator|(
name|dummy
operator|.
name|freeProc
operator|==
literal|0
operator|)
condition|?
name|TCL_VOLATILE
else|:
name|dummy
operator|.
name|freeProc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|TCL_TRACE_DESTROYED
condition|)
block|{
name|result
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tvarPtr
operator|->
name|errMsg
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|tvarPtr
operator|->
name|errMsg
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tvarPtr
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_WhileCmd --  *  *	This procedure is invoked to process the "while" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_WhileCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|result
decl_stmt|,
name|value
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" test command\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|result
operator|=
name|Tcl_ExprBoolean
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
if|if
condition|(
operator|!
name|value
condition|)
block|{
break|break;
block|}
name|result
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|!=
name|TCL_OK
operator|)
operator|&&
operator|(
name|result
operator|!=
name|TCL_CONTINUE
operator|)
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|char
name|msg
index|[
literal|60
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n    (\"while\" body line %d)"
argument_list|,
name|interp
operator|->
name|errorLine
argument_list|)
expr_stmt|;
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|result
operator|==
name|TCL_BREAK
condition|)
block|{
name|result
operator|=
name|TCL_OK
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

end_unit

