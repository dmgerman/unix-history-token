begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclCmdMZ.c --  *  *	This file contains the top-level command routines for most of  *	the Tcl built-in commands whose names begin with the letters  *	M to Z.  It contains only commands in the generic core (i.e.  *	those that don't depend much upon UNIX facilities).  *  * Copyright (c) 1987-1993 The Regents of the University of California.  * Copyright (c) 1994-1997 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclCmdMZ.c 1.102 97/08/13 10:06:58  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_include
include|#
directive|include
file|"tclCompile.h"
end_include

begin_comment
comment|/*  * Structure used to hold information about variable traces:  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|flags
decl_stmt|;
comment|/* Operations for which Tcl command is 				 * to be invoked. */
name|char
modifier|*
name|errMsg
decl_stmt|;
comment|/* Error message returned from Tcl command, 				 * or NULL.  Malloc'ed. */
name|int
name|length
decl_stmt|;
comment|/* Number of non-NULL chars. in command. */
name|char
name|command
index|[
literal|4
index|]
decl_stmt|;
comment|/* Space for Tcl command to invoke.  Actual 				 * size will be as large as necessary to 				 * hold command.  This field must be the 				 * last in the structure, so that it can 				 * be larger than 4 bytes. */
block|}
name|TraceVarInfo
typedef|;
end_typedef

begin_comment
comment|/*  * Forward declarations for procedures defined in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|TraceVarProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|name1
operator|,
name|char
operator|*
name|name2
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_PwdCmd --  *  *	This procedure is invoked to process the "pwd" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_PwdCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|char
modifier|*
name|dirName
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|dirName
operator|=
name|TclGetCwd
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirName
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|dirName
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_RegexpCmd --  *  *	This procedure is invoked to process the "regexp" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_RegexpCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|noCase
init|=
literal|0
decl_stmt|;
name|int
name|indices
init|=
literal|0
decl_stmt|;
name|Tcl_RegExp
name|regExpr
decl_stmt|;
name|char
modifier|*
modifier|*
name|argPtr
decl_stmt|,
modifier|*
name|string
decl_stmt|,
modifier|*
name|pattern
decl_stmt|,
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|match
init|=
literal|0
decl_stmt|;
comment|/* Initialization needed only to 					 * prevent compiler warning. */
name|int
name|i
decl_stmt|;
name|Tcl_DString
name|stringDString
decl_stmt|,
name|patternDString
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|wrongNumArgs
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" ?switches? exp string ?matchVar? ?subMatchVar "
argument_list|,
literal|"subMatchVar ...?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|argPtr
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
name|argc
operator|--
expr_stmt|;
while|while
condition|(
operator|(
name|argc
operator|>
literal|0
operator|)
operator|&&
operator|(
name|argPtr
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
index|[
literal|0
index|]
argument_list|,
literal|"-indices"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|indices
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
index|[
literal|0
index|]
argument_list|,
literal|"-nocase"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|noCase
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
index|[
literal|0
index|]
argument_list|,
literal|"--"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|argPtr
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
break|break;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad switch \""
argument_list|,
name|argPtr
index|[
literal|0
index|]
argument_list|,
literal|"\": must be -indices, -nocase, or --"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|argPtr
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
comment|/*      * Convert the string and pattern to lower case, if desired, and      * perform the matching operation.      */
if|if
condition|(
name|noCase
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|patternDString
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|patternDString
argument_list|,
name|argPtr
index|[
literal|0
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|Tcl_DStringValue
argument_list|(
operator|&
name|patternDString
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|pattern
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isupper
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|p
operator|=
operator|(
name|char
operator|)
name|tolower
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Tcl_DStringInit
argument_list|(
operator|&
name|stringDString
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|stringDString
argument_list|,
name|argPtr
index|[
literal|1
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|string
operator|=
name|Tcl_DStringValue
argument_list|(
operator|&
name|stringDString
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|string
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isupper
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|p
operator|=
operator|(
name|char
operator|)
name|tolower
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|pattern
operator|=
name|argPtr
index|[
literal|0
index|]
expr_stmt|;
name|string
operator|=
name|argPtr
index|[
literal|1
index|]
expr_stmt|;
block|}
name|regExpr
operator|=
name|Tcl_RegExpCompile
argument_list|(
name|interp
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|regExpr
operator|!=
name|NULL
condition|)
block|{
name|match
operator|=
name|Tcl_RegExpExec
argument_list|(
name|interp
argument_list|,
name|regExpr
argument_list|,
name|string
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noCase
condition|)
block|{
name|Tcl_DStringFree
argument_list|(
operator|&
name|stringDString
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|patternDString
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regExpr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|match
operator|<
literal|0
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|!
name|match
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"0"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
comment|/*      * If additional variable names have been specified, return      * index information in those variables.      */
name|argc
operator|-=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|result
decl_stmt|,
name|info
index|[
literal|50
index|]
decl_stmt|;
name|Tcl_RegExpRange
argument_list|(
name|regExpr
argument_list|,
name|i
argument_list|,
operator|&
name|start
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|indices
condition|)
block|{
name|result
operator|=
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argPtr
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
literal|"-1 -1"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argPtr
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|indices
condition|)
block|{
name|sprintf
argument_list|(
name|info
argument_list|,
literal|"%d %d"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|start
operator|-
name|string
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|end
operator|-
name|string
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argPtr
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
name|info
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|savedChar
decl_stmt|,
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|first
operator|=
name|argPtr
index|[
literal|1
index|]
operator|+
operator|(
name|start
operator|-
name|string
operator|)
expr_stmt|;
name|last
operator|=
name|argPtr
index|[
literal|1
index|]
operator|+
operator|(
name|end
operator|-
name|string
operator|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
name|last
condition|)
block|{
comment|/* don't modify argument */
name|result
operator|=
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argPtr
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|savedChar
operator|=
operator|*
name|last
expr_stmt|;
operator|*
name|last
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argPtr
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
name|first
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|last
operator|=
name|savedChar
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't set variable \""
argument_list|,
name|argPtr
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"1"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_RegsubCmd --  *  *	This procedure is invoked to process the "regsub" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_RegsubCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|noCase
init|=
literal|0
decl_stmt|,
name|all
init|=
literal|0
decl_stmt|;
name|Tcl_RegExp
name|regExpr
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|,
modifier|*
name|pattern
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|firstChar
decl_stmt|,
modifier|*
modifier|*
name|argPtr
decl_stmt|;
name|int
name|match
decl_stmt|,
name|code
decl_stmt|,
name|numMatches
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|subStart
decl_stmt|,
modifier|*
name|subEnd
decl_stmt|;
specifier|register
name|char
modifier|*
name|src
decl_stmt|,
name|c
decl_stmt|;
name|Tcl_DString
name|stringDString
decl_stmt|,
name|patternDString
decl_stmt|,
name|resultDString
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|5
condition|)
block|{
name|wrongNumArgs
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" ?switches? exp string subSpec varName\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|argPtr
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
name|argc
operator|--
expr_stmt|;
while|while
condition|(
name|argPtr
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
index|[
literal|0
index|]
argument_list|,
literal|"-nocase"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|noCase
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
index|[
literal|0
index|]
argument_list|,
literal|"-all"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|all
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
index|[
literal|0
index|]
argument_list|,
literal|"--"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|argPtr
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
break|break;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad switch \""
argument_list|,
name|argPtr
index|[
literal|0
index|]
argument_list|,
literal|"\": must be -all, -nocase, or --"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|argPtr
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
goto|goto
name|wrongNumArgs
goto|;
block|}
comment|/*      * Convert the string and pattern to lower case, if desired.      */
if|if
condition|(
name|noCase
condition|)
block|{
name|Tcl_DStringInit
argument_list|(
operator|&
name|patternDString
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|patternDString
argument_list|,
name|argPtr
index|[
literal|0
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|Tcl_DStringValue
argument_list|(
operator|&
name|patternDString
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|pattern
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isupper
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|p
operator|=
operator|(
name|char
operator|)
name|tolower
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Tcl_DStringInit
argument_list|(
operator|&
name|stringDString
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|stringDString
argument_list|,
name|argPtr
index|[
literal|1
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|string
operator|=
name|Tcl_DStringValue
argument_list|(
operator|&
name|stringDString
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|string
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isupper
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|p
operator|=
operator|(
name|char
operator|)
name|tolower
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|pattern
operator|=
name|argPtr
index|[
literal|0
index|]
expr_stmt|;
name|string
operator|=
name|argPtr
index|[
literal|1
index|]
expr_stmt|;
block|}
name|Tcl_DStringInit
argument_list|(
operator|&
name|resultDString
argument_list|)
expr_stmt|;
name|regExpr
operator|=
name|Tcl_RegExpCompile
argument_list|(
name|interp
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|regExpr
operator|==
name|NULL
condition|)
block|{
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*      * The following loop is to handle multiple matches within the      * same source string;  each iteration handles one match and its      * corresponding substitution.  If "-all" hasn't been specified      * then the loop body only gets executed once.      */
name|numMatches
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|string
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
control|)
block|{
name|match
operator|=
name|Tcl_RegExpExec
argument_list|(
name|interp
argument_list|,
name|regExpr
argument_list|,
name|p
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|<
literal|0
condition|)
block|{
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|!
name|match
condition|)
block|{
break|break;
block|}
name|numMatches
operator|+=
literal|1
expr_stmt|;
comment|/* 	 * Copy the portion of the source string before the match to the 	 * result variable. 	 */
name|Tcl_RegExpRange
argument_list|(
name|regExpr
argument_list|,
literal|0
argument_list|,
operator|&
name|start
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|resultDString
argument_list|,
name|argPtr
index|[
literal|1
index|]
operator|+
operator|(
name|p
operator|-
name|string
operator|)
argument_list|,
name|start
operator|-
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * Append the subSpec argument to the variable, making appropriate 	 * substitutions.  This code is a bit hairy because of the backslash 	 * conventions and because the code saves up ranges of characters in 	 * subSpec to reduce the number of calls to Tcl_SetVar. 	 */
for|for
control|(
name|src
operator|=
name|firstChar
operator|=
name|argPtr
index|[
literal|2
index|]
operator|,
name|c
operator|=
operator|*
name|src
init|;
name|c
operator|!=
literal|0
condition|;
name|src
operator|++
operator|,
name|c
operator|=
operator|*
name|src
control|)
block|{
name|int
name|index
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'&'
condition|)
block|{
name|index
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|src
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|index
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'\\'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'&'
operator|)
condition|)
block|{
operator|*
name|src
operator|=
name|c
expr_stmt|;
name|src
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|resultDString
argument_list|,
name|firstChar
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|src
operator|=
literal|'\\'
expr_stmt|;
name|src
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|firstChar
operator|=
name|src
operator|+
literal|2
expr_stmt|;
name|src
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
block|{
continue|continue;
block|}
block|}
else|else
block|{
continue|continue;
block|}
if|if
condition|(
name|firstChar
operator|!=
name|src
condition|)
block|{
name|c
operator|=
operator|*
name|src
expr_stmt|;
operator|*
name|src
operator|=
literal|0
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|resultDString
argument_list|,
name|firstChar
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|src
operator|=
name|c
expr_stmt|;
block|}
name|Tcl_RegExpRange
argument_list|(
name|regExpr
argument_list|,
name|index
argument_list|,
operator|&
name|subStart
argument_list|,
operator|&
name|subEnd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|subStart
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|subEnd
operator|!=
name|NULL
operator|)
condition|)
block|{
name|char
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|,
name|saved
decl_stmt|;
name|first
operator|=
name|argPtr
index|[
literal|1
index|]
operator|+
operator|(
name|subStart
operator|-
name|string
operator|)
expr_stmt|;
name|last
operator|=
name|argPtr
index|[
literal|1
index|]
operator|+
operator|(
name|subEnd
operator|-
name|string
operator|)
expr_stmt|;
name|saved
operator|=
operator|*
name|last
expr_stmt|;
operator|*
name|last
operator|=
literal|0
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|resultDString
argument_list|,
name|first
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|last
operator|=
name|saved
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|src
operator|==
literal|'\\'
condition|)
block|{
name|src
operator|++
expr_stmt|;
block|}
name|firstChar
operator|=
name|src
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|firstChar
operator|!=
name|src
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|resultDString
argument_list|,
name|firstChar
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|==
name|p
condition|)
block|{
comment|/* 	     * Always consume at least one character of the input string 	     * in order to prevent infinite loops. 	     */
name|Tcl_DStringAppend
argument_list|(
operator|&
name|resultDString
argument_list|,
name|argPtr
index|[
literal|1
index|]
operator|+
operator|(
name|p
operator|-
name|string
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|end
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|end
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|all
condition|)
block|{
break|break;
block|}
block|}
comment|/*      * Copy the portion of the source string after the last match to the      * result variable.      */
if|if
condition|(
operator|(
operator|*
name|p
operator|!=
literal|0
operator|)
operator|||
operator|(
name|numMatches
operator|==
literal|0
operator|)
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|resultDString
argument_list|,
name|argPtr
index|[
literal|1
index|]
operator|+
operator|(
name|p
operator|-
name|string
operator|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argPtr
index|[
literal|3
index|]
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|resultDString
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't set variable \""
argument_list|,
name|argPtr
index|[
literal|3
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|TclFormatInt
argument_list|(
name|buf
argument_list|,
name|numMatches
argument_list|)
expr_stmt|;
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
name|code
operator|=
name|TCL_OK
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|noCase
condition|)
block|{
name|Tcl_DStringFree
argument_list|(
operator|&
name|stringDString
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|patternDString
argument_list|)
expr_stmt|;
block|}
name|Tcl_DStringFree
argument_list|(
operator|&
name|resultDString
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_RenameObjCmd --  *  *	This procedure is invoked to process the "rename" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_RenameObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Arbitrary value passed to the command. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|char
modifier|*
name|oldName
decl_stmt|,
modifier|*
name|newName
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"oldName newName"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|oldName
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|newName
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TclRenameCommand
argument_list|(
name|interp
argument_list|,
name|oldName
argument_list|,
name|newName
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ReturnObjCmd --  *  *	This object-based procedure is invoked to process the "return" Tcl  *	command. See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_ReturnObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|int
name|optionLen
decl_stmt|,
name|argLen
decl_stmt|,
name|code
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|errorInfo
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|iPtr
operator|->
name|errorInfo
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|errorInfo
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|iPtr
operator|->
name|errorCode
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|iPtr
operator|->
name|errorCode
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|errorCode
operator|=
name|NULL
expr_stmt|;
block|}
name|code
operator|=
name|TCL_OK
expr_stmt|;
comment|/*     * THIS FAILS IF AN OBJECT CONTAINS AN EMBEDDED NULL.     */
for|for
control|(
name|objv
operator|++
operator|,
name|objc
operator|--
init|;
name|objc
operator|>
literal|1
condition|;
name|objv
operator|+=
literal|2
operator|,
name|objc
operator|-=
literal|2
control|)
block|{
name|char
modifier|*
name|option
init|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|0
index|]
argument_list|,
operator|&
name|optionLen
argument_list|)
decl_stmt|;
name|char
modifier|*
name|arg
init|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
operator|&
name|argLen
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"-code"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|register
name|int
name|c
init|=
name|arg
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'o'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"ok"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|code
operator|=
name|TCL_OK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"error"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'r'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"return"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|code
operator|=
name|TCL_RETURN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'b'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"break"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|code
operator|=
name|TCL_BREAK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'c'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"continue"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|code
operator|=
name|TCL_CONTINUE
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_GetIntFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|,
operator|&
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"bad completion code \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
literal|"\": must be ok, error, return, break, "
argument_list|,
literal|"continue, or an integer"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"-errorinfo"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|iPtr
operator|->
name|errorInfo
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|iPtr
operator|->
name|errorInfo
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"-errorcode"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|iPtr
operator|->
name|errorCode
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|iPtr
operator|->
name|errorCode
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"bad option \""
argument_list|,
name|option
argument_list|,
literal|"\": must be -code, -errorcode, or -errorinfo"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
if|if
condition|(
name|objc
operator|==
literal|1
condition|)
block|{
comment|/* 	 * Set the interpreter's object result. An inline version of 	 * Tcl_SetObjResult. 	 */
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|iPtr
operator|->
name|returnCode
operator|=
name|code
expr_stmt|;
return|return
name|TCL_RETURN
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ScanCmd --  *  *	This procedure is invoked to process the "scan" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_ScanCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
define|#
directive|define
name|MAX_FIELDS
value|20
typedef|typedef
struct|struct
block|{
name|char
name|fmt
decl_stmt|;
comment|/* Format for field. */
name|int
name|size
decl_stmt|;
comment|/* How many bytes to allow for 					 * field. */
name|char
modifier|*
name|location
decl_stmt|;
comment|/* Where field will be stored. */
block|}
name|Field
typedef|;
name|Field
name|fields
index|[
name|MAX_FIELDS
index|]
decl_stmt|;
comment|/* Info about all the fields in the 					 * format string. */
specifier|register
name|Field
modifier|*
name|curField
decl_stmt|;
name|int
name|numFields
init|=
literal|0
decl_stmt|;
comment|/* Number of fields actually 					 * specified. */
name|int
name|suppress
decl_stmt|;
comment|/* Current field is assignment- 					 * suppressed. */
name|int
name|totalSize
init|=
literal|0
decl_stmt|;
comment|/* Number of bytes needed to store 					 * all results combined. */
name|char
modifier|*
name|results
decl_stmt|;
comment|/* Where scanned output goes. 					 * Malloced; NULL means not allocated 					 * yet. */
name|int
name|numScanned
decl_stmt|;
comment|/* sscanf's result. */
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|widthSpecified
decl_stmt|,
name|length
decl_stmt|,
name|code
decl_stmt|;
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
comment|/*      * The variables below are used to hold a copy of the format      * string, so that we can replace format specifiers like "%f"      * and "%F" with specifiers like "%lf"      */
define|#
directive|define
name|STATIC_SIZE
value|5
name|char
name|copyBuf
index|[
name|STATIC_SIZE
index|]
decl_stmt|,
modifier|*
name|fmtCopy
decl_stmt|;
specifier|register
name|char
modifier|*
name|dst
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" string format ?varName varName ...?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * This procedure operates in four stages:      * 1. Scan the format string, collecting information about each field.      * 2. Allocate an array to hold all of the scanned fields.      * 3. Call sscanf to do all the dirty work, and have it store the      *    parsed fields in the array.      * 4. Pick off the fields from the array and assign them to variables.      */
name|code
operator|=
name|TCL_OK
expr_stmt|;
name|results
operator|=
name|NULL
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|length
operator|<
name|STATIC_SIZE
condition|)
block|{
name|fmtCopy
operator|=
name|copyBuf
expr_stmt|;
block|}
else|else
block|{
name|fmtCopy
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|length
argument_list|)
expr_stmt|;
block|}
name|dst
operator|=
name|fmtCopy
expr_stmt|;
for|for
control|(
name|fmt
operator|=
name|argv
index|[
literal|2
index|]
init|;
operator|*
name|fmt
operator|!=
literal|0
condition|;
name|fmt
operator|++
control|)
block|{
operator|*
name|dst
operator|=
operator|*
name|fmt
expr_stmt|;
name|dst
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|fmt
operator|!=
literal|'%'
condition|)
block|{
continue|continue;
block|}
name|fmt
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'%'
condition|)
block|{
operator|*
name|dst
operator|=
operator|*
name|fmt
expr_stmt|;
name|dst
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'*'
condition|)
block|{
name|suppress
operator|=
literal|1
expr_stmt|;
operator|*
name|dst
operator|=
operator|*
name|fmt
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
else|else
block|{
name|suppress
operator|=
literal|0
expr_stmt|;
block|}
name|widthSpecified
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|fmt
argument_list|)
argument_list|)
condition|)
block|{
name|widthSpecified
operator|=
literal|1
expr_stmt|;
operator|*
name|dst
operator|=
operator|*
name|fmt
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|fmt
operator|==
literal|'l'
operator|)
operator|||
operator|(
operator|*
name|fmt
operator|==
literal|'h'
operator|)
operator|||
operator|(
operator|*
name|fmt
operator|==
literal|'L'
operator|)
condition|)
block|{
name|fmt
operator|++
expr_stmt|;
block|}
operator|*
name|dst
operator|=
operator|*
name|fmt
expr_stmt|;
name|dst
operator|++
expr_stmt|;
if|if
condition|(
name|suppress
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|numFields
operator|==
name|MAX_FIELDS
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"too many fields to scan"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|curField
operator|=
operator|&
name|fields
index|[
name|numFields
index|]
expr_stmt|;
name|numFields
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|fmt
condition|)
block|{
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
case|case
literal|'o'
case|:
case|case
literal|'x'
case|:
name|curField
operator|->
name|fmt
operator|=
literal|'d'
expr_stmt|;
name|curField
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|curField
operator|->
name|fmt
operator|=
literal|'u'
expr_stmt|;
name|curField
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|curField
operator|->
name|fmt
operator|=
literal|'s'
expr_stmt|;
name|curField
operator|->
name|size
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|widthSpecified
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"field width may not be specified in %c conversion"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|curField
operator|->
name|fmt
operator|=
literal|'c'
expr_stmt|;
name|curField
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
name|dst
index|[
operator|-
literal|1
index|]
operator|=
literal|'l'
expr_stmt|;
name|dst
index|[
literal|0
index|]
operator|=
literal|'f'
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|curField
operator|->
name|fmt
operator|=
literal|'f'
expr_stmt|;
name|curField
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
name|double
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|curField
operator|->
name|fmt
operator|=
literal|'s'
expr_stmt|;
name|curField
operator|->
name|size
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
do|do
block|{
name|fmt
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|fmt
operator|==
literal|0
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"unmatched [ in format string"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
operator|*
name|dst
operator|=
operator|*
name|fmt
expr_stmt|;
name|dst
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|fmt
operator|!=
literal|']'
condition|)
do|;
break|break;
default|default:
block|{
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"bad scan conversion character \"%c\""
argument_list|,
operator|*
name|fmt
argument_list|)
expr_stmt|;
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|curField
operator|->
name|size
operator|=
name|TCL_ALIGN
argument_list|(
name|curField
operator|->
name|size
argument_list|)
expr_stmt|;
name|totalSize
operator|+=
name|curField
operator|->
name|size
expr_stmt|;
block|}
operator|*
name|dst
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|numFields
operator|!=
operator|(
name|argc
operator|-
literal|3
operator|)
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"different numbers of variable names and field specifiers"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*      * Step 2:      */
name|results
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|totalSize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|totalSize
operator|=
literal|0
operator|,
name|curField
operator|=
name|fields
init|;
name|i
operator|<
name|numFields
condition|;
name|i
operator|++
operator|,
name|curField
operator|++
control|)
block|{
name|curField
operator|->
name|location
operator|=
name|results
operator|+
name|totalSize
expr_stmt|;
name|totalSize
operator|+=
name|curField
operator|->
name|size
expr_stmt|;
block|}
comment|/*      * Fill in the remaining fields with NULL;  the only purpose of      * this is to keep some memory analyzers, like Purify, from      * complaining.      */
for|for
control|(
init|;
name|i
operator|<
name|MAX_FIELDS
condition|;
name|i
operator|++
operator|,
name|curField
operator|++
control|)
block|{
name|curField
operator|->
name|location
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*      * Step 3:      */
name|numScanned
operator|=
name|sscanf
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|fmtCopy
argument_list|,
name|fields
index|[
literal|0
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|1
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|2
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|3
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|4
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|5
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|6
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|7
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|8
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|9
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|10
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|11
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|12
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|13
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|14
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|15
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|16
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|17
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|18
index|]
operator|.
name|location
argument_list|,
name|fields
index|[
literal|19
index|]
operator|.
name|location
argument_list|)
expr_stmt|;
comment|/*      * Step 4:      */
if|if
condition|(
name|numScanned
operator|<
name|numFields
condition|)
block|{
name|numFields
operator|=
name|numScanned
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|curField
operator|=
name|fields
init|;
name|i
operator|<
name|numFields
condition|;
name|i
operator|++
operator|,
name|curField
operator|++
control|)
block|{
switch|switch
condition|(
name|curField
operator|->
name|fmt
condition|)
block|{
name|char
name|string
index|[
name|TCL_DOUBLE_SPACE
index|]
decl_stmt|;
case|case
literal|'d'
case|:
name|TclFormatInt
argument_list|(
name|string
argument_list|,
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|curField
operator|->
name|location
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
operator|+
literal|3
index|]
argument_list|,
name|string
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|storeError
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't set variable \""
argument_list|,
name|argv
index|[
name|i
operator|+
literal|3
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
case|case
literal|'u'
case|:
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%u"
argument_list|,
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|curField
operator|->
name|location
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
operator|+
literal|3
index|]
argument_list|,
name|string
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|storeError
goto|;
block|}
break|break;
case|case
literal|'c'
case|:
name|TclFormatInt
argument_list|(
name|string
argument_list|,
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|curField
operator|->
name|location
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
operator|+
literal|3
index|]
argument_list|,
name|string
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|storeError
goto|;
block|}
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
operator|+
literal|3
index|]
argument_list|,
name|curField
operator|->
name|location
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|storeError
goto|;
block|}
break|break;
case|case
literal|'f'
case|:
name|Tcl_PrintDouble
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
operator|*
operator|(
operator|(
name|double
operator|*
operator|)
name|curField
operator|->
name|location
operator|)
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
operator|+
literal|3
index|]
argument_list|,
name|string
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|storeError
goto|;
block|}
break|break;
block|}
block|}
name|TclFormatInt
argument_list|(
name|buf
argument_list|,
name|numScanned
argument_list|)
expr_stmt|;
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|results
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|results
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fmtCopy
operator|!=
name|copyBuf
condition|)
block|{
name|ckfree
argument_list|(
name|fmtCopy
argument_list|)
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SourceObjCmd --  *  *	This procedure is invoked to process the "source" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_SourceObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|char
modifier|*
name|bytes
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"fileName"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * THIS FAILS IF THE OBJECT'S STRING REP CONTAINS A NULL.      */
name|bytes
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_EvalFile
argument_list|(
name|interp
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SplitObjCmd --  *  *	This procedure is invoked to process the "split" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_SplitObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|char
modifier|*
name|splitChars
decl_stmt|,
modifier|*
name|string
decl_stmt|,
modifier|*
name|elementStart
decl_stmt|;
name|int
name|splitCharLen
decl_stmt|,
name|stringLen
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|Tcl_Obj
modifier|*
name|listPtr
decl_stmt|;
if|if
condition|(
name|objc
operator|==
literal|2
condition|)
block|{
name|splitChars
operator|=
literal|" \n\t\r"
expr_stmt|;
name|splitCharLen
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|objc
operator|==
literal|3
condition|)
block|{
name|splitChars
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|splitCharLen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"string ?splitChars?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|string
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
operator|&
name|stringLen
argument_list|)
expr_stmt|;
name|listPtr
operator|=
name|Tcl_NewListObj
argument_list|(
literal|0
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/*      * Handle the special case of splitting on every character.      */
if|if
condition|(
name|splitCharLen
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|string
init|;
name|i
operator|<
name|stringLen
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	 * Normal case: split on any of a given set of characters. 	 * Discard instances of the split characters. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|elementStart
operator|=
name|string
init|;
name|i
operator|<
name|stringLen
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|p2
operator|=
name|splitChars
init|;
name|j
operator|<
name|splitCharLen
condition|;
name|j
operator|++
operator|,
name|p2
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p2
operator|==
operator|*
name|p
condition|)
block|{
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|elementStart
argument_list|,
operator|(
name|p
operator|-
name|elementStart
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|elementStart
operator|=
name|p
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|p
operator|!=
name|string
condition|)
block|{
name|int
name|remainingChars
init|=
name|stringLen
operator|-
operator|(
name|elementStart
operator|-
name|string
operator|)
decl_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|elementStart
argument_list|,
name|remainingChars
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_StringObjCmd --  *  *	This procedure is invoked to process the "string" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_StringObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|int
name|index
decl_stmt|,
name|first
decl_stmt|,
name|left
decl_stmt|,
name|right
decl_stmt|;
name|Tcl_Obj
modifier|*
name|resultPtr
decl_stmt|;
name|char
modifier|*
name|string1
decl_stmt|,
modifier|*
name|string2
decl_stmt|;
name|int
name|length1
decl_stmt|,
name|length2
decl_stmt|;
specifier|static
name|char
modifier|*
name|options
index|[]
init|=
block|{
literal|"compare"
block|,
literal|"first"
block|,
literal|"index"
block|,
literal|"last"
block|,
literal|"length"
block|,
literal|"match"
block|,
literal|"range"
block|,
literal|"tolower"
block|,
literal|"toupper"
block|,
literal|"trim"
block|,
literal|"trimleft"
block|,
literal|"trimright"
block|,
literal|"wordend"
block|,
literal|"wordstart"
block|,
name|NULL
block|}
decl_stmt|;
enum|enum
name|options
block|{
name|STR_COMPARE
block|,
name|STR_FIRST
block|,
name|STR_INDEX
block|,
name|STR_LAST
block|,
name|STR_LENGTH
block|,
name|STR_MATCH
block|,
name|STR_RANGE
block|,
name|STR_TOLOWER
block|,
name|STR_TOUPPER
block|,
name|STR_TRIM
block|,
name|STR_TRIMLEFT
block|,
name|STR_TRIMRIGHT
block|,
name|STR_WORDEND
block|,
name|STR_WORDSTART
block|}
enum|;
if|if
condition|(
name|objc
operator|<
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"option arg ?arg ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetIndexFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|,
name|options
argument_list|,
literal|"option"
argument_list|,
literal|0
argument_list|,
operator|&
name|index
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|resultPtr
operator|=
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
expr|enum
name|options
operator|)
name|index
condition|)
block|{
case|case
name|STR_COMPARE
case|:
block|{
name|int
name|match
decl_stmt|,
name|length
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"string1 string2"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|string1
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length1
argument_list|)
expr_stmt|;
name|string2
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|length2
argument_list|)
expr_stmt|;
name|length
operator|=
operator|(
name|length1
operator|<
name|length2
operator|)
condition|?
name|length1
else|:
name|length2
expr_stmt|;
name|match
operator|=
name|memcmp
argument_list|(
name|string1
argument_list|,
name|string2
argument_list|,
operator|(
name|unsigned
operator|)
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|==
literal|0
condition|)
block|{
name|match
operator|=
name|length1
operator|-
name|length2
expr_stmt|;
block|}
name|Tcl_SetIntObj
argument_list|(
name|resultPtr
argument_list|,
operator|(
name|match
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
operator|(
name|match
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|STR_FIRST
case|:
block|{
name|first
operator|=
literal|1
expr_stmt|;
goto|goto
name|firstlast
goto|;
block|}
case|case
name|STR_INDEX
case|:
block|{
name|int
name|index
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"string charIndex"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|string1
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length1
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|index
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|index
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|index
operator|<
name|length1
operator|)
condition|)
block|{
name|Tcl_SetStringObj
argument_list|(
name|resultPtr
argument_list|,
name|string1
operator|+
name|index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|STR_LAST
case|:
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|match
decl_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
name|firstlast
label|:
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"string1 string2"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|match
operator|=
operator|-
literal|1
expr_stmt|;
name|string1
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length1
argument_list|)
expr_stmt|;
name|string2
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|length2
argument_list|)
expr_stmt|;
if|if
condition|(
name|length1
operator|>
literal|0
condition|)
block|{
name|end
operator|=
name|string2
operator|+
name|length2
operator|-
name|length1
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|string2
init|;
name|p
operator|<
name|end
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|string1
argument_list|,
name|p
argument_list|,
operator|(
name|unsigned
operator|)
name|length1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|match
operator|=
name|p
operator|-
name|string2
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
break|break;
block|}
block|}
block|}
block|}
name|Tcl_SetIntObj
argument_list|(
name|resultPtr
argument_list|,
name|match
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|STR_LENGTH
case|:
block|{
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"string"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
operator|(
name|void
operator|)
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length1
argument_list|)
expr_stmt|;
name|Tcl_SetIntObj
argument_list|(
name|resultPtr
argument_list|,
name|length1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|STR_MATCH
case|:
block|{
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"pattern string"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|string1
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length1
argument_list|)
expr_stmt|;
name|string2
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|length2
argument_list|)
expr_stmt|;
name|Tcl_SetBooleanObj
argument_list|(
name|resultPtr
argument_list|,
name|Tcl_StringMatch
argument_list|(
name|string2
argument_list|,
name|string1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|STR_RANGE
case|:
block|{
name|int
name|first
decl_stmt|,
name|last
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|5
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"string first last"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|string1
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TclGetIntForIndex
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|3
index|]
argument_list|,
name|length1
operator|-
literal|1
argument_list|,
operator|&
name|first
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|TclGetIntForIndex
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|4
index|]
argument_list|,
name|length1
operator|-
literal|1
argument_list|,
operator|&
name|last
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|first
operator|<
literal|0
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|>=
name|length1
operator|-
literal|1
condition|)
block|{
name|last
operator|=
name|length1
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|>=
name|first
condition|)
block|{
name|Tcl_SetStringObj
argument_list|(
name|resultPtr
argument_list|,
name|string1
operator|+
name|first
argument_list|,
name|last
operator|-
name|first
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|STR_TOLOWER
case|:
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"string"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|string1
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length1
argument_list|)
expr_stmt|;
comment|/* 	     * Since I know resultPtr is not a shared object, I can reach 	     * in and diddle the bytes in its string rep to convert them in 	     * place to lower case. 	     */
name|Tcl_SetStringObj
argument_list|(
name|resultPtr
argument_list|,
name|string1
argument_list|,
name|length1
argument_list|)
expr_stmt|;
name|string1
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|resultPtr
argument_list|,
operator|&
name|length1
argument_list|)
expr_stmt|;
name|end
operator|=
name|string1
operator|+
name|length1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|string1
init|;
name|p
operator|<
name|end
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isupper
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|p
operator|=
operator|(
name|char
operator|)
name|tolower
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|STR_TOUPPER
case|:
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"string"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|string1
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length1
argument_list|)
expr_stmt|;
comment|/* 	     * Since I know resultPtr is not a shared object, I can reach 	     * in and diddle the bytes in its string rep to convert them in 	     * place to upper case. 	     */
name|Tcl_SetStringObj
argument_list|(
name|resultPtr
argument_list|,
name|string1
argument_list|,
name|length1
argument_list|)
expr_stmt|;
name|string1
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|resultPtr
argument_list|,
operator|&
name|length1
argument_list|)
expr_stmt|;
name|end
operator|=
name|string1
operator|+
name|length1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|string1
init|;
name|p
operator|<
name|end
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|islower
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|p
operator|=
operator|(
name|char
operator|)
name|toupper
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|STR_TRIM
case|:
block|{
name|char
name|ch
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|check
decl_stmt|,
modifier|*
name|checkEnd
decl_stmt|;
name|left
operator|=
literal|1
expr_stmt|;
name|right
operator|=
literal|1
expr_stmt|;
name|trim
label|:
if|if
condition|(
name|objc
operator|==
literal|4
condition|)
block|{
name|string2
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|length2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|objc
operator|==
literal|3
condition|)
block|{
name|string2
operator|=
literal|" \t\n\r"
expr_stmt|;
name|length2
operator|=
name|strlen
argument_list|(
name|string2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"string ?chars?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|string1
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length1
argument_list|)
expr_stmt|;
name|checkEnd
operator|=
name|string2
operator|+
name|length2
expr_stmt|;
if|if
condition|(
name|left
condition|)
block|{
name|end
operator|=
name|string1
operator|+
name|length1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|string1
init|;
name|p
operator|<
name|end
condition|;
name|p
operator|++
control|)
block|{
name|ch
operator|=
operator|*
name|p
expr_stmt|;
for|for
control|(
name|check
operator|=
name|string2
init|;
condition|;
name|check
operator|++
control|)
block|{
if|if
condition|(
name|check
operator|>=
name|checkEnd
condition|)
block|{
name|p
operator|=
name|end
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ch
operator|==
operator|*
name|check
condition|)
block|{
name|length1
operator|--
expr_stmt|;
name|string1
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|right
condition|)
block|{
name|end
operator|=
name|string1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|string1
operator|+
name|length1
init|;
name|p
operator|>
name|end
condition|;
control|)
block|{
name|p
operator|--
expr_stmt|;
name|ch
operator|=
operator|*
name|p
expr_stmt|;
for|for
control|(
name|check
operator|=
name|string2
init|;
condition|;
name|check
operator|++
control|)
block|{
if|if
condition|(
name|check
operator|>=
name|checkEnd
condition|)
block|{
name|p
operator|=
name|end
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ch
operator|==
operator|*
name|check
condition|)
block|{
name|length1
operator|--
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|Tcl_SetStringObj
argument_list|(
name|resultPtr
argument_list|,
name|string1
argument_list|,
name|length1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|STR_TRIMLEFT
case|:
block|{
name|left
operator|=
literal|1
expr_stmt|;
name|right
operator|=
literal|0
expr_stmt|;
goto|goto
name|trim
goto|;
block|}
case|case
name|STR_TRIMRIGHT
case|:
block|{
name|left
operator|=
literal|0
expr_stmt|;
name|right
operator|=
literal|1
expr_stmt|;
goto|goto
name|trim
goto|;
block|}
case|case
name|STR_WORDEND
case|:
block|{
name|int
name|cur
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"string index"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|string1
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length1
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|index
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
name|index
operator|=
literal|0
expr_stmt|;
block|}
name|cur
operator|=
name|length1
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|length1
condition|)
block|{
for|for
control|(
name|cur
operator|=
name|index
init|;
name|cur
operator|<
name|length1
condition|;
name|cur
operator|++
control|)
block|{
name|c
operator|=
name|UCHAR
argument_list|(
name|string1
index|[
name|cur
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|c
operator|!=
literal|'_'
operator|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|cur
operator|==
name|index
condition|)
block|{
name|cur
operator|=
name|index
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|Tcl_SetIntObj
argument_list|(
name|resultPtr
argument_list|,
name|cur
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|STR_WORDSTART
case|:
block|{
name|int
name|cur
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"string index"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|string1
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length1
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|index
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|index
operator|>=
name|length1
condition|)
block|{
name|index
operator|=
name|length1
operator|-
literal|1
expr_stmt|;
block|}
name|cur
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|index
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|cur
operator|=
name|index
init|;
name|cur
operator|>=
literal|0
condition|;
name|cur
operator|--
control|)
block|{
name|c
operator|=
name|UCHAR
argument_list|(
name|string1
index|[
name|cur
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|c
operator|!=
literal|'_'
operator|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|cur
operator|!=
name|index
condition|)
block|{
name|cur
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|Tcl_SetIntObj
argument_list|(
name|resultPtr
argument_list|,
name|cur
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SubstCmd --  *  *	This procedure is invoked to process the "subst" Tcl command.  *	See the user documentation for details on what it does.  This  *	command is an almost direct copy of an implementation by  *	Andrew Payne.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_SubstCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Tcl_DString
name|result
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|old
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|int
name|code
decl_stmt|,
name|count
decl_stmt|,
name|doVars
decl_stmt|,
name|doCmds
decl_stmt|,
name|doBackslashes
decl_stmt|,
name|i
decl_stmt|;
name|size_t
name|length
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/*      * Parse command-line options.      */
name|doVars
operator|=
name|doCmds
operator|=
name|doBackslashes
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|(
name|argc
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'-'
condition|)
block|{
break|break;
block|}
name|length
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|4
condition|)
block|{
name|badSwitch
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad switch \""
argument_list|,
name|p
argument_list|,
literal|"\": must be -nobackslashes, -nocommands, "
argument_list|,
literal|"or -novariables"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|p
index|[
literal|3
index|]
operator|==
literal|'b'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"-nobackslashes"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|doBackslashes
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p
index|[
literal|3
index|]
operator|==
literal|'c'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"-nocommands"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|doCmds
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p
index|[
literal|3
index|]
operator|==
literal|'v'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"-novariables"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|doVars
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|badSwitch
goto|;
block|}
block|}
if|if
condition|(
name|i
operator|!=
operator|(
name|argc
operator|-
literal|1
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" ?-nobackslashes? ?-nocommands? ?-novariables? string\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Scan through the string one character at a time, performing      * command, variable, and backslash substitutions.      */
name|Tcl_DStringInit
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|old
operator|=
name|p
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
name|doBackslashes
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|old
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|result
argument_list|,
name|old
argument_list|,
name|p
operator|-
name|old
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|Tcl_Backslash
argument_list|(
name|p
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|result
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|+=
name|count
expr_stmt|;
name|old
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|p
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'$'
case|:
if|if
condition|(
name|doVars
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|old
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|result
argument_list|,
name|old
argument_list|,
name|p
operator|-
name|old
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|Tcl_ParseVar
argument_list|(
name|interp
argument_list|,
name|p
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
name|Tcl_DStringFree
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_DStringAppend
argument_list|(
operator|&
name|result
argument_list|,
name|value
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|old
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|p
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'['
case|:
if|if
condition|(
name|doCmds
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|old
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|result
argument_list|,
name|old
argument_list|,
name|p
operator|-
name|old
argument_list|)
expr_stmt|;
block|}
name|iPtr
operator|->
name|evalFlags
operator|=
name|TCL_BRACKET_TERM
expr_stmt|;
name|code
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TCL_ERROR
condition|)
block|{
name|Tcl_DStringFree
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
name|old
operator|=
name|p
operator|=
operator|(
name|p
operator|+
literal|1
operator|+
name|iPtr
operator|->
name|termOffset
operator|+
literal|1
operator|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|result
argument_list|,
name|iPtr
operator|->
name|result
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|++
expr_stmt|;
block|}
break|break;
default|default:
name|p
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|p
operator|!=
name|old
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|result
argument_list|,
name|old
argument_list|,
name|p
operator|-
name|old
argument_list|)
expr_stmt|;
block|}
name|Tcl_DStringResult
argument_list|(
name|interp
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SwitchObjCmd --  *  *	This object-based procedure is invoked to process the "switch" Tcl  *	command. See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_SwitchObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
define|#
directive|define
name|EXACT
value|0
define|#
directive|define
name|GLOB
value|1
define|#
directive|define
name|REGEXP
value|2
name|int
name|switchObjc
decl_stmt|,
name|index
decl_stmt|;
name|Tcl_Obj
modifier|*
name|CONST
modifier|*
name|switchObjv
decl_stmt|;
name|Tcl_Obj
modifier|*
name|patternObj
decl_stmt|,
modifier|*
name|bodyObj
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|,
modifier|*
name|pattern
decl_stmt|,
modifier|*
name|body
decl_stmt|;
name|int
name|splitObjs
decl_stmt|,
name|length
decl_stmt|,
name|patternLen
decl_stmt|,
name|i
decl_stmt|,
name|code
decl_stmt|,
name|mode
decl_stmt|,
name|matched
decl_stmt|,
name|bodyIdx
decl_stmt|;
specifier|static
name|char
modifier|*
name|switches
index|[]
init|=
block|{
literal|"-exact"
block|,
literal|"-glob"
block|,
literal|"-regexp"
block|,
literal|"--"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
name|switchObjc
operator|=
name|objc
operator|-
literal|1
expr_stmt|;
name|switchObjv
operator|=
name|objv
operator|+
literal|1
expr_stmt|;
name|mode
operator|=
name|EXACT
expr_stmt|;
name|string
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|switchObjv
index|[
literal|0
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|switchObjc
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|*
name|string
operator|==
literal|'-'
operator|)
condition|)
block|{
if|if
condition|(
name|Tcl_GetIndexFromObj
argument_list|(
name|interp
argument_list|,
name|switchObjv
index|[
literal|0
index|]
argument_list|,
name|switches
argument_list|,
literal|"option"
argument_list|,
literal|0
argument_list|,
operator|&
name|index
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
switch|switch
condition|(
name|index
condition|)
block|{
case|case
literal|0
case|:
comment|/* -exact */
name|mode
operator|=
name|EXACT
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* -glob */
name|mode
operator|=
name|GLOB
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* -regexp */
name|mode
operator|=
name|REGEXP
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* -- */
name|switchObjc
operator|--
expr_stmt|;
name|switchObjv
operator|++
expr_stmt|;
goto|goto
name|doneWithSwitches
goto|;
block|}
name|switchObjc
operator|--
expr_stmt|;
name|switchObjv
operator|++
expr_stmt|;
name|string
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|switchObjv
index|[
literal|0
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
block|}
name|doneWithSwitches
label|:
if|if
condition|(
name|switchObjc
operator|<
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"?switches? string pattern body ... ?default body?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|string
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|switchObjv
index|[
literal|0
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|switchObjc
operator|--
expr_stmt|;
name|switchObjv
operator|++
expr_stmt|;
comment|/*      * If all of the pattern/command pairs are lumped into a single      * argument, split them out again.      */
name|splitObjs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|switchObjc
operator|==
literal|1
condition|)
block|{
name|code
operator|=
name|Tcl_ListObjLength
argument_list|(
name|interp
argument_list|,
name|switchObjv
index|[
literal|0
index|]
argument_list|,
operator|&
name|switchObjc
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|code
return|;
block|}
name|splitObjs
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|switchObjc
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|i
operator|==
operator|(
name|switchObjc
operator|-
literal|1
operator|)
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"extra switch pattern with no body"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * See if the pattern matches the string. 	 */
if|if
condition|(
name|splitObjs
condition|)
block|{
name|code
operator|=
name|Tcl_ListObjIndex
argument_list|(
name|interp
argument_list|,
name|switchObjv
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
operator|&
name|patternObj
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|code
return|;
block|}
name|pattern
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|patternObj
argument_list|,
operator|&
name|patternLen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pattern
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|switchObjv
index|[
name|i
index|]
argument_list|,
operator|&
name|patternLen
argument_list|)
expr_stmt|;
block|}
name|matched
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pattern
operator|==
literal|'d'
operator|)
operator|&&
operator|(
name|i
operator|==
name|switchObjc
operator|-
literal|2
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|pattern
argument_list|,
literal|"default"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|matched
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * THIS FAILS IF AN OBJECT'S STRING REP HAS A NULL. 	     */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|EXACT
case|:
name|matched
operator|=
operator|(
name|strcmp
argument_list|(
name|string
argument_list|,
name|pattern
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|GLOB
case|:
name|matched
operator|=
name|Tcl_StringMatch
argument_list|(
name|string
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP
case|:
name|matched
operator|=
name|Tcl_RegExpMatch
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|matched
operator|<
literal|0
condition|)
block|{
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|matched
condition|)
block|{
continue|continue;
block|}
comment|/* 	 * We've got a match. Find a body to execute, skipping bodies 	 * that are "-". 	 */
for|for
control|(
name|bodyIdx
operator|=
name|i
operator|+
literal|1
init|;
condition|;
name|bodyIdx
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|bodyIdx
operator|>=
name|switchObjc
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"no body specified for pattern \""
argument_list|,
name|pattern
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|splitObjs
condition|)
block|{
name|code
operator|=
name|Tcl_ListObjIndex
argument_list|(
name|interp
argument_list|,
name|switchObjv
index|[
literal|0
index|]
argument_list|,
name|bodyIdx
argument_list|,
operator|&
name|bodyObj
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|code
return|;
block|}
block|}
else|else
block|{
name|bodyObj
operator|=
name|switchObjv
index|[
name|bodyIdx
index|]
expr_stmt|;
block|}
comment|/* 	     * THIS FAILS IF AN OBJECT'S STRING REP HAS A NULL. 	     */
name|body
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|bodyObj
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|length
operator|!=
literal|1
operator|)
operator|||
operator|(
name|body
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|)
condition|)
block|{
break|break;
block|}
block|}
name|code
operator|=
name|Tcl_EvalObj
argument_list|(
name|interp
argument_list|,
name|bodyObj
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TCL_ERROR
condition|)
block|{
name|char
name|msg
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n    (\"%.50s\" arm line %d)"
argument_list|,
name|pattern
argument_list|,
name|interp
operator|->
name|errorLine
argument_list|)
expr_stmt|;
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|msg
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
comment|/*      * Nothing matched:  return nothing.      */
name|code
operator|=
name|TCL_OK
expr_stmt|;
name|done
label|:
return|return
name|code
return|;
undef|#
directive|undef
name|EXACT
undef|#
directive|undef
name|GLOB
undef|#
directive|undef
name|REGEXP
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_TimeObjCmd --  *  *	This object-based procedure is invoked to process the "time" Tcl  *	command.  See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_TimeObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|result
decl_stmt|;
name|int
name|count
decl_stmt|;
name|double
name|totalMicroSec
decl_stmt|;
name|Tcl_Time
name|start
decl_stmt|,
name|stop
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|objc
operator|==
literal|2
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|objc
operator|==
literal|3
condition|)
block|{
name|result
operator|=
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
else|else
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"command ?count?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|objPtr
operator|=
name|objv
index|[
literal|1
index|]
expr_stmt|;
name|i
operator|=
name|count
expr_stmt|;
name|TclpGetTime
argument_list|(
operator|&
name|start
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
name|result
operator|=
name|Tcl_EvalObj
argument_list|(
name|interp
argument_list|,
name|objPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
name|TclpGetTime
argument_list|(
operator|&
name|stop
argument_list|)
expr_stmt|;
name|totalMicroSec
operator|=
operator|(
name|stop
operator|.
name|sec
operator|-
name|start
operator|.
name|sec
operator|)
operator|*
literal|1000000
operator|+
operator|(
name|stop
operator|.
name|usec
operator|-
name|start
operator|.
name|usec
operator|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%.0f microseconds per iteration"
argument_list|,
operator|(
operator|(
name|count
operator|<=
literal|0
operator|)
condition|?
literal|0
else|:
name|totalMicroSec
operator|/
name|count
operator|)
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_TraceCmd --  *  *	This procedure is invoked to process the "trace" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_TraceCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|c
decl_stmt|;
name|size_t
name|length
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"too few args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" option [arg arg ...]\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|c
operator|=
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'a'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"variable"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|2
operator|)
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|length
decl_stmt|;
name|TraceVarInfo
modifier|*
name|tvarPtr
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|5
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" variable name ops command\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|flags
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|argv
index|[
literal|3
index|]
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'r'
condition|)
block|{
name|flags
operator||=
name|TCL_TRACE_READS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'w'
condition|)
block|{
name|flags
operator||=
name|TCL_TRACE_WRITES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'u'
condition|)
block|{
name|flags
operator||=
name|TCL_TRACE_UNSETS
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|badOps
goto|;
block|}
block|}
if|if
condition|(
name|flags
operator|==
literal|0
condition|)
block|{
goto|goto
name|badOps
goto|;
block|}
name|length
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|tvarPtr
operator|=
operator|(
name|TraceVarInfo
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|TraceVarInfo
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|tvarPtr
operator|->
name|command
argument_list|)
operator|+
name|length
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|tvarPtr
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|tvarPtr
operator|->
name|errMsg
operator|=
name|NULL
expr_stmt|;
name|tvarPtr
operator|->
name|length
operator|=
name|length
expr_stmt|;
name|flags
operator||=
name|TCL_TRACE_UNSETS
expr_stmt|;
name|strcpy
argument_list|(
name|tvarPtr
operator|->
name|command
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_TraceVar
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|flags
argument_list|,
name|TraceVarProc
argument_list|,
operator|(
name|ClientData
operator|)
name|tvarPtr
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tvarPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'d'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"vdelete"
argument_list|,
name|length
argument_list|)
operator|&&
operator|(
name|length
operator|>=
literal|2
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|length
decl_stmt|;
name|TraceVarInfo
modifier|*
name|tvarPtr
decl_stmt|;
name|ClientData
name|clientData
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|5
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" vdelete name ops command\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|flags
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|argv
index|[
literal|3
index|]
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'r'
condition|)
block|{
name|flags
operator||=
name|TCL_TRACE_READS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'w'
condition|)
block|{
name|flags
operator||=
name|TCL_TRACE_WRITES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'u'
condition|)
block|{
name|flags
operator||=
name|TCL_TRACE_UNSETS
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|badOps
goto|;
block|}
block|}
if|if
condition|(
name|flags
operator|==
literal|0
condition|)
block|{
goto|goto
name|badOps
goto|;
block|}
comment|/* 	 * Search through all of our traces on this variable to 	 * see if there's one with the given command.  If so, then 	 * delete the first one that matches. 	 */
name|length
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|clientData
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|clientData
operator|=
name|Tcl_VarTraceInfo
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
name|TraceVarProc
argument_list|,
name|clientData
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|tvarPtr
operator|=
operator|(
name|TraceVarInfo
operator|*
operator|)
name|clientData
expr_stmt|;
if|if
condition|(
operator|(
name|tvarPtr
operator|->
name|length
operator|==
name|length
operator|)
operator|&&
operator|(
name|tvarPtr
operator|->
name|flags
operator|==
name|flags
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|,
name|tvarPtr
operator|->
name|command
argument_list|,
operator|(
name|size_t
operator|)
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|Tcl_UntraceVar
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|flags
operator||
name|TCL_TRACE_UNSETS
argument_list|,
name|TraceVarProc
argument_list|,
name|clientData
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvarPtr
operator|->
name|errMsg
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|tvarPtr
operator|->
name|errMsg
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tvarPtr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'i'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"vinfo"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|2
operator|)
condition|)
block|{
name|ClientData
name|clientData
decl_stmt|;
name|char
name|ops
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|prefix
init|=
literal|"{"
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" vinfo name\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|clientData
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|clientData
operator|=
name|Tcl_VarTraceInfo
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
name|TraceVarProc
argument_list|,
name|clientData
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|TraceVarInfo
modifier|*
name|tvarPtr
init|=
operator|(
name|TraceVarInfo
operator|*
operator|)
name|clientData
decl_stmt|;
name|p
operator|=
name|ops
expr_stmt|;
if|if
condition|(
name|tvarPtr
operator|->
name|flags
operator|&
name|TCL_TRACE_READS
condition|)
block|{
operator|*
name|p
operator|=
literal|'r'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tvarPtr
operator|->
name|flags
operator|&
name|TCL_TRACE_WRITES
condition|)
block|{
operator|*
name|p
operator|=
literal|'w'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tvarPtr
operator|->
name|flags
operator|&
name|TCL_TRACE_UNSETS
condition|)
block|{
operator|*
name|p
operator|=
literal|'u'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|prefix
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|ops
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|tvarPtr
operator|->
name|command
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"}"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|prefix
operator|=
literal|" {"
expr_stmt|;
block|}
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": should be variable, vdelete, or vinfo"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
name|badOps
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad operations \""
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
literal|"\": should be one or more of rwu"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TraceVarProc --  *  *	This procedure is called to handle variable accesses that have  *	been traced using the "trace" command.  *  * Results:  *	Normally returns NULL.  If the trace command returns an error,  *	then this procedure returns an error string.  *  * Side effects:  *	Depends on the command associated with the trace.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|TraceVarProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|name1
parameter_list|,
name|name2
parameter_list|,
name|flags
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Information about the variable trace. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter containing variable. */
name|char
modifier|*
name|name1
decl_stmt|;
comment|/* Name of variable or array. */
name|char
modifier|*
name|name2
decl_stmt|;
comment|/* Name of element within array;  NULL means 				 * scalar variable is being referenced. */
name|int
name|flags
decl_stmt|;
comment|/* OR-ed bits giving operation and other 				 * information. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|TraceVarInfo
modifier|*
name|tvarPtr
init|=
operator|(
name|TraceVarInfo
operator|*
operator|)
name|clientData
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|int
name|code
decl_stmt|;
name|Interp
name|dummy
decl_stmt|;
name|Tcl_DString
name|cmd
decl_stmt|;
name|Tcl_Obj
modifier|*
name|saveObjPtr
decl_stmt|,
modifier|*
name|oldObjResultPtr
decl_stmt|;
name|result
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tvarPtr
operator|->
name|errMsg
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|tvarPtr
operator|->
name|errMsg
argument_list|)
expr_stmt|;
name|tvarPtr
operator|->
name|errMsg
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tvarPtr
operator|->
name|flags
operator|&
name|flags
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|TCL_INTERP_DESTROYED
operator|)
condition|)
block|{
comment|/* 	 * Generate a command to execute by appending list elements 	 * for the two variable names and the operation.  The five 	 * extra characters are for three space, the opcode character, 	 * and the terminating null. 	 */
if|if
condition|(
name|name2
operator|==
name|NULL
condition|)
block|{
name|name2
operator|=
literal|""
expr_stmt|;
block|}
name|Tcl_DStringInit
argument_list|(
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|cmd
argument_list|,
name|tvarPtr
operator|->
name|command
argument_list|,
name|tvarPtr
operator|->
name|length
argument_list|)
expr_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
operator|&
name|cmd
argument_list|,
name|name1
argument_list|)
expr_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
operator|&
name|cmd
argument_list|,
name|name2
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TCL_TRACE_READS
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|cmd
argument_list|,
literal|" r"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|TCL_TRACE_WRITES
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|cmd
argument_list|,
literal|" w"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|TCL_TRACE_UNSETS
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|cmd
argument_list|,
literal|" u"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Execute the command.  Be careful to save and restore both the 	 * string and object results from the interpreter used for 	 * the command. We discard any object result the command returns. 	 */
name|dummy
operator|.
name|objResultPtr
operator|=
name|Tcl_NewObj
argument_list|()
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|dummy
operator|.
name|objResultPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|interp
operator|->
name|freeProc
operator|==
literal|0
condition|)
block|{
name|dummy
operator|.
name|freeProc
operator|=
operator|(
name|Tcl_FreeProc
operator|*
operator|)
literal|0
expr_stmt|;
name|dummy
operator|.
name|result
operator|=
literal|""
expr_stmt|;
name|Tcl_SetResult
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
operator|&
name|dummy
argument_list|,
name|interp
operator|->
name|result
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dummy
operator|.
name|freeProc
operator|=
name|interp
operator|->
name|freeProc
expr_stmt|;
name|dummy
operator|.
name|result
operator|=
name|interp
operator|->
name|result
expr_stmt|;
name|interp
operator|->
name|freeProc
operator|=
operator|(
name|Tcl_FreeProc
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|saveObjPtr
operator|=
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|saveObjPtr
argument_list|)
expr_stmt|;
name|code
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|TCL_OK
condition|)
block|{
comment|/* copy error msg to result */
name|tvarPtr
operator|->
name|errMsg
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|interp
operator|->
name|result
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tvarPtr
operator|->
name|errMsg
argument_list|,
name|interp
operator|->
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
name|tvarPtr
operator|->
name|errMsg
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
comment|/* must clear error state. */
block|}
comment|/* 	 * Restore the interpreter's string result. 	 */
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|dummy
operator|.
name|result
argument_list|,
operator|(
name|dummy
operator|.
name|freeProc
operator|==
literal|0
operator|)
condition|?
name|TCL_VOLATILE
else|:
name|dummy
operator|.
name|freeProc
argument_list|)
expr_stmt|;
comment|/* 	 * Restore the interpreter's object result from saveObjPtr. 	 */
name|oldObjResultPtr
operator|=
name|iPtr
operator|->
name|objResultPtr
expr_stmt|;
name|iPtr
operator|->
name|objResultPtr
operator|=
name|saveObjPtr
expr_stmt|;
comment|/* was incremented above */
name|Tcl_DecrRefCount
argument_list|(
name|oldObjResultPtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|dummy
operator|.
name|objResultPtr
argument_list|)
expr_stmt|;
name|dummy
operator|.
name|objResultPtr
operator|=
name|NULL
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|cmd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|TCL_TRACE_DESTROYED
condition|)
block|{
name|result
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tvarPtr
operator|->
name|errMsg
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|tvarPtr
operator|->
name|errMsg
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tvarPtr
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_WhileCmd --  *  *      This procedure is invoked to process the "while" Tcl command.  *      See the user documentation for details on what it does.  *  *	With the bytecode compiler, this procedure is only called when  *	a command name is computed at runtime, and is "while" or the name  *	to which "while" was renamed: e.g., "set z while; $z {$i<100} {}"  *  * Results:  *      A standard Tcl result.  *  * Side effects:  *      See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_WhileCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|result
decl_stmt|,
name|value
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" test command\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|result
operator|=
name|Tcl_ExprBoolean
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
if|if
condition|(
operator|!
name|value
condition|)
block|{
break|break;
block|}
name|result
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|!=
name|TCL_OK
operator|)
operator|&&
operator|(
name|result
operator|!=
name|TCL_CONTINUE
operator|)
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|char
name|msg
index|[
literal|60
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n    (\"while\" body line %d)"
argument_list|,
name|interp
operator|->
name|errorLine
argument_list|)
expr_stmt|;
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|result
operator|==
name|TCL_BREAK
condition|)
block|{
name|result
operator|=
name|TCL_OK
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

end_unit

