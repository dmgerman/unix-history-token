begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclHash.c --  *  *	Implementation of in-memory hash tables for Tcl and Tcl-based  *	applications.  *  * Copyright (c) 1991-1993 The Regents of the University of California.  * Copyright (c) 1994 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclHash.c 1.15 96/02/15 11:50:23  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_comment
comment|/*  * When there are this many entries per bucket, on average, rebuild  * the hash table to make it larger.  */
end_comment

begin_define
define|#
directive|define
name|REBUILD_MULTIPLIER
value|3
end_define

begin_comment
comment|/*  * The following macro takes a preliminary integer hash value and  * produces an index into a hash tables bucket list.  The idea is  * to make it so that preliminary values that are arbitrarily similar  * will end up in different buckets.  The hash function was taken  * from a random-number generator.  */
end_comment

begin_define
define|#
directive|define
name|RANDOM_INDEX
parameter_list|(
name|tablePtr
parameter_list|,
name|i
parameter_list|)
define|\
value|(((((long) (i))*1103515245)>> (tablePtr)->downShift)& (tablePtr)->mask)
end_define

begin_comment
comment|/*  * Procedure prototypes for static procedures in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|Tcl_HashEntry
modifier|*
name|ArrayFind
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_HashTable
operator|*
name|tablePtr
operator|,
name|char
operator|*
name|key
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Tcl_HashEntry
modifier|*
name|ArrayCreate
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_HashTable
operator|*
name|tablePtr
operator|,
name|char
operator|*
name|key
operator|,
name|int
operator|*
name|newPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Tcl_HashEntry
modifier|*
name|BogusFind
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_HashTable
operator|*
name|tablePtr
operator|,
name|char
operator|*
name|key
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Tcl_HashEntry
modifier|*
name|BogusCreate
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_HashTable
operator|*
name|tablePtr
operator|,
name|char
operator|*
name|key
operator|,
name|int
operator|*
name|newPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|HashString
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|string
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|RebuildTable
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_HashTable
operator|*
name|tablePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Tcl_HashEntry
modifier|*
name|StringFind
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_HashTable
operator|*
name|tablePtr
operator|,
name|char
operator|*
name|key
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Tcl_HashEntry
modifier|*
name|StringCreate
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_HashTable
operator|*
name|tablePtr
operator|,
name|char
operator|*
name|key
operator|,
name|int
operator|*
name|newPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Tcl_HashEntry
modifier|*
name|OneWordFind
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_HashTable
operator|*
name|tablePtr
operator|,
name|char
operator|*
name|key
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Tcl_HashEntry
modifier|*
name|OneWordCreate
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_HashTable
operator|*
name|tablePtr
operator|,
name|char
operator|*
name|key
operator|,
name|int
operator|*
name|newPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_InitHashTable --  *  *	Given storage for a hash table, set up the fields to prepare  *	the hash table for use.  *  * Results:  *	None.  *  * Side effects:  *	TablePtr is now ready to be passed to Tcl_FindHashEntry and  *	Tcl_CreateHashEntry.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_InitHashTable
parameter_list|(
name|tablePtr
parameter_list|,
name|keyType
parameter_list|)
specifier|register
name|Tcl_HashTable
modifier|*
name|tablePtr
decl_stmt|;
comment|/* Pointer to table record, which 					 * is supplied by the caller. */
name|int
name|keyType
decl_stmt|;
comment|/* Type of keys to use in table: 					 * TCL_STRING_KEYS, TCL_ONE_WORD_KEYS, 					 * or an integer>= 2. */
block|{
name|tablePtr
operator|->
name|buckets
operator|=
name|tablePtr
operator|->
name|staticBuckets
expr_stmt|;
name|tablePtr
operator|->
name|staticBuckets
index|[
literal|0
index|]
operator|=
name|tablePtr
operator|->
name|staticBuckets
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tablePtr
operator|->
name|staticBuckets
index|[
literal|2
index|]
operator|=
name|tablePtr
operator|->
name|staticBuckets
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|tablePtr
operator|->
name|numBuckets
operator|=
name|TCL_SMALL_HASH_TABLE
expr_stmt|;
name|tablePtr
operator|->
name|numEntries
operator|=
literal|0
expr_stmt|;
name|tablePtr
operator|->
name|rebuildSize
operator|=
name|TCL_SMALL_HASH_TABLE
operator|*
name|REBUILD_MULTIPLIER
expr_stmt|;
name|tablePtr
operator|->
name|downShift
operator|=
literal|28
expr_stmt|;
name|tablePtr
operator|->
name|mask
operator|=
literal|3
expr_stmt|;
name|tablePtr
operator|->
name|keyType
operator|=
name|keyType
expr_stmt|;
if|if
condition|(
name|keyType
operator|==
name|TCL_STRING_KEYS
condition|)
block|{
name|tablePtr
operator|->
name|findProc
operator|=
name|StringFind
expr_stmt|;
name|tablePtr
operator|->
name|createProc
operator|=
name|StringCreate
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|keyType
operator|==
name|TCL_ONE_WORD_KEYS
condition|)
block|{
name|tablePtr
operator|->
name|findProc
operator|=
name|OneWordFind
expr_stmt|;
name|tablePtr
operator|->
name|createProc
operator|=
name|OneWordCreate
expr_stmt|;
block|}
else|else
block|{
name|tablePtr
operator|->
name|findProc
operator|=
name|ArrayFind
expr_stmt|;
name|tablePtr
operator|->
name|createProc
operator|=
name|ArrayCreate
expr_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DeleteHashEntry --  *  *	Remove a single entry from a hash table.  *  * Results:  *	None.  *  * Side effects:  *	The entry given by entryPtr is deleted from its table and  *	should never again be used by the caller.  It is up to the  *	caller to free the clientData field of the entry, if that  *	is relevant.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DeleteHashEntry
parameter_list|(
name|entryPtr
parameter_list|)
name|Tcl_HashEntry
modifier|*
name|entryPtr
decl_stmt|;
block|{
specifier|register
name|Tcl_HashEntry
modifier|*
name|prevPtr
decl_stmt|;
if|if
condition|(
operator|*
name|entryPtr
operator|->
name|bucketPtr
operator|==
name|entryPtr
condition|)
block|{
operator|*
name|entryPtr
operator|->
name|bucketPtr
operator|=
name|entryPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|prevPtr
operator|=
operator|*
name|entryPtr
operator|->
name|bucketPtr
init|;
condition|;
name|prevPtr
operator|=
name|prevPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|prevPtr
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"malformed bucket chain in Tcl_DeleteHashEntry"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prevPtr
operator|->
name|nextPtr
operator|==
name|entryPtr
condition|)
block|{
name|prevPtr
operator|->
name|nextPtr
operator|=
name|entryPtr
operator|->
name|nextPtr
expr_stmt|;
break|break;
block|}
block|}
block|}
name|entryPtr
operator|->
name|tablePtr
operator|->
name|numEntries
operator|--
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|entryPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DeleteHashTable --  *  *	Free up everything associated with a hash table except for  *	the record for the table itself.  *  * Results:  *	None.  *  * Side effects:  *	The hash table is no longer useable.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DeleteHashTable
parameter_list|(
name|tablePtr
parameter_list|)
specifier|register
name|Tcl_HashTable
modifier|*
name|tablePtr
decl_stmt|;
comment|/* Table to delete. */
block|{
specifier|register
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|,
modifier|*
name|nextPtr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*      * Free up all the entries in the table.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tablePtr
operator|->
name|numBuckets
condition|;
name|i
operator|++
control|)
block|{
name|hPtr
operator|=
name|tablePtr
operator|->
name|buckets
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|hPtr
operator|!=
name|NULL
condition|)
block|{
name|nextPtr
operator|=
name|hPtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hPtr
argument_list|)
expr_stmt|;
name|hPtr
operator|=
name|nextPtr
expr_stmt|;
block|}
block|}
comment|/*      * Free up the bucket array, if it was dynamically allocated.      */
if|if
condition|(
name|tablePtr
operator|->
name|buckets
operator|!=
name|tablePtr
operator|->
name|staticBuckets
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tablePtr
operator|->
name|buckets
argument_list|)
expr_stmt|;
block|}
comment|/*      * Arrange for panics if the table is used again without      * re-initialization.      */
name|tablePtr
operator|->
name|findProc
operator|=
name|BogusFind
expr_stmt|;
name|tablePtr
operator|->
name|createProc
operator|=
name|BogusCreate
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_FirstHashEntry --  *  *	Locate the first entry in a hash table and set up a record  *	that can be used to step through all the remaining entries  *	of the table.  *  * Results:  *	The return value is a pointer to the first entry in tablePtr,  *	or NULL if tablePtr has no entries in it.  The memory at  *	*searchPtr is initialized so that subsequent calls to  *	Tcl_NextHashEntry will return all of the entries in the table,  *	one at a time.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_HashEntry
modifier|*
name|Tcl_FirstHashEntry
parameter_list|(
name|tablePtr
parameter_list|,
name|searchPtr
parameter_list|)
name|Tcl_HashTable
modifier|*
name|tablePtr
decl_stmt|;
comment|/* Table to search. */
name|Tcl_HashSearch
modifier|*
name|searchPtr
decl_stmt|;
comment|/* Place to store information about 					 * progress through the table. */
block|{
name|searchPtr
operator|->
name|tablePtr
operator|=
name|tablePtr
expr_stmt|;
name|searchPtr
operator|->
name|nextIndex
operator|=
literal|0
expr_stmt|;
name|searchPtr
operator|->
name|nextEntryPtr
operator|=
name|NULL
expr_stmt|;
return|return
name|Tcl_NextHashEntry
argument_list|(
name|searchPtr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_NextHashEntry --  *  *	Once a hash table enumeration has been initiated by calling  *	Tcl_FirstHashEntry, this procedure may be called to return  *	successive elements of the table.  *  * Results:  *	The return value is the next entry in the hash table being  *	enumerated, or NULL if the end of the table is reached.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_HashEntry
modifier|*
name|Tcl_NextHashEntry
parameter_list|(
name|searchPtr
parameter_list|)
specifier|register
name|Tcl_HashSearch
modifier|*
name|searchPtr
decl_stmt|;
comment|/* Place to store information about 					 * progress through the table.  Must 					 * have been initialized by calling 					 * Tcl_FirstHashEntry. */
block|{
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
while|while
condition|(
name|searchPtr
operator|->
name|nextEntryPtr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|searchPtr
operator|->
name|nextIndex
operator|>=
name|searchPtr
operator|->
name|tablePtr
operator|->
name|numBuckets
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|searchPtr
operator|->
name|nextEntryPtr
operator|=
name|searchPtr
operator|->
name|tablePtr
operator|->
name|buckets
index|[
name|searchPtr
operator|->
name|nextIndex
index|]
expr_stmt|;
name|searchPtr
operator|->
name|nextIndex
operator|++
expr_stmt|;
block|}
name|hPtr
operator|=
name|searchPtr
operator|->
name|nextEntryPtr
expr_stmt|;
name|searchPtr
operator|->
name|nextEntryPtr
operator|=
name|hPtr
operator|->
name|nextPtr
expr_stmt|;
return|return
name|hPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_HashStats --  *  *	Return statistics describing the layout of the hash table  *	in its hash buckets.  *  * Results:  *	The return value is a malloc-ed string containing information  *	about tablePtr.  It is the caller's responsibility to free  *	this string.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_HashStats
parameter_list|(
name|tablePtr
parameter_list|)
name|Tcl_HashTable
modifier|*
name|tablePtr
decl_stmt|;
comment|/* Table for which to produce stats. */
block|{
define|#
directive|define
name|NUM_COUNTERS
value|10
name|int
name|count
index|[
name|NUM_COUNTERS
index|]
decl_stmt|,
name|overflow
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|double
name|average
decl_stmt|,
name|tmp
decl_stmt|;
specifier|register
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|,
modifier|*
name|p
decl_stmt|;
comment|/*      * Compute a histogram of bucket usage.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_COUNTERS
condition|;
name|i
operator|++
control|)
block|{
name|count
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|overflow
operator|=
literal|0
expr_stmt|;
name|average
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tablePtr
operator|->
name|numBuckets
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|hPtr
operator|=
name|tablePtr
operator|->
name|buckets
index|[
name|i
index|]
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|hPtr
operator|->
name|nextPtr
control|)
block|{
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|<
name|NUM_COUNTERS
condition|)
block|{
name|count
index|[
name|j
index|]
operator|++
expr_stmt|;
block|}
else|else
block|{
name|overflow
operator|++
expr_stmt|;
block|}
name|tmp
operator|=
name|j
expr_stmt|;
name|average
operator|+=
operator|(
name|tmp
operator|+
literal|1.0
operator|)
operator|*
operator|(
name|tmp
operator|/
name|tablePtr
operator|->
name|numEntries
operator|)
operator|/
literal|2.0
expr_stmt|;
block|}
comment|/*      * Print out the histogram and a few other pieces of information.      */
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|NUM_COUNTERS
operator|*
literal|60
operator|)
operator|+
literal|300
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"%d entries in table, %d buckets\n"
argument_list|,
name|tablePtr
operator|->
name|numEntries
argument_list|,
name|tablePtr
operator|->
name|numBuckets
argument_list|)
expr_stmt|;
name|p
operator|=
name|result
operator|+
name|strlen
argument_list|(
name|result
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_COUNTERS
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"number of buckets with %d entries: %d\n"
argument_list|,
name|i
argument_list|,
name|count
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"number of buckets with %d or more entries: %d\n"
argument_list|,
name|NUM_COUNTERS
argument_list|,
name|overflow
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"average search distance for entry: %.1f"
argument_list|,
name|average
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * HashString --  *  *	Compute a one-word summary of a text string, which can be  *	used to generate a hash index.  *  * Results:  *	The return value is a one-word summary of the information in  *	string.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|HashString
parameter_list|(
name|string
parameter_list|)
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String from which to compute hash value. */
block|{
specifier|register
name|unsigned
name|int
name|result
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
comment|/*      * I tried a zillion different hash functions and asked many other      * people for advice.  Many people had their own favorite functions,      * all different, but no-one had much idea why they were good ones.      * I chose the one below (multiply by 9 and add new character)      * because of the following reasons:      *      * 1. Multiplying by 10 is perfect for keys that are decimal strings,      *    and multiplying by 9 is just about as good.      * 2. Times-9 is (shift-left-3) plus (old).  This means that each      *    character's bits hang around in the low-order bits of the      *    hash value for ever, plus they spread fairly rapidly up to      *    the high-order bits to fill out the hash value.  This seems      *    works well both for decimal and non-decimal strings.      */
name|result
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
operator|*
name|string
expr_stmt|;
name|string
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|result
operator|+=
operator|(
name|result
operator|<<
literal|3
operator|)
operator|+
name|c
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * StringFind --  *  *	Given a hash table with string keys, and a string key, find  *	the entry with a matching key.  *  * Results:  *	The return value is a token for the matching entry in the  *	hash table, or NULL if there was no matching entry.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Tcl_HashEntry
modifier|*
name|StringFind
parameter_list|(
name|tablePtr
parameter_list|,
name|key
parameter_list|)
name|Tcl_HashTable
modifier|*
name|tablePtr
decl_stmt|;
comment|/* Table in which to lookup entry. */
name|char
modifier|*
name|key
decl_stmt|;
comment|/* Key to use to find matching entry. */
block|{
specifier|register
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|int
name|index
decl_stmt|;
name|index
operator|=
name|HashString
argument_list|(
name|key
argument_list|)
operator|&
name|tablePtr
operator|->
name|mask
expr_stmt|;
comment|/*      * Search all of the entries in the appropriate bucket.      */
for|for
control|(
name|hPtr
operator|=
name|tablePtr
operator|->
name|buckets
index|[
name|index
index|]
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|hPtr
operator|->
name|nextPtr
control|)
block|{
for|for
control|(
name|p1
operator|=
name|key
operator|,
name|p2
operator|=
name|hPtr
operator|->
name|key
operator|.
name|string
init|;
condition|;
name|p1
operator|++
operator|,
name|p2
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p1
operator|!=
operator|*
name|p2
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|*
name|p1
operator|==
literal|'\0'
condition|)
block|{
return|return
name|hPtr
return|;
block|}
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * StringCreate --  *  *	Given a hash table with string keys, and a string key, find  *	the entry with a matching key.  If there is no matching entry,  *	then create a new entry that does match.  *  * Results:  *	The return value is a pointer to the matching entry.  If this  *	is a newly-created entry, then *newPtr will be set to a non-zero  *	value;  otherwise *newPtr will be set to 0.  If this is a new  *	entry the value stored in the entry will initially be 0.  *  * Side effects:  *	A new entry may be added to the hash table.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Tcl_HashEntry
modifier|*
name|StringCreate
parameter_list|(
name|tablePtr
parameter_list|,
name|key
parameter_list|,
name|newPtr
parameter_list|)
name|Tcl_HashTable
modifier|*
name|tablePtr
decl_stmt|;
comment|/* Table in which to lookup entry. */
name|char
modifier|*
name|key
decl_stmt|;
comment|/* Key to use to find or create matching 				 * entry. */
name|int
modifier|*
name|newPtr
decl_stmt|;
comment|/* Store info here telling whether a new 				 * entry was created. */
block|{
specifier|register
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|int
name|index
decl_stmt|;
name|index
operator|=
name|HashString
argument_list|(
name|key
argument_list|)
operator|&
name|tablePtr
operator|->
name|mask
expr_stmt|;
comment|/*      * Search all of the entries in this bucket.      */
for|for
control|(
name|hPtr
operator|=
name|tablePtr
operator|->
name|buckets
index|[
name|index
index|]
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|hPtr
operator|->
name|nextPtr
control|)
block|{
for|for
control|(
name|p1
operator|=
name|key
operator|,
name|p2
operator|=
name|hPtr
operator|->
name|key
operator|.
name|string
init|;
condition|;
name|p1
operator|++
operator|,
name|p2
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p1
operator|!=
operator|*
name|p2
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|*
name|p1
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|newPtr
operator|=
literal|0
expr_stmt|;
return|return
name|hPtr
return|;
block|}
block|}
block|}
comment|/*      * Entry not found.  Add a new one to the bucket.      */
operator|*
name|newPtr
operator|=
literal|1
expr_stmt|;
name|hPtr
operator|=
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|Tcl_HashEntry
argument_list|)
operator|+
name|strlen
argument_list|(
name|key
argument_list|)
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|hPtr
operator|->
name|key
argument_list|)
operator|-
literal|1
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|hPtr
operator|->
name|tablePtr
operator|=
name|tablePtr
expr_stmt|;
name|hPtr
operator|->
name|bucketPtr
operator|=
operator|&
operator|(
name|tablePtr
operator|->
name|buckets
index|[
name|index
index|]
operator|)
expr_stmt|;
name|hPtr
operator|->
name|nextPtr
operator|=
operator|*
name|hPtr
operator|->
name|bucketPtr
expr_stmt|;
name|hPtr
operator|->
name|clientData
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|hPtr
operator|->
name|key
operator|.
name|string
argument_list|,
name|key
argument_list|)
expr_stmt|;
operator|*
name|hPtr
operator|->
name|bucketPtr
operator|=
name|hPtr
expr_stmt|;
name|tablePtr
operator|->
name|numEntries
operator|++
expr_stmt|;
comment|/*      * If the table has exceeded a decent size, rebuild it with many      * more buckets.      */
if|if
condition|(
name|tablePtr
operator|->
name|numEntries
operator|>=
name|tablePtr
operator|->
name|rebuildSize
condition|)
block|{
name|RebuildTable
argument_list|(
name|tablePtr
argument_list|)
expr_stmt|;
block|}
return|return
name|hPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * OneWordFind --  *  *	Given a hash table with one-word keys, and a one-word key, find  *	the entry with a matching key.  *  * Results:  *	The return value is a token for the matching entry in the  *	hash table, or NULL if there was no matching entry.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Tcl_HashEntry
modifier|*
name|OneWordFind
parameter_list|(
name|tablePtr
parameter_list|,
name|key
parameter_list|)
name|Tcl_HashTable
modifier|*
name|tablePtr
decl_stmt|;
comment|/* Table in which to lookup entry. */
specifier|register
name|char
modifier|*
name|key
decl_stmt|;
comment|/* Key to use to find matching entry. */
block|{
specifier|register
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|int
name|index
decl_stmt|;
name|index
operator|=
name|RANDOM_INDEX
argument_list|(
name|tablePtr
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|/*      * Search all of the entries in the appropriate bucket.      */
for|for
control|(
name|hPtr
operator|=
name|tablePtr
operator|->
name|buckets
index|[
name|index
index|]
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|hPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|hPtr
operator|->
name|key
operator|.
name|oneWordValue
operator|==
name|key
condition|)
block|{
return|return
name|hPtr
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * OneWordCreate --  *  *	Given a hash table with one-word keys, and a one-word key, find  *	the entry with a matching key.  If there is no matching entry,  *	then create a new entry that does match.  *  * Results:  *	The return value is a pointer to the matching entry.  If this  *	is a newly-created entry, then *newPtr will be set to a non-zero  *	value;  otherwise *newPtr will be set to 0.  If this is a new  *	entry the value stored in the entry will initially be 0.  *  * Side effects:  *	A new entry may be added to the hash table.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Tcl_HashEntry
modifier|*
name|OneWordCreate
parameter_list|(
name|tablePtr
parameter_list|,
name|key
parameter_list|,
name|newPtr
parameter_list|)
name|Tcl_HashTable
modifier|*
name|tablePtr
decl_stmt|;
comment|/* Table in which to lookup entry. */
specifier|register
name|char
modifier|*
name|key
decl_stmt|;
comment|/* Key to use to find or create matching 				 * entry. */
name|int
modifier|*
name|newPtr
decl_stmt|;
comment|/* Store info here telling whether a new 				 * entry was created. */
block|{
specifier|register
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|int
name|index
decl_stmt|;
name|index
operator|=
name|RANDOM_INDEX
argument_list|(
name|tablePtr
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|/*      * Search all of the entries in this bucket.      */
for|for
control|(
name|hPtr
operator|=
name|tablePtr
operator|->
name|buckets
index|[
name|index
index|]
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|hPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|hPtr
operator|->
name|key
operator|.
name|oneWordValue
operator|==
name|key
condition|)
block|{
operator|*
name|newPtr
operator|=
literal|0
expr_stmt|;
return|return
name|hPtr
return|;
block|}
block|}
comment|/*      * Entry not found.  Add a new one to the bucket.      */
operator|*
name|newPtr
operator|=
literal|1
expr_stmt|;
name|hPtr
operator|=
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Tcl_HashEntry
argument_list|)
argument_list|)
expr_stmt|;
name|hPtr
operator|->
name|tablePtr
operator|=
name|tablePtr
expr_stmt|;
name|hPtr
operator|->
name|bucketPtr
operator|=
operator|&
operator|(
name|tablePtr
operator|->
name|buckets
index|[
name|index
index|]
operator|)
expr_stmt|;
name|hPtr
operator|->
name|nextPtr
operator|=
operator|*
name|hPtr
operator|->
name|bucketPtr
expr_stmt|;
name|hPtr
operator|->
name|clientData
operator|=
literal|0
expr_stmt|;
name|hPtr
operator|->
name|key
operator|.
name|oneWordValue
operator|=
name|key
expr_stmt|;
operator|*
name|hPtr
operator|->
name|bucketPtr
operator|=
name|hPtr
expr_stmt|;
name|tablePtr
operator|->
name|numEntries
operator|++
expr_stmt|;
comment|/*      * If the table has exceeded a decent size, rebuild it with many      * more buckets.      */
if|if
condition|(
name|tablePtr
operator|->
name|numEntries
operator|>=
name|tablePtr
operator|->
name|rebuildSize
condition|)
block|{
name|RebuildTable
argument_list|(
name|tablePtr
argument_list|)
expr_stmt|;
block|}
return|return
name|hPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * ArrayFind --  *  *	Given a hash table with array-of-int keys, and a key, find  *	the entry with a matching key.  *  * Results:  *	The return value is a token for the matching entry in the  *	hash table, or NULL if there was no matching entry.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Tcl_HashEntry
modifier|*
name|ArrayFind
parameter_list|(
name|tablePtr
parameter_list|,
name|key
parameter_list|)
name|Tcl_HashTable
modifier|*
name|tablePtr
decl_stmt|;
comment|/* Table in which to lookup entry. */
name|char
modifier|*
name|key
decl_stmt|;
comment|/* Key to use to find matching entry. */
block|{
specifier|register
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|int
modifier|*
name|arrayPtr
init|=
operator|(
name|int
operator|*
operator|)
name|key
decl_stmt|;
specifier|register
name|int
modifier|*
name|iPtr1
decl_stmt|,
modifier|*
name|iPtr2
decl_stmt|;
name|int
name|index
decl_stmt|,
name|count
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
operator|,
name|count
operator|=
name|tablePtr
operator|->
name|keyType
operator|,
name|iPtr1
operator|=
name|arrayPtr
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|iPtr1
operator|++
control|)
block|{
name|index
operator|+=
operator|*
name|iPtr1
expr_stmt|;
block|}
name|index
operator|=
name|RANDOM_INDEX
argument_list|(
name|tablePtr
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/*      * Search all of the entries in the appropriate bucket.      */
for|for
control|(
name|hPtr
operator|=
name|tablePtr
operator|->
name|buckets
index|[
name|index
index|]
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|hPtr
operator|->
name|nextPtr
control|)
block|{
for|for
control|(
name|iPtr1
operator|=
name|arrayPtr
operator|,
name|iPtr2
operator|=
name|hPtr
operator|->
name|key
operator|.
name|words
operator|,
name|count
operator|=
name|tablePtr
operator|->
name|keyType
init|;
condition|;
name|count
operator|--
operator|,
name|iPtr1
operator|++
operator|,
name|iPtr2
operator|++
control|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
return|return
name|hPtr
return|;
block|}
if|if
condition|(
operator|*
name|iPtr1
operator|!=
operator|*
name|iPtr2
condition|)
block|{
break|break;
block|}
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * ArrayCreate --  *  *	Given a hash table with one-word keys, and a one-word key, find  *	the entry with a matching key.  If there is no matching entry,  *	then create a new entry that does match.  *  * Results:  *	The return value is a pointer to the matching entry.  If this  *	is a newly-created entry, then *newPtr will be set to a non-zero  *	value;  otherwise *newPtr will be set to 0.  If this is a new  *	entry the value stored in the entry will initially be 0.  *  * Side effects:  *	A new entry may be added to the hash table.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Tcl_HashEntry
modifier|*
name|ArrayCreate
parameter_list|(
name|tablePtr
parameter_list|,
name|key
parameter_list|,
name|newPtr
parameter_list|)
name|Tcl_HashTable
modifier|*
name|tablePtr
decl_stmt|;
comment|/* Table in which to lookup entry. */
specifier|register
name|char
modifier|*
name|key
decl_stmt|;
comment|/* Key to use to find or create matching 				 * entry. */
name|int
modifier|*
name|newPtr
decl_stmt|;
comment|/* Store info here telling whether a new 				 * entry was created. */
block|{
specifier|register
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|int
modifier|*
name|arrayPtr
init|=
operator|(
name|int
operator|*
operator|)
name|key
decl_stmt|;
specifier|register
name|int
modifier|*
name|iPtr1
decl_stmt|,
modifier|*
name|iPtr2
decl_stmt|;
name|int
name|index
decl_stmt|,
name|count
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
operator|,
name|count
operator|=
name|tablePtr
operator|->
name|keyType
operator|,
name|iPtr1
operator|=
name|arrayPtr
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|iPtr1
operator|++
control|)
block|{
name|index
operator|+=
operator|*
name|iPtr1
expr_stmt|;
block|}
name|index
operator|=
name|RANDOM_INDEX
argument_list|(
name|tablePtr
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/*      * Search all of the entries in the appropriate bucket.      */
for|for
control|(
name|hPtr
operator|=
name|tablePtr
operator|->
name|buckets
index|[
name|index
index|]
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|hPtr
operator|->
name|nextPtr
control|)
block|{
for|for
control|(
name|iPtr1
operator|=
name|arrayPtr
operator|,
name|iPtr2
operator|=
name|hPtr
operator|->
name|key
operator|.
name|words
operator|,
name|count
operator|=
name|tablePtr
operator|->
name|keyType
init|;
condition|;
name|count
operator|--
operator|,
name|iPtr1
operator|++
operator|,
name|iPtr2
operator|++
control|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
operator|*
name|newPtr
operator|=
literal|0
expr_stmt|;
return|return
name|hPtr
return|;
block|}
if|if
condition|(
operator|*
name|iPtr1
operator|!=
operator|*
name|iPtr2
condition|)
block|{
break|break;
block|}
block|}
block|}
comment|/*      * Entry not found.  Add a new one to the bucket.      */
operator|*
name|newPtr
operator|=
literal|1
expr_stmt|;
name|hPtr
operator|=
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|Tcl_HashEntry
argument_list|)
operator|+
operator|(
name|tablePtr
operator|->
name|keyType
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|-
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|hPtr
operator|->
name|tablePtr
operator|=
name|tablePtr
expr_stmt|;
name|hPtr
operator|->
name|bucketPtr
operator|=
operator|&
operator|(
name|tablePtr
operator|->
name|buckets
index|[
name|index
index|]
operator|)
expr_stmt|;
name|hPtr
operator|->
name|nextPtr
operator|=
operator|*
name|hPtr
operator|->
name|bucketPtr
expr_stmt|;
name|hPtr
operator|->
name|clientData
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|iPtr1
operator|=
name|arrayPtr
operator|,
name|iPtr2
operator|=
name|hPtr
operator|->
name|key
operator|.
name|words
operator|,
name|count
operator|=
name|tablePtr
operator|->
name|keyType
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|iPtr1
operator|++
operator|,
name|iPtr2
operator|++
control|)
block|{
operator|*
name|iPtr2
operator|=
operator|*
name|iPtr1
expr_stmt|;
block|}
operator|*
name|hPtr
operator|->
name|bucketPtr
operator|=
name|hPtr
expr_stmt|;
name|tablePtr
operator|->
name|numEntries
operator|++
expr_stmt|;
comment|/*      * If the table has exceeded a decent size, rebuild it with many      * more buckets.      */
if|if
condition|(
name|tablePtr
operator|->
name|numEntries
operator|>=
name|tablePtr
operator|->
name|rebuildSize
condition|)
block|{
name|RebuildTable
argument_list|(
name|tablePtr
argument_list|)
expr_stmt|;
block|}
return|return
name|hPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * BogusFind --  *  *	This procedure is invoked when an Tcl_FindHashEntry is called  *	on a table that has been deleted.  *  * Results:  *	If panic returns (which it shouldn't) this procedure returns  *	NULL.  *  * Side effects:  *	Generates a panic.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|Tcl_HashEntry
modifier|*
name|BogusFind
parameter_list|(
name|tablePtr
parameter_list|,
name|key
parameter_list|)
name|Tcl_HashTable
modifier|*
name|tablePtr
decl_stmt|;
comment|/* Table in which to lookup entry. */
name|char
modifier|*
name|key
decl_stmt|;
comment|/* Key to use to find matching entry. */
block|{
name|panic
argument_list|(
literal|"called Tcl_FindHashEntry on deleted table"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * BogusCreate --  *  *	This procedure is invoked when an Tcl_CreateHashEntry is called  *	on a table that has been deleted.  *  * Results:  *	If panic returns (which it shouldn't) this procedure returns  *	NULL.  *  * Side effects:  *	Generates a panic.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|Tcl_HashEntry
modifier|*
name|BogusCreate
parameter_list|(
name|tablePtr
parameter_list|,
name|key
parameter_list|,
name|newPtr
parameter_list|)
name|Tcl_HashTable
modifier|*
name|tablePtr
decl_stmt|;
comment|/* Table in which to lookup entry. */
name|char
modifier|*
name|key
decl_stmt|;
comment|/* Key to use to find or create matching 				 * entry. */
name|int
modifier|*
name|newPtr
decl_stmt|;
comment|/* Store info here telling whether a new 				 * entry was created. */
block|{
name|panic
argument_list|(
literal|"called Tcl_CreateHashEntry on deleted table"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * RebuildTable --  *  *	This procedure is invoked when the ratio of entries to hash  *	buckets becomes too large.  It creates a new table with a  *	larger bucket array and moves all of the entries into the  *	new table.  *  * Results:  *	None.  *  * Side effects:  *	Memory gets reallocated and entries get re-hashed to new  *	buckets.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|RebuildTable
parameter_list|(
name|tablePtr
parameter_list|)
specifier|register
name|Tcl_HashTable
modifier|*
name|tablePtr
decl_stmt|;
comment|/* Table to enlarge. */
block|{
name|int
name|oldSize
decl_stmt|,
name|count
decl_stmt|,
name|index
decl_stmt|;
name|Tcl_HashEntry
modifier|*
modifier|*
name|oldBuckets
decl_stmt|;
specifier|register
name|Tcl_HashEntry
modifier|*
modifier|*
name|oldChainPtr
decl_stmt|,
modifier|*
modifier|*
name|newChainPtr
decl_stmt|;
specifier|register
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|oldSize
operator|=
name|tablePtr
operator|->
name|numBuckets
expr_stmt|;
name|oldBuckets
operator|=
name|tablePtr
operator|->
name|buckets
expr_stmt|;
comment|/*      * Allocate and initialize the new bucket array, and set up      * hashing constants for new array size.      */
name|tablePtr
operator|->
name|numBuckets
operator|*=
literal|4
expr_stmt|;
name|tablePtr
operator|->
name|buckets
operator|=
operator|(
name|Tcl_HashEntry
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|tablePtr
operator|->
name|numBuckets
operator|*
sizeof|sizeof
argument_list|(
name|Tcl_HashEntry
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
name|tablePtr
operator|->
name|numBuckets
operator|,
name|newChainPtr
operator|=
name|tablePtr
operator|->
name|buckets
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|newChainPtr
operator|++
control|)
block|{
operator|*
name|newChainPtr
operator|=
name|NULL
expr_stmt|;
block|}
name|tablePtr
operator|->
name|rebuildSize
operator|*=
literal|4
expr_stmt|;
name|tablePtr
operator|->
name|downShift
operator|-=
literal|2
expr_stmt|;
name|tablePtr
operator|->
name|mask
operator|=
operator|(
name|tablePtr
operator|->
name|mask
operator|<<
literal|2
operator|)
operator|+
literal|3
expr_stmt|;
comment|/*      * Rehash all of the existing entries into the new bucket array.      */
for|for
control|(
name|oldChainPtr
operator|=
name|oldBuckets
init|;
name|oldSize
operator|>
literal|0
condition|;
name|oldSize
operator|--
operator|,
name|oldChainPtr
operator|++
control|)
block|{
for|for
control|(
name|hPtr
operator|=
operator|*
name|oldChainPtr
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
operator|*
name|oldChainPtr
control|)
block|{
operator|*
name|oldChainPtr
operator|=
name|hPtr
operator|->
name|nextPtr
expr_stmt|;
if|if
condition|(
name|tablePtr
operator|->
name|keyType
operator|==
name|TCL_STRING_KEYS
condition|)
block|{
name|index
operator|=
name|HashString
argument_list|(
name|hPtr
operator|->
name|key
operator|.
name|string
argument_list|)
operator|&
name|tablePtr
operator|->
name|mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tablePtr
operator|->
name|keyType
operator|==
name|TCL_ONE_WORD_KEYS
condition|)
block|{
name|index
operator|=
name|RANDOM_INDEX
argument_list|(
name|tablePtr
argument_list|,
name|hPtr
operator|->
name|key
operator|.
name|oneWordValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|int
modifier|*
name|iPtr
decl_stmt|;
name|int
name|count
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
operator|,
name|count
operator|=
name|tablePtr
operator|->
name|keyType
operator|,
name|iPtr
operator|=
name|hPtr
operator|->
name|key
operator|.
name|words
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|iPtr
operator|++
control|)
block|{
name|index
operator|+=
operator|*
name|iPtr
expr_stmt|;
block|}
name|index
operator|=
name|RANDOM_INDEX
argument_list|(
name|tablePtr
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|hPtr
operator|->
name|bucketPtr
operator|=
operator|&
operator|(
name|tablePtr
operator|->
name|buckets
index|[
name|index
index|]
operator|)
expr_stmt|;
name|hPtr
operator|->
name|nextPtr
operator|=
operator|*
name|hPtr
operator|->
name|bucketPtr
expr_stmt|;
operator|*
name|hPtr
operator|->
name|bucketPtr
operator|=
name|hPtr
expr_stmt|;
block|}
block|}
comment|/*      * Free up the old bucket array, if it was dynamically allocated.      */
if|if
condition|(
name|oldBuckets
operator|!=
name|tablePtr
operator|->
name|staticBuckets
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|oldBuckets
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

