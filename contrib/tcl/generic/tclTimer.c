begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclTimer.c --  *  *	This file provides timer event management facilities for Tcl,  *	including the "after" command.  *  * Copyright (c) 1997 by Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclTimer.c 1.9 97/07/29 16:21:53  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * This flag indicates whether this module has been initialized.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * For each timer callback that's pending there is one record of the following  * type.  The normal handlers (created by Tcl_CreateTimerHandler) are chained  * together in a list sorted by time (earliest event first).  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|TimerHandler
block|{
name|Tcl_Time
name|time
decl_stmt|;
comment|/* When timer is to fire. */
name|Tcl_TimerProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to call. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Argument to pass to proc. */
name|Tcl_TimerToken
name|token
decl_stmt|;
comment|/* Identifies handler so it can be 					 * deleted. */
name|struct
name|TimerHandler
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next event in queue, or NULL for 					 * end of queue. */
block|}
name|TimerHandler
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|TimerHandler
modifier|*
name|firstTimerHandlerPtr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First event in queue. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lastTimerId
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Timer identifier of most recently 					 * created timer. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|timerPending
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if a timer event is in the queue. */
end_comment

begin_comment
comment|/*  * The data structure below is used by the "after" command to remember  * the command to be executed later.  All of the pending "after" commands  * for an interpreter are linked together in a list.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|AfterInfo
block|{
name|struct
name|AfterAssocData
modifier|*
name|assocPtr
decl_stmt|;
comment|/* Pointer to the "tclAfter" assocData for 				 * the interp in which command will be 				 * executed. */
name|char
modifier|*
name|command
decl_stmt|;
comment|/* Command to execute.  Malloc'ed, so must 				 * be freed when structure is deallocated. */
name|int
name|id
decl_stmt|;
comment|/* Integer identifier for command;  used to 				 * cancel it. */
name|Tcl_TimerToken
name|token
decl_stmt|;
comment|/* Used to cancel the "after" command.  NULL 				 * means that the command is run as an 				 * idle handler rather than as a timer 				 * handler.  NULL means this is an "after 				 * idle" handler rather than a                                  * timer handler. */
name|struct
name|AfterInfo
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next in list of all "after" commands for 				 * this interpreter. */
block|}
name|AfterInfo
typedef|;
end_typedef

begin_comment
comment|/*  * One of the following structures is associated with each interpreter  * for which an "after" command has ever been invoked.  A pointer to  * this structure is stored in the AssocData for the "tclAfter" key.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|AfterAssocData
block|{
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interpreter for which this data is 				 * registered. */
name|AfterInfo
modifier|*
name|firstAfterPtr
decl_stmt|;
comment|/* First in list of all "after" commands 				 * still pending for this interpreter, or 				 * NULL if none. */
block|}
name|AfterAssocData
typedef|;
end_typedef

begin_comment
comment|/*  * There is one of the following structures for each of the  * handlers declared in a call to Tcl_DoWhenIdle.  All of the  * currently-active handlers are linked together into a list.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|IdleHandler
block|{
name|Tcl_IdleProc
argument_list|(
operator|*
name|proc
argument_list|)
expr_stmt|;
comment|/* Procedure to call. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Value to pass to proc. */
name|int
name|generation
decl_stmt|;
comment|/* Used to distinguish older handlers from 				 * recently-created ones. */
name|struct
name|IdleHandler
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next in list of active handlers. */
block|}
name|IdleHandler
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|IdleHandler
modifier|*
name|idleList
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First in list of all idle handlers. */
end_comment

begin_decl_stmt
specifier|static
name|IdleHandler
modifier|*
name|lastIdlePtr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last in list (or NULL for empty list). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|idleGeneration
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to fill in the "generation" fields 				 * of IdleHandler structures.  Increments 				 * each time Tcl_DoOneEvent starts calling 				 * idle handlers, so that all old handlers 				 * can be called without calling any of the 				 * new ones created by old ones. */
end_comment

begin_comment
comment|/*  * Prototypes for procedures referenced only in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|AfterCleanupProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|AfterProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|FreeAfterPtr
name|_ANSI_ARGS_
argument_list|(
operator|(
name|AfterInfo
operator|*
name|afterPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|AfterInfo
modifier|*
name|GetAfterEvent
name|_ANSI_ARGS_
argument_list|(
operator|(
name|AfterAssocData
operator|*
name|assocPtr
operator|,
name|char
operator|*
name|string
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|InitTimer
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|TimerExitProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TimerHandlerEventProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Event
operator|*
name|evPtr
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|TimerCheckProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|TimerSetupProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InitTimer --  *  *	This function initializes the timer module.  *  * Results:  *	None.  *  * Side effects:  *	Registers the idle and timer event sources.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|InitTimer
parameter_list|()
block|{
name|initialized
operator|=
literal|1
expr_stmt|;
name|lastTimerId
operator|=
literal|0
expr_stmt|;
name|timerPending
operator|=
literal|0
expr_stmt|;
name|idleGeneration
operator|=
literal|0
expr_stmt|;
name|firstTimerHandlerPtr
operator|=
name|NULL
expr_stmt|;
name|lastIdlePtr
operator|=
name|NULL
expr_stmt|;
name|idleList
operator|=
name|NULL
expr_stmt|;
name|Tcl_CreateEventSource
argument_list|(
name|TimerSetupProc
argument_list|,
name|TimerCheckProc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateExitHandler
argument_list|(
name|TimerExitProc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TimerExitProc --  *  *	This function is call at exit or unload time to remove the  *	timer and idle event sources.  *  * Results:  *	None.  *  * Side effects:  *	Removes the timer and idle event sources.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|TimerExitProc
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
block|{
name|Tcl_DeleteEventSource
argument_list|(
name|TimerSetupProc
argument_list|,
name|TimerCheckProc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * Tcl_CreateTimerHandler --  *  *	Arrange for a given procedure to be invoked at a particular  *	time in the future.  *  * Results:  *	The return value is a token for the timer event, which  *	may be used to delete the event before it fires.  *  * Side effects:  *	When milliseconds have elapsed, proc will be invoked  *	exactly once.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_TimerToken
name|Tcl_CreateTimerHandler
parameter_list|(
name|milliseconds
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|int
name|milliseconds
decl_stmt|;
comment|/* How many milliseconds to wait 				 * before invoking proc. */
name|Tcl_TimerProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to invoke. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary data to pass to proc. */
block|{
specifier|register
name|TimerHandler
modifier|*
name|timerHandlerPtr
decl_stmt|,
modifier|*
name|tPtr2
decl_stmt|,
modifier|*
name|prevPtr
decl_stmt|;
name|Tcl_Time
name|time
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|InitTimer
argument_list|()
expr_stmt|;
block|}
name|timerHandlerPtr
operator|=
operator|(
name|TimerHandler
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TimerHandler
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Compute when the event should fire.      */
name|TclpGetTime
argument_list|(
operator|&
name|time
argument_list|)
expr_stmt|;
name|timerHandlerPtr
operator|->
name|time
operator|.
name|sec
operator|=
name|time
operator|.
name|sec
operator|+
name|milliseconds
operator|/
literal|1000
expr_stmt|;
name|timerHandlerPtr
operator|->
name|time
operator|.
name|usec
operator|=
name|time
operator|.
name|usec
operator|+
operator|(
name|milliseconds
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
if|if
condition|(
name|timerHandlerPtr
operator|->
name|time
operator|.
name|usec
operator|>=
literal|1000000
condition|)
block|{
name|timerHandlerPtr
operator|->
name|time
operator|.
name|usec
operator|-=
literal|1000000
expr_stmt|;
name|timerHandlerPtr
operator|->
name|time
operator|.
name|sec
operator|+=
literal|1
expr_stmt|;
block|}
comment|/*      * Fill in other fields for the event.      */
name|timerHandlerPtr
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|timerHandlerPtr
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
name|lastTimerId
operator|++
expr_stmt|;
name|timerHandlerPtr
operator|->
name|token
operator|=
operator|(
name|Tcl_TimerToken
operator|)
name|lastTimerId
expr_stmt|;
comment|/*      * Add the event to the queue in the correct position      * (ordered by event firing time).      */
for|for
control|(
name|tPtr2
operator|=
name|firstTimerHandlerPtr
operator|,
name|prevPtr
operator|=
name|NULL
init|;
name|tPtr2
operator|!=
name|NULL
condition|;
name|prevPtr
operator|=
name|tPtr2
operator|,
name|tPtr2
operator|=
name|tPtr2
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
operator|(
name|tPtr2
operator|->
name|time
operator|.
name|sec
operator|>
name|timerHandlerPtr
operator|->
name|time
operator|.
name|sec
operator|)
operator|||
operator|(
operator|(
name|tPtr2
operator|->
name|time
operator|.
name|sec
operator|==
name|timerHandlerPtr
operator|->
name|time
operator|.
name|sec
operator|)
operator|&&
operator|(
name|tPtr2
operator|->
name|time
operator|.
name|usec
operator|>
name|timerHandlerPtr
operator|->
name|time
operator|.
name|usec
operator|)
operator|)
condition|)
block|{
break|break;
block|}
block|}
name|timerHandlerPtr
operator|->
name|nextPtr
operator|=
name|tPtr2
expr_stmt|;
if|if
condition|(
name|prevPtr
operator|==
name|NULL
condition|)
block|{
name|firstTimerHandlerPtr
operator|=
name|timerHandlerPtr
expr_stmt|;
block|}
else|else
block|{
name|prevPtr
operator|->
name|nextPtr
operator|=
name|timerHandlerPtr
expr_stmt|;
block|}
name|TimerSetupProc
argument_list|(
name|NULL
argument_list|,
name|TCL_ALL_EVENTS
argument_list|)
expr_stmt|;
return|return
name|timerHandlerPtr
operator|->
name|token
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * Tcl_DeleteTimerHandler --  *  *	Delete a previously-registered timer handler.  *  * Results:  *	None.  *  * Side effects:  *	Destroy the timer callback identified by TimerToken,  *	so that its associated procedure will not be called.  *	If the callback has already fired, or if the given  *	token doesn't exist, then nothing happens.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DeleteTimerHandler
parameter_list|(
name|token
parameter_list|)
name|Tcl_TimerToken
name|token
decl_stmt|;
comment|/* Result previously returned by 				 * Tcl_DeleteTimerHandler. */
block|{
specifier|register
name|TimerHandler
modifier|*
name|timerHandlerPtr
decl_stmt|,
modifier|*
name|prevPtr
decl_stmt|;
for|for
control|(
name|timerHandlerPtr
operator|=
name|firstTimerHandlerPtr
operator|,
name|prevPtr
operator|=
name|NULL
init|;
name|timerHandlerPtr
operator|!=
name|NULL
condition|;
name|prevPtr
operator|=
name|timerHandlerPtr
operator|,
name|timerHandlerPtr
operator|=
name|timerHandlerPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|timerHandlerPtr
operator|->
name|token
operator|!=
name|token
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|prevPtr
operator|==
name|NULL
condition|)
block|{
name|firstTimerHandlerPtr
operator|=
name|timerHandlerPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
name|prevPtr
operator|->
name|nextPtr
operator|=
name|timerHandlerPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|timerHandlerPtr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TimerSetupProc --  *  *	This function is called by Tcl_DoOneEvent to setup the timer  *	event source for before blocking.  This routine checks both the  *	idle and after timer lists.  *  * Results:  *	None.  *  * Side effects:  *	May update the maximum notifier block time.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|TimerSetupProc
parameter_list|(
name|data
parameter_list|,
name|flags
parameter_list|)
name|ClientData
name|data
decl_stmt|;
comment|/* Not used. */
name|int
name|flags
decl_stmt|;
comment|/* Event flags as passed to Tcl_DoOneEvent. */
block|{
name|Tcl_Time
name|blockTime
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|TCL_IDLE_EVENTS
operator|)
operator|&&
name|idleList
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|TCL_TIMER_EVENTS
operator|)
operator|&&
name|timerPending
operator|)
condition|)
block|{
comment|/* 	 * There is an idle handler or a pending timer event, so just poll. 	 */
name|blockTime
operator|.
name|sec
operator|=
literal|0
expr_stmt|;
name|blockTime
operator|.
name|usec
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|TCL_TIMER_EVENTS
operator|)
operator|&&
name|firstTimerHandlerPtr
condition|)
block|{
comment|/* 	 * Compute the timeout for the next timer on the list. 	 */
name|TclpGetTime
argument_list|(
operator|&
name|blockTime
argument_list|)
expr_stmt|;
name|blockTime
operator|.
name|sec
operator|=
name|firstTimerHandlerPtr
operator|->
name|time
operator|.
name|sec
operator|-
name|blockTime
operator|.
name|sec
expr_stmt|;
name|blockTime
operator|.
name|usec
operator|=
name|firstTimerHandlerPtr
operator|->
name|time
operator|.
name|usec
operator|-
name|blockTime
operator|.
name|usec
expr_stmt|;
if|if
condition|(
name|blockTime
operator|.
name|usec
operator|<
literal|0
condition|)
block|{
name|blockTime
operator|.
name|sec
operator|-=
literal|1
expr_stmt|;
name|blockTime
operator|.
name|usec
operator|+=
literal|1000000
expr_stmt|;
block|}
if|if
condition|(
name|blockTime
operator|.
name|sec
operator|<
literal|0
condition|)
block|{
name|blockTime
operator|.
name|sec
operator|=
literal|0
expr_stmt|;
name|blockTime
operator|.
name|usec
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
return|return;
block|}
name|Tcl_SetMaxBlockTime
argument_list|(
operator|&
name|blockTime
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TimerCheckProc --  *  *	This function is called by Tcl_DoOneEvent to check the timer  *	event source for events.  This routine checks both the  *	idle and after timer lists.  *  * Results:  *	None.  *  * Side effects:  *	May queue an event and update the maximum notifier block time.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|TimerCheckProc
parameter_list|(
name|data
parameter_list|,
name|flags
parameter_list|)
name|ClientData
name|data
decl_stmt|;
comment|/* Not used. */
name|int
name|flags
decl_stmt|;
comment|/* Event flags as passed to Tcl_DoOneEvent. */
block|{
name|Tcl_Event
modifier|*
name|timerEvPtr
decl_stmt|;
name|Tcl_Time
name|blockTime
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|TCL_TIMER_EVENTS
operator|)
operator|&&
name|firstTimerHandlerPtr
condition|)
block|{
comment|/* 	 * Compute the timeout for the next timer on the list. 	 */
name|TclpGetTime
argument_list|(
operator|&
name|blockTime
argument_list|)
expr_stmt|;
name|blockTime
operator|.
name|sec
operator|=
name|firstTimerHandlerPtr
operator|->
name|time
operator|.
name|sec
operator|-
name|blockTime
operator|.
name|sec
expr_stmt|;
name|blockTime
operator|.
name|usec
operator|=
name|firstTimerHandlerPtr
operator|->
name|time
operator|.
name|usec
operator|-
name|blockTime
operator|.
name|usec
expr_stmt|;
if|if
condition|(
name|blockTime
operator|.
name|usec
operator|<
literal|0
condition|)
block|{
name|blockTime
operator|.
name|sec
operator|-=
literal|1
expr_stmt|;
name|blockTime
operator|.
name|usec
operator|+=
literal|1000000
expr_stmt|;
block|}
if|if
condition|(
name|blockTime
operator|.
name|sec
operator|<
literal|0
condition|)
block|{
name|blockTime
operator|.
name|sec
operator|=
literal|0
expr_stmt|;
name|blockTime
operator|.
name|usec
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * If the first timer has expired, stick an event on the queue. 	 */
if|if
condition|(
name|blockTime
operator|.
name|sec
operator|==
literal|0
operator|&&
name|blockTime
operator|.
name|usec
operator|==
literal|0
operator|&&
operator|!
name|timerPending
condition|)
block|{
name|timerPending
operator|=
literal|1
expr_stmt|;
name|timerEvPtr
operator|=
operator|(
name|Tcl_Event
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Tcl_Event
argument_list|)
argument_list|)
expr_stmt|;
name|timerEvPtr
operator|->
name|proc
operator|=
name|TimerHandlerEventProc
expr_stmt|;
name|Tcl_QueueEvent
argument_list|(
name|timerEvPtr
argument_list|,
name|TCL_QUEUE_TAIL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TimerHandlerEventProc --  *  *	This procedure is called by Tcl_ServiceEvent when a timer event  *	reaches the front of the event queue.  This procedure handles  *	the event by invoking the callbacks for all timers that are  *	ready.  *  * Results:  *	Returns 1 if the event was handled, meaning it should be removed  *	from the queue.  Returns 0 if the event was not handled, meaning  *	it should stay on the queue.  The only time the event isn't  *	handled is if the TCL_TIMER_EVENTS flag bit isn't set.  *  * Side effects:  *	Whatever the timer handler callback procedures do.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TimerHandlerEventProc
parameter_list|(
name|evPtr
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Event
modifier|*
name|evPtr
decl_stmt|;
comment|/* Event to service. */
name|int
name|flags
decl_stmt|;
comment|/* Flags that indicate what events to 				 * handle, such as TCL_FILE_EVENTS. */
block|{
name|TimerHandler
modifier|*
name|timerHandlerPtr
decl_stmt|,
modifier|*
modifier|*
name|nextPtrPtr
decl_stmt|;
name|Tcl_Time
name|time
decl_stmt|;
name|int
name|currentTimerId
decl_stmt|;
comment|/*      * Do nothing if timers aren't enabled.  This leaves the event on the      * queue, so we will get to it as soon as ServiceEvents() is called      * with timers enabled.      */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TCL_TIMER_EVENTS
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/*      * The code below is trickier than it may look, for the following      * reasons:      *      * 1. New handlers can get added to the list while the current      *    one is being processed.  If new ones get added, we don't      *    want to process them during this pass through the list to avoid      *	  starving other event sources.  This is implemented using the      *	  token number in the handler:  new handlers will have a      *    newer token than any of the ones currently on the list.      * 2. The handler can call Tcl_DoOneEvent, so we have to remove      *    the handler from the list before calling it. Otherwise an      *    infinite loop could result.      * 3. Tcl_DeleteTimerHandler can be called to remove an element from      *    the list while a handler is executing, so the list could      *    change structure during the call.      * 4. Because we only fetch the current time before entering the loop,      *    the only way a new timer will even be considered runnable is if      *	  its expiration time is within the same millisecond as the      *	  current time.  This is fairly likely on Windows, since it has      *	  a course granularity clock.  Since timers are placed      *	  on the queue in time order with the most recently created      *    handler appearing after earlier ones with the same expiration      *	  time, we don't have to worry about newer generation timers      *	  appearing before later ones.      */
name|timerPending
operator|=
literal|0
expr_stmt|;
name|currentTimerId
operator|=
name|lastTimerId
expr_stmt|;
name|TclpGetTime
argument_list|(
operator|&
name|time
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|nextPtrPtr
operator|=
operator|&
name|firstTimerHandlerPtr
expr_stmt|;
name|timerHandlerPtr
operator|=
name|firstTimerHandlerPtr
expr_stmt|;
if|if
condition|(
name|timerHandlerPtr
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|(
name|timerHandlerPtr
operator|->
name|time
operator|.
name|sec
operator|>
name|time
operator|.
name|sec
operator|)
operator|||
operator|(
operator|(
name|timerHandlerPtr
operator|->
name|time
operator|.
name|sec
operator|==
name|time
operator|.
name|sec
operator|)
operator|&&
operator|(
name|timerHandlerPtr
operator|->
name|time
operator|.
name|usec
operator|>
name|time
operator|.
name|usec
operator|)
operator|)
condition|)
block|{
break|break;
block|}
comment|/* 	 * Bail out if the next timer is of a newer generation. 	 */
if|if
condition|(
operator|(
name|currentTimerId
operator|-
operator|(
name|int
operator|)
name|timerHandlerPtr
operator|->
name|token
operator|)
operator|<
literal|0
condition|)
block|{
break|break;
block|}
comment|/* 	 * Remove the handler from the queue before invoking it, 	 * to avoid potential reentrancy problems. 	 */
operator|(
operator|*
name|nextPtrPtr
operator|)
operator|=
name|timerHandlerPtr
operator|->
name|nextPtr
expr_stmt|;
call|(
modifier|*
name|timerHandlerPtr
operator|->
name|proc
call|)
argument_list|(
name|timerHandlerPtr
operator|->
name|clientData
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|timerHandlerPtr
argument_list|)
expr_stmt|;
block|}
name|TimerSetupProc
argument_list|(
name|NULL
argument_list|,
name|TCL_TIMER_EVENTS
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * Tcl_DoWhenIdle --  *  *	Arrange for proc to be invoked the next time the system is  *	idle (i.e., just before the next time that Tcl_DoOneEvent  *	would have to wait for something to happen).  *  * Results:  *	None.  *  * Side effects:  *	Proc will eventually be called, with clientData as argument.  *	See the manual entry for details.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DoWhenIdle
parameter_list|(
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_IdleProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to invoke. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary value to pass to proc. */
block|{
specifier|register
name|IdleHandler
modifier|*
name|idlePtr
decl_stmt|;
name|Tcl_Time
name|blockTime
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|InitTimer
argument_list|()
expr_stmt|;
block|}
name|idlePtr
operator|=
operator|(
name|IdleHandler
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|IdleHandler
argument_list|)
argument_list|)
expr_stmt|;
name|idlePtr
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|idlePtr
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
name|idlePtr
operator|->
name|generation
operator|=
name|idleGeneration
expr_stmt|;
name|idlePtr
operator|->
name|nextPtr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|lastIdlePtr
operator|==
name|NULL
condition|)
block|{
name|idleList
operator|=
name|idlePtr
expr_stmt|;
block|}
else|else
block|{
name|lastIdlePtr
operator|->
name|nextPtr
operator|=
name|idlePtr
expr_stmt|;
block|}
name|lastIdlePtr
operator|=
name|idlePtr
expr_stmt|;
name|blockTime
operator|.
name|sec
operator|=
literal|0
expr_stmt|;
name|blockTime
operator|.
name|usec
operator|=
literal|0
expr_stmt|;
name|Tcl_SetMaxBlockTime
argument_list|(
operator|&
name|blockTime
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CancelIdleCall --  *  *	If there are any when-idle calls requested to a given procedure  *	with given clientData, cancel all of them.  *  * Results:  *	None.  *  * Side effects:  *	If the proc/clientData combination were on the when-idle list,  *	they are removed so that they will never be called.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_CancelIdleCall
parameter_list|(
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_IdleProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure that was previously registered. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary value to pass to proc. */
block|{
specifier|register
name|IdleHandler
modifier|*
name|idlePtr
decl_stmt|,
modifier|*
name|prevPtr
decl_stmt|;
name|IdleHandler
modifier|*
name|nextPtr
decl_stmt|;
for|for
control|(
name|prevPtr
operator|=
name|NULL
operator|,
name|idlePtr
operator|=
name|idleList
init|;
name|idlePtr
operator|!=
name|NULL
condition|;
name|prevPtr
operator|=
name|idlePtr
operator|,
name|idlePtr
operator|=
name|idlePtr
operator|->
name|nextPtr
control|)
block|{
while|while
condition|(
operator|(
name|idlePtr
operator|->
name|proc
operator|==
name|proc
operator|)
operator|&&
operator|(
name|idlePtr
operator|->
name|clientData
operator|==
name|clientData
operator|)
condition|)
block|{
name|nextPtr
operator|=
name|idlePtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|idlePtr
argument_list|)
expr_stmt|;
name|idlePtr
operator|=
name|nextPtr
expr_stmt|;
if|if
condition|(
name|prevPtr
operator|==
name|NULL
condition|)
block|{
name|idleList
operator|=
name|idlePtr
expr_stmt|;
block|}
else|else
block|{
name|prevPtr
operator|->
name|nextPtr
operator|=
name|idlePtr
expr_stmt|;
block|}
if|if
condition|(
name|idlePtr
operator|==
name|NULL
condition|)
block|{
name|lastIdlePtr
operator|=
name|prevPtr
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclServiceIdle --  *  *	This procedure is invoked by the notifier when it becomes  *	idle.  It will invoke all idle handlers that are present at  *	the time the call is invoked, but not those added during idle  *	processing.  *  * Results:  *	The return value is 1 if TclServiceIdle found something to  *	do, otherwise return value is 0.  *  * Side effects:  *	Invokes all pending idle handlers.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclServiceIdle
parameter_list|()
block|{
name|IdleHandler
modifier|*
name|idlePtr
decl_stmt|;
name|int
name|oldGeneration
decl_stmt|;
name|Tcl_Time
name|blockTime
decl_stmt|;
if|if
condition|(
name|idleList
operator|==
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
name|oldGeneration
operator|=
name|idleGeneration
expr_stmt|;
name|idleGeneration
operator|++
expr_stmt|;
comment|/*      * The code below is trickier than it may look, for the following      * reasons:      *      * 1. New handlers can get added to the list while the current      *    one is being processed.  If new ones get added, we don't      *    want to process them during this pass through the list (want      *    to check for other work to do first).  This is implemented      *    using the generation number in the handler:  new handlers      *    will have a different generation than any of the ones currently      *    on the list.      * 2. The handler can call Tcl_DoOneEvent, so we have to remove      *    the handler from the list before calling it. Otherwise an      *    infinite loop could result.      * 3. Tcl_CancelIdleCall can be called to remove an element from      *    the list while a handler is executing, so the list could      *    change structure during the call.      */
for|for
control|(
name|idlePtr
operator|=
name|idleList
init|;
operator|(
operator|(
name|idlePtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|oldGeneration
operator|-
name|idlePtr
operator|->
name|generation
operator|)
operator|>=
literal|0
operator|)
operator|)
condition|;
name|idlePtr
operator|=
name|idleList
control|)
block|{
name|idleList
operator|=
name|idlePtr
operator|->
name|nextPtr
expr_stmt|;
if|if
condition|(
name|idleList
operator|==
name|NULL
condition|)
block|{
name|lastIdlePtr
operator|=
name|NULL
expr_stmt|;
block|}
call|(
modifier|*
name|idlePtr
operator|->
name|proc
call|)
argument_list|(
name|idlePtr
operator|->
name|clientData
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|idlePtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idleList
condition|)
block|{
name|blockTime
operator|.
name|sec
operator|=
literal|0
expr_stmt|;
name|blockTime
operator|.
name|usec
operator|=
literal|0
expr_stmt|;
name|Tcl_SetMaxBlockTime
argument_list|(
operator|&
name|blockTime
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_AfterObjCmd --  *  *	This procedure is invoked to process the "after" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_AfterObjCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Points to the "tclAfter" assocData for 				 * this interpreter, or NULL if the assocData 				 * hasn't been created yet.*/
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
comment|/*      * The variable below is used to generate unique identifiers for      * after commands.  This id can wrap around, which can potentially      * cause problems.  However, there are not likely to be problems      * in practice, because after commands can only be requested to      * about a month in the future, and wrap-around is unlikely to      * occur in less than about 1-10 years.  Thus it's unlikely that      * any old ids will still be around when wrap-around occurs.      */
specifier|static
name|int
name|nextId
init|=
literal|1
decl_stmt|;
name|int
name|ms
decl_stmt|;
name|AfterInfo
modifier|*
name|afterPtr
decl_stmt|;
name|AfterAssocData
modifier|*
name|assocPtr
init|=
operator|(
name|AfterAssocData
operator|*
operator|)
name|clientData
decl_stmt|;
name|Tcl_CmdInfo
name|cmdInfo
decl_stmt|;
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|index
decl_stmt|,
name|result
decl_stmt|;
specifier|static
name|char
modifier|*
name|subCmds
index|[]
init|=
block|{
literal|"cancel"
block|,
literal|"idle"
block|,
literal|"info"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"option ?arg arg ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Create the "after" information associated for this interpreter,      * if it doesn't already exist.  Associate it with the command too,      * so that it will be passed in as the ClientData argument in the      * future.      */
if|if
condition|(
name|assocPtr
operator|==
name|NULL
condition|)
block|{
name|assocPtr
operator|=
operator|(
name|AfterAssocData
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|AfterAssocData
argument_list|)
argument_list|)
expr_stmt|;
name|assocPtr
operator|->
name|interp
operator|=
name|interp
expr_stmt|;
name|assocPtr
operator|->
name|firstAfterPtr
operator|=
name|NULL
expr_stmt|;
name|Tcl_SetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclAfter"
argument_list|,
name|AfterCleanupProc
argument_list|,
operator|(
name|ClientData
operator|)
name|assocPtr
argument_list|)
expr_stmt|;
name|cmdInfo
operator|.
name|proc
operator|=
name|NULL
expr_stmt|;
name|cmdInfo
operator|.
name|clientData
operator|=
operator|(
name|ClientData
operator|)
name|NULL
expr_stmt|;
name|cmdInfo
operator|.
name|objProc
operator|=
name|Tcl_AfterObjCmd
expr_stmt|;
name|cmdInfo
operator|.
name|objClientData
operator|=
operator|(
name|ClientData
operator|)
name|assocPtr
expr_stmt|;
name|cmdInfo
operator|.
name|deleteProc
operator|=
name|NULL
expr_stmt|;
name|cmdInfo
operator|.
name|deleteData
operator|=
operator|(
name|ClientData
operator|)
name|assocPtr
expr_stmt|;
name|Tcl_SetCommandInfo
argument_list|(
name|interp
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|0
index|]
argument_list|,
operator|&
name|length
argument_list|)
argument_list|,
operator|&
name|cmdInfo
argument_list|)
expr_stmt|;
block|}
comment|/*      * First lets see if the command was passed a number as the first argument.      */
name|arg
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|,
operator|&
name|ms
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|ms
operator|<
literal|0
condition|)
block|{
name|ms
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|objc
operator|==
literal|2
condition|)
block|{
name|Tcl_Sleep
argument_list|(
name|ms
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
name|afterPtr
operator|=
operator|(
name|AfterInfo
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|AfterInfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|afterPtr
operator|->
name|assocPtr
operator|=
name|assocPtr
expr_stmt|;
if|if
condition|(
name|objc
operator|==
literal|3
condition|)
block|{
name|arg
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|afterPtr
operator|->
name|command
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|length
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|afterPtr
operator|->
name|command
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_Obj
modifier|*
name|objPtr
init|=
name|Tcl_ConcatObj
argument_list|(
name|objc
operator|-
literal|2
argument_list|,
name|objv
operator|+
literal|2
argument_list|)
decl_stmt|;
name|arg
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|afterPtr
operator|->
name|command
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|length
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|afterPtr
operator|->
name|command
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
name|afterPtr
operator|->
name|id
operator|=
name|nextId
expr_stmt|;
name|nextId
operator|+=
literal|1
expr_stmt|;
name|afterPtr
operator|->
name|token
operator|=
name|Tcl_CreateTimerHandler
argument_list|(
name|ms
argument_list|,
name|AfterProc
argument_list|,
operator|(
name|ClientData
operator|)
name|afterPtr
argument_list|)
expr_stmt|;
name|afterPtr
operator|->
name|nextPtr
operator|=
name|assocPtr
operator|->
name|firstAfterPtr
expr_stmt|;
name|assocPtr
operator|->
name|firstAfterPtr
operator|=
name|afterPtr
expr_stmt|;
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"after#%d"
argument_list|,
name|afterPtr
operator|->
name|id
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
comment|/*      * If it's not a number it must be a subcommand.      */
name|result
operator|=
name|Tcl_GetIndexFromObj
argument_list|(
name|NULL
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|,
name|subCmds
argument_list|,
literal|"option"
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad argument \""
argument_list|,
name|arg
argument_list|,
literal|"\": must be cancel, idle, info, or a number"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
switch|switch
condition|(
name|index
condition|)
block|{
case|case
literal|0
case|:
comment|/* cancel */
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|Tcl_Obj
modifier|*
name|objPtr
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"id|command"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|objc
operator|==
literal|3
condition|)
block|{
name|arg
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|objPtr
operator|=
name|Tcl_ConcatObj
argument_list|(
name|objc
operator|-
literal|2
argument_list|,
name|objv
operator|+
literal|2
argument_list|)
expr_stmt|;
empty_stmt|;
name|arg
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|afterPtr
operator|=
name|assocPtr
operator|->
name|firstAfterPtr
init|;
name|afterPtr
operator|!=
name|NULL
condition|;
name|afterPtr
operator|=
name|afterPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|afterPtr
operator|->
name|command
argument_list|,
name|arg
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|afterPtr
operator|==
name|NULL
condition|)
block|{
name|afterPtr
operator|=
name|GetAfterEvent
argument_list|(
name|assocPtr
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|objPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|afterPtr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|afterPtr
operator|->
name|token
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DeleteTimerHandler
argument_list|(
name|afterPtr
operator|->
name|token
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_CancelIdleCall
argument_list|(
name|AfterProc
argument_list|,
operator|(
name|ClientData
operator|)
name|afterPtr
argument_list|)
expr_stmt|;
block|}
name|FreeAfterPtr
argument_list|(
name|afterPtr
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|1
case|:
comment|/* idle */
if|if
condition|(
name|objc
operator|<
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"script script ..."
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|afterPtr
operator|=
operator|(
name|AfterInfo
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|AfterInfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|afterPtr
operator|->
name|assocPtr
operator|=
name|assocPtr
expr_stmt|;
if|if
condition|(
name|objc
operator|==
literal|3
condition|)
block|{
name|arg
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|afterPtr
operator|->
name|command
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|afterPtr
operator|->
name|command
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_Obj
modifier|*
name|objPtr
init|=
name|Tcl_ConcatObj
argument_list|(
name|objc
operator|-
literal|2
argument_list|,
name|objv
operator|+
literal|2
argument_list|)
decl_stmt|;
empty_stmt|;
name|arg
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|afterPtr
operator|->
name|command
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|length
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|afterPtr
operator|->
name|command
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
name|afterPtr
operator|->
name|id
operator|=
name|nextId
expr_stmt|;
name|nextId
operator|+=
literal|1
expr_stmt|;
name|afterPtr
operator|->
name|token
operator|=
name|NULL
expr_stmt|;
name|afterPtr
operator|->
name|nextPtr
operator|=
name|assocPtr
operator|->
name|firstAfterPtr
expr_stmt|;
name|assocPtr
operator|->
name|firstAfterPtr
operator|=
name|afterPtr
expr_stmt|;
name|Tcl_DoWhenIdle
argument_list|(
name|AfterProc
argument_list|,
operator|(
name|ClientData
operator|)
name|afterPtr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"after#%d"
argument_list|,
name|afterPtr
operator|->
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* info */
if|if
condition|(
name|objc
operator|==
literal|2
condition|)
block|{
name|char
name|buffer
index|[
literal|30
index|]
decl_stmt|;
for|for
control|(
name|afterPtr
operator|=
name|assocPtr
operator|->
name|firstAfterPtr
init|;
name|afterPtr
operator|!=
name|NULL
condition|;
name|afterPtr
operator|=
name|afterPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|assocPtr
operator|->
name|interp
operator|==
name|interp
condition|)
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"after#%d"
argument_list|,
name|afterPtr
operator|->
name|id
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?id?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|arg
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|afterPtr
operator|=
name|GetAfterEvent
argument_list|(
name|assocPtr
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|afterPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"event \""
argument_list|,
name|arg
argument_list|,
literal|"\" doesn't exist"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|afterPtr
operator|->
name|command
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
operator|(
name|afterPtr
operator|->
name|token
operator|==
name|NULL
operator|)
condition|?
literal|"idle"
else|:
literal|"timer"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * GetAfterEvent --  *  *	This procedure parses an "after" id such as "after#4" and  *	returns a pointer to the AfterInfo structure.  *  * Results:  *	The return value is either a pointer to an AfterInfo structure,  *	if one is found that corresponds to "string" and is for interp,  *	or NULL if no corresponding after event can be found.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|AfterInfo
modifier|*
name|GetAfterEvent
parameter_list|(
name|assocPtr
parameter_list|,
name|string
parameter_list|)
name|AfterAssocData
modifier|*
name|assocPtr
decl_stmt|;
comment|/* Points to "after"-related information for 				 * this interpreter. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Textual identifier for after event, such 				 * as "after#6". */
block|{
name|AfterInfo
modifier|*
name|afterPtr
decl_stmt|;
name|int
name|id
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|string
argument_list|,
literal|"after#"
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|string
operator|+=
literal|6
expr_stmt|;
name|id
operator|=
name|strtoul
argument_list|(
name|string
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|end
operator|==
name|string
operator|)
operator|||
operator|(
operator|*
name|end
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
for|for
control|(
name|afterPtr
operator|=
name|assocPtr
operator|->
name|firstAfterPtr
init|;
name|afterPtr
operator|!=
name|NULL
condition|;
name|afterPtr
operator|=
name|afterPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|afterPtr
operator|->
name|id
operator|==
name|id
condition|)
block|{
return|return
name|afterPtr
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * AfterProc --  *  *	Timer callback to execute commands registered with the  *	"after" command.  *  * Results:  *	None.  *  * Side effects:  *	Executes whatever command was specified.  If the command  *	returns an error, then the command "bgerror" is invoked  *	to process the error;  if bgerror fails then information  *	about the error is output on stderr.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|AfterProc
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Describes command to execute. */
block|{
name|AfterInfo
modifier|*
name|afterPtr
init|=
operator|(
name|AfterInfo
operator|*
operator|)
name|clientData
decl_stmt|;
name|AfterAssocData
modifier|*
name|assocPtr
init|=
name|afterPtr
operator|->
name|assocPtr
decl_stmt|;
name|AfterInfo
modifier|*
name|prevPtr
decl_stmt|;
name|int
name|result
decl_stmt|;
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/*      * First remove the callback from our list of callbacks;  otherwise      * someone could delete the callback while it's being executed, which      * could cause a core dump.      */
if|if
condition|(
name|assocPtr
operator|->
name|firstAfterPtr
operator|==
name|afterPtr
condition|)
block|{
name|assocPtr
operator|->
name|firstAfterPtr
operator|=
name|afterPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|prevPtr
operator|=
name|assocPtr
operator|->
name|firstAfterPtr
init|;
name|prevPtr
operator|->
name|nextPtr
operator|!=
name|afterPtr
condition|;
name|prevPtr
operator|=
name|prevPtr
operator|->
name|nextPtr
control|)
block|{
comment|/* Empty loop body. */
block|}
name|prevPtr
operator|->
name|nextPtr
operator|=
name|afterPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
comment|/*      * Execute the callback.      */
name|interp
operator|=
name|assocPtr
operator|->
name|interp
expr_stmt|;
name|Tcl_Preserve
argument_list|(
operator|(
name|ClientData
operator|)
name|interp
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_GlobalEval
argument_list|(
name|interp
argument_list|,
name|afterPtr
operator|->
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
literal|"\n    (\"after\" script)"
argument_list|)
expr_stmt|;
name|Tcl_BackgroundError
argument_list|(
name|interp
argument_list|)
expr_stmt|;
block|}
name|Tcl_Release
argument_list|(
operator|(
name|ClientData
operator|)
name|interp
argument_list|)
expr_stmt|;
comment|/*      * Free the memory for the callback.      */
name|ckfree
argument_list|(
name|afterPtr
operator|->
name|command
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|afterPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FreeAfterPtr --  *  *	This procedure removes an "after" command from the list of  *	those that are pending and frees its resources.  This procedure  *	does *not* cancel the timer handler;  if that's needed, the  *	caller must do it.  *  * Results:  *	None.  *  * Side effects:  *	The memory associated with afterPtr is released.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|FreeAfterPtr
parameter_list|(
name|afterPtr
parameter_list|)
name|AfterInfo
modifier|*
name|afterPtr
decl_stmt|;
comment|/* Command to be deleted. */
block|{
name|AfterInfo
modifier|*
name|prevPtr
decl_stmt|;
name|AfterAssocData
modifier|*
name|assocPtr
init|=
name|afterPtr
operator|->
name|assocPtr
decl_stmt|;
if|if
condition|(
name|assocPtr
operator|->
name|firstAfterPtr
operator|==
name|afterPtr
condition|)
block|{
name|assocPtr
operator|->
name|firstAfterPtr
operator|=
name|afterPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|prevPtr
operator|=
name|assocPtr
operator|->
name|firstAfterPtr
init|;
name|prevPtr
operator|->
name|nextPtr
operator|!=
name|afterPtr
condition|;
name|prevPtr
operator|=
name|prevPtr
operator|->
name|nextPtr
control|)
block|{
comment|/* Empty loop body. */
block|}
name|prevPtr
operator|->
name|nextPtr
operator|=
name|afterPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
name|ckfree
argument_list|(
name|afterPtr
operator|->
name|command
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|afterPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * AfterCleanupProc --  *  *	This procedure is invoked whenever an interpreter is deleted  *	to cleanup the AssocData for "tclAfter".  *  * Results:  *	None.  *  * Side effects:  *	After commands are removed.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|AfterCleanupProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Points to AfterAssocData for the 				 * interpreter. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter that is being deleted. */
block|{
name|AfterAssocData
modifier|*
name|assocPtr
init|=
operator|(
name|AfterAssocData
operator|*
operator|)
name|clientData
decl_stmt|;
name|AfterInfo
modifier|*
name|afterPtr
decl_stmt|;
while|while
condition|(
name|assocPtr
operator|->
name|firstAfterPtr
operator|!=
name|NULL
condition|)
block|{
name|afterPtr
operator|=
name|assocPtr
operator|->
name|firstAfterPtr
expr_stmt|;
name|assocPtr
operator|->
name|firstAfterPtr
operator|=
name|afterPtr
operator|->
name|nextPtr
expr_stmt|;
if|if
condition|(
name|afterPtr
operator|->
name|token
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DeleteTimerHandler
argument_list|(
name|afterPtr
operator|->
name|token
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_CancelIdleCall
argument_list|(
name|AfterProc
argument_list|,
operator|(
name|ClientData
operator|)
name|afterPtr
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
name|afterPtr
operator|->
name|command
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|afterPtr
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|assocPtr
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

