begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclCmdAH.c --  *  *	This file contains the top-level command routines for most of  *	the Tcl built-in commands whose names begin with the letters  *	A to H.  *  * Copyright (c) 1987-1993 The Regents of the University of California.  * Copyright (c) 1994-1997 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclCmdAH.c 1.156 97/08/12 18:10:15  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * Prototypes for local procedures defined in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|GetTypeFromMode
name|_ANSI_ARGS_
argument_list|(
operator|(
name|int
name|mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|StoreStatData
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|varName
operator|,
expr|struct
name|stat
operator|*
name|statPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_BreakCmd --  *  *	This procedure is invoked to process the "break" Tcl command.  *	See the user documentation for details on what it does.  *  *	With the bytecode compiler, this procedure is only called when  *	a command name is computed at runtime, and is "break" or the name  *	to which "break" was renamed: e.g., "set z break; $z"  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_BreakCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_BREAK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CaseObjCmd --  *  *	This procedure is invoked to process the "case" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_CaseObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|body
decl_stmt|,
name|result
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|,
modifier|*
name|arg
decl_stmt|;
name|int
name|argLen
decl_stmt|,
name|caseObjc
decl_stmt|;
name|Tcl_Obj
modifier|*
name|CONST
modifier|*
name|caseObjv
decl_stmt|;
name|Tcl_Obj
modifier|*
name|armPtr
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"string ?in? patList body ... ?default body?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * THIS FAILS IF AN OBJECT'S STRING REP HAS A NULL BYTE.      */
name|string
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
operator|&
name|argLen
argument_list|)
expr_stmt|;
name|body
operator|=
operator|-
literal|1
expr_stmt|;
name|arg
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|argLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"in"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
literal|2
expr_stmt|;
block|}
name|caseObjc
operator|=
name|objc
operator|-
name|i
expr_stmt|;
name|caseObjv
operator|=
name|objv
operator|+
name|i
expr_stmt|;
comment|/*      * If all of the pattern/command pairs are lumped into a single      * argument, split them out again.      * THIS FAILS IF THE ARG'S STRING REP CONTAINS A NULL      */
if|if
condition|(
name|caseObjc
operator|==
literal|1
condition|)
block|{
name|Tcl_Obj
modifier|*
modifier|*
name|newObjv
decl_stmt|;
name|Tcl_ListObjGetElements
argument_list|(
name|interp
argument_list|,
name|caseObjv
index|[
literal|0
index|]
argument_list|,
operator|&
name|caseObjc
argument_list|,
operator|&
name|newObjv
argument_list|)
expr_stmt|;
name|caseObjv
operator|=
name|newObjv
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|caseObjc
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|int
name|patObjc
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
modifier|*
name|patObjv
decl_stmt|;
name|char
modifier|*
name|pat
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|i
operator|==
operator|(
name|caseObjc
operator|-
literal|1
operator|)
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"extra case pattern with no body"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/* 	 * Check for special case of single pattern (no list) with 	 * no backslash sequences. 	 */
name|pat
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|caseObjv
index|[
name|i
index|]
argument_list|,
operator|&
name|argLen
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|pat
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
comment|/* FAILS IF NULL BYTE */
if|if
condition|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'\\'
operator|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|pat
operator|==
literal|'d'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|pat
argument_list|,
literal|"default"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|body
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|Tcl_StringMatch
argument_list|(
name|string
argument_list|,
name|pat
argument_list|)
condition|)
block|{
name|body
operator|=
name|i
operator|+
literal|1
expr_stmt|;
goto|goto
name|match
goto|;
block|}
continue|continue;
block|}
comment|/* 	 * Break up pattern lists, then check each of the patterns 	 * in the list. 	 */
name|result
operator|=
name|Tcl_SplitList
argument_list|(
name|interp
argument_list|,
name|pat
argument_list|,
operator|&
name|patObjc
argument_list|,
operator|&
name|patObjv
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|patObjc
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|Tcl_StringMatch
argument_list|(
name|string
argument_list|,
name|patObjv
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|body
operator|=
name|i
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|patObjv
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|patObjc
condition|)
block|{
break|break;
block|}
block|}
name|match
label|:
if|if
condition|(
name|body
operator|!=
operator|-
literal|1
condition|)
block|{
name|armPtr
operator|=
name|caseObjv
index|[
name|body
operator|-
literal|1
index|]
expr_stmt|;
name|result
operator|=
name|Tcl_EvalObj
argument_list|(
name|interp
argument_list|,
name|caseObjv
index|[
name|body
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|char
name|msg
index|[
literal|100
index|]
decl_stmt|;
name|arg
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|armPtr
argument_list|,
operator|&
name|argLen
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n    (\"%.*s\" arm line %d)"
argument_list|,
name|argLen
argument_list|,
name|arg
argument_list|,
name|interp
operator|->
name|errorLine
argument_list|)
expr_stmt|;
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|msg
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/*      * Nothing matched: return nothing.      */
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CatchObjCmd --  *  *	This object-based procedure is invoked to process the "catch" Tcl   *	command. See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_CatchObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Obj
modifier|*
name|varNamePtr
init|=
name|NULL
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|objc
operator|!=
literal|2
operator|)
operator|&&
operator|(
name|objc
operator|!=
literal|3
operator|)
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"command ?varName?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Save a pointer to the variable name object, if any, in case the      * Tcl_EvalObj reallocates the bytecode interpreter's evaluation      * stack rendering objv invalid.      */
if|if
condition|(
name|objc
operator|==
literal|3
condition|)
block|{
name|varNamePtr
operator|=
name|objv
index|[
literal|2
index|]
expr_stmt|;
block|}
name|result
operator|=
name|Tcl_EvalObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|objc
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|Tcl_ObjSetVar2
argument_list|(
name|interp
argument_list|,
name|varNamePtr
argument_list|,
name|NULL
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|TCL_PARSE_PART1
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"couldn't save command result in variable"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
comment|/*      * Set the interpreter's object result to an integer object holding the      * integer Tcl_EvalObj result. Note that we don't bother generating a      * string representation. We reset the interpreter's object result      * to an unshared empty object and then set it to be an integer object.      */
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_SetIntObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CdObjCmd --  *  *	This procedure is invoked to process the "cd" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_CdObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|char
modifier|*
name|dirName
decl_stmt|;
name|int
name|dirLength
decl_stmt|;
name|Tcl_DString
name|buffer
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|objc
operator|>
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"dirName"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|objc
operator|==
literal|2
condition|)
block|{
name|dirName
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
operator|&
name|dirLength
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dirName
operator|=
literal|"~"
expr_stmt|;
block|}
name|dirName
operator|=
name|Tcl_TranslateFileName
argument_list|(
name|interp
argument_list|,
name|dirName
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirName
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|result
operator|=
name|TclChdir
argument_list|(
name|interp
argument_list|,
name|dirName
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ConcatObjCmd --  *  *	This object-based procedure is invoked to process the "concat" Tcl  *	command. See the user documentation for details on what it does/  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_ConcatObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
if|if
condition|(
name|objc
operator|>=
literal|2
condition|)
block|{
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|Tcl_ConcatObj
argument_list|(
name|objc
operator|-
literal|1
argument_list|,
name|objv
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ContinueCmd -  *  *	This procedure is invoked to process the "continue" Tcl command.  *	See the user documentation for details on what it does.  *  *	With the bytecode compiler, this procedure is only called when  *	a command name is computed at runtime, and is "continue" or the name  *	to which "continue" was renamed: e.g., "set z continue; $z"  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_ContinueCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_CONTINUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ErrorObjCmd --  *  *	This procedure is invoked to process the "error" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_ErrorObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
specifier|register
name|Tcl_Obj
modifier|*
name|namePtr
decl_stmt|;
name|char
modifier|*
name|info
decl_stmt|;
name|int
name|infoLen
decl_stmt|;
if|if
condition|(
operator|(
name|objc
operator|<
literal|2
operator|)
operator|||
operator|(
name|objc
operator|>
literal|4
operator|)
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"message ?errorInfo? ?errorCode?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|objc
operator|>=
literal|3
condition|)
block|{
comment|/* process the optional info argument */
name|info
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|infoLen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|info
operator|!=
literal|0
condition|)
block|{
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|info
argument_list|,
name|infoLen
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|flags
operator||=
name|ERR_ALREADY_LOGGED
expr_stmt|;
block|}
block|}
if|if
condition|(
name|objc
operator|==
literal|4
condition|)
block|{
name|namePtr
operator|=
name|Tcl_NewStringObj
argument_list|(
literal|"errorCode"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_ObjSetVar2
argument_list|(
name|interp
argument_list|,
name|namePtr
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|)
name|NULL
argument_list|,
name|objv
index|[
literal|3
index|]
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|flags
operator||=
name|ERROR_CODE_SET
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
comment|/* we're done with name object */
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_EvalObjCmd --  *  *	This object-based procedure is invoked to process the "eval" Tcl   *	command. See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_EvalObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|int
name|result
decl_stmt|;
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"arg ?arg ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|objc
operator|==
literal|2
condition|)
block|{
name|result
operator|=
name|Tcl_EvalObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * More than one argument: concatenate them together with spaces 	 * between, then evaluate the result. 	 */
name|objPtr
operator|=
name|Tcl_ConcatObj
argument_list|(
name|objc
operator|-
literal|1
argument_list|,
name|objv
operator|+
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_EvalObj
argument_list|(
name|interp
argument_list|,
name|objPtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
comment|/* we're done with the object */
block|}
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|char
name|msg
index|[
literal|60
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n    (\"eval\" body line %d)"
argument_list|,
name|interp
operator|->
name|errorLine
argument_list|)
expr_stmt|;
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|msg
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ExitObjCmd --  *  *	This procedure is invoked to process the "exit" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_ExitObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|int
name|value
decl_stmt|;
if|if
condition|(
operator|(
name|objc
operator|!=
literal|1
operator|)
operator|&&
operator|(
name|objc
operator|!=
literal|2
operator|)
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"?returnCode?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|objc
operator|==
literal|1
condition|)
block|{
name|value
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|,
operator|&
name|value
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_Exit
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
return|return
name|TCL_OK
return|;
comment|/* Better not ever reach this! */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ExprObjCmd --  *  *	This object-based procedure is invoked to process the "expr" Tcl  *	command. See the user documentation for details on what it does.  *  *	With the bytecode compiler, this procedure is called in two  *	circumstances: 1) to execute expr commands that are too complicated  *	or too unsafe to try compiling directly into an inline sequence of  *	instructions, and 2) to execute commands where the command name is  *	computed at runtime and is "expr" or the name to which "expr" was  *	renamed (e.g., "set z expr; $z 2+3")  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_ExprObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|resultPtr
decl_stmt|;
specifier|register
name|char
modifier|*
name|bytes
decl_stmt|;
name|int
name|length
decl_stmt|,
name|i
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"arg ?arg ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|objc
operator|==
literal|2
condition|)
block|{
name|result
operator|=
name|Tcl_ExprObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|,
operator|&
name|resultPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|resultPtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|resultPtr
argument_list|)
expr_stmt|;
comment|/* done with the result object */
block|}
block|}
comment|/*      * Create a new object holding the concatenated argument strings.      * THIS FAILS IF AN OBJECT'S STRING REP HAS A NULL BYTE.      */
name|bytes
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|objPtr
operator|=
name|Tcl_NewStringObj
argument_list|(
name|bytes
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|Tcl_AppendToObj
argument_list|(
name|objPtr
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|objPtr
argument_list|,
name|bytes
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|/*      * Evaluate the concatenated string object.      */
name|result
operator|=
name|Tcl_ExprObj
argument_list|(
name|interp
argument_list|,
name|objPtr
argument_list|,
operator|&
name|resultPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|resultPtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|resultPtr
argument_list|)
expr_stmt|;
comment|/* done with the result object */
block|}
comment|/*      * Free allocated resources.      */
name|Tcl_DecrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_FileObjCmd --  *  *	This procedure is invoked to process the "file" Tcl command.  *	See the user documentation for details on what it does.  *	PLEASE NOTE THAT THIS FAILS WITH FILENAMES AND PATHS WITH  *	EMBEDDED NULLS, WHICH COULD THEORETICALLY HAPPEN ON A MAC.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_FileObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|char
modifier|*
name|fileName
decl_stmt|,
modifier|*
name|extension
decl_stmt|,
modifier|*
name|errorString
decl_stmt|;
name|int
name|statOp
init|=
literal|0
decl_stmt|;
comment|/* Init. to avoid compiler warning. */
name|int
name|length
decl_stmt|;
name|int
name|mode
init|=
literal|0
decl_stmt|;
comment|/* Initialized only to prevent 					 * compiler warning message. */
name|struct
name|stat
name|statBuf
decl_stmt|;
name|Tcl_DString
name|buffer
decl_stmt|;
name|Tcl_Obj
modifier|*
name|resultPtr
decl_stmt|;
name|int
name|index
decl_stmt|,
name|result
decl_stmt|;
comment|/*  * This list of constants should match the fileOption string array below.  */
enum|enum
block|{
name|FILE_ATIME
block|,
name|FILE_ATTRIBUTES
block|,
name|FILE_COPY
block|,
name|FILE_DELETE
block|,
name|FILE_DIRNAME
block|,
name|FILE_EXECUTABLE
block|,
name|FILE_EXISTS
block|,
name|FILE_EXTENSION
block|,
name|FILE_ISDIRECTORY
block|,
name|FILE_ISFILE
block|,
name|FILE_JOIN
block|,
name|FILE_LSTAT
block|,
name|FILE_MTIME
block|,
name|FILE_MKDIR
block|,
name|FILE_NATIVENAME
block|,
name|FILE_OWNED
block|,
name|FILE_PATHTYPE
block|,
name|FILE_READABLE
block|,
name|FILE_READLINK
block|,
name|FILE_RENAME
block|,
name|FILE_ROOTNAME
block|,
name|FILE_SIZE
block|,
name|FILE_SPLIT
block|,
name|FILE_STAT
block|,
name|FILE_TAIL
block|,
name|FILE_TYPE
block|,
name|FILE_VOLUMES
block|,
name|FILE_WRITABLE
block|}
enum|;
specifier|static
name|char
modifier|*
name|fileOptions
index|[]
init|=
block|{
literal|"atime"
block|,
literal|"attributes"
block|,
literal|"copy"
block|,
literal|"delete"
block|,
literal|"dirname"
block|,
literal|"executable"
block|,
literal|"exists"
block|,
literal|"extension"
block|,
literal|"isdirectory"
block|,
literal|"isfile"
block|,
literal|"join"
block|,
literal|"lstat"
block|,
literal|"mtime"
block|,
literal|"mkdir"
block|,
literal|"nativename"
block|,
literal|"owned"
block|,
literal|"pathtype"
block|,
literal|"readable"
block|,
literal|"readlink"
block|,
literal|"rename"
block|,
literal|"rootname"
block|,
literal|"size"
block|,
literal|"split"
block|,
literal|"stat"
block|,
literal|"tail"
block|,
literal|"type"
block|,
literal|"volumes"
block|,
literal|"writable"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"option ?arg ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetIndexFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|,
name|fileOptions
argument_list|,
literal|"option"
argument_list|,
literal|0
argument_list|,
operator|&
name|index
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|result
operator|=
name|TCL_OK
expr_stmt|;
comment|/*       * First, do the volumes command, since it is the only one that      * has objc == 2.      */
if|if
condition|(
name|index
operator|==
name|FILE_VOLUMES
condition|)
block|{
if|if
condition|(
name|objc
operator|!=
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"volumes"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|result
operator|=
name|TclpListVolumes
argument_list|(
name|interp
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
name|objc
operator|<
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"name ?arg ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_DStringInit
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|resultPtr
operator|=
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
comment|/*      * Handle operations on the file name.      */
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|FILE_ATTRIBUTES
case|:
name|result
operator|=
name|TclFileAttrsCmd
argument_list|(
name|interp
argument_list|,
name|objc
operator|-
literal|2
argument_list|,
name|objv
operator|+
literal|2
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|FILE_DIRNAME
case|:
block|{
name|int
name|pargc
decl_stmt|;
name|char
modifier|*
modifier|*
name|pargv
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|errorString
operator|=
literal|"dirname name"
expr_stmt|;
goto|goto
name|not3Args
goto|;
block|}
name|fileName
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
comment|/* 	     * If there is only one element, and it starts with a tilde, 	     * perform tilde substitution and resplit the path. 	     */
name|Tcl_SplitPath
argument_list|(
name|fileName
argument_list|,
operator|&
name|pargc
argument_list|,
operator|&
name|pargv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pargc
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|*
name|fileName
operator|==
literal|'~'
operator|)
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pargv
argument_list|)
expr_stmt|;
name|fileName
operator|=
name|Tcl_TranslateFileName
argument_list|(
name|interp
argument_list|,
name|fileName
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileName
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|Tcl_SplitPath
argument_list|(
name|fileName
argument_list|,
operator|&
name|pargc
argument_list|,
operator|&
name|pargv
argument_list|)
expr_stmt|;
name|Tcl_DStringSetLength
argument_list|(
operator|&
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * Return all but the last component.  If there is only one 	     * component, return it if the path was non-relative, otherwise 	     * return the current directory. 	     */
if|if
condition|(
name|pargc
operator|>
literal|1
condition|)
block|{
name|Tcl_JoinPath
argument_list|(
name|pargc
operator|-
literal|1
argument_list|,
name|pargv
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|Tcl_SetStringObj
argument_list|(
name|resultPtr
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|buffer
argument_list|)
argument_list|,
name|buffer
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|pargc
operator|==
literal|0
operator|)
operator|||
operator|(
name|Tcl_GetPathType
argument_list|(
name|pargv
index|[
literal|0
index|]
argument_list|)
operator|==
name|TCL_PATH_RELATIVE
operator|)
condition|)
block|{
name|Tcl_SetStringObj
argument_list|(
name|resultPtr
argument_list|,
operator|(
name|tclPlatform
operator|==
name|TCL_PLATFORM_MAC
operator|)
condition|?
literal|":"
else|:
literal|"."
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_SetStringObj
argument_list|(
name|resultPtr
argument_list|,
name|pargv
index|[
literal|0
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pargv
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
case|case
name|FILE_TAIL
case|:
block|{
name|int
name|pargc
decl_stmt|;
name|char
modifier|*
modifier|*
name|pargv
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|errorString
operator|=
literal|"tail name"
expr_stmt|;
goto|goto
name|not3Args
goto|;
block|}
name|fileName
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
comment|/* 	     * If there is only one element, and it starts with a tilde, 	     * perform tilde substitution and resplit the path. 	     */
name|Tcl_SplitPath
argument_list|(
name|fileName
argument_list|,
operator|&
name|pargc
argument_list|,
operator|&
name|pargv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pargc
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|*
name|fileName
operator|==
literal|'~'
operator|)
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pargv
argument_list|)
expr_stmt|;
name|fileName
operator|=
name|Tcl_TranslateFileName
argument_list|(
name|interp
argument_list|,
name|fileName
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileName
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|Tcl_SplitPath
argument_list|(
name|fileName
argument_list|,
operator|&
name|pargc
argument_list|,
operator|&
name|pargv
argument_list|)
expr_stmt|;
name|Tcl_DStringSetLength
argument_list|(
operator|&
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * Return the last component, unless it is the only component, 	     * and it is the root of an absolute path. 	     */
if|if
condition|(
name|pargc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pargc
operator|>
literal|1
operator|)
operator|||
operator|(
name|Tcl_GetPathType
argument_list|(
name|pargv
index|[
literal|0
index|]
argument_list|)
operator|==
name|TCL_PATH_RELATIVE
operator|)
condition|)
block|{
name|Tcl_SetStringObj
argument_list|(
name|resultPtr
argument_list|,
name|pargv
index|[
name|pargc
operator|-
literal|1
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pargv
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
case|case
name|FILE_ROOTNAME
case|:
block|{
name|char
modifier|*
name|fileName
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|errorString
operator|=
literal|"rootname name"
expr_stmt|;
goto|goto
name|not3Args
goto|;
block|}
name|fileName
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|extension
operator|=
name|TclGetExtension
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
if|if
condition|(
name|extension
operator|==
name|NULL
condition|)
block|{
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_SetStringObj
argument_list|(
name|resultPtr
argument_list|,
name|fileName
argument_list|,
call|(
name|int
call|)
argument_list|(
name|length
operator|-
name|strlen
argument_list|(
name|extension
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
case|case
name|FILE_EXTENSION
case|:
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|errorString
operator|=
literal|"extension name"
expr_stmt|;
goto|goto
name|not3Args
goto|;
block|}
name|extension
operator|=
name|TclGetExtension
argument_list|(
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|extension
operator|!=
name|NULL
condition|)
block|{
name|Tcl_SetStringObj
argument_list|(
name|resultPtr
argument_list|,
name|extension
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|extension
argument_list|)
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
case|case
name|FILE_PATHTYPE
case|:
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|errorString
operator|=
literal|"pathtype name"
expr_stmt|;
goto|goto
name|not3Args
goto|;
block|}
switch|switch
condition|(
name|Tcl_GetPathType
argument_list|(
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|TCL_PATH_ABSOLUTE
case|:
name|Tcl_SetStringObj
argument_list|(
name|resultPtr
argument_list|,
literal|"absolute"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCL_PATH_RELATIVE
case|:
name|Tcl_SetStringObj
argument_list|(
name|resultPtr
argument_list|,
literal|"relative"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCL_PATH_VOLUME_RELATIVE
case|:
name|Tcl_SetStringObj
argument_list|(
name|resultPtr
argument_list|,
literal|"volumerelative"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|done
goto|;
case|case
name|FILE_SPLIT
case|:
block|{
name|int
name|pargc
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|pargvList
decl_stmt|;
name|Tcl_Obj
modifier|*
name|listObjPtr
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|errorString
operator|=
literal|"split name"
expr_stmt|;
goto|goto
name|not3Args
goto|;
block|}
name|Tcl_SplitPath
argument_list|(
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
argument_list|,
operator|&
name|pargc
argument_list|,
operator|&
name|pargvList
argument_list|)
expr_stmt|;
name|listObjPtr
operator|=
name|Tcl_NewListObj
argument_list|(
literal|0
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pargc
condition|;
name|i
operator|++
control|)
block|{
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listObjPtr
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|pargvList
index|[
name|i
index|]
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pargvList
argument_list|)
expr_stmt|;
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|listObjPtr
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
case|case
name|FILE_JOIN
case|:
block|{
name|char
modifier|*
modifier|*
name|pargv
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|objc
operator|-
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|pargv
index|[
name|i
operator|-
literal|2
index|]
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
block|}
name|Tcl_JoinPath
argument_list|(
name|objc
operator|-
literal|2
argument_list|,
name|pargv
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|Tcl_SetStringObj
argument_list|(
name|resultPtr
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|buffer
argument_list|)
argument_list|,
name|buffer
operator|.
name|length
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pargv
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
case|case
name|FILE_RENAME
case|:
block|{
name|char
modifier|*
modifier|*
name|pargv
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
name|objc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|pargv
index|[
name|i
index|]
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|TclFileRenameCmd
argument_list|(
name|interp
argument_list|,
name|objc
argument_list|,
name|pargv
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pargv
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
case|case
name|FILE_MKDIR
case|:
block|{
name|char
modifier|*
modifier|*
name|pargv
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
name|objc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|pargv
index|[
name|i
index|]
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|TclFileMakeDirsCmd
argument_list|(
name|interp
argument_list|,
name|objc
argument_list|,
name|pargv
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pargv
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
case|case
name|FILE_DELETE
case|:
block|{
name|char
modifier|*
modifier|*
name|pargv
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
name|objc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|pargv
index|[
name|i
index|]
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|TclFileDeleteCmd
argument_list|(
name|interp
argument_list|,
name|objc
argument_list|,
name|pargv
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pargv
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
case|case
name|FILE_COPY
case|:
block|{
name|char
modifier|*
modifier|*
name|pargv
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
name|objc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|pargv
index|[
name|i
index|]
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|TclFileCopyCmd
argument_list|(
name|interp
argument_list|,
name|objc
argument_list|,
name|pargv
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pargv
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
case|case
name|FILE_NATIVENAME
case|:
name|fileName
operator|=
name|Tcl_TranslateFileName
argument_list|(
name|interp
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileName
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
else|else
block|{
name|Tcl_SetStringObj
argument_list|(
name|resultPtr
argument_list|,
name|fileName
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
comment|/*      * Next, handle operations that can be satisfied with the "access"      * kernel call.      */
name|fileName
operator|=
name|Tcl_TranslateFileName
argument_list|(
name|interp
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|FILE_READABLE
case|:
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|errorString
operator|=
literal|"readable name"
expr_stmt|;
goto|goto
name|not3Args
goto|;
block|}
name|mode
operator|=
name|R_OK
expr_stmt|;
name|checkAccess
label|:
comment|/* 	     * The result might have been set within Tcl_TranslateFileName 	     * (like no such user "blah" for file exists ~blah) 	     * but we don't want to flag an error in that case. 	     */
if|if
condition|(
name|fileName
operator|==
name|NULL
condition|)
block|{
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|Tcl_NewBooleanObj
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_SetBooleanObj
argument_list|(
name|resultPtr
argument_list|,
operator|(
name|access
argument_list|(
name|fileName
argument_list|,
name|mode
argument_list|)
operator|!=
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
case|case
name|FILE_WRITABLE
case|:
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|errorString
operator|=
literal|"writable name"
expr_stmt|;
goto|goto
name|not3Args
goto|;
block|}
name|mode
operator|=
name|W_OK
expr_stmt|;
goto|goto
name|checkAccess
goto|;
case|case
name|FILE_EXECUTABLE
case|:
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|errorString
operator|=
literal|"executable name"
expr_stmt|;
goto|goto
name|not3Args
goto|;
block|}
name|mode
operator|=
name|X_OK
expr_stmt|;
goto|goto
name|checkAccess
goto|;
case|case
name|FILE_EXISTS
case|:
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|errorString
operator|=
literal|"exists name"
expr_stmt|;
goto|goto
name|not3Args
goto|;
block|}
name|mode
operator|=
name|F_OK
expr_stmt|;
goto|goto
name|checkAccess
goto|;
block|}
comment|/*      * Lastly, check stuff that requires the file to be stat-ed.      */
if|if
condition|(
name|fileName
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|FILE_ATIME
case|:
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|errorString
operator|=
literal|"atime name"
expr_stmt|;
goto|goto
name|not3Args
goto|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|fileName
argument_list|,
operator|&
name|statBuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
goto|goto
name|badStat
goto|;
block|}
name|Tcl_SetLongObj
argument_list|(
name|resultPtr
argument_list|,
operator|(
name|long
operator|)
name|statBuf
operator|.
name|st_atime
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|FILE_ISDIRECTORY
case|:
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|errorString
operator|=
literal|"isdirectory name"
expr_stmt|;
goto|goto
name|not3Args
goto|;
block|}
name|statOp
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|FILE_ISFILE
case|:
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|errorString
operator|=
literal|"isfile name"
expr_stmt|;
goto|goto
name|not3Args
goto|;
block|}
name|statOp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|FILE_LSTAT
case|:
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"lstat name varName"
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|lstat
argument_list|(
name|fileName
argument_list|,
operator|&
name|statBuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|resultPtr
argument_list|,
literal|"couldn't lstat \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|result
operator|=
name|StoreStatData
argument_list|(
name|interp
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|length
argument_list|)
argument_list|,
operator|&
name|statBuf
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|FILE_MTIME
case|:
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|errorString
operator|=
literal|"mtime name"
expr_stmt|;
goto|goto
name|not3Args
goto|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|fileName
argument_list|,
operator|&
name|statBuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
goto|goto
name|badStat
goto|;
block|}
name|Tcl_SetLongObj
argument_list|(
name|resultPtr
argument_list|,
operator|(
name|long
operator|)
name|statBuf
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|FILE_OWNED
case|:
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|errorString
operator|=
literal|"owned name"
expr_stmt|;
goto|goto
name|not3Args
goto|;
block|}
name|statOp
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FILE_READLINK
case|:
block|{
name|char
name|linkValue
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|linkLength
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|errorString
operator|=
literal|"readlink name"
expr_stmt|;
goto|goto
name|not3Args
goto|;
block|}
comment|/* 	     * If S_IFLNK isn't defined it means that the machine doesn't 	     * support symbolic links, so the file can't possibly be a 	     * symbolic link.  Generate an EINVAL error, which is what 	     * happens on machines that do support symbolic links when 	     * you invoke readlink on a file that isn't a symbolic link. 	     */
ifndef|#
directive|ifndef
name|S_IFLNK
name|linkLength
operator|=
operator|-
literal|1
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
else|#
directive|else
name|linkLength
operator|=
name|readlink
argument_list|(
name|fileName
argument_list|,
name|linkValue
argument_list|,
sizeof|sizeof
argument_list|(
name|linkValue
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* S_IFLNK */
if|if
condition|(
name|linkLength
operator|==
operator|-
literal|1
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|resultPtr
argument_list|,
literal|"couldn't readlink \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|linkValue
index|[
name|linkLength
index|]
operator|=
literal|0
expr_stmt|;
name|Tcl_SetStringObj
argument_list|(
name|resultPtr
argument_list|,
name|linkValue
argument_list|,
name|linkLength
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
case|case
name|FILE_SIZE
case|:
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|errorString
operator|=
literal|"size name"
expr_stmt|;
goto|goto
name|not3Args
goto|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|fileName
argument_list|,
operator|&
name|statBuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
goto|goto
name|badStat
goto|;
block|}
name|Tcl_SetLongObj
argument_list|(
name|resultPtr
argument_list|,
operator|(
name|long
operator|)
name|statBuf
operator|.
name|st_size
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|FILE_STAT
case|:
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"stat name varName"
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|fileName
argument_list|,
operator|&
name|statBuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|badStat
label|:
name|Tcl_AppendStringsToObj
argument_list|(
name|resultPtr
argument_list|,
literal|"couldn't stat \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|result
operator|=
name|StoreStatData
argument_list|(
name|interp
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|length
argument_list|)
argument_list|,
operator|&
name|statBuf
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|FILE_TYPE
case|:
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|errorString
operator|=
literal|"type name"
expr_stmt|;
goto|goto
name|not3Args
goto|;
block|}
if|if
condition|(
name|lstat
argument_list|(
name|fileName
argument_list|,
operator|&
name|statBuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
goto|goto
name|badStat
goto|;
block|}
name|errorString
operator|=
name|GetTypeFromMode
argument_list|(
operator|(
name|int
operator|)
name|statBuf
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|Tcl_SetStringObj
argument_list|(
name|resultPtr
argument_list|,
name|errorString
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|fileName
argument_list|,
operator|&
name|statBuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|Tcl_SetBooleanObj
argument_list|(
name|resultPtr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
switch|switch
condition|(
name|statOp
condition|)
block|{
case|case
literal|0
case|:
comment|/* 	     * For Windows and Macintosh, there are no user ids  	     * associated with a file, so we always return 1. 	     */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__WIN32__
argument_list|)
operator|||
name|defined
argument_list|(
name|MAC_TCL
argument_list|)
operator|)
name|mode
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|mode
operator|=
operator|(
name|geteuid
argument_list|()
operator|==
name|statBuf
operator|.
name|st_uid
operator|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|1
case|:
name|mode
operator|=
name|S_ISREG
argument_list|(
name|statBuf
operator|.
name|st_mode
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|mode
operator|=
name|S_ISDIR
argument_list|(
name|statBuf
operator|.
name|st_mode
argument_list|)
expr_stmt|;
break|break;
block|}
name|Tcl_SetBooleanObj
argument_list|(
name|resultPtr
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|done
label|:
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
return|return
name|result
return|;
name|not3Args
label|:
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
name|errorString
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * StoreStatData --  *  *	This is a utility procedure that breaks out the fields of a  *	"stat" structure and stores them in textual form into the  *	elements of an associative array.  *  * Results:  *	Returns a standard Tcl return value.  If an error occurs then  *	a message is left in interp->result.  *  * Side effects:  *	Elements of the associative array given by "varName" are modified.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|StoreStatData
parameter_list|(
name|interp
parameter_list|,
name|varName
parameter_list|,
name|statPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter for error reports. */
name|char
modifier|*
name|varName
decl_stmt|;
comment|/* Name of associative array variable 					 * in which to store stat results. */
name|struct
name|stat
modifier|*
name|statPtr
decl_stmt|;
comment|/* Pointer to buffer containing 					 * stat data to store in varName. */
block|{
name|char
name|string
index|[
literal|30
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|statPtr
operator|->
name|st_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
literal|"dev"
argument_list|,
name|string
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|statPtr
operator|->
name|st_ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
literal|"ino"
argument_list|,
name|string
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|statPtr
operator|->
name|st_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
literal|"mode"
argument_list|,
name|string
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|statPtr
operator|->
name|st_nlink
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
literal|"nlink"
argument_list|,
name|string
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|statPtr
operator|->
name|st_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
literal|"uid"
argument_list|,
name|string
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|statPtr
operator|->
name|st_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
literal|"gid"
argument_list|,
name|string
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|statPtr
operator|->
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
literal|"size"
argument_list|,
name|string
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|statPtr
operator|->
name|st_atime
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
literal|"atime"
argument_list|,
name|string
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|statPtr
operator|->
name|st_mtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
literal|"mtime"
argument_list|,
name|string
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|statPtr
operator|->
name|st_ctime
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
literal|"ctime"
argument_list|,
name|string
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
literal|"type"
argument_list|,
name|GetTypeFromMode
argument_list|(
operator|(
name|int
operator|)
name|statPtr
operator|->
name|st_mode
argument_list|)
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * GetTypeFromMode --  *  *	Given a mode word, returns a string identifying the type of a  *	file.  *  * Results:  *	A static text string giving the file type from mode.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|GetTypeFromMode
parameter_list|(
name|mode
parameter_list|)
name|int
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|S_ISREG
argument_list|(
name|mode
argument_list|)
condition|)
block|{
return|return
literal|"file"
return|;
block|}
elseif|else
if|if
condition|(
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
condition|)
block|{
return|return
literal|"directory"
return|;
block|}
elseif|else
if|if
condition|(
name|S_ISCHR
argument_list|(
name|mode
argument_list|)
condition|)
block|{
return|return
literal|"characterSpecial"
return|;
block|}
elseif|else
if|if
condition|(
name|S_ISBLK
argument_list|(
name|mode
argument_list|)
condition|)
block|{
return|return
literal|"blockSpecial"
return|;
block|}
elseif|else
if|if
condition|(
name|S_ISFIFO
argument_list|(
name|mode
argument_list|)
condition|)
block|{
return|return
literal|"fifo"
return|;
ifdef|#
directive|ifdef
name|S_ISLNK
block|}
elseif|else
if|if
condition|(
name|S_ISLNK
argument_list|(
name|mode
argument_list|)
condition|)
block|{
return|return
literal|"link"
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISSOCK
block|}
elseif|else
if|if
condition|(
name|S_ISSOCK
argument_list|(
name|mode
argument_list|)
condition|)
block|{
return|return
literal|"socket"
return|;
endif|#
directive|endif
block|}
return|return
literal|"unknown"
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ForCmd --  *  *      This procedure is invoked to process the "for" Tcl command.  *      See the user documentation for details on what it does.  *  *	With the bytecode compiler, this procedure is only called when  *	a command name is computed at runtime, and is "for" or the name  *	to which "for" was renamed: e.g.,  *	"set z for; $z {set i 0} {$i<100} {incr i} {puts $i}"  *  * Results:  *      A standard Tcl result.  *  * Side effects:  *      See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_ForCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|result
decl_stmt|,
name|value
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|5
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" start test next command\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|result
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
literal|"\n    (\"for\" initial command)"
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|result
operator|=
name|Tcl_ExprBoolean
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
if|if
condition|(
operator|!
name|value
condition|)
block|{
break|break;
block|}
name|result
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|!=
name|TCL_OK
operator|)
operator|&&
operator|(
name|result
operator|!=
name|TCL_CONTINUE
operator|)
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|char
name|msg
index|[
literal|60
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n    (\"for\" body line %d)"
argument_list|,
name|interp
operator|->
name|errorLine
argument_list|)
expr_stmt|;
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|result
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_BREAK
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
literal|"\n    (\"for\" loop-end command)"
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
if|if
condition|(
name|result
operator|==
name|TCL_BREAK
condition|)
block|{
name|result
operator|=
name|TCL_OK
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ForeachObjCmd --  *  *	This object-based procedure is invoked to process the "foreach" Tcl  *	command.  See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_ForeachObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* i selects a value list */
name|int
name|j
decl_stmt|,
name|maxj
decl_stmt|;
comment|/* Number of loop iterations */
name|int
name|v
decl_stmt|;
comment|/* v selects a loop variable */
name|int
name|numLists
decl_stmt|;
comment|/* Count of value lists */
name|Tcl_Obj
modifier|*
name|bodyPtr
decl_stmt|;
comment|/*      * We copy the argument object pointers into a local array to avoid      * the problem that "objv" might become invalid. It is a pointer into      * the evaluation stack and that stack might be grown and reallocated      * if the loop body requires a large amount of stack space.      */
define|#
directive|define
name|NUM_ARGS
value|9
name|Tcl_Obj
argument_list|*
operator|(
name|argObjStorage
index|[
name|NUM_ARGS
index|]
operator|)
argument_list|;
name|Tcl_Obj
operator|*
operator|*
name|argObjv
operator|=
name|argObjStorage
argument_list|;
define|#
directive|define
name|STATIC_LIST_SIZE
value|4
name|int
name|indexArray
index|[
name|STATIC_LIST_SIZE
index|]
argument_list|;
comment|/* Array of value list indices */
name|int
name|varcListArray
index|[
name|STATIC_LIST_SIZE
index|]
argument_list|;
comment|/* # loop variables per list */
name|Tcl_Obj
operator|*
operator|*
name|varvListArray
index|[
name|STATIC_LIST_SIZE
index|]
argument_list|;
comment|/* Array of var name lists */
name|int
name|argcListArray
index|[
name|STATIC_LIST_SIZE
index|]
argument_list|;
comment|/* Array of value list sizes */
name|Tcl_Obj
operator|*
operator|*
name|argvListArray
index|[
name|STATIC_LIST_SIZE
index|]
argument_list|;
comment|/* Array of value lists */
name|int
operator|*
name|index
operator|=
name|indexArray
argument_list|;
name|int
operator|*
name|varcList
operator|=
name|varcListArray
argument_list|;
name|Tcl_Obj
operator|*
operator|*
operator|*
name|varvList
operator|=
name|varvListArray
argument_list|;
name|int
operator|*
name|argcList
operator|=
name|argcListArray
argument_list|;
name|Tcl_Obj
operator|*
operator|*
operator|*
name|argvList
operator|=
name|argvListArray
argument_list|;      if
operator|(
name|objc
operator|<
literal|4
operator|||
operator|(
name|objc
operator|%
literal|2
operator|!=
literal|0
operator|)
operator|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"varList list ?varList list ...? command"
argument_list|)
block|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Create the object argument array "argObjv". Make sure argObjv is      * large enough to hold the objc arguments.      */
if|if
condition|(
name|objc
operator|>
name|NUM_ARGS
condition|)
block|{
name|argObjv
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
name|objc
operator|*
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|argObjv
index|[
name|i
index|]
operator|=
name|objv
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/*      * Manage numList parallel value lists.      * argvList[i] is a value list counted by argcList[i]      * varvList[i] is the list of variables associated with the value list      * varcList[i] is the number of variables associated with the value list      * index[i] is the current pointer into the value list argvList[i]      */
name|numLists
operator|=
operator|(
name|objc
operator|-
literal|2
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|numLists
operator|>
name|STATIC_LIST_SIZE
condition|)
block|{
name|index
operator|=
operator|(
name|int
operator|*
operator|)
name|ckalloc
argument_list|(
name|numLists
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|varcList
operator|=
operator|(
name|int
operator|*
operator|)
name|ckalloc
argument_list|(
name|numLists
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|varvList
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
name|numLists
operator|*
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|argcList
operator|=
operator|(
name|int
operator|*
operator|)
name|ckalloc
argument_list|(
name|numLists
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|argvList
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
name|numLists
operator|*
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numLists
condition|;
name|i
operator|++
control|)
block|{
name|index
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|varcList
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|varvList
index|[
name|i
index|]
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
name|argcList
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|argvList
index|[
name|i
index|]
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/*      * Break up the value lists and variable lists into elements      * THIS FAILS IF THE OBJECT'S STRING REP HAS A NULL BYTE.      */
name|maxj
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numLists
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
name|Tcl_ListObjGetElements
argument_list|(
name|interp
argument_list|,
name|argObjv
index|[
literal|1
operator|+
name|i
operator|*
literal|2
index|]
argument_list|,
operator|&
name|varcList
index|[
name|i
index|]
argument_list|,
operator|&
name|varvList
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|varcList
index|[
name|i
index|]
operator|<
literal|1
condition|)
block|{
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"foreach varlist is empty"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|result
operator|=
name|Tcl_ListObjGetElements
argument_list|(
name|interp
argument_list|,
name|argObjv
index|[
literal|2
operator|+
name|i
operator|*
literal|2
index|]
argument_list|,
operator|&
name|argcList
index|[
name|i
index|]
argument_list|,
operator|&
name|argvList
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|j
operator|=
name|argcList
index|[
name|i
index|]
operator|/
name|varcList
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|argcList
index|[
name|i
index|]
operator|%
name|varcList
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|>
name|maxj
condition|)
block|{
name|maxj
operator|=
name|j
expr_stmt|;
block|}
block|}
comment|/*      * Iterate maxj times through the lists in parallel      * If some value lists run out of values, set loop vars to ""      */
name|bodyPtr
operator|=
name|argObjv
index|[
name|objc
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|maxj
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numLists
condition|;
name|i
operator|++
control|)
block|{
comment|/* 	     * If a variable or value list object has been converted to 	     * another kind of Tcl object, convert it back to a list object 	     * and refetch the pointer to its element array. 	     */
if|if
condition|(
name|argObjv
index|[
literal|1
operator|+
name|i
operator|*
literal|2
index|]
operator|->
name|typePtr
operator|!=
operator|&
name|tclListType
condition|)
block|{
name|result
operator|=
name|Tcl_ListObjGetElements
argument_list|(
name|interp
argument_list|,
name|argObjv
index|[
literal|1
operator|+
name|i
operator|*
literal|2
index|]
argument_list|,
operator|&
name|varcList
index|[
name|i
index|]
argument_list|,
operator|&
name|varvList
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_ForeachObjCmd: could not reconvert variable list %d to a list object\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|argObjv
index|[
literal|2
operator|+
name|i
operator|*
literal|2
index|]
operator|->
name|typePtr
operator|!=
operator|&
name|tclListType
condition|)
block|{
name|result
operator|=
name|Tcl_ListObjGetElements
argument_list|(
name|interp
argument_list|,
name|argObjv
index|[
literal|2
operator|+
name|i
operator|*
literal|2
index|]
argument_list|,
operator|&
name|argcList
index|[
name|i
index|]
argument_list|,
operator|&
name|argvList
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_ForeachObjCmd: could not reconvert value list %d to a list object\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|v
operator|=
literal|0
init|;
name|v
operator|<
name|varcList
index|[
name|i
index|]
condition|;
name|v
operator|++
control|)
block|{
name|int
name|k
init|=
name|index
index|[
name|i
index|]
operator|++
decl_stmt|;
name|Tcl_Obj
modifier|*
name|valuePtr
decl_stmt|,
modifier|*
name|varValuePtr
decl_stmt|;
name|int
name|isEmptyObj
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|k
operator|<
name|argcList
index|[
name|i
index|]
condition|)
block|{
name|valuePtr
operator|=
name|argvList
index|[
name|i
index|]
index|[
name|k
index|]
expr_stmt|;
block|}
else|else
block|{
name|valuePtr
operator|=
name|Tcl_NewObj
argument_list|()
expr_stmt|;
comment|/* empty string */
name|isEmptyObj
operator|=
literal|1
expr_stmt|;
block|}
name|varValuePtr
operator|=
name|Tcl_ObjSetVar2
argument_list|(
name|interp
argument_list|,
name|varvList
index|[
name|i
index|]
index|[
name|v
index|]
argument_list|,
name|NULL
argument_list|,
name|valuePtr
argument_list|,
name|TCL_PARSE_PART1
argument_list|)
expr_stmt|;
if|if
condition|(
name|varValuePtr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|isEmptyObj
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
block|}
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"couldn't set loop variable: \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|varvList
index|[
name|i
index|]
index|[
name|v
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
name|result
operator|=
name|Tcl_EvalObj
argument_list|(
name|interp
argument_list|,
name|bodyPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_CONTINUE
condition|)
block|{
name|result
operator|=
name|TCL_OK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|TCL_BREAK
condition|)
block|{
name|result
operator|=
name|TCL_OK
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|char
name|msg
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n    (\"foreach\" body line %d)"
argument_list|,
name|interp
operator|->
name|errorLine
argument_list|)
expr_stmt|;
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|msg
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|numLists
operator|>
name|STATIC_LIST_SIZE
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|index
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|varcList
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argcList
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|varvList
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argvList
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argObjv
operator|!=
name|argObjStorage
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argObjv
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
undef|#
directive|undef
name|STATIC_LIST_SIZE
undef|#
directive|undef
name|NUM_ARGS
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_FormatObjCmd --  *  *	This procedure is invoked to process the "format" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_FormatObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
specifier|register
name|char
modifier|*
name|format
decl_stmt|;
comment|/* Used to read characters from the format 				 * string. */
name|int
name|formatLen
decl_stmt|;
comment|/* The length of the format string */
name|char
modifier|*
name|endPtr
decl_stmt|;
comment|/* Points to the last char in format array */
name|char
name|newFormat
index|[
literal|40
index|]
decl_stmt|;
comment|/* A new format specifier is generated here. */
name|int
name|width
decl_stmt|;
comment|/* Field width from field specifier, or 0 if 				 * no width given. */
name|int
name|precision
decl_stmt|;
comment|/* Field precision from field specifier, or 0 				 * if no precision given. */
name|int
name|size
decl_stmt|;
comment|/* Number of bytes needed for result of 				 * conversion, based on type of conversion 				 * ("e", "s", etc.), width, and precision. */
name|int
name|intValue
decl_stmt|;
comment|/* Used to hold value to pass to sprintf, if 				 * it's a one-word integer or char value */
name|char
modifier|*
name|ptrValue
init|=
name|NULL
decl_stmt|;
comment|/* Used to hold value to pass to sprintf, if 				 * it's a one-word value. */
name|double
name|doubleValue
decl_stmt|;
comment|/* Used to hold value to pass to sprintf if 				 * it's a double value. */
name|int
name|whichValue
decl_stmt|;
comment|/* Indicates which of intValue, ptrValue, 				 * or doubleValue has the value to pass to 				 * sprintf, according to the following 				 * definitions: */
define|#
directive|define
name|INT_VALUE
value|0
define|#
directive|define
name|PTR_VALUE
value|1
define|#
directive|define
name|DOUBLE_VALUE
value|2
define|#
directive|define
name|MAX_FLOAT_SIZE
value|320
name|Tcl_Obj
modifier|*
name|resultPtr
decl_stmt|;
comment|/* Where result is stored finally. */
name|char
name|staticBuf
index|[
name|MAX_FLOAT_SIZE
index|]
decl_stmt|;
comment|/* A static buffer to copy the format results  				 * into */
name|char
modifier|*
name|dst
init|=
name|staticBuf
decl_stmt|;
comment|/* The buffer that sprintf writes into each 				 * time the format processes a specifier */
name|int
name|dstSize
init|=
name|MAX_FLOAT_SIZE
decl_stmt|;
comment|/* The size of the dst buffer */
name|int
name|noPercent
decl_stmt|;
comment|/* Special case for speed:  indicates there's 				 * no field specifier, just a string to copy.*/
name|int
name|objIndex
decl_stmt|;
comment|/* Index of argument to substitute next. */
name|int
name|gotXpg
init|=
literal|0
decl_stmt|;
comment|/* Non-zero means that an XPG3 %n$-style 				 * specifier has been seen. */
name|int
name|gotSequential
init|=
literal|0
decl_stmt|;
comment|/* Non-zero means that a regular sequential 				 * (non-XPG3) conversion specifier has been 				 * seen. */
name|int
name|useShort
decl_stmt|;
comment|/* Value to be printed is short (half word). */
name|char
modifier|*
name|end
decl_stmt|;
comment|/* Used to locate end of numerical fields. */
comment|/*      * This procedure is a bit nasty.  The goal is to use sprintf to      * do most of the dirty work.  There are several problems:      * 1. this procedure can't trust its arguments.      * 2. we must be able to provide a large enough result area to hold      *    whatever's generated.  This is hard to estimate.      * 2. there's no way to move the arguments from objv to the call      *    to sprintf in a reasonable way.  This is particularly nasty      *    because some of the arguments may be two-word values (doubles).      * So, what happens here is to scan the format string one % group      * at a time, making many individual calls to sprintf.      */
if|if
condition|(
name|objc
operator|<
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"formatString ?arg arg ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|format
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
operator|&
name|formatLen
argument_list|)
expr_stmt|;
name|endPtr
operator|=
name|format
operator|+
name|formatLen
expr_stmt|;
name|resultPtr
operator|=
name|Tcl_NewObj
argument_list|()
expr_stmt|;
name|objIndex
operator|=
literal|2
expr_stmt|;
while|while
condition|(
name|format
operator|<
name|endPtr
condition|)
block|{
specifier|register
name|char
modifier|*
name|newPtr
init|=
name|newFormat
decl_stmt|;
name|width
operator|=
name|precision
operator|=
name|noPercent
operator|=
name|useShort
operator|=
literal|0
expr_stmt|;
name|whichValue
operator|=
name|PTR_VALUE
expr_stmt|;
comment|/* 	 * Get rid of any characters before the next field specifier. 	 */
if|if
condition|(
operator|*
name|format
operator|!=
literal|'%'
condition|)
block|{
name|ptrValue
operator|=
name|format
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|format
operator|!=
literal|'%'
operator|)
operator|&&
operator|(
name|format
operator|<
name|endPtr
operator|)
condition|)
block|{
name|format
operator|++
expr_stmt|;
block|}
name|size
operator|=
name|format
operator|-
name|ptrValue
expr_stmt|;
name|noPercent
operator|=
literal|1
expr_stmt|;
goto|goto
name|doField
goto|;
block|}
if|if
condition|(
name|format
index|[
literal|1
index|]
operator|==
literal|'%'
condition|)
block|{
name|ptrValue
operator|=
name|format
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
name|noPercent
operator|=
literal|1
expr_stmt|;
name|format
operator|+=
literal|2
expr_stmt|;
goto|goto
name|doField
goto|;
block|}
comment|/* 	 * Parse off a field specifier, compute how many characters 	 * will be needed to store the result, and substitute for 	 * "*" size specifiers. 	 */
operator|*
name|newPtr
operator|=
literal|'%'
expr_stmt|;
name|newPtr
operator|++
expr_stmt|;
name|format
operator|++
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|format
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|tmp
decl_stmt|;
comment|/* 	     * Check for an XPG3-style %n$ specification.  Note: there 	     * must not be a mixture of XPG3 specs and non-XPG3 specs 	     * in the same format string. 	     */
name|tmp
operator|=
name|strtoul
argument_list|(
name|format
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|!=
literal|'$'
condition|)
block|{
goto|goto
name|notXpg
goto|;
block|}
name|format
operator|=
name|end
operator|+
literal|1
expr_stmt|;
name|gotXpg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|gotSequential
condition|)
block|{
goto|goto
name|mixedXPG
goto|;
block|}
name|objIndex
operator|=
name|tmp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|objIndex
operator|<
literal|2
operator|)
operator|||
operator|(
name|objIndex
operator|>=
name|objc
operator|)
condition|)
block|{
goto|goto
name|badIndex
goto|;
block|}
goto|goto
name|xpgCheckDone
goto|;
block|}
name|notXpg
label|:
name|gotSequential
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|gotXpg
condition|)
block|{
goto|goto
name|mixedXPG
goto|;
block|}
name|xpgCheckDone
label|:
while|while
condition|(
operator|(
operator|*
name|format
operator|==
literal|'-'
operator|)
operator|||
operator|(
operator|*
name|format
operator|==
literal|'#'
operator|)
operator|||
operator|(
operator|*
name|format
operator|==
literal|'0'
operator|)
operator|||
operator|(
operator|*
name|format
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|format
operator|==
literal|'+'
operator|)
condition|)
block|{
operator|*
name|newPtr
operator|=
operator|*
name|format
expr_stmt|;
name|newPtr
operator|++
expr_stmt|;
name|format
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|format
argument_list|)
argument_list|)
condition|)
block|{
name|width
operator|=
name|strtoul
argument_list|(
name|format
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|format
operator|=
name|end
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|format
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|objIndex
operator|>=
name|objc
condition|)
block|{
goto|goto
name|badIndex
goto|;
block|}
if|if
condition|(
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
name|objIndex
index|]
argument_list|,
operator|&
name|width
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|fmtError
goto|;
block|}
name|objIndex
operator|++
expr_stmt|;
name|format
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|width
operator|>
literal|100000
condition|)
block|{
comment|/* 	     * Don't allow arbitrarily large widths:  could cause core 	     * dump when we try to allocate a zillion bytes of memory 	     * below. 	     */
name|width
operator|=
literal|100000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|<
literal|0
condition|)
block|{
name|width
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|width
operator|!=
literal|0
condition|)
block|{
name|TclFormatInt
argument_list|(
name|newPtr
argument_list|,
name|width
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|newPtr
operator|!=
literal|0
condition|)
block|{
name|newPtr
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|format
operator|==
literal|'.'
condition|)
block|{
operator|*
name|newPtr
operator|=
literal|'.'
expr_stmt|;
name|newPtr
operator|++
expr_stmt|;
name|format
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|format
argument_list|)
argument_list|)
condition|)
block|{
name|precision
operator|=
name|strtoul
argument_list|(
name|format
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|format
operator|=
name|end
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|format
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|objIndex
operator|>=
name|objc
condition|)
block|{
goto|goto
name|badIndex
goto|;
block|}
if|if
condition|(
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
name|objIndex
index|]
argument_list|,
operator|&
name|precision
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|fmtError
goto|;
block|}
name|objIndex
operator|++
expr_stmt|;
name|format
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|precision
operator|!=
literal|0
condition|)
block|{
name|TclFormatInt
argument_list|(
name|newPtr
argument_list|,
name|precision
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|newPtr
operator|!=
literal|0
condition|)
block|{
name|newPtr
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|format
operator|==
literal|'l'
condition|)
block|{
name|format
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|format
operator|==
literal|'h'
condition|)
block|{
name|useShort
operator|=
literal|1
expr_stmt|;
operator|*
name|newPtr
operator|=
literal|'h'
expr_stmt|;
name|newPtr
operator|++
expr_stmt|;
name|format
operator|++
expr_stmt|;
block|}
operator|*
name|newPtr
operator|=
operator|*
name|format
expr_stmt|;
name|newPtr
operator|++
expr_stmt|;
operator|*
name|newPtr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|objIndex
operator|>=
name|objc
condition|)
block|{
goto|goto
name|badIndex
goto|;
block|}
switch|switch
condition|(
operator|*
name|format
condition|)
block|{
case|case
literal|'i'
case|:
name|newPtr
index|[
operator|-
literal|1
index|]
operator|=
literal|'d'
expr_stmt|;
case|case
literal|'d'
case|:
case|case
literal|'o'
case|:
case|case
literal|'u'
case|:
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
if|if
condition|(
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
name|objIndex
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|intValue
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|fmtError
goto|;
block|}
name|whichValue
operator|=
name|INT_VALUE
expr_stmt|;
name|size
operator|=
literal|40
operator|+
name|precision
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|ptrValue
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|objIndex
index|]
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
name|objIndex
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|intValue
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|fmtError
goto|;
block|}
name|whichValue
operator|=
name|INT_VALUE
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
if|if
condition|(
name|Tcl_GetDoubleFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
name|objIndex
index|]
argument_list|,
operator|&
name|doubleValue
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|fmtError
goto|;
block|}
name|whichValue
operator|=
name|DOUBLE_VALUE
expr_stmt|;
name|size
operator|=
name|MAX_FLOAT_SIZE
expr_stmt|;
if|if
condition|(
name|precision
operator|>
literal|10
condition|)
block|{
name|size
operator|+=
name|precision
expr_stmt|;
block|}
break|break;
case|case
literal|0
case|:
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"format string ended in middle of field specifier"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
goto|goto
name|fmtError
goto|;
default|default:
block|{
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"bad field specifier \"%c\""
argument_list|,
operator|*
name|format
argument_list|)
expr_stmt|;
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
goto|goto
name|fmtError
goto|;
block|}
block|}
name|objIndex
operator|++
expr_stmt|;
name|format
operator|++
expr_stmt|;
comment|/* 	 * Make sure that there's enough space to hold the formatted 	 * result, then format it. 	 */
name|doField
label|:
if|if
condition|(
name|width
operator|>
name|size
condition|)
block|{
name|size
operator|=
name|width
expr_stmt|;
block|}
if|if
condition|(
name|noPercent
condition|)
block|{
name|Tcl_AppendToObj
argument_list|(
name|resultPtr
argument_list|,
name|ptrValue
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|size
operator|>
name|dstSize
condition|)
block|{
if|if
condition|(
name|dst
operator|!=
name|staticBuf
condition|)
block|{
name|ckfree
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
name|dst
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|size
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|dstSize
operator|=
name|size
expr_stmt|;
block|}
if|if
condition|(
name|whichValue
operator|==
name|DOUBLE_VALUE
condition|)
block|{
name|sprintf
argument_list|(
name|dst
argument_list|,
name|newFormat
argument_list|,
name|doubleValue
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|whichValue
operator|==
name|INT_VALUE
condition|)
block|{
if|if
condition|(
name|useShort
condition|)
block|{
name|sprintf
argument_list|(
name|dst
argument_list|,
name|newFormat
argument_list|,
operator|(
name|short
operator|)
name|intValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|dst
argument_list|,
name|newFormat
argument_list|,
name|intValue
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sprintf
argument_list|(
name|dst
argument_list|,
name|newFormat
argument_list|,
name|ptrValue
argument_list|)
expr_stmt|;
block|}
name|Tcl_AppendToObj
argument_list|(
name|resultPtr
argument_list|,
name|dst
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|resultPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|staticBuf
condition|)
block|{
name|ckfree
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
name|mixedXPG
label|:
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"cannot mix \"%\" and \"%n$\" conversion specifiers"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
goto|goto
name|fmtError
goto|;
name|badIndex
label|:
if|if
condition|(
name|gotXpg
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"\"%n$\" argument index out of range"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"not enough arguments for all format specifiers"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
block|}
name|fmtError
label|:
if|if
condition|(
name|dst
operator|!=
name|staticBuf
condition|)
block|{
name|ckfree
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
name|Tcl_DecrRefCount
argument_list|(
name|resultPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

end_unit

