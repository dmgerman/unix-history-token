begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclProc.c --  *  *	This file contains routines that implement Tcl procedures,  *	including the "proc" and "uplevel" commands.  *  * Copyright (c) 1987-1993 The Regents of the University of California.  * Copyright (c) 1994-1996 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclProc.c 1.115 97/08/12 13:36:11  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclCompile.h"
end_include

begin_comment
comment|/*  * Forward references to procedures defined later in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|CleanupProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Proc
operator|*
name|procPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InterpProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ProcDeleteProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ProcObjCmd --  *  *	This object-based procedure is invoked to process the "proc" Tcl   *	command. See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl object result value.  *  * Side effects:  *	A new procedure gets created.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_ProcObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
specifier|register
name|Proc
modifier|*
name|procPtr
decl_stmt|;
name|char
modifier|*
name|fullName
decl_stmt|,
modifier|*
name|procName
decl_stmt|,
modifier|*
name|args
decl_stmt|,
modifier|*
name|bytes
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
modifier|*
name|argArray
init|=
name|NULL
decl_stmt|;
name|Namespace
modifier|*
name|nsPtr
decl_stmt|,
modifier|*
name|altNsPtr
decl_stmt|,
modifier|*
name|cxtNsPtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|defPtr
decl_stmt|,
modifier|*
name|bodyPtr
decl_stmt|;
name|Tcl_Command
name|cmd
decl_stmt|;
name|Tcl_DString
name|ds
decl_stmt|;
name|int
name|numArgs
decl_stmt|,
name|length
decl_stmt|,
name|result
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|CompiledLocal
modifier|*
name|localPtr
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"name args body"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Determine the namespace where the procedure should reside. Unless      * the command name includes namespace qualifiers, this will be the      * current namespace.      */
name|fullName
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TclGetNamespaceForQualName
argument_list|(
name|interp
argument_list|,
name|fullName
argument_list|,
operator|(
name|Namespace
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|,
operator|&
name|nsPtr
argument_list|,
operator|&
name|altNsPtr
argument_list|,
operator|&
name|cxtNsPtr
argument_list|,
operator|&
name|procName
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
if|if
condition|(
name|nsPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"can't create procedure \""
argument_list|,
name|fullName
argument_list|,
literal|"\": unknown namespace"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|procName
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"can't create procedure \""
argument_list|,
name|fullName
argument_list|,
literal|"\": bad procedure name"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|nsPtr
operator|!=
name|iPtr
operator|->
name|globalNsPtr
operator|)
operator|&&
operator|(
name|procName
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|procName
index|[
literal|0
index|]
operator|==
literal|':'
operator|)
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"can't create procedure \""
argument_list|,
name|procName
argument_list|,
literal|"\" in non-global namespace with name starting with \":\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * If the procedure's body object is shared because its string value is      * identical to, e.g., the body of another procedure, we must create a      * private copy for this procedure to use. Such sharing of procedure      * bodies is rare but can cause problems. A procedure body is compiled      * in a context that includes the number of compiler-allocated "slots"      * for local variables. Each formal parameter is given a local variable      * slot (the "procPtr->numCompiledLocals = numArgs" assignment      * below). This means that the same code can not be shared by two      * procedures that have a different number of arguments, even if their      * bodies are identical. Note that we don't use Tcl_DuplicateObj since      * we would not want any bytecode internal representation.      */
name|bodyPtr
operator|=
name|objv
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|bodyPtr
argument_list|)
condition|)
block|{
name|bytes
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|bodyPtr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|bodyPtr
operator|=
name|Tcl_NewStringObj
argument_list|(
name|bytes
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|/*      * Create and initialize a Proc structure for the procedure. Note that      * we initialize its cmdPtr field below after we've created the command      * for the procedure. We increment the ref count of the procedure's      * body object since there will be a reference to it in the Proc      * structure.      */
name|Tcl_IncrRefCount
argument_list|(
name|bodyPtr
argument_list|)
expr_stmt|;
name|procPtr
operator|=
operator|(
name|Proc
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Proc
argument_list|)
argument_list|)
expr_stmt|;
name|procPtr
operator|->
name|iPtr
operator|=
name|iPtr
expr_stmt|;
name|procPtr
operator|->
name|refCount
operator|=
literal|1
expr_stmt|;
name|procPtr
operator|->
name|bodyPtr
operator|=
name|bodyPtr
expr_stmt|;
name|procPtr
operator|->
name|numArgs
operator|=
literal|0
expr_stmt|;
comment|/* actual argument count is set below. */
name|procPtr
operator|->
name|numCompiledLocals
operator|=
literal|0
expr_stmt|;
name|procPtr
operator|->
name|firstLocalPtr
operator|=
name|NULL
expr_stmt|;
name|procPtr
operator|->
name|lastLocalPtr
operator|=
name|NULL
expr_stmt|;
comment|/*      * Break up the argument list into argument specifiers, then process      * each argument specifier.      * THIS FAILS IF THE ARG LIST OBJECT'S STRING REP CONTAINS NULLS.      */
name|args
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_SplitList
argument_list|(
name|interp
argument_list|,
name|args
argument_list|,
operator|&
name|numArgs
argument_list|,
operator|&
name|argArray
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|procError
goto|;
block|}
name|procPtr
operator|->
name|numArgs
operator|=
name|numArgs
expr_stmt|;
name|procPtr
operator|->
name|numCompiledLocals
operator|=
name|numArgs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numArgs
condition|;
name|i
operator|++
control|)
block|{
name|int
name|fieldCount
decl_stmt|,
name|nameLength
decl_stmt|,
name|valueLength
decl_stmt|;
name|char
modifier|*
modifier|*
name|fieldValues
decl_stmt|;
comment|/* 	 * Now divide the specifier up into name and default. 	 */
name|result
operator|=
name|Tcl_SplitList
argument_list|(
name|interp
argument_list|,
name|argArray
index|[
name|i
index|]
argument_list|,
operator|&
name|fieldCount
argument_list|,
operator|&
name|fieldValues
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|procError
goto|;
block|}
if|if
condition|(
name|fieldCount
operator|>
literal|2
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fieldValues
argument_list|)
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"too many fields in argument specifier \""
argument_list|,
name|argArray
index|[
name|i
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|procError
goto|;
block|}
if|if
condition|(
operator|(
name|fieldCount
operator|==
literal|0
operator|)
operator|||
operator|(
operator|*
name|fieldValues
index|[
literal|0
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fieldValues
argument_list|)
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"procedure \""
argument_list|,
name|fullName
argument_list|,
literal|"\" has argument with no name"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|procError
goto|;
block|}
name|nameLength
operator|=
name|strlen
argument_list|(
name|fieldValues
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldCount
operator|==
literal|2
condition|)
block|{
name|valueLength
operator|=
name|strlen
argument_list|(
name|fieldValues
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|valueLength
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Check that the formal parameter name is a scalar. 	 */
name|p
operator|=
name|fieldValues
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
block|{
name|char
modifier|*
name|q
init|=
name|p
decl_stmt|;
do|do
block|{
name|q
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|q
operator|!=
literal|'\0'
condition|)
do|;
name|q
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|')'
condition|)
block|{
comment|/* we have an array element */
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"procedure \""
argument_list|,
name|fullName
argument_list|,
literal|"\" has formal parameter \""
argument_list|,
name|fieldValues
index|[
literal|0
index|]
argument_list|,
literal|"\" that is an array element"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fieldValues
argument_list|)
expr_stmt|;
goto|goto
name|procError
goto|;
block|}
block|}
name|p
operator|++
expr_stmt|;
block|}
comment|/* 	 * Allocate an entry in the runtime procedure frame's array of local 	 * variables for the argument.  	 */
name|localPtr
operator|=
operator|(
name|CompiledLocal
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|CompiledLocal
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|localPtr
operator|->
name|name
argument_list|)
operator|+
name|nameLength
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|procPtr
operator|->
name|firstLocalPtr
operator|==
name|NULL
condition|)
block|{
name|procPtr
operator|->
name|firstLocalPtr
operator|=
name|procPtr
operator|->
name|lastLocalPtr
operator|=
name|localPtr
expr_stmt|;
block|}
else|else
block|{
name|procPtr
operator|->
name|lastLocalPtr
operator|->
name|nextPtr
operator|=
name|localPtr
expr_stmt|;
name|procPtr
operator|->
name|lastLocalPtr
operator|=
name|localPtr
expr_stmt|;
block|}
name|localPtr
operator|->
name|nextPtr
operator|=
name|NULL
expr_stmt|;
name|localPtr
operator|->
name|nameLength
operator|=
name|nameLength
expr_stmt|;
name|localPtr
operator|->
name|frameIndex
operator|=
name|i
expr_stmt|;
name|localPtr
operator|->
name|isArg
operator|=
literal|1
expr_stmt|;
name|localPtr
operator|->
name|isTemp
operator|=
literal|0
expr_stmt|;
name|localPtr
operator|->
name|flags
operator|=
name|VAR_SCALAR
expr_stmt|;
if|if
condition|(
name|fieldCount
operator|==
literal|2
condition|)
block|{
name|localPtr
operator|->
name|defValuePtr
operator|=
name|Tcl_NewStringObj
argument_list|(
name|fieldValues
index|[
literal|1
index|]
argument_list|,
name|valueLength
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|localPtr
operator|->
name|defValuePtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|localPtr
operator|->
name|defValuePtr
operator|=
name|NULL
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|localPtr
operator|->
name|name
argument_list|,
name|fieldValues
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fieldValues
argument_list|)
expr_stmt|;
block|}
comment|/*      * Now create a command for the procedure. This will initially be in      * the current namespace unless the procedure's name included namespace      * qualifiers. To create the new command in the right namespace, we      * generate a fully qualified name for it.      */
name|Tcl_DStringInit
argument_list|(
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsPtr
operator|!=
name|iPtr
operator|->
name|globalNsPtr
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|ds
argument_list|,
name|nsPtr
operator|->
name|fullName
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|ds
argument_list|,
literal|"::"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|Tcl_DStringAppend
argument_list|(
operator|&
name|ds
argument_list|,
name|procName
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|ds
argument_list|)
argument_list|,
name|InterpProc
argument_list|,
operator|(
name|ClientData
operator|)
name|procPtr
argument_list|,
name|ProcDeleteProc
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|Tcl_CreateObjCommand
argument_list|(
name|interp
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|ds
argument_list|)
argument_list|,
name|TclObjInterpProc
argument_list|,
operator|(
name|ClientData
operator|)
name|procPtr
argument_list|,
name|ProcDeleteProc
argument_list|)
expr_stmt|;
comment|/*      * Now initialize the new procedure's cmdPtr field. This will be used      * later when the procedure is called to determine what namespace the      * procedure will run in. This will be different than the current      * namespace if the proc was renamed into a different namespace.      */
name|procPtr
operator|->
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|cmd
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argArray
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
name|procError
label|:
name|Tcl_DecrRefCount
argument_list|(
name|bodyPtr
argument_list|)
expr_stmt|;
while|while
condition|(
name|procPtr
operator|->
name|firstLocalPtr
operator|!=
name|NULL
condition|)
block|{
name|localPtr
operator|=
name|procPtr
operator|->
name|firstLocalPtr
expr_stmt|;
name|procPtr
operator|->
name|firstLocalPtr
operator|=
name|localPtr
operator|->
name|nextPtr
expr_stmt|;
name|defPtr
operator|=
name|localPtr
operator|->
name|defValuePtr
expr_stmt|;
if|if
condition|(
name|defPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|defPtr
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|localPtr
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|procPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|argArray
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argArray
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclGetFrame --  *  *	Given a description of a procedure frame, such as the first  *	argument to an "uplevel" or "upvar" command, locate the  *	call frame for the appropriate level of procedure.  *  * Results:  *	The return value is -1 if an error occurred in finding the  *	frame (in this case an error message is left in interp->result).  *	1 is returned if string was either a number or a number preceded  *	by "#" and it specified a valid frame.  0 is returned if string  *	isn't one of the two things above (in this case, the lookup  *	acts as if string were "1").  The variable pointed to by  *	framePtrPtr is filled in with the address of the desired frame  *	(unless an error occurs, in which case it isn't modified).  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclGetFrame
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|framePtrPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to find frame. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String describing frame. */
name|CallFrame
modifier|*
modifier|*
name|framePtrPtr
decl_stmt|;
comment|/* Store pointer to frame here (or NULL 				 * if global frame indicated). */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|int
name|curLevel
decl_stmt|,
name|level
decl_stmt|,
name|result
decl_stmt|;
name|CallFrame
modifier|*
name|framePtr
decl_stmt|;
comment|/*      * Parse string to figure out which level number to go to.      */
name|result
operator|=
literal|1
expr_stmt|;
name|curLevel
operator|=
operator|(
name|iPtr
operator|->
name|varFramePtr
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|iPtr
operator|->
name|varFramePtr
operator|->
name|level
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'#'
condition|)
block|{
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|string
operator|+
literal|1
argument_list|,
operator|&
name|level
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|level
operator|<
literal|0
condition|)
block|{
name|levelError
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad level \""
argument_list|,
name|string
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|string
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
operator|&
name|level
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|level
operator|=
name|curLevel
operator|-
name|level
expr_stmt|;
block|}
else|else
block|{
name|level
operator|=
name|curLevel
operator|-
literal|1
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * Figure out which frame to use, and modify the interpreter so      * its variables come from that frame.      */
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
name|framePtr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|framePtr
operator|=
name|iPtr
operator|->
name|varFramePtr
init|;
name|framePtr
operator|!=
name|NULL
condition|;
name|framePtr
operator|=
name|framePtr
operator|->
name|callerVarPtr
control|)
block|{
if|if
condition|(
name|framePtr
operator|->
name|level
operator|==
name|level
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|framePtr
operator|==
name|NULL
condition|)
block|{
goto|goto
name|levelError
goto|;
block|}
block|}
operator|*
name|framePtrPtr
operator|=
name|framePtr
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_UplevelObjCmd --  *  *	This object procedure is invoked to process the "uplevel" Tcl  *	command. See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl object result value.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_UplevelObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|char
modifier|*
name|optLevel
decl_stmt|;
name|int
name|length
decl_stmt|,
name|result
decl_stmt|;
name|CallFrame
modifier|*
name|savedVarFramePtr
decl_stmt|,
modifier|*
name|framePtr
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|2
condition|)
block|{
name|uplevelSyntax
label|:
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"?level? command ?arg ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Find the level to use for executing the command.      * THIS FAILS IF THE OBJECT RESULT'S STRING REP CONTAINS A NULL.      */
name|optLevel
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|result
operator|=
name|TclGetFrame
argument_list|(
name|interp
argument_list|,
name|optLevel
argument_list|,
operator|&
name|framePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|objc
operator|-=
operator|(
name|result
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|objc
operator|==
literal|0
condition|)
block|{
goto|goto
name|uplevelSyntax
goto|;
block|}
name|objv
operator|+=
operator|(
name|result
operator|+
literal|1
operator|)
expr_stmt|;
comment|/*      * Modify the interpreter state to execute in the given frame.      */
name|savedVarFramePtr
operator|=
name|iPtr
operator|->
name|varFramePtr
expr_stmt|;
name|iPtr
operator|->
name|varFramePtr
operator|=
name|framePtr
expr_stmt|;
comment|/*      * Execute the residual arguments as a command.      */
if|if
condition|(
name|objc
operator|==
literal|1
condition|)
block|{
name|result
operator|=
name|Tcl_EvalObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_Obj
modifier|*
name|cmdObjPtr
init|=
name|Tcl_ConcatObj
argument_list|(
name|objc
argument_list|,
name|objv
argument_list|)
decl_stmt|;
name|result
operator|=
name|Tcl_EvalObj
argument_list|(
name|interp
argument_list|,
name|cmdObjPtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|cmdObjPtr
argument_list|)
expr_stmt|;
comment|/* done with object */
block|}
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|char
name|msg
index|[
literal|60
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n    (\"uplevel\" body line %d)"
argument_list|,
name|interp
operator|->
name|errorLine
argument_list|)
expr_stmt|;
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|msg
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*      * Restore the variable frame, and return.      */
name|iPtr
operator|->
name|varFramePtr
operator|=
name|savedVarFramePtr
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclFindProc --  *  *	Given the name of a procedure, return a pointer to the  *	record describing the procedure.  *  * Results:  *	NULL is returned if the name doesn't correspond to any  *	procedure.  Otherwise the return value is a pointer to  *	the procedure's record.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Proc
modifier|*
name|TclFindProc
parameter_list|(
name|iPtr
parameter_list|,
name|procName
parameter_list|)
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Interpreter in which to look. */
name|char
modifier|*
name|procName
decl_stmt|;
comment|/* Name of desired procedure. */
block|{
name|Tcl_Command
name|cmd
decl_stmt|;
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
name|cmd
operator|=
name|Tcl_FindCommand
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
name|procName
argument_list|,
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|NULL
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
operator|(
name|Tcl_Command
operator|)
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|cmd
expr_stmt|;
if|if
condition|(
name|cmdPtr
operator|->
name|proc
operator|!=
name|InterpProc
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
operator|(
name|Proc
operator|*
operator|)
name|cmdPtr
operator|->
name|clientData
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclIsProc --  *  *	Tells whether a command is a Tcl procedure or not.  *  * Results:  *	If the given command is actuall a Tcl procedure, the  *	return value is the address of the record describing  *	the procedure.  Otherwise the return value is 0.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Proc
modifier|*
name|TclIsProc
parameter_list|(
name|cmdPtr
parameter_list|)
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
comment|/* Command to test. */
block|{
if|if
condition|(
name|cmdPtr
operator|->
name|proc
operator|==
name|InterpProc
condition|)
block|{
return|return
operator|(
name|Proc
operator|*
operator|)
name|cmdPtr
operator|->
name|clientData
return|;
block|}
return|return
operator|(
name|Proc
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InterpProc --  *  *	When a Tcl procedure gets invoked with an argc/argv array of  *	strings, this routine gets invoked to interpret the procedure.  *  * Results:  *	A standard Tcl result value, usually TCL_OK.  *  * Side effects:  *	Depends on the commands in the procedure.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InterpProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Record describing procedure to be 				 * interpreted. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which procedure was 				 * invoked. */
name|int
name|argc
decl_stmt|;
comment|/* Count of number of arguments to this 				 * procedure. */
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument values. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/*      * This procedure generates an objv array for object arguments that hold      * the argv strings. It starts out with stack-allocated space but uses      * dynamically-allocated storage if needed.      */
define|#
directive|define
name|NUM_ARGS
value|20
name|Tcl_Obj
argument_list|*
operator|(
name|objStorage
index|[
name|NUM_ARGS
index|]
operator|)
argument_list|;
specifier|register
name|Tcl_Obj
operator|*
operator|*
name|objv
operator|=
name|objStorage
argument_list|;
comment|/*      * Create the object argument array "objv". Make sure objv is large      * enough to hold the objc arguments plus 1 extra for the zero      * end-of-objv word.      */
argument_list|if
operator|(
operator|(
name|argc
operator|+
literal|1
operator|)
operator|>
name|NUM_ARGS
operator|)
block|{
name|objv
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|argc
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
argument_list|)
block|;     }
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|objv
index|[
name|i
index|]
operator|=
name|Tcl_NewStringObj
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|objv
index|[
name|argc
index|]
operator|=
literal|0
expr_stmt|;
comment|/*      * Use TclObjInterpProc to actually interpret the procedure.      */
name|result
operator|=
name|TclObjInterpProc
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|argc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
comment|/*      * Move the interpreter's object result to the string result,       * then reset the object result.      * FAILS IF OBJECT RESULT'S STRING REPRESENTATION CONTAINS NULLS.      */
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|TclGetStringFromObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
comment|/*      * Decrement the ref counts on the objv elements since we are done      * with them.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|objPtr
operator|=
name|objv
index|[
name|i
index|]
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * Free the objv array if malloc'ed storage was used.      */
if|if
condition|(
name|objv
operator|!=
name|objStorage
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|objv
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
undef|#
directive|undef
name|NUM_ARGS
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclObjInterpProc --  *  *	When a Tcl procedure gets invoked during bytecode evaluation, this   *	object-based routine gets invoked to interpret the procedure.  *  * Results:  *	A standard Tcl object result value.  *  * Side effects:  *	Depends on the commands in the procedure.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclObjInterpProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Record describing procedure to be 				 * interpreted. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which procedure was 				 * invoked. */
name|int
name|objc
decl_stmt|;
comment|/* Count of number of arguments to this 				 * procedure. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument value objects. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Proc
modifier|*
name|procPtr
init|=
operator|(
name|Proc
operator|*
operator|)
name|clientData
decl_stmt|;
name|Tcl_Obj
modifier|*
name|bodyPtr
init|=
name|procPtr
operator|->
name|bodyPtr
decl_stmt|;
name|CallFrame
name|frame
decl_stmt|;
specifier|register
name|CallFrame
modifier|*
name|framePtr
init|=
operator|&
name|frame
decl_stmt|;
specifier|register
name|Var
modifier|*
name|varPtr
decl_stmt|;
specifier|register
name|CompiledLocal
modifier|*
name|localPtr
decl_stmt|;
name|Proc
modifier|*
name|saveProcPtr
decl_stmt|;
name|char
modifier|*
name|procName
decl_stmt|,
modifier|*
name|bytes
decl_stmt|;
name|int
name|nameLen
decl_stmt|,
name|localCt
decl_stmt|,
name|numArgs
decl_stmt|,
name|argCt
decl_stmt|,
name|length
decl_stmt|,
name|i
decl_stmt|,
name|result
decl_stmt|;
comment|/*      * This procedure generates an array "compiledLocals" that holds the      * storage for local variables. It starts out with stack-allocated space      * but uses dynamically-allocated storage if needed.      */
define|#
directive|define
name|NUM_LOCALS
value|20
name|Var
name|localStorage
index|[
name|NUM_LOCALS
index|]
decl_stmt|;
name|Var
modifier|*
name|compiledLocals
init|=
name|localStorage
decl_stmt|;
comment|/*      * Get the procedure's name.      * THIS FAILS IF THE PROC NAME'S STRING REP HAS A NULL.      */
name|procName
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|0
index|]
argument_list|,
operator|&
name|nameLen
argument_list|)
expr_stmt|;
comment|/*      * If necessary, compile the procedure's body. The compiler will      * allocate frame slots for the procedure's non-argument local      * variables. If the ByteCode already exists, make sure it hasn't been      * invalidated by someone redefining a core command (this might make the      * compiled code wrong). Also, if the code was compiled in/for a      * different interpreter, we recompile it. Note that compiling the body      * might increase procPtr->numCompiledLocals if new local variables are      * found while compiling.      */
if|if
condition|(
name|bodyPtr
operator|->
name|typePtr
operator|==
operator|&
name|tclByteCodeType
condition|)
block|{
name|ByteCode
modifier|*
name|codePtr
init|=
operator|(
name|ByteCode
operator|*
operator|)
name|bodyPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
decl_stmt|;
if|if
condition|(
operator|(
name|codePtr
operator|->
name|iPtr
operator|!=
name|iPtr
operator|)
operator|||
operator|(
name|codePtr
operator|->
name|compileEpoch
operator|!=
name|iPtr
operator|->
name|compileEpoch
operator|)
condition|)
block|{
name|tclByteCodeType
operator|.
name|freeIntRepProc
argument_list|(
name|bodyPtr
argument_list|)
expr_stmt|;
name|bodyPtr
operator|->
name|typePtr
operator|=
operator|(
name|Tcl_ObjType
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bodyPtr
operator|->
name|typePtr
operator|!=
operator|&
name|tclByteCodeType
condition|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|int
name|numChars
decl_stmt|;
name|char
modifier|*
name|ellipsis
decl_stmt|;
if|if
condition|(
name|tclTraceCompile
operator|>=
literal|1
condition|)
block|{
comment|/* 	     * Display a line summarizing the top level command we 	     * are about to compile. 	     */
name|numChars
operator|=
name|nameLen
expr_stmt|;
name|ellipsis
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|numChars
operator|>
literal|50
condition|)
block|{
name|numChars
operator|=
literal|50
expr_stmt|;
name|ellipsis
operator|=
literal|"..."
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Compiling body of proc \"%.*s%s\"\n"
argument_list|,
name|numChars
argument_list|,
name|procName
argument_list|,
name|ellipsis
argument_list|)
expr_stmt|;
block|}
name|saveProcPtr
operator|=
name|iPtr
operator|->
name|compiledProcPtr
expr_stmt|;
name|iPtr
operator|->
name|compiledProcPtr
operator|=
name|procPtr
expr_stmt|;
name|result
operator|=
name|tclByteCodeType
operator|.
name|setFromAnyProc
argument_list|(
name|interp
argument_list|,
name|bodyPtr
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|compiledProcPtr
operator|=
name|saveProcPtr
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|numChars
operator|=
name|nameLen
expr_stmt|;
name|ellipsis
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|numChars
operator|>
literal|50
condition|)
block|{
name|numChars
operator|=
literal|50
expr_stmt|;
name|ellipsis
operator|=
literal|"..."
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\n    (compiling body of proc \"%.*s%s\", line %d)"
argument_list|,
name|numChars
argument_list|,
name|procName
argument_list|,
name|ellipsis
argument_list|,
name|interp
operator|->
name|errorLine
argument_list|)
expr_stmt|;
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
comment|/*      * Create the "compiledLocals" array. Make sure it is large enough to      * hold all the procedure's compiled local variables, including its      * formal parameters.      */
name|localCt
operator|=
name|procPtr
operator|->
name|numCompiledLocals
expr_stmt|;
if|if
condition|(
name|localCt
operator|>
name|NUM_LOCALS
condition|)
block|{
name|compiledLocals
operator|=
operator|(
name|Var
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|localCt
operator|*
sizeof|sizeof
argument_list|(
name|Var
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*      * Set up and push a new call frame for the new procedure invocation.      * This call frame will execute in the proc's namespace, which might      * be different than the current namespace. The proc's namespace is      * that of its command, which can change if the command is renamed      * from one namespace to another.      */
name|result
operator|=
name|Tcl_PushCallFrame
argument_list|(
name|interp
argument_list|,
operator|(
name|Tcl_CallFrame
operator|*
operator|)
name|framePtr
argument_list|,
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|procPtr
operator|->
name|cmdPtr
operator|->
name|nsPtr
argument_list|,
comment|/*isProcCallFrame*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
name|framePtr
operator|->
name|objc
operator|=
name|objc
expr_stmt|;
name|framePtr
operator|->
name|objv
operator|=
name|objv
expr_stmt|;
comment|/* ref counts for args are incremented below */
name|framePtr
operator|->
name|procPtr
operator|=
name|procPtr
expr_stmt|;
name|framePtr
operator|->
name|numCompiledLocals
operator|=
name|localCt
expr_stmt|;
name|framePtr
operator|->
name|compiledLocals
operator|=
name|compiledLocals
expr_stmt|;
comment|/*      * Initialize the array of local variables stored in the call frame.      */
name|varPtr
operator|=
name|framePtr
operator|->
name|compiledLocals
expr_stmt|;
for|for
control|(
name|localPtr
operator|=
name|procPtr
operator|->
name|firstLocalPtr
init|;
name|localPtr
operator|!=
name|NULL
condition|;
name|localPtr
operator|=
name|localPtr
operator|->
name|nextPtr
control|)
block|{
name|varPtr
operator|->
name|value
operator|.
name|objPtr
operator|=
name|NULL
expr_stmt|;
name|varPtr
operator|->
name|name
operator|=
name|localPtr
operator|->
name|name
expr_stmt|;
comment|/* will be just '\0' if temp var */
name|varPtr
operator|->
name|nsPtr
operator|=
name|procPtr
operator|->
name|cmdPtr
operator|->
name|nsPtr
expr_stmt|;
name|varPtr
operator|->
name|hPtr
operator|=
name|NULL
expr_stmt|;
name|varPtr
operator|->
name|refCount
operator|=
literal|0
expr_stmt|;
name|varPtr
operator|->
name|tracePtr
operator|=
name|NULL
expr_stmt|;
name|varPtr
operator|->
name|searchPtr
operator|=
name|NULL
expr_stmt|;
name|varPtr
operator|->
name|flags
operator|=
operator|(
name|localPtr
operator|->
name|flags
operator||
name|VAR_UNDEFINED
operator|)
expr_stmt|;
name|varPtr
operator|++
expr_stmt|;
block|}
comment|/*      * Match and assign the call's actual parameters to the procedure's      * formal arguments. The formal arguments are described by the first      * numArgs entries in both the Proc structure's local variable list and      * the call frame's local variable array.      */
name|numArgs
operator|=
name|procPtr
operator|->
name|numArgs
expr_stmt|;
name|varPtr
operator|=
name|framePtr
operator|->
name|compiledLocals
expr_stmt|;
name|localPtr
operator|=
name|procPtr
operator|->
name|firstLocalPtr
expr_stmt|;
name|argCt
operator|=
name|objc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|argCt
operator|-=
literal|1
init|;
name|i
operator|<=
name|numArgs
condition|;
name|i
operator|++
operator|,
name|argCt
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|localPtr
operator|->
name|isArg
condition|)
block|{
name|panic
argument_list|(
literal|"TclObjInterpProc: local variable %s is not argument but should be"
argument_list|,
name|localPtr
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|localPtr
operator|->
name|isTemp
condition|)
block|{
name|panic
argument_list|(
literal|"TclObjInterpProc: local variable %d is temporary but should be an argument"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/* 	 * Handle the special case of the last formal being "args".  When 	 * it occurs, assign it a list consisting of all the remaining 	 * actual arguments. 	 */
if|if
condition|(
operator|(
name|i
operator|==
name|numArgs
operator|)
operator|&&
operator|(
operator|(
name|localPtr
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'a'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|localPtr
operator|->
name|name
argument_list|,
literal|"args"
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|Tcl_Obj
modifier|*
name|listPtr
init|=
name|Tcl_NewListObj
argument_list|(
name|argCt
argument_list|,
operator|&
operator|(
name|objv
index|[
name|i
index|]
operator|)
argument_list|)
decl_stmt|;
name|varPtr
operator|->
name|value
operator|.
name|objPtr
operator|=
name|listPtr
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|listPtr
argument_list|)
expr_stmt|;
comment|/* local var is a reference */
name|varPtr
operator|->
name|flags
operator|&=
operator|~
name|VAR_UNDEFINED
expr_stmt|;
name|argCt
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* done processing args */
block|}
elseif|else
if|if
condition|(
name|argCt
operator|>
literal|0
condition|)
block|{
name|Tcl_Obj
modifier|*
name|objPtr
init|=
name|objv
index|[
name|i
index|]
decl_stmt|;
name|varPtr
operator|->
name|value
operator|.
name|objPtr
operator|=
name|objPtr
expr_stmt|;
name|varPtr
operator|->
name|flags
operator|&=
operator|~
name|VAR_UNDEFINED
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
comment|/* since the local variable now has 					* another reference to object. */
block|}
elseif|else
if|if
condition|(
name|localPtr
operator|->
name|defValuePtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_Obj
modifier|*
name|objPtr
init|=
name|localPtr
operator|->
name|defValuePtr
decl_stmt|;
name|varPtr
operator|->
name|value
operator|.
name|objPtr
operator|=
name|objPtr
expr_stmt|;
name|varPtr
operator|->
name|flags
operator|&=
operator|~
name|VAR_UNDEFINED
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
comment|/* since the local variable now has 					* another reference to object. */
block|}
else|else
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"no value given for parameter \""
argument_list|,
name|localPtr
operator|->
name|name
argument_list|,
literal|"\" to \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|0
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|procDone
goto|;
block|}
name|varPtr
operator|++
expr_stmt|;
name|localPtr
operator|=
name|localPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
if|if
condition|(
name|argCt
operator|>
literal|0
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"called \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|0
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
literal|"\" with too many arguments"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|procDone
goto|;
block|}
comment|/*      * Invoke the commands in the procedure's body.      */
if|if
condition|(
name|tclTraceExec
operator|>=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Calling proc "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|bytes
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|TclPrintSource
argument_list|(
name|stdout
argument_list|,
name|bytes
argument_list|,
name|TclMin
argument_list|(
name|length
argument_list|,
literal|15
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|iPtr
operator|->
name|returnCode
operator|=
name|TCL_OK
expr_stmt|;
name|procPtr
operator|->
name|refCount
operator|++
expr_stmt|;
name|result
operator|=
name|Tcl_EvalObj
argument_list|(
name|interp
argument_list|,
name|procPtr
operator|->
name|bodyPtr
argument_list|)
expr_stmt|;
name|procPtr
operator|->
name|refCount
operator|--
expr_stmt|;
if|if
condition|(
name|procPtr
operator|->
name|refCount
operator|<=
literal|0
condition|)
block|{
name|CleanupProc
argument_list|(
name|procPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_RETURN
condition|)
block|{
name|result
operator|=
name|TclUpdateReturnInfo
argument_list|(
name|iPtr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|char
name|msg
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n    (procedure \"%.50s\" line %d)"
argument_list|,
name|procName
argument_list|,
name|iPtr
operator|->
name|errorLine
argument_list|)
expr_stmt|;
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|msg
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|TCL_BREAK
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"invoked \"break\" outside of a loop"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|TCL_CONTINUE
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"invoked \"continue\" outside of a loop"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
block|}
name|procDone
label|:
comment|/*      * Pop and free the call frame for this procedure invocation.      */
name|Tcl_PopCallFrame
argument_list|(
name|interp
argument_list|)
expr_stmt|;
comment|/*      * Free the compiledLocals array if malloc'ed storage was used.      */
if|if
condition|(
name|compiledLocals
operator|!=
name|localStorage
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|compiledLocals
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
undef|#
directive|undef
name|NUM_LOCALS
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * ProcDeleteProc --  *  *	This procedure is invoked just before a command procedure is  *	removed from an interpreter.  Its job is to release all the  *	resources allocated to the procedure.  *  * Results:  *	None.  *  * Side effects:  *	Memory gets freed, unless the procedure is actively being  *	executed.  In this case the cleanup is delayed until the  *	last call to the current procedure completes.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ProcDeleteProc
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Procedure to be deleted. */
block|{
name|Proc
modifier|*
name|procPtr
init|=
operator|(
name|Proc
operator|*
operator|)
name|clientData
decl_stmt|;
name|procPtr
operator|->
name|refCount
operator|--
expr_stmt|;
if|if
condition|(
name|procPtr
operator|->
name|refCount
operator|<=
literal|0
condition|)
block|{
name|CleanupProc
argument_list|(
name|procPtr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CleanupProc --  *  *	This procedure does all the real work of freeing up a Proc  *	structure.  It's called only when the structure's reference  *	count becomes zero.  *  * Results:  *	None.  *  * Side effects:  *	Memory gets freed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|CleanupProc
parameter_list|(
name|procPtr
parameter_list|)
specifier|register
name|Proc
modifier|*
name|procPtr
decl_stmt|;
comment|/* Procedure to be deleted. */
block|{
specifier|register
name|CompiledLocal
modifier|*
name|localPtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|bodyPtr
init|=
name|procPtr
operator|->
name|bodyPtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|defPtr
decl_stmt|;
if|if
condition|(
name|bodyPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|bodyPtr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|localPtr
operator|=
name|procPtr
operator|->
name|firstLocalPtr
init|;
name|localPtr
operator|!=
name|NULL
condition|;
control|)
block|{
name|CompiledLocal
modifier|*
name|nextPtr
init|=
name|localPtr
operator|->
name|nextPtr
decl_stmt|;
if|if
condition|(
name|localPtr
operator|->
name|defValuePtr
operator|!=
name|NULL
condition|)
block|{
name|defPtr
operator|=
name|localPtr
operator|->
name|defValuePtr
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|defPtr
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|localPtr
argument_list|)
expr_stmt|;
name|localPtr
operator|=
name|nextPtr
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|procPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclUpdateReturnInfo --  *  *	This procedure is called when procedures return, and at other  *	points where the TCL_RETURN code is used.  It examines fields  *	such as iPtr->returnCode and iPtr->errorCode and modifies  *	the real return status accordingly.  *  * Results:  *	The return value is the true completion code to use for  *	the procedure, instead of TCL_RETURN.  *  * Side effects:  *	The errorInfo and errorCode variables may get modified.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclUpdateReturnInfo
parameter_list|(
name|iPtr
parameter_list|)
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Interpreter for which TCL_RETURN 				 * exception is being processed. */
block|{
name|int
name|code
decl_stmt|;
name|code
operator|=
name|iPtr
operator|->
name|returnCode
expr_stmt|;
name|iPtr
operator|->
name|returnCode
operator|=
name|TCL_OK
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TCL_ERROR
condition|)
block|{
name|Tcl_SetVar2
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|iPtr
operator|->
name|errorCode
operator|!=
name|NULL
operator|)
condition|?
name|iPtr
operator|->
name|errorCode
else|:
literal|"NONE"
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|flags
operator||=
name|ERROR_CODE_SET
expr_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|errorInfo
operator|!=
name|NULL
condition|)
block|{
name|Tcl_SetVar2
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"errorInfo"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|iPtr
operator|->
name|errorInfo
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|flags
operator||=
name|ERR_IN_PROGRESS
expr_stmt|;
block|}
block|}
return|return
name|code
return|;
block|}
end_function

end_unit

