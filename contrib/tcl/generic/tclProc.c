begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclProc.c --  *  *	This file contains routines that implement Tcl procedures,  *	including the "proc" and "uplevel" commands.  *  * Copyright (c) 1987-1993 The Regents of the University of California.  * Copyright (c) 1994-1995 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclProc.c 1.72 96/02/15 11:42:48  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_comment
comment|/*  * Forward references to procedures defined later in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|CleanupProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Proc
operator|*
name|procPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InterpProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ProcDeleteProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ProcCmd --  *  *	This procedure is invoked to process the "proc" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result value.  *  * Side effects:  *	A new procedure gets created.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_ProcCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
specifier|register
name|Proc
modifier|*
name|procPtr
decl_stmt|;
name|int
name|result
decl_stmt|,
name|argCount
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|argArray
init|=
name|NULL
decl_stmt|;
name|Arg
modifier|*
name|lastArgPtr
decl_stmt|;
specifier|register
name|Arg
modifier|*
name|argPtr
init|=
name|NULL
decl_stmt|;
comment|/* Initialization not needed, but 					 * prevents compiler warning. */
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" name args body\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|procPtr
operator|=
operator|(
name|Proc
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Proc
argument_list|)
argument_list|)
expr_stmt|;
name|procPtr
operator|->
name|iPtr
operator|=
name|iPtr
expr_stmt|;
name|procPtr
operator|->
name|refCount
operator|=
literal|1
expr_stmt|;
name|procPtr
operator|->
name|command
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|procPtr
operator|->
name|command
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|procPtr
operator|->
name|argPtr
operator|=
name|NULL
expr_stmt|;
comment|/*      * Break up the argument list into argument specifiers, then process      * each argument specifier.      */
name|result
operator|=
name|Tcl_SplitList
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|argCount
argument_list|,
operator|&
name|argArray
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|procError
goto|;
block|}
name|lastArgPtr
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argCount
condition|;
name|i
operator|++
control|)
block|{
name|int
name|fieldCount
decl_stmt|,
name|nameLength
decl_stmt|,
name|valueLength
decl_stmt|;
name|char
modifier|*
modifier|*
name|fieldValues
decl_stmt|;
comment|/* 	 * Now divide the specifier up into name and default. 	 */
name|result
operator|=
name|Tcl_SplitList
argument_list|(
name|interp
argument_list|,
name|argArray
index|[
name|i
index|]
argument_list|,
operator|&
name|fieldCount
argument_list|,
operator|&
name|fieldValues
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|procError
goto|;
block|}
if|if
condition|(
name|fieldCount
operator|>
literal|2
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fieldValues
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"too many fields in argument specifier \""
argument_list|,
name|argArray
index|[
name|i
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|procError
goto|;
block|}
if|if
condition|(
operator|(
name|fieldCount
operator|==
literal|0
operator|)
operator|||
operator|(
operator|*
name|fieldValues
index|[
literal|0
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fieldValues
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"procedure \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\" has argument with no name"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|procError
goto|;
block|}
name|nameLength
operator|=
name|strlen
argument_list|(
name|fieldValues
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|fieldCount
operator|==
literal|2
condition|)
block|{
name|valueLength
operator|=
name|strlen
argument_list|(
name|fieldValues
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|valueLength
operator|=
literal|0
expr_stmt|;
block|}
name|argPtr
operator|=
operator|(
name|Arg
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|Arg
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|argPtr
operator|->
name|name
argument_list|)
operator|+
name|nameLength
operator|+
name|valueLength
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastArgPtr
operator|==
name|NULL
condition|)
block|{
name|procPtr
operator|->
name|argPtr
operator|=
name|argPtr
expr_stmt|;
block|}
else|else
block|{
name|lastArgPtr
operator|->
name|nextPtr
operator|=
name|argPtr
expr_stmt|;
block|}
name|lastArgPtr
operator|=
name|argPtr
expr_stmt|;
name|argPtr
operator|->
name|nextPtr
operator|=
name|NULL
expr_stmt|;
name|strcpy
argument_list|(
name|argPtr
operator|->
name|name
argument_list|,
name|fieldValues
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldCount
operator|==
literal|2
condition|)
block|{
name|argPtr
operator|->
name|defValue
operator|=
name|argPtr
operator|->
name|name
operator|+
name|nameLength
expr_stmt|;
name|strcpy
argument_list|(
name|argPtr
operator|->
name|defValue
argument_list|,
name|fieldValues
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|argPtr
operator|->
name|defValue
operator|=
name|NULL
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fieldValues
argument_list|)
expr_stmt|;
block|}
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|InterpProc
argument_list|,
operator|(
name|ClientData
operator|)
name|procPtr
argument_list|,
name|ProcDeleteProc
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argArray
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
name|procError
label|:
name|ckfree
argument_list|(
name|procPtr
operator|->
name|command
argument_list|)
expr_stmt|;
while|while
condition|(
name|procPtr
operator|->
name|argPtr
operator|!=
name|NULL
condition|)
block|{
name|argPtr
operator|=
name|procPtr
operator|->
name|argPtr
expr_stmt|;
name|procPtr
operator|->
name|argPtr
operator|=
name|argPtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argPtr
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|procPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|argArray
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argArray
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclGetFrame --  *  *	Given a description of a procedure frame, such as the first  *	argument to an "uplevel" or "upvar" command, locate the  *	call frame for the appropriate level of procedure.  *  * Results:  *	The return value is -1 if an error occurred in finding the  *	frame (in this case an error message is left in interp->result).  *	1 is returned if string was either a number or a number preceded  *	by "#" and it specified a valid frame.  0 is returned if string  *	isn't one of the two things above (in this case, the lookup  *	acts as if string were "1").  The variable pointed to by  *	framePtrPtr is filled in with the address of the desired frame  *	(unless an error occurs, in which case it isn't modified).  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclGetFrame
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|framePtrPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to find frame. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String describing frame. */
name|CallFrame
modifier|*
modifier|*
name|framePtrPtr
decl_stmt|;
comment|/* Store pointer to frame here (or NULL 				 * if global frame indicated). */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|int
name|curLevel
decl_stmt|,
name|level
decl_stmt|,
name|result
decl_stmt|;
name|CallFrame
modifier|*
name|framePtr
decl_stmt|;
comment|/*      * Parse string to figure out which level number to go to.      */
name|result
operator|=
literal|1
expr_stmt|;
name|curLevel
operator|=
operator|(
name|iPtr
operator|->
name|varFramePtr
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|iPtr
operator|->
name|varFramePtr
operator|->
name|level
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'#'
condition|)
block|{
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|string
operator|+
literal|1
argument_list|,
operator|&
name|level
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|level
operator|<
literal|0
condition|)
block|{
name|levelError
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad level \""
argument_list|,
name|string
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|string
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
operator|&
name|level
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|level
operator|=
name|curLevel
operator|-
name|level
expr_stmt|;
block|}
else|else
block|{
name|level
operator|=
name|curLevel
operator|-
literal|1
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * Figure out which frame to use, and modify the interpreter so      * its variables come from that frame.      */
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
name|framePtr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|framePtr
operator|=
name|iPtr
operator|->
name|varFramePtr
init|;
name|framePtr
operator|!=
name|NULL
condition|;
name|framePtr
operator|=
name|framePtr
operator|->
name|callerVarPtr
control|)
block|{
if|if
condition|(
name|framePtr
operator|->
name|level
operator|==
name|level
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|framePtr
operator|==
name|NULL
condition|)
block|{
goto|goto
name|levelError
goto|;
block|}
block|}
operator|*
name|framePtrPtr
operator|=
name|framePtr
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_UplevelCmd --  *  *	This procedure is invoked to process the "uplevel" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result value.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_UplevelCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|int
name|result
decl_stmt|;
name|CallFrame
modifier|*
name|savedVarFramePtr
decl_stmt|,
modifier|*
name|framePtr
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|uplevelSyntax
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" ?level? command ?arg ...?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Find the level to use for executing the command.      */
name|result
operator|=
name|TclGetFrame
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|framePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|argc
operator|-=
operator|(
name|result
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
goto|goto
name|uplevelSyntax
goto|;
block|}
name|argv
operator|+=
operator|(
name|result
operator|+
literal|1
operator|)
expr_stmt|;
comment|/*      * Modify the interpreter state to execute in the given frame.      */
name|savedVarFramePtr
operator|=
name|iPtr
operator|->
name|varFramePtr
expr_stmt|;
name|iPtr
operator|->
name|varFramePtr
operator|=
name|framePtr
expr_stmt|;
comment|/*      * Execute the residual arguments as a command.      */
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|result
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|cmd
decl_stmt|;
name|cmd
operator|=
name|Tcl_Concat
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|char
name|msg
index|[
literal|60
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n    (\"uplevel\" body line %d)"
argument_list|,
name|interp
operator|->
name|errorLine
argument_list|)
expr_stmt|;
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
comment|/*      * Restore the variable frame, and return.      */
name|iPtr
operator|->
name|varFramePtr
operator|=
name|savedVarFramePtr
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclFindProc --  *  *	Given the name of a procedure, return a pointer to the  *	record describing the procedure.  *  * Results:  *	NULL is returned if the name doesn't correspond to any  *	procedure.  Otherwise the return value is a pointer to  *	the procedure's record.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Proc
modifier|*
name|TclFindProc
parameter_list|(
name|iPtr
parameter_list|,
name|procName
parameter_list|)
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Interpreter in which to look. */
name|char
modifier|*
name|procName
decl_stmt|;
comment|/* Name of desired procedure. */
block|{
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|commandTable
argument_list|,
name|procName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdPtr
operator|->
name|proc
operator|!=
name|InterpProc
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
operator|(
name|Proc
operator|*
operator|)
name|cmdPtr
operator|->
name|clientData
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclIsProc --  *  *	Tells whether a command is a Tcl procedure or not.  *  * Results:  *	If the given command is actuall a Tcl procedure, the  *	return value is the address of the record describing  *	the procedure.  Otherwise the return value is 0.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Proc
modifier|*
name|TclIsProc
parameter_list|(
name|cmdPtr
parameter_list|)
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
comment|/* Command to test. */
block|{
if|if
condition|(
name|cmdPtr
operator|->
name|proc
operator|==
name|InterpProc
condition|)
block|{
return|return
operator|(
name|Proc
operator|*
operator|)
name|cmdPtr
operator|->
name|clientData
return|;
block|}
return|return
operator|(
name|Proc
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InterpProc --  *  *	When a Tcl procedure gets invoked, this routine gets invoked  *	to interpret the procedure.  *  * Results:  *	A standard Tcl result value, usually TCL_OK.  *  * Side effects:  *	Depends on the commands in the procedure.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InterpProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Record describing procedure to be 				 * interpreted. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which procedure was 				 * invoked. */
name|int
name|argc
decl_stmt|;
comment|/* Count of number of arguments to this 				 * procedure. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument values. */
block|{
specifier|register
name|Proc
modifier|*
name|procPtr
init|=
operator|(
name|Proc
operator|*
operator|)
name|clientData
decl_stmt|;
specifier|register
name|Arg
modifier|*
name|argPtr
decl_stmt|;
specifier|register
name|Interp
modifier|*
name|iPtr
decl_stmt|;
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
name|CallFrame
name|frame
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/*      * Set up a call frame for the new procedure invocation.      */
name|iPtr
operator|=
name|procPtr
operator|->
name|iPtr
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
operator|&
name|frame
operator|.
name|varTable
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|varFramePtr
operator|!=
name|NULL
condition|)
block|{
name|frame
operator|.
name|level
operator|=
name|iPtr
operator|->
name|varFramePtr
operator|->
name|level
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|frame
operator|.
name|level
operator|=
literal|1
expr_stmt|;
block|}
name|frame
operator|.
name|argc
operator|=
name|argc
expr_stmt|;
name|frame
operator|.
name|argv
operator|=
name|argv
expr_stmt|;
name|frame
operator|.
name|callerPtr
operator|=
name|iPtr
operator|->
name|framePtr
expr_stmt|;
name|frame
operator|.
name|callerVarPtr
operator|=
name|iPtr
operator|->
name|varFramePtr
expr_stmt|;
name|iPtr
operator|->
name|framePtr
operator|=
operator|&
name|frame
expr_stmt|;
name|iPtr
operator|->
name|varFramePtr
operator|=
operator|&
name|frame
expr_stmt|;
name|iPtr
operator|->
name|returnCode
operator|=
name|TCL_OK
expr_stmt|;
comment|/*      * Match the actual arguments against the procedure's formal      * parameters to compute local variables.      */
for|for
control|(
name|argPtr
operator|=
name|procPtr
operator|->
name|argPtr
operator|,
name|args
operator|=
name|argv
operator|+
literal|1
operator|,
name|argc
operator|-=
literal|1
init|;
name|argPtr
operator|!=
name|NULL
condition|;
name|argPtr
operator|=
name|argPtr
operator|->
name|nextPtr
operator|,
name|args
operator|++
operator|,
name|argc
operator|--
control|)
block|{
comment|/* 	 * Handle the special case of the last formal being "args".  When 	 * it occurs, assign it a list consisting of all the remaining 	 * actual arguments. 	 */
if|if
condition|(
operator|(
name|argPtr
operator|->
name|nextPtr
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|argPtr
operator|->
name|name
argument_list|,
literal|"args"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|0
condition|)
block|{
name|argc
operator|=
literal|0
expr_stmt|;
block|}
name|value
operator|=
name|Tcl_Merge
argument_list|(
name|argc
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argPtr
operator|->
name|name
argument_list|,
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|argc
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|value
operator|=
operator|*
name|args
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argPtr
operator|->
name|defValue
operator|!=
name|NULL
condition|)
block|{
name|value
operator|=
name|argPtr
operator|->
name|defValue
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"no value given for parameter \""
argument_list|,
name|argPtr
operator|->
name|name
argument_list|,
literal|"\" to \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|procDone
goto|;
block|}
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argPtr
operator|->
name|name
argument_list|,
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"called \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"\" with too many arguments"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|procDone
goto|;
block|}
comment|/*      * Invoke the commands in the procedure's body.      */
name|procPtr
operator|->
name|refCount
operator|++
expr_stmt|;
name|result
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|procPtr
operator|->
name|command
argument_list|)
expr_stmt|;
name|procPtr
operator|->
name|refCount
operator|--
expr_stmt|;
if|if
condition|(
name|procPtr
operator|->
name|refCount
operator|<=
literal|0
condition|)
block|{
name|CleanupProc
argument_list|(
name|procPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|TCL_RETURN
condition|)
block|{
name|result
operator|=
name|TclUpdateReturnInfo
argument_list|(
name|iPtr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|char
name|msg
index|[
literal|100
index|]
decl_stmt|;
comment|/* 	 * Record information telling where the error occurred. 	 */
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n    (procedure \"%.50s\" line %d)"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|iPtr
operator|->
name|errorLine
argument_list|)
expr_stmt|;
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|TCL_BREAK
condition|)
block|{
name|iPtr
operator|->
name|result
operator|=
literal|"invoked \"break\" outside of a loop"
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|TCL_CONTINUE
condition|)
block|{
name|iPtr
operator|->
name|result
operator|=
literal|"invoked \"continue\" outside of a loop"
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
comment|/*      * Delete the call frame for this procedure invocation (it's      * important to remove the call frame from the interpreter      * before deleting it, so that traces invoked during the      * deletion don't see the partially-deleted frame).      */
name|procDone
label|:
name|iPtr
operator|->
name|framePtr
operator|=
name|frame
operator|.
name|callerPtr
expr_stmt|;
name|iPtr
operator|->
name|varFramePtr
operator|=
name|frame
operator|.
name|callerVarPtr
expr_stmt|;
comment|/*      * The check below is a hack.  The problem is that there could be      * unset traces on the variables, which cause scripts to be evaluated.      * This will clear the ERR_IN_PROGRESS flag, losing stack trace      * information if the procedure was exiting with an error.  The      * code below preserves the flag.  Unfortunately, that isn't      * really enough:  we really should preserve the errorInfo variable      * too (otherwise a nested error in the trace script will trash      * errorInfo).  What's really needed is a general-purpose      * mechanism for saving and restoring interpreter state.      */
if|if
condition|(
name|iPtr
operator|->
name|flags
operator|&
name|ERR_IN_PROGRESS
condition|)
block|{
name|TclDeleteVars
argument_list|(
name|iPtr
argument_list|,
operator|&
name|frame
operator|.
name|varTable
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|flags
operator||=
name|ERR_IN_PROGRESS
expr_stmt|;
block|}
else|else
block|{
name|TclDeleteVars
argument_list|(
name|iPtr
argument_list|,
operator|&
name|frame
operator|.
name|varTable
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * ProcDeleteProc --  *  *	This procedure is invoked just before a command procedure is  *	removed from an interpreter.  Its job is to release all the  *	resources allocated to the procedure.  *  * Results:  *	None.  *  * Side effects:  *	Memory gets freed, unless the procedure is actively being  *	executed.  In this case the cleanup is delayed until the  *	last call to the current procedure completes.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ProcDeleteProc
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Procedure to be deleted. */
block|{
name|Proc
modifier|*
name|procPtr
init|=
operator|(
name|Proc
operator|*
operator|)
name|clientData
decl_stmt|;
name|procPtr
operator|->
name|refCount
operator|--
expr_stmt|;
if|if
condition|(
name|procPtr
operator|->
name|refCount
operator|<=
literal|0
condition|)
block|{
name|CleanupProc
argument_list|(
name|procPtr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CleanupProc --  *  *	This procedure does all the real work of freeing up a Proc  *	structure.  It's called only when the structure's reference  *	count becomes zero.  *  * Results:  *	None.  *  * Side effects:  *	Memory gets freed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|CleanupProc
parameter_list|(
name|procPtr
parameter_list|)
specifier|register
name|Proc
modifier|*
name|procPtr
decl_stmt|;
comment|/* Procedure to be deleted. */
block|{
specifier|register
name|Arg
modifier|*
name|argPtr
decl_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|procPtr
operator|->
name|command
argument_list|)
expr_stmt|;
for|for
control|(
name|argPtr
operator|=
name|procPtr
operator|->
name|argPtr
init|;
name|argPtr
operator|!=
name|NULL
condition|;
control|)
block|{
name|Arg
modifier|*
name|nextPtr
init|=
name|argPtr
operator|->
name|nextPtr
decl_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argPtr
argument_list|)
expr_stmt|;
name|argPtr
operator|=
name|nextPtr
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|procPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclUpdateReturnInfo --  *  *	This procedure is called when procedures return, and at other  *	points where the TCL_RETURN code is used.  It examines fields  *	such as iPtr->returnCode and iPtr->errorCode and modifies  *	the real return status accordingly.  *  * Results:  *	The return value is the true completion code to use for  *	the procedure, instead of TCL_RETURN.  *  * Side effects:  *	The errorInfo and errorCode variables may get modified.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclUpdateReturnInfo
parameter_list|(
name|iPtr
parameter_list|)
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Interpreter for which TCL_RETURN 				 * exception is being processed. */
block|{
name|int
name|code
decl_stmt|;
name|code
operator|=
name|iPtr
operator|->
name|returnCode
expr_stmt|;
name|iPtr
operator|->
name|returnCode
operator|=
name|TCL_OK
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TCL_ERROR
condition|)
block|{
name|Tcl_SetVar2
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|iPtr
operator|->
name|errorCode
operator|!=
name|NULL
operator|)
condition|?
name|iPtr
operator|->
name|errorCode
else|:
literal|"NONE"
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|flags
operator||=
name|ERROR_CODE_SET
expr_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|errorInfo
operator|!=
name|NULL
condition|)
block|{
name|Tcl_SetVar2
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"errorInfo"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|iPtr
operator|->
name|errorInfo
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|flags
operator||=
name|ERR_IN_PROGRESS
expr_stmt|;
block|}
block|}
return|return
name|code
return|;
block|}
end_function

end_unit

