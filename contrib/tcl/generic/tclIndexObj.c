begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclIndexObj.c --  *  *	This file implements objects of type "index".  This object type  *	is used to lookup a keyword in a table of valid values and cache  *	the index of the matching entry.  *  * Copyright (c) 1997 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclIndexObj.c 1.8 97/07/29 10:16:54  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_comment
comment|/*  * Prototypes for procedures defined later in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DupIndexInternalRep
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Obj
operator|*
name|srcPtr
operator|,
name|Tcl_Obj
operator|*
name|copyPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SetIndexFromAny
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Obj
operator|*
name|objPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|UpdateStringOfIndex
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Obj
operator|*
name|listPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The structure below defines the index Tcl object type by means of  * procedures that can be invoked by generic object code.  */
end_comment

begin_decl_stmt
name|Tcl_ObjType
name|tclIndexType
init|=
block|{
literal|"index"
block|,
comment|/* name */
operator|(
name|Tcl_FreeInternalRepProc
operator|*
operator|)
name|NULL
block|,
comment|/* freeIntRepProc */
name|DupIndexInternalRep
block|,
comment|/* dupIntRepProc */
name|UpdateStringOfIndex
block|,
comment|/* updateStringProc */
name|SetIndexFromAny
comment|/* setFromAnyProc */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetIndexFromObj --  *  *	This procedure looks up an object's value in a table of strings  *	and returns the index of the matching string, if any.  *  * Results:   *	If the value of objPtr is identical to or a unique abbreviation  *	for one of the entries in objPtr, then the return value is  *	TCL_OK and the index of the matching entry is stored at  *	*indexPtr.  If there isn't a proper match, then TCL_ERROR is  *	returned and an error message is left in interp's result (unless  *	interp is NULL).  The msg argument is used in the error  *	message; for example, if msg has the value "option" then the  *	error message will say something flag 'bad option "foo": must be  *	...'  *  * Side effects:  *	The result of the lookup is cached as the internal rep of  *	objPtr, so that repeated lookups can be done quickly.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_GetIndexFromObj
parameter_list|(
name|interp
parameter_list|,
name|objPtr
parameter_list|,
name|tablePtr
parameter_list|,
name|msg
parameter_list|,
name|flags
parameter_list|,
name|indexPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting if not NULL. */
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Object containing the string to lookup. */
name|char
modifier|*
modifier|*
name|tablePtr
decl_stmt|;
comment|/* Array of strings to compare against the 				 * value of objPtr; last entry must be NULL 				 * and there must not be duplicate entries. */
name|char
modifier|*
name|msg
decl_stmt|;
comment|/* Identifying word to use in error messages. */
name|int
name|flags
decl_stmt|;
comment|/* 0 or TCL_EXACT */
name|int
modifier|*
name|indexPtr
decl_stmt|;
comment|/* Place to store resulting integer index. */
block|{
name|int
name|index
decl_stmt|,
name|length
decl_stmt|,
name|i
decl_stmt|,
name|numAbbrev
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
modifier|*
name|entryPtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|resultPtr
decl_stmt|;
comment|/*      * See if there is a valid cached result from a previous lookup.      */
if|if
condition|(
operator|(
name|objPtr
operator|->
name|typePtr
operator|==
operator|&
name|tclIndexType
operator|)
operator|&&
operator|(
name|objPtr
operator|->
name|internalRep
operator|.
name|twoPtrValue
operator|.
name|ptr1
operator|==
operator|(
name|VOID
operator|*
operator|)
name|tablePtr
operator|)
condition|)
block|{
operator|*
name|indexPtr
operator|=
operator|(
name|int
operator|)
name|objPtr
operator|->
name|internalRep
operator|.
name|twoPtrValue
operator|.
name|ptr2
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
comment|/*      * Lookup the value of the object in the table.  Accept unique      * abbreviations unless TCL_EXACT is set in flags.      */
name|key
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|index
operator|=
operator|-
literal|1
expr_stmt|;
name|numAbbrev
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|entryPtr
operator|=
name|tablePtr
operator|,
name|i
operator|=
literal|0
init|;
operator|*
name|entryPtr
operator|!=
name|NULL
condition|;
name|entryPtr
operator|++
operator|,
name|i
operator|++
control|)
block|{
for|for
control|(
name|p1
operator|=
name|key
operator|,
name|p2
operator|=
operator|*
name|entryPtr
init|;
operator|*
name|p1
operator|==
operator|*
name|p2
condition|;
name|p1
operator|++
operator|,
name|p2
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p1
operator|==
literal|0
condition|)
block|{
name|index
operator|=
name|i
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
operator|*
name|p1
operator|==
literal|0
condition|)
block|{
comment|/* 	     * The value is an abbreviation for this entry.  Continue 	     * checking other entries to make sure it's unique.  If we 	     * get more than one unique abbreviation, keep searching to 	     * see if there is an exact match, but remember the number 	     * of unique abbreviations and don't allow either. 	     */
name|numAbbrev
operator|++
expr_stmt|;
name|index
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|TCL_EXACT
operator|)
operator|||
operator|(
name|numAbbrev
operator|!=
literal|1
operator|)
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|done
label|:
if|if
condition|(
operator|(
name|objPtr
operator|->
name|typePtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|objPtr
operator|->
name|typePtr
operator|->
name|freeIntRepProc
operator|!=
name|NULL
operator|)
condition|)
block|{
name|objPtr
operator|->
name|typePtr
operator|->
name|freeIntRepProc
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
name|objPtr
operator|->
name|internalRep
operator|.
name|twoPtrValue
operator|.
name|ptr1
operator|=
operator|(
name|VOID
operator|*
operator|)
name|tablePtr
expr_stmt|;
name|objPtr
operator|->
name|internalRep
operator|.
name|twoPtrValue
operator|.
name|ptr2
operator|=
operator|(
name|VOID
operator|*
operator|)
name|index
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclIndexType
expr_stmt|;
operator|*
name|indexPtr
operator|=
name|index
expr_stmt|;
return|return
name|TCL_OK
return|;
name|error
label|:
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|resultPtr
operator|=
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|resultPtr
argument_list|,
operator|(
name|numAbbrev
operator|>
literal|1
operator|)
condition|?
literal|"ambiguous "
else|:
literal|"bad "
argument_list|,
name|msg
argument_list|,
literal|" \""
argument_list|,
name|key
argument_list|,
literal|"\": must be "
argument_list|,
operator|*
name|tablePtr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|entryPtr
operator|=
name|tablePtr
operator|+
literal|1
init|;
operator|*
name|entryPtr
operator|!=
name|NULL
condition|;
name|entryPtr
operator|++
control|)
block|{
if|if
condition|(
name|entryPtr
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|resultPtr
argument_list|,
literal|", or "
argument_list|,
operator|*
name|entryPtr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|resultPtr
argument_list|,
literal|", "
argument_list|,
operator|*
name|entryPtr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DupIndexInternalRep --  *  *	Copy the internal representation of an index Tcl_Obj from one  *	object to another.  *  * Results:  *	None.  *  * Side effects:  *	"copyPtr"s internal rep is set to same value as "srcPtr"s  *	internal rep.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|DupIndexInternalRep
parameter_list|(
name|srcPtr
parameter_list|,
name|copyPtr
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|srcPtr
decl_stmt|;
comment|/* Object with internal rep to copy. */
specifier|register
name|Tcl_Obj
modifier|*
name|copyPtr
decl_stmt|;
comment|/* Object with internal rep to set. */
block|{
name|copyPtr
operator|->
name|internalRep
operator|.
name|twoPtrValue
operator|.
name|ptr1
operator|=
name|srcPtr
operator|->
name|internalRep
operator|.
name|twoPtrValue
operator|.
name|ptr1
expr_stmt|;
name|copyPtr
operator|->
name|internalRep
operator|.
name|twoPtrValue
operator|.
name|ptr2
operator|=
name|srcPtr
operator|->
name|internalRep
operator|.
name|twoPtrValue
operator|.
name|ptr2
expr_stmt|;
name|copyPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclIndexType
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SetIndexFromAny --  *  *	This procedure is called to convert a Tcl object to index  *	internal form. However, this doesn't make sense (need to have a  *	table of keywords in order to do the conversion) so the  *	procedure always generates an error.  *  * Results:  *	The return value is always TCL_ERROR, and an error message is  *	left in interp's result if interp isn't NULL.   *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SetIndexFromAny
parameter_list|(
name|interp
parameter_list|,
name|objPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting if not NULL. */
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* The object to convert. */
block|{
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"can't convert value to index except via Tcl_GetIndexFromObj API"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * UpdateStringOfIndex --  *  *	This procedure is called to update the string representation for  *	an index object.  It should never be called, because we never  *	invalidate the string representation for an index object.  *  * Results:  *	None.  *  * Side effects:  *	A panic is added  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|UpdateStringOfIndex
parameter_list|(
name|objPtr
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Int object whose string rep to update. */
block|{
name|panic
argument_list|(
literal|"UpdateStringOfIndex should never be invoked"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_WrongNumArgs --  *  *	This procedure generates a "wrong # args" error message in an  *	interpreter.  It is used as a utility function by many command  *	procedures.  *  * Results:  *	None.  *  * Side effects:  *	An error message is generated in interp's result object to  *	indicate that a command was invoked with the wrong number of  *	arguments.  The message has the form  *		wrong # args: should be "foo bar additional stuff"  *	where "foo" and "bar" are the initial objects in objv (objc  *	determines how many of these are printed) and "additional stuff"  *	is the contents of the message argument.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_WrongNumArgs
parameter_list|(
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|,
name|message
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments to print 					 * from objv. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Initial argument objects, which 					 * should be included in the error 					 * message. */
name|char
modifier|*
name|message
decl_stmt|;
comment|/* Error message to print after the 					 * leading objects in objv. The 					 * message may be NULL. */
block|{
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|char
modifier|*
modifier|*
name|tablePtr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|objPtr
operator|=
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|objPtr
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
comment|/* 	 * If the object is an index type use the index table which allows 	 * for the correct error message even if the subcommand was 	 * abbreviated.  Otherwise, just use the string rep. 	 */
if|if
condition|(
name|objv
index|[
name|i
index|]
operator|->
name|typePtr
operator|==
operator|&
name|tclIndexType
condition|)
block|{
name|tablePtr
operator|=
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
name|objv
index|[
name|i
index|]
operator|->
name|internalRep
operator|.
name|twoPtrValue
operator|.
name|ptr1
operator|)
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|objPtr
argument_list|,
name|tablePtr
index|[
operator|(
name|int
operator|)
name|objv
index|[
name|i
index|]
operator|->
name|internalRep
operator|.
name|twoPtrValue
operator|.
name|ptr2
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|objPtr
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
operator|(
name|objc
operator|-
literal|1
operator|)
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|objPtr
argument_list|,
literal|" "
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|message
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|objPtr
argument_list|,
literal|" "
argument_list|,
name|message
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|Tcl_AppendStringsToObj
argument_list|(
name|objPtr
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

