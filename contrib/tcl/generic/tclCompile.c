begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclCompile.c --  *  *	This file contains procedures that compile Tcl commands or parts  *	of commands (like quoted strings or nested sub-commands) into a  *	sequence of instructions ("bytecodes").   *  * Copyright (c) 1996-1997 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclCompile.c 1.61 97/06/23 18:43:46  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclCompile.h"
end_include

begin_comment
comment|/*  * Variable that controls whether compilation tracing is enabled and, if so,  * what level of tracing is desired:  *    0: no compilation tracing  *    1: summarize compilation of top level cmds and proc bodies  *    2: display all instructions of each ByteCode compiled  * This variable is linked to the Tcl variable "tcl_traceCompile".  */
end_comment

begin_decl_stmt
name|int
name|tclTraceCompile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|traceInitialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Count of the number of compilations.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_COMPILE_STATS
end_ifdef

begin_decl_stmt
name|long
name|tclNumCompilations
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_COMPILE_STATS */
end_comment

begin_comment
comment|/*  * A table describing the Tcl bytecode instructions. The entries in this  * table must correspond to the list of instructions in tclInt.h. The names  * "op1" and "op4" refer to an instruction's one or four byte first operand.  * Similarly, "stktop" and "stknext" refer to the topmost and next to  * topmost stack elements.  *  * Note that the load, store, and incr instructions do not distinguish local  * from global variables; the bytecode interpreter at runtime uses the  * existence of a procedure call frame to distinguish these.  */
end_comment

begin_decl_stmt
name|InstructionDesc
name|instructionTable
index|[]
init|=
block|{
comment|/* Name	      Bytes #Opnds Operand types        Stack top, next   */
block|{
literal|"done"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Finish ByteCode execution and return stktop (top stack item) */
block|{
literal|"push1"
block|,
literal|2
block|,
literal|1
block|,
block|{
name|OPERAND_UINT1
block|}
block|}
block|,
comment|/* Push object at ByteCode objArray[op1] */
block|{
literal|"push4"
block|,
literal|5
block|,
literal|1
block|,
block|{
name|OPERAND_UINT4
block|}
block|}
block|,
comment|/* Push object at ByteCode objArray[op4] */
block|{
literal|"pop"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Pop the topmost stack object */
block|{
literal|"dup"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Duplicate the topmost stack object and push the result */
block|{
literal|"concat1"
block|,
literal|2
block|,
literal|1
block|,
block|{
name|OPERAND_UINT1
block|}
block|}
block|,
comment|/* Concatenate the top op1 items and push result */
block|{
literal|"invokeStk1"
block|,
literal|2
block|,
literal|1
block|,
block|{
name|OPERAND_UINT1
block|}
block|}
block|,
comment|/* Invoke command named objv[0];<objc,objv> =<op1,top op1> */
block|{
literal|"invokeStk4"
block|,
literal|5
block|,
literal|1
block|,
block|{
name|OPERAND_UINT4
block|}
block|}
block|,
comment|/* Invoke command named objv[0];<objc,objv> =<op4,top op4> */
block|{
literal|"evalStk"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Evaluate command in stktop using Tcl_EvalObj. */
block|{
literal|"exprStk"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Execute expression in stktop using Tcl_ExprStringObj. */
block|{
literal|"loadScalar1"
block|,
literal|2
block|,
literal|1
block|,
block|{
name|OPERAND_UINT1
block|}
block|}
block|,
comment|/* Load scalar variable at index op1<= 255 in call frame */
block|{
literal|"loadScalar4"
block|,
literal|5
block|,
literal|1
block|,
block|{
name|OPERAND_UINT4
block|}
block|}
block|,
comment|/* Load scalar variable at index op1>= 256 in call frame */
block|{
literal|"loadScalarStk"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Load scalar variable; scalar's name is stktop */
block|{
literal|"loadArray1"
block|,
literal|2
block|,
literal|1
block|,
block|{
name|OPERAND_UINT1
block|}
block|}
block|,
comment|/* Load array element; array at slot op1<=255, element is stktop */
block|{
literal|"loadArray4"
block|,
literal|5
block|,
literal|1
block|,
block|{
name|OPERAND_UINT4
block|}
block|}
block|,
comment|/* Load array element; array at slot op1> 255, element is stktop */
block|{
literal|"loadArrayStk"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Load array element; element is stktop, array name is stknext */
block|{
literal|"loadStk"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Load general variable; unparsed variable name is stktop */
block|{
literal|"storeScalar1"
block|,
literal|2
block|,
literal|1
block|,
block|{
name|OPERAND_UINT1
block|}
block|}
block|,
comment|/* Store scalar variable at op1<=255 in frame; value is stktop */
block|{
literal|"storeScalar4"
block|,
literal|5
block|,
literal|1
block|,
block|{
name|OPERAND_UINT4
block|}
block|}
block|,
comment|/* Store scalar variable at op1> 255 in frame; value is stktop */
block|{
literal|"storeScalarStk"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Store scalar; value is stktop, scalar name is stknext */
block|{
literal|"storeArray1"
block|,
literal|2
block|,
literal|1
block|,
block|{
name|OPERAND_UINT1
block|}
block|}
block|,
comment|/* Store array element; array at op1<=255, value is top then elem */
block|{
literal|"storeArray4"
block|,
literal|5
block|,
literal|1
block|,
block|{
name|OPERAND_UINT4
block|}
block|}
block|,
comment|/* Store array element; array at op1>=256, value is top then elem */
block|{
literal|"storeArrayStk"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Store array element; value is stktop, then elem, array names */
block|{
literal|"storeStk"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Store general variable; value is stktop, then unparsed name */
block|{
literal|"incrScalar1"
block|,
literal|2
block|,
literal|1
block|,
block|{
name|OPERAND_UINT1
block|}
block|}
block|,
comment|/* Incr scalar at index op1<=255 in frame; incr amount is stktop */
block|{
literal|"incrScalarStk"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Incr scalar; incr amount is stktop, scalar's name is stknext */
block|{
literal|"incrArray1"
block|,
literal|2
block|,
literal|1
block|,
block|{
name|OPERAND_UINT1
block|}
block|}
block|,
comment|/* Incr array elem; arr at slot op1<=255, amount is top then elem */
block|{
literal|"incrArrayStk"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Incr array element; amount is top then elem then array names */
block|{
literal|"incrStk"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Incr general variable; amount is stktop then unparsed var name */
block|{
literal|"incrScalar1Imm"
block|,
literal|3
block|,
literal|2
block|,
block|{
name|OPERAND_UINT1
block|,
name|OPERAND_INT1
block|}
block|}
block|,
comment|/* Incr scalar at slot op1<= 255; amount is 2nd operand byte */
block|{
literal|"incrScalarStkImm"
block|,
literal|2
block|,
literal|1
block|,
block|{
name|OPERAND_INT1
block|}
block|}
block|,
comment|/* Incr scalar; scalar name is stktop; incr amount is op1 */
block|{
literal|"incrArray1Imm"
block|,
literal|3
block|,
literal|2
block|,
block|{
name|OPERAND_UINT1
block|,
name|OPERAND_INT1
block|}
block|}
block|,
comment|/* Incr array elem; array at slot op1<= 255, elem is stktop, 	 * amount is 2nd operand byte */
block|{
literal|"incrArrayStkImm"
block|,
literal|2
block|,
literal|1
block|,
block|{
name|OPERAND_INT1
block|}
block|}
block|,
comment|/* Incr array element; elem is top then array name, amount is op1 */
block|{
literal|"incrStkImm"
block|,
literal|2
block|,
literal|1
block|,
block|{
name|OPERAND_INT1
block|}
block|}
block|,
comment|/* Incr general variable; unparsed name is top, amount is op1 */
block|{
literal|"jump1"
block|,
literal|2
block|,
literal|1
block|,
block|{
name|OPERAND_INT1
block|}
block|}
block|,
comment|/* Jump relative to (pc + op1) */
block|{
literal|"jump4"
block|,
literal|5
block|,
literal|1
block|,
block|{
name|OPERAND_INT4
block|}
block|}
block|,
comment|/* Jump relative to (pc + op4) */
block|{
literal|"jumpTrue1"
block|,
literal|2
block|,
literal|1
block|,
block|{
name|OPERAND_INT1
block|}
block|}
block|,
comment|/* Jump relative to (pc + op1) if stktop expr object is true */
block|{
literal|"jumpTrue4"
block|,
literal|5
block|,
literal|1
block|,
block|{
name|OPERAND_INT4
block|}
block|}
block|,
comment|/* Jump relative to (pc + op4) if stktop expr object is true */
block|{
literal|"jumpFalse1"
block|,
literal|2
block|,
literal|1
block|,
block|{
name|OPERAND_INT1
block|}
block|}
block|,
comment|/* Jump relative to (pc + op1) if stktop expr object is false */
block|{
literal|"jumpFalse4"
block|,
literal|5
block|,
literal|1
block|,
block|{
name|OPERAND_INT4
block|}
block|}
block|,
comment|/* Jump relative to (pc + op4) if stktop expr object is false */
block|{
literal|"lor"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Logical or:	push (stknext || stktop) */
block|{
literal|"land"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Logical and:	push (stknext&& stktop) */
block|{
literal|"bitor"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Bitwise or:	push (stknext | stktop) */
block|{
literal|"bitxor"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Bitwise xor	push (stknext ^ stktop) */
block|{
literal|"bitand"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Bitwise and:	push (stknext& stktop) */
block|{
literal|"eq"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Equal:	push (stknext == stktop) */
block|{
literal|"neq"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Not equal:	push (stknext != stktop) */
block|{
literal|"lt"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Less:	push (stknext< stktop) */
block|{
literal|"gt"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Greater:	push (stknext || stktop) */
block|{
literal|"le"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Logical or:	push (stknext || stktop) */
block|{
literal|"ge"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Logical or:	push (stknext || stktop) */
block|{
literal|"lshift"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Left shift:	push (stknext<< stktop) */
block|{
literal|"rshift"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Right shift:	push (stknext>> stktop) */
block|{
literal|"add"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Add:		push (stknext + stktop) */
block|{
literal|"sub"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Sub:		push (stkext - stktop) */
block|{
literal|"mult"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Multiply:	push (stknext * stktop) */
block|{
literal|"div"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Divide:	push (stknext / stktop) */
block|{
literal|"mod"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Mod:		push (stknext % stktop) */
block|{
literal|"uplus"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Unary plus:	push +stktop */
block|{
literal|"uminus"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Unary minus:	push -stktop */
block|{
literal|"bitnot"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Bitwise not:	push ~stktop */
block|{
literal|"not"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Logical not:	push !stktop */
block|{
literal|"callBuiltinFunc1"
block|,
literal|2
block|,
literal|1
block|,
block|{
name|OPERAND_UINT1
block|}
block|}
block|,
comment|/* Call builtin math function with index op1; any args are on stk */
block|{
literal|"callFunc1"
block|,
literal|2
block|,
literal|1
block|,
block|{
name|OPERAND_UINT1
block|}
block|}
block|,
comment|/* Call non-builtin func objv[0];<objc,objv>=<op1,top op1>  */
block|{
literal|"tryCvtToNumeric"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Try converting stktop to first int then double if possible. */
block|{
literal|"break"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Abort closest enclosing loop; if none, return TCL_BREAK code. */
block|{
literal|"continue"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Skip to next iteration of closest enclosing loop; if none, 	 * return TCL_CONTINUE code. */
block|{
literal|"foreach_start4"
block|,
literal|5
block|,
literal|1
block|,
block|{
name|OPERAND_UINT4
block|}
block|}
block|,
comment|/* Initialize execution of a foreach loop. Operand is aux data index 	 * of the ForeachInfo structure for the foreach command. */
block|{
literal|"foreach_step4"
block|,
literal|5
block|,
literal|1
block|,
block|{
name|OPERAND_UINT4
block|}
block|}
block|,
comment|/* "Step" or begin next iteration of foreach loop. Push 0 if to 	 *  terminate loop, else push 1. */
block|{
literal|"beginCatch4"
block|,
literal|5
block|,
literal|1
block|,
block|{
name|OPERAND_UINT4
block|}
block|}
block|,
comment|/* Record start of catch with the operand's exception range index. 	 * Push the current stack depth onto a special catch stack. */
block|{
literal|"endCatch"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* End of last catch. Pop the bytecode interpreter's catch stack. */
block|{
literal|"pushResult"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Push the interpreter's object result onto the stack. */
block|{
literal|"pushReturnCode"
block|,
literal|1
block|,
literal|0
block|,
block|{
name|OPERAND_NONE
block|}
block|}
block|,
comment|/* Push interpreter's return code (e.g. TCL_OK or TCL_ERROR) as 	 * a new object onto the stack. */
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The following table assigns a type to each character. Only types  * meaningful to Tcl parsing are represented here. The table is  * designed to be referenced with either signed or unsigned characters,  * so it has 384 entries. The first 128 entries correspond to negative  * character values, the next 256 correspond to positive character  * values. The last 128 entries are identical to the first 128. The  * table is always indexed with a 128-byte offset (the 128th entry  * corresponds to a 0 character value).  */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|tclTypeTable
index|[]
init|=
block|{
comment|/*      * Negative character values, from -128 to -1:      */
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
comment|/*      * Positive character values, from 0-127:      */
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_SPACE
block|,
name|TCL_COMMAND_END
block|,
name|TCL_SPACE
block|,
name|TCL_SPACE
block|,
name|TCL_SPACE
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_SPACE
block|,
name|TCL_NORMAL
block|,
name|TCL_QUOTE
block|,
name|TCL_NORMAL
block|,
name|TCL_DOLLAR
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_COMMAND_END
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_OPEN_BRACKET
block|,
name|TCL_BACKSLASH
block|,
name|TCL_COMMAND_END
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_OPEN_BRACE
block|,
name|TCL_NORMAL
block|,
name|TCL_CLOSE_BRACE
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
comment|/*      * Large unsigned character values, from 128-255:      */
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Prototypes for procedures defined later in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|AdvanceToNextWord
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|string
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CollectArgInfo
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|char
operator|*
name|lastChar
operator|,
name|int
name|flags
operator|,
name|ArgInfo
operator|*
name|argInfoPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CompileBraces
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|char
operator|*
name|lastChar
operator|,
name|int
name|flags
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CompileCmdWordInline
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|char
operator|*
name|lastChar
operator|,
name|int
name|flags
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CompileExprWord
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|char
operator|*
name|lastChar
operator|,
name|int
name|flags
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CompileMultipartWord
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|char
operator|*
name|lastChar
operator|,
name|int
name|flags
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CompileWord
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|char
operator|*
name|lastChar
operator|,
name|int
name|flags
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CreateExceptionRange
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ExceptionRangeType
name|type
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DupByteCodeInternalRep
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Obj
operator|*
name|srcPtr
operator|,
name|Tcl_Obj
operator|*
name|copyPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ClientData
name|DupForeachInfo
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|EnterCmdExtentData
name|_ANSI_ARGS_
argument_list|(
operator|(
name|CompileEnv
operator|*
name|envPtr
operator|,
name|int
name|cmdNumber
operator|,
name|int
name|numSrcChars
operator|,
name|int
name|numCodeBytes
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|EnterCmdStartData
name|_ANSI_ARGS_
argument_list|(
operator|(
name|CompileEnv
operator|*
name|envPtr
operator|,
name|int
name|cmdNumber
operator|,
name|int
name|srcOffset
operator|,
name|int
name|codeOffset
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ExpandObjectArray
name|_ANSI_ARGS_
argument_list|(
operator|(
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|FreeForeachInfo
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|FreeByteCodeInternalRep
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Obj
operator|*
name|objPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|FreeArgInfo
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ArgInfo
operator|*
name|argInfoPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|InitArgInfo
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ArgInfo
operator|*
name|argInfoPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|LookupCompiledLocal
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
name|int
name|nameChars
operator|,
name|int
name|createIfNew
operator|,
name|int
name|flagsIfCreated
operator|,
name|Proc
operator|*
name|procPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SetByteCodeFromAny
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Obj
operator|*
name|objPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|UpdateStringOfByteCode
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Obj
operator|*
name|objPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The structure below defines the bytecode Tcl object type by  * means of procedures that can be invoked by generic object code.  */
end_comment

begin_decl_stmt
name|Tcl_ObjType
name|tclByteCodeType
init|=
block|{
literal|"bytecode"
block|,
comment|/* name */
name|FreeByteCodeInternalRep
block|,
comment|/* freeIntRepProc */
name|DupByteCodeInternalRep
block|,
comment|/* dupIntRepProc */
name|UpdateStringOfByteCode
block|,
comment|/* updateStringProc */
name|SetByteCodeFromAny
comment|/* setFromAnyProc */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclPrintByteCodeObj --  *  *	This procedure prints ("disassembles") the instructions of a  *	bytecode object to stdout.  *  * Results:  *	None.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclPrintByteCodeObj
parameter_list|(
name|interp
parameter_list|,
name|objPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used only for Tcl_GetStringFromObj. */
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* The bytecode object to disassemble. */
block|{
name|ByteCode
modifier|*
name|codePtr
init|=
operator|(
name|ByteCode
operator|*
operator|)
name|objPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
decl_stmt|;
name|Proc
modifier|*
name|procPtr
decl_stmt|;
name|CmdLocation
modifier|*
name|mapPtr
decl_stmt|;
name|ExceptionRange
modifier|*
name|excRangeArrayPtr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|codeStart
decl_stmt|,
modifier|*
name|codeLimit
decl_stmt|,
modifier|*
name|pc
decl_stmt|,
modifier|*
name|start
decl_stmt|;
name|int
name|numCmds
decl_stmt|,
name|numRanges
decl_stmt|,
name|cmd
decl_stmt|,
name|maxChars
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|source
decl_stmt|;
if|if
condition|(
name|codePtr
operator|->
name|refCount
operator|<=
literal|0
condition|)
block|{
return|return;
comment|/* already freed */
block|}
name|codeStart
operator|=
name|codePtr
operator|->
name|codeStart
expr_stmt|;
name|codeLimit
operator|=
operator|(
name|codeStart
operator|+
name|codePtr
operator|->
name|numCodeBytes
operator|)
expr_stmt|;
name|source
operator|=
name|codePtr
operator|->
name|source
expr_stmt|;
name|procPtr
operator|=
name|codePtr
operator|->
name|procPtr
expr_stmt|;
name|numCmds
operator|=
name|codePtr
operator|->
name|numCommands
expr_stmt|;
name|numRanges
operator|=
name|codePtr
operator|->
name|numExcRanges
expr_stmt|;
name|mapPtr
operator|=
name|codePtr
operator|->
name|cmdMapPtr
expr_stmt|;
name|excRangeArrayPtr
operator|=
name|codePtr
operator|->
name|excRangeArrayPtr
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\nByteCode 0x%x, ref ct %u, epoch %u, interp 0x%x, interp epoch %u\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|codePtr
argument_list|,
name|codePtr
operator|->
name|refCount
argument_list|,
name|codePtr
operator|->
name|compileEpoch
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|codePtr
operator|->
name|iPtr
argument_list|,
name|codePtr
operator|->
name|iPtr
operator|->
name|compileEpoch
argument_list|)
expr_stmt|;
if|if
condition|(
name|procPtr
operator|!=
name|NULL
condition|)
block|{
name|int
name|numCompiledLocals
init|=
name|procPtr
operator|->
name|numCompiledLocals
decl_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"  Proc 0x%x, ref ct=%d, %d args, %d compiled locals\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|procPtr
argument_list|,
name|procPtr
operator|->
name|refCount
argument_list|,
name|procPtr
operator|->
name|numArgs
argument_list|,
name|numCompiledLocals
argument_list|)
expr_stmt|;
if|if
condition|(
name|numCompiledLocals
operator|>
literal|0
condition|)
block|{
name|CompiledLocal
modifier|*
name|localPtr
init|=
name|procPtr
operator|->
name|firstLocalPtr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numCompiledLocals
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"      %d: frame index=%d, flags=0x%x%s%s"
argument_list|,
name|i
argument_list|,
name|localPtr
operator|->
name|frameIndex
argument_list|,
name|localPtr
operator|->
name|flags
argument_list|,
operator|(
name|localPtr
operator|->
name|isArg
condition|?
literal|", arg"
else|:
literal|""
operator|)
argument_list|,
operator|(
name|localPtr
operator|->
name|isTemp
condition|?
literal|", temp"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|localPtr
operator|->
name|isTemp
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|", name=\"%s\"\n"
argument_list|,
name|localPtr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|localPtr
operator|=
name|localPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
block|}
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"  Source: "
argument_list|)
expr_stmt|;
name|TclPrintSource
argument_list|(
name|stdout
argument_list|,
name|source
argument_list|,
name|TclMin
argument_list|(
name|codePtr
operator|->
name|numSrcChars
argument_list|,
literal|70
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n  Chars=%d, bytes=%u, objs=%u, stk depth=%u, exc depth=%d, aux items=%d\n"
argument_list|,
name|codePtr
operator|->
name|numSrcChars
argument_list|,
name|codePtr
operator|->
name|numCodeBytes
argument_list|,
name|codePtr
operator|->
name|numObjects
argument_list|,
name|codePtr
operator|->
name|maxStackDepth
argument_list|,
name|codePtr
operator|->
name|maxExcRangeDepth
argument_list|,
name|codePtr
operator|->
name|numAuxDataItems
argument_list|)
expr_stmt|;
comment|/*      * If there were no commands (e.g., an expression or an empty string      * was compiled), just print all instructions.      */
if|if
condition|(
name|numCmds
operator|==
literal|0
condition|)
block|{
name|start
operator|=
name|codeStart
expr_stmt|;
name|pc
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|pc
operator|<
name|codeLimit
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
name|pc
operator|+=
name|TclPrintInstruction
argument_list|(
name|codePtr
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/*      * Print table giving the source and object locations for each command.      */
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"  Commands=%d\n"
argument_list|,
name|numCmds
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numCmds
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"      %d: source=%d-%d, code=%d-%d\n"
argument_list|,
operator|(
name|i
operator|+
literal|1
operator|)
argument_list|,
name|mapPtr
index|[
name|i
index|]
operator|.
name|srcOffset
argument_list|,
operator|(
name|mapPtr
index|[
name|i
index|]
operator|.
name|srcOffset
operator|+
name|mapPtr
index|[
name|i
index|]
operator|.
name|numSrcChars
operator|-
literal|1
operator|)
argument_list|,
name|mapPtr
index|[
name|i
index|]
operator|.
name|codeOffset
argument_list|,
operator|(
name|mapPtr
index|[
name|i
index|]
operator|.
name|codeOffset
operator|+
name|mapPtr
index|[
name|i
index|]
operator|.
name|numCodeBytes
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/*      * Print the ExceptionRange array.      */
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"  Exception ranges=%d\n"
argument_list|,
name|numRanges
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numRanges
condition|;
name|i
operator|++
control|)
block|{
name|ExceptionRange
modifier|*
name|rangePtr
init|=
operator|&
operator|(
name|excRangeArrayPtr
index|[
name|i
index|]
operator|)
decl_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"      %d: level=%d, type=%s, pc range=%d-%d, "
argument_list|,
name|i
argument_list|,
name|rangePtr
operator|->
name|nestingLevel
argument_list|,
operator|(
operator|(
name|rangePtr
operator|->
name|type
operator|==
name|LOOP_EXCEPTION_RANGE
operator|)
condition|?
literal|"loop"
else|:
literal|"catch"
operator|)
argument_list|,
name|rangePtr
operator|->
name|codeOffset
argument_list|,
operator|(
name|rangePtr
operator|->
name|codeOffset
operator|+
name|rangePtr
operator|->
name|numCodeBytes
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rangePtr
operator|->
name|type
condition|)
block|{
case|case
name|LOOP_EXCEPTION_RANGE
case|:
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"continue=%d, break=%d\n"
argument_list|,
name|rangePtr
operator|->
name|continueOffset
argument_list|,
name|rangePtr
operator|->
name|breakOffset
argument_list|)
expr_stmt|;
break|break;
case|case
name|CATCH_EXCEPTION_RANGE
case|:
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"catch=%d\n"
argument_list|,
name|rangePtr
operator|->
name|catchOffset
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"unrecognized ExceptionRange type %d\n"
argument_list|,
name|rangePtr
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Print each instruction. If the instruction corresponds to the start      * of a command, print the command's source.      */
name|start
operator|=
name|codeStart
expr_stmt|;
name|cmd
operator|=
literal|0
expr_stmt|;
name|pc
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|pc
operator|<
name|codeLimit
condition|)
block|{
name|int
name|pcOffset
init|=
operator|(
name|pc
operator|-
name|start
operator|)
decl_stmt|;
while|while
condition|(
operator|(
name|cmd
operator|<
name|numCmds
operator|)
operator|&&
operator|(
name|pcOffset
operator|>=
name|mapPtr
index|[
name|cmd
index|]
operator|.
name|codeOffset
operator|)
condition|)
block|{
comment|/* 	     * The start of the command with index cmd. 	     */
name|maxChars
operator|=
name|TclMin
argument_list|(
name|mapPtr
index|[
name|cmd
index|]
operator|.
name|numSrcChars
argument_list|,
literal|70
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"  Command %d: "
argument_list|,
operator|(
name|cmd
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|TclPrintSource
argument_list|(
name|stdout
argument_list|,
operator|(
name|source
operator|+
name|mapPtr
index|[
name|cmd
index|]
operator|.
name|srcOffset
operator|)
argument_list|,
name|maxChars
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|cmd
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
name|pc
operator|+=
name|TclPrintInstruction
argument_list|(
name|codePtr
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclPrintInstruction --  *  *	This procedure prints ("disassembles") one instruction from a  *	bytecode object to stdout.  *  * Results:  *	Returns the length in bytes of the current instruiction.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclPrintInstruction
parameter_list|(
name|codePtr
parameter_list|,
name|pc
parameter_list|)
name|ByteCode
modifier|*
name|codePtr
decl_stmt|;
comment|/* Bytecode containing the instruction. */
name|unsigned
name|char
modifier|*
name|pc
decl_stmt|;
comment|/* Points to first byte of instruction. */
block|{
name|Proc
modifier|*
name|procPtr
init|=
name|codePtr
operator|->
name|procPtr
decl_stmt|;
name|unsigned
name|char
name|opCode
init|=
operator|*
name|pc
decl_stmt|;
specifier|register
name|InstructionDesc
modifier|*
name|instDesc
init|=
operator|&
name|instructionTable
index|[
name|opCode
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|codeStart
init|=
name|codePtr
operator|->
name|codeStart
decl_stmt|;
name|unsigned
name|int
name|pcOffset
init|=
operator|(
name|pc
operator|-
name|codeStart
operator|)
decl_stmt|;
name|int
name|opnd
decl_stmt|,
name|elemLen
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|Tcl_Obj
modifier|*
name|elemPtr
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"(%u) %s "
argument_list|,
name|pcOffset
argument_list|,
name|instDesc
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|instDesc
operator|->
name|numOperands
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|instDesc
operator|->
name|opTypes
index|[
name|i
index|]
condition|)
block|{
case|case
name|OPERAND_INT1
case|:
name|opnd
operator|=
name|TclGetInt1AtPc
argument_list|(
name|pc
operator|+
literal|1
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|opCode
operator|==
name|INST_JUMP1
operator|)
operator|||
operator|(
name|opCode
operator|==
name|INST_JUMP_TRUE1
operator|)
operator|||
operator|(
name|opCode
operator|==
name|INST_JUMP_FALSE1
operator|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d	# pc %u"
argument_list|,
name|opnd
argument_list|,
operator|(
name|pcOffset
operator|+
name|opnd
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d"
argument_list|,
name|opnd
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPERAND_INT4
case|:
name|opnd
operator|=
name|TclGetInt4AtPc
argument_list|(
name|pc
operator|+
literal|1
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|opCode
operator|==
name|INST_JUMP4
operator|)
operator|||
operator|(
name|opCode
operator|==
name|INST_JUMP_TRUE4
operator|)
operator|||
operator|(
name|opCode
operator|==
name|INST_JUMP_FALSE4
operator|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d	# pc %u"
argument_list|,
name|opnd
argument_list|,
operator|(
name|pcOffset
operator|+
name|opnd
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d"
argument_list|,
name|opnd
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPERAND_UINT1
case|:
name|opnd
operator|=
name|TclGetUInt1AtPc
argument_list|(
name|pc
operator|+
literal|1
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|&&
operator|(
name|opCode
operator|==
name|INST_PUSH1
operator|)
condition|)
block|{
name|elemPtr
operator|=
name|codePtr
operator|->
name|objArrayPtr
index|[
name|opnd
index|]
expr_stmt|;
name|string
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|elemPtr
argument_list|,
operator|&
name|elemLen
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%u  	# "
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|opnd
argument_list|)
expr_stmt|;
name|TclPrintSource
argument_list|(
name|stdout
argument_list|,
name|string
argument_list|,
name|TclMin
argument_list|(
name|elemLen
argument_list|,
literal|40
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|opCode
operator|==
name|INST_LOAD_SCALAR1
operator|)
operator|||
operator|(
name|opCode
operator|==
name|INST_LOAD_ARRAY1
operator|)
operator|||
operator|(
name|opCode
operator|==
name|INST_STORE_SCALAR1
operator|)
operator|||
operator|(
name|opCode
operator|==
name|INST_STORE_ARRAY1
operator|)
operator|)
condition|)
block|{
name|int
name|localCt
init|=
name|procPtr
operator|->
name|numCompiledLocals
decl_stmt|;
name|CompiledLocal
modifier|*
name|localPtr
init|=
name|procPtr
operator|->
name|firstLocalPtr
decl_stmt|;
if|if
condition|(
name|opnd
operator|>=
name|localCt
condition|)
block|{
name|panic
argument_list|(
literal|"TclPrintInstruction: bad local var index %u (%u locals)\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|opnd
argument_list|,
name|localCt
argument_list|)
expr_stmt|;
return|return
name|instDesc
operator|->
name|numBytes
return|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|opnd
condition|;
name|j
operator|++
control|)
block|{
name|localPtr
operator|=
name|localPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
if|if
condition|(
name|localPtr
operator|->
name|isTemp
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%u	# temp var %u"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|opnd
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|opnd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%u	# var "
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|opnd
argument_list|)
expr_stmt|;
name|TclPrintSource
argument_list|(
name|stdout
argument_list|,
name|localPtr
operator|->
name|name
argument_list|,
literal|40
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%u "
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|opnd
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPERAND_UINT4
case|:
name|opnd
operator|=
name|TclGetUInt4AtPc
argument_list|(
name|pc
operator|+
literal|1
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|opCode
operator|==
name|INST_PUSH4
condition|)
block|{
name|elemPtr
operator|=
name|codePtr
operator|->
name|objArrayPtr
index|[
name|opnd
index|]
expr_stmt|;
name|string
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|elemPtr
argument_list|,
operator|&
name|elemLen
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%u  	# "
argument_list|,
name|opnd
argument_list|)
expr_stmt|;
name|TclPrintSource
argument_list|(
name|stdout
argument_list|,
name|string
argument_list|,
name|TclMin
argument_list|(
name|elemLen
argument_list|,
literal|40
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|opCode
operator|==
name|INST_LOAD_SCALAR4
operator|)
operator|||
operator|(
name|opCode
operator|==
name|INST_LOAD_ARRAY4
operator|)
operator|||
operator|(
name|opCode
operator|==
name|INST_STORE_SCALAR4
operator|)
operator|||
operator|(
name|opCode
operator|==
name|INST_STORE_ARRAY4
operator|)
operator|)
condition|)
block|{
name|int
name|localCt
init|=
name|procPtr
operator|->
name|numCompiledLocals
decl_stmt|;
name|CompiledLocal
modifier|*
name|localPtr
init|=
name|procPtr
operator|->
name|firstLocalPtr
decl_stmt|;
if|if
condition|(
name|opnd
operator|>=
name|localCt
condition|)
block|{
name|panic
argument_list|(
literal|"TclPrintInstruction: bad local var index %u (%u locals)\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|opnd
argument_list|,
name|localCt
argument_list|)
expr_stmt|;
return|return
name|instDesc
operator|->
name|numBytes
return|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|opnd
condition|;
name|j
operator|++
control|)
block|{
name|localPtr
operator|=
name|localPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
if|if
condition|(
name|localPtr
operator|->
name|isTemp
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%u	# temp var %u"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|opnd
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|opnd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%u	# var "
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|opnd
argument_list|)
expr_stmt|;
name|TclPrintSource
argument_list|(
name|stdout
argument_list|,
name|localPtr
operator|->
name|name
argument_list|,
literal|40
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%u "
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|opnd
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPERAND_NONE
case|:
default|default:
break|break;
block|}
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|instDesc
operator|->
name|numBytes
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclPrintSource --  *  *	This procedure prints up to a specified number of characters from  *	the argument string to a specified file. It tries to produce legible  *	output by adding backslashes as necessary.  *  * Results:  *	None.  *  * Side effects:  *	Outputs characters to the specified file.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclPrintSource
parameter_list|(
name|outFile
parameter_list|,
name|string
parameter_list|,
name|maxChars
parameter_list|)
name|FILE
modifier|*
name|outFile
decl_stmt|;
comment|/* The file to print the source to. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* The string to print. */
name|int
name|maxChars
decl_stmt|;
comment|/* Maximum number of chars to print. */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|outFile
argument_list|,
literal|"\"\""
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|outFile
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|p
operator|=
name|string
expr_stmt|;
for|for
control|(
init|;
operator|(
operator|*
name|p
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|i
operator|<
name|maxChars
operator|)
condition|;
name|p
operator|++
operator|,
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'"'
case|:
name|fprintf
argument_list|(
name|outFile
argument_list|,
literal|"\\\""
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'\f'
case|:
name|fprintf
argument_list|(
name|outFile
argument_list|,
literal|"\\f"
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'\n'
case|:
name|fprintf
argument_list|(
name|outFile
argument_list|,
literal|"\\n"
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'\r'
case|:
name|fprintf
argument_list|(
name|outFile
argument_list|,
literal|"\\r"
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'\t'
case|:
name|fprintf
argument_list|(
name|outFile
argument_list|,
literal|"\\t"
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'\v'
case|:
name|fprintf
argument_list|(
name|outFile
argument_list|,
literal|"\\v"
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|fprintf
argument_list|(
name|outFile
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|fprintf
argument_list|(
name|outFile
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FreeByteCodeInternalRep --  *  *	Part of the bytecode Tcl object type implementation. Frees the  *	storage associated with a bytecode object's internal representation  *	unless its code is actively being executed.  *  * Results:  *	None.  *  * Side effects:  *	The bytecode object's internal rep is marked invalid and its  *	code gets freed unless the code is actively being executed.  *	In that case the cleanup is delayed until the last execution  *	of the code completes.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|FreeByteCodeInternalRep
parameter_list|(
name|objPtr
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Object whose internal rep to free. */
block|{
specifier|register
name|ByteCode
modifier|*
name|codePtr
init|=
operator|(
name|ByteCode
operator|*
operator|)
name|objPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
decl_stmt|;
name|codePtr
operator|->
name|refCount
operator|--
expr_stmt|;
if|if
condition|(
name|codePtr
operator|->
name|refCount
operator|<=
literal|0
condition|)
block|{
name|TclCleanupByteCode
argument_list|(
name|codePtr
argument_list|)
expr_stmt|;
block|}
name|objPtr
operator|->
name|typePtr
operator|=
name|NULL
expr_stmt|;
name|objPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CleanupByteCode --  *  *	This procedure does all the real work of freeing up a bytecode  *	object's ByteCode structure. It's called only when the structure's  *	reference count becomes zero.  *  * Results:  *	None.  *  * Side effects:  *	Frees objPtr's bytecode internal representation and sets  *	its type and objPtr->internalRep.otherValuePtr NULL. Also  *	decrements the ref counts on each object in its object array,  *	and frees its auxiliary data items.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclCleanupByteCode
parameter_list|(
name|codePtr
parameter_list|)
name|ByteCode
modifier|*
name|codePtr
decl_stmt|;
comment|/* ByteCode to free. */
block|{
name|Tcl_Obj
modifier|*
modifier|*
name|objArrayPtr
init|=
name|codePtr
operator|->
name|objArrayPtr
decl_stmt|;
name|int
name|numObjects
init|=
name|codePtr
operator|->
name|numObjects
decl_stmt|;
name|int
name|numAuxDataItems
init|=
name|codePtr
operator|->
name|numAuxDataItems
decl_stmt|;
specifier|register
name|AuxData
modifier|*
name|auxDataPtr
decl_stmt|;
specifier|register
name|Tcl_Obj
modifier|*
name|elemPtr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/*      * A single heap object holds the ByteCode structure and its code,      * object, command location, and auxiliary data arrays. This means we      * only need to 1) decrement the ref counts on the objects in its      * object array, 2) call the free procs for the auxiliary data items,      * and 3) free the ByteCode structure's heap object.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numObjects
condition|;
name|i
operator|++
control|)
block|{
name|elemPtr
operator|=
name|objArrayPtr
index|[
name|i
index|]
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|elemPtr
argument_list|)
expr_stmt|;
block|}
name|auxDataPtr
operator|=
name|codePtr
operator|->
name|auxDataArrayPtr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numAuxDataItems
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|auxDataPtr
operator|->
name|freeProc
operator|!=
name|NULL
condition|)
block|{
name|auxDataPtr
operator|->
name|freeProc
argument_list|(
name|auxDataPtr
operator|->
name|clientData
argument_list|)
expr_stmt|;
block|}
name|auxDataPtr
operator|++
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|codePtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DupByteCodeInternalRep --  *  *	Part of the bytecode Tcl object type implementation. Initializes the  *	internal representation of a bytecode Tcl_Obj to a copy of the  *	internal representation of an existing bytecode object.  *  * Results:  *	None.  *  * Side effects:  *	"copyPtr"s internal rep is set to the bytecode sequence  *	corresponding to "srcPtr"s internal rep. Ref counts for objects  *	in the existing bytecode object's  object array are incremented  *	the bytecode copy now also refers to them.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|DupByteCodeInternalRep
parameter_list|(
name|srcPtr
parameter_list|,
name|copyPtr
parameter_list|)
name|Tcl_Obj
modifier|*
name|srcPtr
decl_stmt|;
comment|/* Object with internal rep to copy. */
name|Tcl_Obj
modifier|*
name|copyPtr
decl_stmt|;
comment|/* Object with internal rep to set. */
block|{
name|ByteCode
modifier|*
name|codePtr
init|=
operator|(
name|ByteCode
operator|*
operator|)
name|srcPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
decl_stmt|;
specifier|register
name|ByteCode
modifier|*
name|dupPtr
decl_stmt|;
name|int
name|codeBytes
init|=
name|codePtr
operator|->
name|numCodeBytes
decl_stmt|;
name|int
name|numObjects
init|=
name|codePtr
operator|->
name|numObjects
decl_stmt|;
name|int
name|numAuxDataItems
init|=
name|codePtr
operator|->
name|numAuxDataItems
decl_stmt|;
specifier|register
name|AuxData
modifier|*
name|srcAuxDataPtr
decl_stmt|,
modifier|*
name|dupAuxDataPtr
decl_stmt|;
name|size_t
name|objArrayBytes
decl_stmt|,
name|rangeArrayBytes
decl_stmt|,
name|cmdLocBytes
decl_stmt|,
name|auxDataBytes
decl_stmt|;
specifier|register
name|size_t
name|size
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*      * Allocate a single heap object to hold the copied ByteCode structure      * and its code, object, command location, and auxiliary data arrays.      */
name|objArrayBytes
operator|=
name|numObjects
operator|*
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
expr_stmt|;
name|rangeArrayBytes
operator|=
operator|(
name|codePtr
operator|->
name|numExcRanges
operator|*
sizeof|sizeof
argument_list|(
name|ExceptionRange
argument_list|)
operator|)
expr_stmt|;
name|cmdLocBytes
operator|=
name|codePtr
operator|->
name|numCommands
operator|*
sizeof|sizeof
argument_list|(
name|CmdLocation
argument_list|)
expr_stmt|;
name|auxDataBytes
operator|=
name|numAuxDataItems
operator|*
sizeof|sizeof
argument_list|(
name|AuxData
argument_list|)
expr_stmt|;
name|size
operator|=
name|TCL_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|ByteCode
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|+=
name|TCL_ALIGN
argument_list|(
name|codeBytes
argument_list|)
expr_stmt|;
name|size
operator|+=
name|TCL_ALIGN
argument_list|(
name|objArrayBytes
argument_list|)
expr_stmt|;
name|size
operator|+=
name|TCL_ALIGN
argument_list|(
name|rangeArrayBytes
argument_list|)
expr_stmt|;
name|size
operator|+=
name|TCL_ALIGN
argument_list|(
name|cmdLocBytes
argument_list|)
expr_stmt|;
name|size
operator|+=
name|TCL_ALIGN
argument_list|(
name|auxDataBytes
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|dupPtr
operator|=
operator|(
name|ByteCode
operator|*
operator|)
name|p
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|dupPtr
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|codePtr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|p
operator|+=
name|TCL_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|ByteCode
argument_list|)
argument_list|)
expr_stmt|;
name|dupPtr
operator|->
name|codeStart
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
expr_stmt|;
name|p
operator|+=
name|TCL_ALIGN
argument_list|(
name|codeBytes
argument_list|)
expr_stmt|;
name|dupPtr
operator|->
name|objArrayPtr
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|p
expr_stmt|;
name|p
operator|+=
name|TCL_ALIGN
argument_list|(
name|objArrayBytes
argument_list|)
expr_stmt|;
name|dupPtr
operator|->
name|excRangeArrayPtr
operator|=
operator|(
name|ExceptionRange
operator|*
operator|)
name|p
expr_stmt|;
name|p
operator|+=
name|TCL_ALIGN
argument_list|(
name|rangeArrayBytes
argument_list|)
expr_stmt|;
name|dupPtr
operator|->
name|cmdMapPtr
operator|=
operator|(
name|CmdLocation
operator|*
operator|)
name|p
expr_stmt|;
name|p
operator|+=
name|TCL_ALIGN
argument_list|(
name|cmdLocBytes
argument_list|)
expr_stmt|;
name|dupPtr
operator|->
name|auxDataArrayPtr
operator|=
operator|(
name|AuxData
operator|*
operator|)
name|p
expr_stmt|;
comment|/*      * Increment the ref counts for objects in the object array since we are      * creating new references for them in the copied object array.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numObjects
condition|;
name|i
operator|++
control|)
block|{
name|Tcl_IncrRefCount
argument_list|(
name|dupPtr
operator|->
name|objArrayPtr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/*      * Duplicate any auxiliary data items.      */
name|srcAuxDataPtr
operator|=
name|codePtr
operator|->
name|auxDataArrayPtr
expr_stmt|;
name|dupAuxDataPtr
operator|=
name|dupPtr
operator|->
name|auxDataArrayPtr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numAuxDataItems
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|srcAuxDataPtr
operator|->
name|dupProc
operator|!=
name|NULL
condition|)
block|{
name|dupAuxDataPtr
operator|->
name|clientData
operator|=
name|srcAuxDataPtr
operator|->
name|dupProc
argument_list|(
name|srcAuxDataPtr
operator|->
name|clientData
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dupAuxDataPtr
operator|->
name|clientData
operator|=
name|srcAuxDataPtr
operator|->
name|clientData
expr_stmt|;
block|}
name|srcAuxDataPtr
operator|++
expr_stmt|;
name|dupAuxDataPtr
operator|++
expr_stmt|;
block|}
name|copyPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
operator|=
operator|(
name|VOID
operator|*
operator|)
name|dupPtr
expr_stmt|;
name|copyPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclByteCodeType
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *-----------------------------------------------------------------------  *  * SetByteCodeFromAny --  *  *	Part of the bytecode Tcl object type implementation. Attempts to  *	generate an byte code internal form for the Tcl object "objPtr" by  *	compiling its string representation.  *  * Results:  *	The return value is a standard Tcl object result. If an error occurs  *	during compilation, an error message is left in the interpreter's  *	result unless "interp" is NULL.  *  * Side effects:  *	Frees the old internal representation. If no error occurs, then the  *	compiled code is stored as "objPtr"s bytecode representation.  *	Also, if debugging, initializes the "tcl_traceCompile" Tcl variable  *	used to trace compilations.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SetByteCodeFromAny
parameter_list|(
name|interp
parameter_list|,
name|objPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interpreter for which the code is 				 * compiled. */
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* The object to convert. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|CompileEnv
name|compEnv
decl_stmt|;
comment|/* Compilation environment structure 				 * allocated in frame. */
name|AuxData
modifier|*
name|auxDataPtr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|length
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|traceInitialized
condition|)
block|{
if|if
condition|(
name|Tcl_LinkVar
argument_list|(
name|interp
argument_list|,
literal|"tcl_traceCompile"
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tclTraceCompile
argument_list|,
name|TCL_LINK_INT
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|panic
argument_list|(
literal|"SetByteCodeFromAny: unable to create link for tcl_traceCompile variable"
argument_list|)
expr_stmt|;
block|}
name|traceInitialized
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TCL_COMPILE_STATS
name|tclNumCompilations
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* TCL_COMPILE_STATS */
name|string
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|TclInitCompileEnv
argument_list|(
name|interp
argument_list|,
operator|&
name|compEnv
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|result
operator|=
name|TclCompileString
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
name|string
operator|+
name|length
argument_list|,
name|iPtr
operator|->
name|evalFlags
argument_list|,
operator|&
name|compEnv
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
comment|/* 	 * Add a "done" instruction at the end of the instruction sequence. 	 */
name|TclEmitOpcode
argument_list|(
name|INST_DONE
argument_list|,
operator|&
name|compEnv
argument_list|)
expr_stmt|;
comment|/* 	 * Convert the object to a ByteCode object. 	 */
name|TclInitByteCodeObj
argument_list|(
name|objPtr
argument_list|,
operator|&
name|compEnv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * Compilation errors. Decrement the ref counts on any objects in 	 * the object array and free any aux data items prior to freeing 	 * the compilation environment. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|compEnv
operator|.
name|objArrayNext
condition|;
name|i
operator|++
control|)
block|{
name|Tcl_Obj
modifier|*
name|elemPtr
init|=
name|compEnv
operator|.
name|objArrayPtr
index|[
name|i
index|]
decl_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|elemPtr
argument_list|)
expr_stmt|;
block|}
name|auxDataPtr
operator|=
name|compEnv
operator|.
name|auxDataArrayPtr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|compEnv
operator|.
name|auxDataArrayNext
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|auxDataPtr
operator|->
name|freeProc
operator|!=
name|NULL
condition|)
block|{
name|auxDataPtr
operator|->
name|freeProc
argument_list|(
name|auxDataPtr
operator|->
name|clientData
argument_list|)
expr_stmt|;
block|}
name|auxDataPtr
operator|++
expr_stmt|;
block|}
block|}
name|TclFreeCompileEnv
argument_list|(
operator|&
name|compEnv
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|tclTraceCompile
operator|==
literal|2
condition|)
block|{
name|TclPrintByteCodeObj
argument_list|(
name|interp
argument_list|,
name|objPtr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * UpdateStringOfByteCode --  *  *	Part of the bytecode Tcl object type implementation. Called to  *	update the string representation for a byte code object.  *	Note: This procedure does not free an existing old string rep  *	so storage will be lost if this has not already been done.  *  * Results:  *	None.  *  * Side effects:  *	Generates a panic.   *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|UpdateStringOfByteCode
parameter_list|(
name|objPtr
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* ByteCode object with string rep that  				 * needs updating. */
block|{
comment|/*      * This procedure is never invoked since the internal representation of      * a bytecode object is never modified.      */
name|panic
argument_list|(
literal|"UpdateStringOfByteCode should never be called."
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclInitCompileEnv --  *  *	Initializes a CompileEnv compilation environment structure for the  *	compilation of a string in an interpreter.  *  * Results:  *	None.  *  * Side effects:  *	The CompileEnv structure is initialized.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclInitCompileEnv
parameter_list|(
name|interp
parameter_list|,
name|envPtr
parameter_list|,
name|string
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interpreter for which a CompileEnv 				  * structure is initialized. */
specifier|register
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Points to the CompileEnv structure to 				  * initialize. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* The source string to be compiled. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|envPtr
operator|->
name|iPtr
operator|=
name|iPtr
expr_stmt|;
name|envPtr
operator|->
name|source
operator|=
name|string
expr_stmt|;
name|envPtr
operator|->
name|procPtr
operator|=
name|iPtr
operator|->
name|compiledProcPtr
expr_stmt|;
name|envPtr
operator|->
name|numCommands
operator|=
literal|0
expr_stmt|;
name|envPtr
operator|->
name|excRangeDepth
operator|=
literal|0
expr_stmt|;
name|envPtr
operator|->
name|maxExcRangeDepth
operator|=
literal|0
expr_stmt|;
name|envPtr
operator|->
name|maxStackDepth
operator|=
literal|0
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
operator|&
operator|(
name|envPtr
operator|->
name|objTable
operator|)
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
name|envPtr
operator|->
name|pushSimpleWords
operator|=
literal|1
expr_stmt|;
name|envPtr
operator|->
name|wordIsSimple
operator|=
literal|0
expr_stmt|;
name|envPtr
operator|->
name|numSimpleWordChars
operator|=
literal|0
expr_stmt|;
name|envPtr
operator|->
name|exprIsJustVarRef
operator|=
literal|0
expr_stmt|;
name|envPtr
operator|->
name|termOffset
operator|=
literal|0
expr_stmt|;
name|envPtr
operator|->
name|codeStart
operator|=
name|envPtr
operator|->
name|staticCodeSpace
expr_stmt|;
name|envPtr
operator|->
name|codeNext
operator|=
name|envPtr
operator|->
name|codeStart
expr_stmt|;
name|envPtr
operator|->
name|codeEnd
operator|=
operator|(
name|envPtr
operator|->
name|codeStart
operator|+
name|COMPILEENV_INIT_CODE_BYTES
operator|)
expr_stmt|;
name|envPtr
operator|->
name|mallocedCodeArray
operator|=
literal|0
expr_stmt|;
name|envPtr
operator|->
name|objArrayPtr
operator|=
name|envPtr
operator|->
name|staticObjArraySpace
expr_stmt|;
name|envPtr
operator|->
name|objArrayNext
operator|=
literal|0
expr_stmt|;
name|envPtr
operator|->
name|objArrayEnd
operator|=
name|COMPILEENV_INIT_NUM_OBJECTS
expr_stmt|;
name|envPtr
operator|->
name|mallocedObjArray
operator|=
literal|0
expr_stmt|;
name|envPtr
operator|->
name|excRangeArrayPtr
operator|=
name|envPtr
operator|->
name|staticExcRangeArraySpace
expr_stmt|;
name|envPtr
operator|->
name|excRangeArrayNext
operator|=
literal|0
expr_stmt|;
name|envPtr
operator|->
name|excRangeArrayEnd
operator|=
name|COMPILEENV_INIT_EXCEPT_RANGES
expr_stmt|;
name|envPtr
operator|->
name|mallocedExcRangeArray
operator|=
literal|0
expr_stmt|;
name|envPtr
operator|->
name|cmdMapPtr
operator|=
name|envPtr
operator|->
name|staticCmdMapSpace
expr_stmt|;
name|envPtr
operator|->
name|cmdMapEnd
operator|=
name|COMPILEENV_INIT_CMD_MAP_SIZE
expr_stmt|;
name|envPtr
operator|->
name|mallocedCmdMap
operator|=
literal|0
expr_stmt|;
name|envPtr
operator|->
name|auxDataArrayPtr
operator|=
name|envPtr
operator|->
name|staticAuxDataArraySpace
expr_stmt|;
name|envPtr
operator|->
name|auxDataArrayNext
operator|=
literal|0
expr_stmt|;
name|envPtr
operator|->
name|auxDataArrayEnd
operator|=
name|COMPILEENV_INIT_AUX_DATA_SIZE
expr_stmt|;
name|envPtr
operator|->
name|mallocedAuxDataArray
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclFreeCompileEnv --  *  *	Free the storage allocated in a CompileEnv compilation environment  *	structure.  *  * Results:  *	None.  *  * Side effects:  *	Allocated storage in the CompileEnv structure is freed. Note that  *	ref counts for Tcl objects in its object table are not decremented.  *	In addition, any storage referenced by any auxiliary data items  *	in the CompileEnv structure are not freed either. The expectation  *	is that when compilation is successful, "ownership" (i.e., the  *	pointers to) these objects and aux data items will just be handed  *	over to the corresponding ByteCode structure.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclFreeCompileEnv
parameter_list|(
name|envPtr
parameter_list|)
specifier|register
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Points to the CompileEnv structure. */
block|{
name|Tcl_DeleteHashTable
argument_list|(
operator|&
operator|(
name|envPtr
operator|->
name|objTable
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|envPtr
operator|->
name|mallocedCodeArray
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|envPtr
operator|->
name|codeStart
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|envPtr
operator|->
name|mallocedObjArray
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|envPtr
operator|->
name|objArrayPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|envPtr
operator|->
name|mallocedExcRangeArray
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|envPtr
operator|->
name|excRangeArrayPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|envPtr
operator|->
name|mallocedCmdMap
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|envPtr
operator|->
name|cmdMapPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|envPtr
operator|->
name|mallocedAuxDataArray
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|envPtr
operator|->
name|auxDataArrayPtr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclInitByteCodeObj --  *  *	Create a ByteCode structure and initialize it from a CompileEnv  *	compilation environment structure. The ByteCode structure is  *	smaller and contains just that information needed to execute  *	the bytecode instructions resulting from compiling a Tcl script.  *	The resulting structure is placed in the specified object.  *  * Results:  *	A newly constructed ByteCode object is stored in the internal  *	representation of the objPtr.  *  * Side effects:  *	A single heap object is allocated to hold the new ByteCode structure  *	and its code, object, command location, and aux data arrays. Note  *	that "ownership" (i.e., the pointers to) the Tcl objects and aux  *	data items will be handed over to the new ByteCode structure from  *	the CompileEnv structure.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclInitByteCodeObj
parameter_list|(
name|objPtr
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Points object that should be 				 * initialized, and whose string rep 				 * contains the source code. */
specifier|register
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Points to the CompileEnv structure from 				  * which to create a ByteCode structure. */
block|{
specifier|register
name|ByteCode
modifier|*
name|codePtr
decl_stmt|;
name|size_t
name|codeBytes
decl_stmt|,
name|objArrayBytes
decl_stmt|,
name|rangeArrayBytes
decl_stmt|,
name|cmdLocBytes
decl_stmt|;
name|size_t
name|auxDataArrayBytes
decl_stmt|;
specifier|register
name|size_t
name|size
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|codeBytes
operator|=
name|envPtr
operator|->
name|codeNext
operator|-
name|envPtr
operator|->
name|codeStart
expr_stmt|;
name|objArrayBytes
operator|=
name|envPtr
operator|->
name|objArrayNext
operator|*
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
expr_stmt|;
name|rangeArrayBytes
operator|=
operator|(
name|envPtr
operator|->
name|excRangeArrayNext
operator|*
sizeof|sizeof
argument_list|(
name|ExceptionRange
argument_list|)
operator|)
expr_stmt|;
name|cmdLocBytes
operator|=
name|envPtr
operator|->
name|numCommands
operator|*
sizeof|sizeof
argument_list|(
name|CmdLocation
argument_list|)
expr_stmt|;
name|auxDataArrayBytes
operator|=
name|envPtr
operator|->
name|auxDataArrayNext
operator|*
sizeof|sizeof
argument_list|(
name|AuxData
argument_list|)
expr_stmt|;
name|size
operator|=
name|TCL_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|ByteCode
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|+=
name|TCL_ALIGN
argument_list|(
name|codeBytes
argument_list|)
expr_stmt|;
name|size
operator|+=
name|TCL_ALIGN
argument_list|(
name|objArrayBytes
argument_list|)
expr_stmt|;
name|size
operator|+=
name|TCL_ALIGN
argument_list|(
name|rangeArrayBytes
argument_list|)
expr_stmt|;
name|size
operator|+=
name|TCL_ALIGN
argument_list|(
name|cmdLocBytes
argument_list|)
expr_stmt|;
name|size
operator|+=
name|TCL_ALIGN
argument_list|(
name|auxDataArrayBytes
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|codePtr
operator|=
operator|(
name|ByteCode
operator|*
operator|)
name|p
expr_stmt|;
name|codePtr
operator|->
name|iPtr
operator|=
name|envPtr
operator|->
name|iPtr
expr_stmt|;
name|codePtr
operator|->
name|compileEpoch
operator|=
name|envPtr
operator|->
name|iPtr
operator|->
name|compileEpoch
expr_stmt|;
name|codePtr
operator|->
name|refCount
operator|=
literal|1
expr_stmt|;
name|codePtr
operator|->
name|source
operator|=
name|envPtr
operator|->
name|source
expr_stmt|;
name|codePtr
operator|->
name|procPtr
operator|=
name|envPtr
operator|->
name|procPtr
expr_stmt|;
name|codePtr
operator|->
name|numCommands
operator|=
name|envPtr
operator|->
name|numCommands
expr_stmt|;
name|codePtr
operator|->
name|numSrcChars
operator|=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
name|codePtr
operator|->
name|numCodeBytes
operator|=
name|codeBytes
expr_stmt|;
name|codePtr
operator|->
name|numObjects
operator|=
name|envPtr
operator|->
name|objArrayNext
expr_stmt|;
name|codePtr
operator|->
name|numExcRanges
operator|=
name|envPtr
operator|->
name|excRangeArrayNext
expr_stmt|;
name|codePtr
operator|->
name|numAuxDataItems
operator|=
name|envPtr
operator|->
name|auxDataArrayNext
expr_stmt|;
name|codePtr
operator|->
name|maxExcRangeDepth
operator|=
name|envPtr
operator|->
name|maxExcRangeDepth
expr_stmt|;
name|codePtr
operator|->
name|maxStackDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
name|p
operator|+=
name|TCL_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|ByteCode
argument_list|)
argument_list|)
expr_stmt|;
name|codePtr
operator|->
name|codeStart
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|p
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|envPtr
operator|->
name|codeStart
argument_list|,
name|codeBytes
argument_list|)
expr_stmt|;
name|p
operator|+=
name|TCL_ALIGN
argument_list|(
name|codeBytes
argument_list|)
expr_stmt|;
name|codePtr
operator|->
name|objArrayPtr
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|p
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|p
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|envPtr
operator|->
name|objArrayPtr
argument_list|,
name|objArrayBytes
argument_list|)
expr_stmt|;
name|p
operator|+=
name|TCL_ALIGN
argument_list|(
name|objArrayBytes
argument_list|)
expr_stmt|;
name|codePtr
operator|->
name|excRangeArrayPtr
operator|=
operator|(
name|ExceptionRange
operator|*
operator|)
name|p
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|p
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|envPtr
operator|->
name|excRangeArrayPtr
argument_list|,
name|rangeArrayBytes
argument_list|)
expr_stmt|;
name|p
operator|+=
name|TCL_ALIGN
argument_list|(
name|rangeArrayBytes
argument_list|)
expr_stmt|;
name|codePtr
operator|->
name|cmdMapPtr
operator|=
operator|(
name|CmdLocation
operator|*
operator|)
name|p
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|p
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|envPtr
operator|->
name|cmdMapPtr
argument_list|,
name|cmdLocBytes
argument_list|)
expr_stmt|;
name|p
operator|+=
name|TCL_ALIGN
argument_list|(
name|cmdLocBytes
argument_list|)
expr_stmt|;
name|codePtr
operator|->
name|auxDataArrayPtr
operator|=
operator|(
name|AuxData
operator|*
operator|)
name|p
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|p
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|envPtr
operator|->
name|auxDataArrayPtr
argument_list|,
name|auxDataArrayBytes
argument_list|)
expr_stmt|;
comment|/*      * Free the old internal rep then convert the object to a      * bytecode object by making its internal rep point to the just      * compiled ByteCode.      */
if|if
condition|(
operator|(
name|objPtr
operator|->
name|typePtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|objPtr
operator|->
name|typePtr
operator|->
name|freeIntRepProc
operator|!=
name|NULL
operator|)
condition|)
block|{
name|objPtr
operator|->
name|typePtr
operator|->
name|freeIntRepProc
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
name|objPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
operator|=
operator|(
name|VOID
operator|*
operator|)
name|codePtr
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclByteCodeType
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCompileString --  *  *	Compile a Tcl script in a null-terminated binary string.  *  * Results:  *	The return value is TCL_OK on a successful compilation and TCL_ERROR  *	on failure. If TCL_ERROR is returned, then the interpreter's result  *	contains an error message.  *  *	envPtr->termOffset and interp->termOffset are filled in with the  *	offset of the character in the string just after the last one  *	successfully processed; this might be the offset of the ']' (if  *	flags& TCL_BRACKET_TERM), or the offset of the '\0' at the end of  *	the string. Also updates envPtr->maxStackDepth with the maximum  *	number of stack elements needed to execute the string's commands.  *  * Side effects:  *	Adds instructions to envPtr to evaluate the string at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclCompileString
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|lastChar
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* The source string to compile. */
name|char
modifier|*
name|lastChar
decl_stmt|;
comment|/* Pointer to terminating character of 				  * string. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
specifier|register
name|char
modifier|*
name|src
init|=
name|string
decl_stmt|;
comment|/* Points to current source char. */
specifier|register
name|char
name|c
init|=
operator|*
name|src
decl_stmt|;
comment|/* The current char. */
specifier|register
name|int
name|type
decl_stmt|;
comment|/* Current char's CHAR_TYPE type. */
name|char
name|termChar
init|=
call|(
name|char
call|)
argument_list|(
operator|(
name|flags
operator|&
name|TCL_BRACKET_TERM
operator|)
condition|?
literal|']'
else|:
literal|'\0'
argument_list|)
decl_stmt|;
comment|/* Return when this character is found 				 * (either ']' or '\0'). Zero means newlines 				 * terminate cmds. */
name|int
name|isFirstCmd
init|=
literal|1
decl_stmt|;
comment|/* 1 if compiling the first cmd. */
name|char
modifier|*
name|cmdSrcStart
init|=
name|NULL
decl_stmt|;
comment|/* Points to first non-blank char in each  				 * command. Initialized to avoid compiler  				 * warning. */
name|int
name|cmdIndex
init|=
operator|-
literal|1
decl_stmt|;
comment|/* The index of the current command in the  				 * compilation environment's command  				 * location table. Initialized to avoid  				 * compiler warning. */
name|int
name|cmdCodeOffset
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Offset of first byte of current command's  				 * code. Initialized to avoid compiler  				 * warning. */
name|int
name|cmdCodeBytes
decl_stmt|;
comment|/* Number of code bytes for current 				 * command. */
name|int
name|cmdWords
decl_stmt|;
comment|/* Number of words in current command. */
name|Tcl_Command
name|cmd
decl_stmt|;
comment|/* Used to search for commands. */
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
comment|/* Points to command's Command structure if 				 * first word is simple and command was 				 * found; else NULL. */
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute all cmds. */
name|char
modifier|*
name|termPtr
decl_stmt|;
comment|/* Points to char that terminated word. */
name|char
name|savedChar
decl_stmt|;
comment|/* Holds the character from string 				 * termporarily replaced by a null character 				 * during processing of words. */
name|int
name|objIndex
init|=
operator|-
literal|1
decl_stmt|;
comment|/* The object array index for a pushed  				 * object holding a word or word part  				 * Initialized to avoid compiler warning. */
name|unsigned
name|char
modifier|*
name|entryCodeNext
init|=
name|envPtr
operator|->
name|codeNext
decl_stmt|;
comment|/* Value of envPtr's current instruction 				 * pointer at entry. Used to tell if any 				 * instructions generated. */
name|char
modifier|*
name|ellipsis
init|=
literal|""
decl_stmt|;
comment|/* Used to set errorInfo variable; "..." 				 * indicates that not all of offending 				 * command is included in errorInfo. "" 				 * means that the command is all there. */
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|int
name|numChars
decl_stmt|;
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
name|int
name|savePushSimpleWords
init|=
name|envPtr
operator|->
name|pushSimpleWords
decl_stmt|;
comment|/*      * commands: command {(';' | '\n') command}      */
while|while
condition|(
operator|(
name|src
operator|!=
name|lastChar
operator|)
operator|&&
operator|(
name|c
operator|!=
name|termChar
operator|)
condition|)
block|{
comment|/* 	 * Skip white space, semicolons, backslash-newlines (treated as 	 * spaces), and comments before command. 	 */
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|type
operator|&
operator|(
name|TCL_SPACE
operator||
name|TCL_BACKSLASH
operator|)
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|c
operator|==
literal|';'
operator|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|TCL_BACKSLASH
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|src
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
break|break;
comment|/* no longer white space */
block|}
block|}
else|else
block|{
name|src
operator|++
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|src
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
name|src
operator|!=
name|lastChar
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|int
name|numRead
decl_stmt|;
name|Tcl_Backslash
argument_list|(
name|src
argument_list|,
operator|&
name|numRead
argument_list|)
expr_stmt|;
name|src
operator|+=
name|numRead
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|src
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|src
expr_stmt|;
name|envPtr
operator|->
name|termOffset
operator|=
operator|(
name|src
operator|-
name|string
operator|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|src
operator|++
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|src
expr_stmt|;
block|}
continue|continue;
comment|/* end of comment, restart outer command loop */
block|}
comment|/* 	 * Compile one command: zero or more words terminated by a '\n', 	 * ';', ']' (if command is terminated by close bracket), or 	 * the end of string. 	 * 	 * command: word* 	 */
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|TCL_COMMAND_END
operator|)
operator|&&
operator|(
operator|(
name|c
operator|!=
literal|']'
operator|)
operator|||
operator|(
name|flags
operator|&
name|TCL_BRACKET_TERM
operator|)
operator|)
condition|)
block|{
continue|continue;
comment|/* ignore empty command; restart outer cmd loop */
block|}
comment|/* 	 * If not the first command, discard the previous command's result. 	 */
if|if
condition|(
operator|!
name|isFirstCmd
condition|)
block|{
name|TclEmitOpcode
argument_list|(
name|INST_POP
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TCL_BRACKET_TERM
operator|)
condition|)
block|{
comment|/* 		 * We are compiling a top level command. Update the number 		 * of code bytes for the last command to account for the pop 		 * instruction we just emitted. 		 */
name|int
name|lastCmdIndex
init|=
operator|(
name|envPtr
operator|->
name|numCommands
operator|-
literal|1
operator|)
decl_stmt|;
name|cmdCodeBytes
operator|=
operator|(
name|envPtr
operator|->
name|codeNext
operator|-
name|envPtr
operator|->
name|codeStart
operator|-
name|cmdCodeOffset
operator|)
expr_stmt|;
operator|(
name|envPtr
operator|->
name|cmdMapPtr
index|[
name|lastCmdIndex
index|]
operator|)
operator|.
name|numCodeBytes
operator|=
name|cmdCodeBytes
expr_stmt|;
block|}
block|}
comment|/* 	 * Compile the words of the command. Process the first word 	 * specially, since it is the name of a command. If it is a "simple" 	 * string (just a sequence of characters), look it up in the table 	 * of compilation procedures. If a word other than the first is 	 * simple and represents an integer whose formatted representation 	 * is the same as the word, just push an integer object. Also record 	 * starting source and object information for the command if we are 	 * at the top level (i.e. we were called directly from 	 * SetByteCodeFromAny and are not compiling a substring enclosed in 	 * square brackets). 	 */
name|cmdSrcStart
operator|=
name|src
expr_stmt|;
name|cmdCodeOffset
operator|=
operator|(
name|envPtr
operator|->
name|codeNext
operator|-
name|envPtr
operator|->
name|codeStart
operator|)
expr_stmt|;
name|cmdWords
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TCL_BRACKET_TERM
operator|)
condition|)
block|{
name|envPtr
operator|->
name|numCommands
operator|++
expr_stmt|;
name|cmdIndex
operator|=
operator|(
name|envPtr
operator|->
name|numCommands
operator|-
literal|1
operator|)
expr_stmt|;
name|EnterCmdStartData
argument_list|(
name|envPtr
argument_list|,
name|cmdIndex
argument_list|,
operator|(
name|cmdSrcStart
operator|-
name|envPtr
operator|->
name|source
operator|)
argument_list|,
name|cmdCodeOffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tclTraceCompile
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|envPtr
operator|->
name|procPtr
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* 		 * Display a line summarizing the top level command we 		 * are about to compile. 		 */
name|char
modifier|*
name|p
init|=
name|cmdSrcStart
decl_stmt|;
name|int
name|numChars
decl_stmt|;
name|char
modifier|*
name|ellipsis
init|=
literal|""
decl_stmt|;
while|while
condition|(
operator|(
name|CHAR_TYPE
argument_list|(
name|p
argument_list|,
name|lastChar
argument_list|)
operator|!=
name|TCL_COMMAND_END
operator|)
operator|||
operator|(
operator|(
operator|*
name|p
operator|==
literal|']'
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|TCL_BRACKET_TERM
operator|)
operator|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
name|numChars
operator|=
operator|(
name|p
operator|-
name|cmdSrcStart
operator|)
expr_stmt|;
if|if
condition|(
name|numChars
operator|>
literal|60
condition|)
block|{
name|numChars
operator|=
literal|60
expr_stmt|;
name|ellipsis
operator|=
literal|" ..."
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|numChars
operator|>=
literal|2
operator|)
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'\n'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|==
literal|'{'
operator|)
condition|)
block|{
name|ellipsis
operator|=
literal|" ..."
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Compiling: %.*s%s\n"
argument_list|,
name|numChars
argument_list|,
name|cmdSrcStart
argument_list|,
name|ellipsis
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|(
name|type
operator|!=
name|TCL_COMMAND_END
operator|)
operator|||
operator|(
operator|(
name|c
operator|==
literal|']'
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|TCL_BRACKET_TERM
operator|)
operator|)
condition|)
block|{
comment|/* 	     * Skip any leading white space at the start of a word. Note 	     * that a backslash-newline is treated as a space. 	     */
while|while
condition|(
name|type
operator|&
operator|(
name|TCL_SPACE
operator||
name|TCL_BACKSLASH
operator|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|TCL_BACKSLASH
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|src
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
break|break;
comment|/* no longer white space */
block|}
block|}
else|else
block|{
name|src
operator|++
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|src
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|type
operator|==
name|TCL_COMMAND_END
operator|)
operator|&&
operator|(
operator|(
name|c
operator|!=
literal|']'
operator|)
operator|||
operator|(
name|flags
operator|&
name|TCL_BRACKET_TERM
operator|)
operator|)
condition|)
block|{
break|break;
comment|/* no words remain for command. */
block|}
comment|/* 	     * Compile one word. We use an inline version of CompileWord to 	     * avoid an extra procedure call. 	     */
name|envPtr
operator|->
name|pushSimpleWords
operator|=
literal|0
expr_stmt|;
comment|/* we will handle simple words */
if|if
condition|(
name|type
operator|&
operator|(
name|TCL_QUOTE
operator||
name|TCL_OPEN_BRACE
operator|)
condition|)
block|{
name|src
operator|++
expr_stmt|;
comment|/* advance over the " or { */
if|if
condition|(
name|type
operator|==
name|TCL_QUOTE
condition|)
block|{
name|result
operator|=
name|TclCompileQuotes
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
name|lastChar
argument_list|,
literal|'"'
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|CompileBraces
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
name|lastChar
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
name|termPtr
operator|=
operator|(
name|src
operator|+
name|envPtr
operator|->
name|termOffset
operator|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|src
operator|=
name|termPtr
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 		 * Make sure terminating character of the quoted or braced 		 * string is the end of word. 		 */
name|c
operator|=
operator|*
name|termPtr
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|termPtr
operator|+
literal|1
operator|)
operator|==
literal|'\n'
operator|)
condition|)
block|{
comment|/* 		     * Line is continued on next line; the backslash- 		     * newline turns into space, which terminates the word. 		     */
block|}
else|else
block|{
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|termPtr
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|!=
name|TCL_SPACE
operator|)
operator|&&
operator|(
name|type
operator|!=
name|TCL_COMMAND_END
operator|)
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|src
operator|-
literal|1
operator|)
operator|==
literal|'"'
condition|)
block|{
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"extra characters after close-quote"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"extra characters after close-brace"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|result
operator|=
name|CompileMultipartWord
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
name|lastChar
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|termPtr
operator|=
operator|(
name|src
operator|+
name|envPtr
operator|->
name|termOffset
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|ellipsis
operator|=
literal|"..."
expr_stmt|;
name|src
operator|=
name|termPtr
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|envPtr
operator|->
name|wordIsSimple
condition|)
block|{
comment|/* 		 * A simple word. Temporarily replace the terminating 		 * character with a null character. 		 */
name|numChars
operator|=
name|envPtr
operator|->
name|numSimpleWordChars
expr_stmt|;
name|savedChar
operator|=
name|src
index|[
name|numChars
index|]
expr_stmt|;
name|src
index|[
name|numChars
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|cmdWords
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
operator|(
name|iPtr
operator|->
name|flags
operator|&
name|DONT_COMPILE_CMDS_INLINE
operator|)
operator|)
condition|)
block|{
comment|/* 		     * The first word of a command and inline command 		     * compilation has not been disabled (e.g., by command 		     * traces). Look up the first word in the interpreter's 		     * hashtable of commands. If a compilation procedure is 		     * found, let it compile the command after resetting 		     * error logging information. 		     */
name|cmdPtr
operator|=
name|NULL
expr_stmt|;
name|cmd
operator|=
name|Tcl_FindCommand
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|NULL
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
operator|(
name|Tcl_Command
operator|)
name|NULL
condition|)
block|{
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|cmd
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cmdPtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|cmdPtr
operator|->
name|compileProc
operator|!=
name|NULL
operator|)
condition|)
block|{
name|char
modifier|*
name|firstArg
init|=
name|termPtr
decl_stmt|;
name|src
index|[
name|numChars
index|]
operator|=
name|savedChar
expr_stmt|;
comment|/* restore chr */
name|iPtr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|ERR_ALREADY_LOGGED
operator||
name|ERR_IN_PROGRESS
operator||
name|ERROR_CODE_SET
operator|)
expr_stmt|;
name|result
operator|=
operator|(
operator|*
operator|(
name|cmdPtr
operator|->
name|compileProc
operator|)
operator|)
operator|(
name|interp
operator|,
name|firstArg
operator|,
name|lastChar
operator|,
name|flags
operator|,
name|envPtr
operator|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
name|src
operator|=
operator|(
name|firstArg
operator|+
name|envPtr
operator|->
name|termOffset
operator|)
expr_stmt|;
name|maxDepth
operator|=
name|TclMax
argument_list|(
name|envPtr
operator|->
name|maxStackDepth
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
goto|goto
name|finishCommand
goto|;
comment|/* done with command */
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|TCL_OUT_LINE_COMPILE
condition|)
block|{
name|result
operator|=
name|TCL_OK
expr_stmt|;
comment|/* reset result */
name|src
index|[
name|numChars
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|src
operator|=
name|firstArg
expr_stmt|;
goto|goto
name|done
goto|;
comment|/* an error */
block|}
block|}
comment|/* 		     * No compile procedure was found for the command: push 		     * the word and continue to compile the remaining 		     * words. If a hashtable entry was found for the 		     * command, push a CmdName object instead to avoid 		     * runtime lookups. If necessary, convert the pushed 		     * object to be a CmdName object. If this is the first 		     * CmdName object in this code unit that refers to the 		     * command, increment the reference count in the 		     * Command structure to reflect the new reference from 		     * the CmdName object and, if the command is deleted 		     * later, to keep the Command structure from being freed 		     * until TclExecuteByteCode has a chance to recognize 		     * that the command was deleted. 		     */
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
name|src
argument_list|,
name|numChars
argument_list|,
comment|/*allocStrRep*/
literal|1
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdPtr
operator|!=
name|NULL
condition|)
block|{
name|objPtr
operator|=
name|envPtr
operator|->
name|objArrayPtr
index|[
name|objIndex
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|objPtr
operator|->
name|typePtr
operator|!=
operator|&
name|tclCmdNameType
operator|)
operator|&&
operator|(
name|objPtr
operator|->
name|bytes
operator|!=
name|NULL
operator|)
condition|)
block|{
name|ResolvedCmdName
modifier|*
name|resPtr
init|=
operator|(
name|ResolvedCmdName
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ResolvedCmdName
argument_list|)
argument_list|)
decl_stmt|;
name|Namespace
modifier|*
name|nsPtr
init|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetCurrentNamespace
argument_list|(
name|interp
argument_list|)
decl_stmt|;
name|resPtr
operator|->
name|cmdPtr
operator|=
name|cmdPtr
expr_stmt|;
name|resPtr
operator|->
name|refNsPtr
operator|=
name|nsPtr
expr_stmt|;
name|resPtr
operator|->
name|refNsId
operator|=
name|nsPtr
operator|->
name|nsId
expr_stmt|;
name|resPtr
operator|->
name|refNsCmdEpoch
operator|=
name|nsPtr
operator|->
name|cmdRefEpoch
expr_stmt|;
name|resPtr
operator|->
name|cmdEpoch
operator|=
name|cmdPtr
operator|->
name|cmdEpoch
expr_stmt|;
name|resPtr
operator|->
name|refCount
operator|=
literal|1
expr_stmt|;
name|objPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
operator|=
operator|(
name|VOID
operator|*
operator|)
name|resPtr
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclCmdNameType
expr_stmt|;
name|cmdPtr
operator|->
name|refCount
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		     * See if the word represents an integer whose formatted 		     * representation is the same as the word (e.g., this is 		     * true for 123 and -1 but not for 00005). If so, just 		     * push an integer object. 		     */
name|int
name|isCompilableInt
init|=
literal|0
decl_stmt|;
name|long
name|n
decl_stmt|;
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
if|if
condition|(
name|TclLooksLikeInt
argument_list|(
name|src
argument_list|)
condition|)
block|{
if|if
condition|(
name|TclGetLong
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
operator|&
name|n
argument_list|)
operator|==
name|TCL_OK
condition|)
block|{
name|TclFormatInt
argument_list|(
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|src
argument_list|,
name|buf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|isCompilableInt
operator|=
literal|1
expr_stmt|;
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
name|src
argument_list|,
name|numChars
argument_list|,
comment|/*allocStrRep*/
literal|0
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|objPtr
operator|=
name|envPtr
operator|->
name|objArrayPtr
index|[
name|objIndex
index|]
expr_stmt|;
name|Tcl_InvalidateStringRep
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|=
name|n
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclIntType
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|isCompilableInt
condition|)
block|{
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
name|src
argument_list|,
name|numChars
argument_list|,
comment|/*allocStrRep*/
literal|1
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
block|}
name|src
index|[
name|numChars
index|]
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|maxDepth
operator|=
name|TclMax
argument_list|(
operator|(
name|cmdWords
operator|+
literal|1
operator|)
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* not a simple word */
name|maxDepth
operator|=
name|TclMax
argument_list|(
operator|(
name|cmdWords
operator|+
name|envPtr
operator|->
name|maxStackDepth
operator|)
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
block|}
name|src
operator|=
name|termPtr
expr_stmt|;
name|c
operator|=
operator|*
name|src
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
name|cmdWords
operator|++
expr_stmt|;
block|}
comment|/* 	 * Emit an invoke instruction for the command. If a compile command 	 * was found for the command we called it and skipped this. 	 */
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
if|if
condition|(
operator|(
name|cmdWords
operator|<
literal|0
operator|)
operator|||
operator|(
name|cmdWords
operator|>
literal|10000
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nTclCompileString: bad cmdWords value %d\n"
argument_list|,
name|cmdWords
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"TclCompileString: bad cmdWords value %d"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*TCL_COMPILE_DEBUG*/
if|if
condition|(
name|cmdWords
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cmdWords
operator|<=
literal|255
condition|)
block|{
name|TclEmitInstUInt1
argument_list|(
name|INST_INVOKE_STK1
argument_list|,
name|cmdWords
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TclEmitInstUInt4
argument_list|(
name|INST_INVOKE_STK4
argument_list|,
name|cmdWords
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Update the compilation environment structure. Record 	 * source/object information for the command if we are at the top 	 * level (i.e. we we called directly from SetByteCodeFromAny and are 	 * not compiling a substring enclosed in square brackets). 	 */
name|finishCommand
label|:
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TCL_BRACKET_TERM
operator|)
condition|)
block|{
name|int
name|cmdSrcChars
init|=
operator|(
name|src
operator|-
name|cmdSrcStart
operator|)
decl_stmt|;
name|cmdCodeBytes
operator|=
operator|(
name|envPtr
operator|->
name|codeNext
operator|-
name|envPtr
operator|->
name|codeStart
operator|-
name|cmdCodeOffset
operator|)
expr_stmt|;
name|EnterCmdExtentData
argument_list|(
name|envPtr
argument_list|,
name|cmdIndex
argument_list|,
name|cmdSrcChars
argument_list|,
name|cmdCodeBytes
argument_list|)
expr_stmt|;
block|}
name|isFirstCmd
operator|=
literal|0
expr_stmt|;
name|envPtr
operator|->
name|termOffset
operator|=
operator|(
name|src
operator|-
name|string
operator|)
expr_stmt|;
name|c
operator|=
operator|*
name|src
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
comment|/* 	 * If the source string yielded no instructions (e.g., if it was 	 * empty), push an empty string object as the command's result. 	 */
if|if
condition|(
name|entryCodeNext
operator|==
name|envPtr
operator|->
name|codeNext
condition|)
block|{
name|int
name|objIndex
init|=
name|TclObjIndexForString
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|,
comment|/*allocStrRep*/
literal|0
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
decl_stmt|;
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|maxDepth
operator|=
literal|1
expr_stmt|;
comment|/* we pushed 1 word for the empty string */
block|}
block|}
else|else
block|{
comment|/* 	 * Add additional error information. First compute the line number 	 * where the error occurred. 	 */
name|int
name|numChars
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
name|iPtr
operator|->
name|errorLine
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|string
init|;
name|p
operator|!=
name|cmdSrcStart
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
name|iPtr
operator|->
name|errorLine
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|';'
operator|)
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
name|iPtr
operator|->
name|errorLine
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Figure out how much of the command to print (up to a certain 	 * number of characters, or up to the first newline). 	 */
name|numChars
operator|=
operator|(
name|src
operator|-
name|cmdSrcStart
operator|)
expr_stmt|;
if|if
condition|(
name|numChars
operator|>
literal|150
condition|)
block|{
name|numChars
operator|=
literal|150
expr_stmt|;
name|ellipsis
operator|=
literal|" ..."
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\n    while compiling\n\"%.*s%s\""
argument_list|,
name|numChars
argument_list|,
name|cmdSrcStart
argument_list|,
name|ellipsis
argument_list|)
expr_stmt|;
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|envPtr
operator|->
name|termOffset
operator|=
operator|(
name|src
operator|-
name|string
operator|)
expr_stmt|;
name|iPtr
operator|->
name|termOffset
operator|=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
name|envPtr
operator|->
name|pushSimpleWords
operator|=
name|savePushSimpleWords
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CompileWord --  *  *	This procedure compiles one word from a command string. It skips  *	any leading white space.  *  *	Ordinarily, callers set envPtr->pushSimpleWords to 1 and this  *	procedure emits push and other instructions to compute the  *	word on the Tcl evaluation stack at execution time. If a caller sets  *	envPtr->pushSimpleWords to 0, CompileWord will _not_ compile  *	"simple" words: words that are just a sequence of characters without  *	backslashes. It will leave their compilation up to the caller.  *  *	As an important special case, if the word is simple, this procedure  *	sets envPtr->wordIsSimple to 1 and envPtr->numSimpleWordChars to the  *	number of characters in the simple word. This allows the caller to  *	process these words specially.  *  * Results:  *	The return value is a standard Tcl result. If an error occurs, an  *	error message is left in the interpreter's result.  *	  *	envPtr->termOffset is filled in with the offset of the character in  *	"string" just after the last one successfully processed in the last  *	word. This is normally the character just after the last one in a  *	word (perhaps the command terminator), or the vicinity of an error  *	(if the result is not TCL_OK).  *  *	envPtr->wordIsSimple is set 1 if the word is simple: just a  *	sequence of characters without backslashes. If so, the word's  *	characters are the envPtr->numSimpleWordChars characters starting   *	at string.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to evaluate the word. This is not changed if  *	the word is simple and envPtr->pushSimpleWords was 0 (false).  *  * Side effects:  *	Instructions are added to envPtr to compute and push the word  *	at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CompileWord
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|lastChar
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for nested command 				 * evaluations and error messages. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* First character of word. */
name|char
modifier|*
name|lastChar
decl_stmt|;
comment|/* Pointer to terminating character of 				  * string. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same values 				 * passed to Tcl_EvalObj). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds the resulting instructions. */
block|{
comment|/*      * Compile one word: approximately      *      * word:             quoted_string | braced_string | multipart_word      * quoted_string:    '"' char* '"'      * braced_string:    '{' char* '}'      * multipart_word    (see CompileMultipartWord below)      */
specifier|register
name|char
modifier|*
name|src
init|=
name|string
decl_stmt|;
comment|/* Points to current source char. */
specifier|register
name|int
name|type
init|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
decl_stmt|;
comment|/* Current char's CHAR_TYPE type. */
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				  * to compute and push the word. */
name|char
modifier|*
name|termPtr
init|=
name|src
decl_stmt|;
comment|/* Points to the character that terminated 				  * the word. */
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
comment|/*      * Skip any leading white space at the start of a word. Note that a      * backslash-newline is treated as a space.      */
while|while
condition|(
name|type
operator|&
operator|(
name|TCL_SPACE
operator||
name|TCL_BACKSLASH
operator|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|TCL_BACKSLASH
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|src
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
break|break;
comment|/* no longer white space */
block|}
block|}
else|else
block|{
name|src
operator|++
expr_stmt|;
block|}
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|TCL_COMMAND_END
condition|)
block|{
goto|goto
name|done
goto|;
block|}
comment|/*      * Compile the word. Handle quoted and braced string words here in order      * to avoid an extra procedure call.      */
if|if
condition|(
name|type
operator|&
operator|(
name|TCL_QUOTE
operator||
name|TCL_OPEN_BRACE
operator|)
condition|)
block|{
name|src
operator|++
expr_stmt|;
comment|/* advance over the " or { */
if|if
condition|(
name|type
operator|==
name|TCL_QUOTE
condition|)
block|{
name|result
operator|=
name|TclCompileQuotes
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
name|lastChar
argument_list|,
literal|'"'
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|CompileBraces
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
name|lastChar
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
name|termPtr
operator|=
operator|(
name|src
operator|+
name|envPtr
operator|->
name|termOffset
operator|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Make sure terminating character of the quoted or braced string is 	 * the end of word. 	 */
if|if
condition|(
operator|(
operator|*
name|termPtr
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|termPtr
operator|+
literal|1
operator|)
operator|==
literal|'\n'
operator|)
condition|)
block|{
comment|/* 	     * Line is continued on next line; the backslash-newline turns 	     * into space, which terminates the word. 	     */
block|}
else|else
block|{
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|termPtr
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|type
operator|&
operator|(
name|TCL_SPACE
operator||
name|TCL_COMMAND_END
operator|)
operator|)
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|src
operator|-
literal|1
operator|)
operator|==
literal|'"'
condition|)
block|{
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"extra characters after close-quote"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"extra characters after close-brace"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|CompileMultipartWord
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
name|lastChar
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|termPtr
operator|=
operator|(
name|src
operator|+
name|envPtr
operator|->
name|termOffset
operator|)
expr_stmt|;
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
block|}
comment|/*      * Done processing the word. The values of envPtr->wordIsSimple and      * envPtr->numSimpleWordChars are left at the values returned by      * TclCompileQuotes/Braces/MultipartWord.      */
name|done
label|:
name|envPtr
operator|->
name|termOffset
operator|=
operator|(
name|termPtr
operator|-
name|string
operator|)
expr_stmt|;
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CompileMultipartWord --  *  *	This procedure compiles one multipart word: a word comprised of some  *	number of nested commands, variable references, or arbitrary  *	characters. This procedure assumes that quoted string and braced  *	string words and the end of command have already been handled by its  *	caller. It also assumes that any leading white space has already  *	been consumed.  *  *	Ordinarily, callers set envPtr->pushSimpleWords to 1 and this  *	procedure emits push and other instructions to compute the word on  *	the Tcl evaluation stack at execution time. If a caller sets  *	envPtr->pushSimpleWords to 0, it will _not_ compile "simple" words:  *	words that are just a sequence of characters without backslashes.  *	It will leave their compilation up to the caller. This is done, for  *	example, to provide special support for the first word of commands,  *	which are almost always the (simple) name of a command.  *  *	As an important special case, if the word is simple, this procedure  *	sets envPtr->wordIsSimple to 1 and envPtr->numSimpleWordChars to the  *	number of characters in the simple word. This allows the caller to  *	process these words specially.  *  * Results:  *	The return value is a standard Tcl result. If an error occurs, an  *	error message is left in the interpreter's result.  *	  *	envPtr->termOffset is filled in with the offset of the character in  *	"string" just after the last one successfully processed in the last  *	word. This is normally the character just after the last one in a  *	word (perhaps the command terminator), or the vicinity of an error  *	(if the result is not TCL_OK).  *  *	envPtr->wordIsSimple is set 1 if the word is simple: just a  *	sequence of characters without backslashes. If so, the word's  *	characters are the envPtr->numSimpleWordChars characters starting   *	at string.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to evaluate the word. This is not changed if  *	the word is simple and envPtr->pushSimpleWords was 0 (false).  *  * Side effects:  *	Instructions are added to envPtr to compute and push the word  *	at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CompileMultipartWord
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|lastChar
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for nested command 				 * evaluations and error messages. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* First character of word. */
name|char
modifier|*
name|lastChar
decl_stmt|;
comment|/* Pointer to terminating character of 				  * string. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same values 				 * passed to Tcl_EvalObj). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds the resulting instructions. */
block|{
comment|/*      * Compile one multi_part word:      *      * multi_part_word:  word_part+      * word_part:        nested_cmd | var_reference | char+      * nested_cmd:       '[' command ']'      * var_reference:    '$' name | '$' name '(' index_string ')' |      *                   '$' '{' braced_name '}')      * name:             (letter | digit | underscore)+      * braced_name:      (non_close_brace_char)*      * index_string:     (non_close_paren_char)*      */
specifier|register
name|char
modifier|*
name|src
init|=
name|string
decl_stmt|;
comment|/* Points to current source char. */
specifier|register
name|char
name|c
init|=
operator|*
name|src
decl_stmt|;
comment|/* The current char. */
specifier|register
name|int
name|type
decl_stmt|;
comment|/* Current char's CHAR_TYPE type. */
name|int
name|bracketNormal
init|=
operator|!
operator|(
name|flags
operator|&
name|TCL_BRACKET_TERM
operator|)
decl_stmt|;
name|int
name|simpleWord
init|=
literal|0
decl_stmt|;
comment|/* Set 1 if word is simple. */
name|int
name|numParts
init|=
literal|0
decl_stmt|;
comment|/* Count of word_part objs pushed. */
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to compute and push the word. */
name|char
modifier|*
name|start
decl_stmt|;
comment|/* Starting position of char+ word_part. */
name|int
name|hasBackslash
decl_stmt|;
comment|/* Nonzero if '\' in char+ word_part. */
name|int
name|numChars
decl_stmt|;
comment|/* Number of chars in char+ word_part. */
name|char
name|savedChar
decl_stmt|;
comment|/* Holds the character from string 				 * termporarily replaced by a null character 				 * during word_part processing. */
name|int
name|objIndex
decl_stmt|;
comment|/* The object array index for a pushed 				 * object holding a word_part. */
name|int
name|savePushSimpleWords
init|=
name|envPtr
operator|->
name|pushSimpleWords
decl_stmt|;
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
name|int
name|numRead
decl_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* 	 * Process a word_part: a sequence of chars, a var reference, or 	 * a nested command. 	 */
if|if
condition|(
operator|(
name|type
operator|&
operator|(
name|TCL_NORMAL
operator||
name|TCL_CLOSE_BRACE
operator||
name|TCL_BACKSLASH
operator||
name|TCL_QUOTE
operator||
name|TCL_OPEN_BRACE
operator|)
operator|)
operator|||
operator|(
operator|(
name|c
operator|==
literal|']'
operator|)
operator|&&
name|bracketNormal
operator|)
condition|)
block|{
comment|/* 	     * A char+ word part. Scan first looking for any backslashes. 	     * Note that a backslash-newline must be treated as a word 	     * separator, as if the backslash-newline had been collapsed 	     * before command parsing began. 	     */
name|start
operator|=
name|src
expr_stmt|;
name|hasBackslash
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|type
operator|==
name|TCL_BACKSLASH
condition|)
block|{
name|hasBackslash
operator|=
literal|1
expr_stmt|;
name|Tcl_Backslash
argument_list|(
name|src
argument_list|,
operator|&
name|numRead
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|src
operator|+=
name|numRead
expr_stmt|;
name|type
operator|=
name|TCL_SPACE
expr_stmt|;
comment|/* force word end */
break|break;
comment|/* exit loop: \newline is word separator */
block|}
name|src
operator|+=
name|numRead
expr_stmt|;
block|}
else|else
block|{
name|src
operator|++
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|src
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|type
operator|&
operator|(
name|TCL_NORMAL
operator||
name|TCL_BACKSLASH
operator||
name|TCL_QUOTE
operator||
name|TCL_OPEN_BRACE
operator||
name|TCL_CLOSE_BRACE
operator|)
operator|||
operator|(
operator|(
name|c
operator|==
literal|']'
operator|)
operator|&&
name|bracketNormal
operator|)
condition|)
do|;
if|if
condition|(
operator|(
name|numParts
operator|==
literal|0
operator|)
operator|&&
operator|!
name|hasBackslash
operator|&&
operator|(
name|type
operator|&
operator|(
name|TCL_SPACE
operator||
name|TCL_COMMAND_END
operator|)
operator|)
condition|)
block|{
comment|/* 		 * The word is "simple": just a sequence of characters 		 * without backslashes terminated by a TCL_SPACE or 		 * TCL_COMMAND_END. Just return if we are not to compile 		 * simple words. 		 */
name|simpleWord
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|envPtr
operator|->
name|pushSimpleWords
condition|)
block|{
name|envPtr
operator|->
name|wordIsSimple
operator|=
literal|1
expr_stmt|;
name|envPtr
operator|->
name|numSimpleWordChars
operator|=
operator|(
name|src
operator|-
name|string
operator|)
expr_stmt|;
name|envPtr
operator|->
name|termOffset
operator|=
name|envPtr
operator|->
name|numSimpleWordChars
expr_stmt|;
name|envPtr
operator|->
name|pushSimpleWords
operator|=
name|savePushSimpleWords
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
block|}
comment|/* 	     * Create and push a string object for the char+ word_part, 	     * which starts at "start" and ends at the char just before 	     * src. If backslashes were found, copy the word_part's 	     * characters with substituted backslashes into a heap-allocated 	     * buffer and use it to create the string object. Temporarily 	     * replace the terminating character with a null character. 	     */
name|numChars
operator|=
operator|(
name|src
operator|-
name|start
operator|)
expr_stmt|;
name|savedChar
operator|=
name|start
index|[
name|numChars
index|]
expr_stmt|;
name|start
index|[
name|numChars
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|numChars
operator|>
literal|0
operator|)
operator|&&
operator|(
name|hasBackslash
operator|)
condition|)
block|{
name|char
modifier|*
name|buffer
init|=
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|numChars
operator|+
literal|1
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|dst
init|=
name|buffer
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|start
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|src
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|dst
operator|=
name|Tcl_Backslash
argument_list|(
name|p
argument_list|,
operator|&
name|numRead
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
break|break;
comment|/* end of word */
block|}
name|p
operator|+=
name|numRead
expr_stmt|;
name|dst
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dst
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
name|buffer
argument_list|,
name|dst
operator|-
name|buffer
argument_list|,
comment|/*allocStrRep*/
literal|1
argument_list|,
comment|/*inHeap*/
literal|1
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
name|start
argument_list|,
name|numChars
argument_list|,
comment|/*allocStrRep*/
literal|1
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
name|start
index|[
name|numChars
index|]
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|maxDepth
operator|=
name|TclMax
argument_list|(
operator|(
name|numParts
operator|+
literal|1
operator|)
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TCL_DOLLAR
condition|)
block|{
name|result
operator|=
name|TclCompileDollarVar
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
name|lastChar
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|TclMax
argument_list|(
operator|(
name|numParts
operator|+
name|envPtr
operator|->
name|maxStackDepth
operator|)
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|src
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TCL_OPEN_BRACKET
condition|)
block|{
name|char
modifier|*
name|termPtr
decl_stmt|;
name|envPtr
operator|->
name|pushSimpleWords
operator|=
literal|1
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|result
operator|=
name|TclCompileString
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
name|lastChar
argument_list|,
operator|(
name|flags
operator||
name|TCL_BRACKET_TERM
operator|)
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|termPtr
operator|=
operator|(
name|src
operator|+
name|envPtr
operator|->
name|termOffset
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|termPtr
operator|==
literal|']'
condition|)
block|{
name|termPtr
operator|++
expr_stmt|;
comment|/* advance over the ']'. */
block|}
elseif|else
if|if
condition|(
operator|*
name|termPtr
operator|==
literal|'\0'
condition|)
block|{
comment|/* 		 * Missing ] at end of nested command. 		 */
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"missing close-bracket"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
name|src
operator|=
name|termPtr
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|TclMax
argument_list|(
operator|(
name|numParts
operator|+
name|envPtr
operator|->
name|maxStackDepth
operator|)
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|src
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|&
operator|(
name|TCL_SPACE
operator||
name|TCL_COMMAND_END
operator|)
condition|)
block|{
goto|goto
name|wordEnd
goto|;
block|}
name|numParts
operator|++
expr_stmt|;
block|}
comment|/* end of infinite loop */
name|wordEnd
label|:
comment|/*      * End of a non-simple word: TCL_SPACE, TCL_COMMAND_END, or      * backslash-newline. Concatenate the word_parts if necessary.      */
while|while
condition|(
name|numParts
operator|>
literal|255
condition|)
block|{
name|TclEmitInstUInt1
argument_list|(
name|INST_CONCAT1
argument_list|,
literal|255
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|numParts
operator|-=
literal|254
expr_stmt|;
comment|/* concat pushes 1 obj, the result */
block|}
if|if
condition|(
name|numParts
operator|>
literal|1
condition|)
block|{
name|TclEmitInstUInt1
argument_list|(
name|INST_CONCAT1
argument_list|,
name|numParts
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|simpleWord
condition|)
block|{
name|envPtr
operator|->
name|wordIsSimple
operator|=
literal|1
expr_stmt|;
name|envPtr
operator|->
name|numSimpleWordChars
operator|=
operator|(
name|src
operator|-
name|string
operator|)
expr_stmt|;
block|}
else|else
block|{
name|envPtr
operator|->
name|wordIsSimple
operator|=
literal|0
expr_stmt|;
name|envPtr
operator|->
name|numSimpleWordChars
operator|=
literal|0
expr_stmt|;
block|}
name|envPtr
operator|->
name|termOffset
operator|=
operator|(
name|src
operator|-
name|string
operator|)
expr_stmt|;
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
name|envPtr
operator|->
name|pushSimpleWords
operator|=
name|savePushSimpleWords
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCompileQuotes --  *  *	This procedure compiles a double-quoted string such as a quoted Tcl  *	command argument or a quoted value in a Tcl expression. This  *	procedure is also used to compile array element names within  *	parentheses (where the termChar will be ')' instead of '"'), or  *	anything else that needs the substitutions that happen in quotes.  *  *	Ordinarily, callers set envPtr->pushSimpleWords to 1 and  *	TclCompileQuotes always emits push and other instructions to compute  *	the word on the Tcl evaluation stack at execution time. If a caller  *	sets envPtr->pushSimpleWords to 0, TclCompileQuotes will not compile  *	"simple" words: words that are just a sequence of characters without  *	backslashes. It will leave their compilation up to the caller. This  *	is done to provide special support for the first word of commands,  *	which are almost always the (simple) name of a command.  *  *	As an important special case, if the word is simple, this procedure  *	sets envPtr->wordIsSimple to 1 and envPtr->numSimpleWordChars to the  *	number of characters in the simple word. This allows the caller to  *	process these words specially.  *  * Results:  *	The return value is a standard Tcl result, which is TCL_OK unless  *	there was an error while parsing the quoted string. If an error  *	occurs then the interpreter's result contains a standard error  *	message.  *  *	envPtr->termOffset is filled in with the offset of the character in  *	"string" just after the last one successfully processed; this is  *	usually the character just after the matching close-quote.  *  *	envPtr->wordIsSimple is set 1 if the word is simple: just a  *	sequence of characters without backslashes. If so, the word's  *	characters are the envPtr->numSimpleWordChars characters starting   *	at string.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to evaluate the word. This is not changed if  *	the word is simple and envPtr->pushSimpleWords was 0 (false).  *  * Side effects:  *	Instructions are added to envPtr to push the quoted-string  *	at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclCompileQuotes
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|lastChar
parameter_list|,
name|termChar
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for nested command 				  * evaluations and error messages. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Points to the character just after 				  * the opening '"' or '('. */
name|char
modifier|*
name|lastChar
decl_stmt|;
comment|/* Pointer to terminating character of 				  * string. */
name|int
name|termChar
decl_stmt|;
comment|/* Character that terminates the "quoted" 				  * string (usually double-quote, but might 				  * be right-paren or something else). */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same  				  * values passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds the resulting instructions. */
block|{
specifier|register
name|char
modifier|*
name|src
init|=
name|string
decl_stmt|;
comment|/* Points to current source char. */
specifier|register
name|char
name|c
init|=
operator|*
name|src
decl_stmt|;
comment|/* The current char. */
name|int
name|simpleWord
init|=
literal|0
decl_stmt|;
comment|/* Set 1 if a simple quoted string word. */
name|char
modifier|*
name|start
decl_stmt|;
comment|/* Start position of char+ string_part. */
name|int
name|hasBackslash
decl_stmt|;
comment|/* 1 if '\' found in char+ string_part. */
name|int
name|numRead
decl_stmt|;
comment|/* Count of chars read by Tcl_Backslash. */
name|int
name|numParts
init|=
literal|0
decl_stmt|;
comment|/* Count of string_part objs pushed. */
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				  * to compute and push the string. */
name|char
name|savedChar
decl_stmt|;
comment|/* Holds the character from string 				  * termporarily replaced by a null  				  * char during string_part processing. */
name|int
name|objIndex
decl_stmt|;
comment|/* The object array index for a pushed 				  * object holding a string_part. */
name|int
name|numChars
decl_stmt|;
comment|/* Number of chars in string_part. */
name|int
name|savePushSimpleWords
init|=
name|envPtr
operator|->
name|pushSimpleWords
decl_stmt|;
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
comment|/*      * quoted_string: '"' string_part* '"'   (or termChar instead of ")      * string_part:   var_reference | nested_cmd | char+      */
while|while
condition|(
operator|(
name|src
operator|!=
name|lastChar
operator|)
operator|&&
operator|(
name|c
operator|!=
name|termChar
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
block|{
name|result
operator|=
name|TclCompileDollarVar
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
name|lastChar
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|TclMax
argument_list|(
operator|(
name|numParts
operator|+
name|envPtr
operator|->
name|maxStackDepth
operator|)
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|src
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'['
condition|)
block|{
name|char
modifier|*
name|termPtr
decl_stmt|;
name|envPtr
operator|->
name|pushSimpleWords
operator|=
literal|1
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|result
operator|=
name|TclCompileString
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
name|lastChar
argument_list|,
operator|(
name|flags
operator||
name|TCL_BRACKET_TERM
operator|)
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|termPtr
operator|=
operator|(
name|src
operator|+
name|envPtr
operator|->
name|termOffset
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|termPtr
operator|==
literal|']'
condition|)
block|{
name|termPtr
operator|++
expr_stmt|;
comment|/* advance over the ']'. */
block|}
name|src
operator|=
name|termPtr
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|termPtr
operator|==
name|lastChar
condition|)
block|{
comment|/* 		 * Missing ] at end of nested command. 		 */
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"missing close-bracket"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|TclMax
argument_list|(
operator|(
name|numParts
operator|+
name|envPtr
operator|->
name|maxStackDepth
operator|)
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|src
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * Start of a char+ string_part. Scan first looking for any 	     * backslashes. 	     */
name|start
operator|=
name|src
expr_stmt|;
name|hasBackslash
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|hasBackslash
operator|=
literal|1
expr_stmt|;
name|Tcl_Backslash
argument_list|(
name|src
argument_list|,
operator|&
name|numRead
argument_list|)
expr_stmt|;
name|src
operator|+=
name|numRead
expr_stmt|;
block|}
else|else
block|{
name|src
operator|++
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|src
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|src
operator|!=
name|lastChar
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'$'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'['
operator|)
operator|&&
operator|(
name|c
operator|!=
name|termChar
operator|)
condition|)
do|;
if|if
condition|(
operator|(
name|numParts
operator|==
literal|0
operator|)
operator|&&
operator|!
name|hasBackslash
operator|&&
operator|(
operator|(
name|src
operator|==
name|lastChar
operator|)
operator|&&
operator|(
name|c
operator|==
name|termChar
operator|)
operator|)
condition|)
block|{
comment|/* 		 * The quoted string is "simple": just a sequence of 		 * characters without backslashes terminated by termChar or 		 * a null character. Just return if we are not to compile 		 * simple words. 		 */
name|simpleWord
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|envPtr
operator|->
name|pushSimpleWords
condition|)
block|{
if|if
condition|(
operator|(
name|src
operator|==
name|lastChar
operator|)
operator|&&
operator|(
name|termChar
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"missing %c"
argument_list|,
name|termChar
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
else|else
block|{
name|src
operator|++
expr_stmt|;
comment|/* advance over termChar */
block|}
name|envPtr
operator|->
name|wordIsSimple
operator|=
literal|1
expr_stmt|;
name|envPtr
operator|->
name|numSimpleWordChars
operator|=
operator|(
name|src
operator|-
name|string
operator|-
literal|1
operator|)
expr_stmt|;
name|envPtr
operator|->
name|termOffset
operator|=
operator|(
name|src
operator|-
name|string
operator|)
expr_stmt|;
name|envPtr
operator|->
name|pushSimpleWords
operator|=
name|savePushSimpleWords
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
comment|/* 	     * Create and push a string object for the char+ string_part 	     * that starts at "start" and ends at the char just before 	     * src. If backslashes were found, copy the string_part's 	     * characters with substituted backslashes into a heap-allocated 	     * buffer and use it to create the string object. Temporarily 	     * replace the terminating character with a null character. 	     */
name|numChars
operator|=
operator|(
name|src
operator|-
name|start
operator|)
expr_stmt|;
name|savedChar
operator|=
name|start
index|[
name|numChars
index|]
expr_stmt|;
name|start
index|[
name|numChars
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|numChars
operator|>
literal|0
operator|)
operator|&&
operator|(
name|hasBackslash
operator|)
condition|)
block|{
name|char
modifier|*
name|buffer
init|=
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|numChars
operator|+
literal|1
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|dst
init|=
name|buffer
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|start
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|src
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
name|Tcl_Backslash
argument_list|(
name|p
argument_list|,
operator|&
name|numRead
argument_list|)
expr_stmt|;
name|p
operator|+=
name|numRead
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dst
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
name|buffer
argument_list|,
operator|(
name|dst
operator|-
name|buffer
operator|)
argument_list|,
comment|/*allocStrRep*/
literal|1
argument_list|,
comment|/*inHeap*/
literal|1
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
name|start
argument_list|,
name|numChars
argument_list|,
comment|/*allocStrRep*/
literal|1
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
name|start
index|[
name|numChars
index|]
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|maxDepth
operator|=
name|TclMax
argument_list|(
operator|(
name|numParts
operator|+
literal|1
operator|)
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
block|}
name|numParts
operator|++
expr_stmt|;
block|}
comment|/*      * End of the quoted string: src points at termChar or '\0'. If      * necessary, concatenate the string_part objects on the stack.      */
if|if
condition|(
operator|(
name|src
operator|==
name|lastChar
operator|)
operator|&&
operator|(
name|termChar
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"missing %c"
argument_list|,
name|termChar
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
block|{
name|src
operator|++
expr_stmt|;
comment|/* advance over termChar */
block|}
if|if
condition|(
name|numParts
operator|==
literal|0
condition|)
block|{
comment|/* 	 * The quoted string was empty. Push an empty string object. 	 */
name|int
name|objIndex
init|=
name|TclObjIndexForString
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|,
comment|/*allocStrRep*/
literal|0
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
decl_stmt|;
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * Emit any needed concat instructions. 	 */
while|while
condition|(
name|numParts
operator|>
literal|255
condition|)
block|{
name|TclEmitInstUInt1
argument_list|(
name|INST_CONCAT1
argument_list|,
literal|255
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|numParts
operator|-=
literal|254
expr_stmt|;
comment|/* concat pushes 1 obj, the result */
block|}
if|if
condition|(
name|numParts
operator|>
literal|1
condition|)
block|{
name|TclEmitInstUInt1
argument_list|(
name|INST_CONCAT1
argument_list|,
name|numParts
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
block|}
name|done
label|:
if|if
condition|(
name|simpleWord
condition|)
block|{
name|envPtr
operator|->
name|wordIsSimple
operator|=
literal|1
expr_stmt|;
name|envPtr
operator|->
name|numSimpleWordChars
operator|=
operator|(
name|src
operator|-
name|string
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|envPtr
operator|->
name|wordIsSimple
operator|=
literal|0
expr_stmt|;
name|envPtr
operator|->
name|numSimpleWordChars
operator|=
literal|0
expr_stmt|;
block|}
name|envPtr
operator|->
name|termOffset
operator|=
operator|(
name|src
operator|-
name|string
operator|)
expr_stmt|;
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
name|envPtr
operator|->
name|pushSimpleWords
operator|=
name|savePushSimpleWords
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * CompileBraces --  *  *	This procedure compiles characters between matching curly braces.  *  *	Ordinarily, callers set envPtr->pushSimpleWords to 1 and  *	CompileBraces always emits a push instruction to compute the word on  *	the Tcl evaluation stack at execution time. However, if a caller  *	sets envPtr->pushSimpleWords to 0, CompileBraces will _not_ compile  *	"simple" words: words that are just a sequence of characters without  *	backslash-newlines. It will leave their compilation up to the  *	caller.  *  *	As an important special case, if the word is simple, this procedure  *	sets envPtr->wordIsSimple to 1 and envPtr->numSimpleWordChars to the  *	number of characters in the simple word. This allows the caller to  *	process these words specially.  *  * Results:  *	The return value is a standard Tcl result, which is TCL_OK unless  *	there was an error while parsing string. If an error occurs then  *	the interpreter's result contains a standard error message.  *  *	envPtr->termOffset is filled in with the offset of the character in  *	"string" just after the last one successfully processed. This is  *	usually the character just after the matching close-brace.  *  *	envPtr->wordIsSimple is set 1 if the word is simple: just a  *	sequence of characters without backslash-newlines. If so, the word's  *	characters are the envPtr->numSimpleWordChars characters starting   *	at string.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to evaluate the word. This is not changed if  *	the word is simple and envPtr->pushSimpleWords was 0 (false).  *  * Side effects:  *	Instructions are added to envPtr to push the braced string  *	at runtime.  *  *--------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CompileBraces
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|lastChar
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for nested command 				  * evaluations and error messages. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Character just after opening bracket. */
name|char
modifier|*
name|lastChar
decl_stmt|;
comment|/* Pointer to terminating character of 				  * string. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same  				  * values passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds the resulting instructions. */
block|{
specifier|register
name|char
modifier|*
name|src
init|=
name|string
decl_stmt|;
comment|/* Points to current source char. */
specifier|register
name|char
name|c
decl_stmt|;
comment|/* The current char. */
name|int
name|simpleWord
init|=
literal|0
decl_stmt|;
comment|/* Set 1 if a simple braced string word. */
name|int
name|level
init|=
literal|1
decl_stmt|;
comment|/* {} nesting level. Initially 1 since { 				  * was parsed before we were called. */
name|int
name|hasBackslashNewline
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if '\' found. */
name|char
modifier|*
name|last
decl_stmt|;
comment|/* Points just before terminating '}'. */
name|int
name|numChars
decl_stmt|;
comment|/* Number of chars in braced string. */
name|char
name|savedChar
decl_stmt|;
comment|/* Holds the character from string 				  * termporarily replaced by a null  				  * char during braced string processing. */
name|int
name|objIndex
decl_stmt|;
comment|/* The object array index for a pushed 				  * object holding a braced string. */
name|int
name|numRead
decl_stmt|;
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
comment|/*      * Check for any backslash-newlines, since we must treat      * backslash-newlines specially (they must be replaced by spaces).      */
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
operator|*
name|src
expr_stmt|;
if|if
condition|(
name|src
operator|==
name|lastChar
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"missing close-brace"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
operator|!=
name|TCL_NORMAL
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
block|{
name|level
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
block|{
operator|--
name|level
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
name|src
operator|++
expr_stmt|;
name|last
operator|=
operator|(
name|src
operator|-
literal|2
operator|)
expr_stmt|;
comment|/* i.e. point just before 				       * terminating } */
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|src
operator|+
literal|1
operator|)
operator|==
literal|'\n'
condition|)
block|{
name|hasBackslashNewline
operator|=
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|Tcl_Backslash
argument_list|(
name|src
argument_list|,
operator|&
name|numRead
argument_list|)
expr_stmt|;
name|src
operator|+=
name|numRead
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|src
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hasBackslashNewline
condition|)
block|{
comment|/* 	 * The braced word is "simple": just a sequence of characters 	 * without backslash-newlines. Just return if we are not to compile 	 * simple words. 	 */
name|simpleWord
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|envPtr
operator|->
name|pushSimpleWords
condition|)
block|{
name|envPtr
operator|->
name|wordIsSimple
operator|=
literal|1
expr_stmt|;
name|envPtr
operator|->
name|numSimpleWordChars
operator|=
operator|(
name|src
operator|-
name|string
operator|-
literal|1
operator|)
expr_stmt|;
name|envPtr
operator|->
name|termOffset
operator|=
operator|(
name|src
operator|-
name|string
operator|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
block|}
comment|/*      * Create and push a string object for the braced string. This starts at      * "string" and ends just after "last" (which points to the final      * character before the terminating '}'). If backslash-newlines were      * found, we copy characters one at a time into a heap-allocated buffer      * and do backslash-newline substitutions.      */
name|numChars
operator|=
operator|(
name|last
operator|-
name|string
operator|+
literal|1
operator|)
expr_stmt|;
name|savedChar
operator|=
name|string
index|[
name|numChars
index|]
expr_stmt|;
name|string
index|[
name|numChars
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|numChars
operator|>
literal|0
operator|)
operator|&&
operator|(
name|hasBackslashNewline
operator|)
condition|)
block|{
name|char
modifier|*
name|buffer
init|=
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|numChars
operator|+
literal|1
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|dst
init|=
name|buffer
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|string
decl_stmt|;
while|while
condition|(
name|p
operator|<=
name|last
condition|)
block|{
name|c
operator|=
operator|*
name|dst
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
name|dst
index|[
operator|-
literal|1
index|]
operator|=
name|Tcl_Backslash
argument_list|(
name|p
operator|-
literal|1
argument_list|,
operator|&
name|numRead
argument_list|)
expr_stmt|;
name|p
operator|+=
name|numRead
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|Tcl_Backslash
argument_list|(
name|p
operator|-
literal|1
argument_list|,
operator|&
name|numRead
argument_list|)
expr_stmt|;
while|while
condition|(
name|numRead
operator|>
literal|1
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|numRead
operator|--
expr_stmt|;
block|}
block|}
block|}
block|}
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
name|buffer
argument_list|,
operator|(
name|dst
operator|-
name|buffer
operator|)
argument_list|,
comment|/*allocStrRep*/
literal|1
argument_list|,
comment|/*inHeap*/
literal|1
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
name|string
argument_list|,
name|numChars
argument_list|,
comment|/*allocStrRep*/
literal|1
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
name|string
index|[
name|numChars
index|]
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|simpleWord
condition|)
block|{
name|envPtr
operator|->
name|wordIsSimple
operator|=
literal|1
expr_stmt|;
name|envPtr
operator|->
name|numSimpleWordChars
operator|=
operator|(
name|src
operator|-
name|string
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|envPtr
operator|->
name|wordIsSimple
operator|=
literal|0
expr_stmt|;
name|envPtr
operator|->
name|numSimpleWordChars
operator|=
literal|0
expr_stmt|;
block|}
name|envPtr
operator|->
name|termOffset
operator|=
operator|(
name|src
operator|-
name|string
operator|)
expr_stmt|;
name|envPtr
operator|->
name|maxStackDepth
operator|=
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCompileDollarVar --  *  *	Given a string starting with a $ sign, parse a variable name  *	and compile instructions to push its value. If the variable  *	reference is just a '$' (i.e. the '$' isn't followed by anything  *	that could possibly be a variable name), just push a string object  *	containing '$'.  *  * Results:  *	The return value is a standard Tcl result. If an error occurs  *	then an error message is left in the interpreter's result.  *  *	envPtr->termOffset is filled in with the offset of the character in  *	"string" just after the last one in the variable reference.  *  *	envPtr->wordIsSimple is set 0 (false) because the word is not  *	simple: it is not just a sequence of characters without backslashes.  *	For the same reason, envPtr->numSimpleWordChars is set 0.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the string's commands.  *  * Side effects:  *	Instructions are added to envPtr to look up the variable and  *	push its value at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclCompileDollarVar
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|lastChar
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for nested command 				  * evaluations and error messages. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* First char (i.e. $) of var reference. */
name|char
modifier|*
name|lastChar
decl_stmt|;
comment|/* Pointer to terminating character of 				  * string. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same 				  * values passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds the resulting instructions. */
block|{
specifier|register
name|char
modifier|*
name|src
init|=
name|string
decl_stmt|;
comment|/* Points to current source char. */
specifier|register
name|char
name|c
decl_stmt|;
comment|/* The current char. */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Start of 1st part of variable name. */
name|int
name|nameChars
decl_stmt|;
comment|/* Count of chars in name. */
name|int
name|nameHasNsSeparators
init|=
literal|0
decl_stmt|;
comment|/* Set 1 if name contains "::"s. */
name|char
name|savedChar
decl_stmt|;
comment|/* Holds the character from string 				  * termporarily replaced by a null  				  * char during name processing. */
name|int
name|objIndex
decl_stmt|;
comment|/* The object array index for a pushed 				  * object holding a name part. */
name|int
name|isArrayRef
init|=
literal|0
decl_stmt|;
comment|/* 1 if reference to array element. */
name|int
name|localIndex
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Frame index of local if found.  */
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				  * to push the variable. */
name|int
name|savePushSimpleWords
init|=
name|envPtr
operator|->
name|pushSimpleWords
decl_stmt|;
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
comment|/*      * var_reference: '$' '{' braced_name '}' |      *                '$' name ['(' index_string ')']      *      * There are three cases:      * 1. The $ sign is followed by an open curly brace. Then the variable      *    name is everything up to the next close curly brace, and the      *    variable is a scalar variable.      * 2. The $ sign is not followed by an open curly brace. Then the      *    variable name is everything up to the next character that isn't      *    a letter, digit, underscore, or a "::" namespace separator. If the      *    following character is an open parenthesis, then the information      *    between parentheses is the array element name, which can include      *    any of the substitutions permissible between quotes.      * 3. The $ sign is followed by something that isn't a letter, digit,      *    underscore, or a "::" namespace separator: in this case,      *    there is no variable name, and "$" is pushed.      */
name|src
operator|++
expr_stmt|;
comment|/* advance over the '$'. */
comment|/*      * Collect the first part of the variable's name into "name" and      * determine if it is an array reference and if it contains any      * namespace separator (::'s).      */
if|if
condition|(
operator|*
name|src
operator|==
literal|'{'
condition|)
block|{
comment|/* 	 * A scalar name in braces. 	 */
name|char
modifier|*
name|p
decl_stmt|;
name|src
operator|++
expr_stmt|;
comment|/* advance over the '{'. */
name|name
operator|=
name|src
expr_stmt|;
name|c
operator|=
operator|*
name|src
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'}'
condition|)
block|{
if|if
condition|(
name|src
operator|==
name|lastChar
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"missing close-brace for variable name"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|src
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|src
expr_stmt|;
block|}
name|nameChars
operator|=
operator|(
name|src
operator|-
name|name
operator|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|name
init|;
name|p
operator|<
name|src
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|':'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|':'
operator|)
condition|)
block|{
name|nameHasNsSeparators
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|src
operator|++
expr_stmt|;
comment|/* advance over the '}'. */
block|}
else|else
block|{
comment|/* 	 * Scalar name or array reference not in braces. 	 */
name|name
operator|=
name|src
expr_stmt|;
name|c
operator|=
operator|*
name|src
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
name|UCHAR
argument_list|(
name|c
argument_list|)
argument_list|)
operator|||
operator|(
name|c
operator|==
literal|'_'
operator|)
operator|||
operator|(
name|c
operator|==
literal|':'
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|src
operator|+
literal|1
operator|)
operator|==
literal|':'
condition|)
block|{
name|nameHasNsSeparators
operator|=
literal|1
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
comment|/* skip over the initial :: */
while|while
condition|(
operator|*
name|src
operator|==
literal|':'
condition|)
block|{
name|src
operator|++
expr_stmt|;
comment|/* skip over a subsequent : */
block|}
name|c
operator|=
operator|*
name|src
expr_stmt|;
block|}
else|else
block|{
break|break;
comment|/* : by itself */
block|}
block|}
else|else
block|{
name|src
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|src
expr_stmt|;
block|}
block|}
if|if
condition|(
name|src
operator|==
name|name
condition|)
block|{
comment|/* 	     * A '$' by itself, not a name reference. Push a "$" string. 	     */
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
literal|"$"
argument_list|,
literal|1
argument_list|,
comment|/*allocStrRep*/
literal|1
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|maxDepth
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|nameChars
operator|=
operator|(
name|src
operator|-
name|name
operator|)
expr_stmt|;
name|isArrayRef
operator|=
operator|(
name|c
operator|==
literal|'('
operator|)
expr_stmt|;
block|}
comment|/*      * Now emit instructions to load the variable. First either push the      * name of the scalar or array, or determine its index in the array of      * local variables in a procedure frame. Push the name if we are not      * compiling a procedure body or if the name has namespace      * qualifiers ("::"s).      */
if|if
condition|(
operator|!
name|isArrayRef
condition|)
block|{
comment|/* scalar reference */
if|if
condition|(
operator|(
name|envPtr
operator|->
name|procPtr
operator|==
name|NULL
operator|)
operator|||
name|nameHasNsSeparators
condition|)
block|{
name|savedChar
operator|=
name|name
index|[
name|nameChars
index|]
expr_stmt|;
comment|/* save char just after name */
name|name
index|[
name|nameChars
index|]
operator|=
literal|'\0'
expr_stmt|;
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
name|name
argument_list|,
name|nameChars
argument_list|,
comment|/*allocStrRep*/
literal|1
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|name
index|[
name|nameChars
index|]
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|TclEmitOpcode
argument_list|(
name|INST_LOAD_SCALAR_STK
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|maxDepth
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|localIndex
operator|=
name|LookupCompiledLocal
argument_list|(
name|name
argument_list|,
name|nameChars
argument_list|,
comment|/*createIfNew*/
literal|0
argument_list|,
comment|/*flagsIfCreated*/
literal|0
argument_list|,
name|envPtr
operator|->
name|procPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|localIndex
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|localIndex
operator|<=
literal|255
condition|)
block|{
name|TclEmitInstUInt1
argument_list|(
name|INST_LOAD_SCALAR1
argument_list|,
name|localIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TclEmitInstUInt4
argument_list|(
name|INST_LOAD_SCALAR4
argument_list|,
name|localIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
name|maxDepth
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|savedChar
operator|=
name|name
index|[
name|nameChars
index|]
expr_stmt|;
comment|/* save char after name */
name|name
index|[
name|nameChars
index|]
operator|=
literal|'\0'
expr_stmt|;
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
name|name
argument_list|,
name|nameChars
argument_list|,
comment|/*allocStrRep*/
literal|1
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|name
index|[
name|nameChars
index|]
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|TclEmitOpcode
argument_list|(
name|INST_LOAD_SCALAR_STK
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|maxDepth
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* array reference */
if|if
condition|(
operator|(
name|envPtr
operator|->
name|procPtr
operator|==
name|NULL
operator|)
operator|||
name|nameHasNsSeparators
condition|)
block|{
name|savedChar
operator|=
name|name
index|[
name|nameChars
index|]
expr_stmt|;
comment|/* save char after name */
name|name
index|[
name|nameChars
index|]
operator|=
literal|'\0'
expr_stmt|;
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
name|name
argument_list|,
name|nameChars
argument_list|,
comment|/*allocStrRep*/
literal|1
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|name
index|[
name|nameChars
index|]
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|maxDepth
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|localIndex
operator|=
name|LookupCompiledLocal
argument_list|(
name|name
argument_list|,
name|nameChars
argument_list|,
comment|/*createIfNew*/
literal|0
argument_list|,
comment|/*flagsIfCreated*/
literal|0
argument_list|,
name|envPtr
operator|->
name|procPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|localIndex
operator|<
literal|0
condition|)
block|{
name|savedChar
operator|=
name|name
index|[
name|nameChars
index|]
expr_stmt|;
comment|/* save char after name */
name|name
index|[
name|nameChars
index|]
operator|=
literal|'\0'
expr_stmt|;
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
name|name
argument_list|,
name|nameChars
argument_list|,
comment|/*allocStrRep*/
literal|1
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|name
index|[
name|nameChars
index|]
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|maxDepth
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * Parse and push the array element. Perform substitutions on it, 	 * just as is done for quoted strings. 	 */
name|src
operator|++
expr_stmt|;
comment|/* advance over the '(' */
name|envPtr
operator|->
name|pushSimpleWords
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|TclCompileQuotes
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
name|lastChar
argument_list|,
literal|')'
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
comment|/* advance beyond the terminating ) */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|char
name|msg
index|[
literal|200
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n    (parsing index for array \"%.*s\")"
argument_list|,
operator|(
name|nameChars
operator|>
literal|100
condition|?
literal|100
else|:
name|nameChars
operator|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|msg
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|+=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
comment|/* 	 * Now emit the appropriate load instruction for the array element. 	 */
if|if
condition|(
name|localIndex
operator|<
literal|0
condition|)
block|{
comment|/* a global or an unknown local */
name|TclEmitOpcode
argument_list|(
name|INST_LOAD_ARRAY_STK
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|localIndex
operator|<=
literal|255
condition|)
block|{
name|TclEmitInstUInt1
argument_list|(
name|INST_LOAD_ARRAY1
argument_list|,
name|localIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TclEmitInstUInt4
argument_list|(
name|INST_LOAD_ARRAY4
argument_list|,
name|localIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|done
label|:
name|envPtr
operator|->
name|termOffset
operator|=
operator|(
name|src
operator|-
name|string
operator|)
expr_stmt|;
name|envPtr
operator|->
name|wordIsSimple
operator|=
literal|0
expr_stmt|;
name|envPtr
operator|->
name|numSimpleWordChars
operator|=
literal|0
expr_stmt|;
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
name|envPtr
operator|->
name|pushSimpleWords
operator|=
name|savePushSimpleWords
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCompileBreakCmd --  *  *	Procedure called to compile the "break" command.  *  * Results:  *	The return value is a standard Tcl result, which is TCL_OK unless  *	there was an error while parsing string. If an error occurs then  *	the interpreter's result contains a standard error message.  *  *	envPtr->termOffset is filled in with the offset of the character in  *	"string" just after the last one successfully processed.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the command.  *  * Side effects:  *	Instructions are added to envPtr to evaluate the "break" command  *	at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclCompileBreakCmd
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|lastChar
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* The source string to compile. */
name|char
modifier|*
name|lastChar
decl_stmt|;
comment|/* Pointer to terminating character of 				 * string. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
specifier|register
name|char
modifier|*
name|src
init|=
name|string
decl_stmt|;
comment|/* Points to current source char. */
specifier|register
name|int
name|type
decl_stmt|;
comment|/* Current char's CHAR_TYPE type. */
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
comment|/*      * There should be no argument after the "break".      */
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|TCL_COMMAND_END
condition|)
block|{
name|AdvanceToNextWord
argument_list|(
name|src
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|TCL_COMMAND_END
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"wrong # args: should be \"break\""
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/*      * Emit a break instruction.      */
name|TclEmitOpcode
argument_list|(
name|INST_BREAK
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|done
label|:
name|envPtr
operator|->
name|termOffset
operator|=
operator|(
name|src
operator|-
name|string
operator|)
expr_stmt|;
name|envPtr
operator|->
name|maxStackDepth
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCompileCatchCmd --  *  *	Procedure called to compile the "catch" command.  *  * Results:  *	The return value is a standard Tcl result, which is TCL_OK if  *	compilation was successful. If an error occurs then the  *	interpreter's result contains a standard error message and TCL_ERROR  *	is returned. If compilation failed because the command is too  *	complex for TclCompileCatchCmd, TCL_OUT_LINE_COMPILE is returned  *	indicating that the catch command should be compiled "out of line"  *	by emitting code to invoke its command procedure at runtime.  *  *	envPtr->termOffset is filled in with the offset of the character in  *	"string" just after the last one successfully processed.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the command.  *  * Side effects:  *	Instructions are added to envPtr to evaluate the "catch" command  *	at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclCompileCatchCmd
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|lastChar
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* The source string to compile. */
name|char
modifier|*
name|lastChar
decl_stmt|;
comment|/* Pointer to terminating character of 				 * string. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
name|Proc
modifier|*
name|procPtr
init|=
name|envPtr
operator|->
name|procPtr
decl_stmt|;
comment|/* Points to structure describing procedure 				 * containing the catch cmd, else NULL. */
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute cmd. */
name|ArgInfo
name|argInfo
decl_stmt|;
comment|/* Structure holding information about the 				 * start and end of each argument word. */
name|int
name|range
init|=
operator|-
literal|1
decl_stmt|;
comment|/* If we compile the catch command, the 				 * index for its catch range record in the 				 * ExceptionRange array. -1 if we are not 				 * compiling the command. */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* If a var name appears for a scalar local 				 * to a procedure, this points to the name's 				 * 1st char and nameChars is its length. */
name|int
name|nameChars
decl_stmt|;
comment|/* Length of the variable name, if any. */
name|int
name|localIndex
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Index of the variable in the current 				 * procedure's array of local variables. 				 * Otherwise -1 if not in a procedure or 				 * the variable wasn't found. */
name|char
name|savedChar
decl_stmt|;
comment|/* Holds the character from string 				 * termporarily replaced by a null character 				 * during processing of words. */
name|JumpFixup
name|jumpFixup
decl_stmt|;
comment|/* Used to emit the jump after the "no 				 * errors" epilogue code. */
name|int
name|numWords
decl_stmt|,
name|objIndex
decl_stmt|,
name|jumpDist
decl_stmt|,
name|result
decl_stmt|;
name|char
modifier|*
name|bodyStart
decl_stmt|,
modifier|*
name|bodyEnd
decl_stmt|;
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|int
name|savePushSimpleWords
init|=
name|envPtr
operator|->
name|pushSimpleWords
decl_stmt|;
comment|/*      * Scan the words of the command and record the start and finish of      * each argument word.      */
name|InitArgInfo
argument_list|(
operator|&
name|argInfo
argument_list|)
expr_stmt|;
name|result
operator|=
name|CollectArgInfo
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
name|lastChar
argument_list|,
name|flags
argument_list|,
operator|&
name|argInfo
argument_list|)
expr_stmt|;
name|numWords
operator|=
name|argInfo
operator|.
name|numArgs
expr_stmt|;
comment|/* i.e., the # after the command name */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|numWords
operator|!=
literal|1
operator|)
operator|&&
operator|(
name|numWords
operator|!=
literal|2
operator|)
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"wrong # args: should be \"catch command ?varName?\""
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*      * If a variable was specified and the catch command is at global level      * (not in a procedure), don't compile it inline: the payoff is      * too small.      */
if|if
condition|(
operator|(
name|numWords
operator|==
literal|2
operator|)
operator|&&
operator|(
name|procPtr
operator|==
name|NULL
operator|)
condition|)
block|{
name|result
operator|=
name|TCL_OUT_LINE_COMPILE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*      * Make sure the variable name, if any, has no substitutions and just      * refers to a local scaler.      */
if|if
condition|(
name|numWords
operator|==
literal|2
condition|)
block|{
name|char
modifier|*
name|firstChar
init|=
name|argInfo
operator|.
name|startArray
index|[
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|lastChar
init|=
name|argInfo
operator|.
name|endArray
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|firstChar
operator|==
literal|'{'
condition|)
block|{
if|if
condition|(
operator|*
name|lastChar
operator|!=
literal|'}'
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"extra characters after close-brace"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|firstChar
operator|++
expr_stmt|;
name|lastChar
operator|--
expr_stmt|;
block|}
name|nameChars
operator|=
operator|(
name|lastChar
operator|-
name|firstChar
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|nameChars
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|firstChar
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|lastChar
condition|)
block|{
if|if
condition|(
name|CHAR_TYPE
argument_list|(
name|p
argument_list|,
name|lastChar
argument_list|)
operator|!=
name|TCL_NORMAL
condition|)
block|{
name|result
operator|=
name|TCL_OUT_LINE_COMPILE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
block|{
if|if
condition|(
operator|*
name|lastChar
operator|==
literal|')'
condition|)
block|{
comment|/* we have an array element */
name|result
operator|=
name|TCL_OUT_LINE_COMPILE
expr_stmt|;
goto|goto
name|done
goto|;
comment|/* only scalar loop vars for now */
block|}
block|}
name|p
operator|++
expr_stmt|;
block|}
block|}
name|name
operator|=
name|firstChar
expr_stmt|;
name|localIndex
operator|=
name|LookupCompiledLocal
argument_list|(
name|name
argument_list|,
name|nameChars
argument_list|,
comment|/*createIfNew*/
literal|1
argument_list|,
comment|/*flagsIfCreated*/
name|VAR_SCALAR
argument_list|,
name|procPtr
argument_list|)
expr_stmt|;
block|}
comment|/*      *==== At this point we believe we can compile the catch command ====      */
comment|/*      * Create and initialize a ExceptionRange record to hold information      * about this catch command.      */
name|envPtr
operator|->
name|excRangeDepth
operator|++
expr_stmt|;
name|envPtr
operator|->
name|maxExcRangeDepth
operator|=
name|TclMax
argument_list|(
name|envPtr
operator|->
name|excRangeDepth
argument_list|,
name|envPtr
operator|->
name|maxExcRangeDepth
argument_list|)
expr_stmt|;
name|range
operator|=
name|CreateExceptionRange
argument_list|(
name|CATCH_EXCEPTION_RANGE
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/*      * Emit the instruction to mark the start of the catch command.      */
name|TclEmitInstUInt4
argument_list|(
name|INST_BEGIN_CATCH4
argument_list|,
name|range
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/*      * Inline compile the catch's body word: the command it controls. Also      * register the body's starting PC offset and byte length in the      * ExceptionRange record.      */
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|codeOffset
operator|=
name|TclCurrCodeOffset
argument_list|()
expr_stmt|;
name|bodyStart
operator|=
name|argInfo
operator|.
name|startArray
index|[
literal|0
index|]
expr_stmt|;
name|bodyEnd
operator|=
name|argInfo
operator|.
name|endArray
index|[
literal|0
index|]
expr_stmt|;
name|savedChar
operator|=
operator|*
operator|(
name|bodyEnd
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* save char after body */
operator|*
operator|(
name|bodyEnd
operator|+
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|result
operator|=
name|CompileCmdWordInline
argument_list|(
name|interp
argument_list|,
name|bodyStart
argument_list|,
operator|(
name|bodyEnd
operator|+
literal|1
operator|)
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
operator|*
operator|(
name|bodyEnd
operator|+
literal|1
operator|)
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|char
name|msg
index|[
literal|60
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n    (\"catch\" body line %d)"
argument_list|,
name|interp
operator|->
name|errorLine
argument_list|)
expr_stmt|;
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|msg
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|TclMax
argument_list|(
name|envPtr
operator|->
name|maxStackDepth
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|numCodeBytes
operator|=
name|TclCurrCodeOffset
argument_list|()
operator|-
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|codeOffset
expr_stmt|;
comment|/*      * Now emit the "no errors" epilogue code for the catch. First, if a      * variable was specified, store the body's result into the      * variable; otherwise, just discard the body's result. Then push      * a "0" object as the catch command's "no error" TCL_OK result,      * and jump around the "error case" epilogue code.      */
if|if
condition|(
name|localIndex
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|localIndex
operator|<=
literal|255
condition|)
block|{
name|TclEmitInstUInt1
argument_list|(
name|INST_STORE_SCALAR1
argument_list|,
name|localIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TclEmitInstUInt4
argument_list|(
name|INST_STORE_SCALAR4
argument_list|,
name|localIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
block|}
name|TclEmitOpcode
argument_list|(
name|INST_POP
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* pop the result */
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
literal|"0"
argument_list|,
literal|1
argument_list|,
comment|/*allocStrRep*/
literal|0
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|objPtr
operator|=
name|envPtr
operator|->
name|objArrayPtr
index|[
name|objIndex
index|]
expr_stmt|;
name|Tcl_InvalidateStringRep
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|=
literal|0
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclIntType
expr_stmt|;
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxDepth
operator|==
literal|0
condition|)
block|{
name|maxDepth
operator|=
literal|1
expr_stmt|;
comment|/* since we just pushed one object */
block|}
name|TclEmitForwardJump
argument_list|(
name|envPtr
argument_list|,
name|TCL_UNCONDITIONAL_JUMP
argument_list|,
operator|&
name|jumpFixup
argument_list|)
expr_stmt|;
comment|/*      * Now emit the "error case" epilogue code. First, if a variable was      * specified, emit instructions to push the interpreter's object result      * and store it into the variable. Then emit an instruction to push the      * nonzero error result. Note that the initial PC offset here is the      * catch's error target.      */
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
if|if
condition|(
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|type
operator|!=
name|CATCH_EXCEPTION_RANGE
condition|)
block|{
name|panic
argument_list|(
literal|"TclCompileCatchCmd: bad body ExceptionRange type %d\n"
argument_list|,
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*TCL_COMPILE_DEBUG*/
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|catchOffset
operator|=
name|TclCurrCodeOffset
argument_list|()
expr_stmt|;
if|if
condition|(
name|localIndex
operator|!=
operator|-
literal|1
condition|)
block|{
name|TclEmitOpcode
argument_list|(
name|INST_PUSH_RESULT
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|localIndex
operator|<=
literal|255
condition|)
block|{
name|TclEmitInstUInt1
argument_list|(
name|INST_STORE_SCALAR1
argument_list|,
name|localIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TclEmitInstUInt4
argument_list|(
name|INST_STORE_SCALAR4
argument_list|,
name|localIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
name|TclEmitOpcode
argument_list|(
name|INST_POP
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* pop the result */
block|}
name|TclEmitOpcode
argument_list|(
name|INST_PUSH_RETURN_CODE
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/*      * Now that we know the target of the jump after the "no errors"      * epilogue, update it with the correct distance. This is less      * than 127 bytes.      */
name|jumpDist
operator|=
operator|(
name|TclCurrCodeOffset
argument_list|()
operator|-
name|jumpFixup
operator|.
name|codeOffset
operator|)
expr_stmt|;
if|if
condition|(
name|TclFixupForwardJump
argument_list|(
name|envPtr
argument_list|,
operator|&
name|jumpFixup
argument_list|,
name|jumpDist
argument_list|,
literal|127
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"TclCompileCatchCmd: bad jump distance %d\n"
argument_list|,
name|jumpDist
argument_list|)
expr_stmt|;
block|}
comment|/*      * Emit the instruction to mark the end of the catch command.      */
name|TclEmitOpcode
argument_list|(
name|INST_END_CATCH
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|numWords
operator|==
literal|0
condition|)
block|{
name|envPtr
operator|->
name|termOffset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|envPtr
operator|->
name|termOffset
operator|=
operator|(
name|argInfo
operator|.
name|endArray
index|[
name|numWords
operator|-
literal|1
index|]
operator|+
literal|1
operator|-
name|string
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|range
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* we compiled the catch command */
name|envPtr
operator|->
name|excRangeDepth
operator|--
expr_stmt|;
block|}
name|envPtr
operator|->
name|pushSimpleWords
operator|=
name|savePushSimpleWords
expr_stmt|;
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
name|FreeArgInfo
argument_list|(
operator|&
name|argInfo
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCompileContinueCmd --  *  *	Procedure called to compile the "continue" command.  *  * Results:  *	The return value is a standard Tcl result, which is TCL_OK unless  *	there was an error while parsing string. If an error occurs then  *	the interpreter's result contains a standard error message.  *  *	envPtr->termOffset is filled in with the offset of the character in  *	"string" just after the last one successfully processed.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the command.  *  * Side effects:  *	Instructions are added to envPtr to evaluate the "continue" command  *	at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclCompileContinueCmd
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|lastChar
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* The source string to compile. */
name|char
modifier|*
name|lastChar
decl_stmt|;
comment|/* Pointer to terminating character of 				 * string. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
specifier|register
name|char
modifier|*
name|src
init|=
name|string
decl_stmt|;
comment|/* Points to current source char. */
specifier|register
name|int
name|type
decl_stmt|;
comment|/* Current char's CHAR_TYPE type. */
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
comment|/*      * There should be no argument after the "continue".      */
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|TCL_COMMAND_END
condition|)
block|{
name|AdvanceToNextWord
argument_list|(
name|src
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|TCL_COMMAND_END
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"wrong # args: should be \"continue\""
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/*      * Emit a continue instruction.      */
name|TclEmitOpcode
argument_list|(
name|INST_CONTINUE
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|done
label|:
name|envPtr
operator|->
name|termOffset
operator|=
operator|(
name|src
operator|-
name|string
operator|)
expr_stmt|;
name|envPtr
operator|->
name|maxStackDepth
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCompileExprCmd --  *  *	Procedure called to compile the "expr" command.  *  * Results:  *	The return value is a standard Tcl result, which is TCL_OK  *	unless there was an error while parsing string. If an error occurs  *	then the interpreter's result contains a standard error message.  *  *	envPtr->termOffset is filled in with the offset of the character in  *	"string" just after the last one successfully processed.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the "expr" command.  *  * Side effects:  *	Instructions are added to envPtr to evaluate the "expr" command  *	at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclCompileExprCmd
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|lastChar
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* The source string to compile. */
name|char
modifier|*
name|lastChar
decl_stmt|;
comment|/* Pointer to terminating character of 				 * string. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute cmd. */
name|ArgInfo
name|argInfo
decl_stmt|;
comment|/* Structure holding information about the 				 * start and end of each argument word. */
name|Tcl_DString
name|buffer
decl_stmt|;
comment|/* Holds the concatenated expr command 				 * argument words. */
name|int
name|firstWord
decl_stmt|;
comment|/* 1 if processing the first word; 0 if 				 * processing subsequent words. */
name|char
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|;
comment|/* Points to the first and last significant 				 * chars of the concatenated expression. */
name|int
name|inlineCode
decl_stmt|;
comment|/* 1 if inline "optimistic" code is 				 * emitted for the expression; else 0. */
name|int
name|range
init|=
operator|-
literal|1
decl_stmt|;
comment|/* If we inline compile the concatenated 				 * expression, the index for its catch range 				 * record in the ExceptionRange array. 				 * Initialized to avoid compile warning. */
name|JumpFixup
name|jumpFixup
decl_stmt|;
comment|/* Used to emit the "success" jump after 				 * the inline concat. expression's code. */
name|char
name|savedChar
decl_stmt|;
comment|/* Holds the character termporarily replaced 				 * by a null character during compilation 				 * of the concatenated expression. */
name|int
name|numWords
decl_stmt|,
name|objIndex
decl_stmt|,
name|i
decl_stmt|,
name|result
decl_stmt|;
name|char
modifier|*
name|wordStart
decl_stmt|,
modifier|*
name|wordEnd
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|savePushSimpleWords
init|=
name|envPtr
operator|->
name|pushSimpleWords
decl_stmt|;
name|int
name|saveExprIsJustVarRef
init|=
name|envPtr
operator|->
name|exprIsJustVarRef
decl_stmt|;
comment|/*      * Scan the words of the command and record the start and finish of      * each argument word.      */
name|InitArgInfo
argument_list|(
operator|&
name|argInfo
argument_list|)
expr_stmt|;
name|result
operator|=
name|CollectArgInfo
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
name|lastChar
argument_list|,
name|flags
argument_list|,
operator|&
name|argInfo
argument_list|)
expr_stmt|;
name|numWords
operator|=
name|argInfo
operator|.
name|numArgs
expr_stmt|;
comment|/* i.e., the # after the command name */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|numWords
operator|==
literal|0
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"wrong # args: should be \"expr arg ?arg ...?\""
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*      * If there is a single argument word and it is enclosed in {}s, we may      * strip them off and safely compile the expr command into an inline      * sequence of instructions using TclCompileExpr. We know these      * instructions will have the right Tcl7.x expression semantics.      *      * Otherwise, if the word is not enclosed in {}s, or there are multiple      * words, we may need to call the expr command (Tcl_ExprObjCmd) at      * runtime. This recompiles the expression each time (typically) and so      * is slow. However, there are some circumstances where we can still      * compile inline instructions "optimistically" and check, during their      * execution, for double substitutions (these appear as nonnumeric      * operands). We check for any backslash or command substitutions. If      * none appear, and only variable substitutions are found, we generate      * inline instructions. If there is a compilation error, we must emit      * instructions that return the error at runtime, since this is when      * scripts in Tcl7.x would "see" the error.      *      * For now, if there are multiple words, or the single argument word is      * not in {}s, we concatenate the argument words and strip off any      * enclosing {}s or ""s. We call the expr command at runtime if      * either command or backslash substitutions appear (but not if      * only variable substitutions appear).      */
if|if
condition|(
name|numWords
operator|==
literal|1
condition|)
block|{
name|wordStart
operator|=
name|argInfo
operator|.
name|startArray
index|[
literal|0
index|]
expr_stmt|;
comment|/* start of 1st arg word */
name|wordEnd
operator|=
name|argInfo
operator|.
name|endArray
index|[
literal|0
index|]
expr_stmt|;
comment|/* last char of 1st arg word */
if|if
condition|(
operator|(
operator|*
name|wordStart
operator|==
literal|'{'
operator|)
operator|&&
operator|(
operator|*
name|wordEnd
operator|==
literal|'}'
operator|)
condition|)
block|{
comment|/* 	     * Simple case: a single argument word in {}'s.  	     */
operator|*
name|wordEnd
operator|=
literal|'\0'
expr_stmt|;
comment|/* temporarily replace the '}' by a null */
name|result
operator|=
name|TclCompileExpr
argument_list|(
name|interp
argument_list|,
operator|(
name|wordStart
operator|+
literal|1
operator|)
argument_list|,
name|wordEnd
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
operator|*
name|wordEnd
operator|=
literal|'}'
expr_stmt|;
comment|/* restore the '}' */
name|envPtr
operator|->
name|termOffset
operator|=
operator|(
name|wordEnd
operator|+
literal|1
operator|)
operator|-
name|string
expr_stmt|;
name|envPtr
operator|->
name|pushSimpleWords
operator|=
name|savePushSimpleWords
expr_stmt|;
name|FreeArgInfo
argument_list|(
operator|&
name|argInfo
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
comment|/*      * There are multiple words or no braces around the single word.      * Concatenate the expression's argument words while stripping off      * any enclosing {}s or ""s.      */
name|Tcl_DStringInit
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|firstWord
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numWords
condition|;
name|i
operator|++
control|)
block|{
name|wordStart
operator|=
name|argInfo
operator|.
name|startArray
index|[
name|i
index|]
expr_stmt|;
name|wordEnd
operator|=
name|argInfo
operator|.
name|endArray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|wordStart
operator|==
literal|'{'
operator|)
operator|&&
operator|(
operator|*
name|wordEnd
operator|==
literal|'}'
operator|)
operator|)
operator|||
operator|(
operator|(
operator|*
name|wordStart
operator|==
literal|'"'
operator|)
operator|&&
operator|(
operator|*
name|wordEnd
operator|==
literal|'"'
operator|)
operator|)
condition|)
block|{
name|wordStart
operator|++
expr_stmt|;
name|wordEnd
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|firstWord
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|buffer
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|firstWord
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wordEnd
operator|>=
name|wordStart
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|buffer
argument_list|,
name|wordStart
argument_list|,
operator|(
name|wordEnd
operator|-
name|wordStart
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Scan the concatenated expression's characters looking for any      * '['s or (for now) '\'s. If any are found, just call the expr cmd      * at runtime.      */
name|inlineCode
operator|=
literal|1
expr_stmt|;
name|first
operator|=
name|Tcl_DStringValue
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|last
operator|=
name|first
operator|+
operator|(
name|Tcl_DStringLength
argument_list|(
operator|&
name|buffer
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|first
init|;
name|p
operator|<=
name|last
condition|;
name|p
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'['
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\\'
operator|)
condition|)
block|{
name|inlineCode
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|inlineCode
condition|)
block|{
comment|/* 	 * Inline compile the concatenated expression inside a "catch" 	 * so that a runtime error will back off to a (slow) call on expr. 	 */
name|int
name|startCodeOffset
init|=
operator|(
name|envPtr
operator|->
name|codeNext
operator|-
name|envPtr
operator|->
name|codeStart
operator|)
decl_stmt|;
name|int
name|startRangeNext
init|=
name|envPtr
operator|->
name|excRangeArrayNext
decl_stmt|;
comment|/* 	 * Create a ExceptionRange record to hold information about the 	 * "catch" range for the expression's inline code. Also emit the 	 * instruction to mark the start of the range. 	 */
name|envPtr
operator|->
name|excRangeDepth
operator|++
expr_stmt|;
name|envPtr
operator|->
name|maxExcRangeDepth
operator|=
name|TclMax
argument_list|(
name|envPtr
operator|->
name|excRangeDepth
argument_list|,
name|envPtr
operator|->
name|maxExcRangeDepth
argument_list|)
expr_stmt|;
name|range
operator|=
name|CreateExceptionRange
argument_list|(
name|CATCH_EXCEPTION_RANGE
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|TclEmitInstUInt4
argument_list|(
name|INST_BEGIN_CATCH4
argument_list|,
name|range
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* 	 * Inline compile the concatenated expression. 	 */
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|codeOffset
operator|=
name|TclCurrCodeOffset
argument_list|()
expr_stmt|;
name|savedChar
operator|=
operator|*
operator|(
name|last
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
name|last
operator|+
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* replace term. char with null */
name|result
operator|=
name|TclCompileExpr
argument_list|(
name|interp
argument_list|,
name|first
argument_list|,
name|last
operator|+
literal|1
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
operator|*
operator|(
name|last
operator|+
literal|1
operator|)
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|numCodeBytes
operator|=
name|TclCurrCodeOffset
argument_list|()
operator|-
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|codeOffset
expr_stmt|;
if|if
condition|(
operator|(
name|envPtr
operator|->
name|exprIsJustVarRef
operator|)
operator|||
operator|(
name|result
operator|!=
name|TCL_OK
operator|)
condition|)
block|{
comment|/* 	     * We must call the expr command at runtime since the expression 	     * consisted of just a single variable reference (and a second 	     * round of substitutions might be needed) or there was a 	     * compilation error. Delete the inline code by backing up the 	     * code pc and catch index. Note that if there was a compilation 	     * error, we can't report the error yet since the expression 	     * might be valid after the second round of substitutions. 	     */
name|envPtr
operator|->
name|codeNext
operator|=
operator|(
name|envPtr
operator|->
name|codeStart
operator|+
name|startCodeOffset
operator|)
expr_stmt|;
name|envPtr
operator|->
name|excRangeArrayNext
operator|=
name|startRangeNext
expr_stmt|;
name|inlineCode
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|TclEmitOpcode
argument_list|(
name|INST_END_CATCH
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* for ok case */
name|TclEmitForwardJump
argument_list|(
name|envPtr
argument_list|,
name|TCL_UNCONDITIONAL_JUMP
argument_list|,
operator|&
name|jumpFixup
argument_list|)
expr_stmt|;
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|catchOffset
operator|=
name|TclCurrCodeOffset
argument_list|()
expr_stmt|;
name|TclEmitOpcode
argument_list|(
name|INST_END_CATCH
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* for error case */
block|}
block|}
comment|/*      * Emit code for the (slow) call on the expr command at runtime.      * Generate code to concatenate the (already substituted once)      * expression words with a space between each word.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numWords
condition|;
name|i
operator|++
control|)
block|{
name|wordStart
operator|=
name|argInfo
operator|.
name|startArray
index|[
name|i
index|]
expr_stmt|;
name|wordEnd
operator|=
name|argInfo
operator|.
name|endArray
index|[
name|i
index|]
expr_stmt|;
name|savedChar
operator|=
operator|*
operator|(
name|wordEnd
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
name|wordEnd
operator|+
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* replace term. char with null */
name|envPtr
operator|->
name|pushSimpleWords
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|CompileWord
argument_list|(
name|interp
argument_list|,
name|wordStart
argument_list|,
name|wordEnd
operator|+
literal|1
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
operator|*
operator|(
name|wordEnd
operator|+
literal|1
operator|)
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|i
operator|!=
operator|(
name|numWords
operator|-
literal|1
operator|)
condition|)
block|{
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|,
comment|/*allocStrRep*/
literal|1
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|maxDepth
operator|=
name|TclMax
argument_list|(
operator|(
name|envPtr
operator|->
name|maxStackDepth
operator|+
literal|1
operator|)
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|maxDepth
operator|=
name|TclMax
argument_list|(
name|envPtr
operator|->
name|maxStackDepth
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
name|int
name|concatItems
init|=
literal|2
operator|*
name|numWords
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|concatItems
operator|>
literal|255
condition|)
block|{
name|TclEmitInstUInt1
argument_list|(
name|INST_CONCAT1
argument_list|,
literal|255
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|concatItems
operator|-=
literal|254
expr_stmt|;
comment|/* concat pushes 1 obj, the result */
block|}
if|if
condition|(
name|concatItems
operator|>
literal|1
condition|)
block|{
name|TclEmitInstUInt1
argument_list|(
name|INST_CONCAT1
argument_list|,
name|concatItems
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
name|TclEmitOpcode
argument_list|(
name|INST_EXPR_STK
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * If emitting inline code, update the target of the jump after      * that inline code.      */
if|if
condition|(
name|inlineCode
condition|)
block|{
name|int
name|jumpDist
init|=
operator|(
name|TclCurrCodeOffset
argument_list|()
operator|-
name|jumpFixup
operator|.
name|codeOffset
operator|)
decl_stmt|;
if|if
condition|(
name|TclFixupForwardJump
argument_list|(
name|envPtr
argument_list|,
operator|&
name|jumpFixup
argument_list|,
name|jumpDist
argument_list|,
literal|127
argument_list|)
condition|)
block|{
comment|/* 	     * Update the inline expression code's catch ExceptionRange 	     * target since it, being after the jump, also moved down. 	     */
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
if|if
condition|(
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|type
operator|!=
name|CATCH_EXCEPTION_RANGE
condition|)
block|{
name|panic
argument_list|(
literal|"TclCompileExprCmd: bad body ExceptionRange type %d\n"
argument_list|,
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TCL_COMPILE_DEBUG */
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|catchOffset
operator|+=
literal|3
expr_stmt|;
block|}
block|}
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|numWords
operator|==
literal|0
condition|)
block|{
name|envPtr
operator|->
name|termOffset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|envPtr
operator|->
name|termOffset
operator|=
operator|(
name|argInfo
operator|.
name|endArray
index|[
name|numWords
operator|-
literal|1
index|]
operator|+
literal|1
operator|-
name|string
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|range
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* we inline compiled the expr */
name|envPtr
operator|->
name|excRangeDepth
operator|--
expr_stmt|;
block|}
name|envPtr
operator|->
name|pushSimpleWords
operator|=
name|savePushSimpleWords
expr_stmt|;
name|envPtr
operator|->
name|exprIsJustVarRef
operator|=
name|saveExprIsJustVarRef
expr_stmt|;
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
name|FreeArgInfo
argument_list|(
operator|&
name|argInfo
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCompileForCmd --  *  *	Procedure called to compile the "for" command.  *  * Results:  *	The return value is a standard Tcl result, which is TCL_OK unless  *	there was an error while parsing string. If an error occurs then  *	the interpreter's result contains a standard error message.  *  *	envPtr->termOffset is filled in with the offset of the character in  *	"string" just after the last one successfully processed.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the command.  *  * Side effects:  *	Instructions are added to envPtr to evaluate the "for" command  *	at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclCompileForCmd
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|lastChar
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* The source string to compile. */
name|char
modifier|*
name|lastChar
decl_stmt|;
comment|/* Pointer to terminating character of 				 * string. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute cmd. */
name|ArgInfo
name|argInfo
decl_stmt|;
comment|/* Structure holding information about the 				 * start and end of each argument word. */
name|int
name|range1
decl_stmt|,
name|range2
decl_stmt|;
comment|/* Indexes in the ExceptionRange array of 				 * the loop ranges for this loop: one for 				 * its body and one for its "next" cmd. */
name|JumpFixup
name|jumpFalseFixup
decl_stmt|;
comment|/* Used to update or replace the ifFalse 				 * jump after the "for" test when its target 				 * PC is determined. */
name|int
name|jumpBackDist
decl_stmt|,
name|jumpBackOffset
decl_stmt|,
name|testCodeOffset
decl_stmt|,
name|jumpDist
decl_stmt|,
name|objIndex
decl_stmt|;
name|unsigned
name|char
modifier|*
name|jumpPc
decl_stmt|;
name|int
name|savePushSimpleWords
init|=
name|envPtr
operator|->
name|pushSimpleWords
decl_stmt|;
name|int
name|numWords
decl_stmt|,
name|result
decl_stmt|;
comment|/*      * Scan the words of the command and record the start and finish of      * each argument word.      */
name|InitArgInfo
argument_list|(
operator|&
name|argInfo
argument_list|)
expr_stmt|;
name|result
operator|=
name|CollectArgInfo
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
name|lastChar
argument_list|,
name|flags
argument_list|,
operator|&
name|argInfo
argument_list|)
expr_stmt|;
name|numWords
operator|=
name|argInfo
operator|.
name|numArgs
expr_stmt|;
comment|/* i.e., the # after the command name */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|numWords
operator|!=
literal|4
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"wrong # args: should be \"for start test next command\""
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*      * If the test expression is enclosed in quotes (""s), don't compile      * the for inline. As a result of Tcl's two level substitution      * semantics for expressions, the expression might have a constant      * value that results in the loop never executing, or executing forever.      * Consider "set x 0; for {} "$x> 5" {incr x} {}": the loop body       * should never be executed.      */
if|if
condition|(
operator|*
operator|(
name|argInfo
operator|.
name|startArray
index|[
literal|1
index|]
operator|)
operator|==
literal|'"'
condition|)
block|{
name|result
operator|=
name|TCL_OUT_LINE_COMPILE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*      * Create a ExceptionRange record for the for loop's body. This is used      * to implement break and continue commands inside the body.      * Then create a second ExceptionRange record for the "next" command in       * order to implement break (but not continue) inside it. The second,      * "next" ExceptionRange will always have a -1 continueOffset.      */
name|envPtr
operator|->
name|excRangeDepth
operator|++
expr_stmt|;
name|envPtr
operator|->
name|maxExcRangeDepth
operator|=
name|TclMax
argument_list|(
name|envPtr
operator|->
name|excRangeDepth
argument_list|,
name|envPtr
operator|->
name|maxExcRangeDepth
argument_list|)
expr_stmt|;
name|range1
operator|=
name|CreateExceptionRange
argument_list|(
name|LOOP_EXCEPTION_RANGE
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|range2
operator|=
name|CreateExceptionRange
argument_list|(
name|LOOP_EXCEPTION_RANGE
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/*      * Compile inline the next word: the initial command.      */
name|result
operator|=
name|CompileCmdWordInline
argument_list|(
name|interp
argument_list|,
name|argInfo
operator|.
name|startArray
index|[
literal|0
index|]
argument_list|,
operator|(
name|argInfo
operator|.
name|endArray
index|[
literal|0
index|]
operator|+
literal|1
operator|)
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
literal|"\n    (\"for\" initial command)"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
comment|/*      * Discard the start command's result.      */
name|TclEmitOpcode
argument_list|(
name|INST_POP
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/*      * Compile the next word: the test expression.      */
name|testCodeOffset
operator|=
name|TclCurrCodeOffset
argument_list|()
expr_stmt|;
name|envPtr
operator|->
name|pushSimpleWords
operator|=
literal|1
expr_stmt|;
comment|/* process words normally */
name|result
operator|=
name|CompileExprWord
argument_list|(
name|interp
argument_list|,
name|argInfo
operator|.
name|startArray
index|[
literal|1
index|]
argument_list|,
operator|(
name|argInfo
operator|.
name|endArray
index|[
literal|1
index|]
operator|+
literal|1
operator|)
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
literal|"\n    (\"for\" test expression)"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|TclMax
argument_list|(
name|envPtr
operator|->
name|maxStackDepth
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
comment|/*      * Emit the jump that terminates the for command if the test was      * false. We emit a one byte (relative) jump here, and replace it later      * with a four byte jump if the jump target is> 127 bytes away.      */
name|TclEmitForwardJump
argument_list|(
name|envPtr
argument_list|,
name|TCL_FALSE_JUMP
argument_list|,
operator|&
name|jumpFalseFixup
argument_list|)
expr_stmt|;
comment|/*      * Compile the loop body word inline. Also register the loop body's      * starting PC offset and byte length in the its ExceptionRange record.      */
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range1
index|]
operator|.
name|codeOffset
operator|=
name|TclCurrCodeOffset
argument_list|()
expr_stmt|;
name|result
operator|=
name|CompileCmdWordInline
argument_list|(
name|interp
argument_list|,
name|argInfo
operator|.
name|startArray
index|[
literal|3
index|]
argument_list|,
operator|(
name|argInfo
operator|.
name|endArray
index|[
literal|3
index|]
operator|+
literal|1
operator|)
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|char
name|msg
index|[
literal|60
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n    (\"for\" body line %d)"
argument_list|,
name|interp
operator|->
name|errorLine
argument_list|)
expr_stmt|;
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|msg
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|TclMax
argument_list|(
name|envPtr
operator|->
name|maxStackDepth
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range1
index|]
operator|.
name|numCodeBytes
operator|=
operator|(
name|TclCurrCodeOffset
argument_list|()
operator|-
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range1
index|]
operator|.
name|codeOffset
operator|)
expr_stmt|;
comment|/*      * Discard the loop body's result.      */
name|TclEmitOpcode
argument_list|(
name|INST_POP
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/*      * Finally, compile the "next" subcommand word inline.      */
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range1
index|]
operator|.
name|continueOffset
operator|=
name|TclCurrCodeOffset
argument_list|()
expr_stmt|;
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range2
index|]
operator|.
name|codeOffset
operator|=
name|TclCurrCodeOffset
argument_list|()
expr_stmt|;
name|result
operator|=
name|CompileCmdWordInline
argument_list|(
name|interp
argument_list|,
name|argInfo
operator|.
name|startArray
index|[
literal|2
index|]
argument_list|,
operator|(
name|argInfo
operator|.
name|endArray
index|[
literal|2
index|]
operator|+
literal|1
operator|)
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
literal|"\n    (\"for\" loop-end command)"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|TclMax
argument_list|(
name|envPtr
operator|->
name|maxStackDepth
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range2
index|]
operator|.
name|numCodeBytes
operator|=
name|TclCurrCodeOffset
argument_list|()
operator|-
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range2
index|]
operator|.
name|codeOffset
expr_stmt|;
comment|/*      * Discard the "next" subcommand's result.      */
name|TclEmitOpcode
argument_list|(
name|INST_POP
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/*      * Emit the unconditional jump back to the test at the top of the for      * loop. We generate a four byte jump if the distance to the test is      * greater than 120 bytes. This is conservative, and ensures that we      * won't have to replace this unconditional jump if we later need to      * replace the ifFalse jump with a four-byte jump.      */
name|jumpBackOffset
operator|=
name|TclCurrCodeOffset
argument_list|()
expr_stmt|;
name|jumpBackDist
operator|=
operator|(
name|jumpBackOffset
operator|-
name|testCodeOffset
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
if|if
condition|(
name|jumpBackDist
operator|>
name|MAX_JUMP_DIST
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nTclCompileForCmd: bad distance %u for unconditional jump\n"
argument_list|,
name|jumpBackDist
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"TclCompileForCmd: bad distance for unconditional jump"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*TCL_COMPILE_DEBUG*/
if|if
condition|(
name|jumpBackDist
operator|>
literal|120
condition|)
block|{
name|TclEmitInstInt4
argument_list|(
name|INST_JUMP4
argument_list|,
comment|/*offset*/
operator|-
name|jumpBackDist
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TclEmitInstInt1
argument_list|(
name|INST_JUMP1
argument_list|,
comment|/*offset*/
operator|-
name|jumpBackDist
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * Now that we know the target of the jumpFalse after the test, update      * it with the correct distance. If the distance is too great (more      * than 127 bytes), replace that jump with a four byte instruction and      * move the instructions after the jump down.      */
name|jumpDist
operator|=
operator|(
name|TclCurrCodeOffset
argument_list|()
operator|-
name|jumpFalseFixup
operator|.
name|codeOffset
operator|)
expr_stmt|;
if|if
condition|(
name|TclFixupForwardJump
argument_list|(
name|envPtr
argument_list|,
operator|&
name|jumpFalseFixup
argument_list|,
name|jumpDist
argument_list|,
literal|127
argument_list|)
condition|)
block|{
comment|/* 	 * Update the loop body's ExceptionRange record since it moved down: 	 * i.e., increment both its start and continue PC offsets. Also, 	 * update the "next" command's start PC offset in its ExceptionRange 	 * record since it also moved down. 	 */
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
if|if
condition|(
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range1
index|]
operator|.
name|type
operator|!=
name|LOOP_EXCEPTION_RANGE
condition|)
block|{
name|panic
argument_list|(
literal|"TclCompileForCmd: bad body ExceptionRange type %d\n"
argument_list|,
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range1
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TCL_COMPILE_DEBUG */
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range1
index|]
operator|.
name|codeOffset
operator|+=
literal|3
expr_stmt|;
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range1
index|]
operator|.
name|continueOffset
operator|+=
literal|3
expr_stmt|;
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range2
index|]
operator|.
name|codeOffset
operator|+=
literal|3
expr_stmt|;
comment|/* 	 * Update the distance for the unconditional jump back to the test 	 * at the top of the loop since it moved down 3 bytes too. 	 */
name|jumpBackOffset
operator|+=
literal|3
expr_stmt|;
name|jumpPc
operator|=
operator|(
name|envPtr
operator|->
name|codeStart
operator|+
name|jumpBackOffset
operator|)
expr_stmt|;
if|if
condition|(
name|jumpBackDist
operator|>
literal|120
condition|)
block|{
name|jumpBackDist
operator|+=
literal|3
expr_stmt|;
name|TclUpdateInstInt4AtPc
argument_list|(
name|INST_JUMP4
argument_list|,
comment|/*offset*/
operator|-
name|jumpBackDist
argument_list|,
name|jumpPc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|jumpBackDist
operator|+=
literal|3
expr_stmt|;
name|TclUpdateInstInt1AtPc
argument_list|(
name|INST_JUMP1
argument_list|,
comment|/*offset*/
operator|-
name|jumpBackDist
argument_list|,
name|jumpPc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * The current PC offset (after the loop's body and "next" subcommand)      * is the loop's break target.      */
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
if|if
condition|(
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range1
index|]
operator|.
name|type
operator|!=
name|LOOP_EXCEPTION_RANGE
condition|)
block|{
name|panic
argument_list|(
literal|"TclCompileForCmd: bad body ExceptionRange type %d\n"
argument_list|,
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range1
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TCL_COMPILE_DEBUG */
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range1
index|]
operator|.
name|breakOffset
operator|=
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range2
index|]
operator|.
name|breakOffset
operator|=
name|TclCurrCodeOffset
argument_list|()
expr_stmt|;
comment|/*      * Push an empty string object as the for command's result.      */
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|,
comment|/*allocStrRep*/
literal|0
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxDepth
operator|==
literal|0
condition|)
block|{
name|maxDepth
operator|=
literal|1
expr_stmt|;
comment|/* since we just pushed one object */
block|}
name|done
label|:
if|if
condition|(
name|numWords
operator|==
literal|0
condition|)
block|{
name|envPtr
operator|->
name|termOffset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|envPtr
operator|->
name|termOffset
operator|=
operator|(
name|argInfo
operator|.
name|endArray
index|[
name|numWords
operator|-
literal|1
index|]
operator|+
literal|1
operator|-
name|string
operator|)
expr_stmt|;
block|}
name|envPtr
operator|->
name|pushSimpleWords
operator|=
name|savePushSimpleWords
expr_stmt|;
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
name|envPtr
operator|->
name|excRangeDepth
operator|--
expr_stmt|;
name|FreeArgInfo
argument_list|(
operator|&
name|argInfo
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCompileForeachCmd --  *  *	Procedure called to compile the "foreach" command.  *  * Results:  *	The return value is a standard Tcl result, which is TCL_OK if  *	compilation was successful. If an error occurs then the  *	interpreter's result contains a standard error message and TCL_ERROR  *	is returned. If complation failed because the command is too complex  *	for TclCompileForeachCmd, TCL_OUT_LINE_COMPILE is returned  *	indicating that the foreach command should be compiled "out of line"  *	by emitting code to invoke its command procedure at runtime.  *  *	envPtr->termOffset is filled in with the offset of the character in  *	"string" just after the last one successfully processed.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the "while" command.  *  * Side effects:  *	Instructions are added to envPtr to evaluate the "foreach" command  *	at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclCompileForeachCmd
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|lastChar
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* The source string to compile. */
name|char
modifier|*
name|lastChar
decl_stmt|;
comment|/* Pointer to terminating character of 				 * string. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
name|Proc
modifier|*
name|procPtr
init|=
name|envPtr
operator|->
name|procPtr
decl_stmt|;
comment|/* Points to structure describing procedure 				 * containing foreach command, else NULL. */
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute cmd. */
name|ArgInfo
name|argInfo
decl_stmt|;
comment|/* Structure holding information about the 				 * start and end of each argument word. */
name|int
name|numLists
init|=
literal|0
decl_stmt|;
comment|/* Count of variable (and value) lists. */
name|int
name|range
decl_stmt|;
comment|/* Index in the ExceptionRange array of the 				 * ExceptionRange record for this loop. */
name|ForeachInfo
modifier|*
name|infoPtr
decl_stmt|;
comment|/* Points to the structure describing this 				 * foreach command. Stored in a AuxData 				 * record in the ByteCode. */
name|JumpFixup
name|jumpFalseFixup
decl_stmt|;
comment|/* Used to update or replace the ifFalse 				 * jump after test when its target PC is 				 * determined. */
name|char
name|savedChar
decl_stmt|;
comment|/* Holds the char from string termporarily 				 * replaced by a null character during 				 * processing of argument words. */
name|int
name|firstListTmp
init|=
operator|-
literal|1
decl_stmt|;
comment|/* If we decide to compile this foreach 				 * command, this is the index or "slot 				 * number" for the first temp var allocated 				 * in the proc frame that holds a pointer to 				 * a value list. Initialized to avoid a 				 * compiler warning. */
name|int
name|loopIterNumTmp
decl_stmt|;
comment|/* If we decide to compile this foreach 				 * command, the index for the temp var that 				 * holds the current iteration count.  */
name|char
modifier|*
name|varListStart
decl_stmt|,
modifier|*
name|varListEnd
decl_stmt|,
modifier|*
name|valueListStart
decl_stmt|,
modifier|*
name|bodyStart
decl_stmt|,
modifier|*
name|bodyEnd
decl_stmt|;
name|unsigned
name|char
modifier|*
name|jumpPc
decl_stmt|;
name|int
name|jumpDist
decl_stmt|,
name|jumpBackDist
decl_stmt|,
name|jumpBackOffset
decl_stmt|;
name|int
name|numWords
decl_stmt|,
name|numVars
decl_stmt|,
name|infoIndex
decl_stmt|,
name|tmpIndex
decl_stmt|,
name|objIndex
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|result
decl_stmt|;
name|int
name|savePushSimpleWords
init|=
name|envPtr
operator|->
name|pushSimpleWords
decl_stmt|;
comment|/*      * We parse the variable list argument words and create two arrays:      *    varcList[i] gives the number of variables in the i-th var list      *    varvList[i] points to an array of the names in the i-th var list      * These are initially allocated on the stack, and are allocated on      * the heap if necessary.      */
define|#
directive|define
name|STATIC_VAR_LIST_SIZE
value|4
name|int
name|varcListStaticSpace
index|[
name|STATIC_VAR_LIST_SIZE
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|varvListStaticSpace
index|[
name|STATIC_VAR_LIST_SIZE
index|]
decl_stmt|;
name|int
modifier|*
name|varcList
init|=
name|varcListStaticSpace
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|varvList
init|=
name|varvListStaticSpace
decl_stmt|;
comment|/*      * If the foreach command is at global level (not in a procedure),      * don't compile it inline: the payoff is too small.      */
if|if
condition|(
name|procPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_OUT_LINE_COMPILE
return|;
block|}
comment|/*      * Scan the words of the command and record the start and finish of      * each argument word.      */
name|InitArgInfo
argument_list|(
operator|&
name|argInfo
argument_list|)
expr_stmt|;
name|result
operator|=
name|CollectArgInfo
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
name|lastChar
argument_list|,
name|flags
argument_list|,
operator|&
name|argInfo
argument_list|)
expr_stmt|;
name|numWords
operator|=
name|argInfo
operator|.
name|numArgs
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|numWords
operator|<
literal|3
operator|)
operator|||
operator|(
name|numWords
operator|%
literal|2
operator|!=
literal|1
operator|)
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"wrong # args: should be \"foreach varList list ?varList list ...? command\""
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*      * Initialize the varcList and varvList arrays; allocate heap storage,      * if necessary, for them. Also make sure the variable names      * have no substitutions: that they're just "var" or "var(elem)"      */
name|numLists
operator|=
operator|(
name|numWords
operator|-
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|numLists
operator|>
name|STATIC_VAR_LIST_SIZE
condition|)
block|{
name|varcList
operator|=
operator|(
name|int
operator|*
operator|)
name|ckalloc
argument_list|(
name|numLists
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|varvList
operator|=
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
name|numLists
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numLists
condition|;
name|i
operator|++
control|)
block|{
name|varcList
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|varvList
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numLists
condition|;
name|i
operator|++
control|)
block|{
comment|/* 	 * Break each variable list into its component variables. If the 	 * lists is enclosed in {}s or ""s, strip them off first. 	 */
name|varListStart
operator|=
name|argInfo
operator|.
name|startArray
index|[
name|i
operator|*
literal|2
index|]
expr_stmt|;
name|varListEnd
operator|=
name|argInfo
operator|.
name|endArray
index|[
name|i
operator|*
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|varListStart
operator|==
literal|'{'
operator|)
operator|||
operator|(
operator|*
name|varListStart
operator|==
literal|'"'
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|varListEnd
operator|!=
literal|'}'
operator|)
operator|&&
operator|(
operator|*
name|varListEnd
operator|!=
literal|'"'
operator|)
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|varListStart
operator|==
literal|'"'
condition|)
block|{
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"extra characters after close-quote"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"extra characters after close-brace"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|varListStart
operator|++
expr_stmt|;
name|varListEnd
operator|--
expr_stmt|;
block|}
comment|/* 	 * NOTE: THIS NEEDS TO BE CONVERTED TO AN OBJECT LIST. 	 */
name|savedChar
operator|=
operator|*
operator|(
name|varListEnd
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* save char after var list */
operator|*
operator|(
name|varListEnd
operator|+
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|result
operator|=
name|Tcl_SplitList
argument_list|(
name|interp
argument_list|,
name|varListStart
argument_list|,
operator|&
name|varcList
index|[
name|i
index|]
argument_list|,
operator|&
name|varvList
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|*
operator|(
name|varListEnd
operator|+
literal|1
operator|)
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Check that each variable name has no substitutions and that 	 * it is a scalar name. 	 */
name|numVars
operator|=
name|varcList
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numVars
condition|;
name|j
operator|++
control|)
block|{
name|char
modifier|*
name|varName
init|=
name|varvList
index|[
name|i
index|]
index|[
name|j
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|varName
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|CHAR_TYPE
argument_list|(
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
operator|!=
name|TCL_NORMAL
condition|)
block|{
name|result
operator|=
name|TCL_OUT_LINE_COMPILE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
block|{
name|char
modifier|*
name|q
init|=
name|p
decl_stmt|;
do|do
block|{
name|q
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|q
operator|!=
literal|'\0'
condition|)
do|;
name|q
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|')'
condition|)
block|{
comment|/* we have an array element */
name|result
operator|=
name|TCL_OUT_LINE_COMPILE
expr_stmt|;
goto|goto
name|done
goto|;
comment|/* only scalar loop vars for now */
block|}
block|}
name|p
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/*      *==== At this point we believe we can compile the foreach command ====      */
comment|/*      * Create and initialize a ExceptionRange record to hold information      * about this loop. This is used to implement break and continue.      */
name|envPtr
operator|->
name|excRangeDepth
operator|++
expr_stmt|;
name|envPtr
operator|->
name|maxExcRangeDepth
operator|=
name|TclMax
argument_list|(
name|envPtr
operator|->
name|excRangeDepth
argument_list|,
name|envPtr
operator|->
name|maxExcRangeDepth
argument_list|)
expr_stmt|;
name|range
operator|=
name|CreateExceptionRange
argument_list|(
name|LOOP_EXCEPTION_RANGE
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/*      * Reserve (numLists + 1) temporary variables:      *    - numLists temps for each value list      *    - a temp for the "next value" index into each value list      * At this time we don't try to reuse temporaries; if there are two      * nonoverlapping foreach loops, they don't share any temps.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numLists
condition|;
name|i
operator|++
control|)
block|{
name|tmpIndex
operator|=
name|LookupCompiledLocal
argument_list|(
name|NULL
argument_list|,
comment|/*nameChars*/
literal|0
argument_list|,
comment|/*createIfNew*/
literal|1
argument_list|,
comment|/*flagsIfCreated*/
name|VAR_SCALAR
argument_list|,
name|procPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|firstListTmp
operator|=
name|tmpIndex
expr_stmt|;
block|}
block|}
name|loopIterNumTmp
operator|=
name|LookupCompiledLocal
argument_list|(
name|NULL
argument_list|,
comment|/*nameChars*/
literal|0
argument_list|,
comment|/*createIfNew*/
literal|1
argument_list|,
comment|/*flagsIfCreated*/
name|VAR_SCALAR
argument_list|,
name|procPtr
argument_list|)
expr_stmt|;
comment|/*      * Create and initialize the ForeachInfo and ForeachVarList data      * structures describing this command. Then create a AuxData record      * pointing to the ForeachInfo structure in the compilation environment.      */
name|infoPtr
operator|=
operator|(
name|ForeachInfo
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|ForeachInfo
argument_list|)
operator|+
operator|(
name|numLists
operator|*
sizeof|sizeof
argument_list|(
name|ForeachVarList
operator|*
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|infoPtr
operator|->
name|numLists
operator|=
name|numLists
expr_stmt|;
name|infoPtr
operator|->
name|firstListTmp
operator|=
name|firstListTmp
expr_stmt|;
name|infoPtr
operator|->
name|loopIterNumTmp
operator|=
name|loopIterNumTmp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numLists
condition|;
name|i
operator|++
control|)
block|{
name|ForeachVarList
modifier|*
name|varListPtr
decl_stmt|;
name|numVars
operator|=
name|varcList
index|[
name|i
index|]
expr_stmt|;
name|varListPtr
operator|=
operator|(
name|ForeachVarList
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|ForeachVarList
argument_list|)
operator|+
name|numVars
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|varListPtr
operator|->
name|numVars
operator|=
name|numVars
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numVars
condition|;
name|j
operator|++
control|)
block|{
name|char
modifier|*
name|varName
init|=
name|varvList
index|[
name|i
index|]
index|[
name|j
index|]
decl_stmt|;
name|int
name|nameChars
init|=
name|strlen
argument_list|(
name|varName
argument_list|)
decl_stmt|;
name|varListPtr
operator|->
name|varIndexes
index|[
name|j
index|]
operator|=
name|LookupCompiledLocal
argument_list|(
name|varName
argument_list|,
name|nameChars
argument_list|,
comment|/*createIfNew*/
literal|1
argument_list|,
comment|/*flagsIfCreated*/
name|VAR_SCALAR
argument_list|,
name|procPtr
argument_list|)
expr_stmt|;
block|}
name|infoPtr
operator|->
name|varLists
index|[
name|i
index|]
operator|=
name|varListPtr
expr_stmt|;
block|}
name|infoIndex
operator|=
name|TclCreateAuxData
argument_list|(
operator|(
name|ClientData
operator|)
name|infoPtr
argument_list|,
name|DupForeachInfo
argument_list|,
name|FreeForeachInfo
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/*      * Emit code to store each value list into the associated temporary.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numLists
condition|;
name|i
operator|++
control|)
block|{
name|valueListStart
operator|=
name|argInfo
operator|.
name|startArray
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|envPtr
operator|->
name|pushSimpleWords
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|CompileWord
argument_list|(
name|interp
argument_list|,
name|valueListStart
argument_list|,
name|lastChar
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|TclMax
argument_list|(
name|envPtr
operator|->
name|maxStackDepth
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
name|tmpIndex
operator|=
operator|(
name|firstListTmp
operator|+
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|tmpIndex
operator|<=
literal|255
condition|)
block|{
name|TclEmitInstUInt1
argument_list|(
name|INST_STORE_SCALAR1
argument_list|,
name|tmpIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TclEmitInstUInt4
argument_list|(
name|INST_STORE_SCALAR4
argument_list|,
name|tmpIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
name|TclEmitOpcode
argument_list|(
name|INST_POP
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* no longer need list on the stk */
block|}
comment|/*      * Emit the instruction to initialize the foreach loop's index temp var.      */
name|TclEmitInstUInt4
argument_list|(
name|INST_FOREACH_START4
argument_list|,
name|infoIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/*      * Emit the top of loop code that assigns each loop variable and checks      * whether to terminate the loop.      */
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|continueOffset
operator|=
name|TclCurrCodeOffset
argument_list|()
expr_stmt|;
name|TclEmitInstUInt4
argument_list|(
name|INST_FOREACH_STEP4
argument_list|,
name|infoIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/*      * Emit the ifFalse jump that terminates the foreach if all value lists      * are exhausted. We emit a one byte (relative) jump here, and replace      * it later with a four byte jump if the jump target is more than      * 127 bytes away.      */
name|TclEmitForwardJump
argument_list|(
name|envPtr
argument_list|,
name|TCL_FALSE_JUMP
argument_list|,
operator|&
name|jumpFalseFixup
argument_list|)
expr_stmt|;
comment|/*      * Compile the loop body word inline. Also register the loop body's      * starting PC offset and byte length in the ExceptionRange record.      */
name|bodyStart
operator|=
name|argInfo
operator|.
name|startArray
index|[
name|numWords
operator|-
literal|1
index|]
expr_stmt|;
name|bodyEnd
operator|=
name|argInfo
operator|.
name|endArray
index|[
name|numWords
operator|-
literal|1
index|]
expr_stmt|;
name|savedChar
operator|=
operator|*
operator|(
name|bodyEnd
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* save char after body */
operator|*
operator|(
name|bodyEnd
operator|+
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|codeOffset
operator|=
name|TclCurrCodeOffset
argument_list|()
expr_stmt|;
name|result
operator|=
name|CompileCmdWordInline
argument_list|(
name|interp
argument_list|,
name|bodyStart
argument_list|,
name|bodyEnd
operator|+
literal|1
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
operator|*
operator|(
name|bodyEnd
operator|+
literal|1
operator|)
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|char
name|msg
index|[
literal|60
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n    (\"foreach\" body line %d)"
argument_list|,
name|interp
operator|->
name|errorLine
argument_list|)
expr_stmt|;
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|msg
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|TclMax
argument_list|(
name|envPtr
operator|->
name|maxStackDepth
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|numCodeBytes
operator|=
name|TclCurrCodeOffset
argument_list|()
operator|-
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|codeOffset
expr_stmt|;
comment|/*      * Discard the loop body's result.      */
name|TclEmitOpcode
argument_list|(
name|INST_POP
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/*      * Emit the unconditional jump back to the test at the top of the      * loop. We generate a four byte jump if the distance to the to of      * the foreach is greater than 120 bytes. This is conservative and      * ensures that we won't have to replace this unconditional jump if      * we later need to replace the ifFalse jump with a four-byte jump.      */
name|jumpBackOffset
operator|=
name|TclCurrCodeOffset
argument_list|()
expr_stmt|;
name|jumpBackDist
operator|=
operator|(
name|jumpBackOffset
operator|-
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|continueOffset
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
if|if
condition|(
name|jumpBackDist
operator|>
name|MAX_JUMP_DIST
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nTclCompileForeachCmd: bad distance %u for unconditional jump\n"
argument_list|,
name|jumpBackDist
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"TclCompileForeachCmd: bad distance for unconditional jump"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*TCL_COMPILE_DEBUG*/
if|if
condition|(
name|jumpBackDist
operator|>
literal|120
condition|)
block|{
name|TclEmitInstInt4
argument_list|(
name|INST_JUMP4
argument_list|,
comment|/*offset*/
operator|-
name|jumpBackDist
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TclEmitInstInt1
argument_list|(
name|INST_JUMP1
argument_list|,
comment|/*offset*/
operator|-
name|jumpBackDist
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * Now that we know the target of the jumpFalse after the foreach_step      * test, update it with the correct distance. If the distance is too      * great (more than 127 bytes), replace that jump with a four byte      * instruction and move the instructions after the jump down.      */
name|jumpDist
operator|=
operator|(
name|TclCurrCodeOffset
argument_list|()
operator|-
name|jumpFalseFixup
operator|.
name|codeOffset
operator|)
expr_stmt|;
if|if
condition|(
name|TclFixupForwardJump
argument_list|(
name|envPtr
argument_list|,
operator|&
name|jumpFalseFixup
argument_list|,
name|jumpDist
argument_list|,
literal|127
argument_list|)
condition|)
block|{
comment|/* 	 * Update the loop body's starting PC offset since it moved down. 	 */
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
if|if
condition|(
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|type
operator|!=
name|LOOP_EXCEPTION_RANGE
condition|)
block|{
name|panic
argument_list|(
literal|"TclCompileForeachCmd: bad body ExceptionRange type %d\n"
argument_list|,
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*TCL_COMPILE_DEBUG*/
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|codeOffset
operator|+=
literal|3
expr_stmt|;
comment|/* 	 * Update the distance for the unconditional jump back to the test 	 * at the top of the loop since it moved down 3 bytes too. 	 */
name|jumpBackOffset
operator|+=
literal|3
expr_stmt|;
name|jumpPc
operator|=
operator|(
name|envPtr
operator|->
name|codeStart
operator|+
name|jumpBackOffset
operator|)
expr_stmt|;
if|if
condition|(
name|jumpBackDist
operator|>
literal|120
condition|)
block|{
name|jumpBackDist
operator|+=
literal|3
expr_stmt|;
name|TclUpdateInstInt4AtPc
argument_list|(
name|INST_JUMP4
argument_list|,
comment|/*offset*/
operator|-
name|jumpBackDist
argument_list|,
name|jumpPc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|jumpBackDist
operator|+=
literal|3
expr_stmt|;
name|TclUpdateInstInt1AtPc
argument_list|(
name|INST_JUMP1
argument_list|,
comment|/*offset*/
operator|-
name|jumpBackDist
argument_list|,
name|jumpPc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * The current PC offset (after the loop's body) is the loop's      * break target.      */
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
if|if
condition|(
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|type
operator|!=
name|LOOP_EXCEPTION_RANGE
condition|)
block|{
name|panic
argument_list|(
literal|"TclCompileForeachCmd: bad body ExceptionRange type %d\n"
argument_list|,
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*TCL_COMPILE_DEBUG*/
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|breakOffset
operator|=
name|TclCurrCodeOffset
argument_list|()
expr_stmt|;
comment|/*      * Push an empty string object as the foreach command's result.      */
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|,
comment|/*allocStrRep*/
literal|0
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxDepth
operator|==
literal|0
condition|)
block|{
name|maxDepth
operator|=
literal|1
expr_stmt|;
comment|/* since we just pushed one object */
block|}
name|done
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numLists
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|varvList
index|[
name|i
index|]
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|varvList
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|varcList
operator|!=
name|varcListStaticSpace
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|varcList
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|varvList
argument_list|)
expr_stmt|;
block|}
name|envPtr
operator|->
name|termOffset
operator|=
operator|(
name|argInfo
operator|.
name|endArray
index|[
name|numWords
operator|-
literal|1
index|]
operator|+
literal|1
operator|-
name|string
operator|)
expr_stmt|;
name|envPtr
operator|->
name|pushSimpleWords
operator|=
name|savePushSimpleWords
expr_stmt|;
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
name|envPtr
operator|->
name|excRangeDepth
operator|--
expr_stmt|;
name|FreeArgInfo
argument_list|(
operator|&
name|argInfo
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DupForeachInfo --  *  *	This procedure duplicates a ForeachInfo structure created as  *	auxiliary data during the compilation of a foreach command.  *  * Results:  *	A pointer to a newly allocated copy of the existing ForeachInfo  *	structure is returned.  *  * Side effects:  *	Storage for the copied ForeachInfo record is allocated. If the  *	original ForeachInfo structure pointed to any ForeachVarList  *	records, these structures are also copied and pointers to them  *	are stored in the new ForeachInfo record.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|ClientData
name|DupForeachInfo
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* The foreach command's compilation 				 * auxiliary data to duplicate. */
block|{
specifier|register
name|ForeachInfo
modifier|*
name|srcPtr
init|=
operator|(
name|ForeachInfo
operator|*
operator|)
name|clientData
decl_stmt|;
name|ForeachInfo
modifier|*
name|dupPtr
decl_stmt|;
specifier|register
name|ForeachVarList
modifier|*
name|srcListPtr
decl_stmt|,
modifier|*
name|dupListPtr
decl_stmt|;
name|int
name|numLists
init|=
name|srcPtr
operator|->
name|numLists
decl_stmt|;
name|int
name|numVars
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|dupPtr
operator|=
operator|(
name|ForeachInfo
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|ForeachInfo
argument_list|)
operator|+
operator|(
name|numLists
operator|*
sizeof|sizeof
argument_list|(
name|ForeachVarList
operator|*
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|dupPtr
operator|->
name|numLists
operator|=
name|numLists
expr_stmt|;
name|dupPtr
operator|->
name|firstListTmp
operator|=
name|srcPtr
operator|->
name|firstListTmp
expr_stmt|;
name|dupPtr
operator|->
name|loopIterNumTmp
operator|=
name|srcPtr
operator|->
name|loopIterNumTmp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numLists
condition|;
name|i
operator|++
control|)
block|{
name|srcListPtr
operator|=
name|srcPtr
operator|->
name|varLists
index|[
name|i
index|]
expr_stmt|;
name|numVars
operator|=
name|srcListPtr
operator|->
name|numVars
expr_stmt|;
name|dupListPtr
operator|=
operator|(
name|ForeachVarList
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|ForeachVarList
argument_list|)
operator|+
name|numVars
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|dupListPtr
operator|->
name|numVars
operator|=
name|numVars
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numVars
condition|;
name|j
operator|++
control|)
block|{
name|dupListPtr
operator|->
name|varIndexes
index|[
name|j
index|]
operator|=
name|srcListPtr
operator|->
name|varIndexes
index|[
name|j
index|]
expr_stmt|;
block|}
name|dupPtr
operator|->
name|varLists
index|[
name|i
index|]
operator|=
name|dupListPtr
expr_stmt|;
block|}
return|return
operator|(
name|ClientData
operator|)
name|dupPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FreeForeachInfo --  *  *	Procedure to free a ForeachInfo structure created as auxiliary data  *	during the compilation of a foreach command.  *  * Results:  *	None.  *  * Side effects:  *	Storage for the ForeachInfo structure pointed to by the ClientData  *	argument is freed as is any ForeachVarList record pointed to by the  *	ForeachInfo structure.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|FreeForeachInfo
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* The foreach command's compilation 				 * auxiliary data to free. */
block|{
specifier|register
name|ForeachInfo
modifier|*
name|infoPtr
init|=
operator|(
name|ForeachInfo
operator|*
operator|)
name|clientData
decl_stmt|;
specifier|register
name|ForeachVarList
modifier|*
name|listPtr
decl_stmt|;
name|int
name|numLists
init|=
name|infoPtr
operator|->
name|numLists
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numLists
condition|;
name|i
operator|++
control|)
block|{
name|listPtr
operator|=
name|infoPtr
operator|->
name|varLists
index|[
name|i
index|]
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|listPtr
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|infoPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCompileIfCmd --  *  *	Procedure called to compile the "if" command.  *  * Results:  *	The return value is a standard Tcl result, which is TCL_OK unless  *	there was an error while parsing string. If an error occurs then  *	the interpreter's result contains a standard error message.  *  *	envPtr->termOffset is filled in with the offset of the character in  *	"string" just after the last one successfully processed.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the command.  *  * Side effects:  *	Instructions are added to envPtr to evaluate the "if" command  *	at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclCompileIfCmd
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|lastChar
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* The source string to compile. */
name|char
modifier|*
name|lastChar
decl_stmt|;
comment|/* Pointer to terminating character of 				 * string. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
specifier|register
name|char
modifier|*
name|src
init|=
name|string
decl_stmt|;
comment|/* Points to current source char. */
specifier|register
name|int
name|type
decl_stmt|;
comment|/* Current char's CHAR_TYPE type. */
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute cmd. */
name|JumpFixupArray
name|jumpFalseFixupArray
decl_stmt|;
comment|/* Used to fix up the ifFalse jump after 				 * each "if"/"elseif" test when its target 				 * PC is determined. */
name|JumpFixupArray
name|jumpEndFixupArray
decl_stmt|;
comment|/* Used to fix up the unconditional jump 				 * after each "then" command to the end of 				 * the "if" when that PC is determined. */
name|char
modifier|*
name|testSrcStart
decl_stmt|;
name|int
name|jumpDist
decl_stmt|,
name|jumpFalseDist
decl_stmt|,
name|jumpIndex
decl_stmt|,
name|objIndex
decl_stmt|,
name|j
decl_stmt|,
name|result
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ifFalsePc
decl_stmt|;
name|unsigned
name|char
name|opCode
decl_stmt|;
name|int
name|savePushSimpleWords
init|=
name|envPtr
operator|->
name|pushSimpleWords
decl_stmt|;
comment|/*      * Loop compiling "expr then body" clauses after an "if" or "elseif".      */
name|TclInitJumpFixupArray
argument_list|(
operator|&
name|jumpFalseFixupArray
argument_list|)
expr_stmt|;
name|TclInitJumpFixupArray
argument_list|(
operator|&
name|jumpEndFixupArray
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* 	 * At this point in the loop, we have an expression to test, either 	 * the main expression or an expression following an "elseif". 	 * The arguments after the expression must be "then" (optional) and 	 * a script to execute if the expression is true. 	 */
name|AdvanceToNextWord
argument_list|(
name|src
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* make sure there is a next word */
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TCL_COMMAND_END
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"wrong # args: no expression after \"if\" argument"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Compile the "if"/"elseif" test expression. 	 */
name|testSrcStart
operator|=
name|src
expr_stmt|;
name|envPtr
operator|->
name|pushSimpleWords
operator|=
literal|1
expr_stmt|;
comment|/* process words normally */
name|result
operator|=
name|CompileExprWord
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
name|lastChar
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
literal|"\n    (\"if\" test expression)"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|TclMax
argument_list|(
name|envPtr
operator|->
name|maxStackDepth
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
comment|/* 	 * Emit the ifFalse jump around the "then" part if the test was 	 * false. We emit a one byte (relative) jump here, and replace it 	 * later with a four byte jump if the jump target is more than 127 	 * bytes away.  	 */
if|if
condition|(
name|jumpFalseFixupArray
operator|.
name|next
operator|>=
name|jumpFalseFixupArray
operator|.
name|end
condition|)
block|{
name|TclExpandJumpFixupArray
argument_list|(
operator|&
name|jumpFalseFixupArray
argument_list|)
expr_stmt|;
block|}
name|jumpIndex
operator|=
name|jumpFalseFixupArray
operator|.
name|next
expr_stmt|;
name|jumpFalseFixupArray
operator|.
name|next
operator|++
expr_stmt|;
name|TclEmitForwardJump
argument_list|(
name|envPtr
argument_list|,
name|TCL_FALSE_JUMP
argument_list|,
operator|&
operator|(
name|jumpFalseFixupArray
operator|.
name|fixup
index|[
name|jumpIndex
index|]
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Skip over the optional "then" before the then clause. 	 */
name|AdvanceToNextWord
argument_list|(
name|src
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TCL_COMMAND_END
condition|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"wrong # args: no script following \"%.20s\" argument"
argument_list|,
name|testSrcStart
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
operator|*
name|src
operator|==
literal|'t'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|src
argument_list|,
literal|"then"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
operator|+
literal|4
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|TCL_SPACE
operator|)
operator|||
operator|(
name|type
operator|==
name|TCL_COMMAND_END
operator|)
condition|)
block|{
name|src
operator|+=
literal|4
expr_stmt|;
comment|/* skip over the "then" */
name|AdvanceToNextWord
argument_list|(
name|src
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TCL_COMMAND_END
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"wrong # args: no script following \"then\" argument"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
comment|/* 	 * Compile the "then" command word inline. 	 */
name|result
operator|=
name|CompileCmdWordInline
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
name|lastChar
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
literal|"\n    (\"if\" body script)"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|TclMax
argument_list|(
name|envPtr
operator|->
name|maxStackDepth
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
comment|/* 	 * Emit an unconditional jump to the end of the "if" command. We 	 * emit a one byte jump here, and replace it later with a four byte 	 * jump if the jump target is more than 127 bytes away. Note that 	 * both the jumpFalseFixupArray and the jumpEndFixupArray are 	 * indexed by the same index, "jumpIndex". 	 */
if|if
condition|(
name|jumpEndFixupArray
operator|.
name|next
operator|>=
name|jumpEndFixupArray
operator|.
name|end
condition|)
block|{
name|TclExpandJumpFixupArray
argument_list|(
operator|&
name|jumpEndFixupArray
argument_list|)
expr_stmt|;
block|}
name|jumpEndFixupArray
operator|.
name|next
operator|++
expr_stmt|;
name|TclEmitForwardJump
argument_list|(
name|envPtr
argument_list|,
name|TCL_UNCONDITIONAL_JUMP
argument_list|,
operator|&
operator|(
name|jumpEndFixupArray
operator|.
name|fixup
index|[
name|jumpIndex
index|]
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Now that we know the target of the jumpFalse after the if test,          * update it with the correct distance. We generate a four byte 	 * jump if the distance is greater than 120 bytes. This is 	 * conservative, and ensures that we won't have to replace this 	 * jump if we later also need to replace the preceeding 	 * unconditional jump to the end of the "if" with a four-byte jump.          */
name|jumpDist
operator|=
operator|(
name|TclCurrCodeOffset
argument_list|()
operator|-
name|jumpFalseFixupArray
operator|.
name|fixup
index|[
name|jumpIndex
index|]
operator|.
name|codeOffset
operator|)
expr_stmt|;
if|if
condition|(
name|TclFixupForwardJump
argument_list|(
name|envPtr
argument_list|,
operator|&
operator|(
name|jumpFalseFixupArray
operator|.
name|fixup
index|[
name|jumpIndex
index|]
operator|)
argument_list|,
name|jumpDist
argument_list|,
literal|120
argument_list|)
condition|)
block|{
comment|/* 	     * Adjust the code offset for the unconditional jump at the end 	     * of the last "then" clause. 	     */
name|jumpEndFixupArray
operator|.
name|fixup
index|[
name|jumpIndex
index|]
operator|.
name|codeOffset
operator|+=
literal|3
expr_stmt|;
block|}
comment|/* 	 * Check now for a "elseif" word. If we find one, keep looping. 	 */
name|AdvanceToNextWord
argument_list|(
name|src
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|!=
name|TCL_COMMAND_END
operator|)
operator|&&
operator|(
operator|(
operator|*
name|src
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|src
argument_list|,
literal|"elseif"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
operator|+
literal|6
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|TCL_SPACE
operator|)
operator|||
operator|(
name|type
operator|==
name|TCL_COMMAND_END
operator|)
condition|)
block|{
name|src
operator|+=
literal|6
expr_stmt|;
comment|/* skip over the "elseif" */
name|AdvanceToNextWord
argument_list|(
name|src
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TCL_COMMAND_END
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"wrong # args: no expression after \"elseif\" argument"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
continue|continue;
comment|/* continue the "expr then body" loop */
block|}
block|}
break|break;
comment|/* exit the loop */
block|}
comment|/* end of the "expr then body" loop */
comment|/*      * No more "elseif expr then body" clauses. Check now for an "else"      * clause. If there is another word, we are at its start.      */
if|if
condition|(
name|type
operator|!=
name|TCL_COMMAND_END
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|src
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|src
argument_list|,
literal|"else"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
operator|+
literal|4
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|TCL_SPACE
operator|)
operator|||
operator|(
name|type
operator|==
name|TCL_COMMAND_END
operator|)
condition|)
block|{
name|src
operator|+=
literal|4
expr_stmt|;
comment|/* skip over the "else" */
name|AdvanceToNextWord
argument_list|(
name|src
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TCL_COMMAND_END
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"wrong # args: no script following \"else\" argument"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
comment|/* 	 * Compile the "else" command word inline. 	 */
name|result
operator|=
name|CompileCmdWordInline
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
name|lastChar
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
literal|"\n    (\"if\" else script)"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|TclMax
argument_list|(
name|envPtr
operator|->
name|maxStackDepth
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
comment|/* 	 * Skip over white space until the end of the command. 	 */
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|TCL_COMMAND_END
condition|)
block|{
name|AdvanceToNextWord
argument_list|(
name|src
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|TCL_COMMAND_END
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"wrong # args: extra words after \"else\" clause in \"if\" command"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
else|else
block|{
comment|/* 	 * The "if" command has no "else" clause: push an empty string 	 * object as its result. 	 */
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|,
comment|/*allocStrRep*/
literal|0
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|maxDepth
operator|=
name|TclMax
argument_list|(
literal|1
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
block|}
comment|/*      * Now that we know the target of the unconditional jumps to the end of      * the "if" command, update them with the correct distance. If the      * distance is too great (> 127 bytes), replace the jump with a four      * byte instruction and move instructions after the jump down.      */
for|for
control|(
name|j
operator|=
name|jumpEndFixupArray
operator|.
name|next
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|jumpIndex
operator|=
operator|(
name|j
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* i.e. process the closest jump first */
name|jumpDist
operator|=
operator|(
name|TclCurrCodeOffset
argument_list|()
operator|-
name|jumpEndFixupArray
operator|.
name|fixup
index|[
name|jumpIndex
index|]
operator|.
name|codeOffset
operator|)
expr_stmt|;
if|if
condition|(
name|TclFixupForwardJump
argument_list|(
name|envPtr
argument_list|,
operator|&
operator|(
name|jumpEndFixupArray
operator|.
name|fixup
index|[
name|jumpIndex
index|]
operator|)
argument_list|,
name|jumpDist
argument_list|,
literal|127
argument_list|)
condition|)
block|{
comment|/* 	     * Adjust the jump distance for the "ifFalse" jump that 	     * immediately preceeds this jump. We've moved it's target 	     * (just after this unconditional jump) three bytes down. 	     */
name|ifFalsePc
operator|=
operator|(
name|envPtr
operator|->
name|codeStart
operator|+
name|jumpFalseFixupArray
operator|.
name|fixup
index|[
name|jumpIndex
index|]
operator|.
name|codeOffset
operator|)
expr_stmt|;
name|opCode
operator|=
operator|*
name|ifFalsePc
expr_stmt|;
if|if
condition|(
name|opCode
operator|==
name|INST_JUMP_FALSE1
condition|)
block|{
name|jumpFalseDist
operator|=
name|TclGetInt1AtPc
argument_list|(
name|ifFalsePc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|jumpFalseDist
operator|+=
literal|3
expr_stmt|;
name|TclUpdateInt1AtPc
argument_list|(
name|jumpFalseDist
argument_list|,
operator|(
name|ifFalsePc
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opCode
operator|==
name|INST_JUMP_FALSE4
condition|)
block|{
name|jumpFalseDist
operator|=
name|TclGetInt4AtPc
argument_list|(
name|ifFalsePc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|jumpFalseDist
operator|+=
literal|3
expr_stmt|;
name|TclUpdateInt4AtPc
argument_list|(
name|jumpFalseDist
argument_list|,
operator|(
name|ifFalsePc
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"TclCompileIfCmd: unexpected opcode updating ifFalse jump"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*      * Free the jumpFixupArray array if malloc'ed storage was used.      */
name|done
label|:
name|TclFreeJumpFixupArray
argument_list|(
operator|&
name|jumpFalseFixupArray
argument_list|)
expr_stmt|;
name|TclFreeJumpFixupArray
argument_list|(
operator|&
name|jumpEndFixupArray
argument_list|)
expr_stmt|;
name|envPtr
operator|->
name|termOffset
operator|=
operator|(
name|src
operator|-
name|string
operator|)
expr_stmt|;
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
name|envPtr
operator|->
name|pushSimpleWords
operator|=
name|savePushSimpleWords
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCompileIncrCmd --  *  *	Procedure called to compile the "incr" command.  *  * Results:  *	The return value is a standard Tcl result, which is TCL_OK unless  *	there was an error while parsing string. If an error occurs then  *	the interpreter's result contains a standard error message.  *  *	envPtr->termOffset is filled in with the offset of the character in  *	"string" just after the last one successfully processed.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the "incr" command.  *  * Side effects:  *	Instructions are added to envPtr to evaluate the "incr" command  *	at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclCompileIncrCmd
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|lastChar
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* The source string to compile. */
name|char
modifier|*
name|lastChar
decl_stmt|;
comment|/* Pointer to terminating character of 				 * string. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
name|Proc
modifier|*
name|procPtr
init|=
name|envPtr
operator|->
name|procPtr
decl_stmt|;
comment|/* Points to structure describing procedure 				 * containing incr command, else NULL. */
specifier|register
name|char
modifier|*
name|src
init|=
name|string
decl_stmt|;
comment|/* Points to current source char. */
specifier|register
name|int
name|type
decl_stmt|;
comment|/* Current char's CHAR_TYPE type. */
name|int
name|simpleVarName
decl_stmt|;
comment|/* 1 if name is just sequence of chars with                                  * an optional element name in parens. */
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
comment|/* If simpleVarName, points to first char of 				 * variable name and nameChars is length. 				 * Otherwise NULL. */
name|char
modifier|*
name|elName
init|=
name|NULL
decl_stmt|;
comment|/* If simpleVarName, points to first char of 				 * element name and elNameChars is length. 				 * Otherwise NULL. */
name|int
name|nameChars
init|=
literal|0
decl_stmt|;
comment|/* Length of the var name. Initialized to 				 * avoid a compiler warning. */
name|int
name|elNameChars
init|=
literal|0
decl_stmt|;
comment|/* Length of array's element name, if any. 				 * Initialized to avoid a compiler 				 * warning. */
name|int
name|incrementGiven
decl_stmt|;
comment|/* 1 if an increment amount was given. */
name|int
name|isImmIncrValue
init|=
literal|0
decl_stmt|;
comment|/* 1 if increment amount is a literal 				 * integer in [-127..127]. */
name|int
name|immIncrValue
init|=
literal|0
decl_stmt|;
comment|/* if isImmIncrValue is 1, the immediate 				 * integer value. */
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute cmd. */
name|int
name|localIndex
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Index of the variable in the current 				 * procedure's array of local variables. 				 * Otherwise -1 if not in a procedure or 				 * the variable wasn't found. */
name|char
name|savedChar
decl_stmt|;
comment|/* Holds the character from string 				 * termporarily replaced by a null char 				 * during name processing. */
name|int
name|objIndex
decl_stmt|;
comment|/* The object array index for a pushed 				 * object holding a name part. */
name|int
name|savePushSimpleWords
init|=
name|envPtr
operator|->
name|pushSimpleWords
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|result
decl_stmt|;
comment|/*      * Parse the next word: the variable name. If it is "simple" (requires      * no substitutions at runtime), divide it up into a simple "name" plus      * an optional "elName". Otherwise, if not simple, just push the name.      */
name|AdvanceToNextWord
argument_list|(
name|src
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* make sure there is a next word */
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TCL_COMMAND_END
condition|)
block|{
name|badArgs
label|:
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"wrong # args: should be \"incr varName ?increment?\""
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|envPtr
operator|->
name|pushSimpleWords
operator|=
literal|0
expr_stmt|;
comment|/* we will process the varName */
name|result
operator|=
name|CompileWord
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
name|lastChar
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|simpleVarName
operator|=
name|envPtr
operator|->
name|wordIsSimple
expr_stmt|;
if|if
condition|(
name|simpleVarName
condition|)
block|{
name|name
operator|=
name|src
expr_stmt|;
name|nameChars
operator|=
name|envPtr
operator|->
name|numSimpleWordChars
expr_stmt|;
if|if
condition|(
name|type
operator|&
operator|(
name|TCL_QUOTE
operator||
name|TCL_OPEN_BRACE
operator|)
condition|)
block|{
name|name
operator|++
expr_stmt|;
comment|/* advance over the " or { */
block|}
name|elName
operator|=
name|NULL
expr_stmt|;
name|elNameChars
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nameChars
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
block|{
name|char
modifier|*
name|openParen
init|=
name|p
decl_stmt|;
name|p
operator|=
operator|(
name|src
operator|+
name|nameChars
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|')'
condition|)
block|{
comment|/* last char is ')' => array reference */
name|nameChars
operator|=
operator|(
name|openParen
operator|-
name|name
operator|)
expr_stmt|;
name|elName
operator|=
name|openParen
operator|+
literal|1
expr_stmt|;
name|elNameChars
operator|=
operator|(
name|p
operator|-
name|elName
operator|)
expr_stmt|;
block|}
break|break;
block|}
name|p
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
block|}
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
comment|/*      * See if there is a next word. If so, we are incrementing the variable      * by that value (which must be an integer).      */
name|incrementGiven
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|TCL_COMMAND_END
condition|)
block|{
name|AdvanceToNextWord
argument_list|(
name|src
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
name|incrementGiven
operator|=
operator|(
name|type
operator|!=
name|TCL_COMMAND_END
operator|)
expr_stmt|;
block|}
comment|/*      * Non-simple names have already been pushed. If this is a simple      * variable, either push its name (if a global or an unknown local      * variable) or look up the variable's local frame index. If a local is      * not found, push its name and do the lookup at runtime. If this is an      * array reference, also push the array element.      */
if|if
condition|(
name|simpleVarName
condition|)
block|{
if|if
condition|(
name|procPtr
operator|==
name|NULL
condition|)
block|{
name|savedChar
operator|=
name|name
index|[
name|nameChars
index|]
expr_stmt|;
comment|/* save char after name */
name|name
index|[
name|nameChars
index|]
operator|=
literal|'\0'
expr_stmt|;
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
name|name
argument_list|,
name|nameChars
argument_list|,
comment|/*allocStrRep*/
literal|1
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|name
index|[
name|nameChars
index|]
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|maxDepth
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|localIndex
operator|=
name|LookupCompiledLocal
argument_list|(
name|name
argument_list|,
name|nameChars
argument_list|,
comment|/*createIfNew*/
literal|0
argument_list|,
comment|/*flagsIfCreated*/
literal|0
argument_list|,
name|envPtr
operator|->
name|procPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|localIndex
operator|<
literal|0
operator|)
operator|||
operator|(
name|localIndex
operator|>
literal|255
operator|)
condition|)
block|{
if|if
condition|(
name|localIndex
operator|>
literal|255
condition|)
block|{
comment|/* we'll push the name */
name|localIndex
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|savedChar
operator|=
name|name
index|[
name|nameChars
index|]
expr_stmt|;
comment|/* save char after name */
name|name
index|[
name|nameChars
index|]
operator|=
literal|'\0'
expr_stmt|;
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
name|name
argument_list|,
name|nameChars
argument_list|,
comment|/*allocStrRep*/
literal|1
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|name
index|[
name|nameChars
index|]
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|maxDepth
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|maxDepth
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|elName
operator|!=
name|NULL
condition|)
block|{
comment|/* 	     * Parse and push the array element's name. Perform 	     * substitutions on it, just as is done for quoted strings. 	     */
name|savedChar
operator|=
name|elName
index|[
name|elNameChars
index|]
expr_stmt|;
comment|/* save char after elName */
name|elName
index|[
name|elNameChars
index|]
operator|=
literal|'\0'
expr_stmt|;
name|envPtr
operator|->
name|pushSimpleWords
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|TclCompileQuotes
argument_list|(
name|interp
argument_list|,
name|elName
argument_list|,
name|elName
operator|+
name|elNameChars
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|elName
index|[
name|elNameChars
index|]
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|char
name|msg
index|[
literal|200
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n    (parsing index for array \"%.*s\")"
argument_list|,
name|TclMin
argument_list|(
name|nameChars
argument_list|,
literal|100
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|msg
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|+=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
block|}
block|}
comment|/*      * If an increment was given, push the new value.      */
if|if
condition|(
name|incrementGiven
condition|)
block|{
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
name|envPtr
operator|->
name|pushSimpleWords
operator|=
literal|0
expr_stmt|;
comment|/* we will handle simple words */
name|result
operator|=
name|CompileWord
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
name|lastChar
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
literal|"\n    (reading increment)"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|type
operator|&
operator|(
name|TCL_QUOTE
operator||
name|TCL_OPEN_BRACE
operator|)
condition|)
block|{
name|src
operator|++
expr_stmt|;
comment|/* advance over the " or { */
block|}
if|if
condition|(
name|envPtr
operator|->
name|wordIsSimple
condition|)
block|{
comment|/* 	     * See if the word represents an integer whose formatted 	     * representation is the same as the word (e.g., this is 	     * true for 123 and -1 but not for 00005). If so, just 	     * push an integer object. 	     */
name|int
name|isCompilableInt
init|=
literal|0
decl_stmt|;
name|int
name|numChars
init|=
name|envPtr
operator|->
name|numSimpleWordChars
decl_stmt|;
name|char
name|savedChar
init|=
name|src
index|[
name|numChars
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|long
name|n
decl_stmt|;
name|src
index|[
name|numChars
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|TclLooksLikeInt
argument_list|(
name|src
argument_list|)
condition|)
block|{
if|if
condition|(
name|TclGetLong
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
operator|&
name|n
argument_list|)
operator|==
name|TCL_OK
condition|)
block|{
if|if
condition|(
operator|(
operator|-
literal|127
operator|<=
name|n
operator|)
operator|&&
operator|(
name|n
operator|<=
literal|127
operator|)
condition|)
block|{
name|isCompilableInt
operator|=
literal|1
expr_stmt|;
name|isImmIncrValue
operator|=
literal|1
expr_stmt|;
name|immIncrValue
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
name|TclFormatInt
argument_list|(
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|src
argument_list|,
name|buf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|isCompilableInt
operator|=
literal|1
expr_stmt|;
name|isImmIncrValue
operator|=
literal|0
expr_stmt|;
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
name|src
argument_list|,
name|numChars
argument_list|,
comment|/*allocStrRep*/
literal|0
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|objPtr
operator|=
name|envPtr
operator|->
name|objArrayPtr
index|[
name|objIndex
index|]
expr_stmt|;
name|Tcl_InvalidateStringRep
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|=
name|n
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclIntType
expr_stmt|;
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|maxDepth
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|isCompilableInt
condition|)
block|{
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
name|src
argument_list|,
name|numChars
argument_list|,
comment|/*allocStrRep*/
literal|1
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|maxDepth
operator|+=
literal|1
expr_stmt|;
block|}
name|src
index|[
name|numChars
index|]
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
block|}
else|else
block|{
name|maxDepth
operator|+=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|&
operator|(
name|TCL_QUOTE
operator||
name|TCL_OPEN_BRACE
operator|)
condition|)
block|{
name|src
operator|+=
operator|(
name|envPtr
operator|->
name|termOffset
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* already advanced 1 above */
block|}
else|else
block|{
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* no incr amount given so use 1 */
name|isImmIncrValue
operator|=
literal|1
expr_stmt|;
name|immIncrValue
operator|=
literal|1
expr_stmt|;
block|}
comment|/*      * Now emit instructions to increment the variable.      */
if|if
condition|(
operator|(
name|localIndex
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|localIndex
operator|>
literal|255
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"TclCompileIncrCmd: bad localIndex %d\n"
argument_list|,
name|localIndex
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|simpleVarName
condition|)
block|{
if|if
condition|(
name|elName
operator|==
name|NULL
condition|)
block|{
comment|/* scalar */
if|if
condition|(
name|localIndex
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|isImmIncrValue
condition|)
block|{
name|TclEmitInstUInt1
argument_list|(
name|INST_INCR_SCALAR1_IMM
argument_list|,
name|localIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|TclEmitInt1
argument_list|(
name|immIncrValue
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TclEmitInstUInt1
argument_list|(
name|INST_INCR_SCALAR1
argument_list|,
name|localIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|isImmIncrValue
condition|)
block|{
name|TclEmitInstInt1
argument_list|(
name|INST_INCR_SCALAR_STK_IMM
argument_list|,
name|immIncrValue
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TclEmitOpcode
argument_list|(
name|INST_INCR_SCALAR_STK
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* array */
if|if
condition|(
name|localIndex
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|isImmIncrValue
condition|)
block|{
name|TclEmitInstUInt1
argument_list|(
name|INST_INCR_ARRAY1_IMM
argument_list|,
name|localIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|TclEmitInt1
argument_list|(
name|immIncrValue
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TclEmitInstUInt1
argument_list|(
name|INST_INCR_ARRAY1
argument_list|,
name|localIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|isImmIncrValue
condition|)
block|{
name|TclEmitInstInt1
argument_list|(
name|INST_INCR_ARRAY_STK_IMM
argument_list|,
name|immIncrValue
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TclEmitOpcode
argument_list|(
name|INST_INCR_ARRAY_STK
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* non-simple variable name */
if|if
condition|(
name|isImmIncrValue
condition|)
block|{
name|TclEmitInstInt1
argument_list|(
name|INST_INCR_STK_IMM
argument_list|,
name|immIncrValue
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TclEmitOpcode
argument_list|(
name|INST_INCR_STK
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Skip over white space until the end of the command.      */
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|TCL_COMMAND_END
condition|)
block|{
name|AdvanceToNextWord
argument_list|(
name|src
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|TCL_COMMAND_END
condition|)
block|{
goto|goto
name|badArgs
goto|;
comment|/* too many arguments */
block|}
block|}
name|done
label|:
name|envPtr
operator|->
name|termOffset
operator|=
operator|(
name|src
operator|-
name|string
operator|)
expr_stmt|;
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
name|envPtr
operator|->
name|pushSimpleWords
operator|=
name|savePushSimpleWords
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCompileSetCmd --  *  *	Procedure called to compile the "set" command.  *  * Results:  *	The return value is a standard Tcl result, which is normally TCL_OK  *	unless there was an error while parsing string. If an error occurs  *	then the interpreter's result contains a standard error message. If  *	complation fails because the set command requires a second level of  *	substitutions, TCL_OUT_LINE_COMPILE is returned indicating that the  *	set command should be compiled "out of line" by emitting code to  *	invoke its command procedure (Tcl_SetCmd) at runtime.  *  *	envPtr->termOffset is filled in with the offset of the character in  *	"string" just after the last one successfully processed.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the incr command.  *  * Side effects:  *	Instructions are added to envPtr to evaluate the "set" command  *	at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclCompileSetCmd
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|lastChar
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* The source string to compile. */
name|char
modifier|*
name|lastChar
decl_stmt|;
comment|/* Pointer to terminating character of 				 * string. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
name|Proc
modifier|*
name|procPtr
init|=
name|envPtr
operator|->
name|procPtr
decl_stmt|;
comment|/* Points to structure describing procedure 				 * containing the set command, else NULL. */
name|ArgInfo
name|argInfo
decl_stmt|;
comment|/* Structure holding information about the 				 * start and end of each argument word. */
name|int
name|simpleVarName
decl_stmt|;
comment|/* 1 if name is just sequence of chars with                                  * an optional element name in parens. */
name|char
modifier|*
name|elName
init|=
name|NULL
decl_stmt|;
comment|/* If simpleVarName, points to first char of 				 * element name and elNameChars is length. 				 * Otherwise NULL. */
name|int
name|isAssignment
decl_stmt|;
comment|/* 1 if assigning value to var, else 0. */
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute cmd. */
name|int
name|localIndex
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Index of the variable in the current 				 * procedure's array of local variables. 				 * Otherwise -1 if not in a procedure, the 				 * name contains "::"s, or the variable 				 * wasn't found. */
name|char
name|savedChar
decl_stmt|;
comment|/* Holds the character from string 				 * termporarily replaced by a null char 				 * during name processing. */
name|int
name|objIndex
init|=
operator|-
literal|1
decl_stmt|;
comment|/* The object array index for a pushed 				 * object holding a name part. Initialized 				 * to avoid a compiler warning. */
name|char
modifier|*
name|wordStart
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|numWords
decl_stmt|,
name|isCompilableInt
decl_stmt|,
name|i
decl_stmt|,
name|result
decl_stmt|;
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|int
name|savePushSimpleWords
init|=
name|envPtr
operator|->
name|pushSimpleWords
decl_stmt|;
comment|/*      * Scan the words of the command and record the start and finish of      * each argument word.      */
name|InitArgInfo
argument_list|(
operator|&
name|argInfo
argument_list|)
expr_stmt|;
name|result
operator|=
name|CollectArgInfo
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
name|lastChar
argument_list|,
name|flags
argument_list|,
operator|&
name|argInfo
argument_list|)
expr_stmt|;
name|numWords
operator|=
name|argInfo
operator|.
name|numArgs
expr_stmt|;
comment|/* i.e., the # after the command name */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|numWords
operator|<
literal|1
operator|)
operator|||
operator|(
name|numWords
operator|>
literal|2
operator|)
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"wrong # args: should be \"set varName ?newValue?\""
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|isAssignment
operator|=
operator|(
name|numWords
operator|==
literal|2
operator|)
expr_stmt|;
comment|/*      * Parse the next word: the variable name. If the name is enclosed in      * quotes or braces, we return TCL_OUT_LINE_COMPILE and call the set      * command procedure at runtime since this makes sure that a second      * round of substitutions is done properly.       */
name|wordStart
operator|=
name|argInfo
operator|.
name|startArray
index|[
literal|0
index|]
expr_stmt|;
comment|/* start of 1st arg word: varname */
if|if
condition|(
operator|(
operator|*
name|wordStart
operator|==
literal|'{'
operator|)
operator|||
operator|(
operator|*
name|wordStart
operator|==
literal|'"'
operator|)
condition|)
block|{
name|result
operator|=
name|TCL_OUT_LINE_COMPILE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*      * Check whether the name is "simple": requires no substitutions at      * runtime.      */
name|envPtr
operator|->
name|pushSimpleWords
operator|=
literal|0
expr_stmt|;
comment|/* we will process the varName */
name|result
operator|=
name|CompileWord
argument_list|(
name|interp
argument_list|,
name|wordStart
argument_list|,
name|argInfo
operator|.
name|endArray
index|[
literal|0
index|]
operator|+
literal|1
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|simpleVarName
operator|=
name|envPtr
operator|->
name|wordIsSimple
expr_stmt|;
if|if
condition|(
operator|!
name|simpleVarName
condition|)
block|{
comment|/* 	 * The name isn't simple. CompileWord already pushed it. 	 */
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* If simpleVarName, points to first char of 				 * variable name and nameChars is length. 				 * Otherwise NULL. */
name|int
name|nameChars
decl_stmt|;
comment|/* Length of the var name. */
name|int
name|nameHasNsSeparators
init|=
literal|0
decl_stmt|;
comment|/* Set 1 if name contains "::"s. */
name|int
name|elNameChars
decl_stmt|;
comment|/* Length of array's element name if any. */
comment|/* 	 * A simple name. First divide it up into "name" plus "elName" 	 * for an array element name, if any. 	 */
name|name
operator|=
name|wordStart
expr_stmt|;
name|nameChars
operator|=
name|envPtr
operator|->
name|numSimpleWordChars
expr_stmt|;
name|elName
operator|=
name|NULL
expr_stmt|;
name|elNameChars
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nameChars
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
block|{
name|char
modifier|*
name|openParen
init|=
name|p
decl_stmt|;
name|p
operator|=
operator|(
name|name
operator|+
name|nameChars
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|')'
condition|)
block|{
comment|/* last char is ')' => array reference */
name|nameChars
operator|=
operator|(
name|openParen
operator|-
name|name
operator|)
expr_stmt|;
name|elName
operator|=
name|openParen
operator|+
literal|1
expr_stmt|;
name|elNameChars
operator|=
operator|(
name|p
operator|-
name|elName
operator|)
expr_stmt|;
block|}
break|break;
block|}
name|p
operator|++
expr_stmt|;
block|}
comment|/* 	 * Determine if name has any namespace separators (::'s). 	 */
name|p
operator|=
name|name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nameChars
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|':'
operator|)
operator|&&
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|nameChars
operator|)
operator|&&
operator|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|':'
operator|)
condition|)
block|{
name|nameHasNsSeparators
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|p
operator|++
expr_stmt|;
block|}
comment|/* 	 * Now either push the name or determine its index in the array of 	 * local variables in a procedure frame. Note that if we are 	 * compiling a procedure the variable must be local unless its 	 * name has namespace separators ("::"s). Note also that global 	 * variables are implemented by a local variable that "points" to 	 * the real global. There are two cases: 	 *   1) We are not compiling a procedure body. Push the global 	 *      variable's name and do the lookup at runtime. 	 *   2) We are compiling a procedure and the name has "::"s. 	 *	Push the namespace variable's name and do the lookup at 	 *	runtime. 	 *   3) We are compiling a procedure and the name has no "::"s. 	 *	If the variable has already been allocated an local index, 	 *	just look it up. If the variable is unknown and we are 	 *	doing an assignment, allocate a new index. Otherwise, 	 *	push the name and try to do the lookup at runtime. 	 */
if|if
condition|(
operator|(
name|procPtr
operator|==
name|NULL
operator|)
operator|||
name|nameHasNsSeparators
condition|)
block|{
name|savedChar
operator|=
name|name
index|[
name|nameChars
index|]
expr_stmt|;
comment|/* save char after name */
name|name
index|[
name|nameChars
index|]
operator|=
literal|'\0'
expr_stmt|;
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
name|name
argument_list|,
name|nameChars
argument_list|,
comment|/*allocStrRep*/
literal|1
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|name
index|[
name|nameChars
index|]
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|maxDepth
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|localIndex
operator|=
name|LookupCompiledLocal
argument_list|(
name|name
argument_list|,
name|nameChars
argument_list|,
comment|/*createIfNew*/
name|isAssignment
argument_list|,
comment|/*flagsIfCreated*/
operator|(
operator|(
name|elName
operator|==
name|NULL
operator|)
condition|?
name|VAR_SCALAR
else|:
name|VAR_ARRAY
operator|)
argument_list|,
name|envPtr
operator|->
name|procPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|localIndex
operator|>=
literal|0
condition|)
block|{
name|maxDepth
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|savedChar
operator|=
name|name
index|[
name|nameChars
index|]
expr_stmt|;
comment|/* save char after name */
name|name
index|[
name|nameChars
index|]
operator|=
literal|'\0'
expr_stmt|;
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
name|name
argument_list|,
name|nameChars
argument_list|,
comment|/*allocStrRep*/
literal|1
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|name
index|[
name|nameChars
index|]
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|maxDepth
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * If we are dealing with a reference to an array element, push the 	 * array element. Perform substitutions on it, just as is done 	 * for quoted strings. 	 */
if|if
condition|(
name|elName
operator|!=
name|NULL
condition|)
block|{
name|savedChar
operator|=
name|elName
index|[
name|elNameChars
index|]
expr_stmt|;
comment|/* save char after elName */
name|elName
index|[
name|elNameChars
index|]
operator|=
literal|'\0'
expr_stmt|;
name|envPtr
operator|->
name|pushSimpleWords
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|TclCompileQuotes
argument_list|(
name|interp
argument_list|,
name|elName
argument_list|,
name|elName
operator|+
name|elNameChars
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|elName
index|[
name|elNameChars
index|]
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|char
name|msg
index|[
literal|200
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n    (parsing index for array \"%.*s\")"
argument_list|,
name|TclMin
argument_list|(
name|nameChars
argument_list|,
literal|100
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|msg
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|+=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
block|}
block|}
comment|/*      * If we are doing an assignment, push the new value.      */
if|if
condition|(
name|isAssignment
condition|)
block|{
name|wordStart
operator|=
name|argInfo
operator|.
name|startArray
index|[
literal|1
index|]
expr_stmt|;
comment|/* start of 2nd arg word */
name|envPtr
operator|->
name|pushSimpleWords
operator|=
literal|0
expr_stmt|;
comment|/* we will handle simple words */
name|result
operator|=
name|CompileWord
argument_list|(
name|interp
argument_list|,
name|wordStart
argument_list|,
name|argInfo
operator|.
name|endArray
index|[
literal|1
index|]
operator|+
literal|1
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|!
name|envPtr
operator|->
name|wordIsSimple
condition|)
block|{
comment|/* 	     * The value isn't simple. CompileWord already pushed it. 	     */
name|maxDepth
operator|+=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * The value is simple. See if the word represents an integer 	     * whose formatted representation is the same as the word (e.g., 	     * this is true for 123 and -1 but not for 00005). If so, just 	     * push an integer object. 	     */
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|long
name|n
decl_stmt|;
name|p
operator|=
name|wordStart
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|wordStart
operator|==
literal|'"'
operator|)
operator|||
operator|(
operator|*
name|wordStart
operator|==
literal|'{'
operator|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
comment|/* advance over the " or { */
block|}
name|savedChar
operator|=
name|p
index|[
name|envPtr
operator|->
name|numSimpleWordChars
index|]
expr_stmt|;
name|p
index|[
name|envPtr
operator|->
name|numSimpleWordChars
index|]
operator|=
literal|'\0'
expr_stmt|;
name|isCompilableInt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TclLooksLikeInt
argument_list|(
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|TclGetLong
argument_list|(
name|interp
argument_list|,
name|p
argument_list|,
operator|&
name|n
argument_list|)
operator|==
name|TCL_OK
condition|)
block|{
name|TclFormatInt
argument_list|(
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
name|buf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|isCompilableInt
operator|=
literal|1
expr_stmt|;
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
name|p
argument_list|,
name|envPtr
operator|->
name|numSimpleWordChars
argument_list|,
comment|/*allocStrRep*/
literal|0
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|objPtr
operator|=
name|envPtr
operator|->
name|objArrayPtr
index|[
name|objIndex
index|]
expr_stmt|;
name|Tcl_InvalidateStringRep
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|=
name|n
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclIntType
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|isCompilableInt
condition|)
block|{
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
name|p
argument_list|,
name|envPtr
operator|->
name|numSimpleWordChars
argument_list|,
comment|/*allocStrRep*/
literal|1
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
name|p
index|[
name|envPtr
operator|->
name|numSimpleWordChars
index|]
operator|=
name|savedChar
expr_stmt|;
comment|/* restore char */
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|maxDepth
operator|+=
literal|1
expr_stmt|;
block|}
block|}
comment|/*      * Now emit instructions to set/retrieve the variable.      */
if|if
condition|(
name|simpleVarName
condition|)
block|{
if|if
condition|(
name|elName
operator|==
name|NULL
condition|)
block|{
comment|/* scalar */
if|if
condition|(
name|localIndex
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|localIndex
operator|<=
literal|255
condition|)
block|{
name|TclEmitInstUInt1
argument_list|(
operator|(
name|isAssignment
condition|?
name|INST_STORE_SCALAR1
else|:
name|INST_LOAD_SCALAR1
operator|)
argument_list|,
name|localIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TclEmitInstUInt4
argument_list|(
operator|(
name|isAssignment
condition|?
name|INST_STORE_SCALAR4
else|:
name|INST_LOAD_SCALAR4
operator|)
argument_list|,
name|localIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|TclEmitOpcode
argument_list|(
operator|(
name|isAssignment
condition|?
name|INST_STORE_SCALAR_STK
else|:
name|INST_LOAD_SCALAR_STK
operator|)
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* array */
if|if
condition|(
name|localIndex
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|localIndex
operator|<=
literal|255
condition|)
block|{
name|TclEmitInstUInt1
argument_list|(
operator|(
name|isAssignment
condition|?
name|INST_STORE_ARRAY1
else|:
name|INST_LOAD_ARRAY1
operator|)
argument_list|,
name|localIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TclEmitInstUInt4
argument_list|(
operator|(
name|isAssignment
condition|?
name|INST_STORE_ARRAY4
else|:
name|INST_LOAD_ARRAY4
operator|)
argument_list|,
name|localIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|TclEmitOpcode
argument_list|(
operator|(
name|isAssignment
condition|?
name|INST_STORE_ARRAY_STK
else|:
name|INST_LOAD_ARRAY_STK
operator|)
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* non-simple variable name */
name|TclEmitOpcode
argument_list|(
operator|(
name|isAssignment
condition|?
name|INST_STORE_STK
else|:
name|INST_LOAD_STK
operator|)
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|numWords
operator|==
literal|0
condition|)
block|{
name|envPtr
operator|->
name|termOffset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|envPtr
operator|->
name|termOffset
operator|=
operator|(
name|argInfo
operator|.
name|endArray
index|[
name|numWords
operator|-
literal|1
index|]
operator|+
literal|1
operator|-
name|string
operator|)
expr_stmt|;
block|}
name|envPtr
operator|->
name|pushSimpleWords
operator|=
name|savePushSimpleWords
expr_stmt|;
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
name|FreeArgInfo
argument_list|(
operator|&
name|argInfo
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCompileWhileCmd --  *  *	Procedure called to compile the "while" command.  *  * Results:  *	The return value is a standard Tcl result, which is TCL_OK if  *	compilation was successful. If an error occurs then the  *	interpreter's result contains a standard error message and TCL_ERROR  *	is returned. If compilation failed because the command is too  *	complex for TclCompileWhileCmd, TCL_OUT_LINE_COMPILE is returned  *	indicating that the while command should be compiled "out of line"  *	by emitting code to invoke its command procedure at runtime.  *  *	envPtr->termOffset is filled in with the offset of the character in  *	"string" just after the last one successfully processed.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the "while" command.  *  * Side effects:  *	Instructions are added to envPtr to evaluate the "while" command  *	at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclCompileWhileCmd
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|lastChar
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* The source string to compile. */
name|char
modifier|*
name|lastChar
decl_stmt|;
comment|/* Pointer to terminating character of 				  * string. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
specifier|register
name|char
modifier|*
name|src
init|=
name|string
decl_stmt|;
comment|/* Points to current source char. */
specifier|register
name|int
name|type
decl_stmt|;
comment|/* Current char's CHAR_TYPE type. */
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute cmd. */
name|int
name|range
decl_stmt|;
comment|/* Index in the ExceptionRange array of the 				 * ExceptionRange record for this loop. */
name|JumpFixup
name|jumpFalseFixup
decl_stmt|;
comment|/* Used to update or replace the ifFalse 				 * jump after test when its target PC is 				 * determined. */
name|unsigned
name|char
modifier|*
name|jumpPc
decl_stmt|;
name|int
name|jumpDist
decl_stmt|,
name|jumpBackDist
decl_stmt|,
name|jumpBackOffset
decl_stmt|,
name|objIndex
decl_stmt|,
name|result
decl_stmt|;
name|int
name|savePushSimpleWords
init|=
name|envPtr
operator|->
name|pushSimpleWords
decl_stmt|;
name|envPtr
operator|->
name|excRangeDepth
operator|++
expr_stmt|;
name|envPtr
operator|->
name|maxExcRangeDepth
operator|=
name|TclMax
argument_list|(
name|envPtr
operator|->
name|excRangeDepth
argument_list|,
name|envPtr
operator|->
name|maxExcRangeDepth
argument_list|)
expr_stmt|;
comment|/*      * Create and initialize a ExceptionRange record to hold information      * about this loop. This is used to implement break and continue.      */
name|range
operator|=
name|CreateExceptionRange
argument_list|(
name|LOOP_EXCEPTION_RANGE
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|continueOffset
operator|=
name|TclCurrCodeOffset
argument_list|()
expr_stmt|;
name|AdvanceToNextWord
argument_list|(
name|src
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* make sure there is a next word */
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TCL_COMMAND_END
condition|)
block|{
name|badArgs
label|:
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"wrong # args: should be \"while test command\""
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*      * If the test expression is enclosed in quotes (""s), don't compile      * the while inline. As a result of Tcl's two level substitution      * semantics for expressions, the expression might have a constant      * value that results in the loop never executing, or executing forever.      * Consider "set x 0; while "$x< 5" {incr x}": the loop body should      * never be executed.      */
if|if
condition|(
operator|*
name|src
operator|==
literal|'"'
condition|)
block|{
name|result
operator|=
name|TCL_OUT_LINE_COMPILE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*      * Compile the next word: the test expression.      */
name|envPtr
operator|->
name|pushSimpleWords
operator|=
literal|1
expr_stmt|;
comment|/* process words normally */
name|result
operator|=
name|CompileExprWord
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
name|lastChar
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
literal|"\n    (\"while\" test expression)"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
comment|/*      * Emit the ifFalse jump that terminates the while if the test was      * false. We emit a one byte (relative) jump here, and replace it      * later with a four byte jump if the jump target is more than      * 127 bytes away.      */
name|TclEmitForwardJump
argument_list|(
name|envPtr
argument_list|,
name|TCL_FALSE_JUMP
argument_list|,
operator|&
name|jumpFalseFixup
argument_list|)
expr_stmt|;
comment|/*      * Compile the loop body word inline. Also register the loop body's      * starting PC offset and byte length in the its ExceptionRange record.      */
name|AdvanceToNextWord
argument_list|(
name|src
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* make sure there is a next word */
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TCL_COMMAND_END
condition|)
block|{
goto|goto
name|badArgs
goto|;
block|}
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|codeOffset
operator|=
name|TclCurrCodeOffset
argument_list|()
expr_stmt|;
name|result
operator|=
name|CompileCmdWordInline
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
name|lastChar
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|char
name|msg
index|[
literal|60
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n    (\"while\" body line %d)"
argument_list|,
name|interp
operator|->
name|errorLine
argument_list|)
expr_stmt|;
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|msg
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|TclMax
argument_list|(
name|envPtr
operator|->
name|maxStackDepth
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|numCodeBytes
operator|=
operator|(
name|TclCurrCodeOffset
argument_list|()
operator|-
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|codeOffset
operator|)
expr_stmt|;
comment|/*      * Discard the loop body's result.      */
name|TclEmitOpcode
argument_list|(
name|INST_POP
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/*      * Emit the unconditional jump back to the test at the top of the      * loop. We generate a four byte jump if the distance to the while's      * test is greater than 120 bytes. This is conservative, and ensures      * that we won't have to replace this unconditional jump if we later      * need to replace the ifFalse jump with a four-byte jump.      */
name|jumpBackOffset
operator|=
name|TclCurrCodeOffset
argument_list|()
expr_stmt|;
name|jumpBackDist
operator|=
operator|(
name|jumpBackOffset
operator|-
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|continueOffset
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
if|if
condition|(
name|jumpBackDist
operator|>
name|MAX_JUMP_DIST
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nTclCompileWhileCmd: bad distance %u for unconditional jump\n"
argument_list|,
name|jumpBackDist
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"TclCompileWhileCmd: bad distance for unconditional jump"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*TCL_COMPILE_DEBUG*/
if|if
condition|(
name|jumpBackDist
operator|>
literal|120
condition|)
block|{
name|TclEmitInstInt4
argument_list|(
name|INST_JUMP4
argument_list|,
comment|/*offset*/
operator|-
name|jumpBackDist
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TclEmitInstInt1
argument_list|(
name|INST_JUMP1
argument_list|,
comment|/*offset*/
operator|-
name|jumpBackDist
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * Now that we know the target of the jumpFalse after the test, update      * it with the correct distance. If the distance is too great (more      * than 127 bytes), replace that jump with a four byte instruction and      * move the instructions after the jump down.       */
name|jumpDist
operator|=
operator|(
name|TclCurrCodeOffset
argument_list|()
operator|-
name|jumpFalseFixup
operator|.
name|codeOffset
operator|)
expr_stmt|;
if|if
condition|(
name|TclFixupForwardJump
argument_list|(
name|envPtr
argument_list|,
operator|&
name|jumpFalseFixup
argument_list|,
name|jumpDist
argument_list|,
literal|127
argument_list|)
condition|)
block|{
comment|/* 	 * Update the loop body's starting PC offset since it moved down. 	 */
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
if|if
condition|(
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|type
operator|!=
name|LOOP_EXCEPTION_RANGE
condition|)
block|{
name|panic
argument_list|(
literal|"TclCompileWhileCmd: bad body ExceptionRange type %d\n"
argument_list|,
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TCL_COMPILE_DEBUG */
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|codeOffset
operator|+=
literal|3
expr_stmt|;
comment|/* 	 * Update the distance for the unconditional jump back to the test 	 * at the top of the loop since it moved down 3 bytes too. 	 */
name|jumpBackOffset
operator|+=
literal|3
expr_stmt|;
name|jumpPc
operator|=
operator|(
name|envPtr
operator|->
name|codeStart
operator|+
name|jumpBackOffset
operator|)
expr_stmt|;
if|if
condition|(
name|jumpBackDist
operator|>
literal|120
condition|)
block|{
name|jumpBackDist
operator|+=
literal|3
expr_stmt|;
name|TclUpdateInstInt4AtPc
argument_list|(
name|INST_JUMP4
argument_list|,
comment|/*offset*/
operator|-
name|jumpBackDist
argument_list|,
name|jumpPc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|jumpBackDist
operator|+=
literal|3
expr_stmt|;
name|TclUpdateInstInt1AtPc
argument_list|(
name|INST_JUMP1
argument_list|,
comment|/*offset*/
operator|-
name|jumpBackDist
argument_list|,
name|jumpPc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * The current PC offset (after the loop's body) is the loop's      * break target.      */
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
if|if
condition|(
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|type
operator|!=
name|LOOP_EXCEPTION_RANGE
condition|)
block|{
name|panic
argument_list|(
literal|"TclCompileWhileCmd: bad body ExceptionRange type %d\n"
argument_list|,
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TCL_COMPILE_DEBUG */
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|breakOffset
operator|=
name|TclCurrCodeOffset
argument_list|()
expr_stmt|;
comment|/*      * Push an empty string object as the while command's result.      */
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|,
comment|/*allocStrRep*/
literal|0
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxDepth
operator|==
literal|0
condition|)
block|{
name|maxDepth
operator|=
literal|1
expr_stmt|;
comment|/* since we just pushed one object */
block|}
comment|/*      * Skip over white space until the end of the command.      */
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|TCL_COMMAND_END
condition|)
block|{
name|AdvanceToNextWord
argument_list|(
name|src
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|TCL_COMMAND_END
condition|)
block|{
goto|goto
name|badArgs
goto|;
comment|/* too many arguments */
block|}
block|}
name|done
label|:
name|envPtr
operator|->
name|termOffset
operator|=
operator|(
name|src
operator|-
name|string
operator|)
expr_stmt|;
name|envPtr
operator|->
name|pushSimpleWords
operator|=
name|savePushSimpleWords
expr_stmt|;
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
name|envPtr
operator|->
name|excRangeDepth
operator|--
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CompileExprWord --  *  *	Procedure that compiles a Tcl expression in a command word.  *  * Results:  *	The return value is a standard Tcl result, which is TCL_OK unless  *	there was an error while compiling string. If an error occurs then  *	the interpreter's result contains a standard error message.  *  *	envPtr->termOffset is filled in with the offset of the character in  *	"string" just after the last one successfully processed.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the "expr" word.  *  * Side effects:  *	Instructions are added to envPtr to evaluate the expression word  *	at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CompileExprWord
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|lastChar
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* The source string to compile. */
name|char
modifier|*
name|lastChar
decl_stmt|;
comment|/* Pointer to terminating character of 				  * string. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
specifier|register
name|char
modifier|*
name|src
init|=
name|string
decl_stmt|;
comment|/* Points to current source char. */
specifier|register
name|int
name|type
decl_stmt|;
comment|/* Current char's CHAR_TYPE type. */
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute the expression. */
name|int
name|nestedCmd
init|=
operator|(
name|flags
operator|&
name|TCL_BRACKET_TERM
operator|)
decl_stmt|;
comment|/* 1 if script being compiled is a nested 				 * command and is terminated by a ']'; 				 * otherwise 0. */
name|char
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|;
comment|/* Points to the first and last significant 				 * characters of the word. */
name|char
name|savedChar
decl_stmt|;
comment|/* Holds the character termporarily replaced 				 * by a null character during compilation 				 * of the expression. */
name|int
name|inlineCode
decl_stmt|;
comment|/* 1 if inline "optimistic" code is 				 * emitted for the expression; else 0. */
name|int
name|range
init|=
operator|-
literal|1
decl_stmt|;
comment|/* If we inline compile an un-{}'d 				 * expression, the index for its catch range 				 * record in the ExceptionRange array. 				 * Initialized to avoid compile warning. */
name|JumpFixup
name|jumpFixup
decl_stmt|;
comment|/* Used to emit the "success" jump after 				 * the inline expression code. */
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|savePushSimpleWords
init|=
name|envPtr
operator|->
name|pushSimpleWords
decl_stmt|;
name|int
name|saveExprIsJustVarRef
init|=
name|envPtr
operator|->
name|exprIsJustVarRef
decl_stmt|;
name|int
name|numChars
decl_stmt|,
name|result
decl_stmt|;
comment|/*      * Skip over leading white space.      */
name|AdvanceToNextWord
argument_list|(
name|src
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TCL_COMMAND_END
condition|)
block|{
name|badArgs
label|:
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"malformed expression word"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*      * If the word is enclosed in {}s, we may strip them off and safely      * compile the expression into an inline sequence of instructions using      * TclCompileExpr. We know these instructions will have the right Tcl7.x      * expression semantics.      *      * Otherwise, if the word is not enclosed in {}s, we may need to call      * the expr command (Tcl_ExprObjCmd) at runtime. This recompiles the      * expression each time (typically) and so is slow. However, there are      * some circumstances where we can still compile inline instructions      * "optimistically" and check, during their execution, for double      * substitutions (these appear as nonnumeric operands). We check for any      * backslash or command substitutions. If none appear, and only variable      * substitutions are found, we generate inline instructions.      *      * For now, if the expression is not enclosed in {}s, we call the expr      * command at runtime if either command or backslash substitutions      * appear (but not if only variable substitutions appear).      */
if|if
condition|(
operator|*
name|src
operator|==
literal|'{'
condition|)
block|{
comment|/* 	 * Inline compile the expression inside {}s. 	 */
name|first
operator|=
name|src
operator|+
literal|1
expr_stmt|;
name|src
operator|=
name|TclWordEnd
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|,
name|nestedCmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|src
operator|==
literal|0
condition|)
block|{
comment|/* word doesn't end properly. */
goto|goto
name|badArgs
goto|;
block|}
if|if
condition|(
operator|*
name|src
operator|!=
literal|'}'
condition|)
block|{
goto|goto
name|badArgs
goto|;
block|}
name|last
operator|=
operator|(
name|src
operator|-
literal|1
operator|)
expr_stmt|;
name|numChars
operator|=
operator|(
name|last
operator|-
name|first
operator|+
literal|1
operator|)
expr_stmt|;
name|savedChar
operator|=
name|first
index|[
name|numChars
index|]
expr_stmt|;
name|first
index|[
name|numChars
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* replace term. char with null */
name|result
operator|=
name|TclCompileExpr
argument_list|(
name|interp
argument_list|,
name|first
argument_list|,
name|first
operator|+
name|numChars
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|first
index|[
name|numChars
index|]
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
name|src
operator|++
expr_stmt|;
comment|/* advance src after terminating '}' */
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * No braces. If the expression is enclosed in '"'s, call the expr 	 * cmd at runtime. Otherwise, scan the word's characters looking for 	 * any '['s or (for now) '\'s. If any are found, just call expr cmd 	 * at runtime. 	 */
name|first
operator|=
name|src
expr_stmt|;
name|last
operator|=
name|TclWordEnd
argument_list|(
name|first
argument_list|,
name|lastChar
argument_list|,
name|nestedCmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|last
operator|==
literal|0
condition|)
block|{
comment|/* word doesn't end properly. */
name|src
operator|=
name|last
expr_stmt|;
goto|goto
name|badArgs
goto|;
block|}
name|inlineCode
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|first
operator|==
literal|'"'
operator|)
operator|&&
operator|(
operator|*
name|last
operator|==
literal|'"'
operator|)
condition|)
block|{
name|inlineCode
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|first
init|;
name|p
operator|<=
name|last
condition|;
name|p
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'['
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\\'
operator|)
condition|)
block|{
name|inlineCode
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|inlineCode
condition|)
block|{
comment|/* 	     * Inline compile the expression inside a "catch" so that a 	     * runtime error will back off to make a (slow) call on expr. 	     */
name|int
name|startCodeOffset
init|=
operator|(
name|envPtr
operator|->
name|codeNext
operator|-
name|envPtr
operator|->
name|codeStart
operator|)
decl_stmt|;
name|int
name|startRangeNext
init|=
name|envPtr
operator|->
name|excRangeArrayNext
decl_stmt|;
comment|/* 	     * Create a ExceptionRange record to hold information about 	     * the "catch" range for the expression's inline code. Also 	     * emit the instruction to mark the start of the range. 	     */
name|envPtr
operator|->
name|excRangeDepth
operator|++
expr_stmt|;
name|envPtr
operator|->
name|maxExcRangeDepth
operator|=
name|TclMax
argument_list|(
name|envPtr
operator|->
name|excRangeDepth
argument_list|,
name|envPtr
operator|->
name|maxExcRangeDepth
argument_list|)
expr_stmt|;
name|range
operator|=
name|CreateExceptionRange
argument_list|(
name|CATCH_EXCEPTION_RANGE
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|TclEmitInstUInt4
argument_list|(
name|INST_BEGIN_CATCH4
argument_list|,
name|range
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* 	     * Inline compile the expression. 	     */
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|codeOffset
operator|=
name|TclCurrCodeOffset
argument_list|()
expr_stmt|;
name|numChars
operator|=
operator|(
name|last
operator|-
name|first
operator|+
literal|1
operator|)
expr_stmt|;
name|savedChar
operator|=
name|first
index|[
name|numChars
index|]
expr_stmt|;
name|first
index|[
name|numChars
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* replace term. char with null */
name|result
operator|=
name|TclCompileExpr
argument_list|(
name|interp
argument_list|,
name|first
argument_list|,
name|first
operator|+
name|numChars
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|first
index|[
name|numChars
index|]
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|numCodeBytes
operator|=
name|TclCurrCodeOffset
argument_list|()
operator|-
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|codeOffset
expr_stmt|;
if|if
condition|(
operator|(
name|envPtr
operator|->
name|exprIsJustVarRef
operator|)
operator|||
operator|(
name|result
operator|!=
name|TCL_OK
operator|)
condition|)
block|{
comment|/* 		 * We must call the expr command at runtime since the 		 * expression consisted of just a single variable reference 		 * (and a second round of substitutions might be needed) or 		 * there was a compilation error. Delete the inline code by 		 * backing up the code pc and catch index. Note that if 		 * there was a compilation error, we can't report the error 		 * yet since the expression might be valid after the second 		 * round of substitutions. 		 */
name|envPtr
operator|->
name|codeNext
operator|=
operator|(
name|envPtr
operator|->
name|codeStart
operator|+
name|startCodeOffset
operator|)
expr_stmt|;
name|envPtr
operator|->
name|excRangeArrayNext
operator|=
name|startRangeNext
expr_stmt|;
name|inlineCode
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|TclEmitOpcode
argument_list|(
name|INST_END_CATCH
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|TclEmitForwardJump
argument_list|(
name|envPtr
argument_list|,
name|TCL_UNCONDITIONAL_JUMP
argument_list|,
operator|&
name|jumpFixup
argument_list|)
expr_stmt|;
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|catchOffset
operator|=
name|TclCurrCodeOffset
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* 	 * Arrange to call expr at runtime with the (already substituted 	 * once) expression word on the stack. 	 */
name|envPtr
operator|->
name|pushSimpleWords
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|CompileWord
argument_list|(
name|interp
argument_list|,
name|first
argument_list|,
name|lastChar
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
name|TclEmitOpcode
argument_list|(
name|INST_EXPR_STK
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If emitting inline code for this non-{}'d expression, update 	 * the target of the jump after that inline code. 	 */
if|if
condition|(
name|inlineCode
condition|)
block|{
name|int
name|jumpDist
init|=
operator|(
name|TclCurrCodeOffset
argument_list|()
operator|-
name|jumpFixup
operator|.
name|codeOffset
operator|)
decl_stmt|;
if|if
condition|(
name|TclFixupForwardJump
argument_list|(
name|envPtr
argument_list|,
operator|&
name|jumpFixup
argument_list|,
name|jumpDist
argument_list|,
literal|127
argument_list|)
condition|)
block|{
comment|/* 		 * Update the inline expression code's catch ExceptionRange 		 * target since it, being after the jump, also moved down. 		 */
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
if|if
condition|(
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|type
operator|!=
name|CATCH_EXCEPTION_RANGE
condition|)
block|{
name|panic
argument_list|(
literal|"CompileExprWord: bad body ExceptionRange type %d\n"
argument_list|,
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TCL_COMPILE_DEBUG */
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|range
index|]
operator|.
name|catchOffset
operator|+=
literal|3
expr_stmt|;
block|}
block|}
block|}
comment|/* if expression isn't in {}s */
name|done
label|:
name|envPtr
operator|->
name|termOffset
operator|=
operator|(
name|src
operator|-
name|string
operator|)
expr_stmt|;
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
name|envPtr
operator|->
name|pushSimpleWords
operator|=
name|savePushSimpleWords
expr_stmt|;
name|envPtr
operator|->
name|exprIsJustVarRef
operator|=
name|saveExprIsJustVarRef
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CompileCmdWordInline --  *  *	Procedure that compiles a Tcl command word inline. If the word is  *	enclosed in quotes or braces, we call TclCompileString to compile it  *	after stripping them off. Otherwise, we normally push the word's  *	value and call eval at runtime, but if the word is just a sequence  *	of alphanumeric characters, we emit an invoke instruction  *	directly. This procedure assumes that string points to the start of  *	the word to compile.  *  * Results:  *	The return value is a standard Tcl result, which is TCL_OK unless  *	there was an error while compiling string. If an error occurs then  *	the interpreter's result contains a standard error message.  *  *	envPtr->termOffset is filled in with the offset of the character in  *	"string" just after the last one successfully processed.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the command.  *  * Side effects:  *	Instructions are added to envPtr to execute the command word  *	at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CompileCmdWordInline
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|lastChar
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* The source string to compile. */
name|char
modifier|*
name|lastChar
decl_stmt|;
comment|/* Pointer to terminating character of 				 * string. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
specifier|register
name|char
modifier|*
name|src
init|=
name|string
decl_stmt|;
comment|/* Points to current source char. */
specifier|register
name|int
name|type
decl_stmt|;
comment|/* Current char's CHAR_TYPE type. */
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute cmd. */
name|char
modifier|*
name|termPtr
decl_stmt|;
comment|/* Points to char that terminated braced 				 * string. */
name|char
name|savedChar
decl_stmt|;
comment|/* Holds the character termporarily replaced 				 * by a null character during compilation 				 * of the command. */
name|int
name|savePushSimpleWords
init|=
name|envPtr
operator|->
name|pushSimpleWords
decl_stmt|;
name|int
name|objIndex
decl_stmt|;
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&
operator|(
name|TCL_QUOTE
operator||
name|TCL_OPEN_BRACE
operator|)
condition|)
block|{
name|src
operator|++
expr_stmt|;
comment|/* advance over the " or { */
name|envPtr
operator|->
name|pushSimpleWords
operator|=
literal|0
expr_stmt|;
comment|/* we process a simple word below */
if|if
condition|(
name|type
operator|==
name|TCL_QUOTE
condition|)
block|{
name|result
operator|=
name|TclCompileQuotes
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
name|lastChar
argument_list|,
literal|'"'
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|CompileBraces
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
name|lastChar
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Make sure the terminating character is the end of word. 	 */
name|termPtr
operator|=
operator|(
name|src
operator|+
name|envPtr
operator|->
name|termOffset
operator|)
expr_stmt|;
name|c
operator|=
operator|*
name|termPtr
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|termPtr
operator|+
literal|1
operator|)
operator|==
literal|'\n'
operator|)
condition|)
block|{
comment|/* 	     * Line is continued on next line; the backslash-newline turns 	     * into space, which terminates the word. 	     */
block|}
else|else
block|{
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|termPtr
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|!=
name|TCL_SPACE
operator|)
operator|&&
operator|(
name|type
operator|!=
name|TCL_COMMAND_END
operator|)
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|src
operator|-
literal|1
operator|)
operator|==
literal|'"'
condition|)
block|{
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"extra characters after close-quote"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"extra characters after close-brace"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|envPtr
operator|->
name|wordIsSimple
condition|)
block|{
comment|/* 	     * A simple word enclosed in "" or {}s. Call TclCompileString to 	     * compile it inline. Add a null character after the end of the 	     * quoted or braced string: i.e., at the " or }. Turn the 	     * flag bit TCL_BRACKET_TERM off since the recursively 	     * compiled subcommand is now terminated by a null character. 	     */
name|char
modifier|*
name|closeCharPos
init|=
operator|(
name|termPtr
operator|-
literal|1
operator|)
decl_stmt|;
name|savedChar
operator|=
operator|*
name|closeCharPos
expr_stmt|;
operator|*
name|closeCharPos
operator|=
literal|'\0'
expr_stmt|;
name|result
operator|=
name|TclCompileString
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
name|closeCharPos
argument_list|,
operator|(
name|flags
operator|&
operator|~
name|TCL_BRACKET_TERM
operator|)
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
operator|*
name|closeCharPos
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
comment|/* 	     * The braced string contained a backslash-newline. Call eval 	     * at runtime. 	     */
name|TclEmitOpcode
argument_list|(
name|INST_EVAL_STK
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
name|src
operator|=
name|termPtr
expr_stmt|;
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * Not a braced or quoted string. We normally push the word's 	 * value and call eval at runtime. However, if the word is just 	 * a sequence of alphanumeric characters, we call its compile 	 * procedure, if any, or otherwise just emit an invoke instruction. 	 */
name|char
modifier|*
name|p
init|=
name|src
decl_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
name|UCHAR
argument_list|(
name|c
argument_list|)
argument_list|)
operator|||
operator|(
name|c
operator|==
literal|'_'
operator|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
block|}
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|p
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|>
name|src
operator|)
operator|&&
operator|(
name|type
operator|==
name|TCL_COMMAND_END
operator|)
condition|)
block|{
comment|/* 	     * Look for a compile procedure and call it. Otherwise emit an 	     * invoke instruction to call the command at runtime. 	     */
name|Tcl_Command
name|cmd
decl_stmt|;
name|Command
modifier|*
name|cmdPtr
init|=
name|NULL
decl_stmt|;
name|int
name|wasCompiled
init|=
literal|0
decl_stmt|;
comment|/* set 1 if word has compile proc. */
name|savedChar
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|cmd
operator|=
name|Tcl_FindCommand
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|NULL
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
operator|(
name|Tcl_Command
operator|)
name|NULL
condition|)
block|{
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|cmd
expr_stmt|;
block|}
if|if
condition|(
name|cmdPtr
operator|!=
name|NULL
operator|&&
name|cmdPtr
operator|->
name|compileProc
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
name|src
operator|=
name|p
expr_stmt|;
name|iPtr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|ERR_ALREADY_LOGGED
operator||
name|ERR_IN_PROGRESS
operator||
name|ERROR_CODE_SET
operator|)
expr_stmt|;
name|result
operator|=
operator|(
operator|*
operator|(
name|cmdPtr
operator|->
name|compileProc
operator|)
operator|)
operator|(
name|interp
operator|,
name|src
operator|,
name|lastChar
operator|,
name|flags
operator|,
name|envPtr
operator|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|wasCompiled
operator|=
literal|1
expr_stmt|;
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|wasCompiled
condition|)
block|{
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
name|src
argument_list|,
name|p
operator|-
name|src
argument_list|,
comment|/*allocStrRep*/
literal|1
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|TclEmitInstUInt1
argument_list|(
name|INST_INVOKE_STK1
argument_list|,
literal|1
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|src
operator|=
name|p
expr_stmt|;
name|maxDepth
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	     * Push the word and call eval at runtime. 	     */
name|envPtr
operator|->
name|pushSimpleWords
operator|=
literal|1
expr_stmt|;
comment|/* process words normally */
name|result
operator|=
name|CompileWord
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
name|lastChar
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|TclEmitOpcode
argument_list|(
name|INST_EVAL_STK
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|src
operator|+=
name|envPtr
operator|->
name|termOffset
expr_stmt|;
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
block|}
block|}
name|done
label|:
name|envPtr
operator|->
name|termOffset
operator|=
operator|(
name|src
operator|-
name|string
operator|)
expr_stmt|;
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
name|envPtr
operator|->
name|pushSimpleWords
operator|=
name|savePushSimpleWords
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * LookupCompiledLocal --  *  *	This procedure is called at compile time to look up and optionally  *	allocate an entry ("slot") for a variable in a procedure's array of  *	local variables. If the variable's name is NULL, a new temporary  *	variable is always created. (Such temporary variables can only be  *	referenced using their slot index.)  *  * Results:  *	If createIfNew is 0 (false) and the name is non-NULL, then if the  *	variable is found, the index of its entry in the procedure's array  *	of local variables is returned; otherwise -1 is returned.  *	If name is NULL, the index of a new temporary variable is returned.  *	Finally, if createIfNew is 1 and name is non-NULL, the index of a  *	new entry is returned.  *  * Side effects:  *	Creates and registers a new local variable if createIfNew is 1 and  *	the variable is unknown, or if the name is NULL.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|LookupCompiledLocal
parameter_list|(
name|name
parameter_list|,
name|nameChars
parameter_list|,
name|createIfNew
parameter_list|,
name|flagsIfCreated
parameter_list|,
name|procPtr
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Points to first character of the name of 				 * a scalar or array variable. If NULL, a 				 * temporary var should be created. */
name|int
name|nameChars
decl_stmt|;
comment|/* The length of the name excluding the 				 * terminating null character. */
name|int
name|createIfNew
decl_stmt|;
comment|/* 1 to allocate a local frame entry for the 				 * variable if it is new. */
name|int
name|flagsIfCreated
decl_stmt|;
comment|/* Flag bits for the compiled local if 				 * created. Only VAR_SCALAR, VAR_ARRAY, and 				 * VAR_LINK make sense. */
specifier|register
name|Proc
modifier|*
name|procPtr
decl_stmt|;
comment|/* Points to structure describing procedure 				 * containing the variable reference. */
block|{
specifier|register
name|CompiledLocal
modifier|*
name|localPtr
decl_stmt|;
name|int
name|localIndex
init|=
operator|-
literal|1
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/*      * If not creating a temporary, does a local variable of the specified      * name already exist?      */
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|int
name|localCt
init|=
name|procPtr
operator|->
name|numCompiledLocals
decl_stmt|;
name|localPtr
operator|=
name|procPtr
operator|->
name|firstLocalPtr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|localCt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|localPtr
operator|->
name|isTemp
condition|)
block|{
name|char
modifier|*
name|localName
init|=
name|localPtr
operator|->
name|name
decl_stmt|;
if|if
condition|(
operator|(
name|name
index|[
literal|0
index|]
operator|==
name|localName
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
name|nameChars
operator|==
name|localPtr
operator|->
name|nameLength
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|localName
argument_list|,
operator|(
name|unsigned
operator|)
name|nameChars
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
name|localPtr
operator|=
name|localPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
block|}
comment|/*      * Create a new variable if appropriate.      */
if|if
condition|(
name|createIfNew
operator|||
operator|(
name|name
operator|==
name|NULL
operator|)
condition|)
block|{
name|localIndex
operator|=
name|procPtr
operator|->
name|numCompiledLocals
expr_stmt|;
name|localPtr
operator|=
operator|(
name|CompiledLocal
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|CompiledLocal
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|localPtr
operator|->
name|name
argument_list|)
operator|+
name|nameChars
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|procPtr
operator|->
name|firstLocalPtr
operator|==
name|NULL
condition|)
block|{
name|procPtr
operator|->
name|firstLocalPtr
operator|=
name|procPtr
operator|->
name|lastLocalPtr
operator|=
name|localPtr
expr_stmt|;
block|}
else|else
block|{
name|procPtr
operator|->
name|lastLocalPtr
operator|->
name|nextPtr
operator|=
name|localPtr
expr_stmt|;
name|procPtr
operator|->
name|lastLocalPtr
operator|=
name|localPtr
expr_stmt|;
block|}
name|localPtr
operator|->
name|nextPtr
operator|=
name|NULL
expr_stmt|;
name|localPtr
operator|->
name|nameLength
operator|=
name|nameChars
expr_stmt|;
name|localPtr
operator|->
name|frameIndex
operator|=
name|localIndex
expr_stmt|;
name|localPtr
operator|->
name|isArg
operator|=
literal|0
expr_stmt|;
name|localPtr
operator|->
name|isTemp
operator|=
operator|(
name|name
operator|==
name|NULL
operator|)
expr_stmt|;
name|localPtr
operator|->
name|flags
operator|=
name|flagsIfCreated
expr_stmt|;
name|localPtr
operator|->
name|defValuePtr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
name|localPtr
operator|->
name|name
argument_list|,
name|name
argument_list|,
operator|(
name|unsigned
operator|)
name|nameChars
argument_list|)
expr_stmt|;
block|}
name|localPtr
operator|->
name|name
index|[
name|nameChars
index|]
operator|=
literal|'\0'
expr_stmt|;
name|procPtr
operator|->
name|numCompiledLocals
operator|++
expr_stmt|;
block|}
return|return
name|localIndex
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * AdvanceToNextWord --  *  *	This procedure is called to skip over any leading white space at the  *	start of a word. Note that a backslash-newline is treated as a  *	space.  *  * Results:  *	None.  *  * Side effects:  *	Updates envPtr->termOffset with the offset of the first  *	character in "string" that was not white space or a  *	backslash-newline. This might be the offset of the character that  *	ends the command: a newline, null, semicolon, or close-bracket.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|AdvanceToNextWord
parameter_list|(
name|string
parameter_list|,
name|envPtr
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
comment|/* The source string to compile. */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
specifier|register
name|char
modifier|*
name|src
decl_stmt|;
comment|/* Points to current source char. */
specifier|register
name|int
name|type
decl_stmt|;
comment|/* Current char's CHAR_TYPE type. */
name|src
operator|=
name|string
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|src
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|type
operator|&
operator|(
name|TCL_SPACE
operator||
name|TCL_BACKSLASH
operator|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|TCL_BACKSLASH
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|src
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
break|break;
comment|/* exit loop; no longer white space */
block|}
block|}
else|else
block|{
name|src
operator|++
expr_stmt|;
block|}
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|src
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|envPtr
operator|->
name|termOffset
operator|=
operator|(
name|src
operator|-
name|string
operator|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_Backslash --  *  *	Figure out how to handle a backslash sequence.  *  * Results:  *	The return value is the character that should be substituted  *	in place of the backslash sequence that starts at src.  If  *	readPtr isn't NULL then it is filled in with a count of the  *	number of characters in the backslash sequence.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
name|Tcl_Backslash
parameter_list|(
name|src
parameter_list|,
name|readPtr
parameter_list|)
name|char
modifier|*
name|src
decl_stmt|;
comment|/* Points to the backslash character of 				 * a backslash sequence. */
name|int
modifier|*
name|readPtr
decl_stmt|;
comment|/* Fill in with number of characters read 				 * from src, unless NULL. */
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|src
operator|+
literal|1
decl_stmt|;
name|char
name|result
decl_stmt|;
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|2
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
comment|/*          * Note: in the conversions below, use absolute values (e.g.,          * 0xa) rather than symbolic values (e.g. \n) that get converted          * by the compiler.  It's possible that compilers on some          * platforms will do the symbolic conversions differently, which          * could result in non-portable Tcl scripts.          */
case|case
literal|'a'
case|:
name|result
operator|=
literal|0x7
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|result
operator|=
literal|0x8
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|result
operator|=
literal|0xc
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|result
operator|=
literal|0xa
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|result
operator|=
literal|0xd
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|result
operator|=
literal|0x9
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|result
operator|=
literal|0xb
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
name|isxdigit
argument_list|(
name|UCHAR
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|result
operator|=
operator|(
name|char
operator|)
name|strtoul
argument_list|(
name|p
operator|+
literal|1
argument_list|,
operator|&
name|end
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|count
operator|=
name|end
operator|-
name|src
expr_stmt|;
block|}
else|else
block|{
name|count
operator|=
literal|2
expr_stmt|;
name|result
operator|=
literal|'x'
expr_stmt|;
block|}
break|break;
case|case
literal|'\n'
case|:
do|do
block|{
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|*
name|p
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'\t'
operator|)
condition|)
do|;
name|result
operator|=
literal|' '
expr_stmt|;
name|count
operator|=
name|p
operator|-
name|src
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|result
operator|=
literal|'\\'
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|result
operator|=
call|(
name|char
call|)
argument_list|(
operator|*
name|p
operator|-
literal|'0'
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
break|break;
block|}
name|count
operator|=
literal|3
expr_stmt|;
name|result
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|result
operator|<<
literal|3
operator|)
operator|+
operator|(
operator|*
name|p
operator|-
literal|'0'
operator|)
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
break|break;
block|}
name|count
operator|=
literal|4
expr_stmt|;
name|result
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|result
operator|<<
literal|3
operator|)
operator|+
operator|(
operator|*
name|p
operator|-
literal|'0'
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|result
operator|=
operator|*
name|p
expr_stmt|;
name|count
operator|=
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|readPtr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|readPtr
operator|=
name|count
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclObjIndexForString --  *  *	Procedure to find, or if necessary create, an object in a  *	CompileEnv's object array that has a string representation  *	matching the argument string.  *  * Results:  *	The index in the CompileEnv's object array of an object with a  *	string representation matching the argument "string". The object is  *	created if necessary. If inHeap is 1, then string is heap allocated  *	and ownership of the string is passed to TclObjIndexForString;  *	otherwise, the string is owned by the caller and must not be  *	modified or freed by TclObjIndexForString. Typically, a caller sets  *	inHeap 1 if string is an already heap-allocated buffer holding the  *	result of backslash substitutions.  *  * Side effects:  *	A new Tcl object will be created if no existing object matches the  *	input string. If allocStrRep is 1 then if a new object is created,  *	its string representation is allocated in the heap, else it is left  *	NULL. If inHeap is 1, this procedure is given ownership of the  * 	string: if an object is created and allocStrRep is 1 then its  *	string representation is set directly from string, otherwise  *	the string is freed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclObjIndexForString
parameter_list|(
name|string
parameter_list|,
name|length
parameter_list|,
name|allocStrRep
parameter_list|,
name|inHeap
parameter_list|,
name|envPtr
parameter_list|)
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Points to string for which an object is 				 * found or created in CompileEnv's object 				 * array. */
name|int
name|length
decl_stmt|;
comment|/* Length of string. */
name|int
name|allocStrRep
decl_stmt|;
comment|/* If 1 then the object's string rep should 				 * be allocated in the heap. */
name|int
name|inHeap
decl_stmt|;
comment|/* If 1 then string is heap allocated and 				 * its ownership is passed to 				 * TclObjIndexForString. */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Points to the CompileEnv in whose object 				 * array an object is found or created. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Points to the object created for 				 * the string, if one was created. */
name|int
name|objIndex
decl_stmt|;
comment|/* Index of matching object. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|int
name|strLength
decl_stmt|,
name|new
decl_stmt|;
comment|/*      * Look up the string in the code's object hashtable. If found, just      * return the associated object array index.  Note that if the string      * has embedded nulls, we don't create a hash table entry.  This      * should be fixed, but we need to update hash tables, first.      */
name|strLength
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
operator|-
literal|1
condition|)
block|{
name|length
operator|=
name|strLength
expr_stmt|;
block|}
if|if
condition|(
name|strLength
operator|!=
name|length
condition|)
block|{
name|hPtr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
name|envPtr
operator|->
name|objTable
argument_list|,
name|string
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
block|{
comment|/* already in object table and array */
name|objIndex
operator|=
operator|(
name|int
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|inHeap
condition|)
block|{
name|ckfree
argument_list|(
name|string
argument_list|)
expr_stmt|;
comment|/* since we own the string */
block|}
return|return
name|objIndex
return|;
block|}
block|}
comment|/*      * Create a new object holding the string, add it to the object array,      * and register its index in the object hashtable.      */
name|objPtr
operator|=
name|Tcl_NewObj
argument_list|()
expr_stmt|;
if|if
condition|(
name|allocStrRep
condition|)
block|{
if|if
condition|(
name|inHeap
condition|)
block|{
comment|/* use input string for obj's string rep */
name|objPtr
operator|->
name|bytes
operator|=
name|string
expr_stmt|;
block|}
else|else
block|{
comment|/* must allocate string rep */
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|objPtr
operator|->
name|bytes
operator|=
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|objPtr
operator|->
name|bytes
argument_list|,
name|string
argument_list|,
operator|(
name|size_t
operator|)
name|length
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|bytes
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
name|objPtr
operator|->
name|length
operator|=
name|length
expr_stmt|;
block|}
else|else
block|{
comment|/* leave the string rep NULL */
if|if
condition|(
name|inHeap
condition|)
block|{
name|ckfree
argument_list|(
name|string
argument_list|)
expr_stmt|;
comment|/* since we own the string */
block|}
block|}
if|if
condition|(
name|envPtr
operator|->
name|objArrayNext
operator|>=
name|envPtr
operator|->
name|objArrayEnd
condition|)
block|{
name|ExpandObjectArray
argument_list|(
name|envPtr
argument_list|)
expr_stmt|;
block|}
name|objIndex
operator|=
name|envPtr
operator|->
name|objArrayNext
expr_stmt|;
name|envPtr
operator|->
name|objArrayPtr
index|[
name|objIndex
index|]
operator|=
name|objPtr
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
comment|/* since obj array now has a reference */
name|envPtr
operator|->
name|objArrayNext
operator|++
expr_stmt|;
if|if
condition|(
name|hPtr
condition|)
block|{
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
name|objIndex
argument_list|)
expr_stmt|;
block|}
return|return
name|objIndex
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclExpandCodeArray --  *  *	Procedure that uses malloc to allocate more storage for a  *	CompileEnv's code array.  *  * Results:  *	None.   *  * Side effects:  *	The byte code array in *envPtr is reallocated to a new array of  *	double the size, and if envPtr->mallocedCodeArray is non-zero the  *	old array is freed. Byte codes are copied from the old array to the  *	new one.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclExpandCodeArray
parameter_list|(
name|envPtr
parameter_list|)
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Points to the CompileEnv whose code array 				 * must be enlarged. */
block|{
comment|/*      * envPtr->codeNext is equal to envPtr->codeEnd. The currently defined      * code bytes are stored between envPtr->codeStart and      * (envPtr->codeNext - 1) [inclusive].      */
name|size_t
name|currBytes
init|=
name|TclCurrCodeOffset
argument_list|()
decl_stmt|;
name|size_t
name|newBytes
init|=
literal|2
operator|*
operator|(
name|envPtr
operator|->
name|codeEnd
operator|-
name|envPtr
operator|->
name|codeStart
operator|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|newPtr
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|newBytes
argument_list|)
decl_stmt|;
comment|/*      * Copy from old code array to new, free old code array if needed, and      * mark new code array as malloced.      */
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|newPtr
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|envPtr
operator|->
name|codeStart
argument_list|,
name|currBytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|envPtr
operator|->
name|mallocedCodeArray
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|envPtr
operator|->
name|codeStart
argument_list|)
expr_stmt|;
block|}
name|envPtr
operator|->
name|codeStart
operator|=
name|newPtr
expr_stmt|;
name|envPtr
operator|->
name|codeNext
operator|=
operator|(
name|newPtr
operator|+
name|currBytes
operator|)
expr_stmt|;
name|envPtr
operator|->
name|codeEnd
operator|=
operator|(
name|newPtr
operator|+
name|newBytes
operator|)
expr_stmt|;
name|envPtr
operator|->
name|mallocedCodeArray
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * ExpandObjectArray --  *  *	Procedure that uses malloc to allocate more storage for a  *	CompileEnv's object array.  *  * Results:  *	None.  *  * Side effects:  *	The object array in *envPtr is reallocated to a new array of  *	double the size, and if envPtr->mallocedObjArray is non-zero the  *	old array is freed. Tcl_Obj pointers are copied from the old array  *	to the new one.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ExpandObjectArray
parameter_list|(
name|envPtr
parameter_list|)
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Points to the CompileEnv whose object 				 * array must be enlarged. */
block|{
comment|/*      * envPtr->objArrayNext is equal to envPtr->objArrayEnd. The currently      * allocated Tcl_Obj pointers are stored between elements      * 0 and (envPtr->objArrayNext - 1) [inclusive] in the object array      * pointed to by objArrayPtr.      */
name|size_t
name|currBytes
init|=
name|envPtr
operator|->
name|objArrayNext
operator|*
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
decl_stmt|;
name|int
name|newElems
init|=
literal|2
operator|*
name|envPtr
operator|->
name|objArrayEnd
decl_stmt|;
name|size_t
name|newBytes
init|=
name|newElems
operator|*
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
decl_stmt|;
name|Tcl_Obj
modifier|*
modifier|*
name|newPtr
init|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|newBytes
argument_list|)
decl_stmt|;
comment|/*      * Copy from old object array to new, free old object array if needed,      * and mark new object array as malloced.      */
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|newPtr
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|envPtr
operator|->
name|objArrayPtr
argument_list|,
name|currBytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|envPtr
operator|->
name|mallocedObjArray
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|envPtr
operator|->
name|objArrayPtr
argument_list|)
expr_stmt|;
block|}
name|envPtr
operator|->
name|objArrayPtr
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|newPtr
expr_stmt|;
name|envPtr
operator|->
name|objArrayEnd
operator|=
name|newElems
expr_stmt|;
name|envPtr
operator|->
name|mallocedObjArray
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * EnterCmdStartData --  *  *	Registers the starting source and bytecode location of a  *	command. This information is used at runtime to map between  *	instruction pc and source locations.  *  * Results:  *	None.  *  * Side effects:  *	Inserts source and code location information into the compilation  *	environment envPtr for the command at index cmdIndex. The  *	compilation environment's CmdLocation array is grown if necessary.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|EnterCmdStartData
parameter_list|(
name|envPtr
parameter_list|,
name|cmdIndex
parameter_list|,
name|srcOffset
parameter_list|,
name|codeOffset
parameter_list|)
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Points to the compilation environment 				 * structure in which to enter command 				 * location information. */
name|int
name|cmdIndex
decl_stmt|;
comment|/* Index of the command whose start data 				 * is being set. */
name|int
name|srcOffset
decl_stmt|;
comment|/* Offset of first char of the command. */
name|int
name|codeOffset
decl_stmt|;
comment|/* Offset of first byte of command code. */
block|{
name|CmdLocation
modifier|*
name|cmdLocPtr
decl_stmt|;
if|if
condition|(
operator|(
name|cmdIndex
operator|<
literal|0
operator|)
operator|||
operator|(
name|cmdIndex
operator|>=
name|envPtr
operator|->
name|numCommands
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"EnterCmdStartData: bad command index %d\n"
argument_list|,
name|cmdIndex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmdIndex
operator|>=
name|envPtr
operator|->
name|cmdMapEnd
condition|)
block|{
comment|/* 	 * Expand the command location array by allocating more storage from 	 * the heap. The currently allocated CmdLocation entries are stored 	 * from cmdMapPtr[0] up to cmdMapPtr[envPtr->cmdMapEnd] (inclusive). 	 */
name|size_t
name|currElems
init|=
name|envPtr
operator|->
name|cmdMapEnd
decl_stmt|;
name|size_t
name|newElems
init|=
literal|2
operator|*
name|currElems
decl_stmt|;
name|size_t
name|currBytes
init|=
name|currElems
operator|*
sizeof|sizeof
argument_list|(
name|CmdLocation
argument_list|)
decl_stmt|;
name|size_t
name|newBytes
init|=
name|newElems
operator|*
sizeof|sizeof
argument_list|(
name|CmdLocation
argument_list|)
decl_stmt|;
name|CmdLocation
modifier|*
name|newPtr
init|=
operator|(
name|CmdLocation
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|newBytes
argument_list|)
decl_stmt|;
comment|/* 	 * Copy from old command location array to new, free old command 	 * location array if needed, and mark new array as malloced. 	 */
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|newPtr
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|envPtr
operator|->
name|cmdMapPtr
argument_list|,
name|currBytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|envPtr
operator|->
name|mallocedCmdMap
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|envPtr
operator|->
name|cmdMapPtr
argument_list|)
expr_stmt|;
block|}
name|envPtr
operator|->
name|cmdMapPtr
operator|=
operator|(
name|CmdLocation
operator|*
operator|)
name|newPtr
expr_stmt|;
name|envPtr
operator|->
name|cmdMapEnd
operator|=
name|newElems
expr_stmt|;
name|envPtr
operator|->
name|mallocedCmdMap
operator|=
literal|1
expr_stmt|;
block|}
name|cmdLocPtr
operator|=
operator|&
operator|(
name|envPtr
operator|->
name|cmdMapPtr
index|[
name|cmdIndex
index|]
operator|)
expr_stmt|;
name|cmdLocPtr
operator|->
name|srcOffset
operator|=
name|srcOffset
expr_stmt|;
name|cmdLocPtr
operator|->
name|numSrcChars
operator|=
operator|-
literal|1
expr_stmt|;
name|cmdLocPtr
operator|->
name|codeOffset
operator|=
name|codeOffset
expr_stmt|;
name|cmdLocPtr
operator|->
name|numCodeBytes
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * EnterCmdExtentData --  *  *	Registers the source and bytecode length of a command. This  *	information is used at runtime to map between instruction pc and  *	source locations.  *  * Results:  *	None.  *  * Side effects:  *	Inserts source and code length information into the compilation  *	environment envPtr for the command at index cmdIndex. Starting  *	source and bytecode information for the command must already  *	have been registered.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|EnterCmdExtentData
parameter_list|(
name|envPtr
parameter_list|,
name|cmdIndex
parameter_list|,
name|numSrcChars
parameter_list|,
name|numCodeBytes
parameter_list|)
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Points to the compilation environment 				 * structure in which to enter command 				 * location information. */
name|int
name|cmdIndex
decl_stmt|;
comment|/* Index of the command whose source and 				 * code length data is being set. */
name|int
name|numSrcChars
decl_stmt|;
comment|/* Number of command source chars. */
name|int
name|numCodeBytes
decl_stmt|;
comment|/* Offset of last byte of command code. */
block|{
name|CmdLocation
modifier|*
name|cmdLocPtr
decl_stmt|;
if|if
condition|(
operator|(
name|cmdIndex
operator|<
literal|0
operator|)
operator|||
operator|(
name|cmdIndex
operator|>=
name|envPtr
operator|->
name|numCommands
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"EnterCmdStartData: bad command index %d\n"
argument_list|,
name|cmdIndex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmdIndex
operator|>
name|envPtr
operator|->
name|cmdMapEnd
condition|)
block|{
name|panic
argument_list|(
literal|"EnterCmdStartData: no start data registered for command with index %d\n"
argument_list|,
name|cmdIndex
argument_list|)
expr_stmt|;
block|}
name|cmdLocPtr
operator|=
operator|&
operator|(
name|envPtr
operator|->
name|cmdMapPtr
index|[
name|cmdIndex
index|]
operator|)
expr_stmt|;
name|cmdLocPtr
operator|->
name|numSrcChars
operator|=
name|numSrcChars
expr_stmt|;
name|cmdLocPtr
operator|->
name|numCodeBytes
operator|=
name|numCodeBytes
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InitArgInfo --  *  *	Initializes a ArgInfo structure to hold information about  *	some number of argument words in a command.  *  * Results:  *	None.  *  * Side effects:  *	The ArgInfo structure is initialized.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|InitArgInfo
parameter_list|(
name|argInfoPtr
parameter_list|)
specifier|register
name|ArgInfo
modifier|*
name|argInfoPtr
decl_stmt|;
comment|/* Points to the ArgInfo structure 				   * to initialize. */
block|{
name|argInfoPtr
operator|->
name|numArgs
operator|=
literal|0
expr_stmt|;
name|argInfoPtr
operator|->
name|startArray
operator|=
name|argInfoPtr
operator|->
name|staticStartSpace
expr_stmt|;
name|argInfoPtr
operator|->
name|endArray
operator|=
name|argInfoPtr
operator|->
name|staticEndSpace
expr_stmt|;
name|argInfoPtr
operator|->
name|allocArgs
operator|=
name|ARGINFO_INIT_ENTRIES
expr_stmt|;
name|argInfoPtr
operator|->
name|mallocedArrays
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CollectArgInfo --  *  *	Procedure to scan the argument words of a command and record the  *	start and finish of each argument word in a ArgInfo structure.  *  * Results:  *	The return value is a standard Tcl result, which is TCL_OK unless  *	there was an error while scanning string. If an error occurs then  *	the interpreter's result contains a standard error message.  *  * Side effects:  *	If necessary, the argument start and end arrays in *argInfoPtr  *	are grown and reallocated to a new arrays of double the size, and  *	if argInfoPtr->mallocedArray is non-zero the old arrays are freed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CollectArgInfo
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|lastChar
parameter_list|,
name|flags
parameter_list|,
name|argInfoPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* The source command string to scan. */
name|char
modifier|*
name|lastChar
decl_stmt|;
comment|/* Pointer to terminating character of 				  * string. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as                                  * passed to Tcl_Eval). */
specifier|register
name|ArgInfo
modifier|*
name|argInfoPtr
decl_stmt|;
comment|/* Points to the ArgInfo structure in which 				 * to record the arg word information. */
block|{
specifier|register
name|char
modifier|*
name|src
init|=
name|string
decl_stmt|;
comment|/* Points to current source char. */
specifier|register
name|int
name|type
decl_stmt|;
comment|/* Current char's CHAR_TYPE type. */
name|int
name|nestedCmd
init|=
operator|(
name|flags
operator|&
name|TCL_BRACKET_TERM
operator|)
decl_stmt|;
comment|/* 1 if string being scanned is a nested 				 * command and is terminated by a ']'; 				 * otherwise 0. */
name|int
name|scanningArgs
decl_stmt|;
comment|/* 1 if still scanning argument words to 				 * determine their start and end. */
name|char
modifier|*
name|wordStart
decl_stmt|,
modifier|*
name|wordEnd
decl_stmt|;
comment|/* Points to the first and last significant 				 * characters of each word. */
name|CompileEnv
name|tempCompEnv
decl_stmt|;
comment|/* Only used to hold the termOffset field 				 * updated by AdvanceToNextWord. */
name|char
modifier|*
name|prev
decl_stmt|;
name|argInfoPtr
operator|->
name|numArgs
operator|=
literal|0
expr_stmt|;
name|scanningArgs
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|scanningArgs
condition|)
block|{
name|AdvanceToNextWord
argument_list|(
name|src
argument_list|,
operator|&
name|tempCompEnv
argument_list|)
expr_stmt|;
name|src
operator|+=
name|tempCompEnv
operator|.
name|termOffset
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|TCL_COMMAND_END
operator|)
operator|&&
operator|(
operator|(
operator|*
name|src
operator|!=
literal|']'
operator|)
operator|||
name|nestedCmd
operator|)
condition|)
block|{
break|break;
comment|/* done collecting argument words */
block|}
elseif|else
if|if
condition|(
operator|*
name|src
operator|==
literal|'"'
condition|)
block|{
name|wordStart
operator|=
name|src
expr_stmt|;
name|src
operator|=
name|TclWordEnd
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|,
name|nestedCmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|==
name|lastChar
condition|)
block|{
comment|/* word doesn't end properly. */
name|badStringTermination
label|:
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"quoted string doesn't terminate properly"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|prev
operator|=
operator|(
name|src
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|src
operator|==
literal|'"'
condition|)
block|{
name|wordEnd
operator|=
name|src
expr_stmt|;
name|src
operator|++
expr_stmt|;
comment|/* skip over terminating '"' */
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|src
operator|==
literal|';'
operator|)
operator|&&
operator|(
operator|*
name|prev
operator|==
literal|'"'
operator|)
condition|)
block|{
name|scanningArgs
operator|=
literal|0
expr_stmt|;
comment|/* found a terminating ';' */
name|wordEnd
operator|=
name|prev
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|badStringTermination
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|src
operator|==
literal|'{'
condition|)
block|{
name|wordStart
operator|=
name|src
expr_stmt|;
name|src
operator|=
name|TclWordEnd
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|,
name|nestedCmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|==
name|lastChar
condition|)
block|{
comment|/* word doesn't end properly. */
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"missing close-brace"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|prev
operator|=
operator|(
name|src
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|src
operator|==
literal|'}'
condition|)
block|{
name|wordEnd
operator|=
name|src
expr_stmt|;
name|src
operator|++
expr_stmt|;
comment|/* skip over terminating '}' */
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|src
operator|==
literal|';'
operator|)
operator|&&
operator|(
operator|*
name|prev
operator|==
literal|'}'
operator|)
condition|)
block|{
name|scanningArgs
operator|=
literal|0
expr_stmt|;
comment|/* found a terminating ';' */
name|wordEnd
operator|=
name|prev
expr_stmt|;
block|}
else|else
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"argument word in braces doesn't terminate properly"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
else|else
block|{
name|wordStart
operator|=
name|src
expr_stmt|;
name|src
operator|=
name|TclWordEnd
argument_list|(
name|src
argument_list|,
name|lastChar
argument_list|,
name|nestedCmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|prev
operator|=
operator|(
name|src
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|src
operator|==
name|lastChar
condition|)
block|{
comment|/* word doesn't end properly. */
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"missing close-bracket or close-brace"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|src
operator|==
literal|';'
condition|)
block|{
name|scanningArgs
operator|=
literal|0
expr_stmt|;
comment|/* found a terminating ';' */
name|wordEnd
operator|=
name|prev
expr_stmt|;
block|}
else|else
block|{
name|wordEnd
operator|=
name|src
expr_stmt|;
name|src
operator|++
expr_stmt|;
comment|/* advance to char after word */
if|if
condition|(
operator|(
name|src
operator|==
name|lastChar
operator|)
operator|||
operator|(
operator|*
name|src
operator|==
literal|'\n'
operator|)
operator|||
operator|(
operator|(
operator|*
name|src
operator|==
literal|']'
operator|)
operator|&&
name|nestedCmd
operator|)
condition|)
block|{
name|scanningArgs
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* end of test on each kind of word */
if|if
condition|(
name|argInfoPtr
operator|->
name|numArgs
operator|==
name|argInfoPtr
operator|->
name|allocArgs
condition|)
block|{
name|int
name|newArgs
init|=
literal|2
operator|*
name|argInfoPtr
operator|->
name|numArgs
decl_stmt|;
name|size_t
name|currBytes
init|=
name|argInfoPtr
operator|->
name|numArgs
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
decl_stmt|;
name|size_t
name|newBytes
init|=
name|newArgs
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|newStartArrayPtr
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|newBytes
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|newEndArrayPtr
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|newBytes
argument_list|)
decl_stmt|;
comment|/* 	     * Copy from the old arrays to the new, free the old arrays if 	     * needed, and mark the new arrays as malloc'ed. 	     */
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|newStartArrayPtr
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|argInfoPtr
operator|->
name|startArray
argument_list|,
name|currBytes
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|newEndArrayPtr
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|argInfoPtr
operator|->
name|endArray
argument_list|,
name|currBytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|argInfoPtr
operator|->
name|mallocedArrays
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argInfoPtr
operator|->
name|startArray
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argInfoPtr
operator|->
name|endArray
argument_list|)
expr_stmt|;
block|}
name|argInfoPtr
operator|->
name|startArray
operator|=
name|newStartArrayPtr
expr_stmt|;
name|argInfoPtr
operator|->
name|endArray
operator|=
name|newEndArrayPtr
expr_stmt|;
name|argInfoPtr
operator|->
name|allocArgs
operator|=
name|newArgs
expr_stmt|;
name|argInfoPtr
operator|->
name|mallocedArrays
operator|=
literal|1
expr_stmt|;
block|}
name|argInfoPtr
operator|->
name|startArray
index|[
name|argInfoPtr
operator|->
name|numArgs
index|]
operator|=
name|wordStart
expr_stmt|;
name|argInfoPtr
operator|->
name|endArray
index|[
name|argInfoPtr
operator|->
name|numArgs
index|]
operator|=
name|wordEnd
expr_stmt|;
name|argInfoPtr
operator|->
name|numArgs
operator|++
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FreeArgInfo --  *  *	Free any storage allocated in a ArgInfo structure.  *  * Results:  *	None.  *  * Side effects:  *	Allocated storage in the ArgInfo structure is freed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|FreeArgInfo
parameter_list|(
name|argInfoPtr
parameter_list|)
specifier|register
name|ArgInfo
modifier|*
name|argInfoPtr
decl_stmt|;
comment|/* Points to the ArgInfo structure 				   * to free. */
block|{
if|if
condition|(
name|argInfoPtr
operator|->
name|mallocedArrays
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argInfoPtr
operator|->
name|startArray
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argInfoPtr
operator|->
name|endArray
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CreateLoopExceptionRange --  *  *	Procedure that allocates and initializes a new ExceptionRange  *	structure of the specified kind in a CompileEnv's ExceptionRange  *	array.  *  * Results:  *	Returns the index for the newly created ExceptionRange.  *  * Side effects:  *	If there is not enough room in the CompileEnv's ExceptionRange  *	array, the array in expanded: a new array of double the size is  *	allocated, if envPtr->mallocedExcRangeArray is non-zero the old  *	array is freed, and ExceptionRange entries are copied from the old  *	array to the new one.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CreateExceptionRange
parameter_list|(
name|type
parameter_list|,
name|envPtr
parameter_list|)
name|ExceptionRangeType
name|type
decl_stmt|;
comment|/* The kind of ExceptionRange desired. */
specifier|register
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Points to the CompileEnv for which a new 				 * loop ExceptionRange structure is to be 				 * allocated. */
block|{
name|int
name|index
decl_stmt|;
comment|/* Index for the newly-allocated 				 * ExceptionRange structure. */
specifier|register
name|ExceptionRange
modifier|*
name|rangePtr
decl_stmt|;
comment|/* Points to the new ExceptionRange 				 * structure */
name|index
operator|=
name|envPtr
operator|->
name|excRangeArrayNext
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|envPtr
operator|->
name|excRangeArrayEnd
condition|)
block|{
comment|/* 	 * Expand the ExceptionRange array. The currently allocated entries 	 * are stored between elements 0 and (envPtr->excRangeArrayNext - 1) 	 * [inclusive]. 	 */
name|size_t
name|currBytes
init|=
name|envPtr
operator|->
name|excRangeArrayNext
operator|*
sizeof|sizeof
argument_list|(
name|ExceptionRange
argument_list|)
decl_stmt|;
name|int
name|newElems
init|=
literal|2
operator|*
name|envPtr
operator|->
name|excRangeArrayEnd
decl_stmt|;
name|size_t
name|newBytes
init|=
name|newElems
operator|*
sizeof|sizeof
argument_list|(
name|ExceptionRange
argument_list|)
decl_stmt|;
name|ExceptionRange
modifier|*
name|newPtr
init|=
operator|(
name|ExceptionRange
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|newBytes
argument_list|)
decl_stmt|;
comment|/* 	 * Copy from old ExceptionRange array to new, free old 	 * ExceptionRange array if needed, and mark the new ExceptionRange 	 * array as malloced. 	 */
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|newPtr
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|envPtr
operator|->
name|excRangeArrayPtr
argument_list|,
name|currBytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|envPtr
operator|->
name|mallocedExcRangeArray
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|envPtr
operator|->
name|excRangeArrayPtr
argument_list|)
expr_stmt|;
block|}
name|envPtr
operator|->
name|excRangeArrayPtr
operator|=
operator|(
name|ExceptionRange
operator|*
operator|)
name|newPtr
expr_stmt|;
name|envPtr
operator|->
name|excRangeArrayEnd
operator|=
name|newElems
expr_stmt|;
name|envPtr
operator|->
name|mallocedExcRangeArray
operator|=
literal|1
expr_stmt|;
block|}
name|envPtr
operator|->
name|excRangeArrayNext
operator|++
expr_stmt|;
name|rangePtr
operator|=
operator|&
operator|(
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|index
index|]
operator|)
expr_stmt|;
name|rangePtr
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|rangePtr
operator|->
name|nestingLevel
operator|=
name|envPtr
operator|->
name|excRangeDepth
expr_stmt|;
name|rangePtr
operator|->
name|codeOffset
operator|=
operator|-
literal|1
expr_stmt|;
name|rangePtr
operator|->
name|numCodeBytes
operator|=
operator|-
literal|1
expr_stmt|;
name|rangePtr
operator|->
name|breakOffset
operator|=
operator|-
literal|1
expr_stmt|;
name|rangePtr
operator|->
name|continueOffset
operator|=
operator|-
literal|1
expr_stmt|;
name|rangePtr
operator|->
name|catchOffset
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|index
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCreateAuxData --  *  *	Procedure that allocates and initializes a new AuxData structure in  *	a CompileEnv's array of compilation auxiliary data records. These  *	AuxData records hold information created during compilation by  *	CompileProcs and used by instructions during execution.  *  * Results:  *	Returns the index for the newly created AuxData structure.  *  * Side effects:  *	If there is not enough room in the CompileEnv's AuxData array,  *	the AuxData array in expanded: a new array of double the size  *	is allocated, if envPtr->mallocedAuxDataArray is non-zero  *	the old array is freed, and AuxData entries are copied from  *	the old array to the new one.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclCreateAuxData
parameter_list|(
name|clientData
parameter_list|,
name|dupProc
parameter_list|,
name|freeProc
parameter_list|,
name|envPtr
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* The compilation auxiliary data to store 				 * in the new aux data record. */
name|AuxDataDupProc
modifier|*
name|dupProc
decl_stmt|;
comment|/* Procedure to call to duplicate the 				 * compilation aux data when the containing 				 * ByteCode structure is duplicated. */
name|AuxDataFreeProc
modifier|*
name|freeProc
decl_stmt|;
comment|/* Procedure to call to free the 				 * compilation aux data when the containing 				 * ByteCode structure is freed.  */
specifier|register
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Points to the CompileEnv for which a new 				 * aux data structure is to be allocated. */
block|{
name|int
name|index
decl_stmt|;
comment|/* Index for the new AuxData structure. */
specifier|register
name|AuxData
modifier|*
name|auxDataPtr
decl_stmt|;
comment|/* Points to the new AuxData structure */
name|index
operator|=
name|envPtr
operator|->
name|auxDataArrayNext
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|envPtr
operator|->
name|auxDataArrayEnd
condition|)
block|{
comment|/* 	 * Expand the AuxData array. The currently allocated entries are 	 * stored between elements 0 and (envPtr->auxDataArrayNext - 1) 	 * [inclusive]. 	 */
name|size_t
name|currBytes
init|=
name|envPtr
operator|->
name|auxDataArrayNext
operator|*
sizeof|sizeof
argument_list|(
name|AuxData
argument_list|)
decl_stmt|;
name|int
name|newElems
init|=
literal|2
operator|*
name|envPtr
operator|->
name|auxDataArrayEnd
decl_stmt|;
name|size_t
name|newBytes
init|=
name|newElems
operator|*
sizeof|sizeof
argument_list|(
name|AuxData
argument_list|)
decl_stmt|;
name|AuxData
modifier|*
name|newPtr
init|=
operator|(
name|AuxData
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|newBytes
argument_list|)
decl_stmt|;
comment|/* 	 * Copy from old AuxData array to new, free old AuxData array if 	 * needed, and mark the new AuxData array as malloced. 	 */
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|newPtr
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|envPtr
operator|->
name|auxDataArrayPtr
argument_list|,
name|currBytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|envPtr
operator|->
name|mallocedAuxDataArray
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|envPtr
operator|->
name|auxDataArrayPtr
argument_list|)
expr_stmt|;
block|}
name|envPtr
operator|->
name|auxDataArrayPtr
operator|=
name|newPtr
expr_stmt|;
name|envPtr
operator|->
name|auxDataArrayEnd
operator|=
name|newElems
expr_stmt|;
name|envPtr
operator|->
name|mallocedAuxDataArray
operator|=
literal|1
expr_stmt|;
block|}
name|envPtr
operator|->
name|auxDataArrayNext
operator|++
expr_stmt|;
name|auxDataPtr
operator|=
operator|&
operator|(
name|envPtr
operator|->
name|auxDataArrayPtr
index|[
name|index
index|]
operator|)
expr_stmt|;
name|auxDataPtr
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
name|auxDataPtr
operator|->
name|dupProc
operator|=
name|dupProc
expr_stmt|;
name|auxDataPtr
operator|->
name|freeProc
operator|=
name|freeProc
expr_stmt|;
return|return
name|index
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclInitJumpFixupArray --  *  *	Initializes a JumpFixupArray structure to hold some number of  *	jump fixup entries.  *  * Results:  *	None.  *  * Side effects:  *	The JumpFixupArray structure is initialized.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclInitJumpFixupArray
parameter_list|(
name|fixupArrayPtr
parameter_list|)
specifier|register
name|JumpFixupArray
modifier|*
name|fixupArrayPtr
decl_stmt|;
comment|/* Points to the JumpFixupArray structure 				  * to initialize. */
block|{
name|fixupArrayPtr
operator|->
name|fixup
operator|=
name|fixupArrayPtr
operator|->
name|staticFixupSpace
expr_stmt|;
name|fixupArrayPtr
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|fixupArrayPtr
operator|->
name|end
operator|=
operator|(
name|JUMPFIXUP_INIT_ENTRIES
operator|-
literal|1
operator|)
expr_stmt|;
name|fixupArrayPtr
operator|->
name|mallocedArray
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclExpandJumpFixupArray --  *  *	Procedure that uses malloc to allocate more storage for a  *      jump fixup array.  *  * Results:  *	None.  *  * Side effects:  *	The jump fixup array in *fixupArrayPtr is reallocated to a new array  *	of double the size, and if fixupArrayPtr->mallocedArray is non-zero  *	the old array is freed. Jump fixup structures are copied from the  *	old array to the new one.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclExpandJumpFixupArray
parameter_list|(
name|fixupArrayPtr
parameter_list|)
specifier|register
name|JumpFixupArray
modifier|*
name|fixupArrayPtr
decl_stmt|;
comment|/* Points to the JumpFixupArray structure 				  * to enlarge. */
block|{
comment|/*      * The currently allocated jump fixup entries are stored from fixup[0]      * up to fixup[fixupArrayPtr->fixupNext] (*not* inclusive). We assume      * fixupArrayPtr->fixupNext is equal to fixupArrayPtr->fixupEnd.      */
name|size_t
name|currBytes
init|=
name|fixupArrayPtr
operator|->
name|next
operator|*
sizeof|sizeof
argument_list|(
name|JumpFixup
argument_list|)
decl_stmt|;
name|int
name|newElems
init|=
literal|2
operator|*
operator|(
name|fixupArrayPtr
operator|->
name|end
operator|+
literal|1
operator|)
decl_stmt|;
name|size_t
name|newBytes
init|=
name|newElems
operator|*
sizeof|sizeof
argument_list|(
name|JumpFixup
argument_list|)
decl_stmt|;
name|JumpFixup
modifier|*
name|newPtr
init|=
operator|(
name|JumpFixup
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|newBytes
argument_list|)
decl_stmt|;
comment|/*      * Copy from the old array to new, free the old array if needed,      * and mark the new array as malloced.      */
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|newPtr
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|fixupArrayPtr
operator|->
name|fixup
argument_list|,
name|currBytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixupArrayPtr
operator|->
name|mallocedArray
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fixupArrayPtr
operator|->
name|fixup
argument_list|)
expr_stmt|;
block|}
name|fixupArrayPtr
operator|->
name|fixup
operator|=
operator|(
name|JumpFixup
operator|*
operator|)
name|newPtr
expr_stmt|;
name|fixupArrayPtr
operator|->
name|end
operator|=
name|newElems
expr_stmt|;
name|fixupArrayPtr
operator|->
name|mallocedArray
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclFreeJumpFixupArray --  *  *	Free any storage allocated in a jump fixup array structure.  *  * Results:  *	None.  *  * Side effects:  *	Allocated storage in the JumpFixupArray structure is freed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclFreeJumpFixupArray
parameter_list|(
name|fixupArrayPtr
parameter_list|)
specifier|register
name|JumpFixupArray
modifier|*
name|fixupArrayPtr
decl_stmt|;
comment|/* Points to the JumpFixupArray structure 				  * to free. */
block|{
if|if
condition|(
name|fixupArrayPtr
operator|->
name|mallocedArray
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fixupArrayPtr
operator|->
name|fixup
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclEmitForwardJump --  *  *	Procedure to emit a two-byte forward jump of kind "jumpType". Since  *	the jump may later have to be grown to five bytes if the jump target  *	is more than, say, 127 bytes away, this procedure also initializes a  *	JumpFixup record with information about the jump.   *  * Results:  *	None.  *  * Side effects:  *	The JumpFixup record pointed to by "jumpFixupPtr" is initialized  *	with information needed later if the jump is to be grown. Also,  *	a two byte jump of the designated type is emitted at the current  *	point in the bytecode stream.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclEmitForwardJump
parameter_list|(
name|envPtr
parameter_list|,
name|jumpType
parameter_list|,
name|jumpFixupPtr
parameter_list|)
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Points to the CompileEnv structure that 				 * holds the resulting instruction. */
name|TclJumpType
name|jumpType
decl_stmt|;
comment|/* Indicates the kind of jump: if true or 				 * false or unconditional. */
name|JumpFixup
modifier|*
name|jumpFixupPtr
decl_stmt|;
comment|/* Points to the JumpFixup structure to 				 * initialize with information about this 				 * forward jump. */
block|{
comment|/*      * Initialize the JumpFixup structure:      *    - codeOffset is offset of first byte of jump below      *    - cmdIndex is index of the command after the current one      *    - excRangeIndex is the index of the first ExceptionRange after      *      the current one.      */
name|jumpFixupPtr
operator|->
name|jumpType
operator|=
name|jumpType
expr_stmt|;
name|jumpFixupPtr
operator|->
name|codeOffset
operator|=
name|TclCurrCodeOffset
argument_list|()
expr_stmt|;
name|jumpFixupPtr
operator|->
name|cmdIndex
operator|=
name|envPtr
operator|->
name|numCommands
expr_stmt|;
name|jumpFixupPtr
operator|->
name|excRangeIndex
operator|=
name|envPtr
operator|->
name|excRangeArrayNext
expr_stmt|;
switch|switch
condition|(
name|jumpType
condition|)
block|{
case|case
name|TCL_UNCONDITIONAL_JUMP
case|:
name|TclEmitInstInt1
argument_list|(
name|INST_JUMP1
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCL_TRUE_JUMP
case|:
name|TclEmitInstInt1
argument_list|(
name|INST_JUMP_TRUE1
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|TclEmitInstInt1
argument_list|(
name|INST_JUMP_FALSE1
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclFixupForwardJump --  *  *	Procedure that updates a previously-emitted forward jump to jump  *	a specified number of bytes, "jumpDist". If necessary, the jump is  *      grown from two to five bytes; this is done if the jump distance is  *	greater than "distThreshold" (normally 127 bytes). The jump is  *	described by a JumpFixup record previously initialized by  *	TclEmitForwardJump.  *  * Results:  *	1 if the jump was grown and subsequent instructions had to be moved;  *	otherwise 0. This result is returned to allow callers to update  *	any additional code offsets they may hold.  *  * Side effects:  *	The jump may be grown and subsequent instructions moved. If this  *	happens, the code offsets for any commands and any ExceptionRange  *	records	between the jump and the current code address will be  *	updated to reflect the moved code. Also, the bytecode instruction  *	array in the CompileEnv structure may be grown and reallocated.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclFixupForwardJump
parameter_list|(
name|envPtr
parameter_list|,
name|jumpFixupPtr
parameter_list|,
name|jumpDist
parameter_list|,
name|distThreshold
parameter_list|)
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Points to the CompileEnv structure that 				 * holds the resulting instruction. */
name|JumpFixup
modifier|*
name|jumpFixupPtr
decl_stmt|;
comment|/* Points to the JumpFixup structure that 				 * describes the forward jump. */
name|int
name|jumpDist
decl_stmt|;
comment|/* Jump distance to set in jump 				 * instruction. */
name|int
name|distThreshold
decl_stmt|;
comment|/* Maximum distance before the two byte 				 * jump is grown to five bytes. */
block|{
name|unsigned
name|char
modifier|*
name|jumpPc
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|firstCmd
decl_stmt|,
name|lastCmd
decl_stmt|,
name|firstRange
decl_stmt|,
name|lastRange
decl_stmt|,
name|k
decl_stmt|;
name|unsigned
name|int
name|numBytes
decl_stmt|;
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
if|if
condition|(
name|jumpDist
operator|>
name|MAX_JUMP_DIST
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nTclFixupForwardJump: bad jump distance %u\n"
argument_list|,
name|jumpDist
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"TclFixupForwardJump: bad jump distance"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*TCL_COMPILE_DEBUG*/
if|if
condition|(
name|jumpDist
operator|<=
name|distThreshold
condition|)
block|{
name|jumpPc
operator|=
operator|(
name|envPtr
operator|->
name|codeStart
operator|+
name|jumpFixupPtr
operator|->
name|codeOffset
operator|)
expr_stmt|;
switch|switch
condition|(
name|jumpFixupPtr
operator|->
name|jumpType
condition|)
block|{
case|case
name|TCL_UNCONDITIONAL_JUMP
case|:
name|TclUpdateInstInt1AtPc
argument_list|(
name|INST_JUMP1
argument_list|,
name|jumpDist
argument_list|,
name|jumpPc
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCL_TRUE_JUMP
case|:
name|TclUpdateInstInt1AtPc
argument_list|(
name|INST_JUMP_TRUE1
argument_list|,
name|jumpDist
argument_list|,
name|jumpPc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|TclUpdateInstInt1AtPc
argument_list|(
name|INST_JUMP_FALSE1
argument_list|,
name|jumpDist
argument_list|,
name|jumpPc
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
comment|/* no need to grow the jump */
block|}
comment|/*      * We must grow the jump then move subsequent instructions down.      */
name|TclEnsureCodeSpace
argument_list|(
literal|3
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* NB: might change code addresses! */
name|jumpPc
operator|=
operator|(
name|envPtr
operator|->
name|codeStart
operator|+
name|jumpFixupPtr
operator|->
name|codeOffset
operator|)
expr_stmt|;
for|for
control|(
name|numBytes
operator|=
name|envPtr
operator|->
name|codeNext
operator|-
name|jumpPc
operator|-
literal|2
operator|,
name|p
operator|=
name|jumpPc
operator|+
literal|2
operator|+
name|numBytes
operator|-
literal|1
init|;
name|numBytes
operator|>
literal|0
condition|;
name|numBytes
operator|--
operator|,
name|p
operator|--
control|)
block|{
name|p
index|[
literal|3
index|]
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
block|}
name|envPtr
operator|->
name|codeNext
operator|+=
literal|3
expr_stmt|;
name|jumpDist
operator|+=
literal|3
expr_stmt|;
switch|switch
condition|(
name|jumpFixupPtr
operator|->
name|jumpType
condition|)
block|{
case|case
name|TCL_UNCONDITIONAL_JUMP
case|:
name|TclUpdateInstInt4AtPc
argument_list|(
name|INST_JUMP4
argument_list|,
name|jumpDist
argument_list|,
name|jumpPc
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCL_TRUE_JUMP
case|:
name|TclUpdateInstInt4AtPc
argument_list|(
name|INST_JUMP_TRUE4
argument_list|,
name|jumpDist
argument_list|,
name|jumpPc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|TclUpdateInstInt4AtPc
argument_list|(
name|INST_JUMP_FALSE4
argument_list|,
name|jumpDist
argument_list|,
name|jumpPc
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*      * Adjust the code offsets for any commands and any ExceptionRange      * records between the jump and the current code address.      */
name|firstCmd
operator|=
name|jumpFixupPtr
operator|->
name|cmdIndex
expr_stmt|;
name|lastCmd
operator|=
operator|(
name|envPtr
operator|->
name|numCommands
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|firstCmd
operator|<
name|lastCmd
condition|)
block|{
for|for
control|(
name|k
operator|=
name|firstCmd
init|;
name|k
operator|<=
name|lastCmd
condition|;
name|k
operator|++
control|)
block|{
operator|(
name|envPtr
operator|->
name|cmdMapPtr
index|[
name|k
index|]
operator|)
operator|.
name|codeOffset
operator|+=
literal|3
expr_stmt|;
block|}
block|}
name|firstRange
operator|=
name|jumpFixupPtr
operator|->
name|excRangeIndex
expr_stmt|;
name|lastRange
operator|=
operator|(
name|envPtr
operator|->
name|excRangeArrayNext
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|firstRange
init|;
name|k
operator|<=
name|lastRange
condition|;
name|k
operator|++
control|)
block|{
name|ExceptionRange
modifier|*
name|rangePtr
init|=
operator|&
operator|(
name|envPtr
operator|->
name|excRangeArrayPtr
index|[
name|k
index|]
operator|)
decl_stmt|;
name|rangePtr
operator|->
name|codeOffset
operator|+=
literal|3
expr_stmt|;
switch|switch
condition|(
name|rangePtr
operator|->
name|type
condition|)
block|{
case|case
name|LOOP_EXCEPTION_RANGE
case|:
name|rangePtr
operator|->
name|breakOffset
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|rangePtr
operator|->
name|continueOffset
operator|!=
operator|-
literal|1
condition|)
block|{
name|rangePtr
operator|->
name|continueOffset
operator|+=
literal|3
expr_stmt|;
block|}
break|break;
case|case
name|CATCH_EXCEPTION_RANGE
case|:
name|rangePtr
operator|->
name|catchOffset
operator|+=
literal|3
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"TclFixupForwardJump: unrecognized ExceptionRange type %d\n"
argument_list|,
name|rangePtr
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
comment|/* the jump was grown */
block|}
end_function

end_unit

