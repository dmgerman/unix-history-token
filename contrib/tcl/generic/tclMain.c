begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclMain.c --  *  *	Main program for Tcl shells and other Tcl-based applications.  *  * Copyright (c) 1988-1994 The Regents of the University of California.  * Copyright (c) 1994-1996 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclMain.c 1.54 97/08/07 19:04:43  */
end_comment

begin_include
include|#
directive|include
file|"tcl.h"
end_include

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_comment
comment|/*  * The following code ensures that tclLink.c is linked whenever  * Tcl is linked.  Without this code there's no reference to the  * code in that file from anywhere in Tcl, so it may not be  * linked into the application.  */
end_comment

begin_function_decl
name|EXTERN
name|int
name|Tcl_LinkVar
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|tclDummyLinkVarPtr
function_decl|)
parameter_list|()
init|=
name|Tcl_LinkVar
function_decl|;
end_function_decl

begin_comment
comment|/*  * Declarations for various library procedures and variables (don't want  * to include tclPort.h here, because people might copy this file out of  * the Tcl source directory to make their own modified versions).  * Note:  "exit" should really be declared here, but there's no way to  * declare it without causing conflicts with other definitions elsewher  * on some systems, so it's better just to leave it out.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|isatty
name|_ANSI_ARGS_
argument_list|(
operator|(
name|int
name|fd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|strcpy
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|dst
operator|,
name|CONST
name|char
operator|*
name|src
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Interpreter for application. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|dumpFile
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Records where to dump memory allocation 				 * information. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|quitFlag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 means "checkmem" command was called, 				 * so the application should quit and dump 				 * memory allocation information. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Forward references for procedures defined later in this file:  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|CheckmemCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
name|argv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_Main --  *  *	Main program for tclsh and most other Tcl-based applications.  *  * Results:  *	None. This procedure never returns (it exits the process when  *	it's done.  *  * Side effects:  *	This procedure initializes the Tk world and then starts  *	interpreting commands;  almost anything could happen, depending  *	on the script being interpreted.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_Main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|appInitProc
parameter_list|)
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Array of argument strings. */
name|Tcl_AppInitProc
modifier|*
name|appInitProc
decl_stmt|;
comment|/* Application-specific initialization 				 * procedure to call after most 				 * initialization but before starting to 				 * execute commands. */
block|{
name|Tcl_Obj
modifier|*
name|prompt1NamePtr
init|=
name|NULL
decl_stmt|;
name|Tcl_Obj
modifier|*
name|prompt2NamePtr
init|=
name|NULL
decl_stmt|;
name|Tcl_Obj
modifier|*
name|resultPtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|commandPtr
init|=
name|NULL
decl_stmt|;
name|char
name|buffer
index|[
literal|1000
index|]
decl_stmt|,
modifier|*
name|args
decl_stmt|,
modifier|*
name|fileName
decl_stmt|,
modifier|*
name|bytes
decl_stmt|;
name|int
name|code
decl_stmt|,
name|gotPartial
decl_stmt|,
name|tty
decl_stmt|,
name|length
decl_stmt|;
name|int
name|exitCode
init|=
literal|0
decl_stmt|;
name|Tcl_Channel
name|inChannel
decl_stmt|,
name|outChannel
decl_stmt|,
name|errChannel
decl_stmt|;
name|Tcl_FindExecutable
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|interp
operator|=
name|Tcl_CreateInterp
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
name|Tcl_InitMemory
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"checkmem"
argument_list|,
name|CheckmemCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * Make command-line arguments available in the Tcl variables "argc"      * and "argv".  If the first argument doesn't start with a "-" then      * strip it off and use it as the name of a script file to process.      */
name|fileName
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|argc
operator|>
literal|1
operator|)
operator|&&
operator|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|)
condition|)
block|{
name|fileName
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
name|args
operator|=
name|Tcl_Merge
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
literal|"argv"
argument_list|,
name|args
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|TclFormatInt
argument_list|(
name|buffer
argument_list|,
name|argc
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
literal|"argc"
argument_list|,
name|buffer
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
literal|"argv0"
argument_list|,
operator|(
name|fileName
operator|!=
name|NULL
operator|)
condition|?
name|fileName
else|:
name|argv
index|[
literal|0
index|]
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
comment|/*      * Set the "tcl_interactive" variable.      */
name|tty
operator|=
name|isatty
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
literal|"tcl_interactive"
argument_list|,
operator|(
operator|(
name|fileName
operator|==
name|NULL
operator|)
operator|&&
name|tty
operator|)
condition|?
literal|"1"
else|:
literal|"0"
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
comment|/*      * Invoke application-specific initialization.      */
if|if
condition|(
call|(
modifier|*
name|appInitProc
call|)
argument_list|(
name|interp
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|errChannel
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|errChannel
condition|)
block|{
name|Tcl_Write
argument_list|(
name|errChannel
argument_list|,
literal|"application-specific initialization failed: "
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_Write
argument_list|(
name|errChannel
argument_list|,
name|interp
operator|->
name|result
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_Write
argument_list|(
name|errChannel
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * If a script file was specified then just source that file      * and quit.      */
if|if
condition|(
name|fileName
operator|!=
name|NULL
condition|)
block|{
name|code
operator|=
name|Tcl_EvalFile
argument_list|(
name|interp
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|TCL_OK
condition|)
block|{
name|errChannel
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|errChannel
condition|)
block|{
comment|/* 		 * The following statement guarantees that the errorInfo 		 * variable is set properly. 		 */
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|Tcl_Write
argument_list|(
name|errChannel
argument_list|,
name|Tcl_GetVar
argument_list|(
name|interp
argument_list|,
literal|"errorInfo"
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_Write
argument_list|(
name|errChannel
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|exitCode
operator|=
literal|1
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
comment|/*      * We're running interactively.  Source a user-specific startup      * file if the application specified one and if the file exists.      */
name|Tcl_SourceRCFile
argument_list|(
name|interp
argument_list|)
expr_stmt|;
comment|/*      * Process commands from stdin until there's an end-of-file.  Note      * that we need to fetch the standard channels again after every      * eval, since they may have been changed.      */
name|commandPtr
operator|=
name|Tcl_NewObj
argument_list|()
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|commandPtr
argument_list|)
expr_stmt|;
name|prompt1NamePtr
operator|=
name|Tcl_NewStringObj
argument_list|(
literal|"tcl_prompt1"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|prompt1NamePtr
argument_list|)
expr_stmt|;
name|prompt2NamePtr
operator|=
name|Tcl_NewStringObj
argument_list|(
literal|"tcl_prompt2"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|prompt2NamePtr
argument_list|)
expr_stmt|;
name|inChannel
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDIN
argument_list|)
expr_stmt|;
name|outChannel
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDOUT
argument_list|)
expr_stmt|;
name|gotPartial
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|tty
condition|)
block|{
name|Tcl_Obj
modifier|*
name|promptCmdPtr
decl_stmt|;
name|promptCmdPtr
operator|=
name|Tcl_ObjGetVar2
argument_list|(
name|interp
argument_list|,
operator|(
name|gotPartial
condition|?
name|prompt2NamePtr
else|:
name|prompt1NamePtr
operator|)
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|promptCmdPtr
operator|==
name|NULL
condition|)
block|{
name|defaultPrompt
label|:
if|if
condition|(
operator|!
name|gotPartial
operator|&&
name|outChannel
condition|)
block|{
name|Tcl_Write
argument_list|(
name|outChannel
argument_list|,
literal|"% "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|code
operator|=
name|Tcl_EvalObj
argument_list|(
name|interp
argument_list|,
name|promptCmdPtr
argument_list|)
expr_stmt|;
name|inChannel
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDIN
argument_list|)
expr_stmt|;
name|outChannel
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDOUT
argument_list|)
expr_stmt|;
name|errChannel
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|errChannel
condition|)
block|{
name|resultPtr
operator|=
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|resultPtr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|Tcl_Write
argument_list|(
name|errChannel
argument_list|,
name|bytes
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Tcl_Write
argument_list|(
name|errChannel
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
literal|"\n    (script that generates prompt)"
argument_list|)
expr_stmt|;
goto|goto
name|defaultPrompt
goto|;
block|}
block|}
if|if
condition|(
name|outChannel
condition|)
block|{
name|Tcl_Flush
argument_list|(
name|outChannel
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|inChannel
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|length
operator|=
name|Tcl_GetsObj
argument_list|(
name|inChannel
argument_list|,
name|commandPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|length
operator|==
literal|0
operator|)
operator|&&
name|Tcl_Eof
argument_list|(
name|inChannel
argument_list|)
operator|&&
operator|(
operator|!
name|gotPartial
operator|)
condition|)
block|{
goto|goto
name|done
goto|;
block|}
comment|/*          * Add the newline removed by Tcl_GetsObj back to the string.          */
name|Tcl_AppendToObj
argument_list|(
name|commandPtr
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TclObjCommandComplete
argument_list|(
name|commandPtr
argument_list|)
condition|)
block|{
name|gotPartial
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|gotPartial
operator|=
literal|0
expr_stmt|;
name|code
operator|=
name|Tcl_RecordAndEvalObj
argument_list|(
name|interp
argument_list|,
name|commandPtr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inChannel
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDIN
argument_list|)
expr_stmt|;
name|outChannel
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDOUT
argument_list|)
expr_stmt|;
name|errChannel
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDERR
argument_list|)
expr_stmt|;
name|Tcl_SetObjLength
argument_list|(
name|commandPtr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|errChannel
condition|)
block|{
name|resultPtr
operator|=
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|resultPtr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|Tcl_Write
argument_list|(
name|errChannel
argument_list|,
name|bytes
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Tcl_Write
argument_list|(
name|errChannel
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tty
condition|)
block|{
name|resultPtr
operator|=
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|resultPtr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|length
operator|>
literal|0
operator|)
operator|&&
name|outChannel
condition|)
block|{
name|Tcl_Write
argument_list|(
name|outChannel
argument_list|,
name|bytes
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Tcl_Write
argument_list|(
name|outChannel
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
if|if
condition|(
name|quitFlag
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|commandPtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|prompt1NamePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|prompt2NamePtr
argument_list|)
expr_stmt|;
name|Tcl_DeleteInterp
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_Exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/*      * Rather than calling exit, invoke the "exit" command so that      * users can replace "exit" with some other command to do additional      * cleanup on exit.  The Tcl_Eval call should never return.      */
name|done
label|:
if|if
condition|(
name|commandPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|commandPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prompt1NamePtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|prompt1NamePtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prompt2NamePtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|prompt2NamePtr
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"exit %d"
argument_list|,
name|exitCode
argument_list|)
expr_stmt|;
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CheckmemCmd --  *  *	This is the command procedure for the "checkmem" command, which  *	causes the application to exit after printing information about  *	memory usage to the file passed to this command as its first  *	argument.  *  * Results:  *	Returns a standard Tcl completion code.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
end_ifdef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|CheckmemCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter for evaluation. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
comment|/* String values of arguments. */
block|{
specifier|extern
name|char
modifier|*
name|tclMemDumpFileName
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" fileName\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|strcpy
argument_list|(
name|dumpFile
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|tclMemDumpFileName
operator|=
name|dumpFile
expr_stmt|;
name|quitFlag
operator|=
literal|1
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

