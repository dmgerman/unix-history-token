begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclNotify.c --  *  *	This file provides the parts of the Tcl event notifier that are  *	the same on all platforms, plus a few other parts that are used  *	on more than one platform but not all.  *  *	The notifier is the lowest-level part of the event system.  It  *	manages an event queue that holds Tcl_Event structures and a list  *	of event sources that can add events to the queue.  It also  *	contains the procedure Tcl_DoOneEvent that invokes the event  *	sources and blocks to wait for new events, but Tcl_DoOneEvent  *	is in the platform-specific part of the notifier (in files like  *	tclUnixNotify.c).  *  * Copyright (c) 1995 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclNotify.c 1.6 96/02/29 09:20:10  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * The following variable records the address of the first event  * source in the list of all event sources for the application.  * This variable is accessed by the notifier to traverse the list  * and invoke each event source.  */
end_comment

begin_decl_stmt
name|TclEventSource
modifier|*
name|tclFirstEventSourcePtr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The following variables indicate how long to block in the event  * notifier the next time it blocks (default:  block forever).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|blockTimeSet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 means there is no maximum block 				 * time:  block forever. */
end_comment

begin_decl_stmt
specifier|static
name|Tcl_Time
name|blockTime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If blockTimeSet is 1, gives the 				 * maximum elapsed time for the next block. */
end_comment

begin_comment
comment|/*  * The following variables keep track of the event queue.  In addition  * to the first (next to be serviced) and last events in the queue,  * we keep track of a "marker" event.  This provides a simple priority  * mechanism whereby events can be inserted at the front of the queue  * but behind all other high-priority events already in the queue (this  * is used for things like a sequence of Enter and Leave events generated  * during a grab in Tk).  */
end_comment

begin_decl_stmt
specifier|static
name|Tcl_Event
modifier|*
name|firstEventPtr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First pending event, or NULL if none. */
end_comment

begin_decl_stmt
specifier|static
name|Tcl_Event
modifier|*
name|lastEventPtr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last pending event, or NULL if none. */
end_comment

begin_decl_stmt
specifier|static
name|Tcl_Event
modifier|*
name|markerEventPtr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last high-priority event in queue, or 				 * NULL if none. */
end_comment

begin_comment
comment|/*  * Prototypes for procedures used only in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ServiceEvent
name|_ANSI_ARGS_
argument_list|(
operator|(
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CreateEventSource --  *  *	This procedure is invoked to create a new source of events.  *	The source is identified by a procedure that gets invoked  *	during Tcl_DoOneEvent to check for events on that source  *	and queue them.  *  *  * Results:  *	None.  *  * Side effects:  *	SetupProc and checkProc will be invoked each time that Tcl_DoOneEvent  *	runs out of things to do.  SetupProc will be invoked before  *	Tcl_DoOneEvent calls select or whatever else it uses to wait  *	for events.  SetupProc typically calls functions like Tcl_WatchFile  *	or Tcl_SetMaxBlockTime to indicate what to wait for.  *  *	CheckProc is called after select or whatever operation was actually  *	used to wait.  It figures out whether anything interesting actually  *	happened (e.g. by calling Tcl_FileReady), and then calls  *	Tcl_QueueEvent to queue any events that are ready.  *  *	Each of these procedures is passed two arguments, e.g.  *		(*checkProc)(ClientData clientData, int flags));  *	ClientData is the same as the clientData argument here, and flags  *	is a combination of things like TCL_FILE_EVENTS that indicates  *	what events are of interest:  setupProc and checkProc use flags  *	to figure out whether their events are relevant or not.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_CreateEventSource
parameter_list|(
name|setupProc
parameter_list|,
name|checkProc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_EventSetupProc
modifier|*
name|setupProc
decl_stmt|;
comment|/* Procedure to invoke to figure out 					 * what to wait for. */
name|Tcl_EventCheckProc
modifier|*
name|checkProc
decl_stmt|;
comment|/* Procedure to call after waiting 					 * to see what happened. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* One-word argument to pass to 					 * setupProc and checkProc. */
block|{
name|TclEventSource
modifier|*
name|sourcePtr
decl_stmt|;
name|sourcePtr
operator|=
operator|(
name|TclEventSource
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TclEventSource
argument_list|)
argument_list|)
expr_stmt|;
name|sourcePtr
operator|->
name|setupProc
operator|=
name|setupProc
expr_stmt|;
name|sourcePtr
operator|->
name|checkProc
operator|=
name|checkProc
expr_stmt|;
name|sourcePtr
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
name|sourcePtr
operator|->
name|nextPtr
operator|=
name|tclFirstEventSourcePtr
expr_stmt|;
name|tclFirstEventSourcePtr
operator|=
name|sourcePtr
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DeleteEventSource --  *  *	This procedure is invoked to delete the source of events  *	given by proc and clientData.  *  * Results:  *	None.  *  * Side effects:  *	The given event source is cancelled, so its procedure will  *	never again be called.  If no such source exists, nothing  *	happens.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DeleteEventSource
parameter_list|(
name|setupProc
parameter_list|,
name|checkProc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_EventSetupProc
modifier|*
name|setupProc
decl_stmt|;
comment|/* Procedure to invoke to figure out 					 * what to wait for. */
name|Tcl_EventCheckProc
modifier|*
name|checkProc
decl_stmt|;
comment|/* Procedure to call after waiting 					 * to see what happened. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* One-word argument to pass to 					 * setupProc and checkProc. */
block|{
name|TclEventSource
modifier|*
name|sourcePtr
decl_stmt|,
modifier|*
name|prevPtr
decl_stmt|;
for|for
control|(
name|sourcePtr
operator|=
name|tclFirstEventSourcePtr
operator|,
name|prevPtr
operator|=
name|NULL
init|;
name|sourcePtr
operator|!=
name|NULL
condition|;
name|prevPtr
operator|=
name|sourcePtr
operator|,
name|sourcePtr
operator|=
name|sourcePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
operator|(
name|sourcePtr
operator|->
name|setupProc
operator|!=
name|setupProc
operator|)
operator|||
operator|(
name|sourcePtr
operator|->
name|checkProc
operator|!=
name|checkProc
operator|)
operator|||
operator|(
name|sourcePtr
operator|->
name|clientData
operator|!=
name|clientData
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|prevPtr
operator|==
name|NULL
condition|)
block|{
name|tclFirstEventSourcePtr
operator|=
name|sourcePtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
name|prevPtr
operator|->
name|nextPtr
operator|=
name|sourcePtr
operator|->
name|nextPtr
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sourcePtr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_QueueEvent --  *  *	Insert an event into the Tk event queue at one of three  *	positions: the head, the tail, or before a floating marker.  *	Events inserted before the marker will be processed in  *	first-in-first-out order, but before any events inserted at  *	the tail of the queue.  Events inserted at the head of the  *	queue will be processed in last-in-first-out order.  *  * Results:  *	None.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_QueueEvent
parameter_list|(
name|evPtr
parameter_list|,
name|position
parameter_list|)
name|Tcl_Event
modifier|*
name|evPtr
decl_stmt|;
comment|/* Event to add to queue.  The storage 				 * space must have been allocated the caller 				 * with malloc (ckalloc), and it becomes 				 * the property of the event queue.  It 				 * will be freed after the event has been 				 * handled. */
name|Tcl_QueuePosition
name|position
decl_stmt|;
comment|/* One of TCL_QUEUE_TAIL, TCL_QUEUE_HEAD, 				 * TCL_QUEUE_MARK. */
block|{
if|if
condition|(
name|position
operator|==
name|TCL_QUEUE_TAIL
condition|)
block|{
comment|/* 	 * Append the event on the end of the queue. 	 */
name|evPtr
operator|->
name|nextPtr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|firstEventPtr
operator|==
name|NULL
condition|)
block|{
name|firstEventPtr
operator|=
name|evPtr
expr_stmt|;
block|}
else|else
block|{
name|lastEventPtr
operator|->
name|nextPtr
operator|=
name|evPtr
expr_stmt|;
block|}
name|lastEventPtr
operator|=
name|evPtr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|position
operator|==
name|TCL_QUEUE_HEAD
condition|)
block|{
comment|/* 	 * Push the event on the head of the queue. 	 */
name|evPtr
operator|->
name|nextPtr
operator|=
name|firstEventPtr
expr_stmt|;
if|if
condition|(
name|firstEventPtr
operator|==
name|NULL
condition|)
block|{
name|lastEventPtr
operator|=
name|evPtr
expr_stmt|;
block|}
name|firstEventPtr
operator|=
name|evPtr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|position
operator|==
name|TCL_QUEUE_MARK
condition|)
block|{
comment|/* 	 * Insert the event after the current marker event and advance 	 * the marker to the new event. 	 */
if|if
condition|(
name|markerEventPtr
operator|==
name|NULL
condition|)
block|{
name|evPtr
operator|->
name|nextPtr
operator|=
name|firstEventPtr
expr_stmt|;
name|firstEventPtr
operator|=
name|evPtr
expr_stmt|;
block|}
else|else
block|{
name|evPtr
operator|->
name|nextPtr
operator|=
name|markerEventPtr
operator|->
name|nextPtr
expr_stmt|;
name|markerEventPtr
operator|->
name|nextPtr
operator|=
name|evPtr
expr_stmt|;
block|}
name|markerEventPtr
operator|=
name|evPtr
expr_stmt|;
if|if
condition|(
name|evPtr
operator|->
name|nextPtr
operator|==
name|NULL
condition|)
block|{
name|lastEventPtr
operator|=
name|evPtr
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DeleteEvents --  *  *	Calls a procedure for each event in the queue and deletes those  *	for which the procedure returns 1. Events for which the  *	procedure returns 0 are left in the queue.  *  * Results:  *	None.  *  * Side effects:  *	Potentially removes one or more events from the event queue.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DeleteEvents
parameter_list|(
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_EventDeleteProc
modifier|*
name|proc
decl_stmt|;
comment|/* The procedure to call. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* type-specific data. */
block|{
name|Tcl_Event
modifier|*
name|evPtr
decl_stmt|,
modifier|*
name|prevPtr
decl_stmt|,
modifier|*
name|hold
decl_stmt|;
for|for
control|(
name|prevPtr
operator|=
operator|(
name|Tcl_Event
operator|*
operator|)
name|NULL
operator|,
name|evPtr
operator|=
name|firstEventPtr
init|;
name|evPtr
operator|!=
operator|(
name|Tcl_Event
operator|*
operator|)
name|NULL
condition|;
control|)
block|{
if|if
condition|(
call|(
modifier|*
name|proc
call|)
argument_list|(
name|evPtr
argument_list|,
name|clientData
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|firstEventPtr
operator|==
name|evPtr
condition|)
block|{
name|firstEventPtr
operator|=
name|evPtr
operator|->
name|nextPtr
expr_stmt|;
if|if
condition|(
name|evPtr
operator|->
name|nextPtr
operator|==
operator|(
name|Tcl_Event
operator|*
operator|)
name|NULL
condition|)
block|{
name|lastEventPtr
operator|=
operator|(
name|Tcl_Event
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|prevPtr
operator|->
name|nextPtr
operator|=
name|evPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
name|hold
operator|=
name|evPtr
expr_stmt|;
name|evPtr
operator|=
name|evPtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hold
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prevPtr
operator|=
name|evPtr
expr_stmt|;
name|evPtr
operator|=
name|evPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * ServiceEvent --  *  *	Process one event from the event queue.  This routine is called  *	by the notifier whenever it wants Tk to process an event.    *  * Results:  *	The return value is 1 if the procedure actually found an event  *	to process.  If no processing occurred, then 0 is returned.  *  * Side effects:  *	Invokes all of the event handlers for the highest priority  *	event in the event queue.  May collapse some events into a  *	single event or discard stale events.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ServiceEvent
parameter_list|(
name|flags
parameter_list|)
name|int
name|flags
decl_stmt|;
comment|/* Indicates what events should be processed. 				 * May be any combination of TCL_WINDOW_EVENTS 				 * TCL_FILE_EVENTS, TCL_TIMER_EVENTS, or other 				 * flags defined elsewhere.  Events not 				 * matching this will be skipped for processing 				 * later. */
block|{
name|Tcl_Event
modifier|*
name|evPtr
decl_stmt|,
modifier|*
name|prevPtr
decl_stmt|;
name|Tcl_EventProc
modifier|*
name|proc
decl_stmt|;
comment|/*      * No event flags is equivalent to TCL_ALL_EVENTS.      */
if|if
condition|(
operator|(
name|flags
operator|&
name|TCL_ALL_EVENTS
operator|)
operator|==
literal|0
condition|)
block|{
name|flags
operator||=
name|TCL_ALL_EVENTS
expr_stmt|;
block|}
comment|/*      * Loop through all the events in the queue until we find one      * that can actually be handled.      */
for|for
control|(
name|evPtr
operator|=
name|firstEventPtr
init|;
name|evPtr
operator|!=
name|NULL
condition|;
name|evPtr
operator|=
name|evPtr
operator|->
name|nextPtr
control|)
block|{
comment|/* 	 * Call the handler for the event.  If it actually handles the 	 * event then free the storage for the event.  There are two 	 * tricky things here, but stemming from the fact that the event 	 * code may be re-entered while servicing the event: 	 * 	 * 1. Set the "proc" field to NULL.  This is a signal to ourselves 	 *    that we shouldn't reexecute the handler if the event loop 	 *    is re-entered. 	 * 2. When freeing the event, must search the queue again from the 	 *    front to find it.  This is because the event queue could 	 *    change almost arbitrarily while handling the event, so we 	 *    can't depend on pointers found now still being valid when 	 *    the handler returns. 	 */
name|proc
operator|=
name|evPtr
operator|->
name|proc
expr_stmt|;
name|evPtr
operator|->
name|proc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|proc
operator|!=
name|NULL
operator|)
operator|&&
call|(
modifier|*
name|proc
call|)
argument_list|(
name|evPtr
argument_list|,
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|firstEventPtr
operator|==
name|evPtr
condition|)
block|{
name|firstEventPtr
operator|=
name|evPtr
operator|->
name|nextPtr
expr_stmt|;
if|if
condition|(
name|evPtr
operator|->
name|nextPtr
operator|==
name|NULL
condition|)
block|{
name|lastEventPtr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|prevPtr
operator|=
name|firstEventPtr
init|;
name|prevPtr
operator|->
name|nextPtr
operator|!=
name|evPtr
condition|;
name|prevPtr
operator|=
name|prevPtr
operator|->
name|nextPtr
control|)
block|{
comment|/* Empty loop body. */
block|}
name|prevPtr
operator|->
name|nextPtr
operator|=
name|evPtr
operator|->
name|nextPtr
expr_stmt|;
if|if
condition|(
name|evPtr
operator|->
name|nextPtr
operator|==
name|NULL
condition|)
block|{
name|lastEventPtr
operator|=
name|prevPtr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|markerEventPtr
operator|==
name|evPtr
condition|)
block|{
name|markerEventPtr
operator|=
name|NULL
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|evPtr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* 	     * The event wasn't actually handled, so we have to restore 	     * the proc field to allow the event to be attempted again. 	     */
name|evPtr
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
block|}
comment|/* 	 * The handler for this event asked to defer it.  Just go on to 	 * the next event. 	 */
continue|continue;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetMaxBlockTime --  *  *	This procedure is invoked by event sources to tell the notifier  *	how long it may block the next time it blocks.  The timePtr  *	argument gives a maximum time;  the actual time may be less if  *	some other event source requested a smaller time.  *  * Results:  *	None.  *  * Side effects:  *	May reduce the length of the next sleep in the notifier.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_SetMaxBlockTime
parameter_list|(
name|timePtr
parameter_list|)
name|Tcl_Time
modifier|*
name|timePtr
decl_stmt|;
comment|/* Specifies a maximum elapsed time for 				 * the next blocking operation in the 				 * event notifier. */
block|{
if|if
condition|(
operator|!
name|blockTimeSet
operator|||
operator|(
name|timePtr
operator|->
name|sec
operator|<
name|blockTime
operator|.
name|sec
operator|)
operator|||
operator|(
operator|(
name|timePtr
operator|->
name|sec
operator|==
name|blockTime
operator|.
name|sec
operator|)
operator|&&
operator|(
name|timePtr
operator|->
name|usec
operator|<
name|blockTime
operator|.
name|usec
operator|)
operator|)
condition|)
block|{
name|blockTime
operator|=
operator|*
name|timePtr
expr_stmt|;
name|blockTimeSet
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DoOneEvent --  *  *	Process a single event of some sort.  If there's no work to  *	do, wait for an event to occur, then process it.  *  * Results:  *	The return value is 1 if the procedure actually found an event  *	to process.  If no processing occurred, then 0 is returned (this  *	can happen if the TCL_DONT_WAIT flag is set or if there are no  *	event handlers to wait for in the set specified by flags).  *  * Side effects:  *	May delay execution of process while waiting for an event,  *	unless TCL_DONT_WAIT is set in the flags argument.  Event  *	sources are invoked to check for and queue events.  Event  *	handlers may produce arbitrary side effects.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_DoOneEvent
parameter_list|(
name|flags
parameter_list|)
name|int
name|flags
decl_stmt|;
comment|/* Miscellaneous flag values:  may be any 				 * combination of TCL_DONT_WAIT, 				 * TCL_WINDOW_EVENTS, TCL_FILE_EVENTS, 				 * TCL_TIMER_EVENTS, TCL_IDLE_EVENTS, or 				 * others defined by event sources. */
block|{
name|TclEventSource
modifier|*
name|sourcePtr
decl_stmt|;
name|Tcl_Time
modifier|*
name|timePtr
decl_stmt|;
comment|/*      * No event flags is equivalent to TCL_ALL_EVENTS.      */
if|if
condition|(
operator|(
name|flags
operator|&
name|TCL_ALL_EVENTS
operator|)
operator|==
literal|0
condition|)
block|{
name|flags
operator||=
name|TCL_ALL_EVENTS
expr_stmt|;
block|}
comment|/*      * The core of this procedure is an infinite loop, even though      * we only service one event.  The reason for this is that we      * might think we have an event ready (e.g. the connection to      * the server becomes readable), but then we might discover that      * there's nothing interesting on that connection, so no event      * was serviced.  Or, the select operation could return prematurely      * due to a signal.  The easiest thing in both these cases is      * just to loop back and try again.      */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* 	 * The first thing we do is to service any asynchronous event 	 * handlers. 	 */
if|if
condition|(
name|Tcl_AsyncReady
argument_list|()
condition|)
block|{
operator|(
name|void
operator|)
name|Tcl_AsyncInvoke
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * If idle events are the only things to service, skip the 	 * main part of the loop and go directly to handle idle 	 * events (i.e. don't wait even if TCL_DONT_WAIT isn't set. 	 */
if|if
condition|(
name|flags
operator|==
name|TCL_IDLE_EVENTS
condition|)
block|{
name|flags
operator|=
name|TCL_IDLE_EVENTS
operator||
name|TCL_DONT_WAIT
expr_stmt|;
goto|goto
name|idleEvents
goto|;
block|}
comment|/* 	 * Ask Tk to service a queued event, if there are any. 	 */
if|if
condition|(
name|ServiceEvent
argument_list|(
name|flags
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|/* 	 * There are no events already queued.  Invoke all of the 	 * event sources to give them a chance to setup for the wait. 	 */
name|blockTimeSet
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sourcePtr
operator|=
name|tclFirstEventSourcePtr
init|;
name|sourcePtr
operator|!=
name|NULL
condition|;
name|sourcePtr
operator|=
name|sourcePtr
operator|->
name|nextPtr
control|)
block|{
call|(
modifier|*
name|sourcePtr
operator|->
name|setupProc
call|)
argument_list|(
name|sourcePtr
operator|->
name|clientData
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|TCL_DONT_WAIT
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|TCL_IDLE_EVENTS
operator|)
operator|&&
name|TclIdlePending
argument_list|()
operator|)
condition|)
block|{
comment|/* 	     * Don't block:  there are idle events waiting, or we don't 	     * care about idle events anyway, or the caller asked us not 	     * to block. 	     */
name|blockTime
operator|.
name|sec
operator|=
literal|0
expr_stmt|;
name|blockTime
operator|.
name|usec
operator|=
literal|0
expr_stmt|;
name|timePtr
operator|=
operator|&
name|blockTime
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|blockTimeSet
condition|)
block|{
name|timePtr
operator|=
operator|&
name|blockTime
expr_stmt|;
block|}
else|else
block|{
name|timePtr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Wait until an event occurs or the timer expires. 	 */
if|if
condition|(
name|Tcl_WaitForEvent
argument_list|(
name|timePtr
argument_list|)
operator|==
name|TCL_ERROR
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* 	 * Give each of the event sources a chance to queue events, 	 * then call ServiceEvent and give it another chance to 	 * service events. 	 */
for|for
control|(
name|sourcePtr
operator|=
name|tclFirstEventSourcePtr
init|;
name|sourcePtr
operator|!=
name|NULL
condition|;
name|sourcePtr
operator|=
name|sourcePtr
operator|->
name|nextPtr
control|)
block|{
call|(
modifier|*
name|sourcePtr
operator|->
name|checkProc
call|)
argument_list|(
name|sourcePtr
operator|->
name|clientData
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ServiceEvent
argument_list|(
name|flags
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|/* 	 * We've tried everything at this point, but nobody had anything 	 * to do.  Check for idle events.  If none, either quit or go back 	 * to the top and try again. 	 */
name|idleEvents
label|:
if|if
condition|(
operator|(
name|flags
operator|&
name|TCL_IDLE_EVENTS
operator|)
operator|&&
name|TclServiceIdle
argument_list|()
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|TCL_DONT_WAIT
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

end_unit

