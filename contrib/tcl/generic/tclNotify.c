begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclNotify.c --  *  *	This file implements the generic portion of the Tcl notifier.  *	The notifier is lowest-level part of the event system.  It  *	manages an event queue that holds Tcl_Event structures.  The  *	platform specific portion of the notifier is defined in the  *	tcl*Notify.c files in each platform directory.  *  * Copyright (c) 1995-1997 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclNotify.c 1.16 97/09/15 15:12:52  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * The following static indicates whether this module has been initialized.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * For each event source (created with Tcl_CreateEventSource) there  * is a structure of the following type:  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|EventSource
block|{
name|Tcl_EventSetupProc
modifier|*
name|setupProc
decl_stmt|;
name|Tcl_EventCheckProc
modifier|*
name|checkProc
decl_stmt|;
name|ClientData
name|clientData
decl_stmt|;
name|struct
name|EventSource
modifier|*
name|nextPtr
decl_stmt|;
block|}
name|EventSource
typedef|;
end_typedef

begin_comment
comment|/*  * The following structure keeps track of the state of the notifier.  * The first three elements keep track of the event queue.  In addition to  * the first (next to be serviced) and last events in the queue, we keep  * track of a "marker" event.  This provides a simple priority mechanism  * whereby events can be inserted at the front of the queue but behind all  * other high-priority events already in the queue (this is used for things  * like a sequence of Enter and Leave events generated during a grab in  * Tk).  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|Tcl_Event
modifier|*
name|firstEventPtr
decl_stmt|;
comment|/* First pending event, or NULL if none. */
name|Tcl_Event
modifier|*
name|lastEventPtr
decl_stmt|;
comment|/* Last pending event, or NULL if none. */
name|Tcl_Event
modifier|*
name|markerEventPtr
decl_stmt|;
comment|/* Last high-priority event in queue, or 				 * NULL if none. */
name|int
name|serviceMode
decl_stmt|;
comment|/* One of TCL_SERVICE_NONE or 				 * TCL_SERVICE_ALL. */
name|int
name|blockTimeSet
decl_stmt|;
comment|/* 0 means there is no maximum block 				 * time:  block forever. */
name|Tcl_Time
name|blockTime
decl_stmt|;
comment|/* If blockTimeSet is 1, gives the 				 * maximum elapsed time for the next block. */
name|int
name|inTraversal
decl_stmt|;
comment|/* 1 if Tcl_SetMaxBlockTime is being 				 * called during an event source traversal. */
name|EventSource
modifier|*
name|firstEventSourcePtr
decl_stmt|;
comment|/* Pointer to first event source in 				 * global list of event sources. */
block|}
name|notifier
struct|;
end_struct

begin_comment
comment|/*  * Declarations for functions used in this file.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|InitNotifier
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|NotifierExitHandler
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InitNotifier --  *  *	This routine is called to initialize the notifier module.  *  * Results:  *	None.  *  * Side effects:  *	Creates an exit handler and initializes static data.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|InitNotifier
parameter_list|()
block|{
name|initialized
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|notifier
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|notifier
argument_list|)
argument_list|)
expr_stmt|;
name|notifier
operator|.
name|serviceMode
operator|=
name|TCL_SERVICE_NONE
expr_stmt|;
name|Tcl_CreateExitHandler
argument_list|(
name|NotifierExitHandler
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * NotifierExitHandler --  *  *	This routine is called during Tcl finalization.  *  * Results:  *	None.  *  * Side effects:  *	Clears the notifier intialization flag.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|NotifierExitHandler
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
block|{
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CreateEventSource --  *  *	This procedure is invoked to create a new source of events.  *	The source is identified by a procedure that gets invoked  *	during Tcl_DoOneEvent to check for events on that source  *	and queue them.  *  *  * Results:  *	None.  *  * Side effects:  *	SetupProc and checkProc will be invoked each time that Tcl_DoOneEvent  *	runs out of things to do.  SetupProc will be invoked before  *	Tcl_DoOneEvent calls select or whatever else it uses to wait  *	for events.  SetupProc typically calls functions like Tcl_WatchFile  *	or Tcl_SetMaxBlockTime to indicate what to wait for.  *  *	CheckProc is called after select or whatever operation was actually  *	used to wait.  It figures out whether anything interesting actually  *	happened (e.g. by calling Tcl_FileReady), and then calls  *	Tcl_QueueEvent to queue any events that are ready.  *  *	Each of these procedures is passed two arguments, e.g.  *		(*checkProc)(ClientData clientData, int flags));  *	ClientData is the same as the clientData argument here, and flags  *	is a combination of things like TCL_FILE_EVENTS that indicates  *	what events are of interest:  setupProc and checkProc use flags  *	to figure out whether their events are relevant or not.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_CreateEventSource
parameter_list|(
name|setupProc
parameter_list|,
name|checkProc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_EventSetupProc
modifier|*
name|setupProc
decl_stmt|;
comment|/* Procedure to invoke to figure out 					 * what to wait for. */
name|Tcl_EventCheckProc
modifier|*
name|checkProc
decl_stmt|;
comment|/* Procedure to call after waiting 					 * to see what happened. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* One-word argument to pass to 					 * setupProc and checkProc. */
block|{
name|EventSource
modifier|*
name|sourcePtr
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|InitNotifier
argument_list|()
expr_stmt|;
block|}
name|sourcePtr
operator|=
operator|(
name|EventSource
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|EventSource
argument_list|)
argument_list|)
expr_stmt|;
name|sourcePtr
operator|->
name|setupProc
operator|=
name|setupProc
expr_stmt|;
name|sourcePtr
operator|->
name|checkProc
operator|=
name|checkProc
expr_stmt|;
name|sourcePtr
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
name|sourcePtr
operator|->
name|nextPtr
operator|=
name|notifier
operator|.
name|firstEventSourcePtr
expr_stmt|;
name|notifier
operator|.
name|firstEventSourcePtr
operator|=
name|sourcePtr
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DeleteEventSource --  *  *	This procedure is invoked to delete the source of events  *	given by proc and clientData.  *  * Results:  *	None.  *  * Side effects:  *	The given event source is cancelled, so its procedure will  *	never again be called.  If no such source exists, nothing  *	happens.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DeleteEventSource
parameter_list|(
name|setupProc
parameter_list|,
name|checkProc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_EventSetupProc
modifier|*
name|setupProc
decl_stmt|;
comment|/* Procedure to invoke to figure out 					 * what to wait for. */
name|Tcl_EventCheckProc
modifier|*
name|checkProc
decl_stmt|;
comment|/* Procedure to call after waiting 					 * to see what happened. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* One-word argument to pass to 					 * setupProc and checkProc. */
block|{
name|EventSource
modifier|*
name|sourcePtr
decl_stmt|,
modifier|*
name|prevPtr
decl_stmt|;
for|for
control|(
name|sourcePtr
operator|=
name|notifier
operator|.
name|firstEventSourcePtr
operator|,
name|prevPtr
operator|=
name|NULL
init|;
name|sourcePtr
operator|!=
name|NULL
condition|;
name|prevPtr
operator|=
name|sourcePtr
operator|,
name|sourcePtr
operator|=
name|sourcePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
operator|(
name|sourcePtr
operator|->
name|setupProc
operator|!=
name|setupProc
operator|)
operator|||
operator|(
name|sourcePtr
operator|->
name|checkProc
operator|!=
name|checkProc
operator|)
operator|||
operator|(
name|sourcePtr
operator|->
name|clientData
operator|!=
name|clientData
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|prevPtr
operator|==
name|NULL
condition|)
block|{
name|notifier
operator|.
name|firstEventSourcePtr
operator|=
name|sourcePtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
name|prevPtr
operator|->
name|nextPtr
operator|=
name|sourcePtr
operator|->
name|nextPtr
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sourcePtr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_QueueEvent --  *  *	Insert an event into the Tk event queue at one of three  *	positions: the head, the tail, or before a floating marker.  *	Events inserted before the marker will be processed in  *	first-in-first-out order, but before any events inserted at  *	the tail of the queue.  Events inserted at the head of the  *	queue will be processed in last-in-first-out order.  *  * Results:  *	None.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_QueueEvent
parameter_list|(
name|evPtr
parameter_list|,
name|position
parameter_list|)
name|Tcl_Event
modifier|*
name|evPtr
decl_stmt|;
comment|/* Event to add to queue.  The storage 				 * space must have been allocated the caller 				 * with malloc (ckalloc), and it becomes 				 * the property of the event queue.  It 				 * will be freed after the event has been 				 * handled. */
name|Tcl_QueuePosition
name|position
decl_stmt|;
comment|/* One of TCL_QUEUE_TAIL, TCL_QUEUE_HEAD, 				 * TCL_QUEUE_MARK. */
block|{
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|InitNotifier
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|position
operator|==
name|TCL_QUEUE_TAIL
condition|)
block|{
comment|/* 	 * Append the event on the end of the queue. 	 */
name|evPtr
operator|->
name|nextPtr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|notifier
operator|.
name|firstEventPtr
operator|==
name|NULL
condition|)
block|{
name|notifier
operator|.
name|firstEventPtr
operator|=
name|evPtr
expr_stmt|;
block|}
else|else
block|{
name|notifier
operator|.
name|lastEventPtr
operator|->
name|nextPtr
operator|=
name|evPtr
expr_stmt|;
block|}
name|notifier
operator|.
name|lastEventPtr
operator|=
name|evPtr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|position
operator|==
name|TCL_QUEUE_HEAD
condition|)
block|{
comment|/* 	 * Push the event on the head of the queue. 	 */
name|evPtr
operator|->
name|nextPtr
operator|=
name|notifier
operator|.
name|firstEventPtr
expr_stmt|;
if|if
condition|(
name|notifier
operator|.
name|firstEventPtr
operator|==
name|NULL
condition|)
block|{
name|notifier
operator|.
name|lastEventPtr
operator|=
name|evPtr
expr_stmt|;
block|}
name|notifier
operator|.
name|firstEventPtr
operator|=
name|evPtr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|position
operator|==
name|TCL_QUEUE_MARK
condition|)
block|{
comment|/* 	 * Insert the event after the current marker event and advance 	 * the marker to the new event. 	 */
if|if
condition|(
name|notifier
operator|.
name|markerEventPtr
operator|==
name|NULL
condition|)
block|{
name|evPtr
operator|->
name|nextPtr
operator|=
name|notifier
operator|.
name|firstEventPtr
expr_stmt|;
name|notifier
operator|.
name|firstEventPtr
operator|=
name|evPtr
expr_stmt|;
block|}
else|else
block|{
name|evPtr
operator|->
name|nextPtr
operator|=
name|notifier
operator|.
name|markerEventPtr
operator|->
name|nextPtr
expr_stmt|;
name|notifier
operator|.
name|markerEventPtr
operator|->
name|nextPtr
operator|=
name|evPtr
expr_stmt|;
block|}
name|notifier
operator|.
name|markerEventPtr
operator|=
name|evPtr
expr_stmt|;
if|if
condition|(
name|evPtr
operator|->
name|nextPtr
operator|==
name|NULL
condition|)
block|{
name|notifier
operator|.
name|lastEventPtr
operator|=
name|evPtr
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DeleteEvents --  *  *	Calls a procedure for each event in the queue and deletes those  *	for which the procedure returns 1. Events for which the  *	procedure returns 0 are left in the queue.  *  * Results:  *	None.  *  * Side effects:  *	Potentially removes one or more events from the event queue.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DeleteEvents
parameter_list|(
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_EventDeleteProc
modifier|*
name|proc
decl_stmt|;
comment|/* The procedure to call. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* type-specific data. */
block|{
name|Tcl_Event
modifier|*
name|evPtr
decl_stmt|,
modifier|*
name|prevPtr
decl_stmt|,
modifier|*
name|hold
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|InitNotifier
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|prevPtr
operator|=
operator|(
name|Tcl_Event
operator|*
operator|)
name|NULL
operator|,
name|evPtr
operator|=
name|notifier
operator|.
name|firstEventPtr
init|;
name|evPtr
operator|!=
operator|(
name|Tcl_Event
operator|*
operator|)
name|NULL
condition|;
control|)
block|{
if|if
condition|(
call|(
modifier|*
name|proc
call|)
argument_list|(
name|evPtr
argument_list|,
name|clientData
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|notifier
operator|.
name|firstEventPtr
operator|==
name|evPtr
condition|)
block|{
name|notifier
operator|.
name|firstEventPtr
operator|=
name|evPtr
operator|->
name|nextPtr
expr_stmt|;
if|if
condition|(
name|evPtr
operator|->
name|nextPtr
operator|==
operator|(
name|Tcl_Event
operator|*
operator|)
name|NULL
condition|)
block|{
name|notifier
operator|.
name|lastEventPtr
operator|=
operator|(
name|Tcl_Event
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|prevPtr
operator|->
name|nextPtr
operator|=
name|evPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
name|hold
operator|=
name|evPtr
expr_stmt|;
name|evPtr
operator|=
name|evPtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hold
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prevPtr
operator|=
name|evPtr
expr_stmt|;
name|evPtr
operator|=
name|evPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ServiceEvent --  *  *	Process one event from the event queue, or invoke an  *	asynchronous event handler.  *  * Results:  *	The return value is 1 if the procedure actually found an event  *	to process.  If no processing occurred, then 0 is returned.  *  * Side effects:  *	Invokes all of the event handlers for the highest priority  *	event in the event queue.  May collapse some events into a  *	single event or discard stale events.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_ServiceEvent
parameter_list|(
name|flags
parameter_list|)
name|int
name|flags
decl_stmt|;
comment|/* Indicates what events should be processed. 				 * May be any combination of TCL_WINDOW_EVENTS 				 * TCL_FILE_EVENTS, TCL_TIMER_EVENTS, or other 				 * flags defined elsewhere.  Events not 				 * matching this will be skipped for processing 				 * later. */
block|{
name|Tcl_Event
modifier|*
name|evPtr
decl_stmt|,
modifier|*
name|prevPtr
decl_stmt|;
name|Tcl_EventProc
modifier|*
name|proc
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|InitNotifier
argument_list|()
expr_stmt|;
block|}
comment|/*      * Asynchronous event handlers are considered to be the highest      * priority events, and so must be invoked before we process events      * on the event queue.      */
if|if
condition|(
name|Tcl_AsyncReady
argument_list|()
condition|)
block|{
operator|(
name|void
operator|)
name|Tcl_AsyncInvoke
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/*      * No event flags is equivalent to TCL_ALL_EVENTS.      */
if|if
condition|(
operator|(
name|flags
operator|&
name|TCL_ALL_EVENTS
operator|)
operator|==
literal|0
condition|)
block|{
name|flags
operator||=
name|TCL_ALL_EVENTS
expr_stmt|;
block|}
comment|/*      * Loop through all the events in the queue until we find one      * that can actually be handled.      */
for|for
control|(
name|evPtr
operator|=
name|notifier
operator|.
name|firstEventPtr
init|;
name|evPtr
operator|!=
name|NULL
condition|;
name|evPtr
operator|=
name|evPtr
operator|->
name|nextPtr
control|)
block|{
comment|/* 	 * Call the handler for the event.  If it actually handles the 	 * event then free the storage for the event.  There are two 	 * tricky things here, but stemming from the fact that the event 	 * code may be re-entered while servicing the event: 	 * 	 * 1. Set the "proc" field to NULL.  This is a signal to ourselves 	 *    that we shouldn't reexecute the handler if the event loop 	 *    is re-entered. 	 * 2. When freeing the event, must search the queue again from the 	 *    front to find it.  This is because the event queue could 	 *    change almost arbitrarily while handling the event, so we 	 *    can't depend on pointers found now still being valid when 	 *    the handler returns. 	 */
name|proc
operator|=
name|evPtr
operator|->
name|proc
expr_stmt|;
name|evPtr
operator|->
name|proc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|proc
operator|!=
name|NULL
operator|)
operator|&&
call|(
modifier|*
name|proc
call|)
argument_list|(
name|evPtr
argument_list|,
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|notifier
operator|.
name|firstEventPtr
operator|==
name|evPtr
condition|)
block|{
name|notifier
operator|.
name|firstEventPtr
operator|=
name|evPtr
operator|->
name|nextPtr
expr_stmt|;
if|if
condition|(
name|evPtr
operator|->
name|nextPtr
operator|==
name|NULL
condition|)
block|{
name|notifier
operator|.
name|lastEventPtr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|notifier
operator|.
name|markerEventPtr
operator|==
name|evPtr
condition|)
block|{
name|notifier
operator|.
name|markerEventPtr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|prevPtr
operator|=
name|notifier
operator|.
name|firstEventPtr
init|;
name|prevPtr
operator|->
name|nextPtr
operator|!=
name|evPtr
condition|;
name|prevPtr
operator|=
name|prevPtr
operator|->
name|nextPtr
control|)
block|{
comment|/* Empty loop body. */
block|}
name|prevPtr
operator|->
name|nextPtr
operator|=
name|evPtr
operator|->
name|nextPtr
expr_stmt|;
if|if
condition|(
name|evPtr
operator|->
name|nextPtr
operator|==
name|NULL
condition|)
block|{
name|notifier
operator|.
name|lastEventPtr
operator|=
name|prevPtr
expr_stmt|;
block|}
if|if
condition|(
name|notifier
operator|.
name|markerEventPtr
operator|==
name|evPtr
condition|)
block|{
name|notifier
operator|.
name|markerEventPtr
operator|=
name|prevPtr
expr_stmt|;
block|}
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|evPtr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* 	     * The event wasn't actually handled, so we have to restore 	     * the proc field to allow the event to be attempted again. 	     */
name|evPtr
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
block|}
comment|/* 	 * The handler for this event asked to defer it.  Just go on to 	 * the next event. 	 */
continue|continue;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetServiceMode --  *  *	This routine returns the current service mode of the notifier.  *  * Results:  *	Returns either TCL_SERVICE_ALL or TCL_SERVICE_NONE.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_GetServiceMode
parameter_list|()
block|{
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|InitNotifier
argument_list|()
expr_stmt|;
block|}
return|return
name|notifier
operator|.
name|serviceMode
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetServiceMode --  *  *	This routine sets the current service mode of the notifier.  *  * Results:  *	Returns the previous service mode.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_SetServiceMode
parameter_list|(
name|mode
parameter_list|)
name|int
name|mode
decl_stmt|;
comment|/* New service mode: TCL_SERVICE_ALL or 				 * TCL_SERVICE_NONE */
block|{
name|int
name|oldMode
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|InitNotifier
argument_list|()
expr_stmt|;
block|}
name|oldMode
operator|=
name|notifier
operator|.
name|serviceMode
expr_stmt|;
name|notifier
operator|.
name|serviceMode
operator|=
name|mode
expr_stmt|;
return|return
name|oldMode
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetMaxBlockTime --  *  *	This procedure is invoked by event sources to tell the notifier  *	how long it may block the next time it blocks.  The timePtr  *	argument gives a maximum time;  the actual time may be less if  *	some other event source requested a smaller time.  *  * Results:  *	None.  *  * Side effects:  *	May reduce the length of the next sleep in the notifier.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_SetMaxBlockTime
parameter_list|(
name|timePtr
parameter_list|)
name|Tcl_Time
modifier|*
name|timePtr
decl_stmt|;
comment|/* Specifies a maximum elapsed time for 				 * the next blocking operation in the 				 * event notifier. */
block|{
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|InitNotifier
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|notifier
operator|.
name|blockTimeSet
operator|||
operator|(
name|timePtr
operator|->
name|sec
operator|<
name|notifier
operator|.
name|blockTime
operator|.
name|sec
operator|)
operator|||
operator|(
operator|(
name|timePtr
operator|->
name|sec
operator|==
name|notifier
operator|.
name|blockTime
operator|.
name|sec
operator|)
operator|&&
operator|(
name|timePtr
operator|->
name|usec
operator|<
name|notifier
operator|.
name|blockTime
operator|.
name|usec
operator|)
operator|)
condition|)
block|{
name|notifier
operator|.
name|blockTime
operator|=
operator|*
name|timePtr
expr_stmt|;
name|notifier
operator|.
name|blockTimeSet
operator|=
literal|1
expr_stmt|;
block|}
comment|/*      * If we are called outside an event source traversal, set the      * timeout immediately.      */
if|if
condition|(
operator|!
name|notifier
operator|.
name|inTraversal
condition|)
block|{
if|if
condition|(
name|notifier
operator|.
name|blockTimeSet
condition|)
block|{
name|Tcl_SetTimer
argument_list|(
operator|&
name|notifier
operator|.
name|blockTime
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_SetTimer
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DoOneEvent --  *  *	Process a single event of some sort.  If there's no work to  *	do, wait for an event to occur, then process it.  *  * Results:  *	The return value is 1 if the procedure actually found an event  *	to process.  If no processing occurred, then 0 is returned (this  *	can happen if the TCL_DONT_WAIT flag is set or if there are no  *	event handlers to wait for in the set specified by flags).  *  * Side effects:  *	May delay execution of process while waiting for an event,  *	unless TCL_DONT_WAIT is set in the flags argument.  Event  *	sources are invoked to check for and queue events.  Event  *	handlers may produce arbitrary side effects.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_DoOneEvent
parameter_list|(
name|flags
parameter_list|)
name|int
name|flags
decl_stmt|;
comment|/* Miscellaneous flag values:  may be any 				 * combination of TCL_DONT_WAIT, 				 * TCL_WINDOW_EVENTS, TCL_FILE_EVENTS, 				 * TCL_TIMER_EVENTS, TCL_IDLE_EVENTS, or 				 * others defined by event sources. */
block|{
name|int
name|result
init|=
literal|0
decl_stmt|,
name|oldMode
decl_stmt|;
name|EventSource
modifier|*
name|sourcePtr
decl_stmt|;
name|Tcl_Time
modifier|*
name|timePtr
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|InitNotifier
argument_list|()
expr_stmt|;
block|}
comment|/*      * The first thing we do is to service any asynchronous event      * handlers.      */
if|if
condition|(
name|Tcl_AsyncReady
argument_list|()
condition|)
block|{
operator|(
name|void
operator|)
name|Tcl_AsyncInvoke
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/*      * No event flags is equivalent to TCL_ALL_EVENTS.      */
if|if
condition|(
operator|(
name|flags
operator|&
name|TCL_ALL_EVENTS
operator|)
operator|==
literal|0
condition|)
block|{
name|flags
operator||=
name|TCL_ALL_EVENTS
expr_stmt|;
block|}
comment|/*      * Set the service mode to none so notifier event routines won't      * try to service events recursively.      */
name|oldMode
operator|=
name|notifier
operator|.
name|serviceMode
expr_stmt|;
name|notifier
operator|.
name|serviceMode
operator|=
name|TCL_SERVICE_NONE
expr_stmt|;
comment|/*      * The core of this procedure is an infinite loop, even though      * we only service one event.  The reason for this is that we      * may be processing events that don't do anything inside of Tcl.      */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* 	 * If idle events are the only things to service, skip the 	 * main part of the loop and go directly to handle idle 	 * events (i.e. don't wait even if TCL_DONT_WAIT isn't set). 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|TCL_ALL_EVENTS
operator|)
operator|==
name|TCL_IDLE_EVENTS
condition|)
block|{
name|flags
operator|=
name|TCL_IDLE_EVENTS
operator||
name|TCL_DONT_WAIT
expr_stmt|;
goto|goto
name|idleEvents
goto|;
block|}
comment|/* 	 * Ask Tcl to service a queued event, if there are any. 	 */
if|if
condition|(
name|Tcl_ServiceEvent
argument_list|(
name|flags
argument_list|)
condition|)
block|{
name|result
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 	 * If TCL_DONT_WAIT is set, be sure to poll rather than 	 * blocking, otherwise reset the block time to infinity. 	 */
if|if
condition|(
name|flags
operator|&
name|TCL_DONT_WAIT
condition|)
block|{
name|notifier
operator|.
name|blockTime
operator|.
name|sec
operator|=
literal|0
expr_stmt|;
name|notifier
operator|.
name|blockTime
operator|.
name|usec
operator|=
literal|0
expr_stmt|;
name|notifier
operator|.
name|blockTimeSet
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|notifier
operator|.
name|blockTimeSet
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Set up all the event sources for new events.  This will 	 * cause the block time to be updated if necessary. 	 */
name|notifier
operator|.
name|inTraversal
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|sourcePtr
operator|=
name|notifier
operator|.
name|firstEventSourcePtr
init|;
name|sourcePtr
operator|!=
name|NULL
condition|;
name|sourcePtr
operator|=
name|sourcePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|sourcePtr
operator|->
name|setupProc
condition|)
block|{
call|(
name|sourcePtr
operator|->
name|setupProc
call|)
argument_list|(
name|sourcePtr
operator|->
name|clientData
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
name|notifier
operator|.
name|inTraversal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|TCL_DONT_WAIT
operator|)
operator|||
name|notifier
operator|.
name|blockTimeSet
condition|)
block|{
name|timePtr
operator|=
operator|&
name|notifier
operator|.
name|blockTime
expr_stmt|;
block|}
else|else
block|{
name|timePtr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Wait for a new event or a timeout.  If Tcl_WaitForEvent 	 * returns -1, we should abort Tcl_DoOneEvent. 	 */
name|result
operator|=
name|Tcl_WaitForEvent
argument_list|(
name|timePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
name|result
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 	 * Check all the event sources for new events. 	 */
for|for
control|(
name|sourcePtr
operator|=
name|notifier
operator|.
name|firstEventSourcePtr
init|;
name|sourcePtr
operator|!=
name|NULL
condition|;
name|sourcePtr
operator|=
name|sourcePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|sourcePtr
operator|->
name|checkProc
condition|)
block|{
call|(
name|sourcePtr
operator|->
name|checkProc
call|)
argument_list|(
name|sourcePtr
operator|->
name|clientData
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Check for events queued by the notifier or event sources. 	 */
if|if
condition|(
name|Tcl_ServiceEvent
argument_list|(
name|flags
argument_list|)
condition|)
block|{
name|result
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 	 * We've tried everything at this point, but nobody we know 	 * about had anything to do.  Check for idle events.  If none, 	 * either quit or go back to the top and try again. 	 */
name|idleEvents
label|:
if|if
condition|(
name|flags
operator|&
name|TCL_IDLE_EVENTS
condition|)
block|{
if|if
condition|(
name|TclServiceIdle
argument_list|()
condition|)
block|{
name|result
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|TCL_DONT_WAIT
condition|)
block|{
break|break;
block|}
comment|/* 	 * If Tcl_WaitForEvent has returned 1, 	 * indicating that one system event has been dispatched 	 * (and thus that some Tcl code might have been indirectly executed), 	 * we break out of the loop. 	 * We do this to give VwaitCmd for instance a chance to check  	 * if that system event had the side effect of changing the  	 * variable (so the vwait can return and unwind properly). 	 * 	 * NB: We will process idle events if any first, because 	 *     otherwise we might never do the idle events if the notifier 	 *     always gets system events. 	 */
if|if
condition|(
name|result
condition|)
block|{
break|break;
block|}
block|}
name|notifier
operator|.
name|serviceMode
operator|=
name|oldMode
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ServiceAll --  *  *	This routine checks all of the event sources, processes  *	events that are on the Tcl event queue, and then calls the  *	any idle handlers.  Platform specific notifier callbacks that  *	generate events should call this routine before returning to  *	the system in order to ensure that Tcl gets a chance to  *	process the new events.  *  * Results:  *	Returns 1 if an event or idle handler was invoked, else 0.  *  * Side effects:  *	Anything that an event or idle handler may do.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_ServiceAll
parameter_list|()
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
name|EventSource
modifier|*
name|sourcePtr
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|InitNotifier
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|notifier
operator|.
name|serviceMode
operator|==
name|TCL_SERVICE_NONE
condition|)
block|{
return|return
name|result
return|;
block|}
comment|/*      * We need to turn off event servicing like we to in Tcl_DoOneEvent,      * to avoid recursive calls.      */
name|notifier
operator|.
name|serviceMode
operator|=
name|TCL_SERVICE_NONE
expr_stmt|;
comment|/*      * Check async handlers first.      */
if|if
condition|(
name|Tcl_AsyncReady
argument_list|()
condition|)
block|{
operator|(
name|void
operator|)
name|Tcl_AsyncInvoke
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*      * Make a single pass through all event sources, queued events,      * and idle handlers.  Note that we wait to update the notifier      * timer until the end so we can avoid multiple changes.      */
name|notifier
operator|.
name|inTraversal
operator|=
literal|1
expr_stmt|;
name|notifier
operator|.
name|blockTimeSet
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sourcePtr
operator|=
name|notifier
operator|.
name|firstEventSourcePtr
init|;
name|sourcePtr
operator|!=
name|NULL
condition|;
name|sourcePtr
operator|=
name|sourcePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|sourcePtr
operator|->
name|setupProc
condition|)
block|{
call|(
name|sourcePtr
operator|->
name|setupProc
call|)
argument_list|(
name|sourcePtr
operator|->
name|clientData
argument_list|,
name|TCL_ALL_EVENTS
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|sourcePtr
operator|=
name|notifier
operator|.
name|firstEventSourcePtr
init|;
name|sourcePtr
operator|!=
name|NULL
condition|;
name|sourcePtr
operator|=
name|sourcePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|sourcePtr
operator|->
name|checkProc
condition|)
block|{
call|(
name|sourcePtr
operator|->
name|checkProc
call|)
argument_list|(
name|sourcePtr
operator|->
name|clientData
argument_list|,
name|TCL_ALL_EVENTS
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|Tcl_ServiceEvent
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|result
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TclServiceIdle
argument_list|()
condition|)
block|{
name|result
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|notifier
operator|.
name|blockTimeSet
condition|)
block|{
name|Tcl_SetTimer
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_SetTimer
argument_list|(
operator|&
name|notifier
operator|.
name|blockTime
argument_list|)
expr_stmt|;
block|}
name|notifier
operator|.
name|inTraversal
operator|=
literal|0
expr_stmt|;
name|notifier
operator|.
name|serviceMode
operator|=
name|TCL_SERVICE_ALL
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

end_unit

