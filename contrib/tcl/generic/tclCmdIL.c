begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclCmdIL.c --  *  *	This file contains the top-level command routines for most of  *	the Tcl built-in commands whose names begin with the letters  *	I through L.  It contains only commands in the generic core  *	(i.e. those that don't depend much upon UNIX facilities).  *  * Copyright (c) 1987-1993 The Regents of the University of California.  * Copyright (c) 1993-1997 Lucent Technologies.  * Copyright (c) 1994-1997 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclCmdIL.c 1.168 97/07/29 12:52:40  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * The following variable holds the full path name of the binary  * from which this application was executed, or NULL if it isn't  * know.  The value of the variable is set by the procedure  * Tcl_FindExecutable.  The storage space is dynamically allocated.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|tclExecutableName
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * During execution of the "lsort" command, structures of the following  * type are used to arrange the objects being sorted into a collection  * of linked lists.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|SortElement
block|{
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Object being sorted. */
name|struct
name|SortElement
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next element in the list, or 					 * NULL for end of list. */
block|}
name|SortElement
typedef|;
end_typedef

begin_comment
comment|/*  * The "lsort" command needs to pass certain information down to the  * function that compares two list elements, and the comparison function  * needs to pass success or failure information back up to the top-level  * "lsort" command.  The following structure is used to pass this  * information.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|SortInfo
block|{
name|int
name|isIncreasing
decl_stmt|;
comment|/* Nonzero means sort in increasing order. */
name|int
name|sortMode
decl_stmt|;
comment|/* The sort mode.  One of SORTMODE_* 				 * values defined below */
name|Tcl_DString
name|compareCmd
decl_stmt|;
comment|/* The Tcl comparison command when sortMode 				 * is SORTMODE_COMMAND.  Pre-initialized to 				 * hold base of command.*/
name|int
name|index
decl_stmt|;
comment|/* If the -index option was specified, this 				 * holds the index of the list element 				 * to extract for comparison.  If -index 				 * wasn't specified, this is -1. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interpreter in which the sortis 				 * being done. */
name|int
name|resultCode
decl_stmt|;
comment|/* Completion code for the lsort command. 				 * If an error occurs during the sort this 				 * is changed from TCL_OK to  TCL_ERROR. */
block|}
name|SortInfo
typedef|;
end_typedef

begin_comment
comment|/*  * The "sortMode" field of the SortInfo structure can take on any of the  * following values.  */
end_comment

begin_define
define|#
directive|define
name|SORTMODE_ASCII
value|0
end_define

begin_define
define|#
directive|define
name|SORTMODE_INTEGER
value|1
end_define

begin_define
define|#
directive|define
name|SORTMODE_REAL
value|2
end_define

begin_define
define|#
directive|define
name|SORTMODE_COMMAND
value|3
end_define

begin_define
define|#
directive|define
name|SORTMODE_DICTIONARY
value|4
end_define

begin_comment
comment|/*  * Forward declarations for procedures defined in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|DictionaryCompare
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|left
operator|,
name|char
operator|*
name|right
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InfoArgsCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InfoBodyCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InfoCmdCountCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InfoCommandsCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InfoCompleteCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InfoDefaultCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InfoExistsCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InfoGlobalsCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InfoHostnameCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InfoLevelCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InfoLibraryCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InfoLoadedCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InfoLocalsCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InfoNameOfExecutableCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InfoPatchLevelCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InfoProcsCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InfoScriptCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InfoSharedlibCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InfoTclVersionCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InfoVarsCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SortElement
modifier|*
name|MergeSort
name|_ANSI_ARGS_
argument_list|(
operator|(
name|SortElement
operator|*
name|headPt
operator|,
name|SortInfo
operator|*
name|infoPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SortElement
modifier|*
name|MergeLists
name|_ANSI_ARGS_
argument_list|(
operator|(
name|SortElement
operator|*
name|leftPtr
operator|,
name|SortElement
operator|*
name|rightPtr
operator|,
name|SortInfo
operator|*
name|infoPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SortCompare
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Obj
operator|*
name|firstPtr
operator|,
name|Tcl_Obj
operator|*
name|second
operator|,
name|SortInfo
operator|*
name|infoPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_IfCmd --  *  *	This procedure is invoked to process the "if" Tcl command.  *	See the user documentation for details on what it does.  *  *	With the bytecode compiler, this procedure is only called when  *	a command name is computed at runtime, and is "if" or the name  *	to which "if" was renamed: e.g., "set z if; $z 1 {puts foo}"  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_IfCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|i
decl_stmt|,
name|result
decl_stmt|,
name|value
decl_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* 	 * At this point in the loop, argv and argc refer to an expression 	 * to test, either for the main expression or an expression 	 * following an "elseif".  The arguments after the expression must 	 * be "then" (optional) and a script to execute if the expression is 	 * true. 	 */
if|if
condition|(
name|i
operator|>=
name|argc
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: no expression after \""
argument_list|,
name|argv
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
literal|"\" argument"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|result
operator|=
name|Tcl_ExprBoolean
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
name|i
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|<
name|argc
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"then"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|argc
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: no script following \""
argument_list|,
name|argv
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
literal|"\" argument"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|value
condition|)
block|{
return|return
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
return|;
block|}
comment|/* 	 * The expression evaluated to false.  Skip the command, then 	 * see if there is an "else" or "elseif" clause. 	 */
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|argc
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"elseif"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
comment|/*      * Couldn't find a "then" or "elseif" clause to execute.  Check now      * for an "else" clause.  We know that there's at least one more      * argument when we get here.      */
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"else"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|argc
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: no script following \"else\" argument"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
return|return
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_IncrCmd --  *  *	This procedure is invoked to process the "incr" Tcl command.  *	See the user documentation for details on what it does.  *  *	With the bytecode compiler, this procedure is only called when  *	a command name is computed at runtime, and is "incr" or the name  *	to which "incr" was renamed: e.g., "set z incr; $z i -1"  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_IncrCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|value
decl_stmt|;
name|char
modifier|*
name|oldString
decl_stmt|,
modifier|*
name|result
decl_stmt|;
name|char
name|newString
index|[
literal|30
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|argc
operator|!=
literal|2
operator|)
operator|&&
operator|(
name|argc
operator|!=
literal|3
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" varName ?increment?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|oldString
operator|=
name|Tcl_GetVar
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldString
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|oldString
argument_list|,
operator|&
name|value
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
literal|"\n    (reading value of variable to increment)"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
name|value
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|increment
decl_stmt|;
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|increment
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
literal|"\n    (reading increment)"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|value
operator|+=
name|increment
expr_stmt|;
block|}
name|TclFormatInt
argument_list|(
name|newString
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|newString
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Copy the result since the variable's value might change.      */
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|result
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_InfoObjCmd --  *  *	This procedure is invoked to process the "info" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_InfoObjCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary value passed to the command. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
specifier|static
name|char
modifier|*
name|subCmds
index|[]
init|=
block|{
literal|"args"
block|,
literal|"body"
block|,
literal|"cmdcount"
block|,
literal|"commands"
block|,
literal|"complete"
block|,
literal|"default"
block|,
literal|"exists"
block|,
literal|"globals"
block|,
literal|"hostname"
block|,
literal|"level"
block|,
literal|"library"
block|,
literal|"loaded"
block|,
literal|"locals"
block|,
literal|"nameofexecutable"
block|,
literal|"patchlevel"
block|,
literal|"procs"
block|,
literal|"script"
block|,
literal|"sharedlibextension"
block|,
literal|"tclversion"
block|,
literal|"vars"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
enum|enum
name|ISubCmdIdx
block|{
name|IArgsIdx
block|,
name|IBodyIdx
block|,
name|ICmdCountIdx
block|,
name|ICommandsIdx
block|,
name|ICompleteIdx
block|,
name|IDefaultIdx
block|,
name|IExistsIdx
block|,
name|IGlobalsIdx
block|,
name|IHostnameIdx
block|,
name|ILevelIdx
block|,
name|ILibraryIdx
block|,
name|ILoadedIdx
block|,
name|ILocalsIdx
block|,
name|INameOfExecutableIdx
block|,
name|IPatchLevelIdx
block|,
name|IProcsIdx
block|,
name|IScriptIdx
block|,
name|ISharedLibExtensionIdx
block|,
name|ITclVersionIdx
block|,
name|IVarsIdx
block|}
name|index
enum|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"option ?arg arg ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|result
operator|=
name|Tcl_GetIndexFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|,
name|subCmds
argument_list|,
literal|"option"
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|IArgsIdx
case|:
name|result
operator|=
name|InfoArgsCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|IBodyIdx
case|:
name|result
operator|=
name|InfoBodyCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICmdCountIdx
case|:
name|result
operator|=
name|InfoCmdCountCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICommandsIdx
case|:
name|result
operator|=
name|InfoCommandsCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICompleteIdx
case|:
name|result
operator|=
name|InfoCompleteCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|IDefaultIdx
case|:
name|result
operator|=
name|InfoDefaultCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|IExistsIdx
case|:
name|result
operator|=
name|InfoExistsCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|IGlobalsIdx
case|:
name|result
operator|=
name|InfoGlobalsCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|IHostnameIdx
case|:
name|result
operator|=
name|InfoHostnameCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|ILevelIdx
case|:
name|result
operator|=
name|InfoLevelCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|ILibraryIdx
case|:
name|result
operator|=
name|InfoLibraryCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|ILoadedIdx
case|:
name|result
operator|=
name|InfoLoadedCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|ILocalsIdx
case|:
name|result
operator|=
name|InfoLocalsCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|INameOfExecutableIdx
case|:
name|result
operator|=
name|InfoNameOfExecutableCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPatchLevelIdx
case|:
name|result
operator|=
name|InfoPatchLevelCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|IProcsIdx
case|:
name|result
operator|=
name|InfoProcsCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|IScriptIdx
case|:
name|result
operator|=
name|InfoScriptCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISharedLibExtensionIdx
case|:
name|result
operator|=
name|InfoSharedlibCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|ITclVersionIdx
case|:
name|result
operator|=
name|InfoTclVersionCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|IVarsIdx
case|:
name|result
operator|=
name|InfoVarsCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InfoArgsCmd --  *  *      Called to implement the "info args" command that returns the  *      argument list for a procedure. Handles the following syntax:  *  *          info args procName  *  * Results:  *      Returns TCL_OK is successful and TCL_ERROR is there is an error.  *  * Side effects:  *      Returns a result in the interpreter's result object. If there is  *	an error, the result is an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InfoArgsCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|Proc
modifier|*
name|procPtr
decl_stmt|;
name|CompiledLocal
modifier|*
name|localPtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|listObjPtr
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"procname"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|name
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|procPtr
operator|=
name|TclFindProc
argument_list|(
name|iPtr
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|procPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"\""
argument_list|,
name|name
argument_list|,
literal|"\" isn't a procedure"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Build a return list containing the arguments.      */
name|listObjPtr
operator|=
name|Tcl_NewListObj
argument_list|(
literal|0
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|localPtr
operator|=
name|procPtr
operator|->
name|firstLocalPtr
init|;
name|localPtr
operator|!=
name|NULL
condition|;
name|localPtr
operator|=
name|localPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|localPtr
operator|->
name|isArg
condition|)
block|{
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listObjPtr
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|localPtr
operator|->
name|name
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|listObjPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InfoBodyCmd --  *  *      Called to implement the "info body" command that returns the body  *      for a procedure. Handles the following syntax:  *  *          info body procName  *  * Results:  *      Returns TCL_OK is successful and TCL_ERROR is there is an error.  *  * Side effects:  *      Returns a result in the interpreter's result object. If there is  *	an error, the result is an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InfoBodyCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|Proc
modifier|*
name|procPtr
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"procname"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|name
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|procPtr
operator|=
name|TclFindProc
argument_list|(
name|iPtr
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|procPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"\""
argument_list|,
name|name
argument_list|,
literal|"\" isn't a procedure"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|procPtr
operator|->
name|bodyPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InfoCmdCountCmd --  *  *      Called to implement the "info cmdcount" command that returns the  *      number of commands that have been executed. Handles the following  *      syntax:  *  *          info cmdcount  *  * Results:  *      Returns TCL_OK is successful and TCL_ERROR is there is an error.  *  * Side effects:  *      Returns a result in the interpreter's result object. If there is  *	an error, the result is an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InfoCmdCountCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_SetIntObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|iPtr
operator|->
name|cmdCount
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InfoCommandsCmd --  *  *	Called to implement the "info commands" command that returns the  *	list of commands in the interpreter that match an optional pattern.  *	The pattern, if any, consists of an optional sequence of namespace  *	names separated by "::" qualifiers, which is followed by a  *	glob-style pattern that restricts which commands are returned.  *	Handles the following syntax:  *  *          info commands ?pattern?  *  * Results:  *      Returns TCL_OK is successful and TCL_ERROR is there is an error.  *  * Side effects:  *      Returns a result in the interpreter's result object. If there is  *	an error, the result is an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InfoCommandsCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|char
modifier|*
name|cmdName
decl_stmt|,
modifier|*
name|pattern
decl_stmt|,
modifier|*
name|simplePattern
decl_stmt|;
specifier|register
name|Tcl_HashEntry
modifier|*
name|entryPtr
decl_stmt|;
name|Tcl_HashSearch
name|search
decl_stmt|;
name|Namespace
modifier|*
name|nsPtr
decl_stmt|;
name|Namespace
modifier|*
name|globalNsPtr
init|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetGlobalNamespace
argument_list|(
name|interp
argument_list|)
decl_stmt|;
name|Namespace
modifier|*
name|currNsPtr
init|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetCurrentNamespace
argument_list|(
name|interp
argument_list|)
decl_stmt|;
name|Tcl_Obj
modifier|*
name|listPtr
decl_stmt|,
modifier|*
name|elemObjPtr
decl_stmt|;
name|int
name|specificNsInPattern
init|=
literal|0
decl_stmt|;
comment|/* Init. to avoid compiler warning. */
name|Tcl_Command
name|cmd
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/*      * Get the pattern and find the "effective namespace" in which to      * list commands.      */
if|if
condition|(
name|objc
operator|==
literal|2
condition|)
block|{
name|simplePattern
operator|=
name|NULL
expr_stmt|;
name|nsPtr
operator|=
name|currNsPtr
expr_stmt|;
name|specificNsInPattern
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|objc
operator|==
literal|3
condition|)
block|{
comment|/* 	 * From the pattern, get the effective namespace and the simple 	 * pattern (no namespace qualifiers or ::'s) at the end. If an 	 * error was found while parsing the pattern, return it. Otherwise, 	 * if the namespace wasn't found, just leave nsPtr NULL: we will 	 * return an empty list since no commands there can be found. 	 */
name|Namespace
modifier|*
name|dummy1NsPtr
decl_stmt|,
modifier|*
name|dummy2NsPtr
decl_stmt|;
name|pattern
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TclGetNamespaceForQualName
argument_list|(
name|interp
argument_list|,
name|pattern
argument_list|,
operator|(
name|Namespace
operator|*
operator|)
name|NULL
argument_list|,
comment|/*flags*/
name|TCL_LEAVE_ERR_MSG
argument_list|,
operator|&
name|nsPtr
argument_list|,
operator|&
name|dummy1NsPtr
argument_list|,
operator|&
name|dummy2NsPtr
argument_list|,
operator|&
name|simplePattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|nsPtr
operator|!=
name|NULL
condition|)
block|{
comment|/* we successfully found the pattern's ns */
name|specificNsInPattern
operator|=
operator|(
name|strcmp
argument_list|(
name|simplePattern
argument_list|,
name|pattern
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?pattern?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Scan through the effective namespace's command table and create a      * list with all commands that match the pattern. If a specific      * namespace was requested in the pattern, qualify the command names      * with the namespace name.      */
name|listPtr
operator|=
name|Tcl_NewListObj
argument_list|(
literal|0
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsPtr
operator|!=
name|NULL
condition|)
block|{
name|entryPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
name|nsPtr
operator|->
name|cmdTable
argument_list|,
operator|&
name|search
argument_list|)
expr_stmt|;
while|while
condition|(
name|entryPtr
operator|!=
name|NULL
condition|)
block|{
name|cmdName
operator|=
name|Tcl_GetHashKey
argument_list|(
operator|&
name|nsPtr
operator|->
name|cmdTable
argument_list|,
name|entryPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|simplePattern
operator|==
name|NULL
operator|)
operator|||
name|Tcl_StringMatch
argument_list|(
name|cmdName
argument_list|,
name|simplePattern
argument_list|)
condition|)
block|{
if|if
condition|(
name|specificNsInPattern
condition|)
block|{
name|cmd
operator|=
operator|(
name|Tcl_Command
operator|)
name|Tcl_GetHashValue
argument_list|(
name|entryPtr
argument_list|)
expr_stmt|;
name|elemObjPtr
operator|=
name|Tcl_NewObj
argument_list|()
expr_stmt|;
name|Tcl_GetCommandFullName
argument_list|(
name|interp
argument_list|,
name|cmd
argument_list|,
name|elemObjPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|elemObjPtr
operator|=
name|Tcl_NewStringObj
argument_list|(
name|cmdName
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
name|elemObjPtr
argument_list|)
expr_stmt|;
block|}
name|entryPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the effective namespace isn't the global :: namespace, and a 	 * specific namespace wasn't requested in the pattern, then add in 	 * all global :: commands that match the simple pattern. Of course, 	 * we add in only those commands that aren't hidden by a command in 	 * the effective namespace. 	 */
if|if
condition|(
operator|(
name|nsPtr
operator|!=
name|globalNsPtr
operator|)
operator|&&
operator|!
name|specificNsInPattern
condition|)
block|{
name|entryPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
name|globalNsPtr
operator|->
name|cmdTable
argument_list|,
operator|&
name|search
argument_list|)
expr_stmt|;
while|while
condition|(
name|entryPtr
operator|!=
name|NULL
condition|)
block|{
name|cmdName
operator|=
name|Tcl_GetHashKey
argument_list|(
operator|&
name|globalNsPtr
operator|->
name|cmdTable
argument_list|,
name|entryPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|simplePattern
operator|==
name|NULL
operator|)
operator|||
name|Tcl_StringMatch
argument_list|(
name|cmdName
argument_list|,
name|simplePattern
argument_list|)
condition|)
block|{
if|if
condition|(
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|nsPtr
operator|->
name|cmdTable
argument_list|,
name|cmdName
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|cmdName
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|entryPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InfoCompleteCmd --  *  *      Called to implement the "info complete" command that determines  *      whether a string is a complete Tcl command. Handles the following  *      syntax:  *  *          info complete command  *  * Results:  *      Returns TCL_OK is successful and TCL_ERROR is there is an error.  *  * Side effects:  *      Returns a result in the interpreter's result object. If there is  *	an error, the result is an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InfoCompleteCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|char
modifier|*
name|command
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"command"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|command
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_CommandComplete
argument_list|(
name|command
argument_list|)
condition|)
block|{
name|Tcl_SetIntObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_SetIntObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InfoDefaultCmd --  *  *      Called to implement the "info default" command that returns the  *      default value for a procedure argument. Handles the following  *      syntax:  *  *          info default procName arg varName  *  * Results:  *      Returns TCL_OK is successful and TCL_ERROR is there is an error.  *  * Side effects:  *      Returns a result in the interpreter's result object. If there is  *	an error, the result is an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InfoDefaultCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|char
modifier|*
name|procName
decl_stmt|,
modifier|*
name|argName
decl_stmt|,
modifier|*
name|varName
decl_stmt|;
name|Proc
modifier|*
name|procPtr
decl_stmt|;
name|CompiledLocal
modifier|*
name|localPtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|valueObjPtr
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|5
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"procname arg varname"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|procName
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|argName
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|procPtr
operator|=
name|TclFindProc
argument_list|(
name|iPtr
argument_list|,
name|procName
argument_list|)
expr_stmt|;
if|if
condition|(
name|procPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"\""
argument_list|,
name|procName
argument_list|,
literal|"\" isn't a procedure"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
for|for
control|(
name|localPtr
operator|=
name|procPtr
operator|->
name|firstLocalPtr
init|;
name|localPtr
operator|!=
name|NULL
condition|;
name|localPtr
operator|=
name|localPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
operator|(
name|localPtr
operator|->
name|isArg
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|argName
argument_list|,
name|localPtr
operator|->
name|name
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|localPtr
operator|->
name|defValuePtr
operator|!=
name|NULL
condition|)
block|{
name|valueObjPtr
operator|=
name|Tcl_ObjSetVar2
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|4
index|]
argument_list|,
name|NULL
argument_list|,
name|localPtr
operator|->
name|defValuePtr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|valueObjPtr
operator|==
name|NULL
condition|)
block|{
name|defStoreError
label|:
name|varName
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|4
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"couldn't store default value in variable \""
argument_list|,
name|varName
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_SetIntObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_Obj
modifier|*
name|nullObjPtr
init|=
name|Tcl_NewObj
argument_list|()
decl_stmt|;
name|valueObjPtr
operator|=
name|Tcl_ObjSetVar2
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|4
index|]
argument_list|,
name|NULL
argument_list|,
name|nullObjPtr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|valueObjPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|nullObjPtr
argument_list|)
expr_stmt|;
comment|/* free unneeded obj */
goto|goto
name|defStoreError
goto|;
block|}
name|Tcl_SetIntObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
block|}
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"procedure \""
argument_list|,
name|procName
argument_list|,
literal|"\" doesn't have an argument \""
argument_list|,
name|argName
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InfoExistsCmd --  *  *      Called to implement the "info exists" command that determines  *      whether a variable exists. Handles the following syntax:  *  *          info exists varName  *  * Results:  *      Returns TCL_OK is successful and TCL_ERROR is there is an error.  *  * Side effects:  *      Returns a result in the interpreter's result object. If there is  *	an error, the result is an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InfoExistsCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|char
modifier|*
name|varName
decl_stmt|;
name|Var
modifier|*
name|varPtr
decl_stmt|,
modifier|*
name|arrayPtr
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"varName"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|varName
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|varPtr
operator|=
name|TclLookupVar
argument_list|(
name|interp
argument_list|,
name|varName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_PARSE_PART1
argument_list|,
literal|"access"
argument_list|,
comment|/*createPart1*/
literal|0
argument_list|,
comment|/*createPart2*/
literal|0
argument_list|,
operator|&
name|arrayPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|varPtr
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|TclIsVarUndefined
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
name|Tcl_SetIntObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_SetIntObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InfoGlobalsCmd --  *  *      Called to implement the "info globals" command that returns the list  *      of global variables matching an optional pattern. Handles the  *      following syntax:  *  *          info globals ?pattern?  *  * Results:  *      Returns TCL_OK is successful and TCL_ERROR is there is an error.  *  * Side effects:  *      Returns a result in the interpreter's result object. If there is  *	an error, the result is an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InfoGlobalsCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|char
modifier|*
name|varName
decl_stmt|,
modifier|*
name|pattern
decl_stmt|;
name|Namespace
modifier|*
name|globalNsPtr
init|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetGlobalNamespace
argument_list|(
name|interp
argument_list|)
decl_stmt|;
specifier|register
name|Tcl_HashEntry
modifier|*
name|entryPtr
decl_stmt|;
name|Tcl_HashSearch
name|search
decl_stmt|;
name|Var
modifier|*
name|varPtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|listPtr
decl_stmt|;
if|if
condition|(
name|objc
operator|==
literal|2
condition|)
block|{
name|pattern
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|objc
operator|==
literal|3
condition|)
block|{
name|pattern
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?pattern?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Scan through the global :: namespace's variable table and create a      * list of all global variables that match the pattern.      */
name|listPtr
operator|=
name|Tcl_NewListObj
argument_list|(
literal|0
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|entryPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
name|globalNsPtr
operator|->
name|varTable
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|entryPtr
operator|!=
name|NULL
condition|;
name|entryPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
name|varPtr
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|entryPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TclIsVarUndefined
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|varName
operator|=
name|Tcl_GetHashKey
argument_list|(
operator|&
name|globalNsPtr
operator|->
name|varTable
argument_list|,
name|entryPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pattern
operator|==
name|NULL
operator|)
operator|||
name|Tcl_StringMatch
argument_list|(
name|varName
argument_list|,
name|pattern
argument_list|)
condition|)
block|{
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|varName
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InfoHostnameCmd --  *  *      Called to implement the "info hostname" command that returns the  *      host name. Handles the following syntax:  *  *          info hostname  *  * Results:  *      Returns TCL_OK is successful and TCL_ERROR is there is an error.  *  * Side effects:  *      Returns a result in the interpreter's result object. If there is  *	an error, the result is an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InfoHostnameCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
if|if
condition|(
name|objc
operator|!=
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_SetStringObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|Tcl_GetHostName
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InfoLevelCmd --  *  *      Called to implement the "info level" command that returns  *      information about the call stack. Handles the following syntax:  *  *          info level ?number?  *  * Results:  *      Returns TCL_OK is successful and TCL_ERROR is there is an error.  *  * Side effects:  *      Returns a result in the interpreter's result object. If there is  *	an error, the result is an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InfoLevelCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|int
name|level
decl_stmt|;
name|CallFrame
modifier|*
name|framePtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|listPtr
decl_stmt|;
if|if
condition|(
name|objc
operator|==
literal|2
condition|)
block|{
comment|/* just "info level" */
if|if
condition|(
name|iPtr
operator|->
name|varFramePtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_SetIntObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_SetIntObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|iPtr
operator|->
name|varFramePtr
operator|->
name|level
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
name|objc
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|level
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|level
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|iPtr
operator|->
name|varFramePtr
operator|==
name|NULL
condition|)
block|{
name|levelError
label|:
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"bad level \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|level
operator|+=
name|iPtr
operator|->
name|varFramePtr
operator|->
name|level
expr_stmt|;
block|}
for|for
control|(
name|framePtr
operator|=
name|iPtr
operator|->
name|varFramePtr
init|;
name|framePtr
operator|!=
name|NULL
condition|;
name|framePtr
operator|=
name|framePtr
operator|->
name|callerVarPtr
control|)
block|{
if|if
condition|(
name|framePtr
operator|->
name|level
operator|==
name|level
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|framePtr
operator|==
name|NULL
condition|)
block|{
goto|goto
name|levelError
goto|;
block|}
name|listPtr
operator|=
name|Tcl_NewListObj
argument_list|(
name|framePtr
operator|->
name|objc
argument_list|,
name|framePtr
operator|->
name|objv
argument_list|)
expr_stmt|;
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?number?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InfoLibraryCmd --  *  *      Called to implement the "info library" command that returns the  *      library directory for the Tcl installation. Handles the following  *      syntax:  *  *          info library  *  * Results:  *      Returns TCL_OK is successful and TCL_ERROR is there is an error.  *  * Side effects:  *      Returns a result in the interpreter's result object. If there is  *	an error, the result is an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InfoLibraryCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|char
modifier|*
name|libDirName
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|libDirName
operator|=
name|Tcl_GetVar
argument_list|(
name|interp
argument_list|,
literal|"tcl_library"
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|libDirName
operator|!=
name|NULL
condition|)
block|{
name|Tcl_SetStringObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|libDirName
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
name|Tcl_SetStringObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"no library has been specified for Tcl"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InfoLoadedCmd --  *  *      Called to implement the "info loaded" command that returns the  *      packages that have been loaded into an interpreter. Handles the  *      following syntax:  *  *          info loaded ?interp?  *  * Results:  *      Returns TCL_OK is successful and TCL_ERROR is there is an error.  *  * Side effects:  *      Returns a result in the interpreter's result object. If there is  *	an error, the result is an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InfoLoadedCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|char
modifier|*
name|interpName
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|objc
operator|!=
literal|2
operator|)
operator|&&
operator|(
name|objc
operator|!=
literal|3
operator|)
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?interp?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|objc
operator|==
literal|2
condition|)
block|{
comment|/* get loaded pkgs in all interpreters */
name|interpName
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* get pkgs just in specified interp */
name|interpName
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|TclGetLoadedPackages
argument_list|(
name|interp
argument_list|,
name|interpName
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InfoLocalsCmd --  *  *      Called to implement the "info locals" command to return a list of  *      local variables that match an optional pattern. Handles the  *      following syntax:  *  *          info locals ?pattern?  *  * Results:  *      Returns TCL_OK is successful and TCL_ERROR is there is an error.  *  * Side effects:  *      Returns a result in the interpreter's result object. If there is  *	an error, the result is an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InfoLocalsCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Var
modifier|*
name|varPtr
decl_stmt|;
name|char
modifier|*
name|varName
decl_stmt|,
modifier|*
name|pattern
decl_stmt|;
name|int
name|i
decl_stmt|,
name|localVarCt
decl_stmt|;
name|Tcl_HashTable
modifier|*
name|localVarTablePtr
decl_stmt|;
specifier|register
name|Tcl_HashEntry
modifier|*
name|entryPtr
decl_stmt|;
name|Tcl_HashSearch
name|search
decl_stmt|;
name|Tcl_Obj
modifier|*
name|listPtr
decl_stmt|;
if|if
condition|(
name|objc
operator|==
literal|2
condition|)
block|{
name|pattern
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|objc
operator|==
literal|3
condition|)
block|{
name|pattern
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?pattern?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|iPtr
operator|->
name|varFramePtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
name|localVarTablePtr
operator|=
name|iPtr
operator|->
name|varFramePtr
operator|->
name|varTablePtr
expr_stmt|;
comment|/*      * Return a list containing names of first the compiled locals (i.e. the      * ones stored in the call frame), then the variables in the local hash      * table (if one exists).      */
name|listPtr
operator|=
name|Tcl_NewListObj
argument_list|(
literal|0
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|localVarCt
operator|=
name|iPtr
operator|->
name|varFramePtr
operator|->
name|numCompiledLocals
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|varPtr
operator|=
name|iPtr
operator|->
name|varFramePtr
operator|->
name|compiledLocals
init|;
name|i
operator|<
name|localVarCt
condition|;
name|i
operator|++
operator|,
name|varPtr
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|TclIsVarUndefined
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
name|varName
operator|=
name|varPtr
operator|->
name|name
expr_stmt|;
if|if
condition|(
operator|(
name|pattern
operator|==
name|NULL
operator|)
operator|||
name|Tcl_StringMatch
argument_list|(
name|varName
argument_list|,
name|pattern
argument_list|)
condition|)
block|{
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|varName
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|localVarTablePtr
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|entryPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|localVarTablePtr
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|entryPtr
operator|!=
name|NULL
condition|;
name|entryPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
name|varPtr
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|entryPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TclIsVarUndefined
argument_list|(
name|varPtr
argument_list|)
operator|&&
operator|!
name|TclIsVarLink
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
name|varName
operator|=
name|Tcl_GetHashKey
argument_list|(
name|localVarTablePtr
argument_list|,
name|entryPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pattern
operator|==
name|NULL
operator|)
operator|||
name|Tcl_StringMatch
argument_list|(
name|varName
argument_list|,
name|pattern
argument_list|)
condition|)
block|{
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|varName
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InfoNameOfExecutableCmd --  *  *      Called to implement the "info nameofexecutable" command that returns  *      the name of the binary file running this application. Handles the  *      following syntax:  *  *          info nameofexecutable  *  * Results:  *      Returns TCL_OK is successful and TCL_ERROR is there is an error.  *  * Side effects:  *      Returns a result in the interpreter's result object. If there is  *	an error, the result is an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InfoNameOfExecutableCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
if|if
condition|(
name|objc
operator|!=
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|tclExecutableName
operator|!=
name|NULL
condition|)
block|{
name|Tcl_SetStringObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|tclExecutableName
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InfoPatchLevelCmd --  *  *      Called to implement the "info patchlevel" command that returns the  *      default value for an argument to a procedure. Handles the following  *      syntax:  *  *          info patchlevel  *  * Results:  *      Returns TCL_OK is successful and TCL_ERROR is there is an error.  *  * Side effects:  *      Returns a result in the interpreter's result object. If there is  *	an error, the result is an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InfoPatchLevelCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|char
modifier|*
name|patchlevel
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|patchlevel
operator|=
name|Tcl_GetVar
argument_list|(
name|interp
argument_list|,
literal|"tcl_patchLevel"
argument_list|,
operator|(
name|TCL_GLOBAL_ONLY
operator||
name|TCL_LEAVE_ERR_MSG
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|patchlevel
operator|!=
name|NULL
condition|)
block|{
name|Tcl_SetStringObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|patchlevel
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InfoProcsCmd --  *  *      Called to implement the "info procs" command that returns the  *      procedures in the current namespace that match an optional pattern.  *      Handles the following syntax:  *  *          info procs ?pattern?  *  * Results:  *      Returns TCL_OK is successful and TCL_ERROR is there is an error.  *  * Side effects:  *      Returns a result in the interpreter's result object. If there is  *	an error, the result is an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InfoProcsCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|char
modifier|*
name|cmdName
decl_stmt|,
modifier|*
name|pattern
decl_stmt|;
name|Namespace
modifier|*
name|currNsPtr
init|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetCurrentNamespace
argument_list|(
name|interp
argument_list|)
decl_stmt|;
specifier|register
name|Tcl_HashEntry
modifier|*
name|entryPtr
decl_stmt|;
name|Tcl_HashSearch
name|search
decl_stmt|;
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|listPtr
decl_stmt|;
if|if
condition|(
name|objc
operator|==
literal|2
condition|)
block|{
name|pattern
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|objc
operator|==
literal|3
condition|)
block|{
name|pattern
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?pattern?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Scan through the current namespace's command table and return a list      * of all procs that match the pattern.      */
name|listPtr
operator|=
name|Tcl_NewListObj
argument_list|(
literal|0
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|entryPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
name|currNsPtr
operator|->
name|cmdTable
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|entryPtr
operator|!=
name|NULL
condition|;
name|entryPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
name|cmdName
operator|=
name|Tcl_GetHashKey
argument_list|(
operator|&
name|currNsPtr
operator|->
name|cmdTable
argument_list|,
name|entryPtr
argument_list|)
expr_stmt|;
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|entryPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TclIsProc
argument_list|(
name|cmdPtr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|pattern
operator|==
name|NULL
operator|)
operator|||
name|Tcl_StringMatch
argument_list|(
name|cmdName
argument_list|,
name|pattern
argument_list|)
condition|)
block|{
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|cmdName
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InfoScriptCmd --  *  *      Called to implement the "info script" command that returns the  *      script file that is currently being evaluated. Handles the  *      following syntax:  *  *          info script  *  * Results:  *      Returns TCL_OK is successful and TCL_ERROR is there is an error.  *  * Side effects:  *      Returns a result in the interpreter's result object. If there is  *	an error, the result is an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InfoScriptCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|iPtr
operator|->
name|scriptFile
operator|!=
name|NULL
condition|)
block|{
name|Tcl_SetStringObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|iPtr
operator|->
name|scriptFile
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InfoSharedlibCmd --  *  *      Called to implement the "info sharedlibextension" command that  *      returns the file extension used for shared libraries. Handles the  *      following syntax:  *  *          info sharedlibextension  *  * Results:  *      Returns TCL_OK is successful and TCL_ERROR is there is an error.  *  * Side effects:  *      Returns a result in the interpreter's result object. If there is  *	an error, the result is an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InfoSharedlibCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
if|if
condition|(
name|objc
operator|!=
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
ifdef|#
directive|ifdef
name|TCL_SHLIB_EXT
name|Tcl_SetStringObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|TCL_SHLIB_EXT
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InfoTclVersionCmd --  *  *      Called to implement the "info tclversion" command that returns the  *      version number for this Tcl library. Handles the following syntax:  *  *          info tclversion  *  * Results:  *      Returns TCL_OK is successful and TCL_ERROR is there is an error.  *  * Side effects:  *      Returns a result in the interpreter's result object. If there is  *	an error, the result is an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InfoTclVersionCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|char
modifier|*
name|version
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|version
operator|=
name|Tcl_GetVar
argument_list|(
name|interp
argument_list|,
literal|"tcl_version"
argument_list|,
operator|(
name|TCL_GLOBAL_ONLY
operator||
name|TCL_LEAVE_ERR_MSG
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
name|NULL
condition|)
block|{
name|Tcl_SetStringObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|version
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InfoVarsCmd --  *  *	Called to implement the "info vars" command that returns the  *	list of variables in the interpreter that match an optional pattern.  *	The pattern, if any, consists of an optional sequence of namespace  *	names separated by "::" qualifiers, which is followed by a  *	glob-style pattern that restricts which variables are returned.  *	Handles the following syntax:  *  *          info vars ?pattern?  *  * Results:  *      Returns TCL_OK is successful and TCL_ERROR is there is an error.  *  * Side effects:  *      Returns a result in the interpreter's result object. If there is  *	an error, the result is an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InfoVarsCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|char
modifier|*
name|varName
decl_stmt|,
modifier|*
name|pattern
decl_stmt|,
modifier|*
name|simplePattern
decl_stmt|;
specifier|register
name|Tcl_HashEntry
modifier|*
name|entryPtr
decl_stmt|;
name|Tcl_HashSearch
name|search
decl_stmt|;
name|Var
modifier|*
name|varPtr
decl_stmt|,
modifier|*
name|localVarPtr
decl_stmt|;
name|Namespace
modifier|*
name|nsPtr
decl_stmt|;
name|Namespace
modifier|*
name|globalNsPtr
init|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetGlobalNamespace
argument_list|(
name|interp
argument_list|)
decl_stmt|;
name|Namespace
modifier|*
name|currNsPtr
init|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetCurrentNamespace
argument_list|(
name|interp
argument_list|)
decl_stmt|;
name|Tcl_Obj
modifier|*
name|listPtr
decl_stmt|,
modifier|*
name|elemObjPtr
decl_stmt|;
name|int
name|specificNsInPattern
init|=
literal|0
decl_stmt|;
comment|/* Init. to avoid compiler warning. */
name|int
name|i
decl_stmt|,
name|result
decl_stmt|;
comment|/*      * Get the pattern and find the "effective namespace" in which to      * list variables. We only use this effective namespace if there's      * no active Tcl procedure frame.      */
if|if
condition|(
name|objc
operator|==
literal|2
condition|)
block|{
name|simplePattern
operator|=
name|NULL
expr_stmt|;
name|nsPtr
operator|=
name|currNsPtr
expr_stmt|;
name|specificNsInPattern
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|objc
operator|==
literal|3
condition|)
block|{
comment|/* 	 * From the pattern, get the effective namespace and the simple 	 * pattern (no namespace qualifiers or ::'s) at the end. If an 	 * error was found while parsing the pattern, return it. Otherwise, 	 * if the namespace wasn't found, just leave nsPtr NULL: we will 	 * return an empty list since no variables there can be found. 	 */
name|Namespace
modifier|*
name|dummy1NsPtr
decl_stmt|,
modifier|*
name|dummy2NsPtr
decl_stmt|;
name|pattern
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TclGetNamespaceForQualName
argument_list|(
name|interp
argument_list|,
name|pattern
argument_list|,
operator|(
name|Namespace
operator|*
operator|)
name|NULL
argument_list|,
comment|/*flags*/
name|TCL_LEAVE_ERR_MSG
argument_list|,
operator|&
name|nsPtr
argument_list|,
operator|&
name|dummy1NsPtr
argument_list|,
operator|&
name|dummy2NsPtr
argument_list|,
operator|&
name|simplePattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|nsPtr
operator|!=
name|NULL
condition|)
block|{
comment|/* we successfully found the pattern's ns */
name|specificNsInPattern
operator|=
operator|(
name|strcmp
argument_list|(
name|simplePattern
argument_list|,
name|pattern
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?pattern?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * If the namespace specified in the pattern wasn't found, just return.      */
if|if
condition|(
name|nsPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
name|listPtr
operator|=
name|Tcl_NewListObj
argument_list|(
literal|0
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iPtr
operator|->
name|varFramePtr
operator|==
name|NULL
operator|)
operator|||
operator|!
name|iPtr
operator|->
name|varFramePtr
operator|->
name|isProcCallFrame
operator|||
name|specificNsInPattern
condition|)
block|{
comment|/* 	 * There is no frame pointer, the frame pointer was pushed only 	 * to activate a namespace, or we are in a procedure call frame 	 * but a specific namespace was specified. Create a list containing 	 * only the variables in the effective namespace's variable table. 	 */
name|entryPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
name|nsPtr
operator|->
name|varTable
argument_list|,
operator|&
name|search
argument_list|)
expr_stmt|;
while|while
condition|(
name|entryPtr
operator|!=
name|NULL
condition|)
block|{
name|varPtr
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|entryPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TclIsVarUndefined
argument_list|(
name|varPtr
argument_list|)
operator|||
operator|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_NAMESPACE_VAR
operator|)
condition|)
block|{
name|varName
operator|=
name|Tcl_GetHashKey
argument_list|(
operator|&
name|nsPtr
operator|->
name|varTable
argument_list|,
name|entryPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|simplePattern
operator|==
name|NULL
operator|)
operator|||
name|Tcl_StringMatch
argument_list|(
name|varName
argument_list|,
name|simplePattern
argument_list|)
condition|)
block|{
if|if
condition|(
name|specificNsInPattern
condition|)
block|{
name|elemObjPtr
operator|=
name|Tcl_NewObj
argument_list|()
expr_stmt|;
name|Tcl_GetVariableFullName
argument_list|(
name|interp
argument_list|,
operator|(
name|Tcl_Var
operator|)
name|varPtr
argument_list|,
name|elemObjPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|elemObjPtr
operator|=
name|Tcl_NewStringObj
argument_list|(
name|varName
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
name|elemObjPtr
argument_list|)
expr_stmt|;
block|}
block|}
name|entryPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the effective namespace isn't the global :: namespace, and a 	 * specific namespace wasn't requested in the pattern (i.e., the 	 * pattern only specifies variable names), then add in all global :: 	 * variables that match the simple pattern. Of course, add in only 	 * those variables that aren't hidden by a variable in the effective 	 * namespace. 	 */
if|if
condition|(
operator|(
name|nsPtr
operator|!=
name|globalNsPtr
operator|)
operator|&&
operator|!
name|specificNsInPattern
condition|)
block|{
name|entryPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
name|globalNsPtr
operator|->
name|varTable
argument_list|,
operator|&
name|search
argument_list|)
expr_stmt|;
while|while
condition|(
name|entryPtr
operator|!=
name|NULL
condition|)
block|{
name|varPtr
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|entryPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TclIsVarUndefined
argument_list|(
name|varPtr
argument_list|)
operator|||
operator|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_NAMESPACE_VAR
operator|)
condition|)
block|{
name|varName
operator|=
name|Tcl_GetHashKey
argument_list|(
operator|&
name|globalNsPtr
operator|->
name|varTable
argument_list|,
name|entryPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|simplePattern
operator|==
name|NULL
operator|)
operator|||
name|Tcl_StringMatch
argument_list|(
name|varName
argument_list|,
name|simplePattern
argument_list|)
condition|)
block|{
if|if
condition|(
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|nsPtr
operator|->
name|varTable
argument_list|,
name|varName
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|varName
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|entryPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 	 * We're in a local call frame and no specific namespace was 	 * specific. Create a list that starts with the compiled locals 	 * (i.e. the ones stored in the call frame). 	 */
name|CallFrame
modifier|*
name|varFramePtr
init|=
name|iPtr
operator|->
name|varFramePtr
decl_stmt|;
name|int
name|localVarCt
init|=
name|varFramePtr
operator|->
name|numCompiledLocals
decl_stmt|;
name|Tcl_HashTable
modifier|*
name|varTablePtr
init|=
name|varFramePtr
operator|->
name|varTablePtr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|localVarPtr
operator|=
name|iPtr
operator|->
name|varFramePtr
operator|->
name|compiledLocals
init|;
name|i
operator|<
name|localVarCt
condition|;
name|i
operator|++
operator|,
name|localVarPtr
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|TclIsVarUndefined
argument_list|(
name|localVarPtr
argument_list|)
condition|)
block|{
name|varName
operator|=
name|localVarPtr
operator|->
name|name
expr_stmt|;
if|if
condition|(
operator|(
name|simplePattern
operator|==
name|NULL
operator|)
operator|||
name|Tcl_StringMatch
argument_list|(
name|varName
argument_list|,
name|simplePattern
argument_list|)
condition|)
block|{
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|varName
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Now add in the variables in the call frame's variable hash 	 * table (if one exists). 	 */
if|if
condition|(
name|varTablePtr
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|entryPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|varTablePtr
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|entryPtr
operator|!=
name|NULL
condition|;
name|entryPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
name|varPtr
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|entryPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TclIsVarUndefined
argument_list|(
name|varPtr
argument_list|)
condition|)
block|{
name|varName
operator|=
name|Tcl_GetHashKey
argument_list|(
name|varTablePtr
argument_list|,
name|entryPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|simplePattern
operator|==
name|NULL
operator|)
operator|||
name|Tcl_StringMatch
argument_list|(
name|varName
argument_list|,
name|simplePattern
argument_list|)
condition|)
block|{
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|varName
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_JoinObjCmd --  *  *	This procedure is invoked to process the "join" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_JoinObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* The argument objects. */
block|{
name|char
modifier|*
name|joinString
decl_stmt|,
modifier|*
name|bytes
decl_stmt|;
name|int
name|joinLength
decl_stmt|,
name|listLen
decl_stmt|,
name|length
decl_stmt|,
name|i
decl_stmt|,
name|result
decl_stmt|;
name|Tcl_Obj
modifier|*
modifier|*
name|elemPtrs
decl_stmt|;
if|if
condition|(
name|objc
operator|==
literal|2
condition|)
block|{
name|joinString
operator|=
literal|" "
expr_stmt|;
name|joinLength
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|objc
operator|==
literal|3
condition|)
block|{
name|joinString
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|joinLength
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"list ?joinString?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Make sure the list argument is a list object and get its length and      * a pointer to its array of element pointers.      */
name|result
operator|=
name|Tcl_ListObjGetElements
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|,
operator|&
name|listLen
argument_list|,
operator|&
name|elemPtrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
comment|/*      * Now concatenate strings to form the "joined" result. We append      * directly into the interpreter's result object.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|listLen
condition|;
name|i
operator|++
control|)
block|{
name|bytes
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|elemPtrs
index|[
name|i
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|joinString
argument_list|,
name|bytes
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|bytes
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_LindexObjCmd --  *  *	This object-based procedure is invoked to process the "lindex" Tcl  *	command. See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_LindexObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Obj
modifier|*
name|listPtr
decl_stmt|;
name|Tcl_Obj
modifier|*
modifier|*
name|elemPtrs
decl_stmt|;
name|int
name|listLen
decl_stmt|,
name|index
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"list index"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Convert the first argument to a list if necessary.      */
name|listPtr
operator|=
name|objv
index|[
literal|1
index|]
expr_stmt|;
name|result
operator|=
name|Tcl_ListObjGetElements
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
operator|&
name|listLen
argument_list|,
operator|&
name|elemPtrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
comment|/*      * Get the index from objv[2].      */
name|result
operator|=
name|TclGetIntForIndex
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|,
comment|/*endValue*/
operator|(
name|listLen
operator|-
literal|1
operator|)
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
if|if
condition|(
operator|(
name|index
operator|<
literal|0
operator|)
operator|||
operator|(
name|index
operator|>=
name|listLen
operator|)
condition|)
block|{
comment|/* 	 * The index is out of range: the result is an empty string object. 	 */
return|return
name|TCL_OK
return|;
block|}
comment|/*      * Make sure listPtr still refers to a list object. It might have been      * converted to an int above if the argument objects were shared.      */
if|if
condition|(
name|listPtr
operator|->
name|typePtr
operator|!=
operator|&
name|tclListType
condition|)
block|{
name|result
operator|=
name|Tcl_ListObjGetElements
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
operator|&
name|listLen
argument_list|,
operator|&
name|elemPtrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
comment|/*      * Set the interpreter's object result to the index-th list element.      */
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|elemPtrs
index|[
name|index
index|]
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_LinsertObjCmd --  *  *	This object-based procedure is invoked to process the "linsert" Tcl  *	command. See the user documentation for details on what it does.  *  * Results:  *	A new Tcl list object formed by inserting zero or more elements   *	into a list.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_LinsertObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
specifier|register
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Obj
modifier|*
name|listPtr
decl_stmt|,
modifier|*
name|resultPtr
decl_stmt|;
name|int
name|index
decl_stmt|,
name|isDuplicate
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"list index element ?element ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Get the index first since, if a conversion to int is needed, it      * will invalidate the list's internal representation.      */
name|result
operator|=
name|TclGetIntForIndex
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|,
comment|/*endValue*/
name|INT_MAX
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
comment|/*      * If the list object is unshared we can modify it directly. Otherwise      * we create a copy to modify: this is "copy on write". We create the      * duplicate directly in the interpreter's object result.      */
name|listPtr
operator|=
name|objv
index|[
literal|1
index|]
expr_stmt|;
name|isDuplicate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|listPtr
argument_list|)
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|resultPtr
operator|=
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
name|listPtr
operator|->
name|typePtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_InvalidateStringRep
argument_list|(
name|resultPtr
argument_list|)
expr_stmt|;
name|listPtr
operator|->
name|typePtr
operator|->
name|dupIntRepProc
argument_list|(
name|listPtr
argument_list|,
name|resultPtr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|listPtr
operator|->
name|bytes
operator|!=
name|NULL
condition|)
block|{
name|int
name|len
init|=
name|listPtr
operator|->
name|length
decl_stmt|;
name|TclInitStringRep
argument_list|(
name|resultPtr
argument_list|,
name|listPtr
operator|->
name|bytes
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|listPtr
operator|=
name|resultPtr
expr_stmt|;
name|isDuplicate
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|objc
operator|==
literal|4
operator|)
operator|&&
operator|(
name|index
operator|==
name|INT_MAX
operator|)
condition|)
block|{
comment|/* 	 * Special case: insert one element at the end of the list. 	 */
name|result
operator|=
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
name|objv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|objc
operator|>
literal|3
condition|)
block|{
name|result
operator|=
name|Tcl_ListObjReplace
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
name|index
argument_list|,
literal|0
argument_list|,
operator|(
name|objc
operator|-
literal|3
operator|)
argument_list|,
operator|&
operator|(
name|objv
index|[
literal|3
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
comment|/*      * Set the interpreter's object result.      */
if|if
condition|(
operator|!
name|isDuplicate
condition|)
block|{
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ListObjCmd --  *  *	This procedure is invoked to process the "list" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_ListObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
specifier|register
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
specifier|register
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* The argument objects. */
block|{
comment|/*      * If there are no list elements, the result is an empty object.      * Otherwise modify the interpreter's result object to be a list object.      */
if|if
condition|(
name|objc
operator|>
literal|1
condition|)
block|{
name|Tcl_SetListObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|objc
operator|-
literal|1
operator|)
argument_list|,
operator|&
operator|(
name|objv
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_LlengthObjCmd --  *  *	This object-based procedure is invoked to process the "llength" Tcl  *	command.  See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_LlengthObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
specifier|register
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|int
name|listLen
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"list"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|result
operator|=
name|Tcl_ListObjLength
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|,
operator|&
name|listLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
comment|/*      * Set the interpreter's object result to an integer object holding the      * length.       */
name|Tcl_SetIntObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|listLen
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_LrangeObjCmd --  *  *	This procedure is invoked to process the "lrange" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_LrangeObjCmd
parameter_list|(
name|notUsed
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|notUsed
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
specifier|register
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Obj
modifier|*
name|listPtr
decl_stmt|;
name|Tcl_Obj
modifier|*
modifier|*
name|elemPtrs
decl_stmt|;
name|int
name|listLen
decl_stmt|,
name|first
decl_stmt|,
name|last
decl_stmt|,
name|numElems
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"list first last"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Make sure the list argument is a list object and get its length and      * a pointer to its array of element pointers.      */
name|listPtr
operator|=
name|objv
index|[
literal|1
index|]
expr_stmt|;
name|result
operator|=
name|Tcl_ListObjGetElements
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
operator|&
name|listLen
argument_list|,
operator|&
name|elemPtrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
comment|/*      * Get the first and last indexes.      */
name|result
operator|=
name|TclGetIntForIndex
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|,
comment|/*endValue*/
operator|(
name|listLen
operator|-
literal|1
operator|)
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
if|if
condition|(
name|first
operator|<
literal|0
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|result
operator|=
name|TclGetIntForIndex
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|3
index|]
argument_list|,
comment|/*endValue*/
operator|(
name|listLen
operator|-
literal|1
operator|)
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
if|if
condition|(
name|last
operator|>=
name|listLen
condition|)
block|{
name|last
operator|=
operator|(
name|listLen
operator|-
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|first
operator|>
name|last
condition|)
block|{
return|return
name|TCL_OK
return|;
comment|/* the result is an empty object */
block|}
comment|/*      * Make sure listPtr still refers to a list object. It might have been      * converted to an int above if the argument objects were shared.      */
if|if
condition|(
name|listPtr
operator|->
name|typePtr
operator|!=
operator|&
name|tclListType
condition|)
block|{
name|result
operator|=
name|Tcl_ListObjGetElements
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
operator|&
name|listLen
argument_list|,
operator|&
name|elemPtrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
comment|/*      * Extract a range of fields. We modify the interpreter's result object      * to be a list object containing the specified elements.      */
name|numElems
operator|=
operator|(
name|last
operator|-
name|first
operator|+
literal|1
operator|)
expr_stmt|;
name|Tcl_SetListObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|numElems
argument_list|,
operator|&
operator|(
name|elemPtrs
index|[
name|first
index|]
operator|)
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_LreplaceObjCmd --  *  *	This object-based procedure is invoked to process the "lreplace"   *	Tcl command. See the user documentation for details on what it does.  *  * Results:  *	A new Tcl list object formed by replacing zero or more elements of  *	a list.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_LreplaceObjCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|listPtr
decl_stmt|;
name|int
name|createdNewObj
decl_stmt|,
name|first
decl_stmt|,
name|last
decl_stmt|,
name|listLen
decl_stmt|,
name|numToDelete
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"list first last ?element element ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * If the list object is unshared we can modify it directly, otherwise      * we create a copy to modify: this is "copy on write".      */
name|listPtr
operator|=
name|objv
index|[
literal|1
index|]
expr_stmt|;
name|createdNewObj
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|listPtr
argument_list|)
condition|)
block|{
name|listPtr
operator|=
name|Tcl_DuplicateObj
argument_list|(
name|listPtr
argument_list|)
expr_stmt|;
name|createdNewObj
operator|=
literal|1
expr_stmt|;
block|}
name|result
operator|=
name|Tcl_ListObjLength
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
operator|&
name|listLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|errorReturn
label|:
if|if
condition|(
name|createdNewObj
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|listPtr
argument_list|)
expr_stmt|;
comment|/* free unneeded obj */
block|}
return|return
name|result
return|;
block|}
comment|/*      * Get the first and last indexes.      */
name|result
operator|=
name|TclGetIntForIndex
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|,
comment|/*endValue*/
operator|(
name|listLen
operator|-
literal|1
operator|)
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|errorReturn
goto|;
block|}
name|result
operator|=
name|TclGetIntForIndex
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|3
index|]
argument_list|,
comment|/*endValue*/
operator|(
name|listLen
operator|-
literal|1
operator|)
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|errorReturn
goto|;
block|}
if|if
condition|(
name|first
operator|<
literal|0
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|first
operator|>=
name|listLen
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"list doesn't contain element "
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|errorReturn
goto|;
block|}
if|if
condition|(
name|last
operator|>=
name|listLen
condition|)
block|{
name|last
operator|=
operator|(
name|listLen
operator|-
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|first
operator|<=
name|last
condition|)
block|{
name|numToDelete
operator|=
operator|(
name|last
operator|-
name|first
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|numToDelete
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|objc
operator|>
literal|4
condition|)
block|{
name|result
operator|=
name|Tcl_ListObjReplace
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
name|first
argument_list|,
name|numToDelete
argument_list|,
operator|(
name|objc
operator|-
literal|4
operator|)
argument_list|,
operator|&
operator|(
name|objv
index|[
literal|4
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_ListObjReplace
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
name|first
argument_list|,
name|numToDelete
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|errorReturn
goto|;
block|}
comment|/*      * Set the interpreter's object result.       */
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_LsearchObjCmd --  *  *	This procedure is invoked to process the "lsearch" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_LsearchObjCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument values. */
block|{
define|#
directive|define
name|EXACT
value|0
define|#
directive|define
name|GLOB
value|1
define|#
directive|define
name|REGEXP
value|2
name|char
modifier|*
name|bytes
decl_stmt|,
modifier|*
name|patternBytes
decl_stmt|;
name|int
name|i
decl_stmt|,
name|match
decl_stmt|,
name|mode
decl_stmt|,
name|index
decl_stmt|,
name|result
decl_stmt|,
name|listLen
decl_stmt|,
name|length
decl_stmt|,
name|elemLen
decl_stmt|;
name|Tcl_Obj
modifier|*
modifier|*
name|elemPtrs
decl_stmt|;
specifier|static
name|char
modifier|*
name|switches
index|[]
init|=
block|{
literal|"-exact"
block|,
literal|"-glob"
block|,
literal|"-regexp"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
name|mode
operator|=
name|GLOB
expr_stmt|;
if|if
condition|(
name|objc
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|Tcl_GetIndexFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|,
name|switches
argument_list|,
literal|"search mode"
argument_list|,
literal|0
argument_list|,
operator|&
name|mode
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"?mode? list pattern"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Make sure the list argument is a list object and get its length and      * a pointer to its array of element pointers.      */
name|result
operator|=
name|Tcl_ListObjGetElements
argument_list|(
name|interp
argument_list|,
name|objv
index|[
name|objc
operator|-
literal|2
index|]
argument_list|,
operator|&
name|listLen
argument_list|,
operator|&
name|elemPtrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
name|patternBytes
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|objc
operator|-
literal|1
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|index
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|listLen
condition|;
name|i
operator|++
control|)
block|{
name|match
operator|=
literal|0
expr_stmt|;
name|bytes
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|elemPtrs
index|[
name|i
index|]
argument_list|,
operator|&
name|elemLen
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|EXACT
case|:
if|if
condition|(
name|length
operator|==
name|elemLen
condition|)
block|{
name|match
operator|=
operator|(
name|memcmp
argument_list|(
name|bytes
argument_list|,
name|patternBytes
argument_list|,
operator|(
name|size_t
operator|)
name|length
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|GLOB
case|:
comment|/* 		 * WARNING: will not work with data containing NULLs. 		 */
name|match
operator|=
name|Tcl_StringMatch
argument_list|(
name|bytes
argument_list|,
name|patternBytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP
case|:
comment|/* 		 * WARNING: will not work with data containing NULLs. 		 */
name|match
operator|=
name|Tcl_RegExpMatch
argument_list|(
name|interp
argument_list|,
name|bytes
argument_list|,
name|patternBytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|<
literal|0
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
break|break;
block|}
if|if
condition|(
name|match
condition|)
block|{
name|index
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|Tcl_SetIntObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_LsortObjCmd --  *  *	This procedure is invoked to process the "lsort" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_LsortObjCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument values. */
block|{
name|int
name|i
decl_stmt|,
name|index
decl_stmt|,
name|dummy
decl_stmt|;
name|Tcl_Obj
modifier|*
name|resultPtr
decl_stmt|;
name|int
name|length
decl_stmt|;
name|Tcl_Obj
modifier|*
name|cmdPtr
decl_stmt|,
modifier|*
modifier|*
name|listObjPtrs
decl_stmt|;
name|SortElement
modifier|*
name|elementArray
decl_stmt|;
name|SortElement
modifier|*
name|elementPtr
decl_stmt|;
name|SortInfo
name|sortInfo
decl_stmt|;
comment|/* Information about this sort that                                          * needs to be passed to the                                           * comparison function */
specifier|static
name|char
modifier|*
name|switches
index|[]
init|=
block|{
literal|"-ascii"
block|,
literal|"-command"
block|,
literal|"-decreasing"
block|,
literal|"-dictionary"
block|,
literal|"-increasing"
block|,
literal|"-index"
block|,
literal|"-integer"
block|,
literal|"-real"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
name|resultPtr
operator|=
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
name|objc
operator|<
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"?options? list"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Parse arguments to set up the mode for the sort.      */
name|sortInfo
operator|.
name|isIncreasing
operator|=
literal|1
expr_stmt|;
name|sortInfo
operator|.
name|sortMode
operator|=
name|SORTMODE_ASCII
expr_stmt|;
name|sortInfo
operator|.
name|index
operator|=
operator|-
literal|1
expr_stmt|;
name|sortInfo
operator|.
name|interp
operator|=
name|interp
expr_stmt|;
name|sortInfo
operator|.
name|resultCode
operator|=
name|TCL_OK
expr_stmt|;
name|cmdPtr
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|objc
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Tcl_GetIndexFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
name|i
index|]
argument_list|,
name|switches
argument_list|,
literal|"option"
argument_list|,
literal|0
argument_list|,
operator|&
name|index
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
switch|switch
condition|(
name|index
condition|)
block|{
case|case
literal|0
case|:
comment|/* -ascii */
name|sortInfo
operator|.
name|sortMode
operator|=
name|SORTMODE_ASCII
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* -command */
if|if
condition|(
name|i
operator|==
operator|(
name|objc
operator|-
literal|2
operator|)
condition|)
block|{
name|Tcl_AppendToObj
argument_list|(
name|resultPtr
argument_list|,
literal|"\"-command\" option must be followed by comparison command"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|sortInfo
operator|.
name|sortMode
operator|=
name|SORTMODE_COMMAND
expr_stmt|;
name|cmdPtr
operator|=
name|objv
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* -decreasing */
name|sortInfo
operator|.
name|isIncreasing
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* -dictionary */
name|sortInfo
operator|.
name|sortMode
operator|=
name|SORTMODE_DICTIONARY
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* -increasing */
name|sortInfo
operator|.
name|isIncreasing
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* -index */
if|if
condition|(
name|i
operator|==
operator|(
name|objc
operator|-
literal|2
operator|)
condition|)
block|{
name|Tcl_AppendToObj
argument_list|(
name|resultPtr
argument_list|,
literal|"\"-index\" option must be followed by list index"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|TclGetIntForIndex
argument_list|(
name|interp
argument_list|,
name|objv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|-
literal|2
argument_list|,
operator|&
name|sortInfo
operator|.
name|index
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|cmdPtr
operator|=
name|objv
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* -integer */
name|sortInfo
operator|.
name|sortMode
operator|=
name|SORTMODE_INTEGER
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* -real */
name|sortInfo
operator|.
name|sortMode
operator|=
name|SORTMODE_REAL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sortInfo
operator|.
name|sortMode
operator|==
name|SORTMODE_COMMAND
condition|)
block|{
name|Tcl_DStringInit
argument_list|(
operator|&
name|sortInfo
operator|.
name|compareCmd
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|sortInfo
operator|.
name|compareCmd
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|cmdPtr
argument_list|,
operator|&
name|dummy
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|sortInfo
operator|.
name|resultCode
operator|=
name|Tcl_ListObjGetElements
argument_list|(
name|interp
argument_list|,
name|objv
index|[
name|objc
operator|-
literal|1
index|]
argument_list|,
operator|&
name|length
argument_list|,
operator|&
name|listObjPtrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|sortInfo
operator|.
name|resultCode
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
name|elementArray
operator|=
operator|(
name|SortElement
operator|*
operator|)
name|ckalloc
argument_list|(
name|length
operator|*
sizeof|sizeof
argument_list|(
name|SortElement
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|elementArray
index|[
name|i
index|]
operator|.
name|objPtr
operator|=
name|listObjPtrs
index|[
name|i
index|]
expr_stmt|;
name|elementArray
index|[
name|i
index|]
operator|.
name|nextPtr
operator|=
operator|&
name|elementArray
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|elementArray
index|[
name|length
operator|-
literal|1
index|]
operator|.
name|nextPtr
operator|=
name|NULL
expr_stmt|;
name|elementPtr
operator|=
name|MergeSort
argument_list|(
name|elementArray
argument_list|,
operator|&
name|sortInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|sortInfo
operator|.
name|resultCode
operator|==
name|TCL_OK
condition|)
block|{
comment|/* 	 * Note: must clear the interpreter's result object: it could 	 * have been set by the -command script. 	 */
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|resultPtr
operator|=
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|elementPtr
operator|!=
name|NULL
condition|;
name|elementPtr
operator|=
name|elementPtr
operator|->
name|nextPtr
control|)
block|{
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|resultPtr
argument_list|,
name|elementPtr
operator|->
name|objPtr
argument_list|)
expr_stmt|;
block|}
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|elementArray
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|sortInfo
operator|.
name|sortMode
operator|==
name|SORTMODE_COMMAND
condition|)
block|{
name|Tcl_DStringFree
argument_list|(
operator|&
name|sortInfo
operator|.
name|compareCmd
argument_list|)
expr_stmt|;
block|}
return|return
name|sortInfo
operator|.
name|resultCode
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * MergeSort -  *  *	This procedure sorts a linked list of SortElement structures  *	use the merge-sort algorithm.  *  * Results:  *      A pointer to the head of the list after sorting is returned.  *  * Side effects:  *	None, unless a user-defined comparison command does something  *	weird.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|SortElement
modifier|*
name|MergeSort
parameter_list|(
name|headPtr
parameter_list|,
name|infoPtr
parameter_list|)
name|SortElement
modifier|*
name|headPtr
decl_stmt|;
comment|/* First element on the list */
name|SortInfo
modifier|*
name|infoPtr
decl_stmt|;
comment|/* Information needed by the                                          * comparison operator */
block|{
comment|/*      * The subList array below holds pointers to temporary lists built      * during the merge sort.  Element i of the array holds a list of      * length 2**i.      */
define|#
directive|define
name|NUM_LISTS
value|30
name|SortElement
modifier|*
name|subList
index|[
name|NUM_LISTS
index|]
decl_stmt|;
name|SortElement
modifier|*
name|elementPtr
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_LISTS
condition|;
name|i
operator|++
control|)
block|{
name|subList
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
while|while
condition|(
name|headPtr
operator|!=
name|NULL
condition|)
block|{
name|elementPtr
operator|=
name|headPtr
expr_stmt|;
name|headPtr
operator|=
name|headPtr
operator|->
name|nextPtr
expr_stmt|;
name|elementPtr
operator|->
name|nextPtr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|NUM_LISTS
operator|)
operator|&&
operator|(
name|subList
index|[
name|i
index|]
operator|!=
name|NULL
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|elementPtr
operator|=
name|MergeLists
argument_list|(
name|subList
index|[
name|i
index|]
argument_list|,
name|elementPtr
argument_list|,
name|infoPtr
argument_list|)
expr_stmt|;
name|subList
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|NUM_LISTS
condition|)
block|{
name|i
operator|=
name|NUM_LISTS
operator|-
literal|1
expr_stmt|;
block|}
name|subList
index|[
name|i
index|]
operator|=
name|elementPtr
expr_stmt|;
block|}
name|elementPtr
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_LISTS
condition|;
name|i
operator|++
control|)
block|{
name|elementPtr
operator|=
name|MergeLists
argument_list|(
name|subList
index|[
name|i
index|]
argument_list|,
name|elementPtr
argument_list|,
name|infoPtr
argument_list|)
expr_stmt|;
block|}
return|return
name|elementPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * MergeLists -  *  *	This procedure combines two sorted lists of SortElement structures  *	into a single sorted list.  *  * Results:  *      The unified list of SortElement structures.  *  * Side effects:  *	None, unless a user-defined comparison command does something  *	weird.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|SortElement
modifier|*
name|MergeLists
parameter_list|(
name|leftPtr
parameter_list|,
name|rightPtr
parameter_list|,
name|infoPtr
parameter_list|)
name|SortElement
modifier|*
name|leftPtr
decl_stmt|;
comment|/* First list to be merged; may be 					 * NULL. */
name|SortElement
modifier|*
name|rightPtr
decl_stmt|;
comment|/* Second list to be merged; may be 					 * NULL. */
name|SortInfo
modifier|*
name|infoPtr
decl_stmt|;
comment|/* Information needed by the                                          * comparison operator. */
block|{
name|SortElement
modifier|*
name|headPtr
decl_stmt|;
name|SortElement
modifier|*
name|tailPtr
decl_stmt|;
if|if
condition|(
name|leftPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|rightPtr
return|;
block|}
if|if
condition|(
name|rightPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|leftPtr
return|;
block|}
if|if
condition|(
name|SortCompare
argument_list|(
name|leftPtr
operator|->
name|objPtr
argument_list|,
name|rightPtr
operator|->
name|objPtr
argument_list|,
name|infoPtr
argument_list|)
operator|>
literal|0
condition|)
block|{
name|tailPtr
operator|=
name|rightPtr
expr_stmt|;
name|rightPtr
operator|=
name|rightPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
name|tailPtr
operator|=
name|leftPtr
expr_stmt|;
name|leftPtr
operator|=
name|leftPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
name|headPtr
operator|=
name|tailPtr
expr_stmt|;
while|while
condition|(
operator|(
name|leftPtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|rightPtr
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|SortCompare
argument_list|(
name|leftPtr
operator|->
name|objPtr
argument_list|,
name|rightPtr
operator|->
name|objPtr
argument_list|,
name|infoPtr
argument_list|)
operator|>
literal|0
condition|)
block|{
name|tailPtr
operator|->
name|nextPtr
operator|=
name|rightPtr
expr_stmt|;
name|tailPtr
operator|=
name|rightPtr
expr_stmt|;
name|rightPtr
operator|=
name|rightPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
name|tailPtr
operator|->
name|nextPtr
operator|=
name|leftPtr
expr_stmt|;
name|tailPtr
operator|=
name|leftPtr
expr_stmt|;
name|leftPtr
operator|=
name|leftPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|leftPtr
operator|!=
name|NULL
condition|)
block|{
name|tailPtr
operator|->
name|nextPtr
operator|=
name|leftPtr
expr_stmt|;
block|}
else|else
block|{
name|tailPtr
operator|->
name|nextPtr
operator|=
name|rightPtr
expr_stmt|;
block|}
return|return
name|headPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SortCompare --  *  *	This procedure is invoked by MergeLists to determine the proper  *	ordering between two elements.  *  * Results:  *      A negative results means the the first element comes before the  *      second, and a positive results means that the second element  *      should come first.  A result of zero means the two elements  *      are equal and it doesn't matter which comes first.  *  * Side effects:  *	None, unless a user-defined comparison command does something  *	weird.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SortCompare
parameter_list|(
name|objPtr1
parameter_list|,
name|objPtr2
parameter_list|,
name|infoPtr
parameter_list|)
name|Tcl_Obj
modifier|*
name|objPtr1
decl_stmt|,
decl|*
name|objPtr2
decl_stmt|;
end_function

begin_comment
comment|/* Values to be compared. */
end_comment

begin_decl_stmt
name|SortInfo
modifier|*
name|infoPtr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Information passed from the                                          * top-level "lsort" command */
end_comment

begin_block
block|{
name|int
name|order
decl_stmt|,
name|dummy
decl_stmt|,
name|listLen
decl_stmt|,
name|index
decl_stmt|;
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|char
name|buffer
index|[
literal|30
index|]
decl_stmt|;
name|order
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|infoPtr
operator|->
name|resultCode
operator|!=
name|TCL_OK
condition|)
block|{
comment|/* 	 * Once an error has occurred, skip any future comparisons 	 * so as to preserve the error message in sortInterp->result. 	 */
return|return
name|order
return|;
block|}
if|if
condition|(
name|infoPtr
operator|->
name|index
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 	 * The "-index" option was specified.  Treat each object as a 	 * list, extract the requested element from each list, and 	 * compare the elements, not the lists.  The special index "end" 	 * is signaled here with a large negative index. 	 */
if|if
condition|(
name|Tcl_ListObjLength
argument_list|(
name|infoPtr
operator|->
name|interp
argument_list|,
name|objPtr1
argument_list|,
operator|&
name|listLen
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|infoPtr
operator|->
name|resultCode
operator|=
name|TCL_ERROR
expr_stmt|;
return|return
name|order
return|;
block|}
if|if
condition|(
name|infoPtr
operator|->
name|index
operator|<
operator|-
literal|1
condition|)
block|{
name|index
operator|=
name|listLen
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|index
operator|=
name|infoPtr
operator|->
name|index
expr_stmt|;
block|}
if|if
condition|(
name|Tcl_ListObjIndex
argument_list|(
name|infoPtr
operator|->
name|interp
argument_list|,
name|objPtr1
argument_list|,
name|index
argument_list|,
operator|&
name|objPtr
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|infoPtr
operator|->
name|resultCode
operator|=
name|TCL_ERROR
expr_stmt|;
return|return
name|order
return|;
block|}
if|if
condition|(
name|objPtr
operator|==
name|NULL
condition|)
block|{
name|objPtr
operator|=
name|objPtr1
expr_stmt|;
name|missingElement
label|:
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|infoPtr
operator|->
name|index
argument_list|)
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|infoPtr
operator|->
name|interp
argument_list|)
argument_list|,
literal|"element "
argument_list|,
name|buffer
argument_list|,
literal|" missing from sublist \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|infoPtr
operator|->
name|resultCode
operator|=
name|TCL_ERROR
expr_stmt|;
return|return
name|order
return|;
block|}
name|objPtr1
operator|=
name|objPtr
expr_stmt|;
if|if
condition|(
name|Tcl_ListObjLength
argument_list|(
name|infoPtr
operator|->
name|interp
argument_list|,
name|objPtr2
argument_list|,
operator|&
name|listLen
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|infoPtr
operator|->
name|resultCode
operator|=
name|TCL_ERROR
expr_stmt|;
return|return
name|order
return|;
block|}
if|if
condition|(
name|infoPtr
operator|->
name|index
operator|<
operator|-
literal|1
condition|)
block|{
name|index
operator|=
name|listLen
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|index
operator|=
name|infoPtr
operator|->
name|index
expr_stmt|;
block|}
if|if
condition|(
name|Tcl_ListObjIndex
argument_list|(
name|infoPtr
operator|->
name|interp
argument_list|,
name|objPtr2
argument_list|,
name|index
argument_list|,
operator|&
name|objPtr
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|infoPtr
operator|->
name|resultCode
operator|=
name|TCL_ERROR
expr_stmt|;
return|return
name|order
return|;
block|}
if|if
condition|(
name|objPtr
operator|==
name|NULL
condition|)
block|{
name|objPtr
operator|=
name|objPtr2
expr_stmt|;
goto|goto
name|missingElement
goto|;
block|}
name|objPtr2
operator|=
name|objPtr
expr_stmt|;
block|}
if|if
condition|(
name|infoPtr
operator|->
name|sortMode
operator|==
name|SORTMODE_ASCII
condition|)
block|{
name|order
operator|=
name|strcmp
argument_list|(
name|Tcl_GetStringFromObj
argument_list|(
name|objPtr1
argument_list|,
operator|&
name|dummy
argument_list|)
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objPtr2
argument_list|,
operator|&
name|dummy
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|infoPtr
operator|->
name|sortMode
operator|==
name|SORTMODE_DICTIONARY
condition|)
block|{
name|order
operator|=
name|DictionaryCompare
argument_list|(
name|Tcl_GetStringFromObj
argument_list|(
name|objPtr1
argument_list|,
operator|&
name|dummy
argument_list|)
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objPtr2
argument_list|,
operator|&
name|dummy
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|infoPtr
operator|->
name|sortMode
operator|==
name|SORTMODE_INTEGER
condition|)
block|{
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
if|if
condition|(
operator|(
name|Tcl_GetIntFromObj
argument_list|(
name|infoPtr
operator|->
name|interp
argument_list|,
name|objPtr1
argument_list|,
operator|&
name|a
argument_list|)
operator|!=
name|TCL_OK
operator|)
operator|||
operator|(
name|Tcl_GetIntFromObj
argument_list|(
name|infoPtr
operator|->
name|interp
argument_list|,
name|objPtr2
argument_list|,
operator|&
name|b
argument_list|)
operator|!=
name|TCL_OK
operator|)
condition|)
block|{
name|infoPtr
operator|->
name|resultCode
operator|=
name|TCL_ERROR
expr_stmt|;
return|return
name|order
return|;
block|}
if|if
condition|(
name|a
operator|>
name|b
condition|)
block|{
name|order
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|>
name|a
condition|)
block|{
name|order
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|infoPtr
operator|->
name|sortMode
operator|==
name|SORTMODE_REAL
condition|)
block|{
name|double
name|a
decl_stmt|,
name|b
decl_stmt|;
if|if
condition|(
operator|(
name|Tcl_GetDoubleFromObj
argument_list|(
name|infoPtr
operator|->
name|interp
argument_list|,
name|objPtr1
argument_list|,
operator|&
name|a
argument_list|)
operator|!=
name|TCL_OK
operator|)
operator|||
operator|(
name|Tcl_GetDoubleFromObj
argument_list|(
name|infoPtr
operator|->
name|interp
argument_list|,
name|objPtr2
argument_list|,
operator|&
name|b
argument_list|)
operator|!=
name|TCL_OK
operator|)
condition|)
block|{
name|infoPtr
operator|->
name|resultCode
operator|=
name|TCL_ERROR
expr_stmt|;
return|return
name|order
return|;
block|}
if|if
condition|(
name|a
operator|>
name|b
condition|)
block|{
name|order
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|>
name|a
condition|)
block|{
name|order
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|oldLength
decl_stmt|;
comment|/* 	 * Generate and evaluate a command to determine which string comes 	 * first. 	 */
name|oldLength
operator|=
name|Tcl_DStringLength
argument_list|(
operator|&
name|infoPtr
operator|->
name|compareCmd
argument_list|)
expr_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
operator|&
name|infoPtr
operator|->
name|compareCmd
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objPtr1
argument_list|,
operator|&
name|dummy
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
operator|&
name|infoPtr
operator|->
name|compareCmd
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objPtr2
argument_list|,
operator|&
name|dummy
argument_list|)
argument_list|)
expr_stmt|;
name|infoPtr
operator|->
name|resultCode
operator|=
name|Tcl_Eval
argument_list|(
name|infoPtr
operator|->
name|interp
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|infoPtr
operator|->
name|compareCmd
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DStringTrunc
argument_list|(
operator|&
name|infoPtr
operator|->
name|compareCmd
argument_list|,
name|oldLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoPtr
operator|->
name|resultCode
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_AddErrorInfo
argument_list|(
name|infoPtr
operator|->
name|interp
argument_list|,
literal|"\n    (-compare command)"
argument_list|)
expr_stmt|;
return|return
name|order
return|;
block|}
comment|/* 	 * Parse the result of the command. 	 */
if|if
condition|(
name|Tcl_GetIntFromObj
argument_list|(
name|infoPtr
operator|->
name|interp
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|infoPtr
operator|->
name|interp
argument_list|)
argument_list|,
operator|&
name|order
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|infoPtr
operator|->
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|infoPtr
operator|->
name|interp
argument_list|)
argument_list|,
literal|"-compare command returned non-numeric result"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|infoPtr
operator|->
name|resultCode
operator|=
name|TCL_ERROR
expr_stmt|;
return|return
name|order
return|;
block|}
block|}
if|if
condition|(
operator|!
name|infoPtr
operator|->
name|isIncreasing
condition|)
block|{
name|order
operator|=
operator|-
name|order
expr_stmt|;
block|}
return|return
name|order
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DictionaryCompare  *  *	This function compares two strings as if they were being used in  *	an index or card catalog.  The case of alphabetic characters is  *	ignored, except to break ties.  Thus "B" comes before "b" but  *	after "a".  Also, integers embedded in the strings compare in  *	numerical order.  In other words, "x10y" comes after "x9y", not  *      before it as it would when using strcmp().  *  * Results:  *      A negative result means that the first element comes before the  *      second, and a positive result means that the second element  *      should come first.  A result of zero means the two elements  *      are equal and it doesn't matter which comes first.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|DictionaryCompare
parameter_list|(
name|left
parameter_list|,
name|right
parameter_list|)
name|char
modifier|*
name|left
decl_stmt|,
decl|*
name|right
decl_stmt|;
end_function

begin_comment
comment|/* The strings to compare */
end_comment

begin_block
block|{
name|int
name|diff
decl_stmt|,
name|zeros
decl_stmt|;
name|int
name|secondaryDiff
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|right
argument_list|)
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|left
argument_list|)
argument_list|)
condition|)
block|{
comment|/* 	     * There are decimal numbers embedded in the two 	     * strings.  Compare them as numbers, rather than 	     * strings.  If one number has more leading zeros than 	     * the other, the number with more leading zeros sorts 	     * later, but only as a secondary choice. 	     */
name|zeros
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|right
operator|==
literal|'0'
condition|)
block|{
name|right
operator|++
expr_stmt|;
name|zeros
operator|--
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|left
operator|==
literal|'0'
condition|)
block|{
name|left
operator|++
expr_stmt|;
name|zeros
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|secondaryDiff
operator|==
literal|0
condition|)
block|{
name|secondaryDiff
operator|=
name|zeros
expr_stmt|;
block|}
comment|/* 	     * The code below compares the numbers in the two 	     * strings without ever converting them to integers.  It 	     * does this by first comparing the lengths of the 	     * numbers and then comparing the digit values. 	     */
name|diff
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
block|{
name|diff
operator|=
operator|*
name|left
operator|-
operator|*
name|right
expr_stmt|;
block|}
name|right
operator|++
expr_stmt|;
name|left
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|right
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|left
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* 			 * The two numbers have the same length. See 			 * if their values are different. 			 */
if|if
condition|(
name|diff
operator|!=
literal|0
condition|)
block|{
return|return
name|diff
return|;
block|}
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|left
argument_list|)
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
continue|continue;
block|}
name|diff
operator|=
operator|*
name|left
operator|-
operator|*
name|right
expr_stmt|;
if|if
condition|(
name|diff
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|left
argument_list|)
argument_list|)
operator|&&
name|islower
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|right
argument_list|)
argument_list|)
condition|)
block|{
name|diff
operator|=
name|tolower
argument_list|(
operator|*
name|left
argument_list|)
operator|-
operator|*
name|right
expr_stmt|;
if|if
condition|(
name|diff
condition|)
block|{
return|return
name|diff
return|;
block|}
elseif|else
if|if
condition|(
name|secondaryDiff
operator|==
literal|0
condition|)
block|{
name|secondaryDiff
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isupper
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|right
argument_list|)
argument_list|)
operator|&&
name|islower
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|left
argument_list|)
argument_list|)
condition|)
block|{
name|diff
operator|=
operator|*
name|left
operator|-
name|tolower
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|right
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
condition|)
block|{
return|return
name|diff
return|;
block|}
elseif|else
if|if
condition|(
name|secondaryDiff
operator|==
literal|0
condition|)
block|{
name|secondaryDiff
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
name|diff
return|;
block|}
block|}
if|if
condition|(
operator|*
name|left
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|left
operator|++
expr_stmt|;
name|right
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
block|{
name|diff
operator|=
name|secondaryDiff
expr_stmt|;
block|}
return|return
name|diff
return|;
block|}
end_block

end_unit

