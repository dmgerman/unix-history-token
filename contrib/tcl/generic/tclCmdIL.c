begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclCmdIL.c --  *  *	This file contains the top-level command routines for most of  *	the Tcl built-in commands whose names begin with the letters  *	I through L.  It contains only commands in the generic core  *	(i.e. those that don't depend much upon UNIX facilities).  *  * Copyright (c) 1987-1993 The Regents of the University of California.  * Copyright (c) 1994-1995 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclCmdIL.c 1.119 96/03/22 12:10:14  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * The following variable holds the full path name of the binary  * from which this application was executed, or NULL if it isn't  * know.  The value of the variable is set by the procedure  * Tcl_FindExecutable.  The storage space is dynamically allocated.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|tclExecutableName
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The variables below are used to implement the "lsort" command.  * Unfortunately, this use of static variables prevents "lsort"  * from being thread-safe, but there's no alternative given the  * current implementation of qsort.  In a threaded environment  * these variables should be made thread-local if possible, or else  * "lsort" needs internal mutual exclusion.  */
end_comment

begin_decl_stmt
specifier|static
name|Tcl_Interp
modifier|*
name|sortInterp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Interpreter for "lsort" command.  					 * NULL means no lsort is active. */
end_comment

begin_enum
specifier|static
enum|enum
block|{
name|ASCII
block|,
name|INTEGER
block|,
name|REAL
block|,
name|COMMAND
block|}
name|sortMode
enum|;
end_enum

begin_comment
comment|/* Mode for sorting: compare as strings, 					 * compare as numbers, or call 					 * user-defined command for 					 * comparison. */
end_comment

begin_decl_stmt
specifier|static
name|Tcl_DString
name|sortCmd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds command if mode is COMMAND. 					 * pre-initialized to hold base of 					 * command. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sortIncreasing
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 means sort in decreasing order, 					 * 1 means increasing order. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sortCode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Anything other than TCL_OK means a 					 * problem occurred while sorting; this 					 * executing a comparison command, so 					 * the sort was aborted. */
end_comment

begin_comment
comment|/*  * Forward declarations for procedures defined in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|SortCompareProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|CONST
name|VOID
operator|*
name|first
operator|,
name|CONST
name|VOID
operator|*
name|second
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_IfCmd --  *  *	This procedure is invoked to process the "if" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_IfCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|i
decl_stmt|,
name|result
decl_stmt|,
name|value
decl_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* 	 * At this point in the loop, argv and argc refer to an expression 	 * to test, either for the main expression or an expression 	 * following an "elseif".  The arguments after the expression must 	 * be "then" (optional) and a script to execute if the expression is 	 * true. 	 */
if|if
condition|(
name|i
operator|>=
name|argc
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: no expression after \""
argument_list|,
name|argv
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
literal|"\" argument"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|result
operator|=
name|Tcl_ExprBoolean
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
name|i
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|<
name|argc
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"then"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|argc
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: no script following \""
argument_list|,
name|argv
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
literal|"\" argument"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|value
condition|)
block|{
return|return
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
return|;
block|}
comment|/* 	 * The expression evaluated to false.  Skip the command, then 	 * see if there is an "else" or "elseif" clause. 	 */
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|argc
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"elseif"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
comment|/*      * Couldn't find a "then" or "elseif" clause to execute.  Check now      * for an "else" clause.  We know that there's at least one more      * argument when we get here.      */
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"else"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|argc
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: no script following \"else\" argument"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
return|return
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_IncrCmd --  *  *	This procedure is invoked to process the "incr" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_IncrCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|value
decl_stmt|;
name|char
modifier|*
name|oldString
decl_stmt|,
modifier|*
name|result
decl_stmt|;
name|char
name|newString
index|[
literal|30
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|argc
operator|!=
literal|2
operator|)
operator|&&
operator|(
name|argc
operator|!=
literal|3
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" varName ?increment?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|oldString
operator|=
name|Tcl_GetVar
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldString
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|oldString
argument_list|,
operator|&
name|value
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
literal|"\n    (reading value of variable to increment)"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
name|value
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|increment
decl_stmt|;
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|increment
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
literal|"\n    (reading increment)"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|value
operator|+=
name|increment
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|newString
argument_list|,
literal|"%d"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|newString
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|interp
operator|->
name|result
operator|=
name|result
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_InfoCmd --  *  *	This procedure is invoked to process the "info" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_InfoCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|size_t
name|length
decl_stmt|;
name|int
name|c
decl_stmt|;
name|Arg
modifier|*
name|argPtr
decl_stmt|;
name|Proc
modifier|*
name|procPtr
decl_stmt|;
name|Var
modifier|*
name|varPtr
decl_stmt|;
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|Tcl_HashSearch
name|search
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" option ?arg arg ...?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|c
operator|=
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'a'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"args"
argument_list|,
name|length
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" args procname\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|procPtr
operator|=
name|TclFindProc
argument_list|(
name|iPtr
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|procPtr
operator|==
name|NULL
condition|)
block|{
name|infoNoSuchProc
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"\""
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"\" isn't a procedure"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
for|for
control|(
name|argPtr
operator|=
name|procPtr
operator|->
name|argPtr
init|;
name|argPtr
operator|!=
name|NULL
condition|;
name|argPtr
operator|=
name|argPtr
operator|->
name|nextPtr
control|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|argPtr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'b'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"body"
argument_list|,
name|length
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" body procname\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|procPtr
operator|=
name|TclFindProc
argument_list|(
name|iPtr
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|procPtr
operator|==
name|NULL
condition|)
block|{
goto|goto
name|infoNoSuchProc
goto|;
block|}
name|iPtr
operator|->
name|result
operator|=
name|procPtr
operator|->
name|command
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'c'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"cmdcount"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|2
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" cmdcount\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|sprintf
argument_list|(
name|iPtr
operator|->
name|result
argument_list|,
literal|"%d"
argument_list|,
name|iPtr
operator|->
name|cmdCount
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'c'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"commands"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|4
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" commands ?pattern?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|commandTable
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
name|char
modifier|*
name|name
init|=
name|Tcl_GetHashKey
argument_list|(
operator|&
name|iPtr
operator|->
name|commandTable
argument_list|,
name|hPtr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|argc
operator|==
literal|3
operator|)
operator|&&
operator|!
name|Tcl_StringMatch
argument_list|(
name|name
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'c'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"complete"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|4
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" complete command\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_CommandComplete
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"1"
expr_stmt|;
block|}
else|else
block|{
name|interp
operator|->
name|result
operator|=
literal|"0"
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'d'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"default"
argument_list|,
name|length
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|5
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" default procname arg varname\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|procPtr
operator|=
name|TclFindProc
argument_list|(
name|iPtr
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|procPtr
operator|==
name|NULL
condition|)
block|{
goto|goto
name|infoNoSuchProc
goto|;
block|}
for|for
control|(
name|argPtr
operator|=
name|procPtr
operator|->
name|argPtr
init|;
condition|;
name|argPtr
operator|=
name|argPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|argPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"procedure \""
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"\" doesn't have an argument \""
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|,
name|argPtr
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argPtr
operator|->
name|defValue
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|Tcl_SetVar
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
name|argPtr
operator|->
name|defValue
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|defStoreError
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't store default value in variable \""
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|iPtr
operator|->
name|result
operator|=
literal|"1"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Tcl_SetVar
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|defStoreError
goto|;
block|}
name|iPtr
operator|->
name|result
operator|=
literal|"0"
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"exists"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" exists varName\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|p
operator|=
name|Tcl_GetVar
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * The code below handles the special case where the name is for 	 * an array:  Tcl_GetVar will reject this since you can't read 	 * an array variable without an index. 	 */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|Var
modifier|*
name|varPtr
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|'('
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|noVar
label|:
name|iPtr
operator|->
name|result
operator|=
literal|"0"
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|iPtr
operator|->
name|varFramePtr
operator|==
name|NULL
condition|)
block|{
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|globalTable
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|varFramePtr
operator|->
name|varTable
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hPtr
operator|==
name|NULL
condition|)
block|{
goto|goto
name|noVar
goto|;
block|}
name|varPtr
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_UPVAR
condition|)
block|{
name|varPtr
operator|=
name|varPtr
operator|->
name|value
operator|.
name|upvarPtr
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_ARRAY
operator|)
condition|)
block|{
goto|goto
name|noVar
goto|;
block|}
block|}
name|iPtr
operator|->
name|result
operator|=
literal|"1"
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'g'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"globals"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" globals ?pattern?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|globalTable
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
name|varPtr
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_UNDEFINED
condition|)
block|{
continue|continue;
block|}
name|name
operator|=
name|Tcl_GetHashKey
argument_list|(
operator|&
name|iPtr
operator|->
name|globalTable
argument_list|,
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|argc
operator|==
literal|3
operator|)
operator|&&
operator|!
name|Tcl_StringMatch
argument_list|(
name|name
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'h'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"hostname"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" hostname\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|Tcl_GetHostName
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'l'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"level"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|2
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|iPtr
operator|->
name|varFramePtr
operator|==
name|NULL
condition|)
block|{
name|iPtr
operator|->
name|result
operator|=
literal|"0"
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|iPtr
operator|->
name|result
argument_list|,
literal|"%d"
argument_list|,
name|iPtr
operator|->
name|varFramePtr
operator|->
name|level
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
block|{
name|int
name|level
decl_stmt|;
name|CallFrame
modifier|*
name|framePtr
decl_stmt|;
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|level
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|level
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|iPtr
operator|->
name|varFramePtr
operator|==
name|NULL
condition|)
block|{
name|levelError
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad level \""
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|level
operator|+=
name|iPtr
operator|->
name|varFramePtr
operator|->
name|level
expr_stmt|;
block|}
for|for
control|(
name|framePtr
operator|=
name|iPtr
operator|->
name|varFramePtr
init|;
name|framePtr
operator|!=
name|NULL
condition|;
name|framePtr
operator|=
name|framePtr
operator|->
name|callerVarPtr
control|)
block|{
if|if
condition|(
name|framePtr
operator|->
name|level
operator|==
name|level
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|framePtr
operator|==
name|NULL
condition|)
block|{
goto|goto
name|levelError
goto|;
block|}
name|iPtr
operator|->
name|result
operator|=
name|Tcl_Merge
argument_list|(
name|framePtr
operator|->
name|argc
argument_list|,
name|framePtr
operator|->
name|argv
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|freeProc
operator|=
name|TCL_DYNAMIC
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" level [number]\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'l'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"library"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|2
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" library\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|interp
operator|->
name|result
operator|=
name|Tcl_GetVar
argument_list|(
name|interp
argument_list|,
literal|"tcl_library"
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|interp
operator|->
name|result
operator|==
name|NULL
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"no library has been specified for Tcl"
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'l'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"loaded"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|3
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|argc
operator|!=
literal|2
operator|)
operator|&&
operator|(
name|argc
operator|!=
literal|3
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" loaded ?interp?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TclGetLoadedPackages
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'l'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"locals"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|3
operator|)
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" locals ?pattern?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|iPtr
operator|->
name|varFramePtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|varFramePtr
operator|->
name|varTable
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
name|varPtr
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|varPtr
operator|->
name|flags
operator|&
operator|(
name|VAR_UNDEFINED
operator||
name|VAR_UPVAR
operator|)
condition|)
block|{
continue|continue;
block|}
name|name
operator|=
name|Tcl_GetHashKey
argument_list|(
operator|&
name|iPtr
operator|->
name|varFramePtr
operator|->
name|varTable
argument_list|,
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|argc
operator|==
literal|3
operator|)
operator|&&
operator|!
name|Tcl_StringMatch
argument_list|(
name|name
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'n'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"nameofexecutable"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" nameofexecutable\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|tclExecutableName
operator|!=
name|NULL
condition|)
block|{
name|interp
operator|->
name|result
operator|=
name|tclExecutableName
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'p'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"patchlevel"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|2
operator|)
condition|)
block|{
name|char
modifier|*
name|value
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" patchlevel\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|value
operator|=
name|Tcl_GetVar
argument_list|(
name|interp
argument_list|,
literal|"tcl_patchLevel"
argument_list|,
name|TCL_GLOBAL_ONLY
operator||
name|TCL_LEAVE_ERR_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|interp
operator|->
name|result
operator|=
name|value
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'p'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"procs"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|2
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" procs ?pattern?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|commandTable
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
name|char
modifier|*
name|name
init|=
name|Tcl_GetHashKey
argument_list|(
operator|&
name|iPtr
operator|->
name|commandTable
argument_list|,
name|hPtr
argument_list|)
decl_stmt|;
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TclIsProc
argument_list|(
name|cmdPtr
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|argc
operator|==
literal|3
operator|)
operator|&&
operator|!
name|Tcl_StringMatch
argument_list|(
name|name
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'s'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"script"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|2
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" script\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|iPtr
operator|->
name|scriptFile
operator|!=
name|NULL
condition|)
block|{
comment|/* 	     * Can't depend on iPtr->scriptFile to be non-volatile: 	     * if this command is returned as the result of the script, 	     * then iPtr->scriptFile will go away. 	     */
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|iPtr
operator|->
name|scriptFile
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'s'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"sharedlibextension"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|2
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" sharedlibextension\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
ifdef|#
directive|ifdef
name|TCL_SHLIB_EXT
name|interp
operator|->
name|result
operator|=
name|TCL_SHLIB_EXT
expr_stmt|;
endif|#
directive|endif
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'t'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"tclversion"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|char
modifier|*
name|value
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" tclversion\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|value
operator|=
name|Tcl_GetVar
argument_list|(
name|interp
argument_list|,
literal|"tcl_version"
argument_list|,
name|TCL_GLOBAL_ONLY
operator||
name|TCL_LEAVE_ERR_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|interp
operator|->
name|result
operator|=
name|value
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'v'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"vars"
argument_list|,
name|length
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|Tcl_HashTable
modifier|*
name|tablePtr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" vars ?pattern?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|iPtr
operator|->
name|varFramePtr
operator|==
name|NULL
condition|)
block|{
name|tablePtr
operator|=
operator|&
name|iPtr
operator|->
name|globalTable
expr_stmt|;
block|}
else|else
block|{
name|tablePtr
operator|=
operator|&
name|iPtr
operator|->
name|varFramePtr
operator|->
name|varTable
expr_stmt|;
block|}
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|tablePtr
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
name|varPtr
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|varPtr
operator|->
name|flags
operator|&
name|VAR_UNDEFINED
condition|)
block|{
continue|continue;
block|}
name|name
operator|=
name|Tcl_GetHashKey
argument_list|(
name|tablePtr
argument_list|,
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|argc
operator|==
literal|3
operator|)
operator|&&
operator|!
name|Tcl_StringMatch
argument_list|(
name|name
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": should be args, body, cmdcount, commands, "
argument_list|,
literal|"complete, default, "
argument_list|,
literal|"exists, globals, hostname, level, library, loaded, locals, "
argument_list|,
literal|"nameofexecutable, patchlevel, procs, script, "
argument_list|,
literal|"sharedlibextension, tclversion, or vars"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_JoinCmd --  *  *	This procedure is invoked to process the "join" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_JoinCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|char
modifier|*
name|joinString
decl_stmt|;
name|char
modifier|*
modifier|*
name|listArgv
decl_stmt|;
name|int
name|listArgc
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
name|joinString
operator|=
literal|" "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
block|{
name|joinString
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" list ?joinString?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_SplitList
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|listArgc
argument_list|,
operator|&
name|listArgv
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|listArgc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|listArgv
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|joinString
argument_list|,
name|listArgv
index|[
name|i
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|listArgv
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_LindexCmd --  *  *	This procedure is invoked to process the "lindex" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_LindexCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|element
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|index
decl_stmt|,
name|size
decl_stmt|,
name|parenthesized
decl_stmt|,
name|result
decl_stmt|,
name|returnLast
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" list index\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|argv
index|[
literal|2
index|]
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"end"
argument_list|,
name|strlen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|returnLast
operator|=
literal|1
expr_stmt|;
name|index
operator|=
name|INT_MAX
expr_stmt|;
block|}
else|else
block|{
name|returnLast
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|index
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
for|for
control|(
name|p
operator|=
name|argv
index|[
literal|1
index|]
init|;
name|index
operator|>=
literal|0
condition|;
name|index
operator|--
control|)
block|{
name|result
operator|=
name|TclFindElement
argument_list|(
name|interp
argument_list|,
name|p
argument_list|,
operator|&
name|element
argument_list|,
operator|&
name|next
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|parenthesized
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|next
operator|==
literal|0
operator|)
operator|&&
name|returnLast
condition|)
block|{
break|break;
block|}
name|p
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|size
operator|>=
name|TCL_RESULT_SIZE
condition|)
block|{
name|interp
operator|->
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|interp
operator|->
name|freeProc
operator|=
name|TCL_DYNAMIC
expr_stmt|;
block|}
if|if
condition|(
name|parenthesized
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|interp
operator|->
name|result
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|element
argument_list|,
operator|(
name|size_t
operator|)
name|size
argument_list|)
expr_stmt|;
name|interp
operator|->
name|result
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|TclCopyAndCollapse
argument_list|(
name|size
argument_list|,
name|element
argument_list|,
name|interp
operator|->
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_LinsertCmd --  *  *	This procedure is invoked to process the "linsert" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_LinsertCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|element
decl_stmt|,
name|savedChar
decl_stmt|;
name|int
name|i
decl_stmt|,
name|index
decl_stmt|,
name|count
decl_stmt|,
name|result
decl_stmt|,
name|size
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|4
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" list index element ?element ...?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|argv
index|[
literal|2
index|]
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"end"
argument_list|,
name|strlen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|index
operator|=
name|INT_MAX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|index
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Skip over the first "index" elements of the list, then add      * all of those elements to the result.      */
name|size
operator|=
literal|0
expr_stmt|;
name|element
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|p
operator|=
name|argv
index|[
literal|1
index|]
init|;
operator|(
name|count
operator|<
name|index
operator|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|0
operator|)
condition|;
name|count
operator|++
control|)
block|{
name|result
operator|=
name|TclFindElement
argument_list|(
name|interp
argument_list|,
name|p
argument_list|,
operator|&
name|element
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|size
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|end
operator|=
name|element
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|element
operator|!=
name|argv
index|[
literal|1
index|]
condition|)
block|{
while|while
condition|(
operator|(
operator|*
name|end
operator|!=
literal|0
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|end
argument_list|)
argument_list|)
condition|)
block|{
name|end
operator|++
expr_stmt|;
block|}
block|}
name|savedChar
operator|=
operator|*
name|end
expr_stmt|;
operator|*
name|end
operator|=
literal|0
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
name|savedChar
expr_stmt|;
block|}
comment|/*      * Add the new list elements.      */
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/*      * Append the remainder of the original list.      */
if|if
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|" "
argument_list|,
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ListCmd --  *  *	This procedure is invoked to process the "list" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_ListCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
if|if
condition|(
name|argc
operator|>=
literal|2
condition|)
block|{
name|interp
operator|->
name|result
operator|=
name|Tcl_Merge
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|)
expr_stmt|;
name|interp
operator|->
name|freeProc
operator|=
name|TCL_DYNAMIC
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_LlengthCmd --  *  *	This procedure is invoked to process the "llength" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_LlengthCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|count
decl_stmt|,
name|result
decl_stmt|;
name|char
modifier|*
name|element
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" list\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|p
operator|=
name|argv
index|[
literal|1
index|]
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|count
operator|++
control|)
block|{
name|result
operator|=
name|TclFindElement
argument_list|(
name|interp
argument_list|,
name|p
argument_list|,
operator|&
name|element
argument_list|,
operator|&
name|p
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
if|if
condition|(
operator|*
name|element
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"%d"
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_LrangeCmd --  *  *	This procedure is invoked to process the "lrange" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_LrangeCmd
parameter_list|(
name|notUsed
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|notUsed
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|first
decl_stmt|,
name|last
decl_stmt|,
name|result
decl_stmt|;
name|char
modifier|*
name|begin
decl_stmt|,
modifier|*
name|end
decl_stmt|,
name|c
decl_stmt|,
modifier|*
name|dummy
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|count
decl_stmt|,
name|firstIsEnd
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" list first last\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|argv
index|[
literal|2
index|]
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"end"
argument_list|,
name|strlen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|firstIsEnd
operator|=
literal|1
expr_stmt|;
name|first
operator|=
name|INT_MAX
expr_stmt|;
block|}
else|else
block|{
name|firstIsEnd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|first
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
if|if
condition|(
name|first
operator|<
literal|0
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|argv
index|[
literal|3
index|]
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|,
literal|"end"
argument_list|,
name|strlen
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|last
operator|=
name|INT_MAX
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
operator|&
name|last
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"expected integer or \"end\" but got \""
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
if|if
condition|(
operator|(
name|first
operator|>
name|last
operator|)
operator|&&
operator|!
name|firstIsEnd
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
comment|/*      * Extract a range of fields.      */
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|begin
operator|=
name|argv
index|[
literal|1
index|]
init|;
name|count
operator|<
name|first
condition|;
name|begin
operator|=
name|next
operator|,
name|count
operator|++
control|)
block|{
name|result
operator|=
name|TclFindElement
argument_list|(
name|interp
argument_list|,
name|begin
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|next
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
if|if
condition|(
operator|*
name|next
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|firstIsEnd
condition|)
block|{
name|first
operator|=
name|count
expr_stmt|;
block|}
else|else
block|{
name|begin
operator|=
name|next
expr_stmt|;
block|}
break|break;
block|}
block|}
for|for
control|(
name|count
operator|=
name|first
operator|,
name|end
operator|=
name|begin
init|;
operator|(
name|count
operator|<=
name|last
operator|)
operator|&&
operator|(
operator|*
name|end
operator|!=
literal|0
operator|)
condition|;
name|count
operator|++
control|)
block|{
name|result
operator|=
name|TclFindElement
argument_list|(
name|interp
argument_list|,
name|end
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|end
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
if|if
condition|(
name|end
operator|==
name|begin
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
comment|/*      * Chop off trailing spaces.      */
while|while
condition|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
name|end
index|[
operator|-
literal|1
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|end
operator|--
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|end
expr_stmt|;
operator|*
name|end
operator|=
literal|0
expr_stmt|;
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|begin
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
name|c
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_LreplaceCmd --  *  *	This procedure is invoked to process the "lreplace" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_LreplaceCmd
parameter_list|(
name|notUsed
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|notUsed
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|element
decl_stmt|,
name|savedChar
decl_stmt|,
modifier|*
name|dummy
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|i
decl_stmt|,
name|first
decl_stmt|,
name|last
decl_stmt|,
name|count
decl_stmt|,
name|result
decl_stmt|,
name|size
decl_stmt|,
name|firstIsEnd
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|4
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" list first last ?element element ...?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|argv
index|[
literal|2
index|]
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"end"
argument_list|,
name|strlen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|firstIsEnd
operator|=
literal|1
expr_stmt|;
name|first
operator|=
name|INT_MAX
expr_stmt|;
block|}
else|else
block|{
name|firstIsEnd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|first
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad index \""
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"\": must be integer or \"end\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
if|if
condition|(
operator|(
operator|*
name|argv
index|[
literal|3
index|]
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|,
literal|"end"
argument_list|,
name|strlen
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|last
operator|=
name|INT_MAX
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
operator|&
name|last
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad index \""
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
literal|"\": must be integer or \"end\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
if|if
condition|(
name|first
operator|<
literal|0
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * Skip over the elements of the list before "first".      */
name|size
operator|=
literal|0
expr_stmt|;
name|element
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|p1
operator|=
name|argv
index|[
literal|1
index|]
init|;
operator|(
name|count
operator|<
name|first
operator|)
operator|&&
operator|(
operator|*
name|p1
operator|!=
literal|0
operator|)
condition|;
name|count
operator|++
control|)
block|{
name|result
operator|=
name|TclFindElement
argument_list|(
name|interp
argument_list|,
name|p1
argument_list|,
operator|&
name|element
argument_list|,
operator|&
name|next
argument_list|,
operator|&
name|size
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|next
operator|==
literal|0
operator|)
operator|&&
name|firstIsEnd
condition|)
block|{
break|break;
block|}
name|p1
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p1
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"list doesn't contain element "
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Skip over the elements of the list up through "last".      */
for|for
control|(
name|p2
operator|=
name|p1
init|;
operator|(
name|count
operator|<=
name|last
operator|)
operator|&&
operator|(
operator|*
name|p2
operator|!=
literal|0
operator|)
condition|;
name|count
operator|++
control|)
block|{
name|result
operator|=
name|TclFindElement
argument_list|(
name|interp
argument_list|,
name|p2
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|p2
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
comment|/*      * Add the elements before "first" to the result.  Drop any terminating      * white space, since a separator will be added below, if needed.      */
while|while
condition|(
operator|(
name|p1
operator|!=
name|argv
index|[
literal|1
index|]
operator|)
operator|&&
operator|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
name|p1
index|[
operator|-
literal|1
index|]
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|p1
operator|--
expr_stmt|;
block|}
name|savedChar
operator|=
operator|*
name|p1
expr_stmt|;
operator|*
name|p1
operator|=
literal|0
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|p1
operator|=
name|savedChar
expr_stmt|;
comment|/*      * Add the new list elements.      */
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/*      * Append the remainder of the original list.      */
if|if
condition|(
operator|*
name|p2
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|interp
operator|->
name|result
operator|==
literal|0
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|p2
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|" "
argument_list|,
name|p2
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_LsearchCmd --  *  *	This procedure is invoked to process the "lsearch" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_LsearchCmd
parameter_list|(
name|notUsed
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|notUsed
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
define|#
directive|define
name|EXACT
value|0
define|#
directive|define
name|GLOB
value|1
define|#
directive|define
name|REGEXP
value|2
name|int
name|listArgc
decl_stmt|;
name|char
modifier|*
modifier|*
name|listArgv
decl_stmt|;
name|int
name|i
decl_stmt|,
name|match
decl_stmt|,
name|mode
decl_stmt|,
name|index
decl_stmt|;
name|mode
operator|=
name|GLOB
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-exact"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mode
operator|=
name|EXACT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-glob"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mode
operator|=
name|GLOB
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-regexp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mode
operator|=
name|REGEXP
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad search mode \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": must be -exact, -glob, or -regexp"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" ?mode? list pattern\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_SplitList
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|argc
operator|-
literal|2
index|]
argument_list|,
operator|&
name|listArgc
argument_list|,
operator|&
name|listArgv
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|index
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|listArgc
condition|;
name|i
operator|++
control|)
block|{
name|match
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|EXACT
case|:
name|match
operator|=
operator|(
name|strcmp
argument_list|(
name|listArgv
index|[
name|i
index|]
argument_list|,
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|GLOB
case|:
name|match
operator|=
name|Tcl_StringMatch
argument_list|(
name|listArgv
index|[
name|i
index|]
argument_list|,
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGEXP
case|:
name|match
operator|=
name|Tcl_RegExpMatch
argument_list|(
name|interp
argument_list|,
name|listArgv
index|[
name|i
index|]
argument_list|,
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|<
literal|0
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|listArgv
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
break|break;
block|}
if|if
condition|(
name|match
condition|)
block|{
name|index
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"%d"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|listArgv
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_LsortCmd --  *  *	This procedure is invoked to process the "lsort" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_LsortCmd
parameter_list|(
name|notUsed
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|notUsed
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|listArgc
decl_stmt|,
name|i
decl_stmt|,
name|c
decl_stmt|;
name|size_t
name|length
decl_stmt|;
name|char
modifier|*
modifier|*
name|listArgv
decl_stmt|;
name|char
modifier|*
name|command
init|=
name|NULL
decl_stmt|;
comment|/* Initialization needed only to 					 * prevent compiler warning. */
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" ?-ascii? ?-integer? ?-real? ?-increasing? ?-decreasing?"
argument_list|,
literal|" ?-command string? list\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|sortInterp
operator|!=
name|NULL
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"can't invoke \"lsort\" recursively"
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Parse arguments to set up the mode for the sort.      */
name|sortInterp
operator|=
name|interp
expr_stmt|;
name|sortMode
operator|=
name|ASCII
expr_stmt|;
name|sortIncreasing
operator|=
literal|1
expr_stmt|;
name|sortCode
operator|=
name|TCL_OK
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|length
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|2
condition|)
block|{
name|badSwitch
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad switch \""
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
literal|"\": must be -ascii, -integer, -real, -increasing"
argument_list|,
literal|" -decreasing, or -command"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|sortCode
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|c
operator|=
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'a'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-ascii"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|sortMode
operator|=
name|ASCII
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'c'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-command"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|argc
operator|-
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"\"-command\" must be"
argument_list|,
literal|" followed by comparison command"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|sortCode
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sortMode
operator|=
name|COMMAND
expr_stmt|;
name|command
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'d'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-decreasing"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|sortIncreasing
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'i'
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|4
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-increasing"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|sortIncreasing
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'i'
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|4
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-integer"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|sortMode
operator|=
name|INTEGER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'r'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-real"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|sortMode
operator|=
name|REAL
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|badSwitch
goto|;
block|}
block|}
if|if
condition|(
name|sortMode
operator|==
name|COMMAND
condition|)
block|{
name|Tcl_DStringInit
argument_list|(
operator|&
name|sortCmd
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|sortCmd
argument_list|,
name|command
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Tcl_SplitList
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|,
operator|&
name|listArgc
argument_list|,
operator|&
name|listArgv
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|sortCode
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|qsort
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|listArgv
argument_list|,
operator|(
name|size_t
operator|)
name|listArgc
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|SortCompareProc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sortCode
operator|==
name|TCL_OK
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|interp
operator|->
name|result
operator|=
name|Tcl_Merge
argument_list|(
name|listArgc
argument_list|,
name|listArgv
argument_list|)
expr_stmt|;
name|interp
operator|->
name|freeProc
operator|=
name|TCL_DYNAMIC
expr_stmt|;
block|}
if|if
condition|(
name|sortMode
operator|==
name|COMMAND
condition|)
block|{
name|Tcl_DStringFree
argument_list|(
operator|&
name|sortCmd
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|listArgv
argument_list|)
expr_stmt|;
name|done
label|:
name|sortInterp
operator|=
name|NULL
expr_stmt|;
return|return
name|sortCode
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SortCompareProc --  *  *	This procedure is invoked by qsort to determine the proper  *	ordering between two elements.  *  * Results:  *< 0 means first is "smaller" than "second",> 0 means "first"  *	is larger than "second", and 0 means they should be treated  *	as equal.  *  * Side effects:  *	None, unless a user-defined comparison command does something  *	weird.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SortCompareProc
parameter_list|(
name|first
parameter_list|,
name|second
parameter_list|)
name|CONST
name|VOID
modifier|*
name|first
decl_stmt|,
decl|*
name|second
decl_stmt|;
end_function

begin_comment
comment|/* Elements to be compared. */
end_comment

begin_block
block|{
name|int
name|order
decl_stmt|;
name|char
modifier|*
name|firstString
init|=
operator|*
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
name|first
operator|)
decl_stmt|;
name|char
modifier|*
name|secondString
init|=
operator|*
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
name|second
operator|)
decl_stmt|;
name|order
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sortCode
operator|!=
name|TCL_OK
condition|)
block|{
comment|/* 	 * Once an error has occurred, skip any future comparisons 	 * so as to preserve the error message in sortInterp->result. 	 */
return|return
name|order
return|;
block|}
if|if
condition|(
name|sortMode
operator|==
name|ASCII
condition|)
block|{
name|order
operator|=
name|strcmp
argument_list|(
name|firstString
argument_list|,
name|secondString
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sortMode
operator|==
name|INTEGER
condition|)
block|{
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
if|if
condition|(
operator|(
name|Tcl_GetInt
argument_list|(
name|sortInterp
argument_list|,
name|firstString
argument_list|,
operator|&
name|a
argument_list|)
operator|!=
name|TCL_OK
operator|)
operator|||
operator|(
name|Tcl_GetInt
argument_list|(
name|sortInterp
argument_list|,
name|secondString
argument_list|,
operator|&
name|b
argument_list|)
operator|!=
name|TCL_OK
operator|)
condition|)
block|{
name|Tcl_AddErrorInfo
argument_list|(
name|sortInterp
argument_list|,
literal|"\n    (converting list element from string to integer)"
argument_list|)
expr_stmt|;
name|sortCode
operator|=
name|TCL_ERROR
expr_stmt|;
return|return
name|order
return|;
block|}
if|if
condition|(
name|a
operator|>
name|b
condition|)
block|{
name|order
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|>
name|a
condition|)
block|{
name|order
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sortMode
operator|==
name|REAL
condition|)
block|{
name|double
name|a
decl_stmt|,
name|b
decl_stmt|;
if|if
condition|(
operator|(
name|Tcl_GetDouble
argument_list|(
name|sortInterp
argument_list|,
name|firstString
argument_list|,
operator|&
name|a
argument_list|)
operator|!=
name|TCL_OK
operator|)
operator|||
operator|(
name|Tcl_GetDouble
argument_list|(
name|sortInterp
argument_list|,
name|secondString
argument_list|,
operator|&
name|b
argument_list|)
operator|!=
name|TCL_OK
operator|)
condition|)
block|{
name|Tcl_AddErrorInfo
argument_list|(
name|sortInterp
argument_list|,
literal|"\n    (converting list element from string to real)"
argument_list|)
expr_stmt|;
name|sortCode
operator|=
name|TCL_ERROR
expr_stmt|;
return|return
name|order
return|;
block|}
if|if
condition|(
name|a
operator|>
name|b
condition|)
block|{
name|order
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|>
name|a
condition|)
block|{
name|order
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|oldLength
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
comment|/* 	 * Generate and evaluate a command to determine which string comes 	 * first. 	 */
name|oldLength
operator|=
name|Tcl_DStringLength
argument_list|(
operator|&
name|sortCmd
argument_list|)
expr_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
operator|&
name|sortCmd
argument_list|,
name|firstString
argument_list|)
expr_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
operator|&
name|sortCmd
argument_list|,
name|secondString
argument_list|)
expr_stmt|;
name|sortCode
operator|=
name|Tcl_Eval
argument_list|(
name|sortInterp
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|sortCmd
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DStringTrunc
argument_list|(
operator|&
name|sortCmd
argument_list|,
name|oldLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|sortCode
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_AddErrorInfo
argument_list|(
name|sortInterp
argument_list|,
literal|"\n    (user-defined comparison command)"
argument_list|)
expr_stmt|;
return|return
name|order
return|;
block|}
comment|/* 	 * Parse the result of the command. 	 */
name|order
operator|=
name|strtol
argument_list|(
name|sortInterp
operator|->
name|result
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|end
operator|==
name|sortInterp
operator|->
name|result
operator|)
operator|||
operator|(
operator|*
name|end
operator|!=
literal|0
operator|)
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|sortInterp
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|sortInterp
argument_list|,
literal|"comparison command returned non-numeric result"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|sortCode
operator|=
name|TCL_ERROR
expr_stmt|;
return|return
name|order
return|;
block|}
block|}
if|if
condition|(
operator|!
name|sortIncreasing
condition|)
block|{
name|order
operator|=
operator|-
name|order
expr_stmt|;
block|}
return|return
name|order
return|;
block|}
end_block

end_unit

