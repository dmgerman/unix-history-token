begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclEvent.c --  *  *	This file provides basic event-managing facilities for Tcl,  *	including an event queue, and mechanisms for attaching  *	callbacks to certain events.  *  *	It also contains the command procedures for the commands  *	"after", "vwait", and "update".  *  * Copyright (c) 1990-1994 The Regents of the University of California.  * Copyright (c) 1994-1995 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclEvent.c 1.127 96/03/22 12:12:33  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * For each file registered in a call to Tcl_CreateFileHandler,  * there is one record of the following type.  All of these records  * are chained together into a single list.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|FileHandler
block|{
name|Tcl_File
name|file
decl_stmt|;
comment|/* Generic file handle for file. */
name|int
name|mask
decl_stmt|;
comment|/* Mask of desired events: TCL_READABLE, etc. */
name|int
name|readyMask
decl_stmt|;
comment|/* Events that were ready the last time that 				 * FileHandlerCheckProc checked this file. */
name|Tcl_FileProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to call, in the style of 				 * Tcl_CreateFileHandler.  This is NULL 				 * if the handler was created by 				 * Tcl_CreateFileHandler2. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Argument to pass to proc. */
name|struct
name|FileHandler
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next in list of all files we care 				 * about (NULL for end of list). */
block|}
name|FileHandler
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|FileHandler
modifier|*
name|firstFileHandlerPtr
init|=
operator|(
name|FileHandler
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of all file handlers. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fileEventSourceCreated
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that the file event source 				 * hasn't been registerd with the Tcl 				 * notifier yet. */
end_comment

begin_comment
comment|/*  * The following structure is what is added to the Tcl event queue when  * file handlers are ready to fire.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|FileHandlerEvent
block|{
name|Tcl_Event
name|header
decl_stmt|;
comment|/* Information that is standard for 				 * all events. */
name|Tcl_File
name|file
decl_stmt|;
comment|/* File descriptor that is ready.  Used 				 * to find the FileHandler structure for 				 * the file (can't point directly to the 				 * FileHandler structure because it could 				 * go away while the event is queued). */
block|}
name|FileHandlerEvent
typedef|;
end_typedef

begin_comment
comment|/*  * For each timer callback that's pending (either regular or "modal"),  * there is one record of the following type.  The normal handlers  * (created by Tcl_CreateTimerHandler) are chained together in a  * list sorted by time (earliest event first).  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|TimerHandler
block|{
name|Tcl_Time
name|time
decl_stmt|;
comment|/* When timer is to fire. */
name|Tcl_TimerProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to call. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Argument to pass to proc. */
name|Tcl_TimerToken
name|token
decl_stmt|;
comment|/* Identifies event so it can be 					 * deleted.  Not used in modal 					 * timeouts. */
name|struct
name|TimerHandler
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next event in queue, or NULL for 					 * end of queue. */
block|}
name|TimerHandler
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|TimerHandler
modifier|*
name|firstTimerHandlerPtr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First event in queue. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|timerEventSourceCreated
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 means that the timer event source 					 * hasn't yet been registered with the 					 * Tcl notifier. */
end_comment

begin_comment
comment|/*  * The information below describes a stack of modal timeouts managed by  * Tcl_CreateModalTimer and Tcl_DeleteModalTimer.  Only the first element  * in the list is used at any given time.  */
end_comment

begin_decl_stmt
specifier|static
name|TimerHandler
modifier|*
name|firstModalHandlerPtr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The following structure is what's added to the Tcl event queue when  * timer handlers are ready to fire.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|TimerEvent
block|{
name|Tcl_Event
name|header
decl_stmt|;
comment|/* Information that is standard for 					 * all events. */
name|Tcl_Time
name|time
decl_stmt|;
comment|/* All timer events that specify this 					 * time or earlier are ready                                          * to fire. */
block|}
name|TimerEvent
typedef|;
end_typedef

begin_comment
comment|/*  * There is one of the following structures for each of the  * handlers declared in a call to Tcl_DoWhenIdle.  All of the  * currently-active handlers are linked together into a list.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|IdleHandler
block|{
name|Tcl_IdleProc
argument_list|(
operator|*
name|proc
argument_list|)
expr_stmt|;
comment|/* Procedure to call. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Value to pass to proc. */
name|int
name|generation
decl_stmt|;
comment|/* Used to distinguish older handlers from 				 * recently-created ones. */
name|struct
name|IdleHandler
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next in list of active handlers. */
block|}
name|IdleHandler
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|IdleHandler
modifier|*
name|idleList
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First in list of all idle handlers. */
end_comment

begin_decl_stmt
specifier|static
name|IdleHandler
modifier|*
name|lastIdlePtr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last in list (or NULL for empty list). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|idleGeneration
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to fill in the "generation" fields 				 * of IdleHandler structures.  Increments 				 * each time Tcl_DoOneEvent starts calling 				 * idle handlers, so that all old handlers 				 * can be called without calling any of the 				 * new ones created by old ones. */
end_comment

begin_comment
comment|/*  * The data structure below is used by the "after" command to remember  * the command to be executed later.  All of the pending "after" commands  * for an interpreter are linked together in a list.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|AfterInfo
block|{
name|struct
name|AfterAssocData
modifier|*
name|assocPtr
decl_stmt|;
comment|/* Pointer to the "tclAfter" assocData for 				 * the interp in which command will be 				 * executed. */
name|char
modifier|*
name|command
decl_stmt|;
comment|/* Command to execute.  Malloc'ed, so must 				 * be freed when structure is deallocated. */
name|int
name|id
decl_stmt|;
comment|/* Integer identifier for command;  used to 				 * cancel it. */
name|Tcl_TimerToken
name|token
decl_stmt|;
comment|/* Used to cancel the "after" command.  NULL 				 * means that the command is run as an 				 * idle handler rather than as a timer 				 * handler.  NULL means this is an "after 				 * idle" handler rather than a                                  * timer handler. */
name|struct
name|AfterInfo
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next in list of all "after" commands for 				 * this interpreter. */
block|}
name|AfterInfo
typedef|;
end_typedef

begin_comment
comment|/*  * One of the following structures is associated with each interpreter  * for which an "after" command has ever been invoked.  A pointer to  * this structure is stored in the AssocData for the "tclAfter" key.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|AfterAssocData
block|{
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interpreter for which this data is 				 * registered. */
name|AfterInfo
modifier|*
name|firstAfterPtr
decl_stmt|;
comment|/* First in list of all "after" commands 				 * still pending for this interpreter, or 				 * NULL if none. */
block|}
name|AfterAssocData
typedef|;
end_typedef

begin_comment
comment|/*  * The data structure below is used to report background errors.  One  * such structure is allocated for each error;  it holds information  * about the interpreter and the error until bgerror can be invoked  * later as an idle handler.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|BgError
block|{
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which error occurred.  NULL 				 * means this error report has been cancelled 				 * (a previous report generated a break). */
name|char
modifier|*
name|errorMsg
decl_stmt|;
comment|/* The error message (interp->result when 				 * the error occurred).  Malloc-ed. */
name|char
modifier|*
name|errorInfo
decl_stmt|;
comment|/* Value of the errorInfo variable 				 * (malloc-ed). */
name|char
modifier|*
name|errorCode
decl_stmt|;
comment|/* Value of the errorCode variable 				 * (malloc-ed). */
name|struct
name|BgError
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next in list of all pending error 				 * reports for this interpreter, or NULL 				 * for end of list. */
block|}
name|BgError
typedef|;
end_typedef

begin_comment
comment|/*  * One of the structures below is associated with the "tclBgError"  * assoc data for each interpreter.  It keeps track of the head and  * tail of the list of pending background errors for the interpreter.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ErrAssocData
block|{
name|BgError
modifier|*
name|firstBgPtr
decl_stmt|;
comment|/* First in list of all background errors 				 * waiting to be processed for this 				 * interpreter (NULL if none). */
name|BgError
modifier|*
name|lastBgPtr
decl_stmt|;
comment|/* Last in list of all background errors 				 * waiting to be processed for this 				 * interpreter (NULL if none). */
block|}
name|ErrAssocData
typedef|;
end_typedef

begin_comment
comment|/*  * For each exit handler created with a call to Tcl_CreateExitHandler  * there is a structure of the following type:  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ExitHandler
block|{
name|Tcl_ExitProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to call when process exits. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* One word of information to pass to proc. */
name|struct
name|ExitHandler
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next in list of all exit handlers for 				 * this application, or NULL for end of list. */
block|}
name|ExitHandler
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|ExitHandler
modifier|*
name|firstExitPtr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First in list of all exit handlers for 				 * application. */
end_comment

begin_comment
comment|/*  * Structures of the following type are used during the execution  * of Tcl_WaitForFile, to keep track of the file and timeout.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|FileWait
block|{
name|Tcl_File
name|file
decl_stmt|;
comment|/* File to wait on. */
name|int
name|mask
decl_stmt|;
comment|/* Conditions to wait for (TCL_READABLE, 				 * etc.) */
name|int
name|timeout
decl_stmt|;
comment|/* Original "timeout" argument to 				 * Tcl_WaitForFile. */
name|Tcl_Time
name|abortTime
decl_stmt|;
comment|/* Time at which to abort the wait. */
name|int
name|present
decl_stmt|;
comment|/* Conditions present on the file during 				 * the last time through the event loop. */
name|int
name|done
decl_stmt|;
comment|/* Non-zero means we're done:  either one of 				 * the desired conditions is present or the 				 * timeout period has elapsed. */
block|}
name|FileWait
typedef|;
end_typedef

begin_comment
comment|/*  * The following variable is a "secret" indication to Tcl_Exit that  * it should dump out the state of memory before exiting.  If the  * value is non-NULL, it gives the name of the file in which to  * dump memory usage information.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|tclMemDumpFileName
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Prototypes for procedures referenced only in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|AfterCleanupProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|AfterProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|BgErrorDeleteProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|FileHandlerCheckProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|FileHandlerEventProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Event
operator|*
name|evPtr
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|FileHandlerExitProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|FileHandlerSetupProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|FreeAfterPtr
name|_ANSI_ARGS_
argument_list|(
operator|(
name|AfterInfo
operator|*
name|afterPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|AfterInfo
modifier|*
name|GetAfterEvent
name|_ANSI_ARGS_
argument_list|(
operator|(
name|AfterAssocData
operator|*
name|assocPtr
operator|,
name|char
operator|*
name|string
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|HandleBgErrors
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|TimerHandlerCheckProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TimerHandlerEventProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Event
operator|*
name|evPtr
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|TimerHandlerExitProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|TimerHandlerSetupProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|VwaitVarProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|name1
operator|,
name|char
operator|*
name|name2
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * Tcl_CreateFileHandler --  *  *	Arrange for a given procedure to be invoked whenever  *	a given file becomes readable or writable.  *  * Results:  *	None.  *  * Side effects:  *	From now on, whenever the I/O channel given by file becomes  *	ready in the way indicated by mask, proc will be invoked.  *	See the manual entry for details on the calling sequence  *	to proc.  If file is already registered then the old mask  *	and proc and clientData values will be replaced with  *	new ones.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_CreateFileHandler
parameter_list|(
name|file
parameter_list|,
name|mask
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_File
name|file
decl_stmt|;
comment|/* Handle of stream to watch. */
name|int
name|mask
decl_stmt|;
comment|/* OR'ed combination of TCL_READABLE, 				 * TCL_WRITABLE, and TCL_EXCEPTION: 				 * indicates conditions under which 				 * proc should be called. */
name|Tcl_FileProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to call for each 				 * selected event. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary data to pass to proc. */
block|{
specifier|register
name|FileHandler
modifier|*
name|filePtr
decl_stmt|;
if|if
condition|(
operator|!
name|fileEventSourceCreated
condition|)
block|{
name|fileEventSourceCreated
operator|=
literal|1
expr_stmt|;
name|Tcl_CreateEventSource
argument_list|(
name|FileHandlerSetupProc
argument_list|,
name|FileHandlerCheckProc
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateExitHandler
argument_list|(
name|FileHandlerExitProc
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/*      * Make sure the file isn't already registered.  Create a      * new record in the normal case where there's no existing      * record.      */
for|for
control|(
name|filePtr
operator|=
name|firstFileHandlerPtr
init|;
name|filePtr
operator|!=
name|NULL
condition|;
name|filePtr
operator|=
name|filePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|filePtr
operator|->
name|file
operator|==
name|file
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|filePtr
operator|==
name|NULL
condition|)
block|{
name|filePtr
operator|=
operator|(
name|FileHandler
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FileHandler
argument_list|)
argument_list|)
expr_stmt|;
name|filePtr
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|filePtr
operator|->
name|nextPtr
operator|=
name|firstFileHandlerPtr
expr_stmt|;
name|firstFileHandlerPtr
operator|=
name|filePtr
expr_stmt|;
block|}
comment|/*      * The remainder of the initialization below is done regardless      * of whether or not this is a new record or a modification of      * an old one.      */
name|filePtr
operator|->
name|mask
operator|=
name|mask
expr_stmt|;
name|filePtr
operator|->
name|readyMask
operator|=
literal|0
expr_stmt|;
name|filePtr
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|filePtr
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * Tcl_DeleteFileHandler --  *  *	Cancel a previously-arranged callback arrangement for  *	a file.  *  * Results:  *	None.  *  * Side effects:  *	If a callback was previously registered on file, remove it.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DeleteFileHandler
parameter_list|(
name|file
parameter_list|)
name|Tcl_File
name|file
decl_stmt|;
comment|/* Stream id for which to remove 				 * callback procedure. */
block|{
name|FileHandler
modifier|*
name|filePtr
decl_stmt|,
modifier|*
name|prevPtr
decl_stmt|;
comment|/*      * Find the entry for the given file (and return if there      * isn't one).      */
for|for
control|(
name|prevPtr
operator|=
name|NULL
operator|,
name|filePtr
operator|=
name|firstFileHandlerPtr
init|;
condition|;
name|prevPtr
operator|=
name|filePtr
operator|,
name|filePtr
operator|=
name|filePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|filePtr
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|filePtr
operator|->
name|file
operator|==
name|file
condition|)
block|{
break|break;
block|}
block|}
comment|/*      * Clean up information in the callback record.      */
if|if
condition|(
name|prevPtr
operator|==
name|NULL
condition|)
block|{
name|firstFileHandlerPtr
operator|=
name|filePtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
name|prevPtr
operator|->
name|nextPtr
operator|=
name|filePtr
operator|->
name|nextPtr
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|filePtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FileHandlerExitProc --  *  *	Cleanup procedure to delete the file event source during exit  *	cleanup.  *  * Results:  *	None.  *  * Side effects:  *	Destroys the file event source.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|FileHandlerExitProc
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
block|{
name|Tcl_DeleteEventSource
argument_list|(
name|FileHandlerSetupProc
argument_list|,
name|FileHandlerCheckProc
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FileHandlerSetupProc --  *  *	This procedure is part of the "event source" for file handlers.  *	It is invoked by Tcl_DoOneEvent before it calls select (or  *	whatever it uses to wait).  *  * Results:  *	None.  *  * Side effects:  *	Tells the notifier which files should be waited for.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|FileHandlerSetupProc
parameter_list|(
name|clientData
parameter_list|,
name|flags
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|int
name|flags
decl_stmt|;
comment|/* Flags passed to Tk_DoOneEvent: 					 * if it doesn't include 					 * TCL_FILE_EVENTS then we do 					 * nothing. */
block|{
name|FileHandler
modifier|*
name|filePtr
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TCL_FILE_EVENTS
operator|)
condition|)
block|{
return|return;
block|}
for|for
control|(
name|filePtr
operator|=
name|firstFileHandlerPtr
init|;
name|filePtr
operator|!=
name|NULL
condition|;
name|filePtr
operator|=
name|filePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|filePtr
operator|->
name|mask
operator|!=
literal|0
condition|)
block|{
name|Tcl_WatchFile
argument_list|(
name|filePtr
operator|->
name|file
argument_list|,
name|filePtr
operator|->
name|mask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FileHandlerCheckProc --  *  *	This procedure is the second part of the "event source" for  *	file handlers.  It is invoked by Tcl_DoOneEvent after it calls  *	select (or whatever it uses to wait for events).  *  * Results:  *	None.  *  * Side effects:  *	Makes entries on the Tcl event queue for each file that is  *	now ready.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|FileHandlerCheckProc
parameter_list|(
name|clientData
parameter_list|,
name|flags
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|int
name|flags
decl_stmt|;
comment|/* Flags passed to Tk_DoOneEvent: 					 * if it doesn't include  					 * TCL_FILE_EVENTS then we do 					 * nothing. */
block|{
name|FileHandler
modifier|*
name|filePtr
decl_stmt|;
name|FileHandlerEvent
modifier|*
name|fileEvPtr
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TCL_FILE_EVENTS
operator|)
condition|)
block|{
return|return;
block|}
for|for
control|(
name|filePtr
operator|=
name|firstFileHandlerPtr
init|;
name|filePtr
operator|!=
name|NULL
condition|;
name|filePtr
operator|=
name|filePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|filePtr
operator|->
name|mask
operator|!=
literal|0
condition|)
block|{
name|filePtr
operator|->
name|readyMask
operator|=
name|Tcl_FileReady
argument_list|(
name|filePtr
operator|->
name|file
argument_list|,
name|filePtr
operator|->
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|filePtr
operator|->
name|readyMask
operator|!=
literal|0
condition|)
block|{
name|fileEvPtr
operator|=
operator|(
name|FileHandlerEvent
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FileHandlerEvent
argument_list|)
argument_list|)
expr_stmt|;
name|fileEvPtr
operator|->
name|header
operator|.
name|proc
operator|=
name|FileHandlerEventProc
expr_stmt|;
name|fileEvPtr
operator|->
name|file
operator|=
name|filePtr
operator|->
name|file
expr_stmt|;
name|Tcl_QueueEvent
argument_list|(
operator|(
name|Tcl_Event
operator|*
operator|)
name|fileEvPtr
argument_list|,
name|TCL_QUEUE_TAIL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FileHandlerEventProc --  *  *	This procedure is called by Tcl_DoOneEvent when a file event  *	reaches the front of the event queue.  This procedure is responsible  *	for actually handling the event by invoking the callback for the  *	file handler.  *  * Results:  *	Returns 1 if the event was handled, meaning it should be removed  *	from the queue.  Returns 0 if the event was not handled, meaning  *	it should stay on the queue.  The only time the event isn't  *	handled is if the TCL_FILE_EVENTS flag bit isn't set.  *  * Side effects:  *	Whatever the file handler's callback procedure does  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|FileHandlerEventProc
parameter_list|(
name|evPtr
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Event
modifier|*
name|evPtr
decl_stmt|;
comment|/* Event to service. */
name|int
name|flags
decl_stmt|;
comment|/* Flags that indicate what events to 				 * handle, such as TCL_FILE_EVENTS. */
block|{
name|FileHandler
modifier|*
name|filePtr
decl_stmt|;
name|FileHandlerEvent
modifier|*
name|fileEvPtr
init|=
operator|(
name|FileHandlerEvent
operator|*
operator|)
name|evPtr
decl_stmt|;
name|int
name|mask
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TCL_FILE_EVENTS
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/*      * Search through the file handlers to find the one whose handle matches      * the event.  We do this rather than keeping a pointer to the file      * handler directly in the event, so that the handler can be deleted      * while the event is queued without leaving a dangling pointer.      */
for|for
control|(
name|filePtr
operator|=
name|firstFileHandlerPtr
init|;
name|filePtr
operator|!=
name|NULL
condition|;
name|filePtr
operator|=
name|filePtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|filePtr
operator|->
name|file
operator|!=
name|fileEvPtr
operator|->
name|file
condition|)
block|{
continue|continue;
block|}
comment|/* 	 * The code is tricky for two reasons: 	 * 1. The file handler's desired events could have changed 	 *    since the time when the event was queued, so AND the 	 *    ready mask with the desired mask. 	 * 2. The file could have been closed and re-opened since 	 *    the time when the event was queued.  This is why the 	 *    ready mask is stored in the file handler rather than 	 *    the queued event:  it will be zeroed when a new 	 *    file handler is created for the newly opened file. 	 */
name|mask
operator|=
name|filePtr
operator|->
name|readyMask
operator|&
name|filePtr
operator|->
name|mask
expr_stmt|;
name|filePtr
operator|->
name|readyMask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|filePtr
operator|->
name|proc
call|)
argument_list|(
name|filePtr
operator|->
name|clientData
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * Tcl_CreateTimerHandler --  *  *	Arrange for a given procedure to be invoked at a particular  *	time in the future.  *  * Results:  *	The return value is a token for the timer event, which  *	may be used to delete the event before it fires.  *  * Side effects:  *	When milliseconds have elapsed, proc will be invoked  *	exactly once.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_TimerToken
name|Tcl_CreateTimerHandler
parameter_list|(
name|milliseconds
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|int
name|milliseconds
decl_stmt|;
comment|/* How many milliseconds to wait 				 * before invoking proc. */
name|Tcl_TimerProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to invoke. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary data to pass to proc. */
block|{
specifier|register
name|TimerHandler
modifier|*
name|timerHandlerPtr
decl_stmt|,
modifier|*
name|tPtr2
decl_stmt|,
modifier|*
name|prevPtr
decl_stmt|;
specifier|static
name|int
name|id
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|timerEventSourceCreated
condition|)
block|{
name|timerEventSourceCreated
operator|=
literal|1
expr_stmt|;
name|Tcl_CreateEventSource
argument_list|(
name|TimerHandlerSetupProc
argument_list|,
name|TimerHandlerCheckProc
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateExitHandler
argument_list|(
name|TimerHandlerExitProc
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|timerHandlerPtr
operator|=
operator|(
name|TimerHandler
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TimerHandler
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Compute when the event should fire.      */
name|TclGetTime
argument_list|(
operator|&
name|timerHandlerPtr
operator|->
name|time
argument_list|)
expr_stmt|;
name|timerHandlerPtr
operator|->
name|time
operator|.
name|sec
operator|+=
name|milliseconds
operator|/
literal|1000
expr_stmt|;
name|timerHandlerPtr
operator|->
name|time
operator|.
name|usec
operator|+=
operator|(
name|milliseconds
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
if|if
condition|(
name|timerHandlerPtr
operator|->
name|time
operator|.
name|usec
operator|>=
literal|1000000
condition|)
block|{
name|timerHandlerPtr
operator|->
name|time
operator|.
name|usec
operator|-=
literal|1000000
expr_stmt|;
name|timerHandlerPtr
operator|->
name|time
operator|.
name|sec
operator|+=
literal|1
expr_stmt|;
block|}
comment|/*      * Fill in other fields for the event.      */
name|timerHandlerPtr
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|timerHandlerPtr
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
name|id
operator|++
expr_stmt|;
name|timerHandlerPtr
operator|->
name|token
operator|=
operator|(
name|Tcl_TimerToken
operator|)
name|id
expr_stmt|;
comment|/*      * Add the event to the queue in the correct position      * (ordered by event firing time).      */
for|for
control|(
name|tPtr2
operator|=
name|firstTimerHandlerPtr
operator|,
name|prevPtr
operator|=
name|NULL
init|;
name|tPtr2
operator|!=
name|NULL
condition|;
name|prevPtr
operator|=
name|tPtr2
operator|,
name|tPtr2
operator|=
name|tPtr2
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
operator|(
name|tPtr2
operator|->
name|time
operator|.
name|sec
operator|>
name|timerHandlerPtr
operator|->
name|time
operator|.
name|sec
operator|)
operator|||
operator|(
operator|(
name|tPtr2
operator|->
name|time
operator|.
name|sec
operator|==
name|timerHandlerPtr
operator|->
name|time
operator|.
name|sec
operator|)
operator|&&
operator|(
name|tPtr2
operator|->
name|time
operator|.
name|usec
operator|>
name|timerHandlerPtr
operator|->
name|time
operator|.
name|usec
operator|)
operator|)
condition|)
block|{
break|break;
block|}
block|}
name|timerHandlerPtr
operator|->
name|nextPtr
operator|=
name|tPtr2
expr_stmt|;
if|if
condition|(
name|prevPtr
operator|==
name|NULL
condition|)
block|{
name|firstTimerHandlerPtr
operator|=
name|timerHandlerPtr
expr_stmt|;
block|}
else|else
block|{
name|prevPtr
operator|->
name|nextPtr
operator|=
name|timerHandlerPtr
expr_stmt|;
block|}
return|return
name|timerHandlerPtr
operator|->
name|token
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * Tcl_DeleteTimerHandler --  *  *	Delete a previously-registered timer handler.  *  * Results:  *	None.  *  * Side effects:  *	Destroy the timer callback identified by TimerToken,  *	so that its associated procedure will not be called.  *	If the callback has already fired, or if the given  *	token doesn't exist, then nothing happens.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DeleteTimerHandler
parameter_list|(
name|token
parameter_list|)
name|Tcl_TimerToken
name|token
decl_stmt|;
comment|/* Result previously returned by 				 * Tcl_DeleteTimerHandler. */
block|{
specifier|register
name|TimerHandler
modifier|*
name|timerHandlerPtr
decl_stmt|,
modifier|*
name|prevPtr
decl_stmt|;
for|for
control|(
name|timerHandlerPtr
operator|=
name|firstTimerHandlerPtr
operator|,
name|prevPtr
operator|=
name|NULL
init|;
name|timerHandlerPtr
operator|!=
name|NULL
condition|;
name|prevPtr
operator|=
name|timerHandlerPtr
operator|,
name|timerHandlerPtr
operator|=
name|timerHandlerPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|timerHandlerPtr
operator|->
name|token
operator|!=
name|token
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|prevPtr
operator|==
name|NULL
condition|)
block|{
name|firstTimerHandlerPtr
operator|=
name|timerHandlerPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
name|prevPtr
operator|->
name|nextPtr
operator|=
name|timerHandlerPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|timerHandlerPtr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * Tcl_CreateModalTimeout --  *  *	Arrange for a given procedure to be invoked at a particular  *	time in the future, independently of all other timer events.  *  * Results:  *	None.  *  * Side effects:  *	When milliseconds have elapsed, proc will be invoked  *	exactly once.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_CreateModalTimeout
parameter_list|(
name|milliseconds
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|int
name|milliseconds
decl_stmt|;
comment|/* How many milliseconds to wait 				 * before invoking proc. */
name|Tcl_TimerProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to invoke. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary data to pass to proc. */
block|{
name|TimerHandler
modifier|*
name|timerHandlerPtr
decl_stmt|;
if|if
condition|(
operator|!
name|timerEventSourceCreated
condition|)
block|{
name|timerEventSourceCreated
operator|=
literal|1
expr_stmt|;
name|Tcl_CreateEventSource
argument_list|(
name|TimerHandlerSetupProc
argument_list|,
name|TimerHandlerCheckProc
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_CreateExitHandler
argument_list|(
name|TimerHandlerExitProc
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|timerHandlerPtr
operator|=
operator|(
name|TimerHandler
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TimerHandler
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Compute when the timeout should fire and fill in the other fields      * of the handler.      */
name|TclGetTime
argument_list|(
operator|&
name|timerHandlerPtr
operator|->
name|time
argument_list|)
expr_stmt|;
name|timerHandlerPtr
operator|->
name|time
operator|.
name|sec
operator|+=
name|milliseconds
operator|/
literal|1000
expr_stmt|;
name|timerHandlerPtr
operator|->
name|time
operator|.
name|usec
operator|+=
operator|(
name|milliseconds
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
if|if
condition|(
name|timerHandlerPtr
operator|->
name|time
operator|.
name|usec
operator|>=
literal|1000000
condition|)
block|{
name|timerHandlerPtr
operator|->
name|time
operator|.
name|usec
operator|-=
literal|1000000
expr_stmt|;
name|timerHandlerPtr
operator|->
name|time
operator|.
name|sec
operator|+=
literal|1
expr_stmt|;
block|}
name|timerHandlerPtr
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|timerHandlerPtr
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
comment|/*      * Push the handler on the top of the modal stack.      */
name|timerHandlerPtr
operator|->
name|nextPtr
operator|=
name|firstModalHandlerPtr
expr_stmt|;
name|firstModalHandlerPtr
operator|=
name|timerHandlerPtr
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * Tcl_DeleteModalTimeout --  *  *	Remove the topmost modal timer handler from the stack of  *	modal  handlers.  *  * Results:  *	None.  *  * Side effects:  *	Destroys the topmost modal timeout handler, which must  *	match proc and clientData.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DeleteModalTimeout
parameter_list|(
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_TimerProc
modifier|*
name|proc
decl_stmt|;
comment|/* Callback procedure for the timeout. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary data to pass to proc. */
block|{
name|TimerHandler
modifier|*
name|timerHandlerPtr
decl_stmt|;
name|timerHandlerPtr
operator|=
name|firstModalHandlerPtr
expr_stmt|;
name|firstModalHandlerPtr
operator|=
name|timerHandlerPtr
operator|->
name|nextPtr
expr_stmt|;
if|if
condition|(
operator|(
name|timerHandlerPtr
operator|->
name|proc
operator|!=
name|proc
operator|)
operator|||
operator|(
name|timerHandlerPtr
operator|->
name|clientData
operator|!=
name|clientData
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_DeleteModalTimeout found timeout stack corrupted"
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|timerHandlerPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TimerHandlerSetupProc --  *  *	This procedure is part of the "event source" for timers.  *	It is invoked by Tcl_DoOneEvent before it calls select (or  *	whatever it uses to wait).  *  * Results:  *	None.  *  * Side effects:  *	Tells the notifier how long to sleep if it decides to block.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|TimerHandlerSetupProc
parameter_list|(
name|clientData
parameter_list|,
name|flags
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|int
name|flags
decl_stmt|;
comment|/* Flags passed to Tk_DoOneEvent: 					 * if it doesn't include 					 * TCL_TIMER_EVENTS then we only 					 * consider modal timers. */
block|{
name|TimerHandler
modifier|*
name|timerHandlerPtr
decl_stmt|,
modifier|*
name|tPtr2
decl_stmt|;
name|Tcl_Time
name|blockTime
decl_stmt|;
comment|/*      * Find the timer handler (regular or modal) that fires first.      */
name|timerHandlerPtr
operator|=
name|firstTimerHandlerPtr
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TCL_TIMER_EVENTS
operator|)
condition|)
block|{
name|timerHandlerPtr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|timerHandlerPtr
operator|!=
name|NULL
condition|)
block|{
name|tPtr2
operator|=
name|firstModalHandlerPtr
expr_stmt|;
if|if
condition|(
name|tPtr2
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|timerHandlerPtr
operator|->
name|time
operator|.
name|sec
operator|>
name|tPtr2
operator|->
name|time
operator|.
name|sec
operator|)
operator|||
operator|(
operator|(
name|timerHandlerPtr
operator|->
name|time
operator|.
name|sec
operator|==
name|tPtr2
operator|->
name|time
operator|.
name|sec
operator|)
operator|&&
operator|(
name|timerHandlerPtr
operator|->
name|time
operator|.
name|usec
operator|>
name|tPtr2
operator|->
name|time
operator|.
name|usec
operator|)
operator|)
condition|)
block|{
name|timerHandlerPtr
operator|=
name|tPtr2
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|timerHandlerPtr
operator|=
name|firstModalHandlerPtr
expr_stmt|;
block|}
if|if
condition|(
name|timerHandlerPtr
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|TclGetTime
argument_list|(
operator|&
name|blockTime
argument_list|)
expr_stmt|;
name|blockTime
operator|.
name|sec
operator|=
name|timerHandlerPtr
operator|->
name|time
operator|.
name|sec
operator|-
name|blockTime
operator|.
name|sec
expr_stmt|;
name|blockTime
operator|.
name|usec
operator|=
name|timerHandlerPtr
operator|->
name|time
operator|.
name|usec
operator|-
name|blockTime
operator|.
name|usec
expr_stmt|;
if|if
condition|(
name|blockTime
operator|.
name|usec
operator|<
literal|0
condition|)
block|{
name|blockTime
operator|.
name|sec
operator|-=
literal|1
expr_stmt|;
name|blockTime
operator|.
name|usec
operator|+=
literal|1000000
expr_stmt|;
block|}
if|if
condition|(
name|blockTime
operator|.
name|sec
operator|<
literal|0
condition|)
block|{
name|blockTime
operator|.
name|sec
operator|=
literal|0
expr_stmt|;
name|blockTime
operator|.
name|usec
operator|=
literal|0
expr_stmt|;
block|}
name|Tcl_SetMaxBlockTime
argument_list|(
operator|&
name|blockTime
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TimerHandlerCheckProc --  *  *	This procedure is the second part of the "event source" for  *	file handlers.  It is invoked by Tcl_DoOneEvent after it calls  *	select (or whatever it uses to wait for events).  *  * Results:  *	None.  *  * Side effects:  *	Makes entries on the Tcl event queue for each file that is  *	now ready.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|TimerHandlerCheckProc
parameter_list|(
name|clientData
parameter_list|,
name|flags
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|int
name|flags
decl_stmt|;
comment|/* Flags passed to Tk_DoOneEvent: 					 * if it doesn't include  					 * TCL_TIMER_EVENTS then we only 					 * consider modal timeouts. */
block|{
name|TimerHandler
modifier|*
name|timerHandlerPtr
decl_stmt|;
name|TimerEvent
modifier|*
name|timerEvPtr
decl_stmt|;
name|int
name|triggered
decl_stmt|,
name|gotTime
decl_stmt|;
name|Tcl_Time
name|curTime
decl_stmt|;
name|triggered
operator|=
literal|0
expr_stmt|;
name|gotTime
operator|=
literal|0
expr_stmt|;
name|timerHandlerPtr
operator|=
name|firstTimerHandlerPtr
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|TCL_TIMER_EVENTS
operator|)
operator|&&
operator|(
name|timerHandlerPtr
operator|!=
name|NULL
operator|)
condition|)
block|{
name|TclGetTime
argument_list|(
operator|&
name|curTime
argument_list|)
expr_stmt|;
name|gotTime
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|timerHandlerPtr
operator|->
name|time
operator|.
name|sec
operator|<
name|curTime
operator|.
name|sec
operator|)
operator|||
operator|(
operator|(
name|timerHandlerPtr
operator|->
name|time
operator|.
name|sec
operator|==
name|curTime
operator|.
name|sec
operator|)
operator|&&
operator|(
name|timerHandlerPtr
operator|->
name|time
operator|.
name|usec
operator|<=
name|curTime
operator|.
name|usec
operator|)
operator|)
condition|)
block|{
name|triggered
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|timerHandlerPtr
operator|=
name|firstModalHandlerPtr
expr_stmt|;
if|if
condition|(
name|timerHandlerPtr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|gotTime
condition|)
block|{
name|TclGetTime
argument_list|(
operator|&
name|curTime
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|timerHandlerPtr
operator|->
name|time
operator|.
name|sec
operator|<
name|curTime
operator|.
name|sec
operator|)
operator|||
operator|(
operator|(
name|timerHandlerPtr
operator|->
name|time
operator|.
name|sec
operator|==
name|curTime
operator|.
name|sec
operator|)
operator|&&
operator|(
name|timerHandlerPtr
operator|->
name|time
operator|.
name|usec
operator|<=
name|curTime
operator|.
name|usec
operator|)
operator|)
condition|)
block|{
name|triggered
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|triggered
condition|)
block|{
name|timerEvPtr
operator|=
operator|(
name|TimerEvent
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TimerEvent
argument_list|)
argument_list|)
expr_stmt|;
name|timerEvPtr
operator|->
name|header
operator|.
name|proc
operator|=
name|TimerHandlerEventProc
expr_stmt|;
name|timerEvPtr
operator|->
name|time
operator|.
name|sec
operator|=
name|curTime
operator|.
name|sec
expr_stmt|;
name|timerEvPtr
operator|->
name|time
operator|.
name|usec
operator|=
name|curTime
operator|.
name|usec
expr_stmt|;
name|Tcl_QueueEvent
argument_list|(
operator|(
name|Tcl_Event
operator|*
operator|)
name|timerEvPtr
argument_list|,
name|TCL_QUEUE_TAIL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TimerHandlerExitProc --  *  *	Callback invoked during exit cleanup to destroy the timer event  *	source.  *  * Results:  *	None.  *  * Side effects:  *	Destroys the timer event source.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|TimerHandlerExitProc
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
block|{
name|Tcl_DeleteEventSource
argument_list|(
name|TimerHandlerSetupProc
argument_list|,
name|TimerHandlerCheckProc
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TimerHandlerEventProc --  *  *	This procedure is called by Tcl_DoOneEvent when a timer event  *	reaches the front of the event queue.  This procedure handles  *	the event by invoking the callbacks for all timers that are  *	ready.  *  * Results:  *	Returns 1 if the event was handled, meaning it should be removed  *	from the queue.  Returns 0 if the event was not handled, meaning  *	it should stay on the queue.  The only time the event isn't  *	handled is if the TCL_TIMER_EVENTS flag bit isn't set.  *  * Side effects:  *	Whatever the timer handler callback procedures do.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|TimerHandlerEventProc
parameter_list|(
name|evPtr
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Event
modifier|*
name|evPtr
decl_stmt|;
comment|/* Event to service. */
name|int
name|flags
decl_stmt|;
comment|/* Flags that indicate what events to 				 * handle, such as TCL_FILE_EVENTS. */
block|{
name|TimerHandler
modifier|*
name|timerHandlerPtr
decl_stmt|;
name|TimerEvent
modifier|*
name|timerEvPtr
init|=
operator|(
name|TimerEvent
operator|*
operator|)
name|evPtr
decl_stmt|;
comment|/*      * Invoke the current modal timeout first, if there is one and      * it has triggered.      */
name|timerHandlerPtr
operator|=
name|firstModalHandlerPtr
expr_stmt|;
if|if
condition|(
name|firstModalHandlerPtr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|timerHandlerPtr
operator|->
name|time
operator|.
name|sec
operator|<
name|timerEvPtr
operator|->
name|time
operator|.
name|sec
operator|)
operator|||
operator|(
operator|(
name|timerHandlerPtr
operator|->
name|time
operator|.
name|sec
operator|==
name|timerEvPtr
operator|->
name|time
operator|.
name|sec
operator|)
operator|&&
operator|(
name|timerHandlerPtr
operator|->
name|time
operator|.
name|usec
operator|<=
name|timerEvPtr
operator|->
name|time
operator|.
name|usec
operator|)
operator|)
condition|)
block|{
call|(
modifier|*
name|timerHandlerPtr
operator|->
name|proc
call|)
argument_list|(
name|timerHandlerPtr
operator|->
name|clientData
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Invoke any normal timers that have fired.      */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TCL_TIMER_EVENTS
operator|)
condition|)
block|{
return|return
literal|1
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|timerHandlerPtr
operator|=
name|firstTimerHandlerPtr
expr_stmt|;
if|if
condition|(
name|timerHandlerPtr
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|(
name|timerHandlerPtr
operator|->
name|time
operator|.
name|sec
operator|>
name|timerEvPtr
operator|->
name|time
operator|.
name|sec
operator|)
operator|||
operator|(
operator|(
name|timerHandlerPtr
operator|->
name|time
operator|.
name|sec
operator|==
name|timerEvPtr
operator|->
name|time
operator|.
name|sec
operator|)
operator|&&
operator|(
name|timerHandlerPtr
operator|->
name|time
operator|.
name|usec
operator|>=
name|timerEvPtr
operator|->
name|time
operator|.
name|usec
operator|)
operator|)
condition|)
block|{
break|break;
block|}
comment|/* 	 * Remove the handler from the queue before invoking it, 	 * to avoid potential reentrancy problems. 	 */
name|firstTimerHandlerPtr
operator|=
name|timerHandlerPtr
operator|->
name|nextPtr
expr_stmt|;
call|(
modifier|*
name|timerHandlerPtr
operator|->
name|proc
call|)
argument_list|(
name|timerHandlerPtr
operator|->
name|clientData
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|timerHandlerPtr
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * Tcl_DoWhenIdle --  *  *	Arrange for proc to be invoked the next time the system is  *	idle (i.e., just before the next time that Tcl_DoOneEvent  *	would have to wait for something to happen).  *  * Results:  *	None.  *  * Side effects:  *	Proc will eventually be called, with clientData as argument.  *	See the manual entry for details.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DoWhenIdle
parameter_list|(
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_IdleProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to invoke. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary value to pass to proc. */
block|{
specifier|register
name|IdleHandler
modifier|*
name|idlePtr
decl_stmt|;
name|idlePtr
operator|=
operator|(
name|IdleHandler
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|IdleHandler
argument_list|)
argument_list|)
expr_stmt|;
name|idlePtr
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|idlePtr
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
name|idlePtr
operator|->
name|generation
operator|=
name|idleGeneration
expr_stmt|;
name|idlePtr
operator|->
name|nextPtr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|lastIdlePtr
operator|==
name|NULL
condition|)
block|{
name|idleList
operator|=
name|idlePtr
expr_stmt|;
block|}
else|else
block|{
name|lastIdlePtr
operator|->
name|nextPtr
operator|=
name|idlePtr
expr_stmt|;
block|}
name|lastIdlePtr
operator|=
name|idlePtr
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CancelIdleCall --  *  *	If there are any when-idle calls requested to a given procedure  *	with given clientData, cancel all of them.  *  * Results:  *	None.  *  * Side effects:  *	If the proc/clientData combination were on the when-idle list,  *	they are removed so that they will never be called.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_CancelIdleCall
parameter_list|(
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_IdleProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure that was previously registered. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary value to pass to proc. */
block|{
specifier|register
name|IdleHandler
modifier|*
name|idlePtr
decl_stmt|,
modifier|*
name|prevPtr
decl_stmt|;
name|IdleHandler
modifier|*
name|nextPtr
decl_stmt|;
for|for
control|(
name|prevPtr
operator|=
name|NULL
operator|,
name|idlePtr
operator|=
name|idleList
init|;
name|idlePtr
operator|!=
name|NULL
condition|;
name|prevPtr
operator|=
name|idlePtr
operator|,
name|idlePtr
operator|=
name|idlePtr
operator|->
name|nextPtr
control|)
block|{
while|while
condition|(
operator|(
name|idlePtr
operator|->
name|proc
operator|==
name|proc
operator|)
operator|&&
operator|(
name|idlePtr
operator|->
name|clientData
operator|==
name|clientData
operator|)
condition|)
block|{
name|nextPtr
operator|=
name|idlePtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|idlePtr
argument_list|)
expr_stmt|;
name|idlePtr
operator|=
name|nextPtr
expr_stmt|;
if|if
condition|(
name|prevPtr
operator|==
name|NULL
condition|)
block|{
name|idleList
operator|=
name|idlePtr
expr_stmt|;
block|}
else|else
block|{
name|prevPtr
operator|->
name|nextPtr
operator|=
name|idlePtr
expr_stmt|;
block|}
if|if
condition|(
name|idlePtr
operator|==
name|NULL
condition|)
block|{
name|lastIdlePtr
operator|=
name|prevPtr
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclIdlePending --  *  *	This function is called by the notifier subsystem to determine  *	whether there are any idle handlers currently scheduled.  *  * Results:  *	Returns 0 if the idle list is empty, otherwise it returns 1.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclIdlePending
parameter_list|()
block|{
return|return
operator|(
name|idleList
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclServiceIdle --  *  *	This procedure is invoked by the notifier when it becomes idle.  *  * Results:  *	The return value is 1 if the procedure actually found an idle  *	handler to invoke.  If no handler was found then 0 is returned.  *  * Side effects:  *	Invokes all pending idle handlers.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclServiceIdle
parameter_list|()
block|{
name|IdleHandler
modifier|*
name|idlePtr
decl_stmt|;
name|int
name|oldGeneration
decl_stmt|;
name|int
name|foundIdle
decl_stmt|;
if|if
condition|(
name|idleList
operator|==
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
name|foundIdle
operator|=
literal|0
expr_stmt|;
name|oldGeneration
operator|=
name|idleGeneration
expr_stmt|;
name|idleGeneration
operator|++
expr_stmt|;
comment|/*      * The code below is trickier than it may look, for the following      * reasons:      *      * 1. New handlers can get added to the list while the current      *    one is being processed.  If new ones get added, we don't      *    want to process them during this pass through the list (want      *    to check for other work to do first).  This is implemented      *    using the generation number in the handler:  new handlers      *    will have a different generation than any of the ones currently      *    on the list.      * 2. The handler can call Tcl_DoOneEvent, so we have to remove      *    the handler from the list before calling it. Otherwise an      *    infinite loop could result.      * 3. Tcl_CancelIdleCall can be called to remove an element from      *    the list while a handler is executing, so the list could      *    change structure during the call.      */
for|for
control|(
name|idlePtr
operator|=
name|idleList
init|;
operator|(
operator|(
name|idlePtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|oldGeneration
operator|-
name|idlePtr
operator|->
name|generation
operator|)
operator|>=
literal|0
operator|)
operator|)
condition|;
name|idlePtr
operator|=
name|idleList
control|)
block|{
name|idleList
operator|=
name|idlePtr
operator|->
name|nextPtr
expr_stmt|;
if|if
condition|(
name|idleList
operator|==
name|NULL
condition|)
block|{
name|lastIdlePtr
operator|=
name|NULL
expr_stmt|;
block|}
name|foundIdle
operator|=
literal|1
expr_stmt|;
call|(
modifier|*
name|idlePtr
operator|->
name|proc
call|)
argument_list|(
name|idlePtr
operator|->
name|clientData
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|idlePtr
argument_list|)
expr_stmt|;
block|}
return|return
name|foundIdle
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_BackgroundError --  *  *	This procedure is invoked to handle errors that occur in Tcl  *	commands that are invoked in "background" (e.g. from event or  *	timer bindings).  *  * Results:  *	None.  *  * Side effects:  *	The command "bgerror" is invoked later as an idle handler to  *	process the error, passing it the error message.  If that fails,  *	then an error message is output on stderr.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_BackgroundError
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which an error has 				 * occurred. */
block|{
name|BgError
modifier|*
name|errPtr
decl_stmt|;
name|char
modifier|*
name|varValue
decl_stmt|;
name|ErrAssocData
modifier|*
name|assocPtr
decl_stmt|;
comment|/*      * The Tcl_AddErrorInfo call below (with an empty string) ensures that      * errorInfo gets properly set.  It's needed in cases where the error      * came from a utility procedure like Tcl_GetVar instead of Tcl_Eval;      * in these cases errorInfo still won't have been set when this      * procedure is called.      */
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|errPtr
operator|=
operator|(
name|BgError
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BgError
argument_list|)
argument_list|)
expr_stmt|;
name|errPtr
operator|->
name|interp
operator|=
name|interp
expr_stmt|;
name|errPtr
operator|->
name|errorMsg
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|interp
operator|->
name|result
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|errPtr
operator|->
name|errorMsg
argument_list|,
name|interp
operator|->
name|result
argument_list|)
expr_stmt|;
name|varValue
operator|=
name|Tcl_GetVar
argument_list|(
name|interp
argument_list|,
literal|"errorInfo"
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|varValue
operator|==
name|NULL
condition|)
block|{
name|varValue
operator|=
name|errPtr
operator|->
name|errorMsg
expr_stmt|;
block|}
name|errPtr
operator|->
name|errorInfo
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|varValue
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|errPtr
operator|->
name|errorInfo
argument_list|,
name|varValue
argument_list|)
expr_stmt|;
name|varValue
operator|=
name|Tcl_GetVar
argument_list|(
name|interp
argument_list|,
literal|"errorCode"
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|varValue
operator|==
name|NULL
condition|)
block|{
name|varValue
operator|=
literal|""
expr_stmt|;
block|}
name|errPtr
operator|->
name|errorCode
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|varValue
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|errPtr
operator|->
name|errorCode
argument_list|,
name|varValue
argument_list|)
expr_stmt|;
name|errPtr
operator|->
name|nextPtr
operator|=
name|NULL
expr_stmt|;
name|assocPtr
operator|=
operator|(
name|ErrAssocData
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclBgError"
argument_list|,
operator|(
name|Tcl_InterpDeleteProc
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|assocPtr
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * This is the first time a background error has occurred in 	 * this interpreter.  Create associated data to keep track of 	 * pending error reports. 	 */
name|assocPtr
operator|=
operator|(
name|ErrAssocData
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ErrAssocData
argument_list|)
argument_list|)
expr_stmt|;
name|assocPtr
operator|->
name|firstBgPtr
operator|=
name|NULL
expr_stmt|;
name|assocPtr
operator|->
name|lastBgPtr
operator|=
name|NULL
expr_stmt|;
name|Tcl_SetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclBgError"
argument_list|,
name|BgErrorDeleteProc
argument_list|,
operator|(
name|ClientData
operator|)
name|assocPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|assocPtr
operator|->
name|firstBgPtr
operator|==
name|NULL
condition|)
block|{
name|assocPtr
operator|->
name|firstBgPtr
operator|=
name|errPtr
expr_stmt|;
name|Tcl_DoWhenIdle
argument_list|(
name|HandleBgErrors
argument_list|,
operator|(
name|ClientData
operator|)
name|assocPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assocPtr
operator|->
name|lastBgPtr
operator|->
name|nextPtr
operator|=
name|errPtr
expr_stmt|;
block|}
name|assocPtr
operator|->
name|lastBgPtr
operator|=
name|errPtr
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * HandleBgErrors --  *  *	This procedure is invoked as an idle handler to process all of  *	the accumulated background errors.  *  * Results:  *	None.  *  * Side effects:  *	Depends on what actions "bgerror" takes for the errors.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|HandleBgErrors
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Pointer to ErrAssocData structure. */
block|{
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
name|char
modifier|*
name|command
decl_stmt|;
name|char
modifier|*
name|argv
index|[
literal|2
index|]
decl_stmt|;
name|int
name|code
decl_stmt|;
name|BgError
modifier|*
name|errPtr
decl_stmt|;
name|ErrAssocData
modifier|*
name|assocPtr
init|=
operator|(
name|ErrAssocData
operator|*
operator|)
name|clientData
decl_stmt|;
name|Tcl_Channel
name|errChannel
decl_stmt|;
while|while
condition|(
name|assocPtr
operator|->
name|firstBgPtr
operator|!=
name|NULL
condition|)
block|{
name|interp
operator|=
name|assocPtr
operator|->
name|firstBgPtr
operator|->
name|interp
expr_stmt|;
if|if
condition|(
name|interp
operator|==
name|NULL
condition|)
block|{
goto|goto
name|doneWithReport
goto|;
block|}
comment|/* 	 * Restore important state variables to what they were at 	 * the time the error occurred. 	 */
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
literal|"errorInfo"
argument_list|,
name|assocPtr
operator|->
name|firstBgPtr
operator|->
name|errorInfo
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
literal|"errorCode"
argument_list|,
name|assocPtr
operator|->
name|firstBgPtr
operator|->
name|errorCode
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
comment|/* 	 * Create and invoke the bgerror command. 	 */
name|argv
index|[
literal|0
index|]
operator|=
literal|"bgerror"
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
name|assocPtr
operator|->
name|firstBgPtr
operator|->
name|errorMsg
expr_stmt|;
name|command
operator|=
name|Tcl_Merge
argument_list|(
literal|2
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|Tcl_AllowExceptions
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_Preserve
argument_list|(
operator|(
name|ClientData
operator|)
name|interp
argument_list|)
expr_stmt|;
name|code
operator|=
name|Tcl_GlobalEval
argument_list|(
name|interp
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TCL_ERROR
condition|)
block|{
comment|/*              * We have to get the error output channel at the latest possible              * time, because the eval (above) might have changed the channel.              */
name|errChannel
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|errChannel
operator|!=
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"\"bgerror\" is an invalid command name or ambiguous abbreviation"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_Write
argument_list|(
name|errChannel
argument_list|,
name|assocPtr
operator|->
name|firstBgPtr
operator|->
name|errorInfo
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_Write
argument_list|(
name|errChannel
argument_list|,
literal|"\n"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_Write
argument_list|(
name|errChannel
argument_list|,
literal|"bgerror failed to handle background error.\n"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_Write
argument_list|(
name|errChannel
argument_list|,
literal|"    Original error: "
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_Write
argument_list|(
name|errChannel
argument_list|,
name|assocPtr
operator|->
name|firstBgPtr
operator|->
name|errorMsg
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_Write
argument_list|(
name|errChannel
argument_list|,
literal|"\n"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_Write
argument_list|(
name|errChannel
argument_list|,
literal|"    Error in bgerror: "
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_Write
argument_list|(
name|errChannel
argument_list|,
name|interp
operator|->
name|result
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_Write
argument_list|(
name|errChannel
argument_list|,
literal|"\n"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|Tcl_Flush
argument_list|(
name|errChannel
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|TCL_BREAK
condition|)
block|{
comment|/* 	     * Break means cancel any remaining error reports for this 	     * interpreter. 	     */
for|for
control|(
name|errPtr
operator|=
name|assocPtr
operator|->
name|firstBgPtr
init|;
name|errPtr
operator|!=
name|NULL
condition|;
name|errPtr
operator|=
name|errPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|errPtr
operator|->
name|interp
operator|==
name|interp
condition|)
block|{
name|errPtr
operator|->
name|interp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|Tcl_Release
argument_list|(
operator|(
name|ClientData
operator|)
name|interp
argument_list|)
expr_stmt|;
comment|/* 	 * Discard the command and the information about the error report. 	 */
name|doneWithReport
label|:
name|ckfree
argument_list|(
name|assocPtr
operator|->
name|firstBgPtr
operator|->
name|errorMsg
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|assocPtr
operator|->
name|firstBgPtr
operator|->
name|errorInfo
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|assocPtr
operator|->
name|firstBgPtr
operator|->
name|errorCode
argument_list|)
expr_stmt|;
name|errPtr
operator|=
name|assocPtr
operator|->
name|firstBgPtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|assocPtr
operator|->
name|firstBgPtr
argument_list|)
expr_stmt|;
name|assocPtr
operator|->
name|firstBgPtr
operator|=
name|errPtr
expr_stmt|;
block|}
name|assocPtr
operator|->
name|lastBgPtr
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * BgErrorDeleteProc --  *  *	This procedure is associated with the "tclBgError" assoc data  *	for an interpreter;  it is invoked when the interpreter is  *	deleted in order to free the information assoicated with any  *	pending error reports.  *  * Results:  *	None.  *  * Side effects:  *	Background error information is freed: if there were any  *	pending error reports, they are cancelled.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|BgErrorDeleteProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Pointer to ErrAssocData structure. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter being deleted. */
block|{
name|ErrAssocData
modifier|*
name|assocPtr
init|=
operator|(
name|ErrAssocData
operator|*
operator|)
name|clientData
decl_stmt|;
name|BgError
modifier|*
name|errPtr
decl_stmt|;
while|while
condition|(
name|assocPtr
operator|->
name|firstBgPtr
operator|!=
name|NULL
condition|)
block|{
name|errPtr
operator|=
name|assocPtr
operator|->
name|firstBgPtr
expr_stmt|;
name|assocPtr
operator|->
name|firstBgPtr
operator|=
name|errPtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
name|errPtr
operator|->
name|errorMsg
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|errPtr
operator|->
name|errorInfo
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|errPtr
operator|->
name|errorCode
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|errPtr
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|assocPtr
argument_list|)
expr_stmt|;
name|Tcl_CancelIdleCall
argument_list|(
name|HandleBgErrors
argument_list|,
operator|(
name|ClientData
operator|)
name|assocPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CreateExitHandler --  *  *	Arrange for a given procedure to be invoked just before the  *	application exits.  *  * Results:  *	None.  *  * Side effects:  *	Proc will be invoked with clientData as argument when the  *	application exits.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_CreateExitHandler
parameter_list|(
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_ExitProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to invoke. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary value to pass to proc. */
block|{
name|ExitHandler
modifier|*
name|exitPtr
decl_stmt|;
name|exitPtr
operator|=
operator|(
name|ExitHandler
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ExitHandler
argument_list|)
argument_list|)
expr_stmt|;
name|exitPtr
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|exitPtr
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
name|exitPtr
operator|->
name|nextPtr
operator|=
name|firstExitPtr
expr_stmt|;
name|firstExitPtr
operator|=
name|exitPtr
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DeleteExitHandler --  *  *	This procedure cancels an existing exit handler matching proc  *	and clientData, if such a handler exits.  *  * Results:  *	None.  *  * Side effects:  *	If there is an exit handler corresponding to proc and clientData  *	then it is cancelled;  if no such handler exists then nothing  *	happens.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DeleteExitHandler
parameter_list|(
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_ExitProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure that was previously registered. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary value to pass to proc. */
block|{
name|ExitHandler
modifier|*
name|exitPtr
decl_stmt|,
modifier|*
name|prevPtr
decl_stmt|;
for|for
control|(
name|prevPtr
operator|=
name|NULL
operator|,
name|exitPtr
operator|=
name|firstExitPtr
init|;
name|exitPtr
operator|!=
name|NULL
condition|;
name|prevPtr
operator|=
name|exitPtr
operator|,
name|exitPtr
operator|=
name|exitPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
operator|(
name|exitPtr
operator|->
name|proc
operator|==
name|proc
operator|)
operator|&&
operator|(
name|exitPtr
operator|->
name|clientData
operator|==
name|clientData
operator|)
condition|)
block|{
if|if
condition|(
name|prevPtr
operator|==
name|NULL
condition|)
block|{
name|firstExitPtr
operator|=
name|exitPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
name|prevPtr
operator|->
name|nextPtr
operator|=
name|exitPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|exitPtr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_Exit --  *  *	This procedure is called to terminate the application.  *  * Results:  *	None.  *  * Side effects:  *	All existing exit handlers are invoked, then the application  *	ends.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_Exit
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
comment|/* Exit status for application;  typically 				 * 0 for normal return, 1 for error return. */
block|{
name|ExitHandler
modifier|*
name|exitPtr
decl_stmt|;
for|for
control|(
name|exitPtr
operator|=
name|firstExitPtr
init|;
name|exitPtr
operator|!=
name|NULL
condition|;
name|exitPtr
operator|=
name|firstExitPtr
control|)
block|{
comment|/* 	 * Be careful to remove the handler from the list before invoking 	 * its callback.  This protects us against double-freeing if the 	 * callback should call Tcl_DeleteExitHandler on itself. 	 */
name|firstExitPtr
operator|=
name|exitPtr
operator|->
name|nextPtr
expr_stmt|;
call|(
modifier|*
name|exitPtr
operator|->
name|proc
call|)
argument_list|(
name|exitPtr
operator|->
name|clientData
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|exitPtr
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
if|if
condition|(
name|tclMemDumpFileName
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DumpActiveMemory
argument_list|(
name|tclMemDumpFileName
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|TclPlatformExit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_AfterCmd --  *  *	This procedure is invoked to process the "after" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_AfterCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Points to the "tclAfter" assocData for 				 * this interpreter, or NULL if the assocData 				 * hasn't been created yet.*/
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
comment|/*      * The variable below is used to generate unique identifiers for      * after commands.  This id can wrap around, which can potentially      * cause problems.  However, there are not likely to be problems      * in practice, because after commands can only be requested to      * about a month in the future, and wrap-around is unlikely to      * occur in less than about 1-10 years.  Thus it's unlikely that      * any old ids will still be around when wrap-around occurs.      */
specifier|static
name|int
name|nextId
init|=
literal|1
decl_stmt|;
name|int
name|ms
decl_stmt|;
name|AfterInfo
modifier|*
name|afterPtr
decl_stmt|;
name|AfterAssocData
modifier|*
name|assocPtr
init|=
operator|(
name|AfterAssocData
operator|*
operator|)
name|clientData
decl_stmt|;
name|Tcl_CmdInfo
name|cmdInfo
decl_stmt|;
name|size_t
name|length
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" option ?arg arg ...?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Create the "after" information associated for this interpreter,      * if it doesn't already exist.  Associate it with the command too,      * so that it will be passed in as the ClientData argument in the      * future.      */
if|if
condition|(
name|assocPtr
operator|==
name|NULL
condition|)
block|{
name|assocPtr
operator|=
operator|(
name|AfterAssocData
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|AfterAssocData
argument_list|)
argument_list|)
expr_stmt|;
name|assocPtr
operator|->
name|interp
operator|=
name|interp
expr_stmt|;
name|assocPtr
operator|->
name|firstAfterPtr
operator|=
name|NULL
expr_stmt|;
name|Tcl_SetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclAfter"
argument_list|,
name|AfterCleanupProc
argument_list|,
operator|(
name|ClientData
operator|)
name|assocPtr
argument_list|)
expr_stmt|;
name|cmdInfo
operator|.
name|proc
operator|=
name|Tcl_AfterCmd
expr_stmt|;
name|cmdInfo
operator|.
name|clientData
operator|=
operator|(
name|ClientData
operator|)
name|assocPtr
expr_stmt|;
name|cmdInfo
operator|.
name|deleteProc
operator|=
name|NULL
expr_stmt|;
name|cmdInfo
operator|.
name|deleteData
operator|=
operator|(
name|ClientData
operator|)
name|assocPtr
expr_stmt|;
name|Tcl_SetCommandInfo
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|cmdInfo
argument_list|)
expr_stmt|;
block|}
comment|/*      * Parse the command.      */
name|length
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|ms
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|ms
operator|<
literal|0
condition|)
block|{
name|ms
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
name|Tcl_Sleep
argument_list|(
name|ms
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
name|afterPtr
operator|=
operator|(
name|AfterInfo
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|AfterInfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|afterPtr
operator|->
name|assocPtr
operator|=
name|assocPtr
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
block|{
name|afterPtr
operator|->
name|command
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|afterPtr
operator|->
name|command
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|afterPtr
operator|->
name|command
operator|=
name|Tcl_Concat
argument_list|(
name|argc
operator|-
literal|2
argument_list|,
name|argv
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
name|afterPtr
operator|->
name|id
operator|=
name|nextId
expr_stmt|;
name|nextId
operator|+=
literal|1
expr_stmt|;
name|afterPtr
operator|->
name|token
operator|=
name|Tcl_CreateTimerHandler
argument_list|(
name|ms
argument_list|,
name|AfterProc
argument_list|,
operator|(
name|ClientData
operator|)
name|afterPtr
argument_list|)
expr_stmt|;
name|afterPtr
operator|->
name|nextPtr
operator|=
name|assocPtr
operator|->
name|firstAfterPtr
expr_stmt|;
name|assocPtr
operator|->
name|firstAfterPtr
operator|=
name|afterPtr
expr_stmt|;
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"after#%d"
argument_list|,
name|afterPtr
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"cancel"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|arg
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" cancel id|command\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
block|{
name|arg
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
name|arg
operator|=
name|Tcl_Concat
argument_list|(
name|argc
operator|-
literal|2
argument_list|,
name|argv
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|afterPtr
operator|=
name|assocPtr
operator|->
name|firstAfterPtr
init|;
name|afterPtr
operator|!=
name|NULL
condition|;
name|afterPtr
operator|=
name|afterPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|afterPtr
operator|->
name|command
argument_list|,
name|arg
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|afterPtr
operator|==
name|NULL
condition|)
block|{
name|afterPtr
operator|=
name|GetAfterEvent
argument_list|(
name|assocPtr
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|!=
name|argv
index|[
literal|2
index|]
condition|)
block|{
name|ckfree
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|afterPtr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|afterPtr
operator|->
name|token
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DeleteTimerHandler
argument_list|(
name|afterPtr
operator|->
name|token
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_CancelIdleCall
argument_list|(
name|AfterProc
argument_list|,
operator|(
name|ClientData
operator|)
name|afterPtr
argument_list|)
expr_stmt|;
block|}
name|FreeAfterPtr
argument_list|(
name|afterPtr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"idle"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|2
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" idle script script ...\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|afterPtr
operator|=
operator|(
name|AfterInfo
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|AfterInfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|afterPtr
operator|->
name|assocPtr
operator|=
name|assocPtr
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
block|{
name|afterPtr
operator|->
name|command
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|afterPtr
operator|->
name|command
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|afterPtr
operator|->
name|command
operator|=
name|Tcl_Concat
argument_list|(
name|argc
operator|-
literal|2
argument_list|,
name|argv
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
name|afterPtr
operator|->
name|id
operator|=
name|nextId
expr_stmt|;
name|nextId
operator|+=
literal|1
expr_stmt|;
name|afterPtr
operator|->
name|token
operator|=
name|NULL
expr_stmt|;
name|afterPtr
operator|->
name|nextPtr
operator|=
name|assocPtr
operator|->
name|firstAfterPtr
expr_stmt|;
name|assocPtr
operator|->
name|firstAfterPtr
operator|=
name|afterPtr
expr_stmt|;
name|Tcl_DoWhenIdle
argument_list|(
name|AfterProc
argument_list|,
operator|(
name|ClientData
operator|)
name|afterPtr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"after#%d"
argument_list|,
name|afterPtr
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"info"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|length
operator|>=
literal|2
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
name|char
name|buffer
index|[
literal|30
index|]
decl_stmt|;
for|for
control|(
name|afterPtr
operator|=
name|assocPtr
operator|->
name|firstAfterPtr
init|;
name|afterPtr
operator|!=
name|NULL
condition|;
name|afterPtr
operator|=
name|afterPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|assocPtr
operator|->
name|interp
operator|==
name|interp
condition|)
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"after#%d"
argument_list|,
name|afterPtr
operator|->
name|id
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" info ?id?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|afterPtr
operator|=
name|GetAfterEvent
argument_list|(
name|assocPtr
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|afterPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"event \""
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"\" doesn't exist"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|afterPtr
operator|->
name|command
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
operator|(
name|afterPtr
operator|->
name|token
operator|==
name|NULL
operator|)
condition|?
literal|"idle"
else|:
literal|"timer"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad argument \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": must be cancel, idle, info, or a number"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * GetAfterEvent --  *  *	This procedure parses an "after" id such as "after#4" and  *	returns a pointer to the AfterInfo structure.  *  * Results:  *	The return value is either a pointer to an AfterInfo structure,  *	if one is found that corresponds to "string" and is for interp,  *	or NULL if no corresponding after event can be found.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|AfterInfo
modifier|*
name|GetAfterEvent
parameter_list|(
name|assocPtr
parameter_list|,
name|string
parameter_list|)
name|AfterAssocData
modifier|*
name|assocPtr
decl_stmt|;
comment|/* Points to "after"-related information for 				 * this interpreter. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Textual identifier for after event, such 				 * as "after#6". */
block|{
name|AfterInfo
modifier|*
name|afterPtr
decl_stmt|;
name|int
name|id
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|string
argument_list|,
literal|"after#"
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|string
operator|+=
literal|6
expr_stmt|;
name|id
operator|=
name|strtoul
argument_list|(
name|string
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|end
operator|==
name|string
operator|)
operator|||
operator|(
operator|*
name|end
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
for|for
control|(
name|afterPtr
operator|=
name|assocPtr
operator|->
name|firstAfterPtr
init|;
name|afterPtr
operator|!=
name|NULL
condition|;
name|afterPtr
operator|=
name|afterPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|afterPtr
operator|->
name|id
operator|==
name|id
condition|)
block|{
return|return
name|afterPtr
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * AfterProc --  *  *	Timer callback to execute commands registered with the  *	"after" command.  *  * Results:  *	None.  *  * Side effects:  *	Executes whatever command was specified.  If the command  *	returns an error, then the command "bgerror" is invoked  *	to process the error;  if bgerror fails then information  *	about the error is output on stderr.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|AfterProc
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Describes command to execute. */
block|{
name|AfterInfo
modifier|*
name|afterPtr
init|=
operator|(
name|AfterInfo
operator|*
operator|)
name|clientData
decl_stmt|;
name|AfterAssocData
modifier|*
name|assocPtr
init|=
name|afterPtr
operator|->
name|assocPtr
decl_stmt|;
name|AfterInfo
modifier|*
name|prevPtr
decl_stmt|;
name|int
name|result
decl_stmt|;
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/*      * First remove the callback from our list of callbacks;  otherwise      * someone could delete the callback while it's being executed, which      * could cause a core dump.      */
if|if
condition|(
name|assocPtr
operator|->
name|firstAfterPtr
operator|==
name|afterPtr
condition|)
block|{
name|assocPtr
operator|->
name|firstAfterPtr
operator|=
name|afterPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|prevPtr
operator|=
name|assocPtr
operator|->
name|firstAfterPtr
init|;
name|prevPtr
operator|->
name|nextPtr
operator|!=
name|afterPtr
condition|;
name|prevPtr
operator|=
name|prevPtr
operator|->
name|nextPtr
control|)
block|{
comment|/* Empty loop body. */
block|}
name|prevPtr
operator|->
name|nextPtr
operator|=
name|afterPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
comment|/*      * Execute the callback.      */
name|interp
operator|=
name|assocPtr
operator|->
name|interp
expr_stmt|;
name|Tcl_Preserve
argument_list|(
operator|(
name|ClientData
operator|)
name|interp
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_GlobalEval
argument_list|(
name|interp
argument_list|,
name|afterPtr
operator|->
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
literal|"\n    (\"after\" script)"
argument_list|)
expr_stmt|;
name|Tcl_BackgroundError
argument_list|(
name|interp
argument_list|)
expr_stmt|;
block|}
name|Tcl_Release
argument_list|(
operator|(
name|ClientData
operator|)
name|interp
argument_list|)
expr_stmt|;
comment|/*      * Free the memory for the callback.      */
name|ckfree
argument_list|(
name|afterPtr
operator|->
name|command
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|afterPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FreeAfterPtr --  *  *	This procedure removes an "after" command from the list of  *	those that are pending and frees its resources.  This procedure  *	does *not* cancel the timer handler;  if that's needed, the  *	caller must do it.  *  * Results:  *	None.  *  * Side effects:  *	The memory associated with afterPtr is released.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|FreeAfterPtr
parameter_list|(
name|afterPtr
parameter_list|)
name|AfterInfo
modifier|*
name|afterPtr
decl_stmt|;
comment|/* Command to be deleted. */
block|{
name|AfterInfo
modifier|*
name|prevPtr
decl_stmt|;
name|AfterAssocData
modifier|*
name|assocPtr
init|=
name|afterPtr
operator|->
name|assocPtr
decl_stmt|;
if|if
condition|(
name|assocPtr
operator|->
name|firstAfterPtr
operator|==
name|afterPtr
condition|)
block|{
name|assocPtr
operator|->
name|firstAfterPtr
operator|=
name|afterPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|prevPtr
operator|=
name|assocPtr
operator|->
name|firstAfterPtr
init|;
name|prevPtr
operator|->
name|nextPtr
operator|!=
name|afterPtr
condition|;
name|prevPtr
operator|=
name|prevPtr
operator|->
name|nextPtr
control|)
block|{
comment|/* Empty loop body. */
block|}
name|prevPtr
operator|->
name|nextPtr
operator|=
name|afterPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
name|ckfree
argument_list|(
name|afterPtr
operator|->
name|command
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|afterPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * AfterCleanupProc --  *  *	This procedure is invoked whenever an interpreter is deleted  *	to cleanup the AssocData for "tclAfter".  *  * Results:  *	None.  *  * Side effects:  *	After commands are removed.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|AfterCleanupProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Points to AfterAssocData for the 				 * interpreter. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter that is being deleted. */
block|{
name|AfterAssocData
modifier|*
name|assocPtr
init|=
operator|(
name|AfterAssocData
operator|*
operator|)
name|clientData
decl_stmt|;
name|AfterInfo
modifier|*
name|afterPtr
decl_stmt|;
while|while
condition|(
name|assocPtr
operator|->
name|firstAfterPtr
operator|!=
name|NULL
condition|)
block|{
name|afterPtr
operator|=
name|assocPtr
operator|->
name|firstAfterPtr
expr_stmt|;
name|assocPtr
operator|->
name|firstAfterPtr
operator|=
name|afterPtr
operator|->
name|nextPtr
expr_stmt|;
if|if
condition|(
name|afterPtr
operator|->
name|token
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DeleteTimerHandler
argument_list|(
name|afterPtr
operator|->
name|token
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_CancelIdleCall
argument_list|(
name|AfterProc
argument_list|,
operator|(
name|ClientData
operator|)
name|afterPtr
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
name|afterPtr
operator|->
name|command
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|afterPtr
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|assocPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_VwaitCmd --  *  *	This procedure is invoked to process the "vwait" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_VwaitCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|done
decl_stmt|,
name|foundEvent
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" name\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_TraceVar
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|TCL_GLOBAL_ONLY
operator||
name|TCL_TRACE_WRITES
operator||
name|TCL_TRACE_UNSETS
argument_list|,
name|VwaitVarProc
argument_list|,
operator|(
name|ClientData
operator|)
operator|&
name|done
argument_list|)
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
name|foundEvent
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
name|foundEvent
condition|)
block|{
name|foundEvent
operator|=
name|Tcl_DoOneEvent
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|Tcl_UntraceVar
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|TCL_GLOBAL_ONLY
operator||
name|TCL_TRACE_WRITES
operator||
name|TCL_TRACE_UNSETS
argument_list|,
name|VwaitVarProc
argument_list|,
operator|(
name|ClientData
operator|)
operator|&
name|done
argument_list|)
expr_stmt|;
comment|/*      * Clear out the interpreter's result, since it may have been set      * by event handlers.      */
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|foundEvent
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"can't wait for variable \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\":  would wait forever"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|VwaitVarProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|name1
parameter_list|,
name|name2
parameter_list|,
name|flags
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Pointer to integer to set to 1. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter containing variable. */
name|char
modifier|*
name|name1
decl_stmt|;
comment|/* Name of variable. */
name|char
modifier|*
name|name2
decl_stmt|;
comment|/* Second part of variable name. */
name|int
name|flags
decl_stmt|;
comment|/* Information about what happened. */
block|{
name|int
modifier|*
name|donePtr
init|=
operator|(
name|int
operator|*
operator|)
name|clientData
decl_stmt|;
operator|*
name|donePtr
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_UpdateCmd --  *  *	This procedure is invoked to process the "update" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_UpdateCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
comment|/* Initialization needed only to stop 				 * compiler warnings. */
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|flags
operator|=
name|TCL_ALL_EVENTS
operator||
name|TCL_DONT_WAIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"idletasks"
argument_list|,
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": must be idletasks"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|flags
operator|=
name|TCL_IDLE_EVENTS
operator||
name|TCL_DONT_WAIT
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" ?idletasks?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
while|while
condition|(
name|Tcl_DoOneEvent
argument_list|(
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Empty loop body */
block|}
comment|/*      * Must clear the interpreter's result because event handlers could      * have executed commands.      */
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclWaitForFile --  *  *	This procedure waits synchronously for a file to become readable  *	or writable, with an optional timeout.  *  * Results:  *	The return value is an OR'ed combination of TCL_READABLE,  *	TCL_WRITABLE, and TCL_EXCEPTION, indicating the conditions  *	that are present on file at the time of the return.  This  *	procedure will not return until either "timeout" milliseconds  *	have elapsed or at least one of the conditions given by mask  *	has occurred for file (a return value of 0 means that a timeout  *	occurred).  No normal events will be serviced during the  *	execution of this procedure.  *  * Side effects:  *	Time passes.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclWaitForFile
parameter_list|(
name|file
parameter_list|,
name|mask
parameter_list|,
name|timeout
parameter_list|)
name|Tcl_File
name|file
decl_stmt|;
comment|/* Handle for file on which to wait. */
name|int
name|mask
decl_stmt|;
comment|/* What to wait for: OR'ed combination of 				 * TCL_READABLE, TCL_WRITABLE, and 				 * TCL_EXCEPTION. */
name|int
name|timeout
decl_stmt|;
comment|/* Maximum amount of time to wait for one 				 * of the conditions in mask to occur, in 				 * milliseconds.  A value of 0 means don't 				 * wait at all, and a value of -1 means 				 * wait forever. */
block|{
name|Tcl_Time
name|abortTime
decl_stmt|,
name|now
decl_stmt|,
name|blockTime
decl_stmt|;
name|int
name|present
decl_stmt|;
comment|/*      * If there is a non-zero finite timeout, compute the time when      * we give up.      */
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
name|TclGetTime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|abortTime
operator|.
name|sec
operator|=
name|now
operator|.
name|sec
operator|+
name|timeout
operator|/
literal|1000
expr_stmt|;
name|abortTime
operator|.
name|usec
operator|=
name|now
operator|.
name|usec
operator|+
operator|(
name|timeout
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
if|if
condition|(
name|abortTime
operator|.
name|usec
operator|>=
literal|1000000
condition|)
block|{
name|abortTime
operator|.
name|usec
operator|-=
literal|1000000
expr_stmt|;
name|abortTime
operator|.
name|sec
operator|+=
literal|1
expr_stmt|;
block|}
block|}
comment|/*      * Loop in a mini-event loop of our own, waiting for either the      * file to become ready or a timeout to occur.      */
while|while
condition|(
literal|1
condition|)
block|{
name|Tcl_WatchFile
argument_list|(
name|file
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
name|blockTime
operator|.
name|sec
operator|=
name|abortTime
operator|.
name|sec
operator|-
name|now
operator|.
name|sec
expr_stmt|;
name|blockTime
operator|.
name|usec
operator|=
name|abortTime
operator|.
name|usec
operator|-
name|now
operator|.
name|usec
expr_stmt|;
if|if
condition|(
name|blockTime
operator|.
name|usec
operator|<
literal|0
condition|)
block|{
name|blockTime
operator|.
name|sec
operator|-=
literal|1
expr_stmt|;
name|blockTime
operator|.
name|usec
operator|+=
literal|1000000
expr_stmt|;
block|}
if|if
condition|(
name|blockTime
operator|.
name|sec
operator|<
literal|0
condition|)
block|{
name|blockTime
operator|.
name|sec
operator|=
literal|0
expr_stmt|;
name|blockTime
operator|.
name|usec
operator|=
literal|0
expr_stmt|;
block|}
name|Tcl_WaitForEvent
argument_list|(
operator|&
name|blockTime
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|blockTime
operator|.
name|sec
operator|=
literal|0
expr_stmt|;
name|blockTime
operator|.
name|usec
operator|=
literal|0
expr_stmt|;
name|Tcl_WaitForEvent
argument_list|(
operator|&
name|blockTime
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_WaitForEvent
argument_list|(
operator|(
name|Tcl_Time
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|present
operator|=
name|Tcl_FileReady
argument_list|(
name|file
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|present
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|TclGetTime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|abortTime
operator|.
name|sec
operator|<
name|now
operator|.
name|sec
operator|)
operator|||
operator|(
operator|(
name|abortTime
operator|.
name|sec
operator|==
name|now
operator|.
name|sec
operator|)
operator|&&
operator|(
name|abortTime
operator|.
name|usec
operator|<=
name|now
operator|.
name|usec
operator|)
operator|)
condition|)
block|{
break|break;
block|}
block|}
return|return
name|present
return|;
block|}
end_function

end_unit

