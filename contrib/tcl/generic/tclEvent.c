begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclEvent.c --  *  *	This file implements some general event related interfaces including  *	background errors, exit handlers, and the "vwait" and "update"  *	command procedures.   *  * Copyright (c) 1990-1994 The Regents of the University of California.  * Copyright (c) 1994-1997 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclEvent.c 1.153 97/08/11 20:22:31  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * The data structure below is used to report background errors.  One  * such structure is allocated for each error;  it holds information  * about the interpreter and the error until bgerror can be invoked  * later as an idle handler.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|BgError
block|{
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which error occurred.  NULL 				 * means this error report has been cancelled 				 * (a previous report generated a break). */
name|char
modifier|*
name|errorMsg
decl_stmt|;
comment|/* The error message (interp->result when 				 * the error occurred).  Malloc-ed. */
name|char
modifier|*
name|errorInfo
decl_stmt|;
comment|/* Value of the errorInfo variable 				 * (malloc-ed). */
name|char
modifier|*
name|errorCode
decl_stmt|;
comment|/* Value of the errorCode variable 				 * (malloc-ed). */
name|struct
name|BgError
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next in list of all pending error 				 * reports for this interpreter, or NULL 				 * for end of list. */
block|}
name|BgError
typedef|;
end_typedef

begin_comment
comment|/*  * One of the structures below is associated with the "tclBgError"  * assoc data for each interpreter.  It keeps track of the head and  * tail of the list of pending background errors for the interpreter.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ErrAssocData
block|{
name|BgError
modifier|*
name|firstBgPtr
decl_stmt|;
comment|/* First in list of all background errors 				 * waiting to be processed for this 				 * interpreter (NULL if none). */
name|BgError
modifier|*
name|lastBgPtr
decl_stmt|;
comment|/* Last in list of all background errors 				 * waiting to be processed for this 				 * interpreter (NULL if none). */
block|}
name|ErrAssocData
typedef|;
end_typedef

begin_comment
comment|/*  * For each exit handler created with a call to Tcl_CreateExitHandler  * there is a structure of the following type:  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ExitHandler
block|{
name|Tcl_ExitProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to call when process exits. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* One word of information to pass to proc. */
name|struct
name|ExitHandler
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next in list of all exit handlers for 				 * this application, or NULL for end of list. */
block|}
name|ExitHandler
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|ExitHandler
modifier|*
name|firstExitPtr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First in list of all exit handlers for 				 * application. */
end_comment

begin_comment
comment|/*  * The following variable is a "secret" indication to Tcl_Exit that  * it should dump out the state of memory before exiting.  If the  * value is non-NULL, it gives the name of the file in which to  * dump memory usage information.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|tclMemDumpFileName
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This variable is set to 1 when Tcl_Exit is called, and at the end of  * its work, it is reset to 0. The variable is checked by TclInExit() to  * allow different behavior for exit-time processing, e.g. in closing of  * files and pipes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tclInExit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Prototypes for procedures referenced only in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|BgErrorDeleteProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|HandleBgErrors
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|VwaitVarProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|name1
operator|,
name|char
operator|*
name|name2
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_BackgroundError --  *  *	This procedure is invoked to handle errors that occur in Tcl  *	commands that are invoked in "background" (e.g. from event or  *	timer bindings).  *  * Results:  *	None.  *  * Side effects:  *	The command "bgerror" is invoked later as an idle handler to  *	process the error, passing it the error message.  If that fails,  *	then an error message is output on stderr.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_BackgroundError
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which an error has 				 * occurred. */
block|{
name|BgError
modifier|*
name|errPtr
decl_stmt|;
name|char
modifier|*
name|errResult
decl_stmt|,
modifier|*
name|varValue
decl_stmt|;
name|ErrAssocData
modifier|*
name|assocPtr
decl_stmt|;
comment|/*      * The Tcl_AddErrorInfo call below (with an empty string) ensures that      * errorInfo gets properly set.  It's needed in cases where the error      * came from a utility procedure like Tcl_GetVar instead of Tcl_Eval;      * in these cases errorInfo still won't have been set when this      * procedure is called.      */
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|errResult
operator|=
name|TclGetStringFromObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|errPtr
operator|=
operator|(
name|BgError
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BgError
argument_list|)
argument_list|)
expr_stmt|;
name|errPtr
operator|->
name|interp
operator|=
name|interp
expr_stmt|;
name|errPtr
operator|->
name|errorMsg
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|errResult
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|errPtr
operator|->
name|errorMsg
argument_list|,
name|errResult
argument_list|)
expr_stmt|;
name|varValue
operator|=
name|Tcl_GetVar
argument_list|(
name|interp
argument_list|,
literal|"errorInfo"
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|varValue
operator|==
name|NULL
condition|)
block|{
name|varValue
operator|=
name|errPtr
operator|->
name|errorMsg
expr_stmt|;
block|}
name|errPtr
operator|->
name|errorInfo
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|varValue
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|errPtr
operator|->
name|errorInfo
argument_list|,
name|varValue
argument_list|)
expr_stmt|;
name|varValue
operator|=
name|Tcl_GetVar
argument_list|(
name|interp
argument_list|,
literal|"errorCode"
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|varValue
operator|==
name|NULL
condition|)
block|{
name|varValue
operator|=
literal|""
expr_stmt|;
block|}
name|errPtr
operator|->
name|errorCode
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|varValue
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|errPtr
operator|->
name|errorCode
argument_list|,
name|varValue
argument_list|)
expr_stmt|;
name|errPtr
operator|->
name|nextPtr
operator|=
name|NULL
expr_stmt|;
name|assocPtr
operator|=
operator|(
name|ErrAssocData
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclBgError"
argument_list|,
operator|(
name|Tcl_InterpDeleteProc
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|assocPtr
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * This is the first time a background error has occurred in 	 * this interpreter.  Create associated data to keep track of 	 * pending error reports. 	 */
name|assocPtr
operator|=
operator|(
name|ErrAssocData
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ErrAssocData
argument_list|)
argument_list|)
expr_stmt|;
name|assocPtr
operator|->
name|firstBgPtr
operator|=
name|NULL
expr_stmt|;
name|assocPtr
operator|->
name|lastBgPtr
operator|=
name|NULL
expr_stmt|;
name|Tcl_SetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclBgError"
argument_list|,
name|BgErrorDeleteProc
argument_list|,
operator|(
name|ClientData
operator|)
name|assocPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|assocPtr
operator|->
name|firstBgPtr
operator|==
name|NULL
condition|)
block|{
name|assocPtr
operator|->
name|firstBgPtr
operator|=
name|errPtr
expr_stmt|;
name|Tcl_DoWhenIdle
argument_list|(
name|HandleBgErrors
argument_list|,
operator|(
name|ClientData
operator|)
name|assocPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assocPtr
operator|->
name|lastBgPtr
operator|->
name|nextPtr
operator|=
name|errPtr
expr_stmt|;
block|}
name|assocPtr
operator|->
name|lastBgPtr
operator|=
name|errPtr
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * HandleBgErrors --  *  *	This procedure is invoked as an idle handler to process all of  *	the accumulated background errors.  *  * Results:  *	None.  *  * Side effects:  *	Depends on what actions "bgerror" takes for the errors.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|HandleBgErrors
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Pointer to ErrAssocData structure. */
block|{
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
name|char
modifier|*
name|command
decl_stmt|;
name|char
modifier|*
name|argv
index|[
literal|2
index|]
decl_stmt|;
name|int
name|code
decl_stmt|;
name|BgError
modifier|*
name|errPtr
decl_stmt|;
name|ErrAssocData
modifier|*
name|assocPtr
init|=
operator|(
name|ErrAssocData
operator|*
operator|)
name|clientData
decl_stmt|;
name|Tcl_Channel
name|errChannel
decl_stmt|;
name|Tcl_Preserve
argument_list|(
operator|(
name|ClientData
operator|)
name|assocPtr
argument_list|)
expr_stmt|;
while|while
condition|(
name|assocPtr
operator|->
name|firstBgPtr
operator|!=
name|NULL
condition|)
block|{
name|interp
operator|=
name|assocPtr
operator|->
name|firstBgPtr
operator|->
name|interp
expr_stmt|;
if|if
condition|(
name|interp
operator|==
name|NULL
condition|)
block|{
goto|goto
name|doneWithInterp
goto|;
block|}
comment|/* 	 * Restore important state variables to what they were at 	 * the time the error occurred. 	 */
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
literal|"errorInfo"
argument_list|,
name|assocPtr
operator|->
name|firstBgPtr
operator|->
name|errorInfo
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
literal|"errorCode"
argument_list|,
name|assocPtr
operator|->
name|firstBgPtr
operator|->
name|errorCode
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
comment|/* 	 * Create and invoke the bgerror command. 	 */
name|argv
index|[
literal|0
index|]
operator|=
literal|"bgerror"
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
name|assocPtr
operator|->
name|firstBgPtr
operator|->
name|errorMsg
expr_stmt|;
name|command
operator|=
name|Tcl_Merge
argument_list|(
literal|2
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|Tcl_AllowExceptions
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_Preserve
argument_list|(
operator|(
name|ClientData
operator|)
name|interp
argument_list|)
expr_stmt|;
name|code
operator|=
name|Tcl_GlobalEval
argument_list|(
name|interp
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TCL_ERROR
condition|)
block|{
comment|/*              * If the interpreter is safe, we look for a hidden command              * named "bgerror" and call that with the error information.              * Otherwise, simply ignore the error. The rationale is that              * this could be an error caused by a malicious applet trying              * to cause an infinite barrage of error messages. The hidden              * "bgerror" command can be used by a security policy to              * interpose on such attacks and e.g. kill the applet after a              * few attempts.              */
if|if
condition|(
name|Tcl_IsSafe
argument_list|(
name|interp
argument_list|)
condition|)
block|{
name|Tcl_HashTable
modifier|*
name|hTblPtr
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|hTblPtr
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclHiddenCmds"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hTblPtr
operator|==
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
condition|)
block|{
goto|goto
name|doneWithInterp
goto|;
block|}
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
name|hTblPtr
argument_list|,
literal|"bgerror"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|)
block|{
goto|goto
name|doneWithInterp
goto|;
block|}
comment|/*                  * OK, the hidden command "bgerror" exists, invoke it.                  */
name|argv
index|[
literal|0
index|]
operator|=
literal|"bgerror"
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|assocPtr
operator|->
name|firstBgPtr
operator|->
name|errorMsg
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|assocPtr
operator|->
name|firstBgPtr
operator|->
name|errorMsg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|TclInvoke
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|argv
argument_list|,
name|TCL_INVOKE_HIDDEN
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|doneWithInterp
goto|;
block|}
comment|/*              * We have to get the error output channel at the latest possible              * time, because the eval (above) might have changed the channel.              */
name|errChannel
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|errChannel
operator|!=
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"\"bgerror\" is an invalid command name or ambiguous abbreviation"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_Write
argument_list|(
name|errChannel
argument_list|,
name|assocPtr
operator|->
name|firstBgPtr
operator|->
name|errorInfo
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_Write
argument_list|(
name|errChannel
argument_list|,
literal|"\n"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_Write
argument_list|(
name|errChannel
argument_list|,
literal|"bgerror failed to handle background error.\n"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_Write
argument_list|(
name|errChannel
argument_list|,
literal|"    Original error: "
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_Write
argument_list|(
name|errChannel
argument_list|,
name|assocPtr
operator|->
name|firstBgPtr
operator|->
name|errorMsg
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_Write
argument_list|(
name|errChannel
argument_list|,
literal|"\n"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_Write
argument_list|(
name|errChannel
argument_list|,
literal|"    Error in bgerror: "
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_Write
argument_list|(
name|errChannel
argument_list|,
name|interp
operator|->
name|result
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_Write
argument_list|(
name|errChannel
argument_list|,
literal|"\n"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|Tcl_Flush
argument_list|(
name|errChannel
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|TCL_BREAK
condition|)
block|{
comment|/* 	     * Break means cancel any remaining error reports for this 	     * interpreter. 	     */
for|for
control|(
name|errPtr
operator|=
name|assocPtr
operator|->
name|firstBgPtr
init|;
name|errPtr
operator|!=
name|NULL
condition|;
name|errPtr
operator|=
name|errPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|errPtr
operator|->
name|interp
operator|==
name|interp
condition|)
block|{
name|errPtr
operator|->
name|interp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Discard the command and the information about the error report. 	 */
name|doneWithInterp
label|:
if|if
condition|(
name|assocPtr
operator|->
name|firstBgPtr
condition|)
block|{
name|ckfree
argument_list|(
name|assocPtr
operator|->
name|firstBgPtr
operator|->
name|errorMsg
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|assocPtr
operator|->
name|firstBgPtr
operator|->
name|errorInfo
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|assocPtr
operator|->
name|firstBgPtr
operator|->
name|errorCode
argument_list|)
expr_stmt|;
name|errPtr
operator|=
name|assocPtr
operator|->
name|firstBgPtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|assocPtr
operator|->
name|firstBgPtr
argument_list|)
expr_stmt|;
name|assocPtr
operator|->
name|firstBgPtr
operator|=
name|errPtr
expr_stmt|;
block|}
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|Tcl_Release
argument_list|(
operator|(
name|ClientData
operator|)
name|interp
argument_list|)
expr_stmt|;
block|}
block|}
name|assocPtr
operator|->
name|lastBgPtr
operator|=
name|NULL
expr_stmt|;
name|Tcl_Release
argument_list|(
operator|(
name|ClientData
operator|)
name|assocPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * BgErrorDeleteProc --  *  *	This procedure is associated with the "tclBgError" assoc data  *	for an interpreter;  it is invoked when the interpreter is  *	deleted in order to free the information assoicated with any  *	pending error reports.  *  * Results:  *	None.  *  * Side effects:  *	Background error information is freed: if there were any  *	pending error reports, they are cancelled.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|BgErrorDeleteProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Pointer to ErrAssocData structure. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter being deleted. */
block|{
name|ErrAssocData
modifier|*
name|assocPtr
init|=
operator|(
name|ErrAssocData
operator|*
operator|)
name|clientData
decl_stmt|;
name|BgError
modifier|*
name|errPtr
decl_stmt|;
while|while
condition|(
name|assocPtr
operator|->
name|firstBgPtr
operator|!=
name|NULL
condition|)
block|{
name|errPtr
operator|=
name|assocPtr
operator|->
name|firstBgPtr
expr_stmt|;
name|assocPtr
operator|->
name|firstBgPtr
operator|=
name|errPtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
name|errPtr
operator|->
name|errorMsg
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|errPtr
operator|->
name|errorInfo
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|errPtr
operator|->
name|errorCode
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|errPtr
argument_list|)
expr_stmt|;
block|}
name|Tcl_CancelIdleCall
argument_list|(
name|HandleBgErrors
argument_list|,
operator|(
name|ClientData
operator|)
name|assocPtr
argument_list|)
expr_stmt|;
name|Tcl_EventuallyFree
argument_list|(
operator|(
name|ClientData
operator|)
name|assocPtr
argument_list|,
name|TCL_DYNAMIC
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CreateExitHandler --  *  *	Arrange for a given procedure to be invoked just before the  *	application exits.  *  * Results:  *	None.  *  * Side effects:  *	Proc will be invoked with clientData as argument when the  *	application exits.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_CreateExitHandler
parameter_list|(
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_ExitProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to invoke. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary value to pass to proc. */
block|{
name|ExitHandler
modifier|*
name|exitPtr
decl_stmt|;
name|exitPtr
operator|=
operator|(
name|ExitHandler
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ExitHandler
argument_list|)
argument_list|)
expr_stmt|;
name|exitPtr
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|exitPtr
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
name|exitPtr
operator|->
name|nextPtr
operator|=
name|firstExitPtr
expr_stmt|;
name|firstExitPtr
operator|=
name|exitPtr
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DeleteExitHandler --  *  *	This procedure cancels an existing exit handler matching proc  *	and clientData, if such a handler exits.  *  * Results:  *	None.  *  * Side effects:  *	If there is an exit handler corresponding to proc and clientData  *	then it is cancelled;  if no such handler exists then nothing  *	happens.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DeleteExitHandler
parameter_list|(
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_ExitProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure that was previously registered. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary value to pass to proc. */
block|{
name|ExitHandler
modifier|*
name|exitPtr
decl_stmt|,
modifier|*
name|prevPtr
decl_stmt|;
for|for
control|(
name|prevPtr
operator|=
name|NULL
operator|,
name|exitPtr
operator|=
name|firstExitPtr
init|;
name|exitPtr
operator|!=
name|NULL
condition|;
name|prevPtr
operator|=
name|exitPtr
operator|,
name|exitPtr
operator|=
name|exitPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
operator|(
name|exitPtr
operator|->
name|proc
operator|==
name|proc
operator|)
operator|&&
operator|(
name|exitPtr
operator|->
name|clientData
operator|==
name|clientData
operator|)
condition|)
block|{
if|if
condition|(
name|prevPtr
operator|==
name|NULL
condition|)
block|{
name|firstExitPtr
operator|=
name|exitPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
name|prevPtr
operator|->
name|nextPtr
operator|=
name|exitPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|exitPtr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_Exit --  *  *	This procedure is called to terminate the application.  *  * Results:  *	None.  *  * Side effects:  *	All existing exit handlers are invoked, then the application  *	ends.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_Exit
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
comment|/* Exit status for application;  typically 				 * 0 for normal return, 1 for error return. */
block|{
name|Tcl_Finalize
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
if|if
condition|(
name|tclMemDumpFileName
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DumpActiveMemory
argument_list|(
name|tclMemDumpFileName
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|TclPlatformExit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_Finalize --  *  *	Runs the exit handlers to allow Tcl to clean up its state prior  *	to being unloaded. Called by Tcl_Exit and when Tcl was dynamically  *	loaded and is now being unloaded.  *  * Results:  *	None.  *  * Side effects:  *	Whatever the exit handlers do. Also frees up storage associated  *	with the Tcl object type table.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_Finalize
parameter_list|()
block|{
name|ExitHandler
modifier|*
name|exitPtr
decl_stmt|;
comment|/*      * Invoke exit handler first.      */
name|tclInExit
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|exitPtr
operator|=
name|firstExitPtr
init|;
name|exitPtr
operator|!=
name|NULL
condition|;
name|exitPtr
operator|=
name|firstExitPtr
control|)
block|{
comment|/* 	 * Be careful to remove the handler from the list before invoking 	 * its callback.  This protects us against double-freeing if the 	 * callback should call Tcl_DeleteExitHandler on itself. 	 */
name|firstExitPtr
operator|=
name|exitPtr
operator|->
name|nextPtr
expr_stmt|;
call|(
modifier|*
name|exitPtr
operator|->
name|proc
call|)
argument_list|(
name|exitPtr
operator|->
name|clientData
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|exitPtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * Now finalize the Tcl execution environment.  Note that this must be done      * after the exit handlers, because there are order dependencies.      */
name|TclFinalizeCompExecEnv
argument_list|()
expr_stmt|;
name|TclFinalizeEnvironment
argument_list|()
expr_stmt|;
name|firstExitPtr
operator|=
name|NULL
expr_stmt|;
name|tclInExit
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclInExit --  *  *	Determines if we are in the middle of exit-time cleanup.  *  * Results:  *	If we are in the middle of exiting, 1, otherwise 0.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclInExit
parameter_list|()
block|{
return|return
name|tclInExit
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_VwaitCmd --  *  *	This procedure is invoked to process the "vwait" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_VwaitCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|done
decl_stmt|,
name|foundEvent
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" name\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_TraceVar
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|TCL_GLOBAL_ONLY
operator||
name|TCL_TRACE_WRITES
operator||
name|TCL_TRACE_UNSETS
argument_list|,
name|VwaitVarProc
argument_list|,
operator|(
name|ClientData
operator|)
operator|&
name|done
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
empty_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
name|foundEvent
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
name|foundEvent
condition|)
block|{
name|foundEvent
operator|=
name|Tcl_DoOneEvent
argument_list|(
name|TCL_ALL_EVENTS
argument_list|)
expr_stmt|;
block|}
name|Tcl_UntraceVar
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|TCL_GLOBAL_ONLY
operator||
name|TCL_TRACE_WRITES
operator||
name|TCL_TRACE_UNSETS
argument_list|,
name|VwaitVarProc
argument_list|,
operator|(
name|ClientData
operator|)
operator|&
name|done
argument_list|)
expr_stmt|;
comment|/*      * Clear out the interpreter's result, since it may have been set      * by event handlers.      */
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|foundEvent
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"can't wait for variable \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\":  would wait forever"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|VwaitVarProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|name1
parameter_list|,
name|name2
parameter_list|,
name|flags
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Pointer to integer to set to 1. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter containing variable. */
name|char
modifier|*
name|name1
decl_stmt|;
comment|/* Name of variable. */
name|char
modifier|*
name|name2
decl_stmt|;
comment|/* Second part of variable name. */
name|int
name|flags
decl_stmt|;
comment|/* Information about what happened. */
block|{
name|int
modifier|*
name|donePtr
init|=
operator|(
name|int
operator|*
operator|)
name|clientData
decl_stmt|;
operator|*
name|donePtr
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_UpdateCmd --  *  *	This procedure is invoked to process the "update" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_UpdateCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|flags
operator|=
name|TCL_ALL_EVENTS
operator||
name|TCL_DONT_WAIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"idletasks"
argument_list|,
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": must be idletasks"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|flags
operator|=
name|TCL_WINDOW_EVENTS
operator||
name|TCL_IDLE_EVENTS
operator||
name|TCL_DONT_WAIT
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" ?idletasks?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
while|while
condition|(
name|Tcl_DoOneEvent
argument_list|(
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Empty loop body */
block|}
comment|/*      * Must clear the interpreter's result because event handlers could      * have executed commands.      */
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

end_unit

