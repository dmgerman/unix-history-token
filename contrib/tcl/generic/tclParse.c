begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclParse.c --  *  *	This file contains a collection of procedures that are used  *	to parse Tcl commands or parts of commands (like quoted  *	strings or nested sub-commands).  *  * Copyright (c) 1987-1993 The Regents of the University of California.  * Copyright (c) 1994-1997 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclParse.c 1.56 97/07/29 18:40:03  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * Function prototypes for procedures local to this file:  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|QuoteEnd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|string
operator|,
name|char
operator|*
name|lastChar
operator|,
name|int
name|term
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ScriptEnd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|p
operator|,
name|char
operator|*
name|lastChar
operator|,
name|int
name|nested
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|VarNameEnd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|string
operator|,
name|char
operator|*
name|lastChar
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * TclParseQuotes --  *  *	This procedure parses a double-quoted string such as a  *	quoted Tcl command argument or a quoted value in a Tcl  *	expression.  This procedure is also used to parse array  *	element names within parentheses, or anything else that  *	needs all the substitutions that happen in quotes.  *  * Results:  *	The return value is a standard Tcl result, which is  *	TCL_OK unless there was an error while parsing the  *	quoted string.  If an error occurs then interp->result  *	contains a standard error message.  *TermPtr is filled  *	in with the address of the character just after the  *	last one successfully processed;  this is usually the  *	character just after the matching close-quote.  The  *	fully-substituted contents of the quotes are stored in  *	standard fashion in *pvPtr, null-terminated with  *	pvPtr->next pointing to the terminating null character.  *  * Side effects:  *	The buffer space in pvPtr may be enlarged by calling its  *	expandProc.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclParseQuotes
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|termChar
parameter_list|,
name|flags
parameter_list|,
name|termPtr
parameter_list|,
name|pvPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for nested command 				 * evaluations and error messages. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Character just after opening double- 				 * quote. */
name|int
name|termChar
decl_stmt|;
comment|/* Character that terminates "quoted" string 				 * (usually double-quote, but sometimes 				 * right-paren or something else). */
name|int
name|flags
decl_stmt|;
comment|/* Flags to pass to nested Tcl_Eval calls. */
name|char
modifier|*
modifier|*
name|termPtr
decl_stmt|;
comment|/* Store address of terminating character 				 * here. */
name|ParseValue
modifier|*
name|pvPtr
decl_stmt|;
comment|/* Information about where to place 				 * fully-substituted result of parse. */
block|{
specifier|register
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
name|c
decl_stmt|;
name|char
modifier|*
name|lastChar
init|=
name|string
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|src
operator|=
name|string
expr_stmt|;
name|dst
operator|=
name|pvPtr
operator|->
name|next
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|dst
operator|==
name|pvPtr
operator|->
name|end
condition|)
block|{
comment|/* 	     * Target buffer space is about to run out.  Make more space. 	     */
name|pvPtr
operator|->
name|next
operator|=
name|dst
expr_stmt|;
call|(
modifier|*
name|pvPtr
operator|->
name|expandProc
call|)
argument_list|(
name|pvPtr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dst
operator|=
name|pvPtr
operator|->
name|next
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|src
expr_stmt|;
name|src
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|termChar
condition|)
block|{
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
name|pvPtr
operator|->
name|next
operator|=
name|dst
expr_stmt|;
operator|*
name|termPtr
operator|=
name|src
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
name|CHAR_TYPE
argument_list|(
name|src
operator|-
literal|1
argument_list|,
name|lastChar
argument_list|)
operator|==
name|TCL_NORMAL
condition|)
block|{
name|copy
label|:
operator|*
name|dst
operator|=
name|c
expr_stmt|;
name|dst
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
block|{
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|value
operator|=
name|Tcl_ParseVar
argument_list|(
name|interp
argument_list|,
name|src
operator|-
literal|1
argument_list|,
name|termPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|src
operator|=
operator|*
name|termPtr
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pvPtr
operator|->
name|end
operator|-
name|dst
operator|)
operator|<=
name|length
condition|)
block|{
name|pvPtr
operator|->
name|next
operator|=
name|dst
expr_stmt|;
call|(
modifier|*
name|pvPtr
operator|->
name|expandProc
call|)
argument_list|(
name|pvPtr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|dst
operator|=
name|pvPtr
operator|->
name|next
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|dst
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|length
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'['
condition|)
block|{
name|int
name|result
decl_stmt|;
name|pvPtr
operator|->
name|next
operator|=
name|dst
expr_stmt|;
name|result
operator|=
name|TclParseNestedCmd
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
name|flags
argument_list|,
name|termPtr
argument_list|,
name|pvPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
name|src
operator|=
operator|*
name|termPtr
expr_stmt|;
name|dst
operator|=
name|pvPtr
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|int
name|numRead
decl_stmt|;
name|src
operator|--
expr_stmt|;
operator|*
name|dst
operator|=
name|Tcl_Backslash
argument_list|(
name|src
argument_list|,
operator|&
name|numRead
argument_list|)
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|src
operator|+=
name|numRead
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"missing %c"
argument_list|,
name|termChar
argument_list|)
expr_stmt|;
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
operator|*
name|termPtr
operator|=
name|string
operator|-
literal|1
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
else|else
block|{
goto|goto
name|copy
goto|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * TclParseNestedCmd --  *  *	This procedure parses a nested Tcl command between  *	brackets, returning the result of the command.  *  * Results:  *	The return value is a standard Tcl result, which is  *	TCL_OK unless there was an error while executing the  *	nested command.  If an error occurs then interp->result  *	contains a standard error message.  *TermPtr is filled  *	in with the address of the character just after the  *	last one processed;  this is usually the character just  *	after the matching close-bracket, or the null character  *	at the end of the string if the close-bracket was missing  *	(a missing close bracket is an error).  The result returned  *	by the command is stored in standard fashion in *pvPtr,  *	null-terminated, with pvPtr->next pointing to the null  *	character.  *  * Side effects:  *	The storage space at *pvPtr may be expanded.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclParseNestedCmd
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|flags
parameter_list|,
name|termPtr
parameter_list|,
name|pvPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for nested command 				 * evaluations and error messages. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Character just after opening bracket. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to pass to nested Tcl_Eval. */
name|char
modifier|*
modifier|*
name|termPtr
decl_stmt|;
comment|/* Store address of terminating character 				 * here. */
specifier|register
name|ParseValue
modifier|*
name|pvPtr
decl_stmt|;
comment|/* Information about where to place 				 * result of command. */
block|{
name|int
name|result
decl_stmt|,
name|length
decl_stmt|,
name|shortfall
decl_stmt|;
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|iPtr
operator|->
name|evalFlags
operator|=
name|flags
operator||
name|TCL_BRACKET_TERM
expr_stmt|;
name|result
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|string
argument_list|)
expr_stmt|;
operator|*
name|termPtr
operator|=
operator|(
name|string
operator|+
name|iPtr
operator|->
name|termOffset
operator|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
comment|/* 	 * The increment below results in slightly cleaner message in 	 * the errorInfo variable (the close-bracket will appear). 	 */
if|if
condition|(
operator|*
operator|*
name|termPtr
operator|==
literal|']'
condition|)
block|{
operator|*
name|termPtr
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
operator|(
operator|*
name|termPtr
operator|)
operator|+=
literal|1
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|iPtr
operator|->
name|result
argument_list|)
expr_stmt|;
name|shortfall
operator|=
name|length
operator|+
literal|1
operator|-
operator|(
name|pvPtr
operator|->
name|end
operator|-
name|pvPtr
operator|->
name|next
operator|)
expr_stmt|;
if|if
condition|(
name|shortfall
operator|>
literal|0
condition|)
block|{
call|(
modifier|*
name|pvPtr
operator|->
name|expandProc
call|)
argument_list|(
name|pvPtr
argument_list|,
name|shortfall
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|pvPtr
operator|->
name|next
argument_list|,
name|iPtr
operator|->
name|result
argument_list|)
expr_stmt|;
name|pvPtr
operator|->
name|next
operator|+=
name|length
expr_stmt|;
name|Tcl_FreeResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|result
operator|=
name|iPtr
operator|->
name|resultSpace
expr_stmt|;
name|iPtr
operator|->
name|resultSpace
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * TclParseBraces --  *  *	This procedure scans the information between matching  *	curly braces.  *  * Results:  *	The return value is a standard Tcl result, which is  *	TCL_OK unless there was an error while parsing string.  *	If an error occurs then interp->result contains a  *	standard error message.  *TermPtr is filled  *	in with the address of the character just after the  *	last one successfully processed;  this is usually the  *	character just after the matching close-brace.  The  *	information between curly braces is stored in standard  *	fashion in *pvPtr, null-terminated with pvPtr->next  *	pointing to the terminating null character.  *  * Side effects:  *	The storage space at *pvPtr may be expanded.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclParseBraces
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|termPtr
parameter_list|,
name|pvPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for nested command 				 * evaluations and error messages. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Character just after opening bracket. */
name|char
modifier|*
modifier|*
name|termPtr
decl_stmt|;
comment|/* Store address of terminating character 				 * here. */
specifier|register
name|ParseValue
modifier|*
name|pvPtr
decl_stmt|;
comment|/* Information about where to place 				 * result of command. */
block|{
name|int
name|level
decl_stmt|;
specifier|register
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
modifier|*
name|end
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|lastChar
init|=
name|string
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|src
operator|=
name|string
expr_stmt|;
name|dst
operator|=
name|pvPtr
operator|->
name|next
expr_stmt|;
name|end
operator|=
name|pvPtr
operator|->
name|end
expr_stmt|;
name|level
operator|=
literal|1
expr_stmt|;
comment|/*      * Copy the characters one at a time to the result area, stopping      * when the matching close-brace is found.      */
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
operator|*
name|src
expr_stmt|;
name|src
operator|++
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|end
condition|)
block|{
name|pvPtr
operator|->
name|next
operator|=
name|dst
expr_stmt|;
call|(
modifier|*
name|pvPtr
operator|->
name|expandProc
call|)
argument_list|(
name|pvPtr
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|dst
operator|=
name|pvPtr
operator|->
name|next
expr_stmt|;
name|end
operator|=
name|pvPtr
operator|->
name|end
expr_stmt|;
block|}
operator|*
name|dst
operator|=
name|c
expr_stmt|;
name|dst
operator|++
expr_stmt|;
if|if
condition|(
name|CHAR_TYPE
argument_list|(
name|src
operator|-
literal|1
argument_list|,
name|lastChar
argument_list|)
operator|==
name|TCL_NORMAL
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
block|{
name|level
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
block|{
name|level
operator|--
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
name|dst
operator|--
expr_stmt|;
comment|/* Don't copy the last close brace. */
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|int
name|count
decl_stmt|;
comment|/* 	     * Must always squish out backslash-newlines, even when in 	     * braces.  This is needed so that this sequence can appear 	     * anywhere in a command, such as the middle of an expression. 	     */
if|if
condition|(
operator|*
name|src
operator|==
literal|'\n'
condition|)
block|{
name|dst
index|[
operator|-
literal|1
index|]
operator|=
name|Tcl_Backslash
argument_list|(
name|src
operator|-
literal|1
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
name|src
operator|+=
name|count
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|Tcl_Backslash
argument_list|(
name|src
operator|-
literal|1
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|dst
operator|==
name|end
condition|)
block|{
name|pvPtr
operator|->
name|next
operator|=
name|dst
expr_stmt|;
call|(
modifier|*
name|pvPtr
operator|->
name|expandProc
call|)
argument_list|(
name|pvPtr
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|dst
operator|=
name|pvPtr
operator|->
name|next
expr_stmt|;
name|end
operator|=
name|pvPtr
operator|->
name|end
expr_stmt|;
block|}
operator|*
name|dst
operator|=
operator|*
name|src
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"missing close-brace"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
operator|*
name|termPtr
operator|=
name|string
operator|-
literal|1
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
name|pvPtr
operator|->
name|next
operator|=
name|dst
expr_stmt|;
operator|*
name|termPtr
operator|=
name|src
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * TclExpandParseValue --  *  *	This procedure is commonly used as the value of the  *	expandProc in a ParseValue.  It uses malloc to allocate  *	more space for the result of a parse.  *  * Results:  *	The buffer space in *pvPtr is reallocated to something  *	larger, and if pvPtr->clientData is non-zero the old  *	buffer is freed.  Information is copied from the old  *	buffer to the new one.  *  * Side effects:  *	None.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclExpandParseValue
parameter_list|(
name|pvPtr
parameter_list|,
name|needed
parameter_list|)
specifier|register
name|ParseValue
modifier|*
name|pvPtr
decl_stmt|;
comment|/* Information about buffer that 					 * must be expanded.  If the clientData 					 * in the structure is non-zero, it 					 * means that the current buffer is 					 * dynamically allocated. */
name|int
name|needed
decl_stmt|;
comment|/* Minimum amount of additional space 					 * to allocate. */
block|{
name|int
name|newSpace
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
comment|/*      * Either double the size of the buffer or add enough new space      * to meet the demand, whichever produces a larger new buffer.      */
name|newSpace
operator|=
operator|(
name|pvPtr
operator|->
name|end
operator|-
name|pvPtr
operator|->
name|buffer
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|newSpace
operator|<
name|needed
condition|)
block|{
name|newSpace
operator|+=
name|needed
expr_stmt|;
block|}
else|else
block|{
name|newSpace
operator|+=
name|newSpace
expr_stmt|;
block|}
name|new
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|newSpace
argument_list|)
expr_stmt|;
comment|/*      * Copy from old buffer to new, free old buffer if needed, and      * mark new buffer as malloc-ed.      */
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|new
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|pvPtr
operator|->
name|buffer
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|pvPtr
operator|->
name|next
operator|-
name|pvPtr
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|pvPtr
operator|->
name|next
operator|=
name|new
operator|+
operator|(
name|pvPtr
operator|->
name|next
operator|-
name|pvPtr
operator|->
name|buffer
operator|)
expr_stmt|;
if|if
condition|(
name|pvPtr
operator|->
name|clientData
operator|!=
literal|0
condition|)
block|{
name|ckfree
argument_list|(
name|pvPtr
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
name|pvPtr
operator|->
name|buffer
operator|=
name|new
expr_stmt|;
name|pvPtr
operator|->
name|end
operator|=
name|new
operator|+
name|newSpace
operator|-
literal|1
expr_stmt|;
name|pvPtr
operator|->
name|clientData
operator|=
operator|(
name|ClientData
operator|)
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclWordEnd --  *  *	Given a pointer into a Tcl command, find the end of the next  *	word of the command.  *  * Results:  *	The return value is a pointer to the last character that's part  *	of the word pointed to by "start".  If the word doesn't end  *	properly within the string then the return value is the address  *	of the null character at the end of the string.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|TclWordEnd
parameter_list|(
name|start
parameter_list|,
name|lastChar
parameter_list|,
name|nested
parameter_list|,
name|semiPtr
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
comment|/* Beginning of a word of a Tcl command. */
name|char
modifier|*
name|lastChar
decl_stmt|;
comment|/* Terminating character in string. */
name|int
name|nested
decl_stmt|;
comment|/* Zero means this is a top-level command. 				 * One means this is a nested command (close 				 * bracket is a word terminator). */
name|int
modifier|*
name|semiPtr
decl_stmt|;
comment|/* Set to 1 if word ends with a command- 				 * terminating semi-colon, zero otherwise. 				 * If NULL then ignored. */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|semiPtr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|semiPtr
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * Skip leading white space (backslash-newline must be treated like      * white-space, except that it better not be the last thing in the      * command).      */
for|for
control|(
name|p
operator|=
name|start
init|;
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|+
literal|2
operator|==
name|lastChar
condition|)
block|{
return|return
name|p
operator|+
literal|2
return|;
block|}
continue|continue;
block|}
break|break;
block|}
comment|/*      * Handle words beginning with a double-quote or a brace.      */
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
condition|)
block|{
name|p
operator|=
name|QuoteEnd
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|lastChar
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|lastChar
condition|)
block|{
return|return
name|p
return|;
block|}
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'{'
condition|)
block|{
name|int
name|braces
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|braces
operator|!=
literal|0
condition|)
block|{
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
operator|(
name|void
operator|)
name|Tcl_Backslash
argument_list|(
name|p
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
name|p
operator|+=
name|count
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'}'
condition|)
block|{
name|braces
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'{'
condition|)
block|{
name|braces
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|==
name|lastChar
condition|)
block|{
return|return
name|p
return|;
block|}
block|}
name|p
operator|++
expr_stmt|;
block|}
comment|/*      * Handle words that don't start with a brace or double-quote.      * This code is also invoked if the word starts with a brace or      * double-quote and there is garbage after the closing brace or      * quote.  This is an error as far as Tcl_Eval is concerned, but      * for here the garbage is treated as part of the word.      */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'['
condition|)
block|{
name|p
operator|=
name|ScriptEnd
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|lastChar
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|lastChar
condition|)
block|{
return|return
name|p
return|;
block|}
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
comment|/* 		 * Backslash-newline:  it maps to a space character 		 * that is a word separator, so the word ends just before 		 * the backslash. 		 */
return|return
name|p
operator|-
literal|1
return|;
block|}
operator|(
name|void
operator|)
name|Tcl_Backslash
argument_list|(
name|p
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
name|p
operator|+=
name|count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
name|p
operator|=
name|VarNameEnd
argument_list|(
name|p
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|lastChar
condition|)
block|{
return|return
name|p
return|;
block|}
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|';'
condition|)
block|{
comment|/* 	     * Include the semi-colon in the word that is returned. 	     */
if|if
condition|(
name|semiPtr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|semiPtr
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
elseif|else
if|if
condition|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|p
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|']'
operator|)
operator|&&
name|nested
condition|)
block|{
return|return
name|p
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|p
operator|==
name|lastChar
condition|)
block|{
if|if
condition|(
name|nested
condition|)
block|{
comment|/* 		 * Nested commands can't end because of the end of the 		 * string. 		 */
return|return
name|p
return|;
block|}
return|return
name|p
operator|-
literal|1
return|;
block|}
else|else
block|{
name|p
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * QuoteEnd --  *  *	Given a pointer to a string that obeys the parsing conventions  *	for quoted things in Tcl, find the end of that quoted thing.  *	The actual thing may be a quoted argument or a parenthesized  *	index name.  *  * Results:  *	The return value is a pointer to the last character that is  *	part of the quoted string (i.e the character that's equal to  *	term).  If the quoted string doesn't terminate properly then  *	the return value is a pointer to the null character at the  *	end of the string.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|QuoteEnd
parameter_list|(
name|string
parameter_list|,
name|lastChar
parameter_list|,
name|term
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Pointer to character just after opening 				 * "quote". */
name|char
modifier|*
name|lastChar
decl_stmt|;
comment|/* Terminating character in string. */
name|int
name|term
decl_stmt|;
comment|/* This character will terminate the 				 * quoted string (e.g. '"' or ')'). */
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|string
decl_stmt|;
name|int
name|count
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|term
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
operator|(
name|void
operator|)
name|Tcl_Backslash
argument_list|(
name|p
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
name|p
operator|+=
name|count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'['
condition|)
block|{
for|for
control|(
name|p
operator|++
init|;
operator|*
name|p
operator|!=
literal|']'
condition|;
name|p
operator|++
control|)
block|{
name|p
operator|=
name|TclWordEnd
argument_list|(
name|p
argument_list|,
name|lastChar
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
return|return
name|p
return|;
block|}
block|}
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
name|p
operator|=
name|VarNameEnd
argument_list|(
name|p
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
return|return
name|p
return|;
block|}
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|==
name|lastChar
condition|)
block|{
return|return
name|p
return|;
block|}
else|else
block|{
name|p
operator|++
expr_stmt|;
block|}
block|}
return|return
name|p
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * VarNameEnd --  *  *	Given a pointer to a variable reference using $-notation, find  *	the end of the variable name spec.  *  * Results:  *	The return value is a pointer to the last character that  *	is part of the variable name.  If the variable name doesn't  *	terminate properly then the return value is a pointer to the  *	null character at the end of the string.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|VarNameEnd
parameter_list|(
name|string
parameter_list|,
name|lastChar
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Pointer to dollar-sign character. */
name|char
modifier|*
name|lastChar
decl_stmt|;
comment|/* Terminating character in string. */
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|string
operator|+
literal|1
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'{'
condition|)
block|{
for|for
control|(
name|p
operator|++
init|;
operator|(
operator|*
name|p
operator|!=
literal|'}'
operator|)
operator|&&
operator|(
name|p
operator|!=
name|lastChar
operator|)
condition|;
name|p
operator|++
control|)
block|{
comment|/* Empty loop body. */
block|}
return|return
name|p
return|;
block|}
while|while
condition|(
name|isalnum
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'_'
operator|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'('
operator|)
operator|&&
operator|(
name|p
operator|!=
name|string
operator|+
literal|1
operator|)
condition|)
block|{
return|return
name|QuoteEnd
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|lastChar
argument_list|,
literal|')'
argument_list|)
return|;
block|}
return|return
name|p
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * ScriptEnd --  *  *	Given a pointer to the beginning of a Tcl script, find the end of  *	the script.  *  * Results:  *	The return value is a pointer to the last character that's part  *	of the script pointed to by "p".  If the command doesn't end  *	properly within the string then the return value is the address  *	of the null character at the end of the string.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ScriptEnd
parameter_list|(
name|p
parameter_list|,
name|lastChar
parameter_list|,
name|nested
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Script to check. */
name|char
modifier|*
name|lastChar
decl_stmt|;
comment|/* Terminating character in string. */
name|int
name|nested
decl_stmt|;
comment|/* Zero means this is a top-level command. 				 * One means this is a nested command (the 				 * last character of the script must be 				 * an unquoted ]). */
block|{
name|int
name|commentOK
init|=
literal|1
decl_stmt|;
name|int
name|length
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
name|commentOK
operator|=
literal|1
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'#'
operator|)
operator|&&
name|commentOK
condition|)
block|{
do|do
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
comment|/* 		     * If the script ends with backslash-newline, then 		     * this command isn't complete. 		     */
if|if
condition|(
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|)
operator|&&
operator|(
name|p
operator|+
literal|2
operator|==
name|lastChar
operator|)
condition|)
block|{
return|return
name|p
operator|+
literal|2
return|;
block|}
name|Tcl_Backslash
argument_list|(
name|p
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|p
operator|+=
name|length
expr_stmt|;
block|}
else|else
block|{
name|p
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|p
operator|!=
name|lastChar
operator|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|'\n'
operator|)
condition|)
do|;
continue|continue;
block|}
name|p
operator|=
name|TclWordEnd
argument_list|(
name|p
argument_list|,
name|lastChar
argument_list|,
name|nested
argument_list|,
operator|&
name|commentOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|lastChar
condition|)
block|{
return|return
name|p
return|;
block|}
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|nested
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|']'
condition|)
block|{
return|return
name|p
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|p
operator|==
name|lastChar
condition|)
block|{
return|return
name|p
operator|-
literal|1
return|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ParseVar --  *  *	Given a string starting with a $ sign, parse off a variable  *	name and return its value.  *  * Results:  *	The return value is the contents of the variable given by  *	the leading characters of string.  If termPtr isn't NULL,  *	*termPtr gets filled in with the address of the character  *	just after the last one in the variable specifier.  If the  *	variable doesn't exist, then the return value is NULL and  *	an error message will be left in interp->result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_ParseVar
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|termPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Context for looking up variable. */
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String containing variable name. 					 * First character must be "$". */
name|char
modifier|*
modifier|*
name|termPtr
decl_stmt|;
comment|/* If non-NULL, points to word to fill 					 * in with character just after last 					 * one in the variable specifier. */
block|{
name|char
modifier|*
name|name1
decl_stmt|,
modifier|*
name|name1End
decl_stmt|,
name|c
decl_stmt|,
modifier|*
name|result
decl_stmt|;
specifier|register
name|char
modifier|*
name|name2
decl_stmt|;
define|#
directive|define
name|NUM_CHARS
value|200
name|char
name|copyStorage
index|[
name|NUM_CHARS
index|]
decl_stmt|;
name|ParseValue
name|pv
decl_stmt|;
comment|/*      * There are three cases:      * 1. The $ sign is followed by an open curly brace.  Then the variable      *    name is everything up to the next close curly brace, and the      *    variable is a scalar variable.      * 2. The $ sign is not followed by an open curly brace.  Then the      *    variable name is everything up to the next character that isn't      *    a letter, digit, or underscore, or a "::" namespace separator.      *    If the following character is an open parenthesis, then the      *    information between parentheses is the array element name, which      *    can include any of the substitutions permissible between quotes.      * 3. The $ sign is followed by something that isn't a letter, digit,      *    underscore, or a "::" namespace separator: in this case,      *    there is no variable name, and "$" is returned.      */
name|name2
operator|=
name|NULL
expr_stmt|;
name|string
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'{'
condition|)
block|{
name|string
operator|++
expr_stmt|;
name|name1
operator|=
name|string
expr_stmt|;
while|while
condition|(
operator|*
name|string
operator|!=
literal|'}'
condition|)
block|{
if|if
condition|(
operator|*
name|string
operator|==
literal|0
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"missing close-brace for variable name"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|termPtr
operator|!=
literal|0
condition|)
block|{
operator|*
name|termPtr
operator|=
name|string
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
name|string
operator|++
expr_stmt|;
block|}
name|name1End
operator|=
name|string
expr_stmt|;
name|string
operator|++
expr_stmt|;
block|}
else|else
block|{
name|name1
operator|=
name|string
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|string
argument_list|)
argument_list|)
operator|||
operator|(
operator|*
name|string
operator|==
literal|'_'
operator|)
operator|||
operator|(
operator|*
name|string
operator|==
literal|':'
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|string
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|string
operator|+
literal|1
operator|)
operator|==
literal|':'
condition|)
block|{
name|string
operator|+=
literal|2
expr_stmt|;
comment|/* skip over the initial :: */
while|while
condition|(
operator|*
name|string
operator|==
literal|':'
condition|)
block|{
name|string
operator|++
expr_stmt|;
comment|/* skip over a subsequent : */
block|}
block|}
else|else
block|{
break|break;
comment|/* : by itself */
block|}
block|}
else|else
block|{
name|string
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|string
operator|==
name|name1
condition|)
block|{
if|if
condition|(
name|termPtr
operator|!=
literal|0
condition|)
block|{
operator|*
name|termPtr
operator|=
name|string
expr_stmt|;
block|}
return|return
literal|"$"
return|;
block|}
name|name1End
operator|=
name|string
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'('
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
comment|/* 	     * Perform substitutions on the array element name, just as 	     * is done for quotes. 	     */
name|pv
operator|.
name|buffer
operator|=
name|pv
operator|.
name|next
operator|=
name|copyStorage
expr_stmt|;
name|pv
operator|.
name|end
operator|=
name|copyStorage
operator|+
name|NUM_CHARS
operator|-
literal|1
expr_stmt|;
name|pv
operator|.
name|expandProc
operator|=
name|TclExpandParseValue
expr_stmt|;
name|pv
operator|.
name|clientData
operator|=
operator|(
name|ClientData
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|TclParseQuotes
argument_list|(
name|interp
argument_list|,
name|string
operator|+
literal|1
argument_list|,
literal|')'
argument_list|,
literal|0
argument_list|,
operator|&
name|end
argument_list|,
operator|&
name|pv
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|char
name|msg
index|[
literal|200
index|]
decl_stmt|;
name|int
name|length
decl_stmt|;
name|length
operator|=
name|string
operator|-
name|name1
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|100
condition|)
block|{
name|length
operator|=
literal|100
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n    (parsing index for array \"%.*s\")"
argument_list|,
name|length
argument_list|,
name|name1
argument_list|)
expr_stmt|;
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|result
operator|=
name|NULL
expr_stmt|;
name|name2
operator|=
name|pv
operator|.
name|buffer
expr_stmt|;
if|if
condition|(
name|termPtr
operator|!=
literal|0
condition|)
block|{
operator|*
name|termPtr
operator|=
name|end
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|string
operator|=
name|end
expr_stmt|;
name|name2
operator|=
name|pv
operator|.
name|buffer
expr_stmt|;
block|}
block|}
if|if
condition|(
name|termPtr
operator|!=
literal|0
condition|)
block|{
operator|*
name|termPtr
operator|=
name|string
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|name1End
expr_stmt|;
operator|*
name|name1End
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|Tcl_GetVar2
argument_list|(
name|interp
argument_list|,
name|name1
argument_list|,
name|name2
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
expr_stmt|;
operator|*
name|name1End
operator|=
name|c
expr_stmt|;
name|done
label|:
if|if
condition|(
operator|(
name|name2
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|pv
operator|.
name|buffer
operator|!=
name|copyStorage
operator|)
condition|)
block|{
name|ckfree
argument_list|(
name|pv
operator|.
name|buffer
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CommandComplete --  *  *	Given a partial or complete Tcl command, this procedure  *	determines whether the command is complete in the sense  *	of having matched braces and quotes and brackets.  *  * Results:  *	1 is returned if the command is complete, 0 otherwise.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_CommandComplete
parameter_list|(
name|cmd
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
comment|/* Command to check. */
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|cmd
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
name|p
operator|=
name|ScriptEnd
argument_list|(
name|cmd
argument_list|,
name|cmd
operator|+
name|strlen
argument_list|(
name|cmd
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|p
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclObjCommandComplete --  *  *	Given a partial or complete Tcl command in a Tcl object, this  *	procedure determines whether the command is complete in the sense of  *	having matched braces and quotes and brackets.  *  * Results:  *	1 is returned if the command is complete, 0 otherwise.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclObjCommandComplete
parameter_list|(
name|cmdPtr
parameter_list|)
name|Tcl_Obj
modifier|*
name|cmdPtr
decl_stmt|;
comment|/* Points to object holding command 					 * to check. */
block|{
name|char
modifier|*
name|cmd
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|length
decl_stmt|;
name|cmd
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|cmdPtr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
name|p
operator|=
name|ScriptEnd
argument_list|(
name|cmd
argument_list|,
name|cmd
operator|+
name|length
argument_list|,
comment|/*nested*/
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|p
operator|!=
literal|0
operator|)
return|;
block|}
end_function

end_unit

