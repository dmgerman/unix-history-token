begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclParse.c --  *  *	This file contains a collection of procedures that are used  *	to parse Tcl commands or parts of commands (like quoted  *	strings or nested sub-commands).  *  * Copyright (c) 1987-1993 The Regents of the University of California.  * Copyright (c) 1994-1996 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclParse.c 1.50 96/03/02 14:46:55  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * The following table assigns a type to each character.  Only types  * meaningful to Tcl parsing are represented here.  The table is  * designed to be referenced with either signed or unsigned characters,  * so it has 384 entries.  The first 128 entries correspond to negative  * character values, the next 256 correspond to positive character  * values.  The last 128 entries are identical to the first 128.  The  * table is always indexed with a 128-byte offset (the 128th entry  * corresponds to a 0 character value).  */
end_comment

begin_decl_stmt
name|char
name|tclTypeTable
index|[]
init|=
block|{
comment|/*      * Negative character values, from -128 to -1:      */
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
comment|/*      * Positive character values, from 0-127:      */
name|TCL_COMMAND_END
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_SPACE
block|,
name|TCL_COMMAND_END
block|,
name|TCL_SPACE
block|,
name|TCL_SPACE
block|,
name|TCL_SPACE
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_SPACE
block|,
name|TCL_NORMAL
block|,
name|TCL_QUOTE
block|,
name|TCL_NORMAL
block|,
name|TCL_DOLLAR
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_COMMAND_END
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_OPEN_BRACKET
block|,
name|TCL_BACKSLASH
block|,
name|TCL_COMMAND_END
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_OPEN_BRACE
block|,
name|TCL_NORMAL
block|,
name|TCL_CLOSE_BRACE
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
comment|/*      * Large unsigned character values, from 128-255:      */
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|,
name|TCL_NORMAL
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Function prototypes for procedures local to this file:  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|QuoteEnd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|string
operator|,
name|int
name|term
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ScriptEnd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|p
operator|,
name|int
name|nested
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|VarNameEnd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|string
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_Backslash --  *  *	Figure out how to handle a backslash sequence.  *  * Results:  *	The return value is the character that should be substituted  *	in place of the backslash sequence that starts at src.  If  *	readPtr isn't NULL then it is filled in with a count of the  *	number of characters in the backslash sequence.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
name|Tcl_Backslash
parameter_list|(
name|src
parameter_list|,
name|readPtr
parameter_list|)
name|char
modifier|*
name|src
decl_stmt|;
comment|/* Points to the backslash character of 				 * a backslash sequence. */
name|int
modifier|*
name|readPtr
decl_stmt|;
comment|/* Fill in with number of characters read 				 * from src, unless NULL. */
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|src
operator|+
literal|1
decl_stmt|;
name|char
name|result
decl_stmt|;
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|2
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'a'
case|:
name|result
operator|=
literal|0x7
expr_stmt|;
comment|/* Don't say '\a' here, since some compilers */
break|break;
comment|/* don't support it. */
case|case
literal|'b'
case|:
name|result
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|result
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|result
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|result
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|result
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|result
operator|=
literal|'\v'
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
name|isxdigit
argument_list|(
name|UCHAR
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|result
operator|=
operator|(
name|char
operator|)
name|strtoul
argument_list|(
name|p
operator|+
literal|1
argument_list|,
operator|&
name|end
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|count
operator|=
name|end
operator|-
name|src
expr_stmt|;
block|}
else|else
block|{
name|count
operator|=
literal|2
expr_stmt|;
name|result
operator|=
literal|'x'
expr_stmt|;
block|}
break|break;
case|case
literal|'\n'
case|:
do|do
block|{
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|*
name|p
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'\t'
operator|)
condition|)
do|;
name|result
operator|=
literal|' '
expr_stmt|;
name|count
operator|=
name|p
operator|-
name|src
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|result
operator|=
literal|'\\'
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|result
operator|=
call|(
name|char
call|)
argument_list|(
operator|*
name|p
operator|-
literal|'0'
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
break|break;
block|}
name|count
operator|=
literal|3
expr_stmt|;
name|result
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|result
operator|<<
literal|3
operator|)
operator|+
operator|(
operator|*
name|p
operator|-
literal|'0'
operator|)
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
break|break;
block|}
name|count
operator|=
literal|4
expr_stmt|;
name|result
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|result
operator|<<
literal|3
operator|)
operator|+
operator|(
operator|*
name|p
operator|-
literal|'0'
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|result
operator|=
operator|*
name|p
expr_stmt|;
name|count
operator|=
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|readPtr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|readPtr
operator|=
name|count
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * TclParseQuotes --  *  *	This procedure parses a double-quoted string such as a  *	quoted Tcl command argument or a quoted value in a Tcl  *	expression.  This procedure is also used to parse array  *	element names within parentheses, or anything else that  *	needs all the substitutions that happen in quotes.  *  * Results:  *	The return value is a standard Tcl result, which is  *	TCL_OK unless there was an error while parsing the  *	quoted string.  If an error occurs then interp->result  *	contains a standard error message.  *TermPtr is filled  *	in with the address of the character just after the  *	last one successfully processed;  this is usually the  *	character just after the matching close-quote.  The  *	fully-substituted contents of the quotes are stored in  *	standard fashion in *pvPtr, null-terminated with  *	pvPtr->next pointing to the terminating null character.  *  * Side effects:  *	The buffer space in pvPtr may be enlarged by calling its  *	expandProc.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclParseQuotes
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|termChar
parameter_list|,
name|flags
parameter_list|,
name|termPtr
parameter_list|,
name|pvPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for nested command 				 * evaluations and error messages. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Character just after opening double- 				 * quote. */
name|int
name|termChar
decl_stmt|;
comment|/* Character that terminates "quoted" string 				 * (usually double-quote, but sometimes 				 * right-paren or something else). */
name|int
name|flags
decl_stmt|;
comment|/* Flags to pass to nested Tcl_Eval calls. */
name|char
modifier|*
modifier|*
name|termPtr
decl_stmt|;
comment|/* Store address of terminating character 				 * here. */
name|ParseValue
modifier|*
name|pvPtr
decl_stmt|;
comment|/* Information about where to place 				 * fully-substituted result of parse. */
block|{
specifier|register
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
name|c
decl_stmt|;
name|src
operator|=
name|string
expr_stmt|;
name|dst
operator|=
name|pvPtr
operator|->
name|next
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|dst
operator|==
name|pvPtr
operator|->
name|end
condition|)
block|{
comment|/* 	     * Target buffer space is about to run out.  Make more space. 	     */
name|pvPtr
operator|->
name|next
operator|=
name|dst
expr_stmt|;
call|(
modifier|*
name|pvPtr
operator|->
name|expandProc
call|)
argument_list|(
name|pvPtr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dst
operator|=
name|pvPtr
operator|->
name|next
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|src
expr_stmt|;
name|src
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|termChar
condition|)
block|{
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
name|pvPtr
operator|->
name|next
operator|=
name|dst
expr_stmt|;
operator|*
name|termPtr
operator|=
name|src
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
name|CHAR_TYPE
argument_list|(
name|c
argument_list|)
operator|==
name|TCL_NORMAL
condition|)
block|{
name|copy
label|:
operator|*
name|dst
operator|=
name|c
expr_stmt|;
name|dst
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
block|{
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|value
operator|=
name|Tcl_ParseVar
argument_list|(
name|interp
argument_list|,
name|src
operator|-
literal|1
argument_list|,
name|termPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|src
operator|=
operator|*
name|termPtr
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pvPtr
operator|->
name|end
operator|-
name|dst
operator|)
operator|<=
name|length
condition|)
block|{
name|pvPtr
operator|->
name|next
operator|=
name|dst
expr_stmt|;
call|(
modifier|*
name|pvPtr
operator|->
name|expandProc
call|)
argument_list|(
name|pvPtr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|dst
operator|=
name|pvPtr
operator|->
name|next
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|dst
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|length
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'['
condition|)
block|{
name|int
name|result
decl_stmt|;
name|pvPtr
operator|->
name|next
operator|=
name|dst
expr_stmt|;
name|result
operator|=
name|TclParseNestedCmd
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
name|flags
argument_list|,
name|termPtr
argument_list|,
name|pvPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
name|src
operator|=
operator|*
name|termPtr
expr_stmt|;
name|dst
operator|=
name|pvPtr
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|int
name|numRead
decl_stmt|;
name|src
operator|--
expr_stmt|;
operator|*
name|dst
operator|=
name|Tcl_Backslash
argument_list|(
name|src
argument_list|,
operator|&
name|numRead
argument_list|)
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|src
operator|+=
name|numRead
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"missing %c"
argument_list|,
name|termChar
argument_list|)
expr_stmt|;
operator|*
name|termPtr
operator|=
name|string
operator|-
literal|1
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
else|else
block|{
goto|goto
name|copy
goto|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * TclParseNestedCmd --  *  *	This procedure parses a nested Tcl command between  *	brackets, returning the result of the command.  *  * Results:  *	The return value is a standard Tcl result, which is  *	TCL_OK unless there was an error while executing the  *	nested command.  If an error occurs then interp->result  *	contains a standard error message.  *TermPtr is filled  *	in with the address of the character just after the  *	last one processed;  this is usually the character just  *	after the matching close-bracket, or the null character  *	at the end of the string if the close-bracket was missing  *	(a missing close bracket is an error).  The result returned  *	by the command is stored in standard fashion in *pvPtr,  *	null-terminated, with pvPtr->next pointing to the null  *	character.  *  * Side effects:  *	The storage space at *pvPtr may be expanded.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclParseNestedCmd
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|flags
parameter_list|,
name|termPtr
parameter_list|,
name|pvPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for nested command 				 * evaluations and error messages. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Character just after opening bracket. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to pass to nested Tcl_Eval. */
name|char
modifier|*
modifier|*
name|termPtr
decl_stmt|;
comment|/* Store address of terminating character 				 * here. */
specifier|register
name|ParseValue
modifier|*
name|pvPtr
decl_stmt|;
comment|/* Information about where to place 				 * result of command. */
block|{
name|int
name|result
decl_stmt|,
name|length
decl_stmt|,
name|shortfall
decl_stmt|;
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|iPtr
operator|->
name|evalFlags
operator|=
name|flags
operator||
name|TCL_BRACKET_TERM
expr_stmt|;
name|result
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|string
argument_list|)
expr_stmt|;
operator|*
name|termPtr
operator|=
name|iPtr
operator|->
name|termPtr
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
comment|/* 	 * The increment below results in slightly cleaner message in 	 * the errorInfo variable (the close-bracket will appear). 	 */
if|if
condition|(
operator|*
operator|*
name|termPtr
operator|==
literal|']'
condition|)
block|{
operator|*
name|termPtr
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
operator|(
operator|*
name|termPtr
operator|)
operator|+=
literal|1
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|iPtr
operator|->
name|result
argument_list|)
expr_stmt|;
name|shortfall
operator|=
name|length
operator|+
literal|1
operator|-
operator|(
name|pvPtr
operator|->
name|end
operator|-
name|pvPtr
operator|->
name|next
operator|)
expr_stmt|;
if|if
condition|(
name|shortfall
operator|>
literal|0
condition|)
block|{
call|(
modifier|*
name|pvPtr
operator|->
name|expandProc
call|)
argument_list|(
name|pvPtr
argument_list|,
name|shortfall
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|pvPtr
operator|->
name|next
argument_list|,
name|iPtr
operator|->
name|result
argument_list|)
expr_stmt|;
name|pvPtr
operator|->
name|next
operator|+=
name|length
expr_stmt|;
name|Tcl_FreeResult
argument_list|(
name|iPtr
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|result
operator|=
name|iPtr
operator|->
name|resultSpace
expr_stmt|;
name|iPtr
operator|->
name|resultSpace
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * TclParseBraces --  *  *	This procedure scans the information between matching  *	curly braces.  *  * Results:  *	The return value is a standard Tcl result, which is  *	TCL_OK unless there was an error while parsing string.  *	If an error occurs then interp->result contains a  *	standard error message.  *TermPtr is filled  *	in with the address of the character just after the  *	last one successfully processed;  this is usually the  *	character just after the matching close-brace.  The  *	information between curly braces is stored in standard  *	fashion in *pvPtr, null-terminated with pvPtr->next  *	pointing to the terminating null character.  *  * Side effects:  *	The storage space at *pvPtr may be expanded.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclParseBraces
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|termPtr
parameter_list|,
name|pvPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for nested command 				 * evaluations and error messages. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Character just after opening bracket. */
name|char
modifier|*
modifier|*
name|termPtr
decl_stmt|;
comment|/* Store address of terminating character 				 * here. */
specifier|register
name|ParseValue
modifier|*
name|pvPtr
decl_stmt|;
comment|/* Information about where to place 				 * result of command. */
block|{
name|int
name|level
decl_stmt|;
specifier|register
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
modifier|*
name|end
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|src
operator|=
name|string
expr_stmt|;
name|dst
operator|=
name|pvPtr
operator|->
name|next
expr_stmt|;
name|end
operator|=
name|pvPtr
operator|->
name|end
expr_stmt|;
name|level
operator|=
literal|1
expr_stmt|;
comment|/*      * Copy the characters one at a time to the result area, stopping      * when the matching close-brace is found.      */
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
operator|*
name|src
expr_stmt|;
name|src
operator|++
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|end
condition|)
block|{
name|pvPtr
operator|->
name|next
operator|=
name|dst
expr_stmt|;
call|(
modifier|*
name|pvPtr
operator|->
name|expandProc
call|)
argument_list|(
name|pvPtr
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|dst
operator|=
name|pvPtr
operator|->
name|next
expr_stmt|;
name|end
operator|=
name|pvPtr
operator|->
name|end
expr_stmt|;
block|}
operator|*
name|dst
operator|=
name|c
expr_stmt|;
name|dst
operator|++
expr_stmt|;
if|if
condition|(
name|CHAR_TYPE
argument_list|(
name|c
argument_list|)
operator|==
name|TCL_NORMAL
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
block|{
name|level
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
block|{
name|level
operator|--
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
name|dst
operator|--
expr_stmt|;
comment|/* Don't copy the last close brace. */
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|int
name|count
decl_stmt|;
comment|/* 	     * Must always squish out backslash-newlines, even when in 	     * braces.  This is needed so that this sequence can appear 	     * anywhere in a command, such as the middle of an expression. 	     */
if|if
condition|(
operator|*
name|src
operator|==
literal|'\n'
condition|)
block|{
name|dst
index|[
operator|-
literal|1
index|]
operator|=
name|Tcl_Backslash
argument_list|(
name|src
operator|-
literal|1
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
name|src
operator|+=
name|count
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|Tcl_Backslash
argument_list|(
name|src
operator|-
literal|1
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|dst
operator|==
name|end
condition|)
block|{
name|pvPtr
operator|->
name|next
operator|=
name|dst
expr_stmt|;
call|(
modifier|*
name|pvPtr
operator|->
name|expandProc
call|)
argument_list|(
name|pvPtr
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|dst
operator|=
name|pvPtr
operator|->
name|next
expr_stmt|;
name|end
operator|=
name|pvPtr
operator|->
name|end
expr_stmt|;
block|}
operator|*
name|dst
operator|=
operator|*
name|src
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"missing close-brace"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
operator|*
name|termPtr
operator|=
name|string
operator|-
literal|1
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
name|pvPtr
operator|->
name|next
operator|=
name|dst
expr_stmt|;
operator|*
name|termPtr
operator|=
name|src
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * TclParseWords --  *  *	This procedure parses one or more words from a command  *	string and creates argv-style pointers to fully-substituted  *	copies of those words.  *  * Results:  *	The return value is a standard Tcl result.  *	  *	*argcPtr is modified to hold a count of the number of words  *	successfully parsed, which may be 0.  At most maxWords words  *	will be parsed.  If 0<= *argcPtr< maxWords then it  *	means that a command separator was seen.  If *argcPtr  *	is maxWords then it means that a command separator was  *	not seen yet.  *  *	*TermPtr is filled in with the address of the character  *	just after the last one successfully processed in the  *	last word.  This is either the command terminator (if  *	*argcPtr< maxWords), the character just after the last  *	one in a word (if *argcPtr is maxWords), or the vicinity  *	of an error (if the result is not TCL_OK).  *	  *	The pointers at *argv are filled in with pointers to the  *	fully-substituted words, and the actual contents of the  *	words are copied to the buffer at pvPtr.  *  *	If an error occurrs then an error message is left in  *	interp->result and the information at *argv, *argcPtr,  *	and *pvPtr may be incomplete.  *  * Side effects:  *	The buffer space in pvPtr may be enlarged by calling its  *	expandProc.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclParseWords
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|flags
parameter_list|,
name|maxWords
parameter_list|,
name|termPtr
parameter_list|,
name|argcPtr
parameter_list|,
name|argv
parameter_list|,
name|pvPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for nested command 				 * evaluations and error messages. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* First character of word. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control parsing (same values as 				 * passed to Tcl_Eval). */
name|int
name|maxWords
decl_stmt|;
comment|/* Maximum number of words to parse. */
name|char
modifier|*
modifier|*
name|termPtr
decl_stmt|;
comment|/* Store address of terminating character 				 * here. */
name|int
modifier|*
name|argcPtr
decl_stmt|;
comment|/* Filled in with actual number of words 				 * parsed. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Store addresses of individual words here. */
specifier|register
name|ParseValue
modifier|*
name|pvPtr
decl_stmt|;
comment|/* Information about where to place 				 * fully-substituted word. */
block|{
specifier|register
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|int
name|type
decl_stmt|,
name|result
decl_stmt|,
name|argc
decl_stmt|;
name|char
modifier|*
name|oldBuffer
decl_stmt|;
comment|/* Used to detect when pvPtr's buffer gets 				 * reallocated, so we can adjust all of the 				 * argv pointers. */
name|src
operator|=
name|string
expr_stmt|;
name|oldBuffer
operator|=
name|pvPtr
operator|->
name|buffer
expr_stmt|;
name|dst
operator|=
name|pvPtr
operator|->
name|next
expr_stmt|;
for|for
control|(
name|argc
operator|=
literal|0
init|;
name|argc
operator|<
name|maxWords
condition|;
name|argc
operator|++
control|)
block|{
name|argv
index|[
name|argc
index|]
operator|=
name|dst
expr_stmt|;
comment|/* 	 * Skip leading space. 	 */
name|skipSpace
label|:
name|c
operator|=
operator|*
name|src
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|type
operator|==
name|TCL_SPACE
condition|)
block|{
name|src
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|src
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Handle the normal case (i.e. no leading double-quote or brace). 	 */
if|if
condition|(
name|type
operator|==
name|TCL_NORMAL
condition|)
block|{
name|normalArg
label|:
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|dst
operator|==
name|pvPtr
operator|->
name|end
condition|)
block|{
comment|/* 		     * Target buffer space is about to run out.  Make 		     * more space. 		     */
name|pvPtr
operator|->
name|next
operator|=
name|dst
expr_stmt|;
call|(
modifier|*
name|pvPtr
operator|->
name|expandProc
call|)
argument_list|(
name|pvPtr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dst
operator|=
name|pvPtr
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|TCL_NORMAL
condition|)
block|{
name|copy
label|:
operator|*
name|dst
operator|=
name|c
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|src
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TCL_SPACE
condition|)
block|{
goto|goto
name|wordEnd
goto|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TCL_DOLLAR
condition|)
block|{
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|value
operator|=
name|Tcl_ParseVar
argument_list|(
name|interp
argument_list|,
name|src
argument_list|,
name|termPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|src
operator|=
operator|*
name|termPtr
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pvPtr
operator|->
name|end
operator|-
name|dst
operator|)
operator|<=
name|length
condition|)
block|{
name|pvPtr
operator|->
name|next
operator|=
name|dst
expr_stmt|;
call|(
modifier|*
name|pvPtr
operator|->
name|expandProc
call|)
argument_list|(
name|pvPtr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|dst
operator|=
name|pvPtr
operator|->
name|next
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|dst
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TCL_COMMAND_END
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|==
literal|']'
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|TCL_BRACKET_TERM
operator|)
condition|)
block|{
goto|goto
name|copy
goto|;
block|}
comment|/* 		     * End of command;  simulate a word-end first, so 		     * that the end-of-command can be processed as the 		     * first thing in a new word. 		     */
goto|goto
name|wordEnd
goto|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TCL_OPEN_BRACKET
condition|)
block|{
name|pvPtr
operator|->
name|next
operator|=
name|dst
expr_stmt|;
name|result
operator|=
name|TclParseNestedCmd
argument_list|(
name|interp
argument_list|,
name|src
operator|+
literal|1
argument_list|,
name|flags
argument_list|,
name|termPtr
argument_list|,
name|pvPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
name|src
operator|=
operator|*
name|termPtr
expr_stmt|;
name|dst
operator|=
name|pvPtr
operator|->
name|next
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TCL_BACKSLASH
condition|)
block|{
name|int
name|numRead
decl_stmt|;
operator|*
name|dst
operator|=
name|Tcl_Backslash
argument_list|(
name|src
argument_list|,
operator|&
name|numRead
argument_list|)
expr_stmt|;
comment|/* 		     * The following special check allows a backslash-newline 		     * to be treated as a word-separator, as if the backslash 		     * and newline had been collapsed before command parsing 		     * began. 		     */
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|src
operator|+=
name|numRead
expr_stmt|;
goto|goto
name|wordEnd
goto|;
block|}
name|src
operator|+=
name|numRead
expr_stmt|;
name|dst
operator|++
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|copy
goto|;
block|}
name|c
operator|=
operator|*
name|src
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	     * Check for the end of the command. 	     */
if|if
condition|(
name|type
operator|==
name|TCL_COMMAND_END
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TCL_BRACKET_TERM
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"missing close-bracket"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|']'
condition|)
block|{
goto|goto
name|normalArg
goto|;
block|}
block|}
goto|goto
name|done
goto|;
block|}
comment|/* 	     * Now handle the special cases: open braces, double-quotes, 	     * and backslash-newline. 	     */
name|pvPtr
operator|->
name|next
operator|=
name|dst
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TCL_QUOTE
condition|)
block|{
name|result
operator|=
name|TclParseQuotes
argument_list|(
name|interp
argument_list|,
name|src
operator|+
literal|1
argument_list|,
literal|'"'
argument_list|,
name|flags
argument_list|,
name|termPtr
argument_list|,
name|pvPtr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TCL_OPEN_BRACE
condition|)
block|{
name|result
operator|=
name|TclParseBraces
argument_list|(
name|interp
argument_list|,
name|src
operator|+
literal|1
argument_list|,
name|termPtr
argument_list|,
name|pvPtr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|type
operator|==
name|TCL_BACKSLASH
operator|)
operator|&&
operator|(
name|src
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
comment|/* 		 * This code is needed so that a backslash-newline at the 		 * very beginning of a word is treated as part of the white 		 * space between words and not as a space within the word. 		 */
name|src
operator|+=
literal|2
expr_stmt|;
goto|goto
name|skipSpace
goto|;
block|}
else|else
block|{
goto|goto
name|normalArg
goto|;
block|}
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
comment|/* 	     * Back from quotes or braces;  make sure that the terminating 	     * character was the end of the word. 	     */
name|c
operator|=
operator|*
operator|*
name|termPtr
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
operator|(
operator|*
name|termPtr
operator|)
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
comment|/* 		 * Line is continued on next line;  the backslash-newline 		 * sequence turns into space, which is OK.  No need to do 		 * anything here. 		 */
block|}
else|else
block|{
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|!=
name|TCL_SPACE
operator|)
operator|&&
operator|(
name|type
operator|!=
name|TCL_COMMAND_END
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|src
operator|==
literal|'"'
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"extra characters after close-quote"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"extra characters after close-brace"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
block|}
name|src
operator|=
operator|*
name|termPtr
expr_stmt|;
name|dst
operator|=
name|pvPtr
operator|->
name|next
expr_stmt|;
block|}
comment|/* 	 * We're at the end of a word, so add a null terminator.  Then 	 * see if the buffer was re-allocated during this word.  If so, 	 * update all of the argv pointers. 	 */
name|wordEnd
label|:
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
name|dst
operator|++
expr_stmt|;
if|if
condition|(
name|oldBuffer
operator|!=
name|pvPtr
operator|->
name|buffer
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|argv
index|[
name|i
index|]
operator|=
name|pvPtr
operator|->
name|buffer
operator|+
operator|(
name|argv
index|[
name|i
index|]
operator|-
name|oldBuffer
operator|)
expr_stmt|;
block|}
name|oldBuffer
operator|=
name|pvPtr
operator|->
name|buffer
expr_stmt|;
block|}
block|}
name|done
label|:
name|pvPtr
operator|->
name|next
operator|=
name|dst
expr_stmt|;
operator|*
name|termPtr
operator|=
name|src
expr_stmt|;
operator|*
name|argcPtr
operator|=
name|argc
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * TclExpandParseValue --  *  *	This procedure is commonly used as the value of the  *	expandProc in a ParseValue.  It uses malloc to allocate  *	more space for the result of a parse.  *  * Results:  *	The buffer space in *pvPtr is reallocated to something  *	larger, and if pvPtr->clientData is non-zero the old  *	buffer is freed.  Information is copied from the old  *	buffer to the new one.  *  * Side effects:  *	None.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclExpandParseValue
parameter_list|(
name|pvPtr
parameter_list|,
name|needed
parameter_list|)
specifier|register
name|ParseValue
modifier|*
name|pvPtr
decl_stmt|;
comment|/* Information about buffer that 					 * must be expanded.  If the clientData 					 * in the structure is non-zero, it 					 * means that the current buffer is 					 * dynamically allocated. */
name|int
name|needed
decl_stmt|;
comment|/* Minimum amount of additional space 					 * to allocate. */
block|{
name|int
name|newSpace
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
comment|/*      * Either double the size of the buffer or add enough new space      * to meet the demand, whichever produces a larger new buffer.      */
name|newSpace
operator|=
operator|(
name|pvPtr
operator|->
name|end
operator|-
name|pvPtr
operator|->
name|buffer
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|newSpace
operator|<
name|needed
condition|)
block|{
name|newSpace
operator|+=
name|needed
expr_stmt|;
block|}
else|else
block|{
name|newSpace
operator|+=
name|newSpace
expr_stmt|;
block|}
name|new
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|newSpace
argument_list|)
expr_stmt|;
comment|/*      * Copy from old buffer to new, free old buffer if needed, and      * mark new buffer as malloc-ed.      */
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|new
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|pvPtr
operator|->
name|buffer
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|pvPtr
operator|->
name|next
operator|-
name|pvPtr
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|pvPtr
operator|->
name|next
operator|=
name|new
operator|+
operator|(
name|pvPtr
operator|->
name|next
operator|-
name|pvPtr
operator|->
name|buffer
operator|)
expr_stmt|;
if|if
condition|(
name|pvPtr
operator|->
name|clientData
operator|!=
literal|0
condition|)
block|{
name|ckfree
argument_list|(
name|pvPtr
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
name|pvPtr
operator|->
name|buffer
operator|=
name|new
expr_stmt|;
name|pvPtr
operator|->
name|end
operator|=
name|new
operator|+
name|newSpace
operator|-
literal|1
expr_stmt|;
name|pvPtr
operator|->
name|clientData
operator|=
operator|(
name|ClientData
operator|)
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclWordEnd --  *  *	Given a pointer into a Tcl command, find the end of the next  *	word of the command.  *  * Results:  *	The return value is a pointer to the last character that's part  *	of the word pointed to by "start".  If the word doesn't end  *	properly within the string then the return value is the address  *	of the null character at the end of the string.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|TclWordEnd
parameter_list|(
name|start
parameter_list|,
name|nested
parameter_list|,
name|semiPtr
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
comment|/* Beginning of a word of a Tcl command. */
name|int
name|nested
decl_stmt|;
comment|/* Zero means this is a top-level command. 				 * One means this is a nested command (close 				 * bracket is a word terminator). */
name|int
modifier|*
name|semiPtr
decl_stmt|;
comment|/* Set to 1 if word ends with a command- 				 * terminating semi-colon, zero otherwise. 				 * If NULL then ignored. */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|semiPtr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|semiPtr
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * Skip leading white space (backslash-newline must be treated like      * white-space, except that it better not be the last thing in the      * command).      */
for|for
control|(
name|p
operator|=
name|start
init|;
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
return|return
name|p
operator|+
literal|2
return|;
block|}
continue|continue;
block|}
break|break;
block|}
comment|/*      * Handle words beginning with a double-quote or a brace.      */
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
condition|)
block|{
name|p
operator|=
name|QuoteEnd
argument_list|(
name|p
operator|+
literal|1
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
return|return
name|p
return|;
block|}
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'{'
condition|)
block|{
name|int
name|braces
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|braces
operator|!=
literal|0
condition|)
block|{
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
operator|(
name|void
operator|)
name|Tcl_Backslash
argument_list|(
name|p
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
name|p
operator|+=
name|count
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'}'
condition|)
block|{
name|braces
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'{'
condition|)
block|{
name|braces
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
return|return
name|p
return|;
block|}
block|}
name|p
operator|++
expr_stmt|;
block|}
comment|/*      * Handle words that don't start with a brace or double-quote.      * This code is also invoked if the word starts with a brace or      * double-quote and there is garbage after the closing brace or      * quote.  This is an error as far as Tcl_Eval is concerned, but      * for here the garbage is treated as part of the word.      */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'['
condition|)
block|{
name|p
operator|=
name|ScriptEnd
argument_list|(
name|p
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
return|return
name|p
return|;
block|}
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
comment|/* 		 * Backslash-newline:  it maps to a space character 		 * that is a word separator, so the word ends just before 		 * the backslash. 		 */
return|return
name|p
operator|-
literal|1
return|;
block|}
operator|(
name|void
operator|)
name|Tcl_Backslash
argument_list|(
name|p
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
name|p
operator|+=
name|count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
name|p
operator|=
name|VarNameEnd
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
return|return
name|p
return|;
block|}
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|';'
condition|)
block|{
comment|/* 	     * Include the semi-colon in the word that is returned. 	     */
if|if
condition|(
name|semiPtr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|semiPtr
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
elseif|else
if|if
condition|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|p
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|']'
operator|)
operator|&&
name|nested
condition|)
block|{
return|return
name|p
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nested
condition|)
block|{
comment|/* 		 * Nested commands can't end because of the end of the 		 * string. 		 */
return|return
name|p
return|;
block|}
return|return
name|p
operator|-
literal|1
return|;
block|}
else|else
block|{
name|p
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * QuoteEnd --  *  *	Given a pointer to a string that obeys the parsing conventions  *	for quoted things in Tcl, find the end of that quoted thing.  *	The actual thing may be a quoted argument or a parenthesized  *	index name.  *  * Results:  *	The return value is a pointer to the last character that is  *	part of the quoted string (i.e the character that's equal to  *	term).  If the quoted string doesn't terminate properly then  *	the return value is a pointer to the null character at the  *	end of the string.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|QuoteEnd
parameter_list|(
name|string
parameter_list|,
name|term
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Pointer to character just after opening 				 * "quote". */
name|int
name|term
decl_stmt|;
comment|/* This character will terminate the 				 * quoted string (e.g. '"' or ')'). */
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|string
decl_stmt|;
name|int
name|count
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|term
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
operator|(
name|void
operator|)
name|Tcl_Backslash
argument_list|(
name|p
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
name|p
operator|+=
name|count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'['
condition|)
block|{
for|for
control|(
name|p
operator|++
init|;
operator|*
name|p
operator|!=
literal|']'
condition|;
name|p
operator|++
control|)
block|{
name|p
operator|=
name|TclWordEnd
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
return|return
name|p
return|;
block|}
block|}
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
name|p
operator|=
name|VarNameEnd
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
return|return
name|p
return|;
block|}
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
return|return
name|p
return|;
block|}
else|else
block|{
name|p
operator|++
expr_stmt|;
block|}
block|}
return|return
name|p
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * VarNameEnd --  *  *	Given a pointer to a variable reference using $-notation, find  *	the end of the variable name spec.  *  * Results:  *	The return value is a pointer to the last character that  *	is part of the variable name.  If the variable name doesn't  *	terminate properly then the return value is a pointer to the  *	null character at the end of the string.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|VarNameEnd
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Pointer to dollar-sign character. */
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|string
operator|+
literal|1
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'{'
condition|)
block|{
for|for
control|(
name|p
operator|++
init|;
operator|(
operator|*
name|p
operator|!=
literal|'}'
operator|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|0
operator|)
condition|;
name|p
operator|++
control|)
block|{
comment|/* Empty loop body. */
block|}
return|return
name|p
return|;
block|}
while|while
condition|(
name|isalnum
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'_'
operator|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'('
operator|)
operator|&&
operator|(
name|p
operator|!=
name|string
operator|+
literal|1
operator|)
condition|)
block|{
return|return
name|QuoteEnd
argument_list|(
name|p
operator|+
literal|1
argument_list|,
literal|')'
argument_list|)
return|;
block|}
return|return
name|p
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * ScriptEnd --  *  *	Given a pointer to the beginning of a Tcl script, find the end of  *	the script.  *  * Results:  *	The return value is a pointer to the last character that's part  *	of the script pointed to by "p".  If the command doesn't end  *	properly within the string then the return value is the address  *	of the null character at the end of the string.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ScriptEnd
parameter_list|(
name|p
parameter_list|,
name|nested
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Script to check. */
name|int
name|nested
decl_stmt|;
comment|/* Zero means this is a top-level command. 				 * One means this is a nested command (the 				 * last character of the script must be 				 * an unquoted ]). */
block|{
name|int
name|commentOK
init|=
literal|1
decl_stmt|;
name|int
name|length
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
name|commentOK
operator|=
literal|1
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'#'
operator|)
operator|&&
name|commentOK
condition|)
block|{
do|do
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
comment|/* 		     * If the script ends with backslash-newline, then 		     * this command isn't complete. 		     */
if|if
condition|(
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|)
operator|&&
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|p
operator|+
literal|2
return|;
block|}
name|Tcl_Backslash
argument_list|(
name|p
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|p
operator|+=
name|length
expr_stmt|;
block|}
else|else
block|{
name|p
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
operator|*
name|p
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|'\n'
operator|)
condition|)
do|;
continue|continue;
block|}
name|p
operator|=
name|TclWordEnd
argument_list|(
name|p
argument_list|,
name|nested
argument_list|,
operator|&
name|commentOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
return|return
name|p
return|;
block|}
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|nested
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|']'
condition|)
block|{
return|return
name|p
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
return|return
name|p
operator|-
literal|1
return|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ParseVar --  *  *	Given a string starting with a $ sign, parse off a variable  *	name and return its value.  *  * Results:  *	The return value is the contents of the variable given by  *	the leading characters of string.  If termPtr isn't NULL,  *	*termPtr gets filled in with the address of the character  *	just after the last one in the variable specifier.  If the  *	variable doesn't exist, then the return value is NULL and  *	an error message will be left in interp->result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_ParseVar
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|termPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Context for looking up variable. */
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String containing variable name. 					 * First character must be "$". */
name|char
modifier|*
modifier|*
name|termPtr
decl_stmt|;
comment|/* If non-NULL, points to word to fill 					 * in with character just after last 					 * one in the variable specifier. */
block|{
name|char
modifier|*
name|name1
decl_stmt|,
modifier|*
name|name1End
decl_stmt|,
name|c
decl_stmt|,
modifier|*
name|result
decl_stmt|;
specifier|register
name|char
modifier|*
name|name2
decl_stmt|;
define|#
directive|define
name|NUM_CHARS
value|200
name|char
name|copyStorage
index|[
name|NUM_CHARS
index|]
decl_stmt|;
name|ParseValue
name|pv
decl_stmt|;
comment|/*      * There are three cases:      * 1. The $ sign is followed by an open curly brace.  Then the variable      *    name is everything up to the next close curly brace, and the      *    variable is a scalar variable.      * 2. The $ sign is not followed by an open curly brace.  Then the      *    variable name is everything up to the next character that isn't      *    a letter, digit, or underscore.  If the following character is an      *    open parenthesis, then the information between parentheses is      *    the array element name, which can include any of the substitutions      *    permissible between quotes.      * 3. The $ sign is followed by something that isn't a letter, digit,      *    or underscore:  in this case, there is no variable name, and "$"      *    is returned.      */
name|name2
operator|=
name|NULL
expr_stmt|;
name|string
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'{'
condition|)
block|{
name|string
operator|++
expr_stmt|;
name|name1
operator|=
name|string
expr_stmt|;
while|while
condition|(
operator|*
name|string
operator|!=
literal|'}'
condition|)
block|{
if|if
condition|(
operator|*
name|string
operator|==
literal|0
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"missing close-brace for variable name"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|termPtr
operator|!=
literal|0
condition|)
block|{
operator|*
name|termPtr
operator|=
name|string
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
name|string
operator|++
expr_stmt|;
block|}
name|name1End
operator|=
name|string
expr_stmt|;
name|string
operator|++
expr_stmt|;
block|}
else|else
block|{
name|name1
operator|=
name|string
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|string
argument_list|)
argument_list|)
operator|||
operator|(
operator|*
name|string
operator|==
literal|'_'
operator|)
condition|)
block|{
name|string
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|string
operator|==
name|name1
condition|)
block|{
if|if
condition|(
name|termPtr
operator|!=
literal|0
condition|)
block|{
operator|*
name|termPtr
operator|=
name|string
expr_stmt|;
block|}
return|return
literal|"$"
return|;
block|}
name|name1End
operator|=
name|string
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'('
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
comment|/* 	     * Perform substitutions on the array element name, just as 	     * is done for quotes. 	     */
name|pv
operator|.
name|buffer
operator|=
name|pv
operator|.
name|next
operator|=
name|copyStorage
expr_stmt|;
name|pv
operator|.
name|end
operator|=
name|copyStorage
operator|+
name|NUM_CHARS
operator|-
literal|1
expr_stmt|;
name|pv
operator|.
name|expandProc
operator|=
name|TclExpandParseValue
expr_stmt|;
name|pv
operator|.
name|clientData
operator|=
operator|(
name|ClientData
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|TclParseQuotes
argument_list|(
name|interp
argument_list|,
name|string
operator|+
literal|1
argument_list|,
literal|')'
argument_list|,
literal|0
argument_list|,
operator|&
name|end
argument_list|,
operator|&
name|pv
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|char
name|msg
index|[
literal|200
index|]
decl_stmt|;
name|int
name|length
decl_stmt|;
name|length
operator|=
name|string
operator|-
name|name1
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|100
condition|)
block|{
name|length
operator|=
literal|100
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n    (parsing index for array \"%.*s\")"
argument_list|,
name|length
argument_list|,
name|name1
argument_list|)
expr_stmt|;
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|result
operator|=
name|NULL
expr_stmt|;
name|name2
operator|=
name|pv
operator|.
name|buffer
expr_stmt|;
if|if
condition|(
name|termPtr
operator|!=
literal|0
condition|)
block|{
operator|*
name|termPtr
operator|=
name|end
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|string
operator|=
name|end
expr_stmt|;
name|name2
operator|=
name|pv
operator|.
name|buffer
expr_stmt|;
block|}
block|}
if|if
condition|(
name|termPtr
operator|!=
literal|0
condition|)
block|{
operator|*
name|termPtr
operator|=
name|string
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|Interp
operator|*
operator|)
name|interp
operator|)
operator|->
name|noEval
condition|)
block|{
return|return
literal|""
return|;
block|}
name|c
operator|=
operator|*
name|name1End
expr_stmt|;
operator|*
name|name1End
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|Tcl_GetVar2
argument_list|(
name|interp
argument_list|,
name|name1
argument_list|,
name|name2
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
expr_stmt|;
operator|*
name|name1End
operator|=
name|c
expr_stmt|;
name|done
label|:
if|if
condition|(
operator|(
name|name2
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|pv
operator|.
name|buffer
operator|!=
name|copyStorage
operator|)
condition|)
block|{
name|ckfree
argument_list|(
name|pv
operator|.
name|buffer
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CommandComplete --  *  *	Given a partial or complete Tcl command, this procedure  *	determines whether the command is complete in the sense  *	of having matched braces and quotes and brackets.  *  * Results:  *	1 is returned if the command is complete, 0 otherwise.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_CommandComplete
parameter_list|(
name|cmd
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
comment|/* Command to check. */
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|cmd
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
name|p
operator|=
name|ScriptEnd
argument_list|(
name|cmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|p
operator|!=
literal|0
operator|)
return|;
block|}
end_function

end_unit

