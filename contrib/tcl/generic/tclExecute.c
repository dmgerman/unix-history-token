begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclExecute.c --  *  *	This file contains procedures that execute byte-compiled Tcl  *	commands.  *  * Copyright (c) 1996-1997 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclExecute.c 1.102 97/11/06 11:36:35  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclCompile.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NO_FLOAT_H
end_ifdef

begin_include
include|#
directive|include
file|"../compat/float.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<float.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TCL_NO_MATH
end_ifndef

begin_include
include|#
directive|include
file|"tclMath.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The stuff below is a bit of a hack so that this file can be used  * in environments that include no UNIX, i.e. no errno.  Just define  * errno here.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TCL_GENERIC_ONLY
end_ifndef

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NO_ERRNO_H
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_ERRNO_H
end_ifdef

begin_decl_stmt
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|EDOM
value|33
end_define

begin_define
define|#
directive|define
name|ERANGE
value|34
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Boolean flag indicating whether the Tcl bytecode interpreter has been  * initialized.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|execInitialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Variable that controls whether execution tracing is enabled and, if so,  * what level of tracing is desired:  *    0: no execution tracing  *    1: trace invocations of Tcl procs only  *    2: trace invocations of all (not compiled away) commands  *    3: display each instruction executed  * This variable is linked to the Tcl variable "tcl_traceExec".  */
end_comment

begin_decl_stmt
name|int
name|tclTraceExec
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The following global variable is use to signal matherr that Tcl  * is responsible for the arithmetic, so errors can be handled in a  * fashion appropriate for Tcl.  Zero means no Tcl math is in  * progress;  non-zero means Tcl is doing math.  */
end_comment

begin_decl_stmt
name|int
name|tcl_MathInProgress
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The variable below serves no useful purpose except to generate  * a reference to matherr, so that the Tcl version of matherr is  * linked in rather than the system version. Without this reference  * the need for matherr won't be discovered during linking until after  * libtcl.a has been processed, so Tcl's version won't be used.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_MATHERR
end_ifdef

begin_function_decl
specifier|extern
name|int
name|matherr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|tclMatherrPtr
function_decl|)
parameter_list|()
init|=
name|matherr
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Array of instruction names.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|opName
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Mapping from expression instruction opcodes to strings; used for error  * messages. Note that these entries must match the order and number of the  * expression opcodes (e.g., INST_LOR) in tclCompile.h.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|operatorStrings
index|[]
init|=
block|{
literal|"||"
block|,
literal|"&&"
block|,
literal|"|"
block|,
literal|"^"
block|,
literal|"&"
block|,
literal|"=="
block|,
literal|"!="
block|,
literal|"<"
block|,
literal|">"
block|,
literal|"<="
block|,
literal|">="
block|,
literal|"<<"
block|,
literal|">>"
block|,
literal|"+"
block|,
literal|"-"
block|,
literal|"*"
block|,
literal|"/"
block|,
literal|"%"
block|,
literal|"+"
block|,
literal|"-"
block|,
literal|"~"
block|,
literal|"!"
block|,
literal|"BUILTIN FUNCTION"
block|,
literal|"FUNCTION"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Mapping from Tcl result codes to strings; used for error and debugging  * messages.   */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|resultStrings
index|[]
init|=
block|{
literal|"TCL_OK"
block|,
literal|"TCL_ERROR"
block|,
literal|"TCL_RETURN"
block|,
literal|"TCL_BREAK"
block|,
literal|"TCL_CONTINUE"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_COMPILE_DEBUG */
end_comment

begin_comment
comment|/*  * The following are statistics-related variables that record information  * about the bytecode compiler and interpreter's operation. This includes  * an array that records for each instruction how often it is executed.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_COMPILE_STATS
end_ifdef

begin_decl_stmt
specifier|static
name|long
name|numExecutions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|instructionCount
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_COMPILE_STATS */
end_comment

begin_comment
comment|/*  * Macros for testing floating-point values for certain special cases. Test  * for not-a-number by comparing a value against itself; test for infinity  * by comparing against the largest floating-point value.  */
end_comment

begin_define
define|#
directive|define
name|IS_NAN
parameter_list|(
name|v
parameter_list|)
value|((v) != (v))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DBL_MAX
end_ifdef

begin_define
define|#
directive|define
name|IS_INF
parameter_list|(
name|v
parameter_list|)
value|(((v)> DBL_MAX) || ((v)< -DBL_MAX))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|IS_INF
parameter_list|(
name|v
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Macro to adjust the program counter and restart the instruction execution  * loop after each instruction is executed.  */
end_comment

begin_define
define|#
directive|define
name|ADJUST_PC
parameter_list|(
name|instBytes
parameter_list|)
define|\
value|pc += instBytes;  continue
end_define

begin_comment
comment|/*  * Macros used to cache often-referenced Tcl evaluation stack information  * in local variables. Note that a DECACHE_STACK_INFO()-CACHE_STACK_INFO()  * pair must surround any call inside TclExecuteByteCode (and a few other  * procedures that use this scheme) that could result in a recursive call  * to TclExecuteByteCode.  */
end_comment

begin_define
define|#
directive|define
name|CACHE_STACK_INFO
parameter_list|()
define|\
value|stackPtr = eePtr->stackPtr; \     stackTop = eePtr->stackTop
end_define

begin_define
define|#
directive|define
name|DECACHE_STACK_INFO
parameter_list|()
define|\
value|eePtr->stackTop = stackTop
end_define

begin_comment
comment|/*  * Macros used to access items on the Tcl evaluation stack. PUSH_OBJECT  * increments the object's ref count since it makes the stack have another  * reference pointing to the object. However, POP_OBJECT does not decrement  * the ref count. This is because the stack may hold the only reference to  * the object, so the object would be destroyed if its ref count were  * decremented before the caller had a chance to, e.g., store it in a  * variable. It is the caller's responsibility to decrement the ref count  * when it is finished with an object.  */
end_comment

begin_define
define|#
directive|define
name|STK_ITEM
parameter_list|(
name|offset
parameter_list|)
value|(stackPtr[stackTop + (offset)])
end_define

begin_define
define|#
directive|define
name|STK_OBJECT
parameter_list|(
name|offset
parameter_list|)
value|(STK_ITEM(offset).o)
end_define

begin_define
define|#
directive|define
name|STK_INT
parameter_list|(
name|offset
parameter_list|)
value|(STK_ITEM(offset).i)
end_define

begin_define
define|#
directive|define
name|STK_POINTER
parameter_list|(
name|offset
parameter_list|)
value|(STK_ITEM(offset).p)
end_define

begin_comment
comment|/*  * WARNING! It is essential that objPtr only appear once in the PUSH_OBJECT  * macro. The actual parameter might be an expression with side effects,  * and this ensures that it will be executed only once.   */
end_comment

begin_define
define|#
directive|define
name|PUSH_OBJECT
parameter_list|(
name|objPtr
parameter_list|)
define|\
value|Tcl_IncrRefCount(stackPtr[++stackTop].o = (objPtr))
end_define

begin_define
define|#
directive|define
name|POP_OBJECT
parameter_list|()
define|\
value|(stackPtr[stackTop--].o)
end_define

begin_comment
comment|/*  * Macros used to trace instruction execution. The macros TRACE,  * TRACE_WITH_OBJ, and O2S are only used inside TclExecuteByteCode.  * O2S is only used in TRACE* calls to get a string from an object.  *   * NOTE THAT CLIENTS OF O2S ARE LIKELY TO FAIL IF THE OBJECT'S  * STRING REP CONTAINS NULLS.   */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|O2S
parameter_list|(
name|objPtr
parameter_list|)
define|\
value|Tcl_GetStringFromObj((objPtr),&length)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_COMPILE_STATS
end_ifdef

begin_define
define|#
directive|define
name|TRACE
parameter_list|(
name|a
parameter_list|)
define|\
value|if (traceInstructions) { \         fprintf(stdout, "%d: %d,%ld (%u) ", iPtr->numLevels, \ 	       stackTop, (tclObjsAlloced - tclObjsFreed), \ 	       (unsigned int)(pc - codePtr->codeStart)); \ 	printf a; \         fflush(stdout); \     }
end_define

begin_define
define|#
directive|define
name|TRACE_WITH_OBJ
parameter_list|(
name|a
parameter_list|,
name|objPtr
parameter_list|)
define|\
value|if (traceInstructions) { \         fprintf(stdout, "%d: %d,%ld (%u) ", iPtr->numLevels, \ 	       stackTop, (tclObjsAlloced - tclObjsFreed), \ 	       (unsigned int)(pc - codePtr->codeStart)); \ 	printf a; \ 	bytes = Tcl_GetStringFromObj((objPtr),&length); \         TclPrintSource(stdout, bytes, TclMin(length, 30)); \         fprintf(stdout, "\n"); \         fflush(stdout); \     }
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not TCL_COMPILE_STATS */
end_comment

begin_define
define|#
directive|define
name|TRACE
parameter_list|(
name|a
parameter_list|)
define|\
value|if (traceInstructions) { \         fprintf(stdout, "%d: %d (%u) ", iPtr->numLevels, stackTop, \ 	       (unsigned int)(pc - codePtr->codeStart)); \ 	printf a; \         fflush(stdout); \     }
end_define

begin_define
define|#
directive|define
name|TRACE_WITH_OBJ
parameter_list|(
name|a
parameter_list|,
name|objPtr
parameter_list|)
define|\
value|if (traceInstructions) { \         fprintf(stdout, "%d: %d (%u) ", iPtr->numLevels, stackTop, \ 	       (unsigned int)(pc - codePtr->codeStart)); \ 	printf a; \ 	bytes = Tcl_GetStringFromObj((objPtr),&length); \         TclPrintSource(stdout, bytes, TclMin(length, 30)); \         fprintf(stdout, "\n"); \         fflush(stdout); \     }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_COMPILE_STATS */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not TCL_COMPILE_DEBUG */
end_comment

begin_define
define|#
directive|define
name|TRACE
parameter_list|(
name|a
parameter_list|)
end_define

begin_define
define|#
directive|define
name|TRACE_WITH_OBJ
parameter_list|(
name|a
parameter_list|,
name|objPtr
parameter_list|)
end_define

begin_define
define|#
directive|define
name|O2S
parameter_list|(
name|objPtr
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_COMPILE_DEBUG */
end_comment

begin_comment
comment|/*  * Declarations for local procedures to this file:  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|CallTraceProcedure
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Trace
operator|*
name|tracePtr
operator|,
name|Command
operator|*
name|cmdPtr
operator|,
name|char
operator|*
name|command
operator|,
name|int
name|numChars
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DupCmdNameInternalRep
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Obj
operator|*
name|objPtr
operator|,
name|Tcl_Obj
operator|*
name|copyPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ExprAbsFunc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExecEnv
operator|*
name|eePtr
operator|,
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ExprBinaryFunc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExecEnv
operator|*
name|eePtr
operator|,
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ExprCallMathFunc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExecEnv
operator|*
name|eePtr
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
operator|*
name|objv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ExprDoubleFunc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExecEnv
operator|*
name|eePtr
operator|,
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ExprIntFunc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExecEnv
operator|*
name|eePtr
operator|,
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ExprRandFunc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExecEnv
operator|*
name|eePtr
operator|,
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ExprRoundFunc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExecEnv
operator|*
name|eePtr
operator|,
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ExprSrandFunc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExecEnv
operator|*
name|eePtr
operator|,
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ExprUnaryFunc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExecEnv
operator|*
name|eePtr
operator|,
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_COMPILE_STATS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|EvalStatsCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_COMPILE_STATS */
end_comment

begin_decl_stmt
specifier|static
name|void
name|FreeCmdNameInternalRep
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Obj
operator|*
name|objPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|GetSrcInfoForPc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|unsigned
name|char
operator|*
name|pc
operator|,
name|ByteCode
operator|*
name|codePtr
operator|,
name|int
operator|*
name|lengthPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|GrowEvaluationStack
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ExecEnv
operator|*
name|eePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|IllegalExprOperandType
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|unsigned
name|int
name|opCode
operator|,
name|Tcl_Obj
operator|*
name|opndPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|InitByteCodeExecution
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|PrintByteCodeInfo
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ByteCode
operator|*
name|codePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|RecordTracebackInfo
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|unsigned
name|char
operator|*
name|pc
operator|,
name|ByteCode
operator|*
name|codePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SetCmdNameFromAny
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Obj
operator|*
name|objPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|StringForResultCode
name|_ANSI_ARGS_
argument_list|(
operator|(
name|int
name|result
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_COMPILE_DEBUG */
end_comment

begin_decl_stmt
specifier|static
name|void
name|UpdateStringOfCmdName
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Obj
operator|*
name|objPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|ValidatePcAndStackTop
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ByteCode
operator|*
name|codePtr
operator|,
name|unsigned
name|char
operator|*
name|pc
operator|,
name|int
name|stackTop
operator|,
name|int
name|stackLowerBound
operator|,
name|int
name|stackUpperBound
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_COMPILE_DEBUG */
end_comment

begin_comment
comment|/*  * Table describing the built-in math functions. Entries in this table are  * indexed by the values of the INST_CALL_BUILTIN_FUNC instruction's  * operand byte.  */
end_comment

begin_decl_stmt
name|BuiltinFunc
name|builtinFuncTable
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|TCL_NO_MATH
block|{
literal|"acos"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|acos
block|}
block|,
block|{
literal|"asin"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|asin
block|}
block|,
block|{
literal|"atan"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|atan
block|}
block|,
block|{
literal|"atan2"
block|,
literal|2
block|,
block|{
name|TCL_DOUBLE
block|,
name|TCL_DOUBLE
block|}
block|,
name|ExprBinaryFunc
block|,
operator|(
name|ClientData
operator|)
name|atan2
block|}
block|,
block|{
literal|"ceil"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|ceil
block|}
block|,
block|{
literal|"cos"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|cos
block|}
block|,
block|{
literal|"cosh"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|cosh
block|}
block|,
block|{
literal|"exp"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|exp
block|}
block|,
block|{
literal|"floor"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|floor
block|}
block|,
block|{
literal|"fmod"
block|,
literal|2
block|,
block|{
name|TCL_DOUBLE
block|,
name|TCL_DOUBLE
block|}
block|,
name|ExprBinaryFunc
block|,
operator|(
name|ClientData
operator|)
name|fmod
block|}
block|,
block|{
literal|"hypot"
block|,
literal|2
block|,
block|{
name|TCL_DOUBLE
block|,
name|TCL_DOUBLE
block|}
block|,
name|ExprBinaryFunc
block|,
operator|(
name|ClientData
operator|)
name|hypot
block|}
block|,
block|{
literal|"log"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|log
block|}
block|,
block|{
literal|"log10"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|log10
block|}
block|,
block|{
literal|"pow"
block|,
literal|2
block|,
block|{
name|TCL_DOUBLE
block|,
name|TCL_DOUBLE
block|}
block|,
name|ExprBinaryFunc
block|,
operator|(
name|ClientData
operator|)
name|pow
block|}
block|,
block|{
literal|"sin"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|sin
block|}
block|,
block|{
literal|"sinh"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|sinh
block|}
block|,
block|{
literal|"sqrt"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|sqrt
block|}
block|,
block|{
literal|"tan"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|tan
block|}
block|,
block|{
literal|"tanh"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|tanh
block|}
block|,
endif|#
directive|endif
block|{
literal|"abs"
block|,
literal|1
block|,
block|{
name|TCL_EITHER
block|}
block|,
name|ExprAbsFunc
block|,
literal|0
block|}
block|,
block|{
literal|"double"
block|,
literal|1
block|,
block|{
name|TCL_EITHER
block|}
block|,
name|ExprDoubleFunc
block|,
literal|0
block|}
block|,
block|{
literal|"int"
block|,
literal|1
block|,
block|{
name|TCL_EITHER
block|}
block|,
name|ExprIntFunc
block|,
literal|0
block|}
block|,
block|{
literal|"rand"
block|,
literal|0
block|,
block|{
name|TCL_EITHER
block|}
block|,
name|ExprRandFunc
block|,
literal|0
block|}
block|,
comment|/* NOTE: rand takes no args. */
block|{
literal|"round"
block|,
literal|1
block|,
block|{
name|TCL_EITHER
block|}
block|,
name|ExprRoundFunc
block|,
literal|0
block|}
block|,
block|{
literal|"srand"
block|,
literal|1
block|,
block|{
name|TCL_INT
block|}
block|,
name|ExprSrandFunc
block|,
literal|0
block|}
block|,
block|{
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The structure below defines the command name Tcl object type by means of  * procedures that can be invoked by generic object code. Objects of this  * type cache the Command pointer that results from looking up command names  * in the command hashtable. Such objects appear as the zeroth ("command  * name") argument in a Tcl command.  */
end_comment

begin_decl_stmt
name|Tcl_ObjType
name|tclCmdNameType
init|=
block|{
literal|"cmdName"
block|,
comment|/* name */
name|FreeCmdNameInternalRep
block|,
comment|/* freeIntRepProc */
name|DupCmdNameInternalRep
block|,
comment|/* dupIntRepProc */
name|UpdateStringOfCmdName
block|,
comment|/* updateStringProc */
name|SetCmdNameFromAny
comment|/* setFromAnyProc */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InitByteCodeExecution --  *  *	This procedure is called once to initialize the Tcl bytecode  *	interpreter.  *  * Results:  *	None.  *  * Side effects:  *	This procedure initializes the array of instruction names. If  *	compiling with the TCL_COMPILE_STATS flag, it initializes the  *	array that counts the executions of each instruction and it  *	creates the "evalstats" command. It also registers the command name  *	Tcl_ObjType. It also establishes the link between the Tcl  *	"tcl_traceExec" and C "tclTraceExec" variables.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|InitByteCodeExecution
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter for which the Tcl variable 				 * "tcl_traceExec" is linked to control 				 * instruction tracing. */
block|{
name|int
name|i
decl_stmt|;
name|Tcl_RegisterObjType
argument_list|(
operator|&
name|tclCmdNameType
argument_list|)
expr_stmt|;
operator|(
name|VOID
operator|*
operator|)
name|memset
argument_list|(
name|opName
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opName
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|instructionTable
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|opName
index|[
name|i
index|]
operator|=
name|instructionTable
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TCL_COMPILE_STATS
operator|(
name|VOID
operator|*
operator|)
name|memset
argument_list|(
name|instructionCount
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|instructionCount
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|VOID
operator|*
operator|)
name|memset
argument_list|(
name|tclByteCodeCount
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tclByteCodeCount
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|VOID
operator|*
operator|)
name|memset
argument_list|(
name|tclSourceCount
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tclSourceCount
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"evalstats"
argument_list|,
name|EvalStatsCmd
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TCL_COMPILE_STATS */
if|if
condition|(
name|Tcl_LinkVar
argument_list|(
name|interp
argument_list|,
literal|"tcl_traceExec"
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tclTraceExec
argument_list|,
name|TCL_LINK_INT
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|panic
argument_list|(
literal|"InitByteCodeExecution: can't create link for tcl_traceExec variable"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCreateExecEnv --  *  *	This procedure creates a new execution environment for Tcl bytecode  *	execution. An ExecEnv points to a Tcl evaluation stack. An ExecEnv  *	is typically created once for each Tcl interpreter (Interp  *	structure) and recursively passed to TclExecuteByteCode to execute  *	ByteCode sequences for nested commands.  *  * Results:  *	A newly allocated ExecEnv is returned. This points to an empty  *	evaluation stack of the standard initial size.  *  * Side effects:  *	The bytecode interpreter is also initialized here, as this  *	procedure will be called before any call to TclExecuteByteCode.  *  *----------------------------------------------------------------------  */
end_comment

begin_define
define|#
directive|define
name|TCL_STACK_INITIAL_SIZE
value|2000
end_define

begin_function
name|ExecEnv
modifier|*
name|TclCreateExecEnv
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter for which the execution 				 * environment is being created. */
block|{
name|ExecEnv
modifier|*
name|eePtr
init|=
operator|(
name|ExecEnv
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ExecEnv
argument_list|)
argument_list|)
decl_stmt|;
name|eePtr
operator|->
name|stackPtr
operator|=
operator|(
name|StackItem
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|TCL_STACK_INITIAL_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|StackItem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|eePtr
operator|->
name|stackTop
operator|=
operator|-
literal|1
expr_stmt|;
name|eePtr
operator|->
name|stackEnd
operator|=
operator|(
name|TCL_STACK_INITIAL_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|execInitialized
condition|)
block|{
name|InitByteCodeExecution
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|execInitialized
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|eePtr
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|TCL_STACK_INITIAL_SIZE
end_undef

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclDeleteExecEnv --  *  *	Frees the storage for an ExecEnv.  *  * Results:  *	None.  *  * Side effects:  *	Storage for an ExecEnv and its contained storage (e.g. the  *	evaluation stack) is freed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclDeleteExecEnv
parameter_list|(
name|eePtr
parameter_list|)
name|ExecEnv
modifier|*
name|eePtr
decl_stmt|;
comment|/* Execution environment to free. */
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|eePtr
operator|->
name|stackPtr
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|eePtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclFinalizeExecEnv --  *  *	Finalizes the execution environment setup so that it can be  *	later reinitialized.  *  * Results:  *	None.  *  * Side effects:  *	After this call, the next time TclCreateExecEnv will be called  *	it will call InitByteCodeExecution.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclFinalizeExecEnv
parameter_list|()
block|{
name|execInitialized
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * GrowEvaluationStack --  *  *	This procedure grows a Tcl evaluation stack stored in an ExecEnv.  *  * Results:  *	None.  *  * Side effects:  *	The size of the evaluation stack is doubled.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|GrowEvaluationStack
parameter_list|(
name|eePtr
parameter_list|)
specifier|register
name|ExecEnv
modifier|*
name|eePtr
decl_stmt|;
comment|/* Points to the ExecEnv with an evaluation 			      * stack to enlarge. */
block|{
comment|/*      * The current Tcl stack elements are stored from eePtr->stackPtr[0]      * to eePtr->stackPtr[eePtr->stackEnd] (inclusive).      */
name|int
name|currElems
init|=
operator|(
name|eePtr
operator|->
name|stackEnd
operator|+
literal|1
operator|)
decl_stmt|;
name|int
name|newElems
init|=
literal|2
operator|*
name|currElems
decl_stmt|;
name|int
name|currBytes
init|=
name|currElems
operator|*
sizeof|sizeof
argument_list|(
name|StackItem
argument_list|)
decl_stmt|;
name|int
name|newBytes
init|=
literal|2
operator|*
name|currBytes
decl_stmt|;
name|StackItem
modifier|*
name|newStackPtr
init|=
operator|(
name|StackItem
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|newBytes
argument_list|)
decl_stmt|;
comment|/*      * Copy the existing stack items to the new stack space, free the old      * storage if appropriate, and mark new space as malloc'ed.      */
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|newStackPtr
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|eePtr
operator|->
name|stackPtr
argument_list|,
operator|(
name|size_t
operator|)
name|currBytes
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|eePtr
operator|->
name|stackPtr
argument_list|)
expr_stmt|;
name|eePtr
operator|->
name|stackPtr
operator|=
name|newStackPtr
expr_stmt|;
name|eePtr
operator|->
name|stackEnd
operator|=
operator|(
name|newElems
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* i.e. index of last usable item */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclExecuteByteCode --  *  *	This procedure executes the instructions of a ByteCode structure.  *	It returns when a "done" instruction is executed or an error occurs.  *  * Results:  *	The return value is one of the return codes defined in tcl.h  *	(such as TCL_OK), and interp->objResultPtr refers to a Tcl object  *	that either contains the result of executing the code or an  *	error message.  *  * Side effects:  *	Almost certainly, depending on the ByteCode's instructions.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclExecuteByteCode
parameter_list|(
name|interp
parameter_list|,
name|codePtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Token for command interpreter. */
name|ByteCode
modifier|*
name|codePtr
decl_stmt|;
comment|/* The bytecode sequence to interpret. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|ExecEnv
modifier|*
name|eePtr
init|=
name|iPtr
operator|->
name|execEnvPtr
decl_stmt|;
comment|/* Points to the execution environment. */
specifier|register
name|StackItem
modifier|*
name|stackPtr
init|=
name|eePtr
operator|->
name|stackPtr
decl_stmt|;
comment|/* Cached evaluation stack base pointer. */
specifier|register
name|int
name|stackTop
init|=
name|eePtr
operator|->
name|stackTop
decl_stmt|;
comment|/* Cached top index of evaluation stack. */
name|Tcl_Obj
modifier|*
modifier|*
name|objArrayPtr
init|=
name|codePtr
operator|->
name|objArrayPtr
decl_stmt|;
comment|/* Points to the ByteCode's object array. */
name|unsigned
name|char
modifier|*
name|pc
init|=
name|codePtr
operator|->
name|codeStart
decl_stmt|;
comment|/* The current program counter. */
name|unsigned
name|char
name|opCode
decl_stmt|;
comment|/* The current instruction code. */
name|int
name|opnd
decl_stmt|;
comment|/* Current instruction's operand byte. */
name|int
name|pcAdjustment
decl_stmt|;
comment|/* Hold pc adjustment after instruction. */
name|int
name|initStackTop
init|=
name|stackTop
decl_stmt|;
comment|/* Stack top at start of execution. */
name|ExceptionRange
modifier|*
name|rangePtr
decl_stmt|;
comment|/* Points to closest loop or catch exception 				 * range enclosing the pc. Used by various 				 * instructions and processCatch to 				 * process break, continue, and errors. */
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
comment|/* Return code returned after execution. */
name|int
name|traceInstructions
init|=
operator|(
name|tclTraceExec
operator|==
literal|3
operator|)
decl_stmt|;
name|Tcl_Obj
modifier|*
name|valuePtr
decl_stmt|,
modifier|*
name|value2Ptr
decl_stmt|,
modifier|*
name|namePtr
decl_stmt|,
modifier|*
name|objPtr
decl_stmt|;
name|char
modifier|*
name|bytes
decl_stmt|;
name|int
name|length
decl_stmt|;
name|long
name|i
decl_stmt|;
name|Tcl_DString
name|command
decl_stmt|;
comment|/* Used for debugging. If tclTraceExec>= 2 				 * holds a string representing the last 				 * command invoked. */
comment|/*      * This procedure uses a stack to hold information about catch commands.      * This information is the current operand stack top when starting to      * execute the code for each catch command. It starts out with stack-      * allocated space but uses dynamically-allocated storage if needed.      */
define|#
directive|define
name|STATIC_CATCH_STACK_SIZE
value|5
name|int
argument_list|(
name|catchStackStorage
index|[
name|STATIC_CATCH_STACK_SIZE
index|]
argument_list|)
expr_stmt|;
name|int
modifier|*
name|catchStackPtr
init|=
name|catchStackStorage
decl_stmt|;
name|int
name|catchTop
init|=
operator|-
literal|1
decl_stmt|;
comment|/*      * THIS PROC FAILS IF AN OBJECT'S STRING REP HAS A NULL BYTE.      */
if|if
condition|(
name|tclTraceExec
operator|>=
literal|2
condition|)
block|{
name|PrintByteCodeInfo
argument_list|(
name|codePtr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCL_COMPILE_STATS
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"  Starting stack top=%d, system objects=%ld\n"
argument_list|,
name|eePtr
operator|->
name|stackTop
argument_list|,
operator|(
name|tclObjsAlloced
operator|-
name|tclObjsFreed
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"  Starting stack top=%d\n"
argument_list|,
name|eePtr
operator|->
name|stackTop
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TCL_COMPILE_STATS */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TCL_COMPILE_STATS
name|numExecutions
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* TCL_COMPILE_STATS */
comment|/*      * Make sure the catch stack is large enough to hold the maximum number      * of catch commands that could ever be executing at the same time. This      * will be no more than the exception range array's depth.      */
if|if
condition|(
name|codePtr
operator|->
name|maxExcRangeDepth
operator|>
name|STATIC_CATCH_STACK_SIZE
condition|)
block|{
name|catchStackPtr
operator|=
operator|(
name|int
operator|*
operator|)
name|ckalloc
argument_list|(
name|codePtr
operator|->
name|maxExcRangeDepth
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*      * Make sure the stack has enough room to execute this ByteCode.      */
while|while
condition|(
operator|(
name|stackTop
operator|+
name|codePtr
operator|->
name|maxStackDepth
operator|)
operator|>
name|eePtr
operator|->
name|stackEnd
condition|)
block|{
name|GrowEvaluationStack
argument_list|(
name|eePtr
argument_list|)
expr_stmt|;
name|stackPtr
operator|=
name|eePtr
operator|->
name|stackPtr
expr_stmt|;
block|}
comment|/*      * Initialize the buffer that holds a string containing the name and      * arguments for the last invoked command.      */
name|Tcl_DStringInit
argument_list|(
operator|&
name|command
argument_list|)
expr_stmt|;
comment|/*      * Loop executing instructions until a "done" instruction, a TCL_RETURN,      * or some error.      */
for|for
control|(
init|;
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
name|ValidatePcAndStackTop
argument_list|(
name|codePtr
argument_list|,
name|pc
argument_list|,
name|stackTop
argument_list|,
name|initStackTop
argument_list|,
name|eePtr
operator|->
name|stackEnd
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not TCL_COMPILE_DEBUG */
if|if
condition|(
name|traceInstructions
condition|)
block|{
ifdef|#
directive|ifdef
name|TCL_COMPILE_STATS
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d: %d,%ld "
argument_list|,
name|iPtr
operator|->
name|numLevels
argument_list|,
name|stackTop
argument_list|,
operator|(
name|tclObjsAlloced
operator|-
name|tclObjsFreed
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* TCL_COMPILE_STATS */
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d: %d "
argument_list|,
name|iPtr
operator|->
name|numLevels
argument_list|,
name|stackTop
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TCL_COMPILE_STATS */
name|TclPrintInstruction
argument_list|(
name|codePtr
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TCL_COMPILE_DEBUG */
name|opCode
operator|=
operator|*
name|pc
expr_stmt|;
ifdef|#
directive|ifdef
name|TCL_COMPILE_STATS
name|instructionCount
index|[
name|opCode
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* TCL_COMPILE_STATS */
switch|switch
condition|(
name|opCode
condition|)
block|{
case|case
name|INST_DONE
case|:
comment|/* 	     * Pop the topmost object from the stack, set the interpreter's 	     * object result to point to it, and return. 	     */
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|stackTop
operator|!=
name|initStackTop
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nTclExecuteByteCode: done instruction at pc %u: stack top %d != entry stack top %d\n"
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|pc
operator|-
name|codePtr
operator|->
name|codeStart
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|stackTop
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|initStackTop
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Source: "
argument_list|)
expr_stmt|;
name|TclPrintSource
argument_list|(
name|stderr
argument_list|,
name|codePtr
operator|->
name|source
argument_list|,
literal|150
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"TclExecuteByteCode execution failure: end stack top != start stack top"
argument_list|)
expr_stmt|;
block|}
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"done => return code=%d, result is "
operator|,
name|result
operator|)
argument_list|,
name|iPtr
operator|->
name|objResultPtr
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|INST_PUSH1
case|:
name|valuePtr
operator|=
name|objArrayPtr
index|[
name|TclGetUInt1AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
index|]
expr_stmt|;
name|PUSH_OBJECT
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"push1 %u => "
operator|,
name|TclGetUInt1AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
operator|)
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
literal|2
argument_list|)
expr_stmt|;
case|case
name|INST_PUSH4
case|:
name|valuePtr
operator|=
name|objArrayPtr
index|[
name|TclGetUInt4AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
index|]
expr_stmt|;
name|PUSH_OBJECT
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"push4 %u => "
operator|,
name|TclGetUInt4AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
operator|)
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
literal|5
argument_list|)
expr_stmt|;
case|case
name|INST_POP
case|:
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"pop => discarding "
operator|)
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
comment|/* finished with pop'ed object. */
name|ADJUST_PC
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|INST_DUP
case|:
name|valuePtr
operator|=
name|stackPtr
index|[
name|stackTop
index|]
operator|.
name|o
expr_stmt|;
name|PUSH_OBJECT
argument_list|(
name|Tcl_DuplicateObj
argument_list|(
name|valuePtr
argument_list|)
argument_list|)
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"dup => "
operator|)
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|INST_CONCAT1
case|:
name|opnd
operator|=
name|TclGetUInt1AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
expr_stmt|;
block|{
name|Tcl_Obj
modifier|*
name|concatObjPtr
decl_stmt|;
name|int
name|totalLen
init|=
literal|0
decl_stmt|;
comment|/* 		 * Concatenate strings (with no separators) from the top 		 * opnd items on the stack starting with the deepest item. 		 * First, determine how many characters are needed. 		 */
for|for
control|(
name|i
operator|=
operator|(
name|stackTop
operator|-
operator|(
name|opnd
operator|-
literal|1
operator|)
operator|)
init|;
name|i
operator|<=
name|stackTop
condition|;
name|i
operator|++
control|)
block|{
name|valuePtr
operator|=
name|stackPtr
index|[
name|i
index|]
operator|.
name|o
expr_stmt|;
name|bytes
operator|=
name|TclGetStringFromObj
argument_list|(
name|valuePtr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|!=
name|NULL
condition|)
block|{
name|totalLen
operator|+=
name|length
expr_stmt|;
block|}
block|}
comment|/* 		 * Initialize the new append string object by appending the 		 * strings of the opnd stack objects. Also pop the objects.  		 */
name|TclNewObj
argument_list|(
name|concatObjPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|totalLen
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|totalLen
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|concatObjPtr
operator|->
name|bytes
operator|=
name|p
expr_stmt|;
name|concatObjPtr
operator|->
name|length
operator|=
name|totalLen
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|stackTop
operator|-
operator|(
name|opnd
operator|-
literal|1
operator|)
operator|)
init|;
name|i
operator|<=
name|stackTop
condition|;
name|i
operator|++
control|)
block|{
name|valuePtr
operator|=
name|stackPtr
index|[
name|i
index|]
operator|.
name|o
expr_stmt|;
name|bytes
operator|=
name|TclGetStringFromObj
argument_list|(
name|valuePtr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|p
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|bytes
argument_list|,
operator|(
name|size_t
operator|)
name|length
argument_list|)
expr_stmt|;
name|p
operator|+=
name|length
expr_stmt|;
block|}
name|TclDecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
operator|(
name|stackTop
operator|-
operator|(
name|opnd
operator|-
literal|1
operator|)
operator|)
init|;
name|i
operator|<=
name|stackTop
condition|;
name|i
operator|++
control|)
block|{
name|valuePtr
operator|=
name|stackPtr
index|[
name|i
index|]
operator|.
name|o
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
block|}
block|}
name|stackTop
operator|-=
name|opnd
expr_stmt|;
name|PUSH_OBJECT
argument_list|(
name|concatObjPtr
argument_list|)
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"concat %u => "
operator|,
name|opnd
operator|)
argument_list|,
name|concatObjPtr
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
case|case
name|INST_INVOKE_STK4
case|:
name|opnd
operator|=
name|TclGetUInt4AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pcAdjustment
operator|=
literal|5
expr_stmt|;
goto|goto
name|doInvocation
goto|;
case|case
name|INST_INVOKE_STK1
case|:
name|opnd
operator|=
name|TclGetUInt1AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pcAdjustment
operator|=
literal|2
expr_stmt|;
name|doInvocation
label|:
block|{
name|char
modifier|*
name|cmdName
decl_stmt|;
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
comment|/* Points to command's Command struct. */
name|int
name|objc
init|=
name|opnd
decl_stmt|;
comment|/* The number of arguments. */
name|Tcl_Obj
modifier|*
modifier|*
name|objv
decl_stmt|;
comment|/* The array of argument objects. */
name|Tcl_Obj
modifier|*
name|objv0Ptr
decl_stmt|;
comment|/* Holds objv[0], the command name. */
name|int
name|newPcOffset
init|=
literal|0
decl_stmt|;
comment|/* Instruction offset computed during 				    * break, continue, error processing. 				    * Init. to avoid compiler warning. */
name|Tcl_Command
name|cmd
decl_stmt|;
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
name|int
name|isUnknownCmd
init|=
literal|0
decl_stmt|;
name|char
name|cmdNameBuf
index|[
literal|30
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* TCL_COMPILE_DEBUG */
comment|/* 		 * If the interpreter was deleted, return an error. 		 */
if|if
condition|(
name|iPtr
operator|->
name|flags
operator|&
name|DELETED
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"attempt to call eval in deleted interpreter"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"CORE"
argument_list|,
literal|"IDELETE"
argument_list|,
literal|"attempt to call eval in deleted interpreter"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
name|objv
operator|=
operator|&
operator|(
name|stackPtr
index|[
name|stackTop
operator|-
operator|(
name|objc
operator|-
literal|1
operator|)
index|]
operator|.
name|o
operator|)
expr_stmt|;
name|objv0Ptr
operator|=
name|objv
index|[
literal|0
index|]
expr_stmt|;
name|cmdName
operator|=
name|TclGetStringFromObj
argument_list|(
name|objv0Ptr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * Find the procedure to execute this command. If there 		 * isn't one, then see if there is a command "unknown". If 		 * so, invoke it, passing it the original command words as 		 * arguments. 		 * 		 * We convert the objv[0] object to be a CmdName object. 		 * This caches a pointer to the Command structure for the 		 * command; this pointer is held in a ResolvedCmdName 		 * structure the object's internal rep. points to. 		 */
name|cmd
operator|=
name|Tcl_GetCommandFromObj
argument_list|(
name|interp
argument_list|,
name|objv0Ptr
argument_list|)
expr_stmt|;
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|cmd
expr_stmt|;
comment|/* 		 * If the command is still not found, handle it with the 		 * "unknown" proc. 		 */
if|if
condition|(
name|cmdPtr
operator|==
name|NULL
condition|)
block|{
name|cmd
operator|=
name|Tcl_FindCommand
argument_list|(
name|interp
argument_list|,
literal|"unknown"
argument_list|,
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|NULL
argument_list|,
comment|/*flags*/
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
operator|(
name|Tcl_Command
operator|)
name|NULL
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"invalid command name \""
argument_list|,
name|cmdName
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"%s %u => unknown proc not found: "
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|objc
operator|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|cmd
expr_stmt|;
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
name|isUnknownCmd
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/*TCL_COMPILE_DEBUG*/
name|stackTop
operator|++
expr_stmt|;
comment|/* need room for new inserted objv[0] */
for|for
control|(
name|i
operator|=
name|objc
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|objv
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|objv
index|[
name|i
index|]
expr_stmt|;
block|}
name|objc
operator|++
expr_stmt|;
name|objv
index|[
literal|0
index|]
operator|=
name|Tcl_NewStringObj
argument_list|(
literal|"unknown"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|objv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Call any trace procedures. 		 */
if|if
condition|(
name|iPtr
operator|->
name|tracePtr
operator|!=
name|NULL
condition|)
block|{
name|Trace
modifier|*
name|tracePtr
decl_stmt|,
modifier|*
name|nextTracePtr
decl_stmt|;
for|for
control|(
name|tracePtr
operator|=
name|iPtr
operator|->
name|tracePtr
init|;
name|tracePtr
operator|!=
name|NULL
condition|;
name|tracePtr
operator|=
name|nextTracePtr
control|)
block|{
name|nextTracePtr
operator|=
name|tracePtr
operator|->
name|nextPtr
expr_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|numLevels
operator|<=
name|tracePtr
operator|->
name|level
condition|)
block|{
name|int
name|numChars
decl_stmt|;
name|char
modifier|*
name|cmd
init|=
name|GetSrcInfoForPc
argument_list|(
name|pc
argument_list|,
name|codePtr
argument_list|,
operator|&
name|numChars
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmd
operator|!=
name|NULL
condition|)
block|{
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
name|CallTraceProcedure
argument_list|(
name|interp
argument_list|,
name|tracePtr
argument_list|,
name|cmdPtr
argument_list|,
name|cmd
argument_list|,
name|numChars
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 		 * Finally, invoke the command's Tcl_ObjCmdProc. First reset 		 * the interpreter's string and object results to their 		 * default empty values since they could have gotten changed 		 * by earlier invocations. 		 */
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tclTraceExec
operator|>=
literal|2
condition|)
block|{
name|char
name|buffer
index|[
literal|50
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d: (%u) invoking "
argument_list|,
name|iPtr
operator|->
name|numLevels
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|pc
operator|-
name|codePtr
operator|->
name|codeStart
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|command
argument_list|,
name|buffer
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
if|if
condition|(
name|traceInstructions
condition|)
block|{
comment|/* tclTraceExec == 3 */
name|strncpy
argument_list|(
name|cmdNameBuf
argument_list|,
name|cmdName
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"%s %u => call "
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
operator|(
name|isUnknownCmd
condition|?
name|objc
operator|-
literal|1
else|:
name|objc
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* TCL_COMPILE_DEBUG */
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*TCL_COMPILE_DEBUG*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|bytes
operator|=
name|TclGetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|TclPrintSource
argument_list|(
name|stdout
argument_list|,
name|bytes
argument_list|,
name|TclMin
argument_list|(
name|length
argument_list|,
literal|15
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"\"%.*s\" "
argument_list|,
name|TclMin
argument_list|(
name|length
argument_list|,
literal|15
argument_list|)
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|command
argument_list|,
name|buffer
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|command
argument_list|)
expr_stmt|;
block|}
name|iPtr
operator|->
name|cmdCount
operator|++
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
name|result
operator|=
call|(
modifier|*
name|cmdPtr
operator|->
name|objProc
call|)
argument_list|(
name|cmdPtr
operator|->
name|objClientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_AsyncReady
argument_list|()
condition|)
block|{
name|result
operator|=
name|Tcl_AsyncInvoke
argument_list|(
name|interp
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
comment|/* 		 * If the interpreter has a non-empty string result, the 		 * result object is either empty or stale because some 		 * procedure set interp->result directly. If so, move the 		 * string result to the result object, then reset the 		 * string result. 		 */
if|if
condition|(
operator|*
operator|(
name|iPtr
operator|->
name|result
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Pop the objc top stack elements and decrement their ref 		 * counts.  		 */
name|i
operator|=
operator|(
name|stackTop
operator|-
operator|(
name|objc
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
while|while
condition|(
name|i
operator|<=
name|stackTop
condition|)
block|{
name|valuePtr
operator|=
name|stackPtr
index|[
name|i
index|]
operator|.
name|o
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|stackTop
operator|-=
name|objc
expr_stmt|;
comment|/* 		 * Process the result of the Tcl_ObjCmdProc call. 		 */
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|TCL_OK
case|:
comment|/* 		     * Push the call's object result and continue execution 		     * with the next instruction. 		     */
name|PUSH_OBJECT
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"%s %u => ...after \"%.20s\", result="
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|objc
operator|,
name|cmdNameBuf
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
name|pcAdjustment
argument_list|)
expr_stmt|;
case|case
name|TCL_BREAK
case|:
case|case
name|TCL_CONTINUE
case|:
comment|/* 		     * The invoked command requested a break or continue. 		     * Find the closest enclosing loop or catch exception 		     * range, if any. If a loop is found, terminate its 		     * execution or skip to its next iteration. If the 		     * closest is a catch exception range, jump to its 		     * catchOffset. If no enclosing range is found, stop 		     * execution and return the TCL_BREAK or TCL_CONTINUE. 		     */
name|rangePtr
operator|=
name|TclGetExceptionRangeForPc
argument_list|(
name|pc
argument_list|,
comment|/*catchOnly*/
literal|0
argument_list|,
name|codePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rangePtr
operator|==
name|NULL
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"%s %u => ... after \"%.20s\", no encl. loop or catch, returning %s\n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|objc
operator|,
name|cmdNameBuf
operator|,
name|StringForResultCode
argument_list|(
name|result
argument_list|)
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|abnormalReturn
goto|;
comment|/* no catch exists to check */
block|}
switch|switch
condition|(
name|rangePtr
operator|->
name|type
condition|)
block|{
case|case
name|LOOP_EXCEPTION_RANGE
case|:
if|if
condition|(
name|result
operator|==
name|TCL_BREAK
condition|)
block|{
name|newPcOffset
operator|=
name|rangePtr
operator|->
name|breakOffset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rangePtr
operator|->
name|continueOffset
operator|==
operator|-
literal|1
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"%s %u => ... after \"%.20s\", %s, loop w/o continue, checking for catch\n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|objc
operator|,
name|cmdNameBuf
operator|,
name|StringForResultCode
argument_list|(
name|result
argument_list|)
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
else|else
block|{
name|newPcOffset
operator|=
name|rangePtr
operator|->
name|continueOffset
expr_stmt|;
block|}
name|TRACE
argument_list|(
operator|(
literal|"%s %u => ... after \"%.20s\", %s, range at %d, new pc %d\n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|objc
operator|,
name|cmdNameBuf
operator|,
name|StringForResultCode
argument_list|(
name|result
argument_list|)
operator|,
name|rangePtr
operator|->
name|codeOffset
operator|,
name|newPcOffset
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CATCH_EXCEPTION_RANGE
case|:
name|TRACE
argument_list|(
operator|(
literal|"%s %u => ... after \"%.20s\", %s...\n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|objc
operator|,
name|cmdNameBuf
operator|,
name|StringForResultCode
argument_list|(
name|result
argument_list|)
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|processCatch
goto|;
comment|/* it will use rangePtr */
default|default:
name|panic
argument_list|(
literal|"TclExecuteByteCode: unrecognized ExceptionRange type %d\n"
argument_list|,
name|rangePtr
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|TCL_OK
expr_stmt|;
name|pc
operator|=
operator|(
name|codePtr
operator|->
name|codeStart
operator|+
name|newPcOffset
operator|)
expr_stmt|;
continue|continue;
comment|/* restart outer instruction loop at pc */
case|case
name|TCL_ERROR
case|:
comment|/* 		     * The invoked command returned an error. Look for an 		     * enclosing catch exception range, if any. 		     */
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"%s %u => ... after \"%.20s\", TCL_ERROR "
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|objc
operator|,
name|cmdNameBuf
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
case|case
name|TCL_RETURN
case|:
comment|/* 		     * The invoked command requested that the current 		     * procedure stop execution and return. First check 		     * for an enclosing catch exception range, if any. 		     */
name|TRACE
argument_list|(
operator|(
literal|"%s %u => ... after \"%.20s\", TCL_RETURN\n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|objc
operator|,
name|cmdNameBuf
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
default|default:
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"%s %u => ... after \"%.20s\", OTHER RETURN CODE %d "
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|objc
operator|,
name|cmdNameBuf
operator|,
name|result
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
comment|/* end of switch on result from invoke instruction */
block|}
case|case
name|INST_EVAL_STK
case|:
name|objPtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
name|result
operator|=
name|Tcl_EvalObj
argument_list|(
name|interp
argument_list|,
name|objPtr
argument_list|)
expr_stmt|;
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
comment|/* 		 * Normal return; push the eval's object result. 		 */
name|PUSH_OBJECT
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"evalStk \"%.30s\" => "
operator|,
name|O2S
argument_list|(
name|objPtr
argument_list|)
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|result
operator|==
name|TCL_BREAK
operator|)
operator|||
operator|(
name|result
operator|==
name|TCL_CONTINUE
operator|)
condition|)
block|{
comment|/* 		 * Find the closest enclosing loop or catch exception range, 		 * if any. If a loop is found, terminate its execution or 		 * skip to its next iteration. If the closest is a catch 		 * exception range, jump to its catchOffset. If no enclosing 		 * range is found, stop execution and return that same 		 * TCL_BREAK or TCL_CONTINUE. 		 */
name|int
name|newPcOffset
init|=
literal|0
decl_stmt|;
comment|/* Pc offset computed during break, 				      * continue, error processing. Init. 				      * to avoid compiler warning. */
name|rangePtr
operator|=
name|TclGetExceptionRangeForPc
argument_list|(
name|pc
argument_list|,
comment|/*catchOnly*/
literal|0
argument_list|,
name|codePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rangePtr
operator|==
name|NULL
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"evalStk \"%.30s\" => no encl. loop or catch, returning %s\n"
operator|,
name|O2S
argument_list|(
name|objPtr
argument_list|)
operator|,
name|StringForResultCode
argument_list|(
name|result
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
goto|goto
name|abnormalReturn
goto|;
comment|/* no catch exists to check */
block|}
switch|switch
condition|(
name|rangePtr
operator|->
name|type
condition|)
block|{
case|case
name|LOOP_EXCEPTION_RANGE
case|:
if|if
condition|(
name|result
operator|==
name|TCL_BREAK
condition|)
block|{
name|newPcOffset
operator|=
name|rangePtr
operator|->
name|breakOffset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rangePtr
operator|->
name|continueOffset
operator|==
operator|-
literal|1
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"evalStk \"%.30s\" => %s, loop w/o continue, checking for catch\n"
operator|,
name|O2S
argument_list|(
name|objPtr
argument_list|)
operator|,
name|StringForResultCode
argument_list|(
name|result
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
else|else
block|{
name|newPcOffset
operator|=
name|rangePtr
operator|->
name|continueOffset
expr_stmt|;
block|}
name|result
operator|=
name|TCL_OK
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"evalStk \"%.30s\" => %s, range at %d, new pc %d "
operator|,
name|O2S
argument_list|(
name|objPtr
argument_list|)
operator|,
name|StringForResultCode
argument_list|(
name|result
argument_list|)
operator|,
name|rangePtr
operator|->
name|codeOffset
operator|,
name|newPcOffset
operator|)
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
break|break;
case|case
name|CATCH_EXCEPTION_RANGE
case|:
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"evalStk \"%.30s\" => %s "
operator|,
name|O2S
argument_list|(
name|objPtr
argument_list|)
operator|,
name|StringForResultCode
argument_list|(
name|result
argument_list|)
operator|)
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
goto|goto
name|processCatch
goto|;
comment|/* it will use rangePtr */
default|default:
name|panic
argument_list|(
literal|"TclExecuteByteCode: unrecognized ExceptionRange type %d\n"
argument_list|,
name|rangePtr
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
name|Tcl_DecrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|pc
operator|=
operator|(
name|codePtr
operator|->
name|codeStart
operator|+
name|newPcOffset
operator|)
expr_stmt|;
continue|continue;
comment|/* restart outer instruction loop at pc */
block|}
else|else
block|{
comment|/* eval returned TCL_ERROR, TCL_RETURN, unknown code */
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"evalStk \"%.30s\" => ERROR: "
operator|,
name|O2S
argument_list|(
name|objPtr
argument_list|)
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
case|case
name|INST_EXPR_STK
case|:
name|objPtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
name|result
operator|=
name|Tcl_ExprObj
argument_list|(
name|interp
argument_list|,
name|objPtr
argument_list|,
operator|&
name|valuePtr
argument_list|)
expr_stmt|;
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"exprStk \"%.30s\" => ERROR: "
operator|,
name|O2S
argument_list|(
name|objPtr
argument_list|)
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
name|stackPtr
index|[
operator|++
name|stackTop
index|]
operator|.
name|o
operator|=
name|valuePtr
expr_stmt|;
comment|/* already has right refct */
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"exprStk \"%.30s\" => "
operator|,
name|O2S
argument_list|(
name|objPtr
argument_list|)
operator|)
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|INST_LOAD_SCALAR4
case|:
name|opnd
operator|=
name|TclGetInt4AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pcAdjustment
operator|=
literal|5
expr_stmt|;
goto|goto
name|doLoadScalar
goto|;
case|case
name|INST_LOAD_SCALAR1
case|:
name|opnd
operator|=
name|TclGetUInt1AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pcAdjustment
operator|=
literal|2
expr_stmt|;
name|doLoadScalar
label|:
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
name|valuePtr
operator|=
name|TclGetIndexedScalar
argument_list|(
name|interp
argument_list|,
name|opnd
argument_list|,
comment|/*leaveErrorMsg*/
literal|1
argument_list|)
expr_stmt|;
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
if|if
condition|(
name|valuePtr
operator|==
name|NULL
condition|)
block|{
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"%s %u => ERROR: "
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|opnd
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
name|PUSH_OBJECT
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"%s %u => "
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|opnd
operator|)
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
name|pcAdjustment
argument_list|)
expr_stmt|;
case|case
name|INST_LOAD_SCALAR_STK
case|:
name|namePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
name|valuePtr
operator|=
name|Tcl_ObjGetVar2
argument_list|(
name|interp
argument_list|,
name|namePtr
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
expr_stmt|;
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
if|if
condition|(
name|valuePtr
operator|==
name|NULL
condition|)
block|{
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"loadScalarStk \"%.30s\" => ERROR: "
operator|,
name|O2S
argument_list|(
name|namePtr
argument_list|)
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
name|PUSH_OBJECT
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"loadScalarStk \"%.30s\" => "
operator|,
name|O2S
argument_list|(
name|namePtr
argument_list|)
operator|)
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|INST_LOAD_ARRAY4
case|:
name|opnd
operator|=
name|TclGetUInt4AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pcAdjustment
operator|=
literal|5
expr_stmt|;
goto|goto
name|doLoadArray
goto|;
case|case
name|INST_LOAD_ARRAY1
case|:
name|opnd
operator|=
name|TclGetUInt1AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pcAdjustment
operator|=
literal|2
expr_stmt|;
name|doLoadArray
label|:
block|{
name|Tcl_Obj
modifier|*
name|elemPtr
init|=
name|POP_OBJECT
argument_list|()
decl_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
name|valuePtr
operator|=
name|TclGetElementOfIndexedArray
argument_list|(
name|interp
argument_list|,
name|opnd
argument_list|,
name|elemPtr
argument_list|,
comment|/*leaveErrorMsg*/
literal|1
argument_list|)
expr_stmt|;
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
if|if
condition|(
name|valuePtr
operator|==
name|NULL
condition|)
block|{
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"%s %u \"%.30s\" => ERROR: "
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|opnd
operator|,
name|O2S
argument_list|(
name|elemPtr
argument_list|)
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|elemPtr
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
name|PUSH_OBJECT
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"%s %u \"%.30s\" => "
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|opnd
operator|,
name|O2S
argument_list|(
name|elemPtr
argument_list|)
operator|)
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|elemPtr
argument_list|)
expr_stmt|;
block|}
name|ADJUST_PC
argument_list|(
name|pcAdjustment
argument_list|)
expr_stmt|;
case|case
name|INST_LOAD_ARRAY_STK
case|:
block|{
name|Tcl_Obj
modifier|*
name|elemPtr
init|=
name|POP_OBJECT
argument_list|()
decl_stmt|;
name|namePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
name|valuePtr
operator|=
name|Tcl_ObjGetVar2
argument_list|(
name|interp
argument_list|,
name|namePtr
argument_list|,
name|elemPtr
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
expr_stmt|;
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
if|if
condition|(
name|valuePtr
operator|==
name|NULL
condition|)
block|{
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"loadArrayStk \"%.30s(%.30s)\" => ERROR: "
operator|,
name|O2S
argument_list|(
name|namePtr
argument_list|)
operator|,
name|O2S
argument_list|(
name|elemPtr
argument_list|)
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|elemPtr
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
name|PUSH_OBJECT
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"loadArrayStk \"%.30s(%.30s)\" => "
operator|,
name|O2S
argument_list|(
name|namePtr
argument_list|)
operator|,
name|O2S
argument_list|(
name|elemPtr
argument_list|)
operator|)
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|elemPtr
argument_list|)
expr_stmt|;
block|}
name|ADJUST_PC
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|INST_LOAD_STK
case|:
name|namePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
name|valuePtr
operator|=
name|Tcl_ObjGetVar2
argument_list|(
name|interp
argument_list|,
name|namePtr
argument_list|,
name|NULL
argument_list|,
name|TCL_PARSE_PART1
operator||
name|TCL_LEAVE_ERR_MSG
argument_list|)
expr_stmt|;
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
if|if
condition|(
name|valuePtr
operator|==
name|NULL
condition|)
block|{
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"loadStk \"%.30s\" => ERROR: "
operator|,
name|O2S
argument_list|(
name|namePtr
argument_list|)
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
name|PUSH_OBJECT
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"loadStk \"%.30s\" => "
operator|,
name|O2S
argument_list|(
name|namePtr
argument_list|)
operator|)
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|INST_STORE_SCALAR4
case|:
name|opnd
operator|=
name|TclGetUInt4AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pcAdjustment
operator|=
literal|5
expr_stmt|;
goto|goto
name|doStoreScalar
goto|;
case|case
name|INST_STORE_SCALAR1
case|:
name|opnd
operator|=
name|TclGetUInt1AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pcAdjustment
operator|=
literal|2
expr_stmt|;
name|doStoreScalar
label|:
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
name|value2Ptr
operator|=
name|TclSetIndexedScalar
argument_list|(
name|interp
argument_list|,
name|opnd
argument_list|,
name|valuePtr
argument_list|,
comment|/*leaveErrorMsg*/
literal|1
argument_list|)
expr_stmt|;
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
if|if
condition|(
name|value2Ptr
operator|==
name|NULL
condition|)
block|{
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"%s %u<- \"%.30s\" => ERROR: "
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|opnd
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
name|PUSH_OBJECT
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"%s %u<- \"%.30s\" => "
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|opnd
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|)
argument_list|,
name|value2Ptr
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
name|pcAdjustment
argument_list|)
expr_stmt|;
case|case
name|INST_STORE_SCALAR_STK
case|:
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|namePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
name|value2Ptr
operator|=
name|Tcl_ObjSetVar2
argument_list|(
name|interp
argument_list|,
name|namePtr
argument_list|,
name|NULL
argument_list|,
name|valuePtr
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
expr_stmt|;
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
if|if
condition|(
name|value2Ptr
operator|==
name|NULL
condition|)
block|{
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"storeScalarStk \"%.30s\"<- \"%.30s\" => ERROR: "
operator|,
name|O2S
argument_list|(
name|namePtr
argument_list|)
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
name|PUSH_OBJECT
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"storeScalarStk \"%.30s\"<- \"%.30s\" => "
operator|,
name|O2S
argument_list|(
name|namePtr
argument_list|)
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|)
argument_list|,
name|value2Ptr
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|INST_STORE_ARRAY4
case|:
name|opnd
operator|=
name|TclGetUInt4AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pcAdjustment
operator|=
literal|5
expr_stmt|;
goto|goto
name|doStoreArray
goto|;
case|case
name|INST_STORE_ARRAY1
case|:
name|opnd
operator|=
name|TclGetUInt1AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pcAdjustment
operator|=
literal|2
expr_stmt|;
name|doStoreArray
label|:
block|{
name|Tcl_Obj
modifier|*
name|elemPtr
decl_stmt|;
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|elemPtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
name|value2Ptr
operator|=
name|TclSetElementOfIndexedArray
argument_list|(
name|interp
argument_list|,
name|opnd
argument_list|,
name|elemPtr
argument_list|,
name|valuePtr
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
expr_stmt|;
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
if|if
condition|(
name|value2Ptr
operator|==
name|NULL
condition|)
block|{
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"%s %u \"%.30s\"<- \"%.30s\" => ERROR: "
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|opnd
operator|,
name|O2S
argument_list|(
name|elemPtr
argument_list|)
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|elemPtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
name|PUSH_OBJECT
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"%s %u \"%.30s\"<- \"%.30s\" => "
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|opnd
operator|,
name|O2S
argument_list|(
name|elemPtr
argument_list|)
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|)
argument_list|,
name|value2Ptr
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|elemPtr
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
block|}
name|ADJUST_PC
argument_list|(
name|pcAdjustment
argument_list|)
expr_stmt|;
case|case
name|INST_STORE_ARRAY_STK
case|:
block|{
name|Tcl_Obj
modifier|*
name|elemPtr
decl_stmt|;
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|elemPtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|namePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
name|value2Ptr
operator|=
name|Tcl_ObjSetVar2
argument_list|(
name|interp
argument_list|,
name|namePtr
argument_list|,
name|elemPtr
argument_list|,
name|valuePtr
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
expr_stmt|;
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
if|if
condition|(
name|value2Ptr
operator|==
name|NULL
condition|)
block|{
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"storeArrayStk \"%.30s(%.30s)\"<- \"%.30s\" => ERROR: "
operator|,
name|O2S
argument_list|(
name|namePtr
argument_list|)
operator|,
name|O2S
argument_list|(
name|elemPtr
argument_list|)
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|elemPtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
name|PUSH_OBJECT
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"storeArrayStk \"%.30s(%.30s)\"<- \"%.30s\" => "
operator|,
name|O2S
argument_list|(
name|namePtr
argument_list|)
operator|,
name|O2S
argument_list|(
name|elemPtr
argument_list|)
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|)
argument_list|,
name|value2Ptr
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|elemPtr
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
block|}
name|ADJUST_PC
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|INST_STORE_STK
case|:
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|namePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
name|value2Ptr
operator|=
name|Tcl_ObjSetVar2
argument_list|(
name|interp
argument_list|,
name|namePtr
argument_list|,
name|NULL
argument_list|,
name|valuePtr
argument_list|,
name|TCL_PARSE_PART1
operator||
name|TCL_LEAVE_ERR_MSG
argument_list|)
expr_stmt|;
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
if|if
condition|(
name|value2Ptr
operator|==
name|NULL
condition|)
block|{
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"storeStk \"%.30s\"<- \"%.30s\" => ERROR: "
operator|,
name|O2S
argument_list|(
name|namePtr
argument_list|)
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
name|PUSH_OBJECT
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"storeStk \"%.30s\"<- \"%.30s\" => "
operator|,
name|O2S
argument_list|(
name|namePtr
argument_list|)
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|)
argument_list|,
name|value2Ptr
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|INST_INCR_SCALAR1
case|:
name|opnd
operator|=
name|TclGetUInt1AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
if|if
condition|(
name|valuePtr
operator|->
name|typePtr
operator|!=
operator|&
name|tclIntType
condition|)
block|{
name|result
operator|=
name|tclIntType
operator|.
name|setFromAnyProc
argument_list|(
name|interp
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"incrScalar1 %u (by %s) => ERROR converting increment amount to int: "
operator|,
name|opnd
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
block|}
name|i
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
name|value2Ptr
operator|=
name|TclIncrIndexedScalar
argument_list|(
name|interp
argument_list|,
name|opnd
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
if|if
condition|(
name|value2Ptr
operator|==
name|NULL
condition|)
block|{
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"incrScalar1 %u (by %ld) => ERROR: "
operator|,
name|opnd
operator|,
name|i
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
name|PUSH_OBJECT
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"incrScalar1 %u (by %ld) => "
operator|,
name|opnd
operator|,
name|i
operator|)
argument_list|,
name|value2Ptr
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
literal|2
argument_list|)
expr_stmt|;
case|case
name|INST_INCR_SCALAR_STK
case|:
case|case
name|INST_INCR_STK
case|:
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|namePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
if|if
condition|(
name|valuePtr
operator|->
name|typePtr
operator|!=
operator|&
name|tclIntType
condition|)
block|{
name|result
operator|=
name|tclIntType
operator|.
name|setFromAnyProc
argument_list|(
name|interp
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"%s \"%.30s\" (by %s) => ERROR converting increment amount to int: "
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|O2S
argument_list|(
name|namePtr
argument_list|)
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
block|}
name|i
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
name|value2Ptr
operator|=
name|TclIncrVar2
argument_list|(
name|interp
argument_list|,
name|namePtr
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|)
name|NULL
argument_list|,
name|i
argument_list|,
comment|/*part1NotParsed*/
operator|(
name|opCode
operator|==
name|INST_INCR_STK
operator|)
argument_list|)
expr_stmt|;
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
if|if
condition|(
name|value2Ptr
operator|==
name|NULL
condition|)
block|{
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"%s \"%.30s\" (by %ld) => ERROR: "
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|O2S
argument_list|(
name|namePtr
argument_list|)
operator|,
name|i
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
name|PUSH_OBJECT
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"%s \"%.30s\" (by %ld) => "
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|O2S
argument_list|(
name|namePtr
argument_list|)
operator|,
name|i
operator|)
argument_list|,
name|value2Ptr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|INST_INCR_ARRAY1
case|:
block|{
name|Tcl_Obj
modifier|*
name|elemPtr
decl_stmt|;
name|opnd
operator|=
name|TclGetUInt1AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|elemPtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
if|if
condition|(
name|valuePtr
operator|->
name|typePtr
operator|!=
operator|&
name|tclIntType
condition|)
block|{
name|result
operator|=
name|tclIntType
operator|.
name|setFromAnyProc
argument_list|(
name|interp
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"incrArray1 %u \"%.30s\" (by %s) => ERROR converting increment amount to int: "
operator|,
name|opnd
operator|,
name|O2S
argument_list|(
name|elemPtr
argument_list|)
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|elemPtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
block|}
name|i
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
name|value2Ptr
operator|=
name|TclIncrElementOfIndexedArray
argument_list|(
name|interp
argument_list|,
name|opnd
argument_list|,
name|elemPtr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
if|if
condition|(
name|value2Ptr
operator|==
name|NULL
condition|)
block|{
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"incrArray1 %u \"%.30s\" (by %ld) => ERROR: "
operator|,
name|opnd
operator|,
name|O2S
argument_list|(
name|elemPtr
argument_list|)
operator|,
name|i
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|elemPtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
name|PUSH_OBJECT
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"incrArray1 %u \"%.30s\" (by %ld) => "
operator|,
name|opnd
operator|,
name|O2S
argument_list|(
name|elemPtr
argument_list|)
operator|,
name|i
operator|)
argument_list|,
name|value2Ptr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|elemPtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
block|}
name|ADJUST_PC
argument_list|(
literal|2
argument_list|)
expr_stmt|;
case|case
name|INST_INCR_ARRAY_STK
case|:
block|{
name|Tcl_Obj
modifier|*
name|elemPtr
decl_stmt|;
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|elemPtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|namePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
if|if
condition|(
name|valuePtr
operator|->
name|typePtr
operator|!=
operator|&
name|tclIntType
condition|)
block|{
name|result
operator|=
name|tclIntType
operator|.
name|setFromAnyProc
argument_list|(
name|interp
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"incrArrayStk \"%.30s(%.30s)\" (by %s) => ERROR converting increment amount to int: "
operator|,
name|O2S
argument_list|(
name|namePtr
argument_list|)
operator|,
name|O2S
argument_list|(
name|elemPtr
argument_list|)
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|elemPtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
block|}
name|i
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
name|value2Ptr
operator|=
name|TclIncrVar2
argument_list|(
name|interp
argument_list|,
name|namePtr
argument_list|,
name|elemPtr
argument_list|,
name|i
argument_list|,
comment|/*part1NotParsed*/
literal|0
argument_list|)
expr_stmt|;
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
if|if
condition|(
name|value2Ptr
operator|==
name|NULL
condition|)
block|{
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"incrArrayStk \"%.30s(%.30s)\" (by %ld) => ERROR: "
operator|,
name|O2S
argument_list|(
name|namePtr
argument_list|)
operator|,
name|O2S
argument_list|(
name|elemPtr
argument_list|)
operator|,
name|i
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|elemPtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
name|PUSH_OBJECT
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"incrArrayStk \"%.30s(%.30s)\" (by %ld) => "
operator|,
name|O2S
argument_list|(
name|namePtr
argument_list|)
operator|,
name|O2S
argument_list|(
name|elemPtr
argument_list|)
operator|,
name|i
operator|)
argument_list|,
name|value2Ptr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|elemPtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
block|}
name|ADJUST_PC
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|INST_INCR_SCALAR1_IMM
case|:
name|opnd
operator|=
name|TclGetUInt1AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
name|TclGetInt1AtPtr
argument_list|(
name|pc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
name|value2Ptr
operator|=
name|TclIncrIndexedScalar
argument_list|(
name|interp
argument_list|,
name|opnd
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
if|if
condition|(
name|value2Ptr
operator|==
name|NULL
condition|)
block|{
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"incrScalar1Imm %u %ld => ERROR: "
operator|,
name|opnd
operator|,
name|i
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
name|PUSH_OBJECT
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"incrScalar1Imm %u %ld => "
operator|,
name|opnd
operator|,
name|i
operator|)
argument_list|,
name|value2Ptr
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
literal|3
argument_list|)
expr_stmt|;
case|case
name|INST_INCR_SCALAR_STK_IMM
case|:
case|case
name|INST_INCR_STK_IMM
case|:
name|namePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|i
operator|=
name|TclGetInt1AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
name|value2Ptr
operator|=
name|TclIncrVar2
argument_list|(
name|interp
argument_list|,
name|namePtr
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|)
name|NULL
argument_list|,
name|i
argument_list|,
comment|/*part1NotParsed*/
operator|(
name|opCode
operator|==
name|INST_INCR_STK_IMM
operator|)
argument_list|)
expr_stmt|;
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
if|if
condition|(
name|value2Ptr
operator|==
name|NULL
condition|)
block|{
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"%s \"%.30s\" %ld => ERROR: "
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|O2S
argument_list|(
name|namePtr
argument_list|)
operator|,
name|i
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
name|PUSH_OBJECT
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"%s \"%.30s\" %ld => "
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|O2S
argument_list|(
name|namePtr
argument_list|)
operator|,
name|i
operator|)
argument_list|,
name|value2Ptr
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
literal|2
argument_list|)
expr_stmt|;
case|case
name|INST_INCR_ARRAY1_IMM
case|:
block|{
name|Tcl_Obj
modifier|*
name|elemPtr
decl_stmt|;
name|opnd
operator|=
name|TclGetUInt1AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
name|TclGetInt1AtPtr
argument_list|(
name|pc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|elemPtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
name|value2Ptr
operator|=
name|TclIncrElementOfIndexedArray
argument_list|(
name|interp
argument_list|,
name|opnd
argument_list|,
name|elemPtr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
if|if
condition|(
name|value2Ptr
operator|==
name|NULL
condition|)
block|{
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"incrArray1Imm %u \"%.30s\" (by %ld) => ERROR: "
operator|,
name|opnd
operator|,
name|O2S
argument_list|(
name|elemPtr
argument_list|)
operator|,
name|i
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|elemPtr
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
name|PUSH_OBJECT
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"incrArray1Imm %u \"%.30s\" (by %ld) => "
operator|,
name|opnd
operator|,
name|O2S
argument_list|(
name|elemPtr
argument_list|)
operator|,
name|i
operator|)
argument_list|,
name|value2Ptr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|elemPtr
argument_list|)
expr_stmt|;
block|}
name|ADJUST_PC
argument_list|(
literal|3
argument_list|)
expr_stmt|;
case|case
name|INST_INCR_ARRAY_STK_IMM
case|:
block|{
name|Tcl_Obj
modifier|*
name|elemPtr
decl_stmt|;
name|i
operator|=
name|TclGetInt1AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|elemPtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|namePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
name|value2Ptr
operator|=
name|TclIncrVar2
argument_list|(
name|interp
argument_list|,
name|namePtr
argument_list|,
name|elemPtr
argument_list|,
name|i
argument_list|,
comment|/*part1NotParsed*/
literal|0
argument_list|)
expr_stmt|;
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
if|if
condition|(
name|value2Ptr
operator|==
name|NULL
condition|)
block|{
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"incrArrayStkImm \"%.30s(%.30s)\" (by %ld) => ERROR: "
operator|,
name|O2S
argument_list|(
name|namePtr
argument_list|)
operator|,
name|O2S
argument_list|(
name|elemPtr
argument_list|)
operator|,
name|i
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|elemPtr
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
name|PUSH_OBJECT
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"incrArrayStkImm \"%.30s(%.30s)\" (by %ld) => "
operator|,
name|O2S
argument_list|(
name|namePtr
argument_list|)
operator|,
name|O2S
argument_list|(
name|elemPtr
argument_list|)
operator|,
name|i
operator|)
argument_list|,
name|value2Ptr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|elemPtr
argument_list|)
expr_stmt|;
block|}
name|ADJUST_PC
argument_list|(
literal|2
argument_list|)
expr_stmt|;
case|case
name|INST_JUMP1
case|:
name|opnd
operator|=
name|TclGetInt1AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"jump1 %d => new pc %u\n"
operator|,
name|opnd
operator|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|pc
operator|+
name|opnd
operator|-
name|codePtr
operator|->
name|codeStart
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
name|opnd
argument_list|)
expr_stmt|;
case|case
name|INST_JUMP4
case|:
name|opnd
operator|=
name|TclGetInt4AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"jump4 %d => new pc %u\n"
operator|,
name|opnd
operator|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|pc
operator|+
name|opnd
operator|-
name|codePtr
operator|->
name|codeStart
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
name|opnd
argument_list|)
expr_stmt|;
case|case
name|INST_JUMP_TRUE4
case|:
name|opnd
operator|=
name|TclGetInt4AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pcAdjustment
operator|=
literal|5
expr_stmt|;
goto|goto
name|doJumpTrue
goto|;
case|case
name|INST_JUMP_TRUE1
case|:
name|opnd
operator|=
name|TclGetInt1AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pcAdjustment
operator|=
literal|2
expr_stmt|;
name|doJumpTrue
label|:
block|{
name|int
name|b
decl_stmt|;
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
if|if
condition|(
name|valuePtr
operator|->
name|typePtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
name|b
operator|=
operator|(
name|valuePtr
operator|->
name|internalRep
operator|.
name|longValue
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|valuePtr
operator|->
name|typePtr
operator|==
operator|&
name|tclDoubleType
condition|)
block|{
name|b
operator|=
operator|(
name|valuePtr
operator|->
name|internalRep
operator|.
name|doubleValue
operator|!=
literal|0.0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_GetBooleanFromObj
argument_list|(
name|interp
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"%s %d => ERROR: "
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|opnd
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
block|}
if|if
condition|(
name|b
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"%s %d => %.20s true, new pc %u\n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|opnd
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|pc
operator|+
name|opnd
operator|-
name|codePtr
operator|->
name|codeStart
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
name|opnd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TRACE
argument_list|(
operator|(
literal|"%s %d => %.20s false\n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|opnd
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
name|pcAdjustment
argument_list|)
expr_stmt|;
block|}
block|}
case|case
name|INST_JUMP_FALSE4
case|:
name|opnd
operator|=
name|TclGetInt4AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pcAdjustment
operator|=
literal|5
expr_stmt|;
goto|goto
name|doJumpFalse
goto|;
case|case
name|INST_JUMP_FALSE1
case|:
name|opnd
operator|=
name|TclGetInt1AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pcAdjustment
operator|=
literal|2
expr_stmt|;
name|doJumpFalse
label|:
block|{
name|int
name|b
decl_stmt|;
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
if|if
condition|(
name|valuePtr
operator|->
name|typePtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
name|b
operator|=
operator|(
name|valuePtr
operator|->
name|internalRep
operator|.
name|longValue
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|valuePtr
operator|->
name|typePtr
operator|==
operator|&
name|tclDoubleType
condition|)
block|{
name|b
operator|=
operator|(
name|valuePtr
operator|->
name|internalRep
operator|.
name|doubleValue
operator|!=
literal|0.0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_GetBooleanFromObj
argument_list|(
name|interp
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"%s %d => ERROR: "
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|opnd
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
block|}
if|if
condition|(
name|b
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"%s %d => %.20s true\n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|opnd
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
name|pcAdjustment
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TRACE
argument_list|(
operator|(
literal|"%s %d => %.20s false, new pc %u\n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|opnd
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|pc
operator|+
name|opnd
operator|-
name|codePtr
operator|->
name|codeStart
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
name|opnd
argument_list|)
expr_stmt|;
block|}
block|}
case|case
name|INST_LOR
case|:
case|case
name|INST_LAND
case|:
block|{
comment|/* 		 * Operands must be boolean or numeric. No int->double 		 * conversions are performed. 		 */
name|int
name|i1
decl_stmt|,
name|i2
decl_stmt|;
name|int
name|iResult
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|Tcl_ObjType
modifier|*
name|t1Ptr
decl_stmt|,
modifier|*
name|t2Ptr
decl_stmt|;
name|value2Ptr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|t1Ptr
operator|=
name|valuePtr
operator|->
name|typePtr
expr_stmt|;
name|t2Ptr
operator|=
name|value2Ptr
operator|->
name|typePtr
expr_stmt|;
if|if
condition|(
operator|(
name|t1Ptr
operator|==
operator|&
name|tclIntType
operator|)
operator|||
operator|(
name|t1Ptr
operator|==
operator|&
name|tclBooleanType
operator|)
condition|)
block|{
name|i1
operator|=
operator|(
name|valuePtr
operator|->
name|internalRep
operator|.
name|longValue
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t1Ptr
operator|==
operator|&
name|tclDoubleType
condition|)
block|{
name|i1
operator|=
operator|(
name|valuePtr
operator|->
name|internalRep
operator|.
name|doubleValue
operator|!=
literal|0.0
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* FAILS IF NULL STRING REP */
name|s
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|valuePtr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|TclLooksLikeInt
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|result
operator|=
name|Tcl_GetLongFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|i1
operator|=
operator|(
name|i
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_GetBooleanFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|i1
argument_list|)
expr_stmt|;
name|i1
operator|=
operator|(
name|i1
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"%s \"%.20s\" => ILLEGAL TYPE %s \n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|,
operator|(
name|t1Ptr
condition|?
name|t1Ptr
operator|->
name|name
else|:
literal|"null"
operator|)
operator|)
argument_list|)
expr_stmt|;
name|IllegalExprOperandType
argument_list|(
name|interp
argument_list|,
name|opCode
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|t2Ptr
operator|==
operator|&
name|tclIntType
operator|)
operator|||
operator|(
name|t2Ptr
operator|==
operator|&
name|tclBooleanType
operator|)
condition|)
block|{
name|i2
operator|=
operator|(
name|value2Ptr
operator|->
name|internalRep
operator|.
name|longValue
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t2Ptr
operator|==
operator|&
name|tclDoubleType
condition|)
block|{
name|i2
operator|=
operator|(
name|value2Ptr
operator|->
name|internalRep
operator|.
name|doubleValue
operator|!=
literal|0.0
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* FAILS IF NULL STRING REP */
name|s
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|value2Ptr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|TclLooksLikeInt
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|result
operator|=
name|Tcl_GetLongFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|value2Ptr
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|i2
operator|=
operator|(
name|i
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_GetBooleanFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|value2Ptr
argument_list|,
operator|&
name|i2
argument_list|)
expr_stmt|;
name|i2
operator|=
operator|(
name|i2
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"%s \"%.20s\" => ILLEGAL TYPE %s \n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|O2S
argument_list|(
name|value2Ptr
argument_list|)
operator|,
operator|(
name|t2Ptr
condition|?
name|t2Ptr
operator|->
name|name
else|:
literal|"null"
operator|)
operator|)
argument_list|)
expr_stmt|;
name|IllegalExprOperandType
argument_list|(
name|interp
argument_list|,
name|opCode
argument_list|,
name|value2Ptr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
block|}
comment|/* 		 * Reuse the valuePtr object already on stack if possible. 		 */
if|if
condition|(
name|opCode
operator|==
name|INST_LOR
condition|)
block|{
name|iResult
operator|=
operator|(
name|i1
operator|||
name|i2
operator|)
expr_stmt|;
block|}
else|else
block|{
name|iResult
operator|=
operator|(
name|i1
operator|&&
name|i2
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|valuePtr
argument_list|)
condition|)
block|{
name|PUSH_OBJECT
argument_list|(
name|Tcl_NewLongObj
argument_list|(
name|iResult
argument_list|)
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"%s %.20s %.20s => %d\n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|,
name|O2S
argument_list|(
name|value2Ptr
argument_list|)
operator|,
name|iResult
operator|)
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* reuse the valuePtr object */
name|TRACE
argument_list|(
operator|(
literal|"%s %.20s %.20s => %d\n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
comment|/* NB: stack top is off by 1 */
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|,
name|O2S
argument_list|(
name|value2Ptr
argument_list|)
operator|,
name|iResult
operator|)
argument_list|)
expr_stmt|;
name|Tcl_SetLongObj
argument_list|(
name|valuePtr
argument_list|,
name|iResult
argument_list|)
expr_stmt|;
operator|++
name|stackTop
expr_stmt|;
comment|/* valuePtr now on stk top has right r.c. */
block|}
name|TclDecrRefCount
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
block|}
name|ADJUST_PC
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|INST_EQ
case|:
case|case
name|INST_NEQ
case|:
case|case
name|INST_LT
case|:
case|case
name|INST_GT
case|:
case|case
name|INST_LE
case|:
case|case
name|INST_GE
case|:
block|{
comment|/* 		 * Any type is allowed but the two operands must have the 	         * same type. We will compute value op value2. 		 */
name|Tcl_ObjType
modifier|*
name|t1Ptr
decl_stmt|,
modifier|*
name|t2Ptr
decl_stmt|;
name|char
modifier|*
name|s1
init|=
name|NULL
decl_stmt|;
comment|/* Init. avoids compiler warning. */
name|char
modifier|*
name|s2
init|=
name|NULL
decl_stmt|;
comment|/* Init. avoids compiler warning. */
name|long
name|i2
init|=
literal|0
decl_stmt|;
comment|/* Init. avoids compiler warning. */
name|double
name|d1
init|=
literal|0.0
decl_stmt|;
comment|/* Init. avoids compiler warning. */
name|double
name|d2
init|=
literal|0.0
decl_stmt|;
comment|/* Init. avoids compiler warning. */
name|long
name|iResult
init|=
literal|0
decl_stmt|;
comment|/* Init. avoids compiler warning. */
name|value2Ptr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|t1Ptr
operator|=
name|valuePtr
operator|->
name|typePtr
expr_stmt|;
name|t2Ptr
operator|=
name|value2Ptr
operator|->
name|typePtr
expr_stmt|;
if|if
condition|(
operator|(
name|t1Ptr
operator|!=
operator|&
name|tclIntType
operator|)
operator|&&
operator|(
name|t1Ptr
operator|!=
operator|&
name|tclDoubleType
operator|)
condition|)
block|{
name|s1
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|valuePtr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|TclLooksLikeInt
argument_list|(
name|s1
argument_list|)
condition|)
block|{
comment|/* FAILS IF NULLS */
operator|(
name|void
operator|)
name|Tcl_GetLongFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|Tcl_GetDoubleFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|d1
argument_list|)
expr_stmt|;
block|}
name|t1Ptr
operator|=
name|valuePtr
operator|->
name|typePtr
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|t2Ptr
operator|!=
operator|&
name|tclIntType
operator|)
operator|&&
operator|(
name|t2Ptr
operator|!=
operator|&
name|tclDoubleType
operator|)
condition|)
block|{
name|s2
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|value2Ptr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|TclLooksLikeInt
argument_list|(
name|s2
argument_list|)
condition|)
block|{
comment|/* FAILS IF NULLS */
operator|(
name|void
operator|)
name|Tcl_GetLongFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|value2Ptr
argument_list|,
operator|&
name|i2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|Tcl_GetDoubleFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|value2Ptr
argument_list|,
operator|&
name|d2
argument_list|)
expr_stmt|;
block|}
name|t2Ptr
operator|=
name|value2Ptr
operator|->
name|typePtr
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|t1Ptr
operator|!=
operator|&
name|tclIntType
operator|)
operator|&&
operator|(
name|t1Ptr
operator|!=
operator|&
name|tclDoubleType
operator|)
operator|)
operator|||
operator|(
operator|(
name|t2Ptr
operator|!=
operator|&
name|tclIntType
operator|)
operator|&&
operator|(
name|t2Ptr
operator|!=
operator|&
name|tclDoubleType
operator|)
operator|)
condition|)
block|{
comment|/* 		     * One operand is not numeric. Compare as strings. 		     * THIS FAILS IF AN OBJECT'S STRING REP CONTAINS NULLS. 		     */
name|int
name|cmpValue
decl_stmt|;
name|s1
operator|=
name|TclGetStringFromObj
argument_list|(
name|valuePtr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|s2
operator|=
name|TclGetStringFromObj
argument_list|(
name|value2Ptr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|cmpValue
operator|=
name|strcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opCode
condition|)
block|{
case|case
name|INST_EQ
case|:
name|iResult
operator|=
operator|(
name|cmpValue
operator|==
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|INST_NEQ
case|:
name|iResult
operator|=
operator|(
name|cmpValue
operator|!=
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|INST_LT
case|:
name|iResult
operator|=
operator|(
name|cmpValue
operator|<
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|INST_GT
case|:
name|iResult
operator|=
operator|(
name|cmpValue
operator|>
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|INST_LE
case|:
name|iResult
operator|=
operator|(
name|cmpValue
operator|<=
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|INST_GE
case|:
name|iResult
operator|=
operator|(
name|cmpValue
operator|>=
literal|0
operator|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|t1Ptr
operator|==
operator|&
name|tclDoubleType
operator|)
operator|||
operator|(
name|t2Ptr
operator|==
operator|&
name|tclDoubleType
operator|)
condition|)
block|{
comment|/* 		     * Compare as doubles. 		     */
if|if
condition|(
name|t1Ptr
operator|==
operator|&
name|tclDoubleType
condition|)
block|{
name|d1
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|doubleValue
expr_stmt|;
if|if
condition|(
name|t2Ptr
operator|==
operator|&
name|tclIntType
condition|)
block|{
name|d2
operator|=
name|value2Ptr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
block|}
else|else
block|{
name|d2
operator|=
name|value2Ptr
operator|->
name|internalRep
operator|.
name|doubleValue
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* t1Ptr is int, t2Ptr is double */
name|d1
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
name|d2
operator|=
name|value2Ptr
operator|->
name|internalRep
operator|.
name|doubleValue
expr_stmt|;
block|}
switch|switch
condition|(
name|opCode
condition|)
block|{
case|case
name|INST_EQ
case|:
name|iResult
operator|=
name|d1
operator|==
name|d2
expr_stmt|;
break|break;
case|case
name|INST_NEQ
case|:
name|iResult
operator|=
name|d1
operator|!=
name|d2
expr_stmt|;
break|break;
case|case
name|INST_LT
case|:
name|iResult
operator|=
name|d1
operator|<
name|d2
expr_stmt|;
break|break;
case|case
name|INST_GT
case|:
name|iResult
operator|=
name|d1
operator|>
name|d2
expr_stmt|;
break|break;
case|case
name|INST_LE
case|:
name|iResult
operator|=
name|d1
operator|<=
name|d2
expr_stmt|;
break|break;
case|case
name|INST_GE
case|:
name|iResult
operator|=
name|d1
operator|>=
name|d2
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* 		     * Compare as ints. 		     */
name|i
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
name|i2
operator|=
name|value2Ptr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
switch|switch
condition|(
name|opCode
condition|)
block|{
case|case
name|INST_EQ
case|:
name|iResult
operator|=
name|i
operator|==
name|i2
expr_stmt|;
break|break;
case|case
name|INST_NEQ
case|:
name|iResult
operator|=
name|i
operator|!=
name|i2
expr_stmt|;
break|break;
case|case
name|INST_LT
case|:
name|iResult
operator|=
name|i
operator|<
name|i2
expr_stmt|;
break|break;
case|case
name|INST_GT
case|:
name|iResult
operator|=
name|i
operator|>
name|i2
expr_stmt|;
break|break;
case|case
name|INST_LE
case|:
name|iResult
operator|=
name|i
operator|<=
name|i2
expr_stmt|;
break|break;
case|case
name|INST_GE
case|:
name|iResult
operator|=
name|i
operator|>=
name|i2
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * Reuse the valuePtr object already on stack if possible. 		 */
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|valuePtr
argument_list|)
condition|)
block|{
name|PUSH_OBJECT
argument_list|(
name|Tcl_NewLongObj
argument_list|(
name|iResult
argument_list|)
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"%s %.20s %.20s => %ld\n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|,
name|O2S
argument_list|(
name|value2Ptr
argument_list|)
operator|,
name|iResult
operator|)
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* reuse the valuePtr object */
name|TRACE
argument_list|(
operator|(
literal|"%s %.20s %.20s => %ld\n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
comment|/* NB: stack top is off by 1 */
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|,
name|O2S
argument_list|(
name|value2Ptr
argument_list|)
operator|,
name|iResult
operator|)
argument_list|)
expr_stmt|;
name|Tcl_SetLongObj
argument_list|(
name|valuePtr
argument_list|,
name|iResult
argument_list|)
expr_stmt|;
operator|++
name|stackTop
expr_stmt|;
comment|/* valuePtr now on stk top has right r.c. */
block|}
name|TclDecrRefCount
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
block|}
name|ADJUST_PC
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|INST_MOD
case|:
case|case
name|INST_LSHIFT
case|:
case|case
name|INST_RSHIFT
case|:
case|case
name|INST_BITOR
case|:
case|case
name|INST_BITXOR
case|:
case|case
name|INST_BITAND
case|:
block|{
comment|/* 		 * Only integers are allowed. We compute value op value2. 		 */
name|long
name|i2
decl_stmt|,
name|rem
decl_stmt|,
name|negative
decl_stmt|;
name|long
name|iResult
init|=
literal|0
decl_stmt|;
comment|/* Init. avoids compiler warning. */
name|value2Ptr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
if|if
condition|(
name|valuePtr
operator|->
name|typePtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
name|i
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
block|}
else|else
block|{
comment|/* try to convert to int */
name|result
operator|=
name|Tcl_GetLongFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"%s %.20s %.20s => ILLEGAL 1st TYPE %s\n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|,
name|O2S
argument_list|(
name|value2Ptr
argument_list|)
operator|,
operator|(
name|valuePtr
operator|->
name|typePtr
condition|?
name|valuePtr
operator|->
name|typePtr
operator|->
name|name
else|:
literal|"null"
operator|)
operator|)
argument_list|)
expr_stmt|;
name|IllegalExprOperandType
argument_list|(
name|interp
argument_list|,
name|opCode
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
block|}
if|if
condition|(
name|value2Ptr
operator|->
name|typePtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
name|i2
operator|=
name|value2Ptr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_GetLongFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|value2Ptr
argument_list|,
operator|&
name|i2
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"%s %.20s %.20s => ILLEGAL 2nd TYPE %s\n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|,
name|O2S
argument_list|(
name|value2Ptr
argument_list|)
operator|,
operator|(
name|value2Ptr
operator|->
name|typePtr
condition|?
name|value2Ptr
operator|->
name|typePtr
operator|->
name|name
else|:
literal|"null"
operator|)
operator|)
argument_list|)
expr_stmt|;
name|IllegalExprOperandType
argument_list|(
name|interp
argument_list|,
name|opCode
argument_list|,
name|value2Ptr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
block|}
switch|switch
condition|(
name|opCode
condition|)
block|{
case|case
name|INST_MOD
case|:
comment|/* 		     * This code is tricky: C doesn't guarantee much about 		     * the quotient or remainder, but Tcl does. The 		     * remainder always has the same sign as the divisor and 		     * a smaller absolute value. 		     */
if|if
condition|(
name|i2
operator|==
literal|0
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"mod %ld %ld => DIVIDE BY ZERO\n"
operator|,
name|i
operator|,
name|i2
operator|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
goto|goto
name|divideByZero
goto|;
block|}
name|negative
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i2
operator|<
literal|0
condition|)
block|{
name|i2
operator|=
operator|-
name|i2
expr_stmt|;
name|i
operator|=
operator|-
name|i
expr_stmt|;
name|negative
operator|=
literal|1
expr_stmt|;
block|}
name|rem
operator|=
name|i
operator|%
name|i2
expr_stmt|;
if|if
condition|(
name|rem
operator|<
literal|0
condition|)
block|{
name|rem
operator|+=
name|i2
expr_stmt|;
block|}
if|if
condition|(
name|negative
condition|)
block|{
name|rem
operator|=
operator|-
name|rem
expr_stmt|;
block|}
name|iResult
operator|=
name|rem
expr_stmt|;
break|break;
case|case
name|INST_LSHIFT
case|:
name|iResult
operator|=
name|i
operator|<<
name|i2
expr_stmt|;
break|break;
case|case
name|INST_RSHIFT
case|:
comment|/* 		     * The following code is a bit tricky: it ensures that 		     * right shifts propagate the sign bit even on machines 		     * where ">>" won't do it by default. 		     */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|iResult
operator|=
operator|~
operator|(
operator|(
operator|~
name|i
operator|)
operator|>>
name|i2
operator|)
expr_stmt|;
block|}
else|else
block|{
name|iResult
operator|=
name|i
operator|>>
name|i2
expr_stmt|;
block|}
break|break;
case|case
name|INST_BITOR
case|:
name|iResult
operator|=
name|i
operator||
name|i2
expr_stmt|;
break|break;
case|case
name|INST_BITXOR
case|:
name|iResult
operator|=
name|i
operator|^
name|i2
expr_stmt|;
break|break;
case|case
name|INST_BITAND
case|:
name|iResult
operator|=
name|i
operator|&
name|i2
expr_stmt|;
break|break;
block|}
comment|/* 		 * Reuse the valuePtr object already on stack if possible. 		 */
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|valuePtr
argument_list|)
condition|)
block|{
name|PUSH_OBJECT
argument_list|(
name|Tcl_NewLongObj
argument_list|(
name|iResult
argument_list|)
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"%s %ld %ld => %ld\n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|i
operator|,
name|i2
operator|,
name|iResult
operator|)
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* reuse the valuePtr object */
name|TRACE
argument_list|(
operator|(
literal|"%s %ld %ld => %ld\n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|i
operator|,
name|i2
operator|,
name|iResult
operator|)
argument_list|)
expr_stmt|;
comment|/* NB: stack top is off by 1 */
name|Tcl_SetLongObj
argument_list|(
name|valuePtr
argument_list|,
name|iResult
argument_list|)
expr_stmt|;
operator|++
name|stackTop
expr_stmt|;
comment|/* valuePtr now on stk top has right r.c. */
block|}
name|TclDecrRefCount
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
block|}
name|ADJUST_PC
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|INST_ADD
case|:
case|case
name|INST_SUB
case|:
case|case
name|INST_MULT
case|:
case|case
name|INST_DIV
case|:
block|{
comment|/* 		 * Operands must be numeric and ints get converted to floats 		 * if necessary. We compute value op value2. 		 */
name|Tcl_ObjType
modifier|*
name|t1Ptr
decl_stmt|,
modifier|*
name|t2Ptr
decl_stmt|;
name|long
name|i2
decl_stmt|,
name|quot
decl_stmt|,
name|rem
decl_stmt|;
name|double
name|d1
decl_stmt|,
name|d2
decl_stmt|;
name|long
name|iResult
init|=
literal|0
decl_stmt|;
comment|/* Init. avoids compiler warning. */
name|double
name|dResult
init|=
literal|0.0
decl_stmt|;
comment|/* Init. avoids compiler warning. */
name|int
name|doDouble
init|=
literal|0
decl_stmt|;
comment|/* 1 if doing floating arithmetic */
name|value2Ptr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|t1Ptr
operator|=
name|valuePtr
operator|->
name|typePtr
expr_stmt|;
name|t2Ptr
operator|=
name|value2Ptr
operator|->
name|typePtr
expr_stmt|;
if|if
condition|(
name|t1Ptr
operator|==
operator|&
name|tclIntType
condition|)
block|{
name|i
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t1Ptr
operator|==
operator|&
name|tclDoubleType
condition|)
block|{
name|d1
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|doubleValue
expr_stmt|;
block|}
else|else
block|{
comment|/* try to convert; FAILS IF NULLS */
name|char
modifier|*
name|s
init|=
name|Tcl_GetStringFromObj
argument_list|(
name|valuePtr
argument_list|,
operator|&
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|TclLooksLikeInt
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|result
operator|=
name|Tcl_GetLongFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_GetDoubleFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|d1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"%s %.20s %.20s => ILLEGAL 1st TYPE %s\n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|s
operator|,
name|O2S
argument_list|(
name|value2Ptr
argument_list|)
operator|,
operator|(
name|valuePtr
operator|->
name|typePtr
condition|?
name|valuePtr
operator|->
name|typePtr
operator|->
name|name
else|:
literal|"null"
operator|)
operator|)
argument_list|)
expr_stmt|;
name|IllegalExprOperandType
argument_list|(
name|interp
argument_list|,
name|opCode
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
name|t1Ptr
operator|=
name|valuePtr
operator|->
name|typePtr
expr_stmt|;
block|}
if|if
condition|(
name|t2Ptr
operator|==
operator|&
name|tclIntType
condition|)
block|{
name|i2
operator|=
name|value2Ptr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t2Ptr
operator|==
operator|&
name|tclDoubleType
condition|)
block|{
name|d2
operator|=
name|value2Ptr
operator|->
name|internalRep
operator|.
name|doubleValue
expr_stmt|;
block|}
else|else
block|{
comment|/* try to convert; FAILS IF NULLS */
name|char
modifier|*
name|s
init|=
name|Tcl_GetStringFromObj
argument_list|(
name|value2Ptr
argument_list|,
operator|&
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|TclLooksLikeInt
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|result
operator|=
name|Tcl_GetLongFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|value2Ptr
argument_list|,
operator|&
name|i2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_GetDoubleFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|value2Ptr
argument_list|,
operator|&
name|d2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"%s %.20s %.20s => ILLEGAL 2nd TYPE %s\n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|,
name|s
operator|,
operator|(
name|value2Ptr
operator|->
name|typePtr
condition|?
name|value2Ptr
operator|->
name|typePtr
operator|->
name|name
else|:
literal|"null"
operator|)
operator|)
argument_list|)
expr_stmt|;
name|IllegalExprOperandType
argument_list|(
name|interp
argument_list|,
name|opCode
argument_list|,
name|value2Ptr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
name|t2Ptr
operator|=
name|value2Ptr
operator|->
name|typePtr
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|t1Ptr
operator|==
operator|&
name|tclDoubleType
operator|)
operator|||
operator|(
name|t2Ptr
operator|==
operator|&
name|tclDoubleType
operator|)
condition|)
block|{
comment|/* 		     * Do double arithmetic. 		     */
name|doDouble
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|t1Ptr
operator|==
operator|&
name|tclIntType
condition|)
block|{
name|d1
operator|=
name|i
expr_stmt|;
comment|/* promote value 1 to double */
block|}
elseif|else
if|if
condition|(
name|t2Ptr
operator|==
operator|&
name|tclIntType
condition|)
block|{
name|d2
operator|=
name|i2
expr_stmt|;
comment|/* promote value 2 to double */
block|}
switch|switch
condition|(
name|opCode
condition|)
block|{
case|case
name|INST_ADD
case|:
name|dResult
operator|=
name|d1
operator|+
name|d2
expr_stmt|;
break|break;
case|case
name|INST_SUB
case|:
name|dResult
operator|=
name|d1
operator|-
name|d2
expr_stmt|;
break|break;
case|case
name|INST_MULT
case|:
name|dResult
operator|=
name|d1
operator|*
name|d2
expr_stmt|;
break|break;
case|case
name|INST_DIV
case|:
if|if
condition|(
name|d2
operator|==
literal|0.0
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"div %.6g %.6g => DIVIDE BY ZERO\n"
operator|,
name|d1
operator|,
name|d2
operator|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
goto|goto
name|divideByZero
goto|;
block|}
name|dResult
operator|=
name|d1
operator|/
name|d2
expr_stmt|;
break|break;
block|}
comment|/* 		     * Check now for IEEE floating-point error. 		     */
if|if
condition|(
name|IS_NAN
argument_list|(
name|dResult
argument_list|)
operator|||
name|IS_INF
argument_list|(
name|dResult
argument_list|)
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"%s %.20s %.20s => IEEE FLOATING PT ERROR\n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|,
name|O2S
argument_list|(
name|value2Ptr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|TclExprFloatError
argument_list|(
name|interp
argument_list|,
name|dResult
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
block|}
else|else
block|{
comment|/* 		     * Do integer arithmetic. 		     */
switch|switch
condition|(
name|opCode
condition|)
block|{
case|case
name|INST_ADD
case|:
name|iResult
operator|=
name|i
operator|+
name|i2
expr_stmt|;
break|break;
case|case
name|INST_SUB
case|:
name|iResult
operator|=
name|i
operator|-
name|i2
expr_stmt|;
break|break;
case|case
name|INST_MULT
case|:
name|iResult
operator|=
name|i
operator|*
name|i2
expr_stmt|;
break|break;
case|case
name|INST_DIV
case|:
comment|/* 			 * This code is tricky: C doesn't guarantee much 			 * about the quotient or remainder, but Tcl does. 			 * The remainder always has the same sign as the 			 * divisor and a smaller absolute value. 			 */
if|if
condition|(
name|i2
operator|==
literal|0
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"div %ld %ld => DIVIDE BY ZERO\n"
operator|,
name|i
operator|,
name|i2
operator|)
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
goto|goto
name|divideByZero
goto|;
block|}
if|if
condition|(
name|i2
operator|<
literal|0
condition|)
block|{
name|i2
operator|=
operator|-
name|i2
expr_stmt|;
name|i
operator|=
operator|-
name|i
expr_stmt|;
block|}
name|quot
operator|=
name|i
operator|/
name|i2
expr_stmt|;
name|rem
operator|=
name|i
operator|%
name|i2
expr_stmt|;
if|if
condition|(
name|rem
operator|<
literal|0
condition|)
block|{
name|quot
operator|-=
literal|1
expr_stmt|;
block|}
name|iResult
operator|=
name|quot
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * Reuse the valuePtr object already on stack if possible. 		 */
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|valuePtr
argument_list|)
condition|)
block|{
if|if
condition|(
name|doDouble
condition|)
block|{
name|PUSH_OBJECT
argument_list|(
name|Tcl_NewDoubleObj
argument_list|(
name|dResult
argument_list|)
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"%s %.6g %.6g => %.6g\n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|d1
operator|,
name|d2
operator|,
name|dResult
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUSH_OBJECT
argument_list|(
name|Tcl_NewLongObj
argument_list|(
name|iResult
argument_list|)
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"%s %ld %ld => %ld\n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|i
operator|,
name|i2
operator|,
name|iResult
operator|)
argument_list|)
expr_stmt|;
block|}
name|TclDecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* reuse the valuePtr object */
if|if
condition|(
name|doDouble
condition|)
block|{
comment|/* NB: stack top is off by 1 */
name|TRACE
argument_list|(
operator|(
literal|"%s %.6g %.6g => %.6g\n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|d1
operator|,
name|d2
operator|,
name|dResult
operator|)
argument_list|)
expr_stmt|;
name|Tcl_SetDoubleObj
argument_list|(
name|valuePtr
argument_list|,
name|dResult
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TRACE
argument_list|(
operator|(
literal|"%s %ld %ld => %ld\n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|i
operator|,
name|i2
operator|,
name|iResult
operator|)
argument_list|)
expr_stmt|;
name|Tcl_SetLongObj
argument_list|(
name|valuePtr
argument_list|,
name|iResult
argument_list|)
expr_stmt|;
block|}
operator|++
name|stackTop
expr_stmt|;
comment|/* valuePtr now on stk top has right r.c. */
block|}
name|TclDecrRefCount
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
block|}
name|ADJUST_PC
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|INST_UPLUS
case|:
block|{
comment|/* 	         * Operand must be numeric. 	         */
name|double
name|d
decl_stmt|;
name|Tcl_ObjType
modifier|*
name|tPtr
decl_stmt|;
name|valuePtr
operator|=
name|stackPtr
index|[
name|stackTop
index|]
operator|.
name|o
expr_stmt|;
name|tPtr
operator|=
name|valuePtr
operator|->
name|typePtr
expr_stmt|;
if|if
condition|(
operator|(
name|tPtr
operator|!=
operator|&
name|tclIntType
operator|)
operator|&&
operator|(
name|tPtr
operator|!=
operator|&
name|tclDoubleType
operator|)
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|Tcl_GetStringFromObj
argument_list|(
name|valuePtr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|TclLooksLikeInt
argument_list|(
name|s
argument_list|)
condition|)
block|{
comment|/* FAILS IF NULLS */
name|result
operator|=
name|Tcl_GetLongFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_GetDoubleFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"%s \"%.20s\" => ILLEGAL TYPE %s \n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|s
operator|,
operator|(
name|tPtr
condition|?
name|tPtr
operator|->
name|name
else|:
literal|"null"
operator|)
operator|)
argument_list|)
expr_stmt|;
name|IllegalExprOperandType
argument_list|(
name|interp
argument_list|,
name|opCode
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
block|}
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"uplus %s => "
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|)
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
block|}
name|ADJUST_PC
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|INST_UMINUS
case|:
case|case
name|INST_LNOT
case|:
block|{
comment|/* 		 * The operand must be numeric. If the operand object is 		 * unshared modify it directly, otherwise create a copy to 		 * modify: this is "copy on write". free any old string 		 * representation since it is now invalid. 		 */
name|double
name|d
decl_stmt|;
name|Tcl_ObjType
modifier|*
name|tPtr
decl_stmt|;
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|tPtr
operator|=
name|valuePtr
operator|->
name|typePtr
expr_stmt|;
if|if
condition|(
operator|(
name|tPtr
operator|!=
operator|&
name|tclIntType
operator|)
operator|&&
operator|(
name|tPtr
operator|!=
operator|&
name|tclDoubleType
operator|)
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|Tcl_GetStringFromObj
argument_list|(
name|valuePtr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|TclLooksLikeInt
argument_list|(
name|s
argument_list|)
condition|)
block|{
comment|/* FAILS IF NULLS */
name|result
operator|=
name|Tcl_GetLongFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_GetDoubleFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"%s \"%.20s\" => ILLEGAL TYPE %s\n"
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|s
operator|,
operator|(
name|tPtr
condition|?
name|tPtr
operator|->
name|name
else|:
literal|"null"
operator|)
operator|)
argument_list|)
expr_stmt|;
name|IllegalExprOperandType
argument_list|(
name|interp
argument_list|,
name|opCode
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
name|tPtr
operator|=
name|valuePtr
operator|->
name|typePtr
expr_stmt|;
block|}
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|valuePtr
argument_list|)
condition|)
block|{
comment|/* 		     * Create a new object. 		     */
if|if
condition|(
name|tPtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
name|i
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
name|objPtr
operator|=
name|Tcl_NewLongObj
argument_list|(
operator|(
name|opCode
operator|==
name|INST_UMINUS
operator|)
condition|?
operator|-
name|i
else|:
operator|!
name|i
argument_list|)
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"%s %ld => "
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|i
operator|)
argument_list|,
name|objPtr
argument_list|)
expr_stmt|;
comment|/* NB: stack top is off by 1 */
block|}
else|else
block|{
name|d
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|doubleValue
expr_stmt|;
if|if
condition|(
name|opCode
operator|==
name|INST_UMINUS
condition|)
block|{
name|objPtr
operator|=
name|Tcl_NewDoubleObj
argument_list|(
operator|-
name|d
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			     * Should be able to use "!d", but apparently 			     * some compilers can't handle it. 			     */
name|objPtr
operator|=
name|Tcl_NewLongObj
argument_list|(
operator|(
name|d
operator|==
literal|0.0
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"%s %.6g => "
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|d
operator|)
argument_list|,
name|objPtr
argument_list|)
expr_stmt|;
comment|/* NB: stack top is off by 1 */
block|}
name|PUSH_OBJECT
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		     * valuePtr is unshared. Modify it directly. 		     */
if|if
condition|(
name|tPtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
name|i
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
name|Tcl_SetLongObj
argument_list|(
name|valuePtr
argument_list|,
operator|(
name|opCode
operator|==
name|INST_UMINUS
operator|)
condition|?
operator|-
name|i
else|:
operator|!
name|i
argument_list|)
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"%s %ld => "
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|i
operator|)
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
comment|/* NB: stack top is off by 1 */
block|}
else|else
block|{
name|d
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|doubleValue
expr_stmt|;
if|if
condition|(
name|opCode
operator|==
name|INST_UMINUS
condition|)
block|{
name|Tcl_SetDoubleObj
argument_list|(
name|valuePtr
argument_list|,
operator|-
name|d
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			     * Should be able to use "!d", but apparently 			     * some compilers can't handle it. 			     */
name|Tcl_SetLongObj
argument_list|(
name|valuePtr
argument_list|,
operator|(
name|d
operator|==
literal|0.0
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"%s %.6g => "
operator|,
name|opName
index|[
name|opCode
index|]
operator|,
name|d
operator|)
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
comment|/* NB: stack top is off by 1 */
block|}
operator|++
name|stackTop
expr_stmt|;
comment|/* valuePtr now on stk top has right r.c. */
block|}
block|}
name|ADJUST_PC
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|INST_BITNOT
case|:
block|{
comment|/* 		 * The operand must be an integer. If the operand object is 		 * unshared modify it directly, otherwise modify a copy.  		 * Free any old string representation since it is now 		 * invalid. 		 */
name|Tcl_ObjType
modifier|*
name|tPtr
decl_stmt|;
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|tPtr
operator|=
name|valuePtr
operator|->
name|typePtr
expr_stmt|;
if|if
condition|(
name|tPtr
operator|!=
operator|&
name|tclIntType
condition|)
block|{
name|result
operator|=
name|Tcl_GetLongFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
comment|/* try to convert to double */
name|TRACE
argument_list|(
operator|(
literal|"bitnot \"%.20s\" => ILLEGAL TYPE %s\n"
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|,
operator|(
name|tPtr
condition|?
name|tPtr
operator|->
name|name
else|:
literal|"null"
operator|)
operator|)
argument_list|)
expr_stmt|;
name|IllegalExprOperandType
argument_list|(
name|interp
argument_list|,
name|opCode
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
block|}
name|i
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|valuePtr
argument_list|)
condition|)
block|{
name|PUSH_OBJECT
argument_list|(
name|Tcl_NewLongObj
argument_list|(
operator|~
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"bitnot 0x%lx => (%lu)\n"
operator|,
name|i
operator|,
operator|~
name|i
operator|)
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		     * valuePtr is unshared. Modify it directly. 		     */
name|Tcl_SetLongObj
argument_list|(
name|valuePtr
argument_list|,
operator|~
name|i
argument_list|)
expr_stmt|;
operator|++
name|stackTop
expr_stmt|;
comment|/* valuePtr now on stk top has right r.c. */
name|TRACE
argument_list|(
operator|(
literal|"bitnot 0x%lx => (%lu)\n"
operator|,
name|i
operator|,
operator|~
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ADJUST_PC
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|INST_CALL_BUILTIN_FUNC1
case|:
name|opnd
operator|=
name|TclGetUInt1AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
expr_stmt|;
block|{
comment|/* 		 * Call one of the built-in Tcl math functions. 		 */
name|BuiltinFunc
modifier|*
name|mathFuncPtr
decl_stmt|;
if|if
condition|(
operator|(
name|opnd
operator|<
literal|0
operator|)
operator|||
operator|(
name|opnd
operator|>
name|LAST_BUILTIN_FUNC
operator|)
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"UNRECOGNIZED BUILTIN FUNC CODE %d\n"
operator|,
name|opnd
operator|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"TclExecuteByteCode: unrecognized builtin function code %d"
argument_list|,
name|opnd
argument_list|)
expr_stmt|;
block|}
name|mathFuncPtr
operator|=
operator|&
operator|(
name|builtinFuncTable
index|[
name|opnd
index|]
operator|)
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
name|tcl_MathInProgress
operator|++
expr_stmt|;
name|result
operator|=
call|(
modifier|*
name|mathFuncPtr
operator|->
name|proc
call|)
argument_list|(
name|interp
argument_list|,
name|eePtr
argument_list|,
name|mathFuncPtr
operator|->
name|clientData
argument_list|)
expr_stmt|;
name|tcl_MathInProgress
operator|--
expr_stmt|;
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|checkForCatch
goto|;
block|}
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"callBuiltinFunc1 %d => "
operator|,
name|opnd
operator|)
argument_list|,
name|stackPtr
index|[
name|stackTop
index|]
operator|.
name|o
argument_list|)
expr_stmt|;
block|}
name|ADJUST_PC
argument_list|(
literal|2
argument_list|)
expr_stmt|;
case|case
name|INST_CALL_FUNC1
case|:
name|opnd
operator|=
name|TclGetUInt1AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
expr_stmt|;
block|{
comment|/* 		 * Call a non-builtin Tcl math function previously 		 * registered by a call to Tcl_CreateMathFunc. 		 */
name|int
name|objc
init|=
name|opnd
decl_stmt|;
comment|/* Number of arguments. The function name 				    * is the 0-th argument. */
name|Tcl_Obj
modifier|*
modifier|*
name|objv
decl_stmt|;
comment|/* The array of arguments. The function 				    * name is objv[0]. */
name|objv
operator|=
operator|&
operator|(
name|stackPtr
index|[
name|stackTop
operator|-
operator|(
name|objc
operator|-
literal|1
operator|)
index|]
operator|.
name|o
operator|)
expr_stmt|;
comment|/* "objv[0]" */
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
name|tcl_MathInProgress
operator|++
expr_stmt|;
name|result
operator|=
name|ExprCallMathFunc
argument_list|(
name|interp
argument_list|,
name|eePtr
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
name|tcl_MathInProgress
operator|--
expr_stmt|;
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|checkForCatch
goto|;
block|}
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"callFunc1 %d => "
operator|,
name|objc
operator|)
argument_list|,
name|stackPtr
index|[
name|stackTop
index|]
operator|.
name|o
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
case|case
name|INST_TRY_CVT_TO_NUMERIC
case|:
block|{
comment|/* 		 * Try to convert the topmost stack object to an int or 		 * double object. This is done in order to support Tcl's 		 * policy of interpreting operands if at all possible as 		 * first integers, else floating-point numbers. 		 */
name|double
name|d
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|Tcl_ObjType
modifier|*
name|tPtr
decl_stmt|;
name|int
name|converted
decl_stmt|,
name|shared
decl_stmt|;
name|valuePtr
operator|=
name|stackPtr
index|[
name|stackTop
index|]
operator|.
name|o
expr_stmt|;
name|tPtr
operator|=
name|valuePtr
operator|->
name|typePtr
expr_stmt|;
name|converted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|tPtr
operator|!=
operator|&
name|tclIntType
operator|)
operator|&&
operator|(
name|tPtr
operator|!=
operator|&
name|tclDoubleType
operator|)
condition|)
block|{
name|s
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|valuePtr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|TclLooksLikeInt
argument_list|(
name|s
argument_list|)
condition|)
block|{
comment|/* FAILS IF NULLS */
name|result
operator|=
name|Tcl_GetLongFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_GetDoubleFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
name|converted
operator|=
literal|1
expr_stmt|;
block|}
name|result
operator|=
name|TCL_OK
expr_stmt|;
comment|/* reset the result variable */
name|tPtr
operator|=
name|valuePtr
operator|->
name|typePtr
expr_stmt|;
block|}
comment|/* 		 * Ensure that the topmost stack object, if numeric, has a 		 * string rep the same as the formatted version of its 		 * internal rep. This is used, e.g., to make sure that "expr 		 * {0001}" yields "1", not "0001". We implement this by 		 * _discarding_ the string rep since we know it will be 		 * regenerated, if needed later, by formatting the internal 		 * rep's value. Also check if there has been an IEEE 		 * floating point error. 		 */
if|if
condition|(
operator|(
name|tPtr
operator|==
operator|&
name|tclIntType
operator|)
operator|||
operator|(
name|tPtr
operator|==
operator|&
name|tclDoubleType
operator|)
condition|)
block|{
name|shared
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|valuePtr
argument_list|)
condition|)
block|{
name|shared
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tPtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
name|i
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
name|objPtr
operator|=
name|Tcl_NewLongObj
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|doubleValue
expr_stmt|;
name|objPtr
operator|=
name|Tcl_NewDoubleObj
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
name|Tcl_IncrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|valuePtr
operator|=
name|objPtr
expr_stmt|;
name|tPtr
operator|=
name|valuePtr
operator|->
name|typePtr
expr_stmt|;
block|}
else|else
block|{
name|Tcl_InvalidateStringRep
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
block|}
name|stackPtr
index|[
name|stackTop
index|]
operator|.
name|o
operator|=
name|valuePtr
expr_stmt|;
if|if
condition|(
name|tPtr
operator|==
operator|&
name|tclDoubleType
condition|)
block|{
name|d
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|doubleValue
expr_stmt|;
if|if
condition|(
name|IS_NAN
argument_list|(
name|d
argument_list|)
operator|||
name|IS_INF
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"tryCvtToNumeric \"%.20s\" => IEEE FLOATING PT ERROR\n"
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|TclExprFloatError
argument_list|(
name|interp
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
block|}
name|shared
operator|=
name|shared
expr_stmt|;
comment|/* lint, shared not used. */
name|converted
operator|=
name|converted
expr_stmt|;
comment|/* lint, converted not used. */
name|TRACE
argument_list|(
operator|(
literal|"tryCvtToNumeric \"%.20s\" => numeric, %s, %s\n"
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|,
operator|(
name|converted
condition|?
literal|"converted"
else|:
literal|"not converted"
operator|)
operator|,
operator|(
name|shared
condition|?
literal|"shared"
else|:
literal|"not shared"
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TRACE
argument_list|(
operator|(
literal|"tryCvtToNumeric \"%.20s\" => not numeric\n"
operator|,
name|O2S
argument_list|(
name|valuePtr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ADJUST_PC
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|INST_BREAK
case|:
comment|/* 	     * First reset the interpreter's result. Then find the closest 	     * enclosing loop or catch exception range, if any. If a loop is 	     * found, terminate its execution. If the closest is a catch 	     * exception range, jump to its catchOffset. If no enclosing 	     * range is found, stop execution and return TCL_BREAK. 	     */
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|rangePtr
operator|=
name|TclGetExceptionRangeForPc
argument_list|(
name|pc
argument_list|,
comment|/*catchOnly*/
literal|0
argument_list|,
name|codePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rangePtr
operator|==
name|NULL
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"break => no encl. loop or catch, returning TCL_BREAK\n"
operator|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_BREAK
expr_stmt|;
goto|goto
name|abnormalReturn
goto|;
comment|/* no catch exists to check */
block|}
switch|switch
condition|(
name|rangePtr
operator|->
name|type
condition|)
block|{
case|case
name|LOOP_EXCEPTION_RANGE
case|:
name|result
operator|=
name|TCL_OK
expr_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"break => range at %d, new pc %d\n"
operator|,
name|rangePtr
operator|->
name|codeOffset
operator|,
name|rangePtr
operator|->
name|breakOffset
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CATCH_EXCEPTION_RANGE
case|:
name|result
operator|=
name|TCL_BREAK
expr_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"break => ...\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|processCatch
goto|;
comment|/* it will use rangePtr */
default|default:
name|panic
argument_list|(
literal|"TclExecuteByteCode: unrecognized ExceptionRange type %d\n"
argument_list|,
name|rangePtr
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
name|pc
operator|=
operator|(
name|codePtr
operator|->
name|codeStart
operator|+
name|rangePtr
operator|->
name|breakOffset
operator|)
expr_stmt|;
continue|continue;
comment|/* restart outer instruction loop at pc */
case|case
name|INST_CONTINUE
case|:
comment|/* 	     * Find the closest enclosing loop or catch exception range, 	     * if any. If a loop is found, skip to its next iteration. 	     * If the closest is a catch exception range, jump to its 	     * catchOffset. If no enclosing range is found, stop 	     * execution and return TCL_CONTINUE. 	     */
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|rangePtr
operator|=
name|TclGetExceptionRangeForPc
argument_list|(
name|pc
argument_list|,
comment|/*catchOnly*/
literal|0
argument_list|,
name|codePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rangePtr
operator|==
name|NULL
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"continue => no encl. loop or catch, returning TCL_CONTINUE\n"
operator|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_CONTINUE
expr_stmt|;
goto|goto
name|abnormalReturn
goto|;
block|}
switch|switch
condition|(
name|rangePtr
operator|->
name|type
condition|)
block|{
case|case
name|LOOP_EXCEPTION_RANGE
case|:
if|if
condition|(
name|rangePtr
operator|->
name|continueOffset
operator|==
operator|-
literal|1
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"continue => loop w/o continue, checking for catch\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
else|else
block|{
name|result
operator|=
name|TCL_OK
expr_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"continue => range at %d, new pc %d\n"
operator|,
name|rangePtr
operator|->
name|codeOffset
operator|,
name|rangePtr
operator|->
name|continueOffset
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CATCH_EXCEPTION_RANGE
case|:
name|result
operator|=
name|TCL_CONTINUE
expr_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"continue => ...\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|processCatch
goto|;
comment|/* it will use rangePtr */
default|default:
name|panic
argument_list|(
literal|"TclExecuteByteCode: unrecognized ExceptionRange type %d\n"
argument_list|,
name|rangePtr
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
name|pc
operator|=
operator|(
name|codePtr
operator|->
name|codeStart
operator|+
name|rangePtr
operator|->
name|continueOffset
operator|)
expr_stmt|;
continue|continue;
comment|/* restart outer instruction loop at pc */
case|case
name|INST_FOREACH_START4
case|:
name|opnd
operator|=
name|TclGetUInt4AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
expr_stmt|;
block|{
comment|/* 		 * Initialize the temporary local var that holds the count 		 * of the number of iterations of the loop body to -1. 		 */
name|ForeachInfo
modifier|*
name|infoPtr
init|=
operator|(
name|ForeachInfo
operator|*
operator|)
name|codePtr
operator|->
name|auxDataArrayPtr
index|[
name|opnd
index|]
operator|.
name|clientData
decl_stmt|;
name|int
name|iterTmpIndex
init|=
name|infoPtr
operator|->
name|loopIterNumTmp
decl_stmt|;
name|CallFrame
modifier|*
name|varFramePtr
init|=
name|iPtr
operator|->
name|varFramePtr
decl_stmt|;
name|Var
modifier|*
name|compiledLocals
init|=
name|varFramePtr
operator|->
name|compiledLocals
decl_stmt|;
name|Var
modifier|*
name|iterVarPtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|oldValuePtr
decl_stmt|;
name|iterVarPtr
operator|=
operator|&
operator|(
name|compiledLocals
index|[
name|iterTmpIndex
index|]
operator|)
expr_stmt|;
name|oldValuePtr
operator|=
name|iterVarPtr
operator|->
name|value
operator|.
name|objPtr
expr_stmt|;
if|if
condition|(
name|oldValuePtr
operator|==
name|NULL
condition|)
block|{
name|iterVarPtr
operator|->
name|value
operator|.
name|objPtr
operator|=
name|Tcl_NewLongObj
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|iterVarPtr
operator|->
name|value
operator|.
name|objPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldValuePtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|oldValuePtr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Tcl_SetLongObj
argument_list|(
name|oldValuePtr
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|TclSetVarScalar
argument_list|(
name|iterVarPtr
argument_list|)
expr_stmt|;
name|TclClearVarUndefined
argument_list|(
name|iterVarPtr
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"foreach_start4 %u => loop iter count temp %d\n"
operator|,
name|opnd
operator|,
name|iterTmpIndex
operator|)
argument_list|)
expr_stmt|;
block|}
name|ADJUST_PC
argument_list|(
literal|5
argument_list|)
expr_stmt|;
case|case
name|INST_FOREACH_STEP4
case|:
name|opnd
operator|=
name|TclGetUInt4AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
expr_stmt|;
block|{
comment|/* 		 * "Step" a foreach loop (i.e., begin its next iteration) by 		 * assigning the next value list element to each loop var. 		 */
name|ForeachInfo
modifier|*
name|infoPtr
init|=
operator|(
name|ForeachInfo
operator|*
operator|)
name|codePtr
operator|->
name|auxDataArrayPtr
index|[
name|opnd
index|]
operator|.
name|clientData
decl_stmt|;
name|ForeachVarList
modifier|*
name|varListPtr
decl_stmt|;
name|int
name|numLists
init|=
name|infoPtr
operator|->
name|numLists
decl_stmt|;
name|int
name|iterTmpIndex
init|=
name|infoPtr
operator|->
name|loopIterNumTmp
decl_stmt|;
name|CallFrame
modifier|*
name|varFramePtr
init|=
name|iPtr
operator|->
name|varFramePtr
decl_stmt|;
name|Var
modifier|*
name|compiledLocals
init|=
name|varFramePtr
operator|->
name|compiledLocals
decl_stmt|;
name|int
name|iterNum
decl_stmt|,
name|listTmpIndex
decl_stmt|,
name|listLen
decl_stmt|,
name|numVars
decl_stmt|;
name|int
name|varIndex
decl_stmt|,
name|valIndex
decl_stmt|,
name|j
decl_stmt|;
name|Tcl_Obj
modifier|*
name|listPtr
decl_stmt|,
modifier|*
name|elemPtr
decl_stmt|,
modifier|*
name|oldValuePtr
decl_stmt|;
name|List
modifier|*
name|listRepPtr
decl_stmt|;
name|Var
modifier|*
name|iterVarPtr
decl_stmt|,
modifier|*
name|listVarPtr
decl_stmt|;
name|int
name|continueLoop
init|=
literal|0
decl_stmt|;
comment|/* 		 * Increment the temp holding the loop iteration number. 		 */
name|iterVarPtr
operator|=
operator|&
operator|(
name|compiledLocals
index|[
name|iterTmpIndex
index|]
operator|)
expr_stmt|;
name|oldValuePtr
operator|=
name|iterVarPtr
operator|->
name|value
operator|.
name|objPtr
expr_stmt|;
name|iterNum
operator|=
operator|(
name|oldValuePtr
operator|->
name|internalRep
operator|.
name|longValue
operator|+
literal|1
operator|)
expr_stmt|;
name|Tcl_SetLongObj
argument_list|(
name|oldValuePtr
argument_list|,
name|iterNum
argument_list|)
expr_stmt|;
comment|/* 		 * Check whether all value lists are exhausted and we should 		 * stop the loop. 		 */
name|listTmpIndex
operator|=
name|infoPtr
operator|->
name|firstListTmp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numLists
condition|;
name|i
operator|++
control|)
block|{
name|varListPtr
operator|=
name|infoPtr
operator|->
name|varLists
index|[
name|i
index|]
expr_stmt|;
name|numVars
operator|=
name|varListPtr
operator|->
name|numVars
expr_stmt|;
name|listVarPtr
operator|=
operator|&
operator|(
name|compiledLocals
index|[
name|listTmpIndex
index|]
operator|)
expr_stmt|;
name|listPtr
operator|=
name|listVarPtr
operator|->
name|value
operator|.
name|objPtr
expr_stmt|;
name|result
operator|=
name|Tcl_ListObjLength
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
operator|&
name|listLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"foreach_step4 %u => ERROR converting list %ld, \"%s\": "
operator|,
name|opnd
operator|,
name|i
operator|,
name|O2S
argument_list|(
name|listPtr
argument_list|)
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
if|if
condition|(
name|listLen
operator|>
operator|(
name|iterNum
operator|*
name|numVars
operator|)
condition|)
block|{
name|continueLoop
operator|=
literal|1
expr_stmt|;
block|}
name|listTmpIndex
operator|++
expr_stmt|;
block|}
comment|/* 		 * If some var in some var list still has a remaining list 		 * element iterate one more time. Assign to var the next 		 * element from its value list. We already checked above 		 * that each list temp holds a valid list object. 		 */
if|if
condition|(
name|continueLoop
condition|)
block|{
name|listTmpIndex
operator|=
name|infoPtr
operator|->
name|firstListTmp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numLists
condition|;
name|i
operator|++
control|)
block|{
name|varListPtr
operator|=
name|infoPtr
operator|->
name|varLists
index|[
name|i
index|]
expr_stmt|;
name|numVars
operator|=
name|varListPtr
operator|->
name|numVars
expr_stmt|;
name|listVarPtr
operator|=
operator|&
operator|(
name|compiledLocals
index|[
name|listTmpIndex
index|]
operator|)
expr_stmt|;
name|listPtr
operator|=
name|listVarPtr
operator|->
name|value
operator|.
name|objPtr
expr_stmt|;
name|listRepPtr
operator|=
operator|(
name|List
operator|*
operator|)
name|listPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
expr_stmt|;
name|listLen
operator|=
name|listRepPtr
operator|->
name|elemCount
expr_stmt|;
name|valIndex
operator|=
operator|(
name|iterNum
operator|*
name|numVars
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numVars
condition|;
name|j
operator|++
control|)
block|{
name|int
name|setEmptyStr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|valIndex
operator|>=
name|listLen
condition|)
block|{
name|setEmptyStr
operator|=
literal|1
expr_stmt|;
name|elemPtr
operator|=
name|Tcl_NewObj
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|elemPtr
operator|=
name|listRepPtr
operator|->
name|elements
index|[
name|valIndex
index|]
expr_stmt|;
block|}
name|varIndex
operator|=
name|varListPtr
operator|->
name|varIndexes
index|[
name|j
index|]
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
name|value2Ptr
operator|=
name|TclSetIndexedScalar
argument_list|(
name|interp
argument_list|,
name|varIndex
argument_list|,
name|elemPtr
argument_list|,
comment|/*leaveErrorMsg*/
literal|1
argument_list|)
expr_stmt|;
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
if|if
condition|(
name|value2Ptr
operator|==
name|NULL
condition|)
block|{
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"foreach_step4 %u => ERROR init. index temp %d: "
operator|,
name|opnd
operator|,
name|varIndex
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setEmptyStr
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|elemPtr
argument_list|)
expr_stmt|;
comment|/* unneeded */
block|}
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|checkForCatch
goto|;
block|}
name|valIndex
operator|++
expr_stmt|;
block|}
name|listTmpIndex
operator|++
expr_stmt|;
block|}
block|}
comment|/* 		 * Now push a "1" object if at least one value list had a 		 * remaining element and the loop should continue. 		 * Otherwise push "0". 		 */
name|PUSH_OBJECT
argument_list|(
name|Tcl_NewLongObj
argument_list|(
name|continueLoop
argument_list|)
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"foreach_step4 %u => %d lists, iter %d, %s loop\n"
operator|,
name|opnd
operator|,
name|numLists
operator|,
name|iterNum
operator|,
operator|(
name|continueLoop
condition|?
literal|"continue"
else|:
literal|"exit"
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|ADJUST_PC
argument_list|(
literal|5
argument_list|)
expr_stmt|;
case|case
name|INST_BEGIN_CATCH4
case|:
comment|/* 	     * Record start of the catch command with exception range index 	     * equal to the operand. Push the current stack depth onto the 	     * special catch stack. 	     */
name|catchStackPtr
index|[
operator|++
name|catchTop
index|]
operator|=
name|stackTop
expr_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"beginCatch4 %u => catchTop=%d, stackTop=%d\n"
operator|,
name|TclGetUInt4AtPtr
argument_list|(
name|pc
operator|+
literal|1
argument_list|)
operator|,
name|catchTop
operator|,
name|stackTop
operator|)
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
literal|5
argument_list|)
expr_stmt|;
case|case
name|INST_END_CATCH
case|:
name|catchTop
operator|--
expr_stmt|;
name|result
operator|=
name|TCL_OK
expr_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"endCatch => catchTop=%d\n"
operator|,
name|catchTop
operator|)
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|INST_PUSH_RESULT
case|:
name|PUSH_OBJECT
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|TRACE_WITH_OBJ
argument_list|(
operator|(
literal|"pushResult => "
operator|)
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|INST_PUSH_RETURN_CODE
case|:
name|PUSH_OBJECT
argument_list|(
name|Tcl_NewLongObj
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"pushReturnCode => %u\n"
operator|,
name|result
operator|)
argument_list|)
expr_stmt|;
name|ADJUST_PC
argument_list|(
literal|1
argument_list|)
expr_stmt|;
default|default:
name|TRACE
argument_list|(
operator|(
literal|"UNRECOGNIZED INSTRUCTION %u\n"
operator|,
name|opCode
operator|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"TclExecuteByteCode: unrecognized opCode %u"
argument_list|,
name|opCode
argument_list|)
expr_stmt|;
block|}
comment|/* end of switch on opCode */
comment|/* 	 * Division by zero in an expression. Control only reaches this 	 * point by "goto divideByZero". 	 */
name|divideByZero
label|:
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"divide by zero"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"ARITH"
argument_list|,
literal|"DIVZERO"
argument_list|,
literal|"divide by zero"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
comment|/* 	 * Execution has generated an "exception" such as TCL_ERROR. If the 	 * exception is an error, record information about what was being 	 * executed when the error occurred. Find the closest enclosing 	 * catch range, if any. If no enclosing catch range is found, stop 	 * execution and return the "exception" code. 	 */
name|checkForCatch
label|:
if|if
condition|(
operator|(
name|result
operator|==
name|TCL_ERROR
operator|)
operator|&&
operator|!
operator|(
name|iPtr
operator|->
name|flags
operator|&
name|ERR_ALREADY_LOGGED
operator|)
condition|)
block|{
name|RecordTracebackInfo
argument_list|(
name|interp
argument_list|,
name|pc
argument_list|,
name|codePtr
argument_list|)
expr_stmt|;
block|}
name|rangePtr
operator|=
name|TclGetExceptionRangeForPc
argument_list|(
name|pc
argument_list|,
comment|/*catchOnly*/
literal|1
argument_list|,
name|codePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rangePtr
operator|==
name|NULL
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"   ... no enclosing catch, returning %s\n"
operator|,
name|StringForResultCode
argument_list|(
name|result
argument_list|)
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|abnormalReturn
goto|;
block|}
comment|/* 	 * A catch exception range (rangePtr) was found to handle an 	 * "exception". It was found either by checkForCatch just above or 	 * by an instruction during break, continue, or error processing. 	 * Jump to its catchOffset after unwinding the operand stack to 	 * the depth it had when starting to execute the range's catch 	 * command. 	 */
name|processCatch
label|:
while|while
condition|(
name|stackTop
operator|>
name|catchStackPtr
index|[
name|catchTop
index|]
condition|)
block|{
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
block|}
name|TRACE
argument_list|(
operator|(
literal|"  ... found catch at %d, catchTop=%d, unwound to %d, new pc %u\n"
operator|,
name|rangePtr
operator|->
name|codeOffset
operator|,
name|catchTop
operator|,
name|catchStackPtr
index|[
name|catchTop
index|]
operator|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|rangePtr
operator|->
name|catchOffset
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|pc
operator|=
operator|(
name|codePtr
operator|->
name|codeStart
operator|+
name|rangePtr
operator|->
name|catchOffset
operator|)
expr_stmt|;
continue|continue;
comment|/* restart the execution loop at pc */
block|}
comment|/* end of infinite loop dispatching on instructions */
comment|/*      * Abnormal return code. Restore the stack to state it had when starting      * to execute the ByteCode.      */
name|abnormalReturn
label|:
while|while
condition|(
name|stackTop
operator|>
name|initStackTop
condition|)
block|{
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * Free the catch stack array if malloc'ed storage was used.      */
name|done
label|:
if|if
condition|(
name|catchStackPtr
operator|!=
name|catchStackStorage
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|catchStackPtr
argument_list|)
expr_stmt|;
block|}
name|eePtr
operator|->
name|stackTop
operator|=
name|initStackTop
expr_stmt|;
return|return
name|result
return|;
undef|#
directive|undef
name|STATIC_CATCH_STACK_SIZE
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * PrintByteCodeInfo --  *  *	This procedure prints a summary about a bytecode object to stdout.  *	It is called by TclExecuteByteCode when starting to execute the  *	bytecode object if tclTraceExec has the value 2 or more.  *  * Results:  *	None.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|PrintByteCodeInfo
parameter_list|(
name|codePtr
parameter_list|)
specifier|register
name|ByteCode
modifier|*
name|codePtr
decl_stmt|;
comment|/* The bytecode whose summary is printed 				 * to stdout. */
block|{
name|Proc
modifier|*
name|procPtr
init|=
name|codePtr
operator|->
name|procPtr
decl_stmt|;
name|int
name|numCmds
init|=
name|codePtr
operator|->
name|numCommands
decl_stmt|;
name|int
name|numObjs
init|=
name|codePtr
operator|->
name|numObjects
decl_stmt|;
name|int
name|objBytes
decl_stmt|,
name|i
decl_stmt|;
name|objBytes
operator|=
operator|(
name|numObjs
operator|*
sizeof|sizeof
argument_list|(
name|Tcl_Obj
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numObjs
condition|;
name|i
operator|++
control|)
block|{
name|Tcl_Obj
modifier|*
name|litObjPtr
init|=
name|codePtr
operator|->
name|objArrayPtr
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|litObjPtr
operator|->
name|bytes
operator|!=
name|NULL
condition|)
block|{
name|objBytes
operator|+=
name|litObjPtr
operator|->
name|length
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\nExecuting ByteCode 0x%x, ref ct %u, epoch %u, interp 0x%x(epoch %u)\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|codePtr
argument_list|,
name|codePtr
operator|->
name|refCount
argument_list|,
name|codePtr
operator|->
name|compileEpoch
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|codePtr
operator|->
name|iPtr
argument_list|,
name|codePtr
operator|->
name|iPtr
operator|->
name|compileEpoch
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"  Source: "
argument_list|)
expr_stmt|;
name|TclPrintSource
argument_list|(
name|stdout
argument_list|,
name|codePtr
operator|->
name|source
argument_list|,
literal|70
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n  Cmds %d, chars %d, inst %u, objs %u, aux %d, stk depth %u, code/src %.2fn"
argument_list|,
name|numCmds
argument_list|,
name|codePtr
operator|->
name|numSrcChars
argument_list|,
name|codePtr
operator|->
name|numCodeBytes
argument_list|,
name|numObjs
argument_list|,
name|codePtr
operator|->
name|numAuxDataItems
argument_list|,
name|codePtr
operator|->
name|maxStackDepth
argument_list|,
operator|(
name|codePtr
operator|->
name|numSrcChars
condition|?
operator|(
operator|(
name|float
operator|)
name|codePtr
operator|->
name|totalSize
operator|)
operator|/
operator|(
operator|(
name|float
operator|)
name|codePtr
operator|->
name|numSrcChars
operator|)
else|:
literal|0.0
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"  Code %d = %d(header)+%d(inst)+%d(objs)+%d(exc)+%d(aux)+%d(cmd map)\n"
argument_list|,
name|codePtr
operator|->
name|totalSize
argument_list|,
sizeof|sizeof
argument_list|(
name|ByteCode
argument_list|)
argument_list|,
name|codePtr
operator|->
name|numCodeBytes
argument_list|,
name|objBytes
argument_list|,
operator|(
name|codePtr
operator|->
name|numExcRanges
operator|*
sizeof|sizeof
argument_list|(
name|ExceptionRange
argument_list|)
operator|)
argument_list|,
operator|(
name|codePtr
operator|->
name|numAuxDataItems
operator|*
sizeof|sizeof
argument_list|(
name|AuxData
argument_list|)
operator|)
argument_list|,
name|codePtr
operator|->
name|numCmdLocBytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|procPtr
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"  Proc 0x%x, ref ct %d, args %d, compiled locals %d\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|procPtr
argument_list|,
name|procPtr
operator|->
name|refCount
argument_list|,
name|procPtr
operator|->
name|numArgs
argument_list|,
name|procPtr
operator|->
name|numCompiledLocals
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * ValidatePcAndStackTop --  *  *	This procedure is called by TclExecuteByteCode when debugging to  *	verify that the program counter and stack top are valid during  *	execution.  *  * Results:  *	None.  *  * Side effects:  *	Prints a message to stderr and panics if either the pc or stack  *	top are invalid.  *  *----------------------------------------------------------------------  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|ValidatePcAndStackTop
parameter_list|(
name|codePtr
parameter_list|,
name|pc
parameter_list|,
name|stackTop
parameter_list|,
name|stackLowerBound
parameter_list|,
name|stackUpperBound
parameter_list|)
specifier|register
name|ByteCode
modifier|*
name|codePtr
decl_stmt|;
comment|/* The bytecode whose summary is printed 				 * to stdout. */
name|unsigned
name|char
modifier|*
name|pc
decl_stmt|;
comment|/* Points to first byte of a bytecode 				 * instruction. The program counter. */
name|int
name|stackTop
decl_stmt|;
comment|/* Current stack top. Must be between 				 * stackLowerBound and stackUpperBound 				 * (inclusive). */
name|int
name|stackLowerBound
decl_stmt|;
comment|/* Smallest legal value for stackTop. */
name|int
name|stackUpperBound
decl_stmt|;
comment|/* Greatest legal value for stackTop. */
block|{
name|unsigned
name|int
name|relativePc
init|=
call|(
name|unsigned
name|int
call|)
argument_list|(
name|pc
operator|-
name|codePtr
operator|->
name|codeStart
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|codeStart
init|=
operator|(
name|unsigned
name|int
operator|)
name|codePtr
operator|->
name|codeStart
decl_stmt|;
name|unsigned
name|int
name|codeEnd
init|=
call|(
name|unsigned
name|int
call|)
argument_list|(
name|codePtr
operator|->
name|codeStart
operator|+
name|codePtr
operator|->
name|numCodeBytes
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|opCode
init|=
operator|*
name|pc
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|unsigned
name|int
operator|)
name|pc
operator|<
name|codeStart
operator|)
operator|||
operator|(
operator|(
name|unsigned
name|int
operator|)
name|pc
operator|>
name|codeEnd
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nBad instruction pc 0x%x in TclExecuteByteCode\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|pc
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"TclExecuteByteCode execution failure: bad pc"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|opCode
operator|>
name|LAST_INST_OPCODE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nBad opcode %d at pc %u in TclExecuteByteCode\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|opCode
argument_list|,
name|relativePc
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"TclExecuteByteCode execution failure: bad opcode"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stackTop
operator|<
name|stackLowerBound
operator|)
operator|||
operator|(
name|stackTop
operator|>
name|stackUpperBound
operator|)
condition|)
block|{
name|int
name|numChars
decl_stmt|;
name|char
modifier|*
name|cmd
init|=
name|GetSrcInfoForPc
argument_list|(
name|pc
argument_list|,
name|codePtr
argument_list|,
operator|&
name|numChars
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ellipsis
init|=
literal|""
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nBad stack top %d at pc %u in TclExecuteByteCode"
argument_list|,
name|stackTop
argument_list|,
name|relativePc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|numChars
operator|>
literal|100
condition|)
block|{
name|numChars
operator|=
literal|100
expr_stmt|;
name|ellipsis
operator|=
literal|"..."
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n executing %.*s%s\n"
argument_list|,
name|numChars
argument_list|,
name|cmd
argument_list|,
name|ellipsis
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|panic
argument_list|(
literal|"TclExecuteByteCode execution failure: bad stack top"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_COMPILE_DEBUG */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * IllegalExprOperandType --  *  *	Used by TclExecuteByteCode to add an error message to errorInfo  *	when an illegal operand type is detected by an expression  *	instruction. The argument opCode holds the failing instruction's  *	opcode and opndPtr holds the operand object in error.  *  * Results:  *	None.  *  * Side effects:  *	An error message is appended to errorInfo.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|IllegalExprOperandType
parameter_list|(
name|interp
parameter_list|,
name|opCode
parameter_list|,
name|opndPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to which error information 				 * pertains. */
name|unsigned
name|int
name|opCode
decl_stmt|;
comment|/* The instruction opcode being executed 				 * when the illegal type was found. */
name|Tcl_Obj
modifier|*
name|opndPtr
decl_stmt|;
comment|/* Points to the operand holding the value 				 * with the illegal type. */
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opndPtr
operator|->
name|bytes
operator|==
name|NULL
operator|)
operator|||
operator|(
name|opndPtr
operator|->
name|length
operator|==
literal|0
operator|)
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"can't use empty string as operand of \""
argument_list|,
name|operatorStrings
index|[
name|opCode
operator|-
name|INST_LOR
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"can't use "
argument_list|,
operator|(
operator|(
name|opndPtr
operator|->
name|typePtr
operator|==
operator|&
name|tclDoubleType
operator|)
condition|?
literal|"floating-point value"
else|:
literal|"non-numeric string"
operator|)
argument_list|,
literal|" as operand of \""
argument_list|,
name|operatorStrings
index|[
name|opCode
operator|-
name|INST_LOR
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CallTraceProcedure --  *  *	Invokes a trace procedure registered with an interpreter. These  *	procedures trace command execution. Currently this trace procedure  *	is called with the address of the string-based Tcl_CmdProc for the  *	command, not the Tcl_ObjCmdProc.  *  * Results:  *	None.  *  * Side effects:  *	Those side effects made by the trace procedure.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|CallTraceProcedure
parameter_list|(
name|interp
parameter_list|,
name|tracePtr
parameter_list|,
name|cmdPtr
parameter_list|,
name|command
parameter_list|,
name|numChars
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The current interpreter. */
specifier|register
name|Trace
modifier|*
name|tracePtr
decl_stmt|;
comment|/* Describes the trace procedure to call. */
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
comment|/* Points to command's Command struct. */
name|char
modifier|*
name|command
decl_stmt|;
comment|/* Points to the first character of the 				 * command's source before substitutions. */
name|int
name|numChars
decl_stmt|;
comment|/* The number of characters in the 				 * command's source. */
specifier|register
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments for the command. */
name|Tcl_Obj
modifier|*
name|objv
index|[]
decl_stmt|;
comment|/* Pointers to Tcl_Obj of each argument. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/*      * Get the string rep from the objv argument objects and place their      * pointers in argv. First make sure argv is large enough to hold the      * objc args plus 1 extra word for the zero end-of-argv word.      * THIS FAILS IF AN OBJECT'S STRING REP CONTAINS NULLS.      */
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|objc
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|argv
index|[
name|i
index|]
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
block|}
name|argv
index|[
name|objc
index|]
operator|=
literal|0
expr_stmt|;
comment|/*      * Copy the command characters into a new string.      */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|numChars
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|p
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|command
argument_list|,
operator|(
name|size_t
operator|)
name|numChars
argument_list|)
expr_stmt|;
name|p
index|[
name|numChars
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/*      * Call the trace procedure then free allocated storage.      */
call|(
modifier|*
name|tracePtr
operator|->
name|proc
call|)
argument_list|(
name|tracePtr
operator|->
name|clientData
argument_list|,
name|interp
argument_list|,
name|iPtr
operator|->
name|numLevels
argument_list|,
name|p
argument_list|,
name|cmdPtr
operator|->
name|proc
argument_list|,
name|cmdPtr
operator|->
name|clientData
argument_list|,
name|objc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * RecordTracebackInfo --  *  *      Procedure called by TclExecuteByteCode to record information  *      about what was being executed when the error occurred.  *  * Results:  *      None.  *  * Side effects:  *      Appends information about the command being executed to the  *      "errorInfo" variable. Sets the errorLine field in the interpreter  *      to the line number of that command. Sets the ERR_ALREADY_LOGGED  *      bit in the interpreter's execution flags.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|RecordTracebackInfo
parameter_list|(
name|interp
parameter_list|,
name|pc
parameter_list|,
name|codePtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interpreter in which the error                                  * occurred. */
name|unsigned
name|char
modifier|*
name|pc
decl_stmt|;
comment|/* The program counter value where the error                                 * occurred. This points to a bytecode                                  * instruction in codePtr's code. */
name|ByteCode
modifier|*
name|codePtr
decl_stmt|;
comment|/* The bytecode sequence being executed. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|,
modifier|*
name|ellipsis
decl_stmt|;
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|numChars
decl_stmt|;
comment|/*      * Record the command in errorInfo (up to a certain number of      * characters, or up to the first newline).      */
name|iPtr
operator|->
name|errorLine
operator|=
literal|1
expr_stmt|;
name|cmd
operator|=
name|GetSrcInfoForPc
argument_list|(
name|pc
argument_list|,
name|codePtr
argument_list|,
operator|&
name|numChars
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|p
operator|=
name|codePtr
operator|->
name|source
init|;
name|p
operator|!=
name|cmd
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
name|iPtr
operator|->
name|errorLine
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
operator|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|';'
operator|)
operator|)
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
name|iPtr
operator|->
name|errorLine
operator|++
expr_stmt|;
block|}
block|}
name|ellipsis
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|numChars
operator|>
literal|150
condition|)
block|{
name|numChars
operator|=
literal|150
expr_stmt|;
name|ellipsis
operator|=
literal|"..."
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|iPtr
operator|->
name|flags
operator|&
name|ERR_IN_PROGRESS
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\n    while executing\n\"%.*s%s\""
argument_list|,
name|numChars
argument_list|,
name|cmd
argument_list|,
name|ellipsis
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\n    invoked from within\n\"%.*s%s\""
argument_list|,
name|numChars
argument_list|,
name|cmd
argument_list|,
name|ellipsis
argument_list|)
expr_stmt|;
block|}
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|flags
operator||=
name|ERR_ALREADY_LOGGED
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * GetSrcInfoForPc --  *  *	Given a program counter value, finds the closest command in the  *	bytecode code unit's CmdLocation array and returns information about  *	that command's source: a pointer to its first byte and the number of  *	characters.  *  * Results:  *	If a command is found that encloses the program counter value, a  *	pointer to the command's source is returned and the length of the  *	source is stored at *lengthPtr. If multiple commands resulted in  *	code at pc, information about the closest enclosing command is  *	returned. If no matching command is found, NULL is returned and  *	*lengthPtr is unchanged.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|GetSrcInfoForPc
parameter_list|(
name|pc
parameter_list|,
name|codePtr
parameter_list|,
name|lengthPtr
parameter_list|)
name|unsigned
name|char
modifier|*
name|pc
decl_stmt|;
comment|/* The program counter value for which to 				 * return the closest command's source info. 				 * This points to a bytecode instruction 				 * in codePtr's code. */
name|ByteCode
modifier|*
name|codePtr
decl_stmt|;
comment|/* The bytecode sequence in which to look 				 * up the command source for the pc. */
name|int
modifier|*
name|lengthPtr
decl_stmt|;
comment|/* If non-NULL, the location where the 				 * length of the command's source should be 				 * stored. If NULL, no length is stored. */
block|{
specifier|register
name|int
name|pcOffset
init|=
operator|(
name|pc
operator|-
name|codePtr
operator|->
name|codeStart
operator|)
decl_stmt|;
name|int
name|numCmds
init|=
name|codePtr
operator|->
name|numCommands
decl_stmt|;
name|unsigned
name|char
modifier|*
name|codeDeltaNext
decl_stmt|,
modifier|*
name|codeLengthNext
decl_stmt|;
name|unsigned
name|char
modifier|*
name|srcDeltaNext
decl_stmt|,
modifier|*
name|srcLengthNext
decl_stmt|;
name|int
name|codeOffset
decl_stmt|,
name|codeLen
decl_stmt|,
name|codeEnd
decl_stmt|,
name|srcOffset
decl_stmt|,
name|srcLen
decl_stmt|,
name|delta
decl_stmt|,
name|i
decl_stmt|;
name|int
name|bestDist
init|=
name|INT_MAX
decl_stmt|;
comment|/* Distance of pc to best cmd's start pc. */
name|int
name|bestSrcOffset
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Initialized to avoid compiler warning. */
name|int
name|bestSrcLength
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Initialized to avoid compiler warning. */
if|if
condition|(
operator|(
name|pcOffset
operator|<
literal|0
operator|)
operator|||
operator|(
name|pcOffset
operator|>=
name|codePtr
operator|->
name|numCodeBytes
operator|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|/*      * Decode the code and source offset and length for each command. The      * closest enclosing command is the last one whose code started before      * pcOffset.      */
name|codeDeltaNext
operator|=
name|codePtr
operator|->
name|codeDeltaStart
expr_stmt|;
name|codeLengthNext
operator|=
name|codePtr
operator|->
name|codeLengthStart
expr_stmt|;
name|srcDeltaNext
operator|=
name|codePtr
operator|->
name|srcDeltaStart
expr_stmt|;
name|srcLengthNext
operator|=
name|codePtr
operator|->
name|srcLengthStart
expr_stmt|;
name|codeOffset
operator|=
name|srcOffset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numCmds
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|*
name|codeDeltaNext
argument_list|)
operator|==
operator|(
name|unsigned
name|int
operator|)
literal|0xFF
condition|)
block|{
name|codeDeltaNext
operator|++
expr_stmt|;
name|delta
operator|=
name|TclGetInt4AtPtr
argument_list|(
name|codeDeltaNext
argument_list|)
expr_stmt|;
name|codeDeltaNext
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|delta
operator|=
name|TclGetInt1AtPtr
argument_list|(
name|codeDeltaNext
argument_list|)
expr_stmt|;
name|codeDeltaNext
operator|++
expr_stmt|;
block|}
name|codeOffset
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|*
name|codeLengthNext
argument_list|)
operator|==
operator|(
name|unsigned
name|int
operator|)
literal|0xFF
condition|)
block|{
name|codeLengthNext
operator|++
expr_stmt|;
name|codeLen
operator|=
name|TclGetInt4AtPtr
argument_list|(
name|codeLengthNext
argument_list|)
expr_stmt|;
name|codeLengthNext
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|codeLen
operator|=
name|TclGetInt1AtPtr
argument_list|(
name|codeLengthNext
argument_list|)
expr_stmt|;
name|codeLengthNext
operator|++
expr_stmt|;
block|}
name|codeEnd
operator|=
operator|(
name|codeOffset
operator|+
name|codeLen
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|*
name|srcDeltaNext
argument_list|)
operator|==
operator|(
name|unsigned
name|int
operator|)
literal|0xFF
condition|)
block|{
name|srcDeltaNext
operator|++
expr_stmt|;
name|delta
operator|=
name|TclGetInt4AtPtr
argument_list|(
name|srcDeltaNext
argument_list|)
expr_stmt|;
name|srcDeltaNext
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|delta
operator|=
name|TclGetInt1AtPtr
argument_list|(
name|srcDeltaNext
argument_list|)
expr_stmt|;
name|srcDeltaNext
operator|++
expr_stmt|;
block|}
name|srcOffset
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|*
name|srcLengthNext
argument_list|)
operator|==
operator|(
name|unsigned
name|int
operator|)
literal|0xFF
condition|)
block|{
name|srcLengthNext
operator|++
expr_stmt|;
name|srcLen
operator|=
name|TclGetInt4AtPtr
argument_list|(
name|srcLengthNext
argument_list|)
expr_stmt|;
name|srcLengthNext
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|srcLen
operator|=
name|TclGetInt1AtPtr
argument_list|(
name|srcLengthNext
argument_list|)
expr_stmt|;
name|srcLengthNext
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|codeOffset
operator|>
name|pcOffset
condition|)
block|{
comment|/* best cmd already found */
break|break;
block|}
elseif|else
if|if
condition|(
name|pcOffset
operator|<=
name|codeEnd
condition|)
block|{
comment|/* this cmd's code encloses pc */
name|int
name|dist
init|=
operator|(
name|pcOffset
operator|-
name|codeOffset
operator|)
decl_stmt|;
if|if
condition|(
name|dist
operator|<=
name|bestDist
condition|)
block|{
name|bestDist
operator|=
name|dist
expr_stmt|;
name|bestSrcOffset
operator|=
name|srcOffset
expr_stmt|;
name|bestSrcLength
operator|=
name|srcLen
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|bestDist
operator|==
name|INT_MAX
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|lengthPtr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|lengthPtr
operator|=
name|bestSrcLength
expr_stmt|;
block|}
return|return
operator|(
name|codePtr
operator|->
name|source
operator|+
name|bestSrcOffset
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclGetExceptionRangeForPc --  *  *	Procedure that given a program counter value, returns the closest  *	enclosing ExceptionRange that matches the kind requested.  *  * Results:  *	In the normal case, catchOnly is 0 (false) and this procedure  *	returns a pointer to the most closely enclosing ExceptionRange  *	structure regardless of whether it is a loop or catch exception  *	range. This is appropriate when processing a TCL_BREAK or  *	TCL_CONTINUE, which will be "handled" either by a loop exception  *	range or a closer catch range. If catchOnly is nonzero (true), this  *	procedure ignores loop exception ranges and returns a pointer to the  *	closest catch range. If no matching ExceptionRange is found that  *	encloses pc, a NULL is returned.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|ExceptionRange
modifier|*
name|TclGetExceptionRangeForPc
parameter_list|(
name|pc
parameter_list|,
name|catchOnly
parameter_list|,
name|codePtr
parameter_list|)
name|unsigned
name|char
modifier|*
name|pc
decl_stmt|;
comment|/* The program counter value for which to 				 * search for a closest enclosing exception 				 * range. This points to a bytecode 				 * instruction in codePtr's code. */
name|int
name|catchOnly
decl_stmt|;
comment|/* If 0, consider either loop or catch 				 * ExceptionRanges in search. Otherwise 				 * consider only catch ranges (and ignore 				 * any closer loop ranges). */
name|ByteCode
modifier|*
name|codePtr
decl_stmt|;
comment|/* Points to the ByteCode in which to search 				 * for the enclosing ExceptionRange. */
block|{
name|ExceptionRange
modifier|*
name|rangeArrayPtr
init|=
name|codePtr
operator|->
name|excRangeArrayPtr
decl_stmt|;
name|int
name|numRanges
init|=
name|codePtr
operator|->
name|numExcRanges
decl_stmt|;
specifier|register
name|ExceptionRange
modifier|*
name|rangePtr
decl_stmt|;
name|int
name|codeOffset
init|=
operator|(
name|pc
operator|-
name|codePtr
operator|->
name|codeStart
operator|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|level
decl_stmt|;
for|for
control|(
name|level
operator|=
name|codePtr
operator|->
name|maxExcRangeDepth
init|;
name|level
operator|>=
literal|0
condition|;
name|level
operator|--
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numRanges
condition|;
name|i
operator|++
control|)
block|{
name|rangePtr
operator|=
operator|&
operator|(
name|rangeArrayPtr
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|rangePtr
operator|->
name|nestingLevel
operator|==
name|level
condition|)
block|{
name|int
name|start
init|=
name|rangePtr
operator|->
name|codeOffset
decl_stmt|;
name|int
name|end
init|=
operator|(
name|start
operator|+
name|rangePtr
operator|->
name|numCodeBytes
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|start
operator|<=
name|codeOffset
operator|)
operator|&&
operator|(
name|codeOffset
operator|<
name|end
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|catchOnly
operator|)
operator|||
operator|(
name|rangePtr
operator|->
name|type
operator|==
name|CATCH_EXCEPTION_RANGE
operator|)
condition|)
block|{
return|return
name|rangePtr
return|;
block|}
block|}
block|}
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Math Functions --  *  *	This page contains the procedures that implement all of the  *	built-in math functions for expressions.  *  * Results:  *	Each procedure returns TCL_OK if it succeeds and pushes an  *	Tcl object holding the result. If it fails it returns TCL_ERROR  *	and leaves an error message in the interpreter's result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ExprUnaryFunc
parameter_list|(
name|interp
parameter_list|,
name|eePtr
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interpreter in which to execute the 				 * function. */
name|ExecEnv
modifier|*
name|eePtr
decl_stmt|;
comment|/* Points to the environment for executing 				 * the function. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Contains the address of a procedure that 				 * takes one double argument and returns a 				 * double result. */
block|{
name|StackItem
modifier|*
name|stackPtr
decl_stmt|;
comment|/* Cached evaluation stack base pointer. */
specifier|register
name|int
name|stackTop
decl_stmt|;
comment|/* Cached top index of evaluation stack. */
specifier|register
name|Tcl_Obj
modifier|*
name|valuePtr
decl_stmt|;
name|Tcl_ObjType
modifier|*
name|tPtr
decl_stmt|;
name|double
name|d
decl_stmt|,
name|dResult
decl_stmt|;
name|long
name|i
decl_stmt|;
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
name|double
argument_list|(
argument|*func
argument_list|)
name|_ANSI_ARGS_
argument_list|(
operator|(
name|double
operator|)
argument_list|)
operator|=
operator|(
name|double
argument_list|(
argument|*
argument_list|)
name|_ANSI_ARGS_
argument_list|(
operator|(
name|double
operator|)
argument_list|)
operator|)
name|clientData
expr_stmt|;
comment|/*      * Set stackPtr and stackTop from eePtr.      */
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
comment|/*      * Pop the function's argument from the evaluation stack. Convert it      * to a double if necessary.      */
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|tPtr
operator|=
name|valuePtr
operator|->
name|typePtr
expr_stmt|;
if|if
condition|(
name|tPtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
name|d
operator|=
operator|(
name|double
operator|)
name|valuePtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tPtr
operator|==
operator|&
name|tclDoubleType
condition|)
block|{
name|d
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|doubleValue
expr_stmt|;
block|}
else|else
block|{
comment|/* FAILS IF STRING REP HAS NULLS */
name|char
modifier|*
name|s
init|=
name|Tcl_GetStringFromObj
argument_list|(
name|valuePtr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|TclLooksLikeInt
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|result
operator|=
name|Tcl_GetLongFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
name|double
operator|)
name|valuePtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_GetDoubleFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"argument to math function didn't have numeric value"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|dResult
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|errno
operator|!=
literal|0
operator|)
operator|||
name|IS_NAN
argument_list|(
name|dResult
argument_list|)
operator|||
name|IS_INF
argument_list|(
name|dResult
argument_list|)
condition|)
block|{
name|TclExprFloatError
argument_list|(
name|interp
argument_list|,
name|dResult
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*      * Push a Tcl object holding the result.      */
name|PUSH_OBJECT
argument_list|(
name|Tcl_NewDoubleObj
argument_list|(
name|dResult
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Reflect the change to stackTop back in eePtr.      */
name|done
label|:
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ExprBinaryFunc
parameter_list|(
name|interp
parameter_list|,
name|eePtr
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interpreter in which to execute the 				 * function. */
name|ExecEnv
modifier|*
name|eePtr
decl_stmt|;
comment|/* Points to the environment for executing 				 * the function. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Contains the address of a procedure that 				 * takes two double arguments and 				 * returns a double result. */
block|{
name|StackItem
modifier|*
name|stackPtr
decl_stmt|;
comment|/* Cached evaluation stack base pointer. */
specifier|register
name|int
name|stackTop
decl_stmt|;
comment|/* Cached top index of evaluation stack. */
specifier|register
name|Tcl_Obj
modifier|*
name|valuePtr
decl_stmt|,
modifier|*
name|value2Ptr
decl_stmt|;
name|Tcl_ObjType
modifier|*
name|tPtr
decl_stmt|;
name|double
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|dResult
decl_stmt|;
name|long
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
name|double
argument_list|(
argument|*func
argument_list|)
name|_ANSI_ARGS_
argument_list|(
operator|(
name|double
operator|,
name|double
operator|)
argument_list|)
operator|=
operator|(
name|double
argument_list|(
argument|*
argument_list|)
name|_ANSI_ARGS_
argument_list|(
operator|(
name|double
operator|,
name|double
operator|)
argument_list|)
operator|)
name|clientData
expr_stmt|;
comment|/*      * Set stackPtr and stackTop from eePtr.      */
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
comment|/*      * Pop the function's two arguments from the evaluation stack. Convert      * them to doubles if necessary.      */
name|value2Ptr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|tPtr
operator|=
name|valuePtr
operator|->
name|typePtr
expr_stmt|;
if|if
condition|(
name|tPtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
name|d1
operator|=
operator|(
name|double
operator|)
name|valuePtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tPtr
operator|==
operator|&
name|tclDoubleType
condition|)
block|{
name|d1
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|doubleValue
expr_stmt|;
block|}
else|else
block|{
comment|/* FAILS IF STRING REP HAS NULLS */
name|s
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|valuePtr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|TclLooksLikeInt
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|result
operator|=
name|Tcl_GetLongFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|d1
operator|=
operator|(
name|double
operator|)
name|valuePtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_GetDoubleFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|d1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|badArg
label|:
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"argument to math function didn't have numeric value"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|tPtr
operator|=
name|value2Ptr
operator|->
name|typePtr
expr_stmt|;
if|if
condition|(
name|tPtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
name|d2
operator|=
name|value2Ptr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tPtr
operator|==
operator|&
name|tclDoubleType
condition|)
block|{
name|d2
operator|=
name|value2Ptr
operator|->
name|internalRep
operator|.
name|doubleValue
expr_stmt|;
block|}
else|else
block|{
comment|/* FAILS IF STRING REP HAS NULLS */
name|s
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|value2Ptr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|TclLooksLikeInt
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|result
operator|=
name|Tcl_GetLongFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|value2Ptr
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|d2
operator|=
operator|(
name|double
operator|)
name|value2Ptr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_GetDoubleFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|value2Ptr
argument_list|,
operator|&
name|d2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|badArg
goto|;
block|}
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|dResult
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|d1
argument_list|,
name|d2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|errno
operator|!=
literal|0
operator|)
operator|||
name|IS_NAN
argument_list|(
name|dResult
argument_list|)
operator|||
name|IS_INF
argument_list|(
name|dResult
argument_list|)
condition|)
block|{
name|TclExprFloatError
argument_list|(
name|interp
argument_list|,
name|dResult
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*      * Push a Tcl object holding the result.      */
name|PUSH_OBJECT
argument_list|(
name|Tcl_NewDoubleObj
argument_list|(
name|dResult
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Reflect the change to stackTop back in eePtr.      */
name|done
label|:
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|value2Ptr
argument_list|)
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ExprAbsFunc
parameter_list|(
name|interp
parameter_list|,
name|eePtr
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interpreter in which to execute the 				 * function. */
name|ExecEnv
modifier|*
name|eePtr
decl_stmt|;
comment|/* Points to the environment for executing 				 * the function. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Ignored. */
block|{
name|StackItem
modifier|*
name|stackPtr
decl_stmt|;
comment|/* Cached evaluation stack base pointer. */
specifier|register
name|int
name|stackTop
decl_stmt|;
comment|/* Cached top index of evaluation stack. */
specifier|register
name|Tcl_Obj
modifier|*
name|valuePtr
decl_stmt|;
name|Tcl_ObjType
modifier|*
name|tPtr
decl_stmt|;
name|long
name|i
decl_stmt|,
name|iResult
decl_stmt|;
name|double
name|d
decl_stmt|,
name|dResult
decl_stmt|;
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
comment|/*      * Set stackPtr and stackTop from eePtr.      */
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
comment|/*      * Pop the argument from the evaluation stack.      */
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|tPtr
operator|=
name|valuePtr
operator|->
name|typePtr
expr_stmt|;
if|if
condition|(
name|tPtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
name|i
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tPtr
operator|==
operator|&
name|tclDoubleType
condition|)
block|{
name|d
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|doubleValue
expr_stmt|;
block|}
else|else
block|{
comment|/* FAILS IF STRING REP HAS NULLS */
name|char
modifier|*
name|s
init|=
name|Tcl_GetStringFromObj
argument_list|(
name|valuePtr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|TclLooksLikeInt
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|result
operator|=
name|Tcl_GetLongFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_GetDoubleFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"argument to math function didn't have numeric value"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|tPtr
operator|=
name|valuePtr
operator|->
name|typePtr
expr_stmt|;
block|}
comment|/*      * Push a Tcl object with the result.      */
if|if
condition|(
name|tPtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|iResult
operator|=
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|iResult
operator|<
literal|0
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"integer value too large to represent"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"ARITH"
argument_list|,
literal|"IOVERFLOW"
argument_list|,
literal|"integer value too large to represent"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
name|iResult
operator|=
name|i
expr_stmt|;
block|}
name|PUSH_OBJECT
argument_list|(
name|Tcl_NewLongObj
argument_list|(
name|iResult
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|d
operator|<
literal|0.0
condition|)
block|{
name|dResult
operator|=
operator|-
name|d
expr_stmt|;
block|}
else|else
block|{
name|dResult
operator|=
name|d
expr_stmt|;
block|}
if|if
condition|(
name|IS_NAN
argument_list|(
name|dResult
argument_list|)
operator|||
name|IS_INF
argument_list|(
name|dResult
argument_list|)
condition|)
block|{
name|TclExprFloatError
argument_list|(
name|interp
argument_list|,
name|dResult
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|PUSH_OBJECT
argument_list|(
name|Tcl_NewDoubleObj
argument_list|(
name|dResult
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*      * Reflect the change to stackTop back in eePtr.      */
name|done
label|:
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ExprDoubleFunc
parameter_list|(
name|interp
parameter_list|,
name|eePtr
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interpreter in which to execute the 				 * function. */
name|ExecEnv
modifier|*
name|eePtr
decl_stmt|;
comment|/* Points to the environment for executing 				 * the function. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Ignored. */
block|{
name|StackItem
modifier|*
name|stackPtr
decl_stmt|;
comment|/* Cached evaluation stack base pointer. */
specifier|register
name|int
name|stackTop
decl_stmt|;
comment|/* Cached top index of evaluation stack. */
specifier|register
name|Tcl_Obj
modifier|*
name|valuePtr
decl_stmt|;
name|double
name|dResult
decl_stmt|;
name|long
name|i
decl_stmt|;
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
comment|/*      * Set stackPtr and stackTop from eePtr.      */
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
comment|/*      * Pop the argument from the evaluation stack.      */
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
if|if
condition|(
name|valuePtr
operator|->
name|typePtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
name|dResult
operator|=
operator|(
name|double
operator|)
name|valuePtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|valuePtr
operator|->
name|typePtr
operator|==
operator|&
name|tclDoubleType
condition|)
block|{
name|dResult
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|doubleValue
expr_stmt|;
block|}
else|else
block|{
comment|/* FAILS IF STRING REP HAS NULLS */
name|char
modifier|*
name|s
init|=
name|Tcl_GetStringFromObj
argument_list|(
name|valuePtr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|TclLooksLikeInt
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|result
operator|=
name|Tcl_GetLongFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|dResult
operator|=
operator|(
name|double
operator|)
name|valuePtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_GetDoubleFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|dResult
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"argument to math function didn't have numeric value"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/*      * Push a Tcl object with the result.      */
name|PUSH_OBJECT
argument_list|(
name|Tcl_NewDoubleObj
argument_list|(
name|dResult
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Reflect the change to stackTop back in eePtr.      */
name|done
label|:
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ExprIntFunc
parameter_list|(
name|interp
parameter_list|,
name|eePtr
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interpreter in which to execute the 				 * function. */
name|ExecEnv
modifier|*
name|eePtr
decl_stmt|;
comment|/* Points to the environment for executing 				 * the function. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Ignored. */
block|{
name|StackItem
modifier|*
name|stackPtr
decl_stmt|;
comment|/* Cached evaluation stack base pointer. */
specifier|register
name|int
name|stackTop
decl_stmt|;
comment|/* Cached top index of evaluation stack. */
specifier|register
name|Tcl_Obj
modifier|*
name|valuePtr
decl_stmt|;
name|Tcl_ObjType
modifier|*
name|tPtr
decl_stmt|;
name|long
name|i
init|=
literal|0
decl_stmt|;
comment|/* Initialized to avoid compiler warning. */
name|long
name|iResult
decl_stmt|;
name|double
name|d
decl_stmt|;
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
comment|/*      * Set stackPtr and stackTop from eePtr.      */
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
comment|/*      * Pop the argument from the evaluation stack.      */
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|tPtr
operator|=
name|valuePtr
operator|->
name|typePtr
expr_stmt|;
if|if
condition|(
name|tPtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
name|i
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tPtr
operator|==
operator|&
name|tclDoubleType
condition|)
block|{
name|d
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|doubleValue
expr_stmt|;
block|}
else|else
block|{
comment|/* FAILS IF STRING REP HAS NULLS */
name|char
modifier|*
name|s
init|=
name|Tcl_GetStringFromObj
argument_list|(
name|valuePtr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|TclLooksLikeInt
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|result
operator|=
name|Tcl_GetLongFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_GetDoubleFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"argument to math function didn't have numeric value"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|tPtr
operator|=
name|valuePtr
operator|->
name|typePtr
expr_stmt|;
block|}
comment|/*      * Push a Tcl object with the result.      */
if|if
condition|(
name|tPtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
name|iResult
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|d
operator|<
literal|0.0
condition|)
block|{
if|if
condition|(
name|d
operator|<
operator|(
name|double
operator|)
operator|(
name|long
operator|)
name|LONG_MIN
condition|)
block|{
name|tooLarge
label|:
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"integer value too large to represent"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"ARITH"
argument_list|,
literal|"IOVERFLOW"
argument_list|,
literal|"integer value too large to represent"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|d
operator|>
operator|(
name|double
operator|)
name|LONG_MAX
condition|)
block|{
goto|goto
name|tooLarge
goto|;
block|}
block|}
if|if
condition|(
name|IS_NAN
argument_list|(
name|d
argument_list|)
operator|||
name|IS_INF
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|TclExprFloatError
argument_list|(
name|interp
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|iResult
operator|=
operator|(
name|long
operator|)
name|d
expr_stmt|;
block|}
name|PUSH_OBJECT
argument_list|(
name|Tcl_NewLongObj
argument_list|(
name|iResult
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Reflect the change to stackTop back in eePtr.      */
name|done
label|:
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ExprRandFunc
parameter_list|(
name|interp
parameter_list|,
name|eePtr
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interpreter in which to execute the 				 * function. */
name|ExecEnv
modifier|*
name|eePtr
decl_stmt|;
comment|/* Points to the environment for executing 				 * the function. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Ignored. */
block|{
name|StackItem
modifier|*
name|stackPtr
decl_stmt|;
comment|/* Cached evaluation stack base pointer. */
specifier|register
name|int
name|stackTop
decl_stmt|;
comment|/* Cached top index of evaluation stack. */
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|double
name|dResult
decl_stmt|;
name|int
name|tmp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|iPtr
operator|->
name|flags
operator|&
name|RAND_SEED_INITIALIZED
operator|)
condition|)
block|{
name|iPtr
operator|->
name|flags
operator||=
name|RAND_SEED_INITIALIZED
expr_stmt|;
name|iPtr
operator|->
name|randSeed
operator|=
name|TclpGetClicks
argument_list|()
expr_stmt|;
block|}
comment|/*      * Set stackPtr and stackTop from eePtr.      */
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
comment|/*      * Generate the random number using the linear congruential      * generator defined by the following recurrence:      *		seed = ( IA * seed ) mod IM      * where IA is 16807 and IM is (2^31) - 1.  In order to avoid      * potential problems with integer overflow, the  code uses      * additional constants IQ and IR such that      *		IM = IA*IQ + IR      * For details on how this algorithm works, refer to the following      * papers:       *      *	S.K. Park& K.W. Miller, "Random number generators: good ones      *	are hard to find," Comm ACM 31(10):1192-1201, Oct 1988      *      *	W.H. Press& S.A. Teukolsky, "Portable random number      *	generators," Computers in Physics 6(5):522-524, Sep/Oct 1992.      */
define|#
directive|define
name|RAND_IA
value|16807
define|#
directive|define
name|RAND_IM
value|2147483647
define|#
directive|define
name|RAND_IQ
value|127773
define|#
directive|define
name|RAND_IR
value|2836
define|#
directive|define
name|RAND_MASK
value|123459876
if|if
condition|(
name|iPtr
operator|->
name|randSeed
operator|==
literal|0
condition|)
block|{
comment|/* 	 * Don't allow a 0 seed, since it breaks the generator.  Shift 	 * it to some other value. 	 */
name|iPtr
operator|->
name|randSeed
operator|=
literal|123459876
expr_stmt|;
block|}
name|tmp
operator|=
name|iPtr
operator|->
name|randSeed
operator|/
name|RAND_IQ
expr_stmt|;
name|iPtr
operator|->
name|randSeed
operator|=
name|RAND_IA
operator|*
operator|(
name|iPtr
operator|->
name|randSeed
operator|-
name|tmp
operator|*
name|RAND_IQ
operator|)
operator|-
name|RAND_IR
operator|*
name|tmp
expr_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|randSeed
operator|<
literal|0
condition|)
block|{
name|iPtr
operator|->
name|randSeed
operator|+=
name|RAND_IM
expr_stmt|;
block|}
comment|/*      * On 64-bit architectures we need to mask off the upper bits to      * ensure we only have a 32-bit range.  The constant has the      * bizarre form below in order to make sure that it doesn't      * get sign-extended (the rules for sign extension are very      * concat, particularly on 64-bit machines).      */
name|iPtr
operator|->
name|randSeed
operator|&=
operator|(
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|0xfffffff
operator|)
operator|<<
literal|4
operator|)
operator||
literal|0xf
operator|)
expr_stmt|;
name|dResult
operator|=
name|iPtr
operator|->
name|randSeed
operator|*
operator|(
literal|1.0
operator|/
name|RAND_IM
operator|)
expr_stmt|;
comment|/*      * Push a Tcl object with the result.      */
name|PUSH_OBJECT
argument_list|(
name|Tcl_NewDoubleObj
argument_list|(
name|dResult
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Reflect the change to stackTop back in eePtr.      */
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ExprRoundFunc
parameter_list|(
name|interp
parameter_list|,
name|eePtr
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interpreter in which to execute the 				 * function. */
name|ExecEnv
modifier|*
name|eePtr
decl_stmt|;
comment|/* Points to the environment for executing 				 * the function. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Ignored. */
block|{
name|StackItem
modifier|*
name|stackPtr
decl_stmt|;
comment|/* Cached evaluation stack base pointer. */
specifier|register
name|int
name|stackTop
decl_stmt|;
comment|/* Cached top index of evaluation stack. */
name|Tcl_Obj
modifier|*
name|valuePtr
decl_stmt|;
name|Tcl_ObjType
modifier|*
name|tPtr
decl_stmt|;
name|long
name|i
init|=
literal|0
decl_stmt|;
comment|/* Initialized to avoid compiler warning. */
name|long
name|iResult
decl_stmt|;
name|double
name|d
decl_stmt|,
name|temp
decl_stmt|;
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
comment|/*      * Set stackPtr and stackTop from eePtr.      */
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
comment|/*      * Pop the argument from the evaluation stack.      */
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|tPtr
operator|=
name|valuePtr
operator|->
name|typePtr
expr_stmt|;
if|if
condition|(
name|tPtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
name|i
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tPtr
operator|==
operator|&
name|tclDoubleType
condition|)
block|{
name|d
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|doubleValue
expr_stmt|;
block|}
else|else
block|{
comment|/* FAILS IF STRING REP HAS NULLS */
name|char
modifier|*
name|s
init|=
name|Tcl_GetStringFromObj
argument_list|(
name|valuePtr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|TclLooksLikeInt
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|result
operator|=
name|Tcl_GetLongFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_GetDoubleFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"argument to math function didn't have numeric value"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|tPtr
operator|=
name|valuePtr
operator|->
name|typePtr
expr_stmt|;
block|}
comment|/*      * Push a Tcl object with the result.      */
if|if
condition|(
name|tPtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
name|iResult
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|d
operator|<
literal|0.0
condition|)
block|{
if|if
condition|(
name|d
operator|<=
operator|(
operator|(
operator|(
name|double
operator|)
operator|(
name|long
operator|)
name|LONG_MIN
operator|)
operator|-
literal|0.5
operator|)
condition|)
block|{
name|tooLarge
label|:
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"integer value too large to represent"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"ARITH"
argument_list|,
literal|"IOVERFLOW"
argument_list|,
literal|"integer value too large to represent"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|temp
operator|=
call|(
name|long
call|)
argument_list|(
name|d
operator|-
literal|0.5
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|d
operator|>=
operator|(
operator|(
operator|(
name|double
operator|)
name|LONG_MAX
operator|+
literal|0.5
operator|)
operator|)
condition|)
block|{
goto|goto
name|tooLarge
goto|;
block|}
name|temp
operator|=
call|(
name|long
call|)
argument_list|(
name|d
operator|+
literal|0.5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_NAN
argument_list|(
name|temp
argument_list|)
operator|||
name|IS_INF
argument_list|(
name|temp
argument_list|)
condition|)
block|{
name|TclExprFloatError
argument_list|(
name|interp
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|iResult
operator|=
operator|(
name|long
operator|)
name|temp
expr_stmt|;
block|}
name|PUSH_OBJECT
argument_list|(
name|Tcl_NewLongObj
argument_list|(
name|iResult
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Reflect the change to stackTop back in eePtr.      */
name|done
label|:
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ExprSrandFunc
parameter_list|(
name|interp
parameter_list|,
name|eePtr
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interpreter in which to execute the 				 * function. */
name|ExecEnv
modifier|*
name|eePtr
decl_stmt|;
comment|/* Points to the environment for executing 				 * the function. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Ignored. */
block|{
name|StackItem
modifier|*
name|stackPtr
decl_stmt|;
comment|/* Cached evaluation stack base pointer. */
specifier|register
name|int
name|stackTop
decl_stmt|;
comment|/* Cached top index of evaluation stack. */
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Tcl_Obj
modifier|*
name|valuePtr
decl_stmt|;
name|Tcl_ObjType
modifier|*
name|tPtr
decl_stmt|;
name|long
name|i
init|=
literal|0
decl_stmt|;
comment|/* Initialized to avoid compiler warning. */
name|int
name|result
decl_stmt|;
comment|/*      * Set stackPtr and stackTop from eePtr.      */
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
comment|/*      * Pop the argument from the evaluation stack.  Use the value      * to reset the random number seed.      */
name|valuePtr
operator|=
name|POP_OBJECT
argument_list|()
expr_stmt|;
name|tPtr
operator|=
name|valuePtr
operator|->
name|typePtr
expr_stmt|;
if|if
condition|(
name|tPtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
name|i
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
block|}
else|else
block|{
comment|/* FAILS IF STRING REP HAS NULLS */
name|result
operator|=
name|Tcl_GetLongFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"can't use "
argument_list|,
operator|(
operator|(
name|tPtr
operator|==
operator|&
name|tclDoubleType
operator|)
condition|?
literal|"floating-point value"
else|:
literal|"non-numeric string"
operator|)
argument_list|,
literal|" as argument to srand"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
comment|/*      * Reset the seed.      */
name|iPtr
operator|->
name|flags
operator||=
name|RAND_SEED_INITIALIZED
expr_stmt|;
name|iPtr
operator|->
name|randSeed
operator|=
name|i
expr_stmt|;
comment|/*      * To avoid duplicating the random number generation code we simply      * clean up our state and call the real random number function. That      * function will always succeed.      */
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
name|ExprRandFunc
argument_list|(
name|interp
argument_list|,
name|eePtr
argument_list|,
name|clientData
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * ExprCallMathFunc --  *  *	This procedure is invoked to call a non-builtin math function  *	during the execution of an expression.   *  * Results:  *	TCL_OK is returned if all went well and the function's value  *	was computed successfully. If an error occurred, TCL_ERROR  *	is returned and an error message is left in the interpreter's  *	result.	After a successful return this procedure pushes a Tcl object  *	holding the result.   *  * Side effects:  *	None, unless the called math function has side effects.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ExprCallMathFunc
parameter_list|(
name|interp
parameter_list|,
name|eePtr
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interpreter in which to execute the 				 * function. */
name|ExecEnv
modifier|*
name|eePtr
decl_stmt|;
comment|/* Points to the environment for executing 				 * the function. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. The function name is 				 * the 0-th argument. */
name|Tcl_Obj
modifier|*
modifier|*
name|objv
decl_stmt|;
comment|/* The array of arguments. The function name 				 * is objv[0]. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|StackItem
modifier|*
name|stackPtr
decl_stmt|;
comment|/* Cached evaluation stack base pointer. */
specifier|register
name|int
name|stackTop
decl_stmt|;
comment|/* Cached top index of evaluation stack. */
name|char
modifier|*
name|funcName
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|MathFunc
modifier|*
name|mathFuncPtr
decl_stmt|;
comment|/* Information about math function. */
name|Tcl_Value
name|args
index|[
name|MAX_MATH_ARGS
index|]
decl_stmt|;
comment|/* Arguments for function call. */
name|Tcl_Value
name|funcResult
decl_stmt|;
comment|/* Result of function call as Tcl_Value. */
specifier|register
name|Tcl_Obj
modifier|*
name|valuePtr
decl_stmt|;
name|Tcl_ObjType
modifier|*
name|tPtr
decl_stmt|;
name|long
name|i
decl_stmt|;
name|double
name|d
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|,
name|result
decl_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
comment|/*      * Set stackPtr and stackTop from eePtr.      */
name|CACHE_STACK_INFO
argument_list|()
expr_stmt|;
comment|/*      * Look up the MathFunc record for the function.      * THIS FAILS IF THE OBJECT'S STRING REP CONTAINS NULLS.      */
name|funcName
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|0
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|mathFuncTable
argument_list|,
name|funcName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"unknown math function \""
argument_list|,
name|funcName
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|mathFuncPtr
operator|=
operator|(
name|MathFunc
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mathFuncPtr
operator|->
name|numArgs
operator|!=
operator|(
name|objc
operator|-
literal|1
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"ExprCallMathFunc: expected number of args %d != actual number %d"
argument_list|,
name|mathFuncPtr
operator|->
name|numArgs
argument_list|,
name|objc
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*      * Collect the arguments for the function, if there are any, into the      * array "args". Note that args[0] will have the Tcl_Value that      * corresponds to objv[1].      */
for|for
control|(
name|j
operator|=
literal|1
operator|,
name|k
operator|=
literal|0
init|;
name|j
operator|<
name|objc
condition|;
name|j
operator|++
operator|,
name|k
operator|++
control|)
block|{
name|valuePtr
operator|=
name|objv
index|[
name|j
index|]
expr_stmt|;
name|tPtr
operator|=
name|valuePtr
operator|->
name|typePtr
expr_stmt|;
if|if
condition|(
name|tPtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
name|i
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tPtr
operator|==
operator|&
name|tclDoubleType
condition|)
block|{
name|d
operator|=
name|valuePtr
operator|->
name|internalRep
operator|.
name|doubleValue
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * Try to convert to int first then double. 	     * FAILS IF STRING REP HAS NULLS. 	     */
name|char
modifier|*
name|s
init|=
name|Tcl_GetStringFromObj
argument_list|(
name|valuePtr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|TclLooksLikeInt
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|result
operator|=
name|Tcl_GetLongFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_GetDoubleFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|valuePtr
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"argument to math function didn't have numeric value"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|tPtr
operator|=
name|valuePtr
operator|->
name|typePtr
expr_stmt|;
block|}
comment|/* 	 * Copy the object's numeric value to the argument record, 	 * converting it if necessary.  	 */
if|if
condition|(
name|tPtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
if|if
condition|(
name|mathFuncPtr
operator|->
name|argTypes
index|[
name|k
index|]
operator|==
name|TCL_DOUBLE
condition|)
block|{
name|args
index|[
name|k
index|]
operator|.
name|type
operator|=
name|TCL_DOUBLE
expr_stmt|;
name|args
index|[
name|k
index|]
operator|.
name|doubleValue
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|args
index|[
name|k
index|]
operator|.
name|type
operator|=
name|TCL_INT
expr_stmt|;
name|args
index|[
name|k
index|]
operator|.
name|intValue
operator|=
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|mathFuncPtr
operator|->
name|argTypes
index|[
name|k
index|]
operator|==
name|TCL_INT
condition|)
block|{
name|args
index|[
name|k
index|]
operator|.
name|type
operator|=
name|TCL_INT
expr_stmt|;
name|args
index|[
name|k
index|]
operator|.
name|intValue
operator|=
operator|(
name|long
operator|)
name|d
expr_stmt|;
block|}
else|else
block|{
name|args
index|[
name|k
index|]
operator|.
name|type
operator|=
name|TCL_DOUBLE
expr_stmt|;
name|args
index|[
name|k
index|]
operator|.
name|doubleValue
operator|=
name|d
expr_stmt|;
block|}
block|}
block|}
comment|/*      * Invoke the function and copy its result back into valuePtr.      */
name|tcl_MathInProgress
operator|++
expr_stmt|;
name|result
operator|=
call|(
modifier|*
name|mathFuncPtr
operator|->
name|proc
call|)
argument_list|(
name|mathFuncPtr
operator|->
name|clientData
argument_list|,
name|interp
argument_list|,
name|args
argument_list|,
operator|&
name|funcResult
argument_list|)
expr_stmt|;
name|tcl_MathInProgress
operator|--
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
comment|/*      * Pop the objc top stack elements and decrement their ref counts.      */
name|i
operator|=
operator|(
name|stackTop
operator|-
operator|(
name|objc
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
while|while
condition|(
name|i
operator|<=
name|stackTop
condition|)
block|{
name|valuePtr
operator|=
name|stackPtr
index|[
name|i
index|]
operator|.
name|o
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|valuePtr
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|stackTop
operator|-=
name|objc
expr_stmt|;
comment|/*      * Push the call's object result.      */
if|if
condition|(
name|funcResult
operator|.
name|type
operator|==
name|TCL_INT
condition|)
block|{
name|PUSH_OBJECT
argument_list|(
name|Tcl_NewLongObj
argument_list|(
name|funcResult
operator|.
name|intValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
name|funcResult
operator|.
name|doubleValue
expr_stmt|;
if|if
condition|(
name|IS_NAN
argument_list|(
name|d
argument_list|)
operator|||
name|IS_INF
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|TclExprFloatError
argument_list|(
name|interp
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|PUSH_OBJECT
argument_list|(
name|Tcl_NewDoubleObj
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*      * Reflect the change to stackTop back in eePtr.      */
name|done
label|:
name|DECACHE_STACK_INFO
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclExprFloatError --  *  *	This procedure is called when an error occurs during a  *	floating-point operation. It reads errno and sets  *	interp->objResultPtr accordingly.  *  * Results:  *	interp->objResultPtr is set to hold an error message.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclExprFloatError
parameter_list|(
name|interp
parameter_list|,
name|value
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Where to store error message. */
name|double
name|value
decl_stmt|;
comment|/* Value returned after error;  used to 				 * distinguish underflows from overflows. */
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|errno
operator|==
name|EDOM
operator|)
operator|||
operator|(
name|value
operator|!=
name|value
operator|)
condition|)
block|{
name|s
operator|=
literal|"domain error: argument not in valid range"
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|s
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"ARITH"
argument_list|,
literal|"DOMAIN"
argument_list|,
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|errno
operator|==
name|ERANGE
operator|)
operator|||
name|IS_INF
argument_list|(
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|==
literal|0.0
condition|)
block|{
name|s
operator|=
literal|"floating-point value too small to represent"
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|s
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"ARITH"
argument_list|,
literal|"UNDERFLOW"
argument_list|,
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
literal|"floating-point value too large to represent"
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|s
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"ARITH"
argument_list|,
literal|"OVERFLOW"
argument_list|,
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* FAILS IF STRING REP CONTAINS NULLS */
name|char
name|msg
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"unknown floating-point error, errno = %d"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|msg
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"ARITH"
argument_list|,
literal|"UNKNOWN"
argument_list|,
name|msg
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_COMPILE_STATS
end_ifdef

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclLog2 --  *  *	Procedure used while collecting compilation statistics to determine  *	the log base 2 of an integer.  *  * Results:  *	Returns the log base 2 of the operand. If the argument is less  *	than or equal to zero, a zero is returned.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclLog2
parameter_list|(
name|value
parameter_list|)
specifier|register
name|int
name|value
decl_stmt|;
comment|/* The integer for which to compute the 				 * log base 2. */
block|{
specifier|register
name|int
name|n
init|=
name|value
decl_stmt|;
specifier|register
name|int
name|result
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|n
operator|>
literal|1
condition|)
block|{
name|n
operator|=
name|n
operator|>>
literal|1
expr_stmt|;
name|result
operator|++
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * EvalStatsCmd --  *  *	Implements the "evalstats" command that prints instruction execution  *	counts to stdout.  *  * Results:  *	Standard Tcl results.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|EvalStatsCmd
parameter_list|(
name|unused
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|unused
decl_stmt|;
comment|/* Unused. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* The number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* The argument strings. */
block|{
specifier|register
name|double
name|total
init|=
literal|0.0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|maxSizeDecade
init|=
literal|0
decl_stmt|;
name|double
name|totalHeaderBytes
init|=
operator|(
name|tclNumCompilations
operator|*
sizeof|sizeof
argument_list|(
name|ByteCode
argument_list|)
operator|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|instructionCount
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|total
operator|+=
name|instructionCount
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|31
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|tclSourceCount
index|[
name|i
index|]
operator|>
literal|0
operator|)
operator|&&
operator|(
name|tclByteCodeCount
index|[
name|i
index|]
operator|>
literal|0
operator|)
condition|)
block|{
name|maxSizeDecade
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\nNumber of compilations		%ld\n"
argument_list|,
name|tclNumCompilations
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Number of executions		%ld\n"
argument_list|,
name|numExecutions
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Average executions/compilation	%.0f\n"
argument_list|,
operator|(
operator|(
name|float
operator|)
name|numExecutions
operator|/
name|tclNumCompilations
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\nInstructions executed		%.0f\n"
argument_list|,
name|total
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Average instructions/compile	%.0f\n"
argument_list|,
name|total
operator|/
name|tclNumCompilations
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Average instructions/execution	%.0f\n"
argument_list|,
name|total
operator|/
name|numExecutions
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\nTotal source bytes		%.6g\n"
argument_list|,
name|tclTotalSourceBytes
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Total code bytes		%.6g\n"
argument_list|,
name|tclTotalCodeBytes
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Average code/compilation	%.0f\n"
argument_list|,
name|tclTotalCodeBytes
operator|/
name|tclNumCompilations
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Average code/source		%.2f\n"
argument_list|,
name|tclTotalCodeBytes
operator|/
name|tclTotalSourceBytes
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Current source bytes		%.6g\n"
argument_list|,
name|tclCurrentSourceBytes
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Current code bytes		%.6g\n"
argument_list|,
name|tclCurrentCodeBytes
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Current code/source		%.2f\n"
argument_list|,
name|tclCurrentCodeBytes
operator|/
name|tclCurrentSourceBytes
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\nTotal objects allocated		%ld\n"
argument_list|,
name|tclObjsAlloced
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Total objects freed		%ld\n"
argument_list|,
name|tclObjsFreed
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Current objects:	 	%ld\n"
argument_list|,
operator|(
name|tclObjsAlloced
operator|-
name|tclObjsFreed
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\nBreakdown of code byte requirements:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"                   Total bytes      Pct of    Avg per\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"                                  all code    compile\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Total code        %12.6g        100%%   %8.2f\n"
argument_list|,
name|tclTotalCodeBytes
argument_list|,
name|tclTotalCodeBytes
operator|/
name|tclNumCompilations
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Header            %12.6g   %8.2f%%   %8.2f\n"
argument_list|,
name|totalHeaderBytes
argument_list|,
operator|(
operator|(
name|totalHeaderBytes
operator|*
literal|100.0
operator|)
operator|/
name|tclTotalCodeBytes
operator|)
argument_list|,
name|totalHeaderBytes
operator|/
name|tclNumCompilations
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Instructions      %12.6g   %8.2f%%   %8.2f\n"
argument_list|,
name|tclTotalInstBytes
argument_list|,
operator|(
operator|(
name|tclTotalInstBytes
operator|*
literal|100.0
operator|)
operator|/
name|tclTotalCodeBytes
operator|)
argument_list|,
name|tclTotalInstBytes
operator|/
name|tclNumCompilations
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Objects           %12.6g   %8.2f%%   %8.2f\n"
argument_list|,
name|tclTotalObjBytes
argument_list|,
operator|(
operator|(
name|tclTotalObjBytes
operator|*
literal|100.0
operator|)
operator|/
name|tclTotalCodeBytes
operator|)
argument_list|,
name|tclTotalObjBytes
operator|/
name|tclNumCompilations
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Exception table   %12.6g   %8.2f%%   %8.2f\n"
argument_list|,
name|tclTotalExceptBytes
argument_list|,
operator|(
operator|(
name|tclTotalExceptBytes
operator|*
literal|100.0
operator|)
operator|/
name|tclTotalCodeBytes
operator|)
argument_list|,
name|tclTotalExceptBytes
operator|/
name|tclNumCompilations
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Auxiliary data    %12.6g   %8.2f%%   %8.2f\n"
argument_list|,
name|tclTotalAuxBytes
argument_list|,
operator|(
operator|(
name|tclTotalAuxBytes
operator|*
literal|100.0
operator|)
operator|/
name|tclTotalCodeBytes
operator|)
argument_list|,
name|tclTotalAuxBytes
operator|/
name|tclNumCompilations
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Command map       %12.6g   %8.2f%%   %8.2f\n"
argument_list|,
name|tclTotalCmdMapBytes
argument_list|,
operator|(
operator|(
name|tclTotalCmdMapBytes
operator|*
literal|100.0
operator|)
operator|/
name|tclTotalCodeBytes
operator|)
argument_list|,
name|tclTotalCmdMapBytes
operator|/
name|tclNumCompilations
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\nSource and ByteCode size distributions:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"	 binary decade		source	  code\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|maxSizeDecade
condition|;
name|i
operator|++
control|)
block|{
name|int
name|decadeLow
decl_stmt|,
name|decadeHigh
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|decadeLow
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|decadeLow
operator|=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
name|decadeHigh
operator|=
operator|(
literal|1
operator|<<
operator|(
name|i
operator|+
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"	%6d -%6d		%6d	%6d\n"
argument_list|,
name|decadeLow
argument_list|,
name|decadeHigh
argument_list|,
name|tclSourceCount
index|[
name|i
index|]
argument_list|,
name|tclByteCodeCount
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\nInstruction counts:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|instructionCount
index|[
name|i
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%20s %8d %6.2f%%\n"
argument_list|,
name|opName
index|[
name|i
index|]
argument_list|,
name|instructionCount
index|[
name|i
index|]
argument_list|,
operator|(
name|instructionCount
index|[
name|i
index|]
operator|*
literal|100.0
operator|)
operator|/
name|total
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\nHeap Statistics:\n"
argument_list|)
expr_stmt|;
name|TclDumpMemoryInfo
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TCL_MEM_DEBUG */
return|return
name|TCL_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_COMPILE_STATS */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetCommandFromObj --  *  *      Returns the command specified by the name in a Tcl_Obj.  *  * Results:  *	Returns a token for the command if it is found. Otherwise, if it  *	can't be found or there is an error, returns NULL.  *  * Side effects:  *      May update the internal representation for the object, caching  *      the command reference so that the next time this procedure is  *	called with the same object, the command can be found quickly.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Command
name|Tcl_GetCommandFromObj
parameter_list|(
name|interp
parameter_list|,
name|objPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interpreter in which to resolve the 				 * command and to report errors. */
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* The object containing the command's 				 * name. If the name starts with "::", will 				 * be looked up in global namespace. Else, 				 * looked up first in the current namespace 				 * if contextNsPtr is NULL, then in global 				 * namespace. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
specifier|register
name|ResolvedCmdName
modifier|*
name|resPtr
decl_stmt|;
specifier|register
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
name|Namespace
modifier|*
name|currNsPtr
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/*      * Get the internal representation, converting to a command type if      * needed. The internal representation is a ResolvedCmdName that points      * to the actual command.      */
if|if
condition|(
name|objPtr
operator|->
name|typePtr
operator|!=
operator|&
name|tclCmdNameType
condition|)
block|{
name|result
operator|=
name|tclCmdNameType
operator|.
name|setFromAnyProc
argument_list|(
name|interp
argument_list|,
name|objPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
operator|(
name|Tcl_Command
operator|)
name|NULL
return|;
block|}
block|}
name|resPtr
operator|=
operator|(
name|ResolvedCmdName
operator|*
operator|)
name|objPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
expr_stmt|;
comment|/*      * Get the current namespace.      */
if|if
condition|(
name|iPtr
operator|->
name|varFramePtr
operator|!=
name|NULL
condition|)
block|{
name|currNsPtr
operator|=
name|iPtr
operator|->
name|varFramePtr
operator|->
name|nsPtr
expr_stmt|;
block|}
else|else
block|{
name|currNsPtr
operator|=
name|iPtr
operator|->
name|globalNsPtr
expr_stmt|;
block|}
comment|/*      * Check the context namespace and the namespace epoch of the resolved      * symbol to make sure that it is fresh. If not, then force another      * conversion to the command type, to discard the old rep and create a      * new one. Note that we verify that the namespace id of the context      * namespace is the same as the one we cached; this insures that the      * namespace wasn't deleted and a new one created at the same address      * with the same command epoch.      */
name|cmdPtr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|resPtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|resPtr
operator|->
name|refNsPtr
operator|==
name|currNsPtr
operator|)
operator|&&
operator|(
name|resPtr
operator|->
name|refNsId
operator|==
name|currNsPtr
operator|->
name|nsId
operator|)
operator|&&
operator|(
name|resPtr
operator|->
name|refNsCmdEpoch
operator|==
name|currNsPtr
operator|->
name|cmdRefEpoch
operator|)
condition|)
block|{
name|cmdPtr
operator|=
name|resPtr
operator|->
name|cmdPtr
expr_stmt|;
if|if
condition|(
name|cmdPtr
operator|->
name|cmdEpoch
operator|!=
name|resPtr
operator|->
name|cmdEpoch
condition|)
block|{
name|cmdPtr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cmdPtr
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|tclCmdNameType
operator|.
name|setFromAnyProc
argument_list|(
name|interp
argument_list|,
name|objPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
operator|(
name|Tcl_Command
operator|)
name|NULL
return|;
block|}
name|resPtr
operator|=
operator|(
name|ResolvedCmdName
operator|*
operator|)
name|objPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
expr_stmt|;
if|if
condition|(
name|resPtr
operator|!=
name|NULL
condition|)
block|{
name|cmdPtr
operator|=
name|resPtr
operator|->
name|cmdPtr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cmdPtr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|Tcl_Command
operator|)
name|NULL
return|;
block|}
return|return
operator|(
name|Tcl_Command
operator|)
name|cmdPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FreeCmdNameInternalRep --  *  *	Frees the resources associated with a cmdName object's internal  *	representation.  *  * Results:  *	None.  *  * Side effects:  *	Decrements the ref count of any cached ResolvedCmdName structure  *	pointed to by the cmdName's internal representation. If this is   *	the last use of the ResolvedCmdName, it is freed. This in turn  *	decrements the ref count of the Command structure pointed to by   *	the ResolvedSymbol, which may free the Command structure.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|FreeCmdNameInternalRep
parameter_list|(
name|objPtr
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* CmdName object with internal 				 * representation to free. */
block|{
specifier|register
name|ResolvedCmdName
modifier|*
name|resPtr
init|=
operator|(
name|ResolvedCmdName
operator|*
operator|)
name|objPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
decl_stmt|;
if|if
condition|(
name|resPtr
operator|!=
name|NULL
condition|)
block|{
comment|/* 	 * Decrement the reference count of the ResolvedCmdName structure. 	 * If there are no more uses, free the ResolvedCmdName structure. 	 */
name|resPtr
operator|->
name|refCount
operator|--
expr_stmt|;
if|if
condition|(
name|resPtr
operator|->
name|refCount
operator|==
literal|0
condition|)
block|{
comment|/* 	     * Now free the cached command, unless it is still in its              * hash table or if there are other references to it              * from other cmdName objects. 	     */
name|Command
modifier|*
name|cmdPtr
init|=
name|resPtr
operator|->
name|cmdPtr
decl_stmt|;
name|TclCleanupCommand
argument_list|(
name|cmdPtr
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|resPtr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DupCmdNameInternalRep --  *  *	Initialize the internal representation of an cmdName Tcl_Obj to a  *	copy of the internal representation of an existing cmdName object.   *  * Results:  *	None.  *  * Side effects:  *	"copyPtr"s internal rep is set to point to the ResolvedCmdName  *	structure corresponding to "srcPtr"s internal rep. Increments the  *	ref count of the ResolvedCmdName structure pointed to by the  *	cmdName's internal representation.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|DupCmdNameInternalRep
parameter_list|(
name|srcPtr
parameter_list|,
name|copyPtr
parameter_list|)
name|Tcl_Obj
modifier|*
name|srcPtr
decl_stmt|;
comment|/* Object with internal rep to copy. */
specifier|register
name|Tcl_Obj
modifier|*
name|copyPtr
decl_stmt|;
comment|/* Object with internal rep to set. */
block|{
specifier|register
name|ResolvedCmdName
modifier|*
name|resPtr
init|=
operator|(
name|ResolvedCmdName
operator|*
operator|)
name|srcPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
decl_stmt|;
name|copyPtr
operator|->
name|internalRep
operator|.
name|twoPtrValue
operator|.
name|ptr1
operator|=
operator|(
name|VOID
operator|*
operator|)
name|resPtr
expr_stmt|;
name|copyPtr
operator|->
name|internalRep
operator|.
name|twoPtrValue
operator|.
name|ptr2
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|resPtr
operator|!=
name|NULL
condition|)
block|{
name|resPtr
operator|->
name|refCount
operator|++
expr_stmt|;
block|}
name|copyPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclCmdNameType
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SetCmdNameFromAny --  *  *	Generate an cmdName internal form for the Tcl object "objPtr".  *  * Results:  *	The return value is a standard Tcl result. The conversion always  *	succeeds and TCL_OK is returned.  *  * Side effects:  *	A pointer to a ResolvedCmdName structure that holds a cached pointer  *	to the command with a name that matches objPtr's string rep is  *	stored as objPtr's internal representation. This ResolvedCmdName  *	pointer will be NULL if no matching command was found. The ref count  *	of the cached Command's structure (if any) is also incremented.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SetCmdNameFromAny
parameter_list|(
name|interp
parameter_list|,
name|objPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting if not NULL. */
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* The object to convert. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|Tcl_Command
name|cmd
decl_stmt|;
specifier|register
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
name|Namespace
modifier|*
name|currNsPtr
decl_stmt|;
specifier|register
name|ResolvedCmdName
modifier|*
name|resPtr
decl_stmt|;
comment|/*      * Get "objPtr"s string representation. Make it up-to-date if necessary.      */
name|name
operator|=
name|objPtr
operator|->
name|bytes
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|name
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/*      * Find the Command structure, if any, that describes the command called      * "name". Build a ResolvedCmdName that holds a cached pointer to this      * Command, and bump the reference count in the referenced Command      * structure. A Command structure will not be deleted as long as it is      * referenced from a CmdName object.      */
name|cmd
operator|=
name|Tcl_FindCommand
argument_list|(
name|interp
argument_list|,
name|name
argument_list|,
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|NULL
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|cmd
expr_stmt|;
if|if
condition|(
name|cmdPtr
operator|!=
name|NULL
condition|)
block|{
comment|/* 	 * Get the current namespace. 	 */
if|if
condition|(
name|iPtr
operator|->
name|varFramePtr
operator|!=
name|NULL
condition|)
block|{
name|currNsPtr
operator|=
name|iPtr
operator|->
name|varFramePtr
operator|->
name|nsPtr
expr_stmt|;
block|}
else|else
block|{
name|currNsPtr
operator|=
name|iPtr
operator|->
name|globalNsPtr
expr_stmt|;
block|}
name|cmdPtr
operator|->
name|refCount
operator|++
expr_stmt|;
name|resPtr
operator|=
operator|(
name|ResolvedCmdName
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ResolvedCmdName
argument_list|)
argument_list|)
expr_stmt|;
name|resPtr
operator|->
name|cmdPtr
operator|=
name|cmdPtr
expr_stmt|;
name|resPtr
operator|->
name|refNsPtr
operator|=
name|currNsPtr
expr_stmt|;
name|resPtr
operator|->
name|refNsId
operator|=
name|currNsPtr
operator|->
name|nsId
expr_stmt|;
name|resPtr
operator|->
name|refNsCmdEpoch
operator|=
name|currNsPtr
operator|->
name|cmdRefEpoch
expr_stmt|;
name|resPtr
operator|->
name|cmdEpoch
operator|=
name|cmdPtr
operator|->
name|cmdEpoch
expr_stmt|;
name|resPtr
operator|->
name|refCount
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|resPtr
operator|=
name|NULL
expr_stmt|;
comment|/* no command named "name" was found */
block|}
comment|/*      * Free the old internalRep before setting the new one. We do this as      * late as possible to allow the conversion code, in particular      * GetStringFromObj, to use that old internalRep. If no Command      * structure was found, leave NULL as the cached value.      */
if|if
condition|(
operator|(
name|objPtr
operator|->
name|typePtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|objPtr
operator|->
name|typePtr
operator|->
name|freeIntRepProc
operator|!=
name|NULL
operator|)
condition|)
block|{
name|objPtr
operator|->
name|typePtr
operator|->
name|freeIntRepProc
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
name|objPtr
operator|->
name|internalRep
operator|.
name|twoPtrValue
operator|.
name|ptr1
operator|=
operator|(
name|VOID
operator|*
operator|)
name|resPtr
expr_stmt|;
name|objPtr
operator|->
name|internalRep
operator|.
name|twoPtrValue
operator|.
name|ptr2
operator|=
name|NULL
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclCmdNameType
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * UpdateStringOfCmdName --  *  *	Update the string representation for an cmdName object.  *  * Results:  *	None.  *  * Side effects:  *	Generates a panic.   *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|UpdateStringOfCmdName
parameter_list|(
name|objPtr
parameter_list|)
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* CmdName obj to update string rep. */
block|{
comment|/*      * This procedure is never invoked since the internal representation of      * a cmdName object is never modified.      */
name|panic
argument_list|(
literal|"UpdateStringOfCmdName should never be invoked"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
end_ifdef

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * StringForResultCode --  *  *	Procedure that returns a human-readable string representing a  *	Tcl result code such as TCL_ERROR.   *  * Results:  *	If the result code is one of the standard Tcl return codes, the  *	result is a string representing that code such as "TCL_ERROR".  *	Otherwise, the result string is that code formatted as a  *	sequence of decimal digit characters. Note that the resulting  *	string must not be modified by the caller.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|StringForResultCode
parameter_list|(
name|result
parameter_list|)
name|int
name|result
decl_stmt|;
comment|/* The Tcl result code for which to 				 * generate a string. */
block|{
specifier|static
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|result
operator|>=
name|TCL_OK
operator|)
operator|&&
operator|(
name|result
operator|<=
name|TCL_CONTINUE
operator|)
condition|)
block|{
return|return
name|resultStrings
index|[
name|result
index|]
return|;
block|}
name|TclFormatInt
argument_list|(
name|buf
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_COMPILE_DEBUG */
end_comment

end_unit

