begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * tclNamesp.c --  *  *      Contains support for namespaces, which provide a separate context of  *      commands and global variables. The global :: namespace is the  *      traditional Tcl "global" scope. Other namespaces are created as  *      children of the global namespace. These other namespaces contain  *      special-purpose commands and variables for packages.  *  * Copyright (c) 1993-1997 Lucent Technologies.  * Copyright (c) 1997 Sun Microsystems, Inc.  *  * Originally implemented by  *   Michael J. McLennan  *   Bell Labs Innovations for Lucent Technologies  *   mmclennan@lucent.com  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclNamesp.c 1.29 97/08/04 09:32:38  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_comment
comment|/*  * Flag passed to TclGetNamespaceForQualName to indicate that it should  * search for a namespace rather than a command or variable inside a  * namespace. Note that this flag's value must not conflict with the values  * of TCL_GLOBAL_ONLY, TCL_NAMESPACE_ONLY, or CREATE_NS_IF_UNKNOWN.  */
end_comment

begin_define
define|#
directive|define
name|FIND_ONLY_NS
value|0x1000
end_define

begin_comment
comment|/*  * Count of the number of namespaces created. This value is used as a  * unique id for each namespace.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|numNsCreated
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Data structure used as the ClientData of imported commands: commands  * created in an namespace when it imports a "real" command from another  * namespace.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ImportedCmdData
block|{
name|Command
modifier|*
name|realCmdPtr
decl_stmt|;
comment|/* "Real" command that this imported command                                  * refers to. */
name|Command
modifier|*
name|selfPtr
decl_stmt|;
comment|/* Pointer to this imported command. Needed 				 * only when deleting it in order to remove 				 * it from the real command's linked list of 				 * imported commands that refer to it. */
block|}
name|ImportedCmdData
typedef|;
end_typedef

begin_comment
comment|/*  * This structure contains a cached pointer to a namespace that is the  * result of resolving the namespace's name in some other namespace. It is  * the internal representation for a nsName object. It contains the  * pointer along with some information that is used to check the cached  * pointer's validity.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ResolvedNsName
block|{
name|Namespace
modifier|*
name|nsPtr
decl_stmt|;
comment|/* A cached namespace pointer. */
name|long
name|nsId
decl_stmt|;
comment|/* nsPtr's unique namespace id. Used to 				 * verify that nsPtr is still valid 				 * (e.g., it's possible that the namespace 				 * was deleted and a new one created at 				 * the same address). */
name|Namespace
modifier|*
name|refNsPtr
decl_stmt|;
comment|/* Points to the namespace containing the 				 * reference (not the namespace that 				 * contains the referenced namespace). */
name|int
name|refCount
decl_stmt|;
comment|/* Reference count: 1 for each nsName 				 * object that has a pointer to this 				 * ResolvedNsName structure as its internal 				 * rep. This structure can be freed when 				 * refCount becomes zero. */
block|}
name|ResolvedNsName
typedef|;
end_typedef

begin_comment
comment|/*  * Declarations for procedures local to this file:  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DeleteImportedCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DupNsNameInternalRep
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Obj
operator|*
name|objPtr
operator|,
name|Tcl_Obj
operator|*
name|copyPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|FreeNsNameInternalRep
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Obj
operator|*
name|objPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|GetNamespaceFromObj
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Obj
operator|*
name|objPtr
operator|,
name|Tcl_Namespace
operator|*
operator|*
name|nsPtrPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InvokeImportedCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|NamespaceChildrenCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|NamespaceCodeCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|NamespaceCurrentCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|NamespaceDeleteCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|NamespaceEvalCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|NamespaceExportCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|NamespaceForgetCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|NamespaceFree
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Namespace
operator|*
name|nsPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|NamespaceImportCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|NamespaceInscopeCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|NamespaceOriginCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|NamespaceParentCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|NamespaceQualifiersCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|NamespaceTailCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|NamespaceWhichCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SetNsNameFromAny
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Obj
operator|*
name|objPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|UpdateStringOfNsName
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Obj
operator|*
name|objPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This structure defines a Tcl object type that contains a  * namespace reference.  It is used in commands that take the  * name of a namespace as an argument.  The namespace reference  * is resolved, and the result in cached in the object.  */
end_comment

begin_decl_stmt
name|Tcl_ObjType
name|tclNsNameType
init|=
block|{
literal|"nsName"
block|,
comment|/* the type's name */
name|FreeNsNameInternalRep
block|,
comment|/* freeIntRepProc */
name|DupNsNameInternalRep
block|,
comment|/* dupIntRepProc */
name|UpdateStringOfNsName
block|,
comment|/* updateStringProc */
name|SetNsNameFromAny
comment|/* setFromAnyProc */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Boolean flag indicating whether or not the namespName object  * type has been registered with the Tcl compiler.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nsInitialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclInitNamespaces --  *  *	Called when any interpreter is created to make sure that  *	things are properly set up for namespaces.  *  * Results:  *	None.  *  * Side effects:  *	On the first call, the namespName object type is registered  *	with the Tcl compiler.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclInitNamespaces
parameter_list|()
block|{
if|if
condition|(
operator|!
name|nsInitialized
condition|)
block|{
name|Tcl_RegisterObjType
argument_list|(
operator|&
name|tclNsNameType
argument_list|)
expr_stmt|;
name|nsInitialized
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetCurrentNamespace --  *  *	Returns a pointer to an interpreter's currently active namespace.  *  * Results:  *	Returns a pointer to the interpreter's current namespace.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Namespace
modifier|*
name|Tcl_GetCurrentNamespace
parameter_list|(
name|interp
parameter_list|)
specifier|register
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter whose current namespace is 				  * being queried. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
specifier|register
name|Namespace
modifier|*
name|nsPtr
decl_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|varFramePtr
operator|!=
name|NULL
condition|)
block|{
name|nsPtr
operator|=
name|iPtr
operator|->
name|varFramePtr
operator|->
name|nsPtr
expr_stmt|;
block|}
else|else
block|{
name|nsPtr
operator|=
name|iPtr
operator|->
name|globalNsPtr
expr_stmt|;
block|}
return|return
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|nsPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetGlobalNamespace --  *  *	Returns a pointer to an interpreter's global :: namespace.  *  * Results:  *	Returns a pointer to the specified interpreter's global namespace.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Namespace
modifier|*
name|Tcl_GetGlobalNamespace
parameter_list|(
name|interp
parameter_list|)
specifier|register
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter whose global namespace  				  * should be returned. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
return|return
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|iPtr
operator|->
name|globalNsPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_PushCallFrame --  *  *	Pushes a new call frame onto the interpreter's Tcl call stack.  *	Called when executing a Tcl procedure or a "namespace eval" or  *	"namespace inscope" command.   *  * Results:  *	Returns TCL_OK if successful, or TCL_ERROR (along with an error  *	message in the interpreter's result object) if something goes wrong.  *  * Side effects:  *	Modifies the interpreter's Tcl call stack.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_PushCallFrame
parameter_list|(
name|interp
parameter_list|,
name|callFramePtr
parameter_list|,
name|namespacePtr
parameter_list|,
name|isProcCallFrame
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which the new call frame 				  * is to be pushed. */
name|Tcl_CallFrame
modifier|*
name|callFramePtr
decl_stmt|;
comment|/* Points to a call frame structure to 				  * push. Storage for this have already been 				  * allocated by the caller; typically this 				  * is the address of a CallFrame structure 				  * allocated on the caller's C stack.  The 				  * call frame will be initialized by this 				  * procedure. The caller can pop the frame 				  * later with Tcl_PopCallFrame, and it is 				  * responsible for freeing the frame's 				  * storage. */
name|Tcl_Namespace
modifier|*
name|namespacePtr
decl_stmt|;
comment|/* Points to the namespace in which the 				  * frame will execute. If NULL, the 				  * interpreter's current namespace will 				  * be used. */
name|int
name|isProcCallFrame
decl_stmt|;
comment|/* If nonzero, the frame represents a 				  * called Tcl procedure and may have local 				  * vars. Vars will ordinarily be looked up 				  * in the frame. If new variables are 				  * created, they will be created in the 				  * frame. If 0, the frame is for a 				  * "namespace eval" or "namespace inscope" 				  * command and var references are treated 				  * as references to namespace variables. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
specifier|register
name|CallFrame
modifier|*
name|framePtr
init|=
operator|(
name|CallFrame
operator|*
operator|)
name|callFramePtr
decl_stmt|;
specifier|register
name|Namespace
modifier|*
name|nsPtr
decl_stmt|;
if|if
condition|(
name|namespacePtr
operator|==
name|NULL
condition|)
block|{
name|nsPtr
operator|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetCurrentNamespace
argument_list|(
name|interp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nsPtr
operator|=
operator|(
name|Namespace
operator|*
operator|)
name|namespacePtr
expr_stmt|;
if|if
condition|(
name|nsPtr
operator|->
name|flags
operator|&
name|NS_DEAD
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"namespace \""
argument_list|,
name|nsPtr
operator|->
name|fullName
argument_list|,
literal|"\" not found in context \""
argument_list|,
name|Tcl_GetCurrentNamespace
argument_list|(
name|interp
argument_list|)
operator|->
name|fullName
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
name|nsPtr
operator|->
name|activationCount
operator|++
expr_stmt|;
name|framePtr
operator|->
name|nsPtr
operator|=
name|nsPtr
expr_stmt|;
name|framePtr
operator|->
name|isProcCallFrame
operator|=
name|isProcCallFrame
expr_stmt|;
name|framePtr
operator|->
name|objc
operator|=
literal|0
expr_stmt|;
name|framePtr
operator|->
name|objv
operator|=
name|NULL
expr_stmt|;
name|framePtr
operator|->
name|callerPtr
operator|=
name|iPtr
operator|->
name|framePtr
expr_stmt|;
name|framePtr
operator|->
name|callerVarPtr
operator|=
name|iPtr
operator|->
name|varFramePtr
expr_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|varFramePtr
operator|!=
name|NULL
condition|)
block|{
name|framePtr
operator|->
name|level
operator|=
operator|(
name|iPtr
operator|->
name|varFramePtr
operator|->
name|level
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|framePtr
operator|->
name|level
operator|=
literal|1
expr_stmt|;
block|}
name|framePtr
operator|->
name|procPtr
operator|=
name|NULL
expr_stmt|;
comment|/* no called procedure */
name|framePtr
operator|->
name|varTablePtr
operator|=
name|NULL
expr_stmt|;
comment|/* and no local variables */
name|framePtr
operator|->
name|numCompiledLocals
operator|=
literal|0
expr_stmt|;
name|framePtr
operator|->
name|compiledLocals
operator|=
name|NULL
expr_stmt|;
comment|/*      * Push the new call frame onto the interpreter's stack of procedure      * call frames making it the current frame.      */
name|iPtr
operator|->
name|framePtr
operator|=
name|framePtr
expr_stmt|;
name|iPtr
operator|->
name|varFramePtr
operator|=
name|framePtr
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_PopCallFrame --  *  *	Removes a call frame from the Tcl call stack for the interpreter.  *	Called to remove a frame previously pushed by Tcl_PushCallFrame.  *  * Results:  *	None.  *  * Side effects:  *	Modifies the call stack of the interpreter. Resets various fields of  *	the popped call frame. If a namespace has been deleted and  *	has no more activations on the call stack, the namespace is  *	destroyed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_PopCallFrame
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter with call frame to pop. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
specifier|register
name|CallFrame
modifier|*
name|framePtr
init|=
name|iPtr
operator|->
name|framePtr
decl_stmt|;
name|int
name|saveErrFlag
decl_stmt|;
name|Namespace
modifier|*
name|nsPtr
decl_stmt|;
comment|/*      * It's important to remove the call frame from the interpreter's stack      * of call frames before deleting local variables, so that traces      * invoked by the variable deletion don't see the partially-deleted      * frame.      */
name|iPtr
operator|->
name|framePtr
operator|=
name|framePtr
operator|->
name|callerPtr
expr_stmt|;
name|iPtr
operator|->
name|varFramePtr
operator|=
name|framePtr
operator|->
name|callerVarPtr
expr_stmt|;
comment|/*      * Delete the local variables. As a hack, we save then restore the      * ERR_IN_PROGRESS flag in the interpreter. The problem is that there      * could be unset traces on the variables, which cause scripts to be      * evaluated. This will clear the ERR_IN_PROGRESS flag, losing stack      * trace information if the procedure was exiting with an error. The      * code below preserves the flag. Unfortunately, that isn't really      * enough: we really should preserve the errorInfo variable too      * (otherwise a nested error in the trace script will trash errorInfo).      * What's really needed is a general-purpose mechanism for saving and      * restoring interpreter state.      */
name|saveErrFlag
operator|=
operator|(
name|iPtr
operator|->
name|flags
operator|&
name|ERR_IN_PROGRESS
operator|)
expr_stmt|;
if|if
condition|(
name|framePtr
operator|->
name|varTablePtr
operator|!=
name|NULL
condition|)
block|{
name|TclDeleteVars
argument_list|(
name|iPtr
argument_list|,
name|framePtr
operator|->
name|varTablePtr
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|framePtr
operator|->
name|varTablePtr
argument_list|)
expr_stmt|;
name|framePtr
operator|->
name|varTablePtr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|framePtr
operator|->
name|numCompiledLocals
operator|>
literal|0
condition|)
block|{
name|TclDeleteCompiledLocalVars
argument_list|(
name|iPtr
argument_list|,
name|framePtr
argument_list|)
expr_stmt|;
block|}
name|iPtr
operator|->
name|flags
operator||=
name|saveErrFlag
expr_stmt|;
comment|/*      * Decrement the namespace's count of active call frames. If the      * namespace is "dying" and there are no more active call frames,      * call Tcl_DeleteNamespace to destroy it.      */
name|nsPtr
operator|=
name|framePtr
operator|->
name|nsPtr
expr_stmt|;
name|nsPtr
operator|->
name|activationCount
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|nsPtr
operator|->
name|flags
operator|&
name|NS_DYING
operator|)
operator|&&
operator|(
name|nsPtr
operator|->
name|activationCount
operator|==
literal|0
operator|)
condition|)
block|{
name|Tcl_DeleteNamespace
argument_list|(
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|nsPtr
argument_list|)
expr_stmt|;
block|}
name|framePtr
operator|->
name|nsPtr
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CreateNamespace --  *  *	Creates a new namespace with the given name. If there is no  *	active namespace (i.e., the interpreter is being initialized),  *	the global :: namespace is created and returned.  *  * Results:  *	Returns a pointer to the new namespace if successful. If the  *	namespace already exists or if another error occurs, this routine  *	returns NULL, along with an error message in the interpreter's  *	result object.  *  * Side effects:  *	If the name contains "::" qualifiers and a parent namespace does  *	not already exist, it is automatically created.   *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Namespace
modifier|*
name|Tcl_CreateNamespace
parameter_list|(
name|interp
parameter_list|,
name|name
parameter_list|,
name|clientData
parameter_list|,
name|deleteProc
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which a new namespace 				     * is being created. Also used for 				     * error reporting. */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name for the new namespace. May be a 				     * qualified name with names of ancestor 				     * namespaces separated by "::"s. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* One-word value to store with 				     * namespace. */
name|Tcl_NamespaceDeleteProc
modifier|*
name|deleteProc
decl_stmt|;
comment|/* Procedure called to delete client 				     * data when the namespace is deleted. 				     * NULL if no procedure should be 				     * called. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
specifier|register
name|Namespace
modifier|*
name|nsPtr
decl_stmt|,
modifier|*
name|ancestorPtr
decl_stmt|;
name|Namespace
modifier|*
name|parentPtr
decl_stmt|,
modifier|*
name|dummy1Ptr
decl_stmt|,
modifier|*
name|dummy2Ptr
decl_stmt|;
name|Namespace
modifier|*
name|globalNsPtr
init|=
name|iPtr
operator|->
name|globalNsPtr
decl_stmt|;
name|char
modifier|*
name|simpleName
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|entryPtr
decl_stmt|;
name|Tcl_DString
name|buffer1
decl_stmt|,
name|buffer2
decl_stmt|;
name|int
name|newEntry
decl_stmt|,
name|result
decl_stmt|;
comment|/*      * If there is no active namespace, the interpreter is being      * initialized.       */
if|if
condition|(
operator|(
name|globalNsPtr
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|iPtr
operator|->
name|varFramePtr
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* 	 * Treat this namespace as the global namespace, and avoid 	 * looking for a parent. 	 */
name|parentPtr
operator|=
name|NULL
expr_stmt|;
name|simpleName
operator|=
literal|""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"can't create namespace \"\": only global namespace can have empty name"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
block|{
comment|/* 	 * Find the parent for the new namespace. 	 */
name|result
operator|=
name|TclGetNamespaceForQualName
argument_list|(
name|interp
argument_list|,
name|name
argument_list|,
operator|(
name|Namespace
operator|*
operator|)
name|NULL
argument_list|,
comment|/*flags*/
operator|(
name|CREATE_NS_IF_UNKNOWN
operator||
name|TCL_LEAVE_ERR_MSG
operator|)
argument_list|,
operator|&
name|parentPtr
argument_list|,
operator|&
name|dummy1Ptr
argument_list|,
operator|&
name|dummy2Ptr
argument_list|,
operator|&
name|simpleName
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|/* 	 * If the unqualified name at the end is empty, there were trailing 	 * "::"s after the namespace's name which we ignore. The new 	 * namespace was already (recursively) created and is pointed to 	 * by parentPtr. 	 */
if|if
condition|(
operator|*
name|simpleName
operator|==
literal|'\0'
condition|)
block|{
return|return
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|parentPtr
return|;
block|}
comment|/*          * Check for a bad namespace name and make sure that the name 	 * does not already exist in the parent namespace. 	 */
if|if
condition|(
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|parentPtr
operator|->
name|childTable
argument_list|,
name|simpleName
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"can't create namespace \""
argument_list|,
name|name
argument_list|,
literal|"\": already exists"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/*      * Create the new namespace and root it in its parent. Increment the      * count of namespaces created.      */
name|numNsCreated
operator|++
expr_stmt|;
name|nsPtr
operator|=
operator|(
name|Namespace
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Namespace
argument_list|)
argument_list|)
expr_stmt|;
name|nsPtr
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|simpleName
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|nsPtr
operator|->
name|name
argument_list|,
name|simpleName
argument_list|)
expr_stmt|;
name|nsPtr
operator|->
name|fullName
operator|=
name|NULL
expr_stmt|;
comment|/* set below */
name|nsPtr
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
name|nsPtr
operator|->
name|deleteProc
operator|=
name|deleteProc
expr_stmt|;
name|nsPtr
operator|->
name|parentPtr
operator|=
name|parentPtr
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
operator|&
name|nsPtr
operator|->
name|childTable
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
name|nsPtr
operator|->
name|nsId
operator|=
name|numNsCreated
expr_stmt|;
name|nsPtr
operator|->
name|interp
operator|=
name|interp
expr_stmt|;
name|nsPtr
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|nsPtr
operator|->
name|activationCount
operator|=
literal|0
expr_stmt|;
name|nsPtr
operator|->
name|refCount
operator|=
literal|0
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
operator|&
name|nsPtr
operator|->
name|cmdTable
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
operator|&
name|nsPtr
operator|->
name|varTable
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
name|nsPtr
operator|->
name|exportArrayPtr
operator|=
name|NULL
expr_stmt|;
name|nsPtr
operator|->
name|numExportPatterns
operator|=
literal|0
expr_stmt|;
name|nsPtr
operator|->
name|maxExportPatterns
operator|=
literal|0
expr_stmt|;
name|nsPtr
operator|->
name|cmdRefEpoch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|parentPtr
operator|!=
name|NULL
condition|)
block|{
name|entryPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
name|parentPtr
operator|->
name|childTable
argument_list|,
name|simpleName
argument_list|,
operator|&
name|newEntry
argument_list|)
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|entryPtr
argument_list|,
operator|(
name|ClientData
operator|)
name|nsPtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * Build the fully qualified name for this namespace.      */
name|Tcl_DStringInit
argument_list|(
operator|&
name|buffer1
argument_list|)
expr_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|buffer2
argument_list|)
expr_stmt|;
for|for
control|(
name|ancestorPtr
operator|=
name|nsPtr
init|;
name|ancestorPtr
operator|!=
name|NULL
condition|;
name|ancestorPtr
operator|=
name|ancestorPtr
operator|->
name|parentPtr
control|)
block|{
if|if
condition|(
name|ancestorPtr
operator|!=
name|globalNsPtr
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|buffer1
argument_list|,
literal|"::"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|buffer1
argument_list|,
name|ancestorPtr
operator|->
name|name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|Tcl_DStringAppend
argument_list|(
operator|&
name|buffer1
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|buffer2
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_DStringSetLength
argument_list|(
operator|&
name|buffer2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|buffer2
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|buffer1
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_DStringSetLength
argument_list|(
operator|&
name|buffer1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|Tcl_DStringValue
argument_list|(
operator|&
name|buffer2
argument_list|)
expr_stmt|;
name|nsPtr
operator|->
name|fullName
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|nsPtr
operator|->
name|fullName
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer1
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer2
argument_list|)
expr_stmt|;
comment|/*      * Return a pointer to the new namespace.      */
return|return
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|nsPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DeleteNamespace --  *  *	Deletes a namespace and all of the commands, variables, and other  *	namespaces within it.  *  * Results:  *	None.  *  * Side effects:  *	When a namespace is deleted, it is automatically removed as a  *	child of its parent namespace. Also, all its commands, variables  *	and child namespaces are deleted.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DeleteNamespace
parameter_list|(
name|namespacePtr
parameter_list|)
name|Tcl_Namespace
modifier|*
name|namespacePtr
decl_stmt|;
comment|/* Points to the namespace to delete. */
block|{
specifier|register
name|Namespace
modifier|*
name|nsPtr
init|=
operator|(
name|Namespace
operator|*
operator|)
name|namespacePtr
decl_stmt|;
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|nsPtr
operator|->
name|interp
decl_stmt|;
name|Namespace
modifier|*
name|globalNsPtr
init|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetGlobalNamespace
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|)
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|entryPtr
decl_stmt|;
comment|/*      * If the namespace is on the call frame stack, it is marked as "dying"      * (NS_DYING is OR'd into its flags): the namespace can't be looked up      * by name but its commands and variables are still usable by those      * active call frames. When all active call frames referring to the      * namespace have been popped from the Tcl stack, Tcl_PopCallFrame will      * call this procedure again to delete everything in the namespace.      * If no nsName objects refer to the namespace (i.e., if its refCount       * is zero), its commands and variables are deleted and the storage for      * its namespace structure is freed. Otherwise, if its refCount is      * nonzero, the namespace's commands and variables are deleted but the      * structure isn't freed. Instead, NS_DEAD is OR'd into the structure's      * flags to allow the namespace resolution code to recognize that the      * namespace is "deleted". The structure's storage is freed by      * FreeNsNameInternalRep when its refCount reaches 0.      */
if|if
condition|(
name|nsPtr
operator|->
name|activationCount
operator|>
literal|0
condition|)
block|{
name|nsPtr
operator|->
name|flags
operator||=
name|NS_DYING
expr_stmt|;
if|if
condition|(
name|nsPtr
operator|->
name|parentPtr
operator|!=
name|NULL
condition|)
block|{
name|entryPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|nsPtr
operator|->
name|parentPtr
operator|->
name|childTable
argument_list|,
name|nsPtr
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|entryPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DeleteHashEntry
argument_list|(
name|entryPtr
argument_list|)
expr_stmt|;
block|}
block|}
name|nsPtr
operator|->
name|parentPtr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * Delete the namespace and everything in it. If this is the global 	 * namespace, then clear it but don't free its storage unless the 	 * interpreter is being torn down. 	 */
name|TclTeardownNamespace
argument_list|(
name|nsPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nsPtr
operator|!=
name|globalNsPtr
operator|)
operator|||
operator|(
name|iPtr
operator|->
name|flags
operator|&
name|DELETED
operator|)
condition|)
block|{
comment|/* 	     * If this is the global namespace, then it may have residual              * "errorInfo" and "errorCode" variables for errors that              * occurred while it was being torn down.  Try to clear the              * variable list one last time. 	     */
name|TclDeleteVars
argument_list|(
operator|(
name|Interp
operator|*
operator|)
name|nsPtr
operator|->
name|interp
argument_list|,
operator|&
name|nsPtr
operator|->
name|varTable
argument_list|)
expr_stmt|;
name|Tcl_DeleteHashTable
argument_list|(
operator|&
name|nsPtr
operator|->
name|childTable
argument_list|)
expr_stmt|;
name|Tcl_DeleteHashTable
argument_list|(
operator|&
name|nsPtr
operator|->
name|cmdTable
argument_list|)
expr_stmt|;
comment|/*              * If the reference count is 0, then discard the namespace.              * Otherwise, mark it as "dead" so that it can't be used.              */
if|if
condition|(
name|nsPtr
operator|->
name|refCount
operator|==
literal|0
condition|)
block|{
name|NamespaceFree
argument_list|(
name|nsPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nsPtr
operator|->
name|flags
operator||=
name|NS_DEAD
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclTeardownNamespace --  *  *	Used internally to dismantle and unlink a namespace when it is  *	deleted. Divorces the namespace from its parent, and deletes all  *	commands, variables, and child namespaces.  *  *	This is kept separate from Tcl_DeleteNamespace so that the global  *	namespace can be handled specially. Global variables like  *	"errorInfo" and "errorCode" need to remain intact while other  *	namespaces and commands are torn down, in case any errors occur.  *  * Results:  *	None.  *  * Side effects:  *	Removes this namespace from its parent's child namespace hashtable.  *	Deletes all commands, variables and namespaces in this namespace.  *	If this is the global namespace, the "errorInfo" and "errorCode"  *	variables are left alone and deleted later.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclTeardownNamespace
parameter_list|(
name|nsPtr
parameter_list|)
specifier|register
name|Namespace
modifier|*
name|nsPtr
decl_stmt|;
comment|/* Points to the namespace to be dismantled 				 * and unlinked from its parent. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|nsPtr
operator|->
name|interp
decl_stmt|;
specifier|register
name|Tcl_HashEntry
modifier|*
name|entryPtr
decl_stmt|;
name|Tcl_HashSearch
name|search
decl_stmt|;
name|Tcl_Namespace
modifier|*
name|childNsPtr
decl_stmt|;
name|Tcl_Command
name|cmd
decl_stmt|;
name|Namespace
modifier|*
name|globalNsPtr
init|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetGlobalNamespace
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*      * Start by destroying the namespace's variable table,      * since variables might trigger traces.      */
if|if
condition|(
name|nsPtr
operator|==
name|globalNsPtr
condition|)
block|{
comment|/* 	 * This is the global namespace, so be careful to preserve the 	 * "errorInfo" and "errorCode" variables. These might be needed 	 * later on if errors occur while deleting commands. We are careful 	 * to destroy and recreate the "errorInfo" and "errorCode" 	 * variables, in case they had any traces on them. 	 */
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|errorInfoStr
decl_stmt|,
modifier|*
name|errorCodeStr
decl_stmt|;
name|str
operator|=
name|Tcl_GetVar
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"errorInfo"
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
block|{
name|errorInfoStr
operator|=
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|errorInfoStr
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errorInfoStr
operator|=
name|NULL
expr_stmt|;
block|}
name|str
operator|=
name|Tcl_GetVar
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"errorCode"
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
block|{
name|errorCodeStr
operator|=
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|errorCodeStr
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errorCodeStr
operator|=
name|NULL
expr_stmt|;
block|}
name|TclDeleteVars
argument_list|(
name|iPtr
argument_list|,
operator|&
name|nsPtr
operator|->
name|varTable
argument_list|)
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
operator|&
name|nsPtr
operator|->
name|varTable
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorInfoStr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_SetVar
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"errorInfo"
argument_list|,
name|errorInfoStr
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|errorInfoStr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errorCodeStr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_SetVar
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"errorCode"
argument_list|,
name|errorCodeStr
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|errorCodeStr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	 * Variable table should be cleared but not freed! TclDeleteVars 	 * frees it, so we reinitialize it afterwards. 	 */
name|TclDeleteVars
argument_list|(
name|iPtr
argument_list|,
operator|&
name|nsPtr
operator|->
name|varTable
argument_list|)
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
operator|&
name|nsPtr
operator|->
name|varTable
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
block|}
comment|/*      * Remove the namespace from its parent's child hashtable.      */
if|if
condition|(
name|nsPtr
operator|->
name|parentPtr
operator|!=
name|NULL
condition|)
block|{
name|entryPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|nsPtr
operator|->
name|parentPtr
operator|->
name|childTable
argument_list|,
name|nsPtr
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|entryPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_DeleteHashEntry
argument_list|(
name|entryPtr
argument_list|)
expr_stmt|;
block|}
block|}
name|nsPtr
operator|->
name|parentPtr
operator|=
name|NULL
expr_stmt|;
comment|/*      * Delete all the child namespaces.      *      * BE CAREFUL: When each child is deleted, it will divorce      *    itself from its parent. You can't traverse a hash table      *    properly if its elements are being deleted. We use only      *    the Tcl_FirstHashEntry function to be safe.      */
for|for
control|(
name|entryPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
name|nsPtr
operator|->
name|childTable
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|entryPtr
operator|!=
name|NULL
condition|;
name|entryPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
name|nsPtr
operator|->
name|childTable
argument_list|,
operator|&
name|search
argument_list|)
control|)
block|{
name|childNsPtr
operator|=
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|entryPtr
argument_list|)
expr_stmt|;
name|Tcl_DeleteNamespace
argument_list|(
name|childNsPtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * Delete all commands in this namespace. Be careful when traversing the      * hash table: when each command is deleted, it removes itself from the      * command table.      */
for|for
control|(
name|entryPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
name|nsPtr
operator|->
name|cmdTable
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|entryPtr
operator|!=
name|NULL
condition|;
name|entryPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
name|nsPtr
operator|->
name|cmdTable
argument_list|,
operator|&
name|search
argument_list|)
control|)
block|{
name|cmd
operator|=
operator|(
name|Tcl_Command
operator|)
name|Tcl_GetHashValue
argument_list|(
name|entryPtr
argument_list|)
expr_stmt|;
name|Tcl_DeleteCommandFromToken
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
name|Tcl_DeleteHashTable
argument_list|(
operator|&
name|nsPtr
operator|->
name|cmdTable
argument_list|)
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
operator|&
name|nsPtr
operator|->
name|cmdTable
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
comment|/*      * Free the namespace's export pattern array.      */
if|if
condition|(
name|nsPtr
operator|->
name|exportArrayPtr
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsPtr
operator|->
name|numExportPatterns
condition|;
name|i
operator|++
control|)
block|{
name|ckfree
argument_list|(
name|nsPtr
operator|->
name|exportArrayPtr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nsPtr
operator|->
name|exportArrayPtr
argument_list|)
expr_stmt|;
name|nsPtr
operator|->
name|exportArrayPtr
operator|=
name|NULL
expr_stmt|;
name|nsPtr
operator|->
name|numExportPatterns
operator|=
literal|0
expr_stmt|;
name|nsPtr
operator|->
name|maxExportPatterns
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * Free any client data associated with the namespace.      */
if|if
condition|(
name|nsPtr
operator|->
name|deleteProc
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|nsPtr
operator|->
name|deleteProc
call|)
argument_list|(
name|nsPtr
operator|->
name|clientData
argument_list|)
expr_stmt|;
block|}
name|nsPtr
operator|->
name|deleteProc
operator|=
name|NULL
expr_stmt|;
name|nsPtr
operator|->
name|clientData
operator|=
name|NULL
expr_stmt|;
comment|/*      * Reset the namespace's id field to ensure that this namespace won't      * be interpreted as valid by, e.g., the cache validation code for      * cached command references in Tcl_GetCommandFromObj.      */
name|nsPtr
operator|->
name|nsId
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * NamespaceFree --  *  *	Called after a namespace has been deleted, when its  *	reference count reaches 0.  Frees the data structure  *	representing the namespace.  *  * Results:  *	None.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|NamespaceFree
parameter_list|(
name|nsPtr
parameter_list|)
specifier|register
name|Namespace
modifier|*
name|nsPtr
decl_stmt|;
comment|/* Points to the namespace to free. */
block|{
comment|/*      * Most of the namespace's contents are freed when the namespace is      * deleted by Tcl_DeleteNamespace. All that remains is to free its names      * (for error messages), and the structure itself.      */
name|ckfree
argument_list|(
name|nsPtr
operator|->
name|name
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|nsPtr
operator|->
name|fullName
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nsPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_Export --  *  *	Makes all the commands matching a pattern available to later be  *	imported from the namespace specified by contextNsPtr (or the  *	current namespace if contextNsPtr is NULL). The specified pattern is  *	appended onto the namespace's export pattern list, which is  *	optionally cleared beforehand.  *  * Results:  *	Returns TCL_OK if successful, or TCL_ERROR (along with an error  *	message in the interpreter's result) if something goes wrong.  *  * Side effects:  *	Appends the export pattern onto the namespace's export list.  *	Optionally reset the namespace's export pattern list.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_Export
parameter_list|(
name|interp
parameter_list|,
name|namespacePtr
parameter_list|,
name|pattern
parameter_list|,
name|resetListFirst
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|Tcl_Namespace
modifier|*
name|namespacePtr
decl_stmt|;
comment|/* Points to the namespace from which  				  * commands are to be exported. NULL for                                   * the current namespace. */
name|char
modifier|*
name|pattern
decl_stmt|;
comment|/* String pattern indicating which commands                                   * to export. This pattern may not include 				  * any namespace qualifiers; only commands 				  * in the specified namespace may be 				  * exported. */
name|int
name|resetListFirst
decl_stmt|;
comment|/* If nonzero, resets the namespace's 				  * export list before appending  				  * be overwritten by imported commands. 				  * If 0, return an error if an imported 				  * cmd conflicts with an existing one. */
block|{
define|#
directive|define
name|INIT_EXPORT_PATTERNS
value|5
name|Namespace
modifier|*
name|nsPtr
decl_stmt|,
modifier|*
name|exportNsPtr
decl_stmt|,
modifier|*
name|dummyPtr
decl_stmt|;
name|Namespace
modifier|*
name|currNsPtr
init|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetCurrentNamespace
argument_list|(
name|interp
argument_list|)
decl_stmt|;
name|char
modifier|*
name|simplePattern
decl_stmt|,
modifier|*
name|patternCpy
decl_stmt|;
name|int
name|neededElems
decl_stmt|,
name|len
decl_stmt|,
name|i
decl_stmt|,
name|result
decl_stmt|;
comment|/*      * If the specified namespace is NULL, use the current namespace.      */
if|if
condition|(
name|namespacePtr
operator|==
name|NULL
condition|)
block|{
name|nsPtr
operator|=
operator|(
name|Namespace
operator|*
operator|)
name|currNsPtr
expr_stmt|;
block|}
else|else
block|{
name|nsPtr
operator|=
operator|(
name|Namespace
operator|*
operator|)
name|namespacePtr
expr_stmt|;
block|}
comment|/*      * If resetListFirst is true (nonzero), clear the namespace's export      * pattern list.      */
if|if
condition|(
name|resetListFirst
condition|)
block|{
if|if
condition|(
name|nsPtr
operator|->
name|exportArrayPtr
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsPtr
operator|->
name|numExportPatterns
condition|;
name|i
operator|++
control|)
block|{
name|ckfree
argument_list|(
name|nsPtr
operator|->
name|exportArrayPtr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nsPtr
operator|->
name|exportArrayPtr
argument_list|)
expr_stmt|;
name|nsPtr
operator|->
name|exportArrayPtr
operator|=
name|NULL
expr_stmt|;
name|nsPtr
operator|->
name|numExportPatterns
operator|=
literal|0
expr_stmt|;
name|nsPtr
operator|->
name|maxExportPatterns
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/*      * Check that the pattern doesn't have namespace qualifiers.      */
name|result
operator|=
name|TclGetNamespaceForQualName
argument_list|(
name|interp
argument_list|,
name|pattern
argument_list|,
name|nsPtr
argument_list|,
comment|/*flags*/
name|TCL_LEAVE_ERR_MSG
argument_list|,
operator|&
name|exportNsPtr
argument_list|,
operator|&
name|dummyPtr
argument_list|,
operator|&
name|dummyPtr
argument_list|,
operator|&
name|simplePattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
if|if
condition|(
operator|(
name|exportNsPtr
operator|!=
name|nsPtr
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|pattern
argument_list|,
name|simplePattern
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"invalid export pattern \""
argument_list|,
name|pattern
argument_list|,
literal|"\": pattern can't specify a namespace"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Make sure there is room in the namespace's pattern array for the      * new pattern.      */
name|neededElems
operator|=
name|nsPtr
operator|->
name|numExportPatterns
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nsPtr
operator|->
name|exportArrayPtr
operator|==
name|NULL
condition|)
block|{
name|nsPtr
operator|->
name|exportArrayPtr
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|INIT_EXPORT_PATTERNS
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|nsPtr
operator|->
name|numExportPatterns
operator|=
literal|0
expr_stmt|;
name|nsPtr
operator|->
name|maxExportPatterns
operator|=
name|INIT_EXPORT_PATTERNS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|neededElems
operator|>
name|nsPtr
operator|->
name|maxExportPatterns
condition|)
block|{
name|int
name|numNewElems
init|=
literal|2
operator|*
name|nsPtr
operator|->
name|maxExportPatterns
decl_stmt|;
name|size_t
name|currBytes
init|=
name|nsPtr
operator|->
name|numExportPatterns
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
decl_stmt|;
name|size_t
name|newBytes
init|=
name|numNewElems
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|newPtr
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|newBytes
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|newPtr
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|nsPtr
operator|->
name|exportArrayPtr
argument_list|,
name|currBytes
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nsPtr
operator|->
name|exportArrayPtr
argument_list|)
expr_stmt|;
name|nsPtr
operator|->
name|exportArrayPtr
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|newPtr
expr_stmt|;
name|nsPtr
operator|->
name|maxExportPatterns
operator|=
name|numNewElems
expr_stmt|;
block|}
comment|/*      * Add the pattern to the namespace's array of export patterns.      */
name|len
operator|=
name|strlen
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|patternCpy
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|len
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|patternCpy
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
name|nsPtr
operator|->
name|exportArrayPtr
index|[
name|nsPtr
operator|->
name|numExportPatterns
index|]
operator|=
name|patternCpy
expr_stmt|;
name|nsPtr
operator|->
name|numExportPatterns
operator|++
expr_stmt|;
return|return
name|TCL_OK
return|;
undef|#
directive|undef
name|INIT_EXPORT_PATTERNS
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_AppendExportList --  *  *	Appends onto the argument object the list of export patterns for the  *	specified namespace.  *  * Results:  *	The return value is normally TCL_OK; in this case the object  *	referenced by objPtr has each export pattern appended to it. If an  *	error occurs, TCL_ERROR is returned and the interpreter's result  *	holds an error message.  *  * Side effects:  *	If necessary, the object referenced by objPtr is converted into  *	a list object.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_AppendExportList
parameter_list|(
name|interp
parameter_list|,
name|namespacePtr
parameter_list|,
name|objPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter used for error reporting. */
name|Tcl_Namespace
modifier|*
name|namespacePtr
decl_stmt|;
comment|/* Points to the namespace whose export 				  * pattern list is appended onto objPtr. 				  * NULL for the current namespace. */
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Points to the Tcl object onto which the 				  * export pattern list is appended. */
block|{
name|Namespace
modifier|*
name|nsPtr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|result
decl_stmt|;
comment|/*      * If the specified namespace is NULL, use the current namespace.      */
if|if
condition|(
name|namespacePtr
operator|==
name|NULL
condition|)
block|{
name|nsPtr
operator|=
operator|(
name|Namespace
operator|*
operator|)
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetCurrentNamespace
argument_list|(
name|interp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nsPtr
operator|=
operator|(
name|Namespace
operator|*
operator|)
name|namespacePtr
expr_stmt|;
block|}
comment|/*      * Append the export pattern list onto objPtr.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsPtr
operator|->
name|numExportPatterns
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|objPtr
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|nsPtr
operator|->
name|exportArrayPtr
index|[
name|i
index|]
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_Import --  *  *	Imports all of the commands matching a pattern into the namespace  *	specified by contextNsPtr (or the current namespace if contextNsPtr  *	is NULL). This is done by creating a new command (the "imported  *	command") that points to the real command in its original namespace.  *  * Results:  *	Returns TCL_OK if successful, or TCL_ERROR (along with an error  *	message in the interpreter's result) if something goes wrong.  *  * Side effects:  *	Creates new commands in the importing namespace. These indirect  *	calls back to the real command and are deleted if the real commands  *	are deleted.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_Import
parameter_list|(
name|interp
parameter_list|,
name|namespacePtr
parameter_list|,
name|pattern
parameter_list|,
name|allowOverwrite
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|Tcl_Namespace
modifier|*
name|namespacePtr
decl_stmt|;
comment|/* Points to the namespace into which the 				  * commands are to be imported. NULL for                                   * the current namespace. */
name|char
modifier|*
name|pattern
decl_stmt|;
comment|/* String pattern indicating which commands                                   * to import. This pattern should be 				  * qualified by the name of the namespace 				  * from which to import the command(s). */
name|int
name|allowOverwrite
decl_stmt|;
comment|/* If nonzero, allow existing commands to 				  * be overwritten by imported commands. 				  * If 0, return an error if an imported 				  * cmd conflicts with an existing one. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Namespace
modifier|*
name|nsPtr
decl_stmt|,
modifier|*
name|importNsPtr
decl_stmt|,
modifier|*
name|dummyPtr
decl_stmt|;
name|Namespace
modifier|*
name|currNsPtr
init|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetCurrentNamespace
argument_list|(
name|interp
argument_list|)
decl_stmt|;
name|char
modifier|*
name|simplePattern
decl_stmt|,
modifier|*
name|cmdName
decl_stmt|;
specifier|register
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|Tcl_HashSearch
name|search
decl_stmt|;
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
name|ImportRef
modifier|*
name|refPtr
decl_stmt|;
name|Tcl_Command
name|importedCmd
decl_stmt|;
name|ImportedCmdData
modifier|*
name|dataPtr
decl_stmt|;
name|int
name|wasExported
decl_stmt|,
name|i
decl_stmt|,
name|result
decl_stmt|;
comment|/*      * If the specified namespace is NULL, use the current namespace.      */
if|if
condition|(
name|namespacePtr
operator|==
name|NULL
condition|)
block|{
name|nsPtr
operator|=
operator|(
name|Namespace
operator|*
operator|)
name|currNsPtr
expr_stmt|;
block|}
else|else
block|{
name|nsPtr
operator|=
operator|(
name|Namespace
operator|*
operator|)
name|namespacePtr
expr_stmt|;
block|}
comment|/*      * From the pattern, find the namespace from which we are importing      * and get the simple pattern (no namespace qualifiers or ::'s) at      * the end.      */
if|if
condition|(
name|strlen
argument_list|(
name|pattern
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_SetStringObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"empty import pattern"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|result
operator|=
name|TclGetNamespaceForQualName
argument_list|(
name|interp
argument_list|,
name|pattern
argument_list|,
name|nsPtr
argument_list|,
comment|/*flags*/
name|TCL_LEAVE_ERR_MSG
argument_list|,
operator|&
name|importNsPtr
argument_list|,
operator|&
name|dummyPtr
argument_list|,
operator|&
name|dummyPtr
argument_list|,
operator|&
name|simplePattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|importNsPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"unknown namespace in import pattern \""
argument_list|,
name|pattern
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|importNsPtr
operator|==
name|nsPtr
condition|)
block|{
if|if
condition|(
name|pattern
operator|==
name|simplePattern
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"no namespace specified in import pattern \""
argument_list|,
name|pattern
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"import pattern \""
argument_list|,
name|pattern
argument_list|,
literal|"\" tries to import from namespace \""
argument_list|,
name|importNsPtr
operator|->
name|name
argument_list|,
literal|"\" into itself"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Scan through the command table in the source namespace and look for      * exported commands that match the string pattern. Create an "imported      * command" in the current namespace for each imported command; these      * commands redirect their invocations to the "real" command.      */
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
name|importNsPtr
operator|->
name|cmdTable
argument_list|,
operator|&
name|search
argument_list|)
init|;
operator|(
name|hPtr
operator|!=
name|NULL
operator|)
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
name|cmdName
operator|=
name|Tcl_GetHashKey
argument_list|(
operator|&
name|importNsPtr
operator|->
name|cmdTable
argument_list|,
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_StringMatch
argument_list|(
name|cmdName
argument_list|,
name|simplePattern
argument_list|)
condition|)
block|{
comment|/* 	     * The command cmdName in the source namespace matches the 	     * pattern. Check whether it was exported. If it wasn't, 	     * we ignore it. 	     */
name|wasExported
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|importNsPtr
operator|->
name|numExportPatterns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Tcl_StringMatch
argument_list|(
name|cmdName
argument_list|,
name|importNsPtr
operator|->
name|exportArrayPtr
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|wasExported
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|wasExported
condition|)
block|{
continue|continue;
block|}
comment|/* 	     * Unless there is a name clash, create an imported command 	     * in the current namespace that refers to cmdPtr. 	     */
if|if
condition|(
operator|(
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|nsPtr
operator|->
name|cmdTable
argument_list|,
name|cmdName
argument_list|)
operator|==
name|NULL
operator|)
operator|||
name|allowOverwrite
condition|)
block|{
comment|/* 		 * Create the imported command and its client data. 		 * To create the new command in the current namespace,  		 * generate a fully qualified name for it. 		 */
name|Tcl_DString
name|ds
decl_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|ds
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|ds
argument_list|,
name|currNsPtr
operator|->
name|fullName
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|currNsPtr
operator|!=
name|iPtr
operator|->
name|globalNsPtr
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|ds
argument_list|,
literal|"::"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|Tcl_DStringAppend
argument_list|(
operator|&
name|ds
argument_list|,
name|cmdName
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
name|dataPtr
operator|=
operator|(
name|ImportedCmdData
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ImportedCmdData
argument_list|)
argument_list|)
expr_stmt|;
name|importedCmd
operator|=
name|Tcl_CreateObjCommand
argument_list|(
name|interp
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|ds
argument_list|)
argument_list|,
name|InvokeImportedCmd
argument_list|,
operator|(
name|ClientData
operator|)
name|dataPtr
argument_list|,
name|DeleteImportedCmd
argument_list|)
expr_stmt|;
name|dataPtr
operator|->
name|realCmdPtr
operator|=
name|cmdPtr
expr_stmt|;
name|dataPtr
operator|->
name|selfPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|importedCmd
expr_stmt|;
comment|/* 		 * Create an ImportRef structure describing this new import 		 * command and add it to the import ref list in the "real" 		 * command. 		 */
name|refPtr
operator|=
operator|(
name|ImportRef
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ImportRef
argument_list|)
argument_list|)
expr_stmt|;
name|refPtr
operator|->
name|importedCmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|importedCmd
expr_stmt|;
name|refPtr
operator|->
name|nextPtr
operator|=
name|cmdPtr
operator|->
name|importRefPtr
expr_stmt|;
name|cmdPtr
operator|->
name|importRefPtr
operator|=
name|refPtr
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"can't import command \""
argument_list|,
name|cmdName
argument_list|,
literal|"\": already exists"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ForgetImport --  *  *	Deletes previously imported commands. Given a pattern that may  *	include the name of an exporting namespace, this procedure first  *	finds all matching exported commands. It then looks in the namespace  *	specified by namespacePtr for any corresponding previously imported  *	commands, which it deletes. If namespacePtr is NULL, commands are  *	deleted from the current namespace.  *  * Results:  *	Returns TCL_OK if successful. If there is an error, returns  *	TCL_ERROR and puts an error message in the interpreter's result  *	object.  *  * Side effects:  *	May delete commands.   *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_ForgetImport
parameter_list|(
name|interp
parameter_list|,
name|namespacePtr
parameter_list|,
name|pattern
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|Tcl_Namespace
modifier|*
name|namespacePtr
decl_stmt|;
comment|/* Points to the namespace from which 				  * previously imported commands should be 				  * removed. NULL for current namespace. */
name|char
modifier|*
name|pattern
decl_stmt|;
comment|/* String pattern indicating which imported 				  * commands to remove. This pattern should 				  * be qualified by the name of the 				  * namespace from which the command(s) were 				  * imported. */
block|{
name|Namespace
modifier|*
name|nsPtr
decl_stmt|,
modifier|*
name|importNsPtr
decl_stmt|,
modifier|*
name|dummyPtr
decl_stmt|,
modifier|*
name|actualCtxPtr
decl_stmt|;
name|char
modifier|*
name|simplePattern
decl_stmt|,
modifier|*
name|cmdName
decl_stmt|;
specifier|register
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|Tcl_HashSearch
name|search
decl_stmt|;
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/*      * If the specified namespace is NULL, use the current namespace.      */
if|if
condition|(
name|namespacePtr
operator|==
name|NULL
condition|)
block|{
name|nsPtr
operator|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetCurrentNamespace
argument_list|(
name|interp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nsPtr
operator|=
operator|(
name|Namespace
operator|*
operator|)
name|namespacePtr
expr_stmt|;
block|}
comment|/*      * From the pattern, find the namespace from which we are importing      * and get the simple pattern (no namespace qualifiers or ::'s) at      * the end.      */
name|result
operator|=
name|TclGetNamespaceForQualName
argument_list|(
name|interp
argument_list|,
name|pattern
argument_list|,
name|nsPtr
argument_list|,
comment|/*flags*/
name|TCL_LEAVE_ERR_MSG
argument_list|,
operator|&
name|importNsPtr
argument_list|,
operator|&
name|dummyPtr
argument_list|,
operator|&
name|actualCtxPtr
argument_list|,
operator|&
name|simplePattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
if|if
condition|(
name|importNsPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"unknown namespace in namespace forget pattern \""
argument_list|,
name|pattern
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Scan through the command table in the source namespace and look for      * exported commands that match the string pattern. If the current      * namespace has an imported command that refers to one of those real      * commands, delete it.      */
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
name|importNsPtr
operator|->
name|cmdTable
argument_list|,
operator|&
name|search
argument_list|)
init|;
operator|(
name|hPtr
operator|!=
name|NULL
operator|)
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
name|cmdName
operator|=
name|Tcl_GetHashKey
argument_list|(
operator|&
name|importNsPtr
operator|->
name|cmdTable
argument_list|,
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_StringMatch
argument_list|(
name|cmdName
argument_list|,
name|simplePattern
argument_list|)
condition|)
block|{
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|nsPtr
operator|->
name|cmdTable
argument_list|,
name|cmdName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|!=
name|NULL
condition|)
block|{
comment|/* cmd of same name in current namespace */
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdPtr
operator|->
name|deleteProc
operator|==
name|DeleteImportedCmd
condition|)
block|{
name|Tcl_DeleteCommandFromToken
argument_list|(
name|interp
argument_list|,
operator|(
name|Tcl_Command
operator|)
name|cmdPtr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclGetOriginalCommand --  *  *	An imported command is created in an namespace when it imports a  *	"real" command from another namespace. If the specified command is a  *	imported command, this procedure returns the original command it  *	refers to.    *  * Results:  *	If the command was imported into a sequence of namespaces a, b,...,n  *	where each successive namespace just imports the command from the  *	previous namespace, this procedure returns the Tcl_Command token in  *	the first namespace, a. Otherwise, if the specified command is not  *	an imported command, the procedure returns NULL.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Command
name|TclGetOriginalCommand
parameter_list|(
name|command
parameter_list|)
name|Tcl_Command
name|command
decl_stmt|;
comment|/* The command for which the original 				 * command should be returned. */
block|{
specifier|register
name|Command
modifier|*
name|cmdPtr
init|=
operator|(
name|Command
operator|*
operator|)
name|command
decl_stmt|;
name|ImportedCmdData
modifier|*
name|dataPtr
decl_stmt|;
if|if
condition|(
name|cmdPtr
operator|->
name|deleteProc
operator|!=
name|DeleteImportedCmd
condition|)
block|{
return|return
operator|(
name|Tcl_Command
operator|)
name|NULL
return|;
block|}
while|while
condition|(
name|cmdPtr
operator|->
name|deleteProc
operator|==
name|DeleteImportedCmd
condition|)
block|{
name|dataPtr
operator|=
operator|(
name|ImportedCmdData
operator|*
operator|)
name|cmdPtr
operator|->
name|objClientData
expr_stmt|;
name|cmdPtr
operator|=
name|dataPtr
operator|->
name|realCmdPtr
expr_stmt|;
block|}
return|return
operator|(
name|Tcl_Command
operator|)
name|cmdPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InvokeImportedCmd --  *  *	Invoked by Tcl whenever the user calls an imported command that  *	was created by Tcl_Import. Finds the "real" command (in another  *	namespace), and passes control to it.  *  * Results:  *	Returns TCL_OK if successful, and  TCL_ERROR if anything goes wrong.  *  * Side effects:  *	Returns a result in the interpreter's result object. If anything  *	goes wrong, the result object is set to an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InvokeImportedCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Points to the imported command's 				 * ImportedCmdData structure. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* The argument objects. */
block|{
specifier|register
name|ImportedCmdData
modifier|*
name|dataPtr
init|=
operator|(
name|ImportedCmdData
operator|*
operator|)
name|clientData
decl_stmt|;
specifier|register
name|Command
modifier|*
name|realCmdPtr
init|=
name|dataPtr
operator|->
name|realCmdPtr
decl_stmt|;
return|return
call|(
modifier|*
name|realCmdPtr
operator|->
name|objProc
call|)
argument_list|(
name|realCmdPtr
operator|->
name|objClientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DeleteImportedCmd --  *  *	Invoked by Tcl whenever an imported command is deleted. The "real"  *	command keeps a list of all the imported commands that refer to it,  *	so those imported commands can be deleted when the real command is  *	deleted. This procedure removes the imported command reference from  *	the real command's list, and frees up the memory associated with  *	the imported command.  *  * Results:  *	None.  *  * Side effects:  *	Removes the imported command from the real command's import list.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|DeleteImportedCmd
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Points to the imported command's 				 * ImportedCmdData structure. */
block|{
name|ImportedCmdData
modifier|*
name|dataPtr
init|=
operator|(
name|ImportedCmdData
operator|*
operator|)
name|clientData
decl_stmt|;
name|Command
modifier|*
name|realCmdPtr
init|=
name|dataPtr
operator|->
name|realCmdPtr
decl_stmt|;
name|Command
modifier|*
name|selfPtr
init|=
name|dataPtr
operator|->
name|selfPtr
decl_stmt|;
specifier|register
name|ImportRef
modifier|*
name|refPtr
decl_stmt|,
modifier|*
name|prevPtr
decl_stmt|;
name|prevPtr
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|refPtr
operator|=
name|realCmdPtr
operator|->
name|importRefPtr
init|;
name|refPtr
operator|!=
name|NULL
condition|;
name|refPtr
operator|=
name|refPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|refPtr
operator|->
name|importedCmdPtr
operator|==
name|selfPtr
condition|)
block|{
comment|/* 	     * Remove *refPtr from real command's list of imported commands 	     * that refer to it. 	     */
if|if
condition|(
name|prevPtr
operator|==
name|NULL
condition|)
block|{
comment|/* refPtr is first in list */
name|realCmdPtr
operator|->
name|importRefPtr
operator|=
name|refPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
name|prevPtr
operator|->
name|nextPtr
operator|=
name|refPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|refPtr
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dataPtr
argument_list|)
expr_stmt|;
return|return;
block|}
name|prevPtr
operator|=
name|refPtr
expr_stmt|;
block|}
name|panic
argument_list|(
literal|"DeleteImportedCmd: did not find cmd in real cmd's list of import references"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclGetNamespaceForQualName --  *  *	Given a qualified name specifying a command, variable, or namespace,  *	and a namespace in which to resolve the name, this procedure returns  *	a pointer to the namespace that contains the item. A qualified name  *	consists of the "simple" name of an item qualified by the names of  *	an arbitrary number of containing namespace separated by "::"s. If  *	the qualified name starts with "::", it is interpreted absolutely  *	from the global namespace. Otherwise, it is interpreted relative to  *	the namespace specified by cxtNsPtr if it is non-NULL. If cxtNsPtr  *	is NULL, the name is interpreted relative to the current namespace.  *  *	A relative name like "foo::bar::x" can be found starting in either  *	the current namespace or in the global namespace. So each search  *	usually follows two tracks, and two possible namespaces are  *	returned. If the procedure sets either *nsPtrPtr or *altNsPtrPtr to  *	NULL, then that path failed.  *  *	If "flags" contains TCL_GLOBAL_ONLY, the relative qualified name is  *	sought only in the global :: namespace. The alternate search  *	(also) starting from the global namespace is ignored and  *	*altNsPtrPtr is set NULL.   *  *	If "flags" contains TCL_NAMESPACE_ONLY, the relative qualified  *	name is sought only in the namespace specified by cxtNsPtr. The  *	alternate search starting from the global namespace is ignored and  *	*altNsPtrPtr is set NULL. If both TCL_GLOBAL_ONLY and  *	TCL_NAMESPACE_ONLY are specified, TCL_GLOBAL_ONLY is ignored and  *	the search starts from the namespace specified by cxtNsPtr.  *  *	If "flags" contains CREATE_NS_IF_UNKNOWN, all namespace  *	components of the qualified name that cannot be found are  *	automatically created within their specified parent. This makes sure  *	that functions like Tcl_CreateCommand always succeed. There is no  *	alternate search path, so *altNsPtrPtr is set NULL.  *  *	If "flags" contains FIND_ONLY_NS, the qualified name is treated as a  *	reference to a namespace, and the entire qualified name is  *	followed. If the name is relative, the namespace is looked up only  *	in the current namespace. A pointer to the namespace is stored in  *	*nsPtrPtr and NULL is stored in *simpleNamePtr. Otherwise, if  *	FIND_ONLY_NS is not specified, only the leading components are  *	treated as namespace names, and a pointer to the simple name of the  *	final component is stored in *simpleNamePtr.  *  * Results:  *	Ordinarily this procedure returns TCL_OK. It sets *nsPtrPtr and  *	*altNsPtrPtr to point to the two possible namespaces which represent  *	the last (containing) namespace in the qualified name. If the  *	procedure sets either *nsPtrPtr or *altNsPtrPtr to NULL, then the  *	search along that path failed. The procedure also stores a pointer  *	to the simple name of the final component in *simpleNamePtr. If the  *	qualified name is "::" or was treated as a namespace reference  *	(FIND_ONLY_NS), the procedure stores a pointer to the  *	namespace in *nsPtrPtr, NULL in *altNsPtrPtr, and sets  *	*simpleNamePtr to point to an empty string.  *  *	If there is an error, this procedure returns TCL_ERROR. If "flags"  *	contains TCL_LEAVE_ERR_MSG, an error message is returned in the  *	interpreter's result object. Otherwise, the interpreter's result  *	object is left unchanged.  *  *	*actualCxtPtrPtr is set to the actual context namespace. It is  *	set to the input context namespace pointer in cxtNsPtr. If cxtNsPtr  *	is NULL, it is set to the current namespace context.  *  * Side effects:  *	If flags contains TCL_LEAVE_ERR_MSG and an error is encountered,  *	the interpreter's result object will contain an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclGetNamespaceForQualName
parameter_list|(
name|interp
parameter_list|,
name|qualName
parameter_list|,
name|cxtNsPtr
parameter_list|,
name|flags
parameter_list|,
name|nsPtrPtr
parameter_list|,
name|altNsPtrPtr
parameter_list|,
name|actualCxtPtrPtr
parameter_list|,
name|simpleNamePtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to find the 				  * namespace containing qualName. */
specifier|register
name|char
modifier|*
name|qualName
decl_stmt|;
comment|/* A namespace-qualified name of an 				  * command, variable, or namespace. */
name|Namespace
modifier|*
name|cxtNsPtr
decl_stmt|;
comment|/* The namespace in which to start the 				  * search for qualName's namespace. If NULL 				  * start from the current namespace. 				  * Ignored if TCL_GLOBAL_ONLY or 				  * TCL_NAMESPACE_ONLY are set. */
name|int
name|flags
decl_stmt|;
comment|/* Flags controlling the search: an OR'd 				  * combination of TCL_GLOBAL_ONLY, 				  * TCL_NAMESPACE_ONLY, 				  * CREATE_NS_IF_UNKNOWN, and 				  * FIND_ONLY_NS. */
name|Namespace
modifier|*
modifier|*
name|nsPtrPtr
decl_stmt|;
comment|/* Address where procedure stores a pointer 				  * to containing namespace if qualName is 				  * found starting from *cxtNsPtr or, if 				  * TCL_GLOBAL_ONLY is set, if qualName is 				  * found in the global :: namespace. NULL 				  * is stored otherwise. */
name|Namespace
modifier|*
modifier|*
name|altNsPtrPtr
decl_stmt|;
comment|/* Address where procedure stores a pointer 				  * to containing namespace if qualName is 				  * found starting from the global :: 				  * namespace. NULL is stored if qualName 				  * isn't found starting from :: or if the 				  * TCL_GLOBAL_ONLY, TCL_NAMESPACE_ONLY, 				  * CREATE_NS_IF_UNKNOWN, FIND_ONLY_NS flag 				  * is set. */
name|Namespace
modifier|*
modifier|*
name|actualCxtPtrPtr
decl_stmt|;
comment|/* Address where procedure stores a pointer 				  * to the actual namespace from which the 				  * search started. This is either cxtNsPtr, 				  * the :: namespace if TCL_GLOBAL_ONLY was 				  * specified, or the current namespace if 				  * cxtNsPtr was NULL. */
name|char
modifier|*
modifier|*
name|simpleNamePtr
decl_stmt|;
comment|/* Address where procedure stores the 				  * simple name at end of the qualName, or 				  * NULL if qualName is "::" or the flag 				  * FIND_ONLY_NS was specified. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Namespace
modifier|*
name|nsPtr
init|=
name|cxtNsPtr
decl_stmt|;
name|Namespace
modifier|*
name|altNsPtr
decl_stmt|;
name|Namespace
modifier|*
name|globalNsPtr
init|=
name|iPtr
operator|->
name|globalNsPtr
decl_stmt|;
specifier|register
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
name|nsName
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|entryPtr
decl_stmt|;
name|Tcl_DString
name|buffer
decl_stmt|;
name|int
name|len
decl_stmt|,
name|result
decl_stmt|;
comment|/*      * Determine the context namespace nsPtr in which to start the primary      * search. If TCL_NAMESPACE_ONLY or FIND_ONLY_NS was specified, search      * from the current namespace. If the qualName name starts with a "::"      * or TCL_GLOBAL_ONLY was specified, search from the global      * namespace. Otherwise, use the given namespace given in cxtNsPtr, or      * if that is NULL, use the current namespace context. Note that we      * always treat two or more adjacent ":"s as a namespace separator.      */
if|if
condition|(
name|flags
operator|&
operator|(
name|TCL_NAMESPACE_ONLY
operator||
name|FIND_ONLY_NS
operator|)
condition|)
block|{
name|nsPtr
operator|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetCurrentNamespace
argument_list|(
name|interp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|TCL_GLOBAL_ONLY
condition|)
block|{
name|nsPtr
operator|=
name|globalNsPtr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nsPtr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|iPtr
operator|->
name|varFramePtr
operator|!=
name|NULL
condition|)
block|{
name|nsPtr
operator|=
name|iPtr
operator|->
name|varFramePtr
operator|->
name|nsPtr
expr_stmt|;
block|}
else|else
block|{
name|nsPtr
operator|=
name|iPtr
operator|->
name|globalNsPtr
expr_stmt|;
block|}
block|}
name|start
operator|=
name|qualName
expr_stmt|;
comment|/* pts to start of qualifying namespace */
if|if
condition|(
operator|(
operator|*
name|qualName
operator|==
literal|':'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|qualName
operator|+
literal|1
operator|)
operator|==
literal|':'
operator|)
condition|)
block|{
name|start
operator|=
name|qualName
operator|+
literal|2
expr_stmt|;
comment|/* skip over the initial :: */
while|while
condition|(
operator|*
name|start
operator|==
literal|':'
condition|)
block|{
name|start
operator|++
expr_stmt|;
comment|/* skip over a subsequent : */
block|}
name|nsPtr
operator|=
name|globalNsPtr
expr_stmt|;
if|if
condition|(
operator|*
name|start
operator|==
literal|'\0'
condition|)
block|{
comment|/* qualName is just two or more ":"s */
operator|*
name|nsPtrPtr
operator|=
name|globalNsPtr
expr_stmt|;
operator|*
name|altNsPtrPtr
operator|=
name|NULL
expr_stmt|;
operator|*
name|actualCxtPtrPtr
operator|=
name|globalNsPtr
expr_stmt|;
operator|*
name|simpleNamePtr
operator|=
name|start
expr_stmt|;
comment|/* points to empty string */
return|return
name|TCL_OK
return|;
block|}
block|}
operator|*
name|actualCxtPtrPtr
operator|=
name|nsPtr
expr_stmt|;
comment|/*      * Start an alternate search path starting with the global namespace.      * However, if the starting context is the global namespace, or if the      * flag is set to search only the namespace *cxtNsPtr, ignore the      * alternate search path.      */
name|altNsPtr
operator|=
name|globalNsPtr
expr_stmt|;
if|if
condition|(
operator|(
name|nsPtr
operator|==
name|globalNsPtr
operator|)
operator|||
operator|(
name|flags
operator|&
operator|(
name|TCL_NAMESPACE_ONLY
operator||
name|FIND_ONLY_NS
operator|)
operator|)
condition|)
block|{
name|altNsPtr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*      * Loop to resolve each namespace qualifier in qualName.      */
name|Tcl_DStringInit
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|end
operator|=
name|start
expr_stmt|;
while|while
condition|(
operator|*
name|start
operator|!=
literal|'\0'
condition|)
block|{
comment|/*          * Find the next namespace qualifier (i.e., a name ending in "::") 	 * or the end of the qualified name  (i.e., a name ending in "\0"). 	 * Set len to the number of characters, starting from start, 	 * in the name; set end to point after the "::"s or at the "\0".          */
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|end
operator|=
name|start
init|;
operator|*
name|end
operator|!=
literal|'\0'
condition|;
name|end
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|end
operator|==
literal|':'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|end
operator|+
literal|1
operator|)
operator|==
literal|':'
operator|)
condition|)
block|{
name|end
operator|+=
literal|2
expr_stmt|;
comment|/* skip over the initial :: */
while|while
condition|(
operator|*
name|end
operator|==
literal|':'
condition|)
block|{
name|end
operator|++
expr_stmt|;
comment|/* skip over the subsequent : */
block|}
break|break;
comment|/* exit for loop; end is after ::'s */
block|}
name|len
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|end
operator|==
literal|'\0'
operator|)
operator|&&
operator|!
operator|(
operator|(
name|end
operator|-
name|start
operator|>=
literal|2
operator|)
operator|&&
operator|(
operator|*
operator|(
name|end
operator|-
literal|1
operator|)
operator|==
literal|':'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|end
operator|-
literal|2
operator|)
operator|==
literal|':'
operator|)
operator|)
condition|)
block|{
comment|/* 	     * qualName ended with a simple name at start. If FIND_ONLY_NS 	     * was specified, look this up as a namespace. Otherwise, 	     * start is the name of a cmd or var and we are done. 	     */
if|if
condition|(
name|flags
operator|&
name|FIND_ONLY_NS
condition|)
block|{
name|nsName
operator|=
name|start
expr_stmt|;
block|}
else|else
block|{
operator|*
name|nsPtrPtr
operator|=
name|nsPtr
expr_stmt|;
operator|*
name|altNsPtrPtr
operator|=
name|altNsPtr
expr_stmt|;
operator|*
name|simpleNamePtr
operator|=
name|start
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
block|}
else|else
block|{
comment|/* 	     * start points to the beginning of a namespace qualifier ending 	     * in "::". end points to the start of a name in that namespace 	     * that might be empty. Copy the namespace qualifier to a 	     * buffer so it can be null terminated. We can't modify the 	     * incoming qualName since it may be a string constant. 	     */
name|Tcl_DStringSetLength
argument_list|(
operator|&
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|buffer
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|nsName
operator|=
name|Tcl_DStringValue
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Look up the namespace qualifier nsName in the current namespace          * context. If it isn't found but CREATE_NS_IF_UNKNOWN is set,          * create that qualifying namespace. This is needed for procedures          * like Tcl_CreateCommand that cannot fail. 	 */
if|if
condition|(
name|nsPtr
operator|!=
name|NULL
condition|)
block|{
name|entryPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|nsPtr
operator|->
name|childTable
argument_list|,
name|nsName
argument_list|)
expr_stmt|;
if|if
condition|(
name|entryPtr
operator|!=
name|NULL
condition|)
block|{
name|nsPtr
operator|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|entryPtr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|CREATE_NS_IF_UNKNOWN
condition|)
block|{
name|Tcl_CallFrame
name|frame
decl_stmt|;
name|result
operator|=
name|Tcl_PushCallFrame
argument_list|(
name|interp
argument_list|,
operator|&
name|frame
argument_list|,
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|nsPtr
argument_list|,
comment|/*isProcCallFrame*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
name|nsPtr
operator|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_CreateNamespace
argument_list|(
name|interp
argument_list|,
name|nsName
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|,
operator|(
name|Tcl_NamespaceDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_PopCallFrame
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
else|else
block|{
comment|/* namespace not found and wasn't created */
name|nsPtr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/*          * Look up the namespace qualifier in the alternate search path too.          */
if|if
condition|(
name|altNsPtr
operator|!=
name|NULL
condition|)
block|{
name|entryPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|altNsPtr
operator|->
name|childTable
argument_list|,
name|nsName
argument_list|)
expr_stmt|;
if|if
condition|(
name|entryPtr
operator|!=
name|NULL
condition|)
block|{
name|altNsPtr
operator|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|entryPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|altNsPtr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/*          * If both search paths have failed, return NULL results.          */
if|if
condition|(
operator|(
name|nsPtr
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|altNsPtr
operator|==
name|NULL
operator|)
condition|)
block|{
operator|*
name|nsPtrPtr
operator|=
name|NULL
expr_stmt|;
operator|*
name|altNsPtrPtr
operator|=
name|NULL
expr_stmt|;
operator|*
name|simpleNamePtr
operator|=
name|NULL
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
name|start
operator|=
name|end
expr_stmt|;
block|}
comment|/*      * We ignore trailing "::"s in a namespace name, but in a command or      * variable name, trailing "::"s refer to the cmd or var named {}.      */
if|if
condition|(
operator|(
name|flags
operator|&
name|FIND_ONLY_NS
operator|)
operator|||
operator|(
operator|(
name|end
operator|>
name|start
operator|)
operator|&&
operator|(
operator|*
operator|(
name|end
operator|-
literal|1
operator|)
operator|!=
literal|':'
operator|)
operator|)
condition|)
block|{
operator|*
name|simpleNamePtr
operator|=
name|NULL
expr_stmt|;
comment|/* found namespace name */
block|}
else|else
block|{
operator|*
name|simpleNamePtr
operator|=
name|end
expr_stmt|;
comment|/* found cmd/var: points to empty string */
block|}
comment|/*      * As a special case, if we are looking for a namespace and qualName      * is "" and the current active namespace (nsPtr) is not the global      * namespace, return NULL (no namespace was found). This is because      * namespaces can not have empty names except for the global namespace.      */
if|if
condition|(
operator|(
name|flags
operator|&
name|FIND_ONLY_NS
operator|)
operator|&&
operator|(
operator|*
name|qualName
operator|==
literal|'\0'
operator|)
operator|&&
operator|(
name|nsPtr
operator|!=
name|globalNsPtr
operator|)
condition|)
block|{
name|nsPtr
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|nsPtrPtr
operator|=
name|nsPtr
expr_stmt|;
operator|*
name|altNsPtrPtr
operator|=
name|altNsPtr
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_FindNamespace --  *  *	Searches for a namespace.  *  * Results:  *	Returns a pointer to the namespace if it is found. Otherwise,  *	returns NULL and leaves an error message in the interpreter's  *	result object if "flags" contains TCL_LEAVE_ERR_MSG.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Namespace
modifier|*
name|Tcl_FindNamespace
parameter_list|(
name|interp
parameter_list|,
name|name
parameter_list|,
name|contextNsPtr
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interpreter in which to find the 				  * namespace. */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Namespace name. If it starts with "::", 				  * will be looked up in global namespace. 				  * Else, looked up first in contextNsPtr 				  * (current namespace if contextNsPtr is 				  * NULL), then in global namespace. */
name|Tcl_Namespace
modifier|*
name|contextNsPtr
decl_stmt|;
comment|/* Ignored if TCL_GLOBAL_ONLY flag is set 				  * or if the name starts with "::". 				  * Otherwise, points to namespace in which 				  * to resolve name; if NULL, look up name 				  * in the current namespace. */
specifier|register
name|int
name|flags
decl_stmt|;
comment|/* Flags controlling namespace lookup: an 				  * OR'd combination of TCL_GLOBAL_ONLY and 				  * TCL_LEAVE_ERR_MSG flags. */
block|{
name|Namespace
modifier|*
name|nsPtr
decl_stmt|,
modifier|*
name|dummy1Ptr
decl_stmt|,
modifier|*
name|dummy2Ptr
decl_stmt|;
name|char
modifier|*
name|dummy
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/*      * Find the namespace(s) that contain the specified namespace name.      * Add the FIND_ONLY_NS flag to resolve the name all the way down      * to its last component, a namespace.      */
name|result
operator|=
name|TclGetNamespaceForQualName
argument_list|(
name|interp
argument_list|,
name|name
argument_list|,
operator|(
name|Namespace
operator|*
operator|)
name|contextNsPtr
argument_list|,
comment|/*flags*/
operator|(
name|flags
operator||
name|FIND_ONLY_NS
operator|)
argument_list|,
operator|&
name|nsPtr
argument_list|,
operator|&
name|dummy1Ptr
argument_list|,
operator|&
name|dummy2Ptr
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|nsPtr
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|nsPtr
return|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|TCL_LEAVE_ERR_MSG
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"unknown namespace \""
argument_list|,
name|name
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_FindCommand --  *  *	Searches for a command.  *  * Results:  *	Returns a token for the command if it is found. Otherwise, if it  *	can't be found or there is an error, returns NULL and leaves an  *	error message in the interpreter's result object if "flags"  *	contains TCL_LEAVE_ERR_MSG.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Command
name|Tcl_FindCommand
parameter_list|(
name|interp
parameter_list|,
name|name
parameter_list|,
name|contextNsPtr
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interpreter in which to find the 				  * command and to report errors. */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Command's name. If it starts with "::", 				  * will be looked up in global namespace. 				  * Else, looked up first in contextNsPtr 				  * (current namespace if contextNsPtr is 				  * NULL), then in global namespace. */
name|Tcl_Namespace
modifier|*
name|contextNsPtr
decl_stmt|;
comment|/* Ignored if TCL_GLOBAL_ONLY flag set. 				  * Otherwise, points to namespace in which 				  * to resolve name. If NULL, look up name 				  * in the current namespace. */
name|int
name|flags
decl_stmt|;
comment|/* An OR'd combination of flags: 				  * TCL_GLOBAL_ONLY (look up name only in 				  * global namespace), TCL_NAMESPACE_ONLY 				  * (look up only in contextNsPtr, or the 				  * current namespace if contextNsPtr is 				  * NULL), and TCL_LEAVE_ERR_MSG. If both 				  * TCL_GLOBAL_ONLY and TCL_NAMESPACE_ONLY 				  * are given, TCL_GLOBAL_ONLY is 				  * ignored. */
block|{
name|Namespace
modifier|*
name|nsPtr
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|cxtNsPtr
decl_stmt|;
name|char
modifier|*
name|simpleName
decl_stmt|;
specifier|register
name|Tcl_HashEntry
modifier|*
name|entryPtr
decl_stmt|;
specifier|register
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
specifier|register
name|int
name|search
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/*      * Find the namespace(s) that contain the command.      */
name|result
operator|=
name|TclGetNamespaceForQualName
argument_list|(
name|interp
argument_list|,
name|name
argument_list|,
operator|(
name|Namespace
operator|*
operator|)
name|contextNsPtr
argument_list|,
name|flags
argument_list|,
operator|&
name|nsPtr
index|[
literal|0
index|]
argument_list|,
operator|&
name|nsPtr
index|[
literal|1
index|]
argument_list|,
operator|&
name|cxtNsPtr
argument_list|,
operator|&
name|simpleName
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
operator|(
name|Tcl_Command
operator|)
name|NULL
return|;
block|}
comment|/*      * Look for the command in the command table of its namespace.      * Be sure to check both possible search paths: from the specified      * namespace context and from the global namespace.      */
name|cmdPtr
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|search
operator|=
literal|0
init|;
operator|(
name|search
operator|<
literal|2
operator|)
operator|&&
operator|(
name|cmdPtr
operator|==
name|NULL
operator|)
condition|;
name|search
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|nsPtr
index|[
name|search
index|]
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|simpleName
operator|!=
name|NULL
operator|)
condition|)
block|{
name|entryPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|nsPtr
index|[
name|search
index|]
operator|->
name|cmdTable
argument_list|,
name|simpleName
argument_list|)
expr_stmt|;
if|if
condition|(
name|entryPtr
operator|!=
name|NULL
condition|)
block|{
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|entryPtr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|cmdPtr
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|Tcl_Command
operator|)
name|cmdPtr
return|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|TCL_LEAVE_ERR_MSG
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"unknown command \""
argument_list|,
name|name
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|Tcl_Command
operator|)
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_FindNamespaceVar --  *  *	Searches for a namespace variable, a variable not local to a  *	procedure. The variable can be either a scalar or an array, but  *	may not be an element of an array.  *  * Results:  *	Returns a token for the variable if it is found. Otherwise, if it  *	can't be found or there is an error, returns NULL and leaves an  *	error message in the interpreter's result object if "flags"  *	contains TCL_LEAVE_ERR_MSG.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Var
name|Tcl_FindNamespaceVar
parameter_list|(
name|interp
parameter_list|,
name|name
parameter_list|,
name|contextNsPtr
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interpreter in which to find the 				  * variable. */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Variable's name. If it starts with "::", 				  * will be looked up in global namespace. 				  * Else, looked up first in contextNsPtr 				  * (current namespace if contextNsPtr is 				  * NULL), then in global namespace. */
name|Tcl_Namespace
modifier|*
name|contextNsPtr
decl_stmt|;
comment|/* Ignored if TCL_GLOBAL_ONLY flag set. 				  * Otherwise, points to namespace in which 				  * to resolve name. If NULL, look up name 				  * in the current namespace. */
name|int
name|flags
decl_stmt|;
comment|/* An OR'd combination of flags: 				  * TCL_GLOBAL_ONLY (look up name only in 				  * global namespace), TCL_NAMESPACE_ONLY 				  * (look up only in contextNsPtr, or the 				  * current namespace if contextNsPtr is 				  * NULL), and TCL_LEAVE_ERR_MSG. If both 				  * TCL_GLOBAL_ONLY and TCL_NAMESPACE_ONLY 				  * are given, TCL_GLOBAL_ONLY is 				  * ignored. */
block|{
name|Namespace
modifier|*
name|nsPtr
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|cxtNsPtr
decl_stmt|;
name|char
modifier|*
name|simpleName
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|entryPtr
decl_stmt|;
name|Var
modifier|*
name|varPtr
decl_stmt|;
specifier|register
name|int
name|search
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/*      * Find the namespace(s) that contain the variable.      */
name|result
operator|=
name|TclGetNamespaceForQualName
argument_list|(
name|interp
argument_list|,
name|name
argument_list|,
operator|(
name|Namespace
operator|*
operator|)
name|contextNsPtr
argument_list|,
name|flags
argument_list|,
operator|&
name|nsPtr
index|[
literal|0
index|]
argument_list|,
operator|&
name|nsPtr
index|[
literal|1
index|]
argument_list|,
operator|&
name|cxtNsPtr
argument_list|,
operator|&
name|simpleName
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
operator|(
name|Tcl_Var
operator|)
name|NULL
return|;
block|}
comment|/*      * Look for the variable in the variable table of its namespace.      * Be sure to check both possible search paths: from the specified      * namespace context and from the global namespace.      */
name|varPtr
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|search
operator|=
literal|0
init|;
operator|(
name|search
operator|<
literal|2
operator|)
operator|&&
operator|(
name|varPtr
operator|==
name|NULL
operator|)
condition|;
name|search
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|nsPtr
index|[
name|search
index|]
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|simpleName
operator|!=
name|NULL
operator|)
condition|)
block|{
name|entryPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|nsPtr
index|[
name|search
index|]
operator|->
name|varTable
argument_list|,
name|simpleName
argument_list|)
expr_stmt|;
if|if
condition|(
name|entryPtr
operator|!=
name|NULL
condition|)
block|{
name|varPtr
operator|=
operator|(
name|Var
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|entryPtr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|varPtr
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|Tcl_Var
operator|)
name|varPtr
return|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|TCL_LEAVE_ERR_MSG
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"unknown variable \""
argument_list|,
name|name
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|Tcl_Var
operator|)
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclResetShadowedCmdRefs --  *  *	Called when a command is added to a namespace to check for existing  *	command references that the new command may invalidate. Consider the  *	following cases that could happen when you add a command "foo" to a  *	namespace "b":  *	   1. It could shadow a command named "foo" at the global scope.  *	      If it does, all command references in the namespace "b" are  *	      suspect.  *	   2. Suppose the namespace "b" resides in a namespace "a".  *	      Then to "a" the new command "b::foo" could shadow another  *	      command "b::foo" in the global namespace. If so, then all  *	      command references in "a" are suspect.  *	The same checks are applied to all parent namespaces, until we  *	reach the global :: namespace.  *  * Results:  *	None.  *  * Side effects:  *	If the new command shadows an existing command, the cmdRefEpoch  *	counter is incremented in each namespace that sees the shadow.  *	This invalidates all command references that were previously cached  *	in that namespace. The next time the commands are used, they are  *	resolved from scratch.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclResetShadowedCmdRefs
parameter_list|(
name|interp
parameter_list|,
name|newCmdPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter containing the new command. */
name|Command
modifier|*
name|newCmdPtr
decl_stmt|;
comment|/* Points to the new command. */
block|{
name|char
modifier|*
name|cmdName
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
specifier|register
name|Namespace
modifier|*
name|nsPtr
decl_stmt|;
name|Namespace
modifier|*
name|trailNsPtr
decl_stmt|,
modifier|*
name|shadowNsPtr
decl_stmt|;
name|Namespace
modifier|*
name|globalNsPtr
init|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetGlobalNamespace
argument_list|(
name|interp
argument_list|)
decl_stmt|;
name|int
name|found
decl_stmt|,
name|i
decl_stmt|;
comment|/*      * This procedure generates an array used to hold the trail list. This      * starts out with stack-allocated space but uses dynamically-allocated      * storage if needed.      */
define|#
directive|define
name|NUM_TRAIL_ELEMS
value|5
name|Namespace
argument_list|*
operator|(
name|trailStorage
index|[
name|NUM_TRAIL_ELEMS
index|]
operator|)
argument_list|;
name|Namespace
operator|*
operator|*
name|trailPtr
operator|=
name|trailStorage
argument_list|;
name|int
name|trailFront
operator|=
operator|-
literal|1
argument_list|;
name|int
name|trailSize
operator|=
name|NUM_TRAIL_ELEMS
argument_list|;
comment|/*      * Start at the namespace containing the new command, and work up      * through the list of parents. Stop just before the global namespace,      * since the global namespace can't "shadow" its own entries.      *      * The namespace "trail" list we build consists of the names of each      * namespace that encloses the new command, in order from outermost to      * innermost: for example, "a" then "b". Each iteration of this loop      * eventually extends the trail upwards by one namespace, nsPtr. We use      * this trail list to see if nsPtr (e.g. "a" in 2. above) could have      * now-invalid cached command references. This will happen if nsPtr      * (e.g. "a") contains a sequence of child namespaces (e.g. "b")      * such that there is a identically-named sequence of child namespaces      * starting from :: (e.g. "::b") whose tail namespace contains a command      * also named cmdName.      */
name|cmdName
operator|=
name|Tcl_GetHashKey
argument_list|(
name|newCmdPtr
operator|->
name|hPtr
operator|->
name|tablePtr
argument_list|,
name|newCmdPtr
operator|->
name|hPtr
argument_list|)
argument_list|;     for
operator|(
name|nsPtr
operator|=
name|newCmdPtr
operator|->
name|nsPtr
expr|;
operator|(
name|nsPtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|nsPtr
operator|!=
name|globalNsPtr
operator|)
expr|;
name|nsPtr
operator|=
name|nsPtr
operator|->
name|parentPtr
operator|)
block|{
comment|/* 	 * Find the maximal sequence of child namespaces contained in nsPtr 	 * such that there is a identically-named sequence of child 	 * namespaces starting from ::. shadowNsPtr will be the tail of this 	 * sequence, or the deepest namespace under :: that might contain a 	 * command now shadowed by cmdName. We check below if shadowNsPtr 	 * actually contains a command cmdName. 	 */
name|found
operator|=
literal|1
block|;
name|shadowNsPtr
operator|=
name|globalNsPtr
block|;
for|for
control|(
name|i
operator|=
name|trailFront
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|trailNsPtr
operator|=
name|trailPtr
index|[
name|i
index|]
expr_stmt|;
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|shadowNsPtr
operator|->
name|childTable
argument_list|,
name|trailNsPtr
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|!=
name|NULL
condition|)
block|{
name|shadowNsPtr
operator|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|found
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* 	 * If shadowNsPtr contains a command named cmdName, we invalidate          * all of the command refs cached in nsPtr. As a boundary case, 	 * shadowNsPtr is initially :: and we check for case 1. above. 	 */
end_comment

begin_if
if|if
condition|(
name|found
condition|)
block|{
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|shadowNsPtr
operator|->
name|cmdTable
argument_list|,
name|cmdName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|!=
name|NULL
condition|)
block|{
name|nsPtr
operator|->
name|cmdRefEpoch
operator|++
expr_stmt|;
block|}
block|}
end_if

begin_comment
comment|/* 	 * Insert nsPtr at the front of the trail list: i.e., at the end 	 * of the trailPtr array. 	 */
end_comment

begin_expr_stmt
name|trailFront
operator|++
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|trailFront
operator|==
name|trailSize
condition|)
block|{
name|size_t
name|currBytes
init|=
name|trailSize
operator|*
sizeof|sizeof
argument_list|(
name|Namespace
operator|*
argument_list|)
decl_stmt|;
name|int
name|newSize
init|=
literal|2
operator|*
name|trailSize
decl_stmt|;
name|size_t
name|newBytes
init|=
name|newSize
operator|*
sizeof|sizeof
argument_list|(
name|Namespace
operator|*
argument_list|)
decl_stmt|;
name|Namespace
modifier|*
modifier|*
name|newPtr
init|=
operator|(
name|Namespace
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|newBytes
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|newPtr
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|trailPtr
argument_list|,
name|currBytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|trailPtr
operator|!=
name|trailStorage
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|trailPtr
argument_list|)
expr_stmt|;
block|}
name|trailPtr
operator|=
name|newPtr
expr_stmt|;
name|trailSize
operator|=
name|newSize
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|trailPtr
index|[
name|trailFront
index|]
operator|=
name|nsPtr
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*      * Free any allocated storage.      */
end_comment

begin_expr_stmt
unit|if
operator|(
name|trailPtr
operator|!=
name|trailStorage
operator|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|trailPtr
argument_list|)
block|;     }
end_expr_stmt

begin_undef
undef|#
directive|undef
name|NUM_TRAIL_ELEMS
end_undef

begin_escape
unit|}
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * GetNamespaceFromObj --  *  *	Returns the namespace specified by the name in a Tcl_Obj.  *  * Results:  *	Returns TCL_OK if the namespace was resolved successfully, and  *	stores a pointer to the namespace in the location specified by  *	nsPtrPtr. If the namespace can't be found, the procedure stores  *	NULL in *nsPtrPtr and returns TCL_OK. If anything else goes wrong,  *	this procedure returns TCL_ERROR.  *  * Side effects:  *	May update the internal representation for the object, caching the  *	namespace reference. The next time this procedure is called, the  *	namespace value can be found quickly.  *  *	If anything goes wrong, an error message is left in the  *	interpreter's result object.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
unit|static
name|int
name|GetNamespaceFromObj
parameter_list|(
name|interp
parameter_list|,
name|objPtr
parameter_list|,
name|nsPtrPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The current interpreter. */
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* The object to be resolved as the name 				 * of a namespace. */
name|Tcl_Namespace
modifier|*
modifier|*
name|nsPtrPtr
decl_stmt|;
comment|/* Result namespace pointer goes here. */
block|{
specifier|register
name|ResolvedNsName
modifier|*
name|resNamePtr
decl_stmt|;
specifier|register
name|Namespace
modifier|*
name|nsPtr
decl_stmt|;
name|Namespace
modifier|*
name|currNsPtr
init|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetCurrentNamespace
argument_list|(
name|interp
argument_list|)
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/*      * Get the internal representation, converting to a namespace type if      * needed. The internal representation is a ResolvedNsName that points      * to the actual namespace.      */
if|if
condition|(
name|objPtr
operator|->
name|typePtr
operator|!=
operator|&
name|tclNsNameType
condition|)
block|{
name|result
operator|=
name|tclNsNameType
operator|.
name|setFromAnyProc
argument_list|(
name|interp
argument_list|,
name|objPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
name|resNamePtr
operator|=
operator|(
name|ResolvedNsName
operator|*
operator|)
name|objPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
expr_stmt|;
comment|/*      * Check the context namespace of the resolved symbol to make sure that      * it is fresh. If not, then force another conversion to the namespace      * type, to discard the old rep and create a new one. Note that we      * verify that the namespace id of the cached namespace is the same as      * the id when we cached it; this insures that the namespace wasn't      * deleted and a new one created at the same address.      */
name|nsPtr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|resNamePtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|resNamePtr
operator|->
name|refNsPtr
operator|==
name|currNsPtr
operator|)
operator|&&
operator|(
name|resNamePtr
operator|->
name|nsId
operator|==
name|resNamePtr
operator|->
name|nsPtr
operator|->
name|nsId
operator|)
condition|)
block|{
name|nsPtr
operator|=
name|resNamePtr
operator|->
name|nsPtr
expr_stmt|;
if|if
condition|(
name|nsPtr
operator|->
name|flags
operator|&
name|NS_DEAD
condition|)
block|{
name|nsPtr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nsPtr
operator|==
name|NULL
condition|)
block|{
comment|/* try again */
name|result
operator|=
name|tclNsNameType
operator|.
name|setFromAnyProc
argument_list|(
name|interp
argument_list|,
name|objPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|resNamePtr
operator|=
operator|(
name|ResolvedNsName
operator|*
operator|)
name|objPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
expr_stmt|;
if|if
condition|(
name|resNamePtr
operator|!=
name|NULL
condition|)
block|{
name|nsPtr
operator|=
name|resNamePtr
operator|->
name|nsPtr
expr_stmt|;
if|if
condition|(
name|nsPtr
operator|->
name|flags
operator|&
name|NS_DEAD
condition|)
block|{
name|nsPtr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
operator|*
name|nsPtrPtr
operator|=
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|nsPtr
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_NamespaceObjCmd --  *  *	Invoked to implement the "namespace" command that creates, deletes,  *	or manipulates Tcl namespaces. Handles the following syntax:  *  *	    namespace children ?name? ?pattern?  *	    namespace code arg  *	    namespace current  *	    namespace delete ?name name...?  *	    namespace eval name arg ?arg...?  *	    namespace export ?-clear? ?pattern pattern...?  *	    namespace forget ?pattern pattern...?  *	    namespace import ?-force? ?pattern pattern...?  *	    namespace inscope name arg ?arg...?  *	    namespace origin name  *	    namespace parent ?name?  *	    namespace qualifiers string  *	    namespace tail string  *	    namespace which ?-command? ?-variable? name  *  * Results:  *	Returns TCL_OK if the command is successful. Returns TCL_ERROR if  *	anything goes wrong.  *  * Side effects:  *	Based on the subcommand name (e.g., "import"), this procedure  *	dispatches to a corresponding procedure NamespaceXXXCmd defined  *	statically in this file. This procedure's side effects depend on  *	whatever that subcommand procedure does. If there is an error, this  *	procedure returns an error message in the interpreter's result  *	object. Otherwise it may return a result in the interpreter's result  *	object.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_NamespaceObjCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary value passed to cmd. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
specifier|register
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
specifier|register
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
specifier|static
name|char
modifier|*
name|subCmds
index|[]
init|=
block|{
literal|"children"
block|,
literal|"code"
block|,
literal|"current"
block|,
literal|"delete"
block|,
literal|"eval"
block|,
literal|"export"
block|,
literal|"forget"
block|,
literal|"import"
block|,
literal|"inscope"
block|,
literal|"origin"
block|,
literal|"parent"
block|,
literal|"qualifiers"
block|,
literal|"tail"
block|,
literal|"which"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
enum|enum
name|NSSubCmdIdx
block|{
name|NSChildrenIdx
block|,
name|NSCodeIdx
block|,
name|NSCurrentIdx
block|,
name|NSDeleteIdx
block|,
name|NSEvalIdx
block|,
name|NSExportIdx
block|,
name|NSForgetIdx
block|,
name|NSImportIdx
block|,
name|NSInscopeIdx
block|,
name|NSOriginIdx
block|,
name|NSParentIdx
block|,
name|NSQualifiersIdx
block|,
name|NSTailIdx
block|,
name|NSWhichIdx
block|}
name|index
enum|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"subcommand ?arg ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Return an index reflecting the particular subcommand.      */
name|result
operator|=
name|Tcl_GetIndexFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|interp
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|,
name|subCmds
argument_list|,
literal|"option"
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|NSChildrenIdx
case|:
name|result
operator|=
name|NamespaceChildrenCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|NSCodeIdx
case|:
name|result
operator|=
name|NamespaceCodeCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|NSCurrentIdx
case|:
name|result
operator|=
name|NamespaceCurrentCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|NSDeleteIdx
case|:
name|result
operator|=
name|NamespaceDeleteCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|NSEvalIdx
case|:
name|result
operator|=
name|NamespaceEvalCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|NSExportIdx
case|:
name|result
operator|=
name|NamespaceExportCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|NSForgetIdx
case|:
name|result
operator|=
name|NamespaceForgetCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|NSImportIdx
case|:
name|result
operator|=
name|NamespaceImportCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|NSInscopeIdx
case|:
name|result
operator|=
name|NamespaceInscopeCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|NSOriginIdx
case|:
name|result
operator|=
name|NamespaceOriginCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|NSParentIdx
case|:
name|result
operator|=
name|NamespaceParentCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|NSQualifiersIdx
case|:
name|result
operator|=
name|NamespaceQualifiersCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|NSTailIdx
case|:
name|result
operator|=
name|NamespaceTailCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
case|case
name|NSWhichIdx
case|:
name|result
operator|=
name|NamespaceWhichCmd
argument_list|(
name|clientData
argument_list|,
name|interp
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * NamespaceChildrenCmd --  *  *	Invoked to implement the "namespace children" command that returns a  *	list containing the fully-qualified names of the child namespaces of  *	a given namespace. Handles the following syntax:  *  *	    namespace children ?name? ?pattern?  *  * Results:  *	Returns TCL_OK if successful, and TCL_ERROR if anything goes wrong.  *  * Side effects:  *	Returns a result in the interpreter's result object. If anything  *	goes wrong, the result is an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|NamespaceChildrenCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Namespace
modifier|*
name|namespacePtr
decl_stmt|;
name|Namespace
modifier|*
name|nsPtr
decl_stmt|,
modifier|*
name|childNsPtr
decl_stmt|;
name|Namespace
modifier|*
name|globalNsPtr
init|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetGlobalNamespace
argument_list|(
name|interp
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pattern
init|=
name|NULL
decl_stmt|;
name|Tcl_DString
name|buffer
decl_stmt|;
specifier|register
name|Tcl_HashEntry
modifier|*
name|entryPtr
decl_stmt|;
name|Tcl_HashSearch
name|search
decl_stmt|;
name|Tcl_Obj
modifier|*
name|listPtr
decl_stmt|,
modifier|*
name|elemPtr
decl_stmt|;
comment|/*      * Get a pointer to the specified namespace, or the current namespace.      */
if|if
condition|(
name|objc
operator|==
literal|2
condition|)
block|{
name|nsPtr
operator|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetCurrentNamespace
argument_list|(
name|interp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|objc
operator|==
literal|3
operator|)
operator|||
operator|(
name|objc
operator|==
literal|4
operator|)
condition|)
block|{
if|if
condition|(
name|GetNamespaceFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|namespacePtr
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|namespacePtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"unknown namespace \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
literal|"\" in namespace children command"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|nsPtr
operator|=
operator|(
name|Namespace
operator|*
operator|)
name|namespacePtr
expr_stmt|;
block|}
else|else
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?name? ?pattern?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Get the glob-style pattern, if any, used to narrow the search.      */
name|Tcl_DStringInit
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|objc
operator|==
literal|4
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|name
operator|==
literal|':'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|name
operator|+
literal|1
operator|)
operator|==
literal|':'
operator|)
condition|)
block|{
name|pattern
operator|=
name|name
expr_stmt|;
block|}
else|else
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|buffer
argument_list|,
name|nsPtr
operator|->
name|fullName
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsPtr
operator|!=
name|globalNsPtr
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|buffer
argument_list|,
literal|"::"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|Tcl_DStringAppend
argument_list|(
operator|&
name|buffer
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|Tcl_DStringValue
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Create a list containing the full names of all child namespaces      * whose names match the specified pattern, if any.      */
name|listPtr
operator|=
name|Tcl_NewListObj
argument_list|(
literal|0
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|entryPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
name|nsPtr
operator|->
name|childTable
argument_list|,
operator|&
name|search
argument_list|)
expr_stmt|;
while|while
condition|(
name|entryPtr
operator|!=
name|NULL
condition|)
block|{
name|childNsPtr
operator|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|entryPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pattern
operator|==
name|NULL
operator|)
operator|||
name|Tcl_StringMatch
argument_list|(
name|childNsPtr
operator|->
name|fullName
argument_list|,
name|pattern
argument_list|)
condition|)
block|{
name|elemPtr
operator|=
name|Tcl_NewStringObj
argument_list|(
name|childNsPtr
operator|->
name|fullName
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
name|elemPtr
argument_list|)
expr_stmt|;
block|}
name|entryPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|search
argument_list|)
expr_stmt|;
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * NamespaceCodeCmd --  *  *	Invoked to implement the "namespace code" command to capture the  *	namespace context of a command. Handles the following syntax:  *  *	    namespace code arg  *  *	Here "arg" can be a list. "namespace code arg" produces a result  *	equivalent to that produced by the command  *  *	    list namespace inscope [namespace current] $arg  *  *	However, if "arg" is itself a scoped value starting with  *	"namespace inscope", then the result is just "arg".  *  * Results:  *	Returns TCL_OK if successful, and TCL_ERROR if anything goes wrong.  *  * Side effects:  *	If anything goes wrong, this procedure returns an error  *	message as the result in the interpreter's result object.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|NamespaceCodeCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Namespace
modifier|*
name|currNsPtr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|listPtr
decl_stmt|,
modifier|*
name|objPtr
decl_stmt|;
specifier|register
name|char
modifier|*
name|arg
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|length
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"arg"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * If "arg" is already a scoped value, then return it directly.      */
name|arg
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|arg
operator|==
literal|'n'
operator|)
operator|&&
operator|(
name|length
operator|>
literal|17
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"namespace"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
for|for
control|(
name|p
operator|=
operator|(
name|arg
operator|+
literal|9
operator|)
init|;
operator|(
operator|*
name|p
operator|==
literal|' '
operator|)
condition|;
name|p
operator|++
control|)
block|{
comment|/* empty body: skip over spaces */
block|}
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'i'
operator|)
operator|&&
operator|(
operator|(
name|p
operator|+
literal|7
operator|)
operator|<=
operator|(
name|arg
operator|+
name|length
operator|)
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"inscope"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
block|}
comment|/*      * Otherwise, construct a scoped command by building a list with      * "namespace inscope", the full name of the current namespace, and       * the argument "arg". By constructing a list, we ensure that scoped      * commands are interpreted properly when they are executed later,      * by the "namespace inscope" command.      */
name|listPtr
operator|=
name|Tcl_NewListObj
argument_list|(
literal|0
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
name|Tcl_NewStringObj
argument_list|(
literal|"namespace"
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
name|Tcl_NewStringObj
argument_list|(
literal|"inscope"
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|currNsPtr
operator|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetCurrentNamespace
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
name|currNsPtr
operator|==
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetGlobalNamespace
argument_list|(
name|interp
argument_list|)
condition|)
block|{
name|objPtr
operator|=
name|Tcl_NewStringObj
argument_list|(
literal|"::"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|objPtr
operator|=
name|Tcl_NewStringObj
argument_list|(
name|currNsPtr
operator|->
name|fullName
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
name|objPtr
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * NamespaceCurrentCmd --  *  *	Invoked to implement the "namespace current" command which returns  *	the fully-qualified name of the current namespace. Handles the  *	following syntax:  *  *	    namespace current  *  * Results:  *	Returns TCL_OK if successful, and TCL_ERROR if anything goes wrong.  *  * Side effects:  *	Returns a result in the interpreter's result object. If anything  *	goes wrong, the result is an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|NamespaceCurrentCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
specifier|register
name|Namespace
modifier|*
name|currNsPtr
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * The "real" name of the global namespace ("::") is the null string,      * but we return "::" for it as a convenience to programmers. Note that      * "" and "::" are treated as synonyms by the namespace code so that it      * is still easy to do things like:      *      *    namespace [namespace current]::bar { ... }      */
name|currNsPtr
operator|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetCurrentNamespace
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
name|currNsPtr
operator|==
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetGlobalNamespace
argument_list|(
name|interp
argument_list|)
condition|)
block|{
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"::"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|currNsPtr
operator|->
name|fullName
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * NamespaceDeleteCmd --  *  *	Invoked to implement the "namespace delete" command to delete  *	namespace(s). Handles the following syntax:  *  *	    namespace delete ?name name...?  *  *	Each name identifies a namespace. It may include a sequence of  *	namespace qualifiers separated by "::"s. If a namespace is found, it  *	is deleted: all variables and procedures contained in that namespace  *	are deleted. If that namespace is being used on the call stack, it  *	is kept alive (but logically deleted) until it is removed from the  *	call stack: that is, it can no longer be referenced by name but any  *	currently executing procedure that refers to it is allowed to do so  *	until the procedure returns. If the namespace can't be found, this  *	procedure returns an error. If no namespaces are specified, this  *	command does nothing.  *  * Results:  *	Returns TCL_OK if successful, and  TCL_ERROR if anything goes wrong.  *  * Side effects:  *	Deletes the specified namespaces. If anything goes wrong, this  *	procedure returns an error message in the interpreter's  *	result object.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|NamespaceDeleteCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Namespace
modifier|*
name|namespacePtr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?name name...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Destroying one namespace may cause another to be destroyed. Break      * this into two passes: first check to make sure that all namespaces on      * the command line are valid, and report any errors.      */
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|name
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|namespacePtr
operator|=
name|Tcl_FindNamespace
argument_list|(
name|interp
argument_list|,
name|name
argument_list|,
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|NULL
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|namespacePtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"unknown namespace \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
literal|"\" in namespace delete command"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
comment|/*      * Okay, now delete each namespace.      */
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|name
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|namespacePtr
operator|=
name|Tcl_FindNamespace
argument_list|(
name|interp
argument_list|,
name|name
argument_list|,
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_LEAVE_ERR_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|namespacePtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_DeleteNamespace
argument_list|(
name|namespacePtr
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * NamespaceEvalCmd --  *  *	Invoked to implement the "namespace eval" command. Executes  *	commands in a namespace. If the namespace does not already exist,  *	it is created. Handles the following syntax:  *  *	    namespace eval name arg ?arg...?  *  *	If more than one arg argument is specified, the command that is  *	executed is the result of concatenating the arguments together with  *	a space between each argument.  *  * Results:  *	Returns TCL_OK if the namespace is found and the commands are  *	executed successfully. Returns TCL_ERROR if anything goes wrong.  *  * Side effects:  *	Returns the result of the command in the interpreter's result  *	object. If anything goes wrong, this procedure returns an error  *	message as the result.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|NamespaceEvalCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Namespace
modifier|*
name|namespacePtr
decl_stmt|;
name|Tcl_CallFrame
name|frame
decl_stmt|;
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|length
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"name arg ?arg...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Try to resolve the namespace reference, caching the result in the      * namespace object along the way.      */
name|result
operator|=
name|GetNamespaceFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|namespacePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
comment|/*      * If the namespace wasn't found, try to create it.      */
if|if
condition|(
name|namespacePtr
operator|==
name|NULL
condition|)
block|{
name|name
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|namespacePtr
operator|=
name|Tcl_CreateNamespace
argument_list|(
name|interp
argument_list|,
name|name
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|,
operator|(
name|Tcl_NamespaceDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|namespacePtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
comment|/*      * Make the specified namespace the current namespace and evaluate      * the command(s).      */
name|result
operator|=
name|Tcl_PushCallFrame
argument_list|(
name|interp
argument_list|,
operator|&
name|frame
argument_list|,
name|namespacePtr
argument_list|,
comment|/*isProcCallFrame*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|objc
operator|==
literal|4
condition|)
block|{
name|result
operator|=
name|Tcl_EvalObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|objPtr
operator|=
name|Tcl_ConcatObj
argument_list|(
name|objc
operator|-
literal|3
argument_list|,
name|objv
operator|+
literal|3
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_EvalObj
argument_list|(
name|interp
argument_list|,
name|objPtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
comment|/* we're done with the object */
block|}
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|char
name|msg
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n    (in namespace eval \"%.200s\" script line %d)"
argument_list|,
name|namespacePtr
operator|->
name|fullName
argument_list|,
name|interp
operator|->
name|errorLine
argument_list|)
expr_stmt|;
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|msg
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*      * Restore the previous "current" namespace.      */
name|Tcl_PopCallFrame
argument_list|(
name|interp
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * NamespaceExportCmd --  *  *	Invoked to implement the "namespace export" command that specifies  *	which commands are exported from a namespace. The exported commands  *	are those that can be imported into another namespace using  *	"namespace import". Both commands defined in a namespace and  *	commands the namespace has imported can be exported by a  *	namespace. This command has the following syntax:  *  *	    namespace export ?-clear? ?pattern pattern...?  *  *	Each pattern may contain "string match"-style pattern matching  *	special characters, but the pattern may not include any namespace  *	qualifiers: that is, the pattern must specify commands in the  *	current (exporting) namespace. The specified patterns are appended  *	onto the namespace's list of export patterns.  *  *	To reset the namespace's export pattern list, specify the "-clear"  *	flag.  *  *	If there are no export patterns and the "-clear" flag isn't given,  *	this command returns the namespace's current export list.  *  * Results:  *	Returns TCL_OK if successful, and TCL_ERROR if anything goes wrong.  *  * Side effects:  *	Returns a result in the interpreter's result object. If anything  *	goes wrong, the result is an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|NamespaceExportCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Namespace
modifier|*
name|currNsPtr
init|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetCurrentNamespace
argument_list|(
name|interp
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pattern
decl_stmt|,
modifier|*
name|string
decl_stmt|;
name|int
name|resetListFirst
init|=
literal|0
decl_stmt|;
name|int
name|firstArg
decl_stmt|,
name|patternCt
decl_stmt|,
name|i
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?-clear? ?pattern pattern...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Process the optional "-clear" argument.      */
name|firstArg
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|firstArg
operator|<
name|objc
condition|)
block|{
name|string
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|firstArg
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"-clear"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|resetListFirst
operator|=
literal|1
expr_stmt|;
name|firstArg
operator|++
expr_stmt|;
block|}
block|}
comment|/*      * If no pattern arguments are given, and "-clear" isn't specified,      * return the namespace's current export pattern list.      */
name|patternCt
operator|=
operator|(
name|objc
operator|-
name|firstArg
operator|)
expr_stmt|;
if|if
condition|(
name|patternCt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|firstArg
operator|>
literal|2
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
else|else
block|{
comment|/* create list with export patterns */
name|Tcl_Obj
modifier|*
name|listPtr
init|=
name|Tcl_NewListObj
argument_list|(
literal|0
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|NULL
argument_list|)
decl_stmt|;
name|result
operator|=
name|Tcl_AppendExportList
argument_list|(
name|interp
argument_list|,
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|currNsPtr
argument_list|,
name|listPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
block|}
comment|/*      * Add each pattern to the namespace's export pattern list.      */
for|for
control|(
name|i
operator|=
name|firstArg
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|pattern
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_Export
argument_list|(
name|interp
argument_list|,
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|currNsPtr
argument_list|,
name|pattern
argument_list|,
operator|(
operator|(
name|i
operator|==
name|firstArg
operator|)
condition|?
name|resetListFirst
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * NamespaceForgetCmd --  *  *	Invoked to implement the "namespace forget" command to remove  *	imported commands from a namespace. Handles the following syntax:  *  *	    namespace forget ?pattern pattern...?  *  *	Each pattern is a name like "foo::*" or "a::b::x*". That is, the  *	pattern may include the special pattern matching characters  *	recognized by the "string match" command, but only in the command  *	name at the end of the qualified name; the special pattern  *	characters may not appear in a namespace name. All of the commands  *	that match that pattern are checked to see if they have an imported  *	command in the current namespace that refers to the matched  *	command. If there is an alias, it is removed.  *	  * Results:  *	Returns TCL_OK if successful, and TCL_ERROR if anything goes wrong.  *  * Side effects:  *	Imported commands are removed from the current namespace. If  *	anything goes wrong, this procedure returns an error message in the  *	interpreter's result object.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|NamespaceForgetCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|char
modifier|*
name|pattern
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?pattern pattern...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|pattern
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_ForgetImport
argument_list|(
name|interp
argument_list|,
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|NULL
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * NamespaceImportCmd --  *  *	Invoked to implement the "namespace import" command that imports  *	commands into a namespace. Handles the following syntax:  *  *	    namespace import ?-force? ?pattern pattern...?  *  *	Each pattern is a namespace-qualified name like "foo::*",  *	"a::b::x*", or "bar::p". That is, the pattern may include the  *	special pattern matching characters recognized by the "string match"  *	command, but only in the command name at the end of the qualified  *	name; the special pattern characters may not appear in a namespace  *	name. All of the commands that match the pattern and which are  *	exported from their namespace are made accessible from the current  *	namespace context. This is done by creating a new "imported command"  *	in the current namespace that points to the real command in its  *	original namespace; when the imported command is called, it invokes  *	the real command.  *  *	If an imported command conflicts with an existing command, it is  *	treated as an error. But if the "-force" option is included, then  *	existing commands are overwritten by the imported commands.  *	  * Results:  *	Returns TCL_OK if successful, and TCL_ERROR if anything goes wrong.  *  * Side effects:  *	Adds imported commands to the current namespace. If anything goes  *	wrong, this procedure returns an error message in the interpreter's  *	result object.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|NamespaceImportCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|int
name|allowOverwrite
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|,
modifier|*
name|pattern
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|result
decl_stmt|;
name|int
name|firstArg
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?-force? ?pattern pattern...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Skip over the optional "-force" as the first argument.      */
name|firstArg
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|firstArg
operator|<
name|objc
condition|)
block|{
name|string
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|firstArg
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|string
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"-force"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|allowOverwrite
operator|=
literal|1
expr_stmt|;
name|firstArg
operator|++
expr_stmt|;
block|}
block|}
comment|/*      * Handle the imports for each of the patterns.      */
for|for
control|(
name|i
operator|=
name|firstArg
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|pattern
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_Import
argument_list|(
name|interp
argument_list|,
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|NULL
argument_list|,
name|pattern
argument_list|,
name|allowOverwrite
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * NamespaceInscopeCmd --  *  *	Invoked to implement the "namespace inscope" command that executes a  *	script in the context of a particular namespace. This command is not  *	expected to be used directly by programmers; calls to it are  *	generated implicitly when programs use "namespace code" commands  *	to register callback scripts. Handles the following syntax:  *  *	    namespace inscope name arg ?arg...?  *  *	The "namespace inscope" command is much like the "namespace eval"  *	command except that it has lappend semantics and the namespace must  *	already exist. It treats the first argument as a list, and appends  *	any arguments after the first onto the end as proper list elements.  *	For example,  *  *	    namespace inscope ::foo a b c d  *  *	is equivalent to  *  *	    namespace eval ::foo [concat a [list b c d]]  *  *	This lappend semantics is important because many callback scripts  *	are actually prefixes.  *  * Results:  *	Returns TCL_OK to indicate success, or TCL_ERROR to indicate  *	failure.  *  * Side effects:  *	Returns a result in the Tcl interpreter's result object.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|NamespaceInscopeCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Namespace
modifier|*
name|namespacePtr
decl_stmt|;
name|Tcl_CallFrame
name|frame
decl_stmt|;
name|int
name|i
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"name arg ?arg...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Resolve the namespace reference.      */
name|result
operator|=
name|GetNamespaceFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|namespacePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
if|if
condition|(
name|namespacePtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"unknown namespace \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
literal|"\" in inscope namespace command"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Make the specified namespace the current namespace.      */
name|result
operator|=
name|Tcl_PushCallFrame
argument_list|(
name|interp
argument_list|,
operator|&
name|frame
argument_list|,
name|namespacePtr
argument_list|,
comment|/*isProcCallFrame*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
comment|/*      * Execute the command. If there is just one argument, just treat it as      * a script and evaluate it. Otherwise, create a list from the arguments      * after the first one, then concatenate the first argument and the list      * of extra arguments to form the command to evaluate.      */
if|if
condition|(
name|objc
operator|==
literal|4
condition|)
block|{
name|result
operator|=
name|Tcl_EvalObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_Obj
modifier|*
name|concatObjv
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|Tcl_Obj
modifier|*
name|listPtr
decl_stmt|,
modifier|*
name|cmdObjPtr
decl_stmt|;
name|listPtr
operator|=
name|Tcl_NewListObj
argument_list|(
literal|0
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
name|objv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|listPtr
argument_list|)
expr_stmt|;
comment|/* free unneeded obj */
return|return
name|result
return|;
block|}
block|}
name|concatObjv
index|[
literal|0
index|]
operator|=
name|objv
index|[
literal|3
index|]
expr_stmt|;
name|concatObjv
index|[
literal|1
index|]
operator|=
name|listPtr
expr_stmt|;
name|cmdObjPtr
operator|=
name|Tcl_ConcatObj
argument_list|(
literal|2
argument_list|,
name|concatObjv
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_EvalObj
argument_list|(
name|interp
argument_list|,
name|cmdObjPtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|cmdObjPtr
argument_list|)
expr_stmt|;
comment|/* we're done with the cmd object */
name|Tcl_DecrRefCount
argument_list|(
name|listPtr
argument_list|)
expr_stmt|;
comment|/* we're done with the list object */
block|}
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|char
name|msg
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n    (in namespace inscope \"%.200s\" script line %d)"
argument_list|,
name|namespacePtr
operator|->
name|fullName
argument_list|,
name|interp
operator|->
name|errorLine
argument_list|)
expr_stmt|;
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|msg
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*      * Restore the previous "current" namespace.      */
name|Tcl_PopCallFrame
argument_list|(
name|interp
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * NamespaceOriginCmd --  *  *	Invoked to implement the "namespace origin" command to return the  *	fully-qualified name of the "real" command to which the specified  *	"imported command" refers. Handles the following syntax:  *  *	    namespace origin name  *  * Results:  *	An imported command is created in an namespace when that namespace  *	imports a command from another namespace. If a command is imported  *	into a sequence of namespaces a, b,...,n where each successive  *	namespace just imports the command from the previous namespace, this  *	command returns the fully-qualified name of the original command in  *	the first namespace, a. If "name" does not refer to an alias, its  *	fully-qualified name is returned. The returned name is stored in the  *	interpreter's result object. This procedure returns TCL_OK if  *	successful, and TCL_ERROR if anything goes wrong.  *  * Side effects:  *	If anything goes wrong, this procedure returns an error message in  *	the interpreter's result object.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|NamespaceOriginCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Command
name|command
decl_stmt|,
name|origCommand
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"name"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|command
operator|=
name|Tcl_GetCommandFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|==
operator|(
name|Tcl_Command
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"invalid command name \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|origCommand
operator|=
name|TclGetOriginalCommand
argument_list|(
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|origCommand
operator|==
operator|(
name|Tcl_Command
operator|)
name|NULL
condition|)
block|{
comment|/* 	 * The specified command isn't an imported command. Return the 	 * command's name qualified by the full name of the namespace it 	 * was defined in. 	 */
name|Tcl_GetCommandFullName
argument_list|(
name|interp
argument_list|,
name|command
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_GetCommandFullName
argument_list|(
name|interp
argument_list|,
name|origCommand
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * NamespaceParentCmd --  *  *	Invoked to implement the "namespace parent" command that returns the  *	fully-qualified name of the parent namespace for a specified  *	namespace. Handles the following syntax:  *  *	    namespace parent ?name?  *  * Results:  *	Returns TCL_OK if successful, and TCL_ERROR if anything goes wrong.  *  * Side effects:  *	Returns a result in the interpreter's result object. If anything  *	goes wrong, the result is an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|NamespaceParentCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Namespace
modifier|*
name|nsPtr
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|objc
operator|==
literal|2
condition|)
block|{
name|nsPtr
operator|=
name|Tcl_GetCurrentNamespace
argument_list|(
name|interp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|objc
operator|==
literal|3
condition|)
block|{
name|result
operator|=
name|GetNamespaceFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|nsPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
if|if
condition|(
name|nsPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"unknown namespace \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
literal|"\" in namespace parent command"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
else|else
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?name?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Report the parent of the specified namespace.      */
if|if
condition|(
name|nsPtr
operator|->
name|parentPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_SetStringObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|nsPtr
operator|->
name|parentPtr
operator|->
name|fullName
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * NamespaceQualifiersCmd --  *  *	Invoked to implement the "namespace qualifiers" command that returns  *	any leading namespace qualifiers in a string. These qualifiers are  *	namespace names separated by "::"s. For example, for "::foo::p" this  *	command returns "::foo", and for "::" it returns "". This command  *	is the complement of the "namespace tail" command. Note that this  *	command does not check whether the "namespace" names are, in fact,  *	the names of currently defined namespaces. Handles the following  *	syntax:  *  *	    namespace qualifiers string  *  * Results:  *	Returns TCL_OK if successful, and  TCL_ERROR if anything goes wrong.  *  * Side effects:  *	Returns a result in the interpreter's result object. If anything  *	goes wrong, the result is an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|NamespaceQualifiersCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|length
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"string"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Find the end of the string, then work backward and find      * the start of the last "::" qualifier.      */
name|name
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
comment|/* empty body */
block|}
while|while
condition|(
operator|--
name|p
operator|>=
name|name
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|':'
operator|)
operator|&&
operator|(
name|p
operator|>
name|name
operator|)
operator|&&
operator|(
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|==
literal|':'
operator|)
condition|)
block|{
name|p
operator|-=
literal|2
expr_stmt|;
comment|/* back up over the :: */
while|while
condition|(
operator|(
name|p
operator|>=
name|name
operator|)
operator|&&
operator|(
operator|*
name|p
operator|==
literal|':'
operator|)
condition|)
block|{
name|p
operator|--
expr_stmt|;
comment|/* back up over the preceeding : */
block|}
break|break;
block|}
block|}
if|if
condition|(
name|p
operator|>=
name|name
condition|)
block|{
name|length
operator|=
name|p
operator|-
name|name
operator|+
literal|1
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|name
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * NamespaceTailCmd --  *  *	Invoked to implement the "namespace tail" command that returns the  *	trailing name at the end of a string with "::" namespace  *	qualifiers. These qualifiers are namespace names separated by  *	"::"s. For example, for "::foo::p" this command returns "p", and for  *	"::" it returns "". This command is the complement of the "namespace  *	qualifiers" command. Note that this command does not check whether  *	the "namespace" names are, in fact, the names of currently defined  *	namespaces. Handles the following syntax:  *  *	    namespace tail string  *  * Results:  *	Returns TCL_OK if successful, and TCL_ERROR if anything goes wrong.  *  * Side effects:  *	Returns a result in the interpreter's result object. If anything  *	goes wrong, the result is an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|NamespaceTailCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"string"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Find the end of the string, then work backward and find the      * last "::" qualifier.      */
name|name
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
comment|/* empty body */
block|}
while|while
condition|(
operator|--
name|p
operator|>
name|name
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|':'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|==
literal|':'
operator|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
comment|/* just after the last "::" */
break|break;
block|}
block|}
if|if
condition|(
name|p
operator|>=
name|name
condition|)
block|{
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|p
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * NamespaceWhichCmd --  *  *	Invoked to implement the "namespace which" command that returns the  *	fully-qualified name of a command or variable. If the specified  *	command or variable does not exist, it returns "". Handles the  *	following syntax:  *  *	    namespace which ?-command? ?-variable? name  *  * Results:  *	Returns TCL_OK if successful, and TCL_ERROR if anything goes wrong.  *  * Side effects:  *	Returns a result in the interpreter's result object. If anything  *	goes wrong, the result is an error message.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|NamespaceWhichCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
specifier|register
name|char
modifier|*
name|arg
decl_stmt|;
name|Tcl_Command
name|cmd
decl_stmt|;
name|Tcl_Var
name|variable
decl_stmt|;
name|int
name|argIndex
decl_stmt|,
name|lookup
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|3
condition|)
block|{
name|badArgs
label|:
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?-command? ?-variable? name"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Look for a flag controlling the lookup.      */
name|argIndex
operator|=
literal|2
expr_stmt|;
name|lookup
operator|=
literal|0
expr_stmt|;
comment|/* assume command lookup by default */
name|arg
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"-command"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|lookup
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"-variable"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
name|lookup
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|badArgs
goto|;
block|}
name|argIndex
operator|=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|objc
operator|!=
operator|(
name|argIndex
operator|+
literal|1
operator|)
condition|)
block|{
goto|goto
name|badArgs
goto|;
block|}
switch|switch
condition|(
name|lookup
condition|)
block|{
case|case
literal|0
case|:
comment|/* -command */
name|cmd
operator|=
name|Tcl_GetCommandFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
name|argIndex
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
operator|(
name|Tcl_Command
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_OK
return|;
comment|/* cmd not found, just return (no error) */
block|}
name|Tcl_GetCommandFullName
argument_list|(
name|interp
argument_list|,
name|cmd
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* -variable */
name|arg
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|argIndex
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|variable
operator|=
name|Tcl_FindNamespaceVar
argument_list|(
name|interp
argument_list|,
name|arg
argument_list|,
operator|(
name|Tcl_Namespace
operator|*
operator|)
name|NULL
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|variable
operator|!=
operator|(
name|Tcl_Var
operator|)
name|NULL
condition|)
block|{
name|Tcl_GetVariableFullName
argument_list|(
name|interp
argument_list|,
name|variable
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FreeNsNameInternalRep --  *  *	Frees the resources associated with a nsName object's internal  *	representation.  *  * Results:  *	None.  *  * Side effects:  *	Decrements the ref count of any Namespace structure pointed  *	to by the nsName's internal representation. If there are no more  *	references to the namespace, it's structure will be freed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|FreeNsNameInternalRep
parameter_list|(
name|objPtr
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* nsName object with internal                                  * representation to free */
block|{
specifier|register
name|ResolvedNsName
modifier|*
name|resNamePtr
init|=
operator|(
name|ResolvedNsName
operator|*
operator|)
name|objPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
decl_stmt|;
name|Namespace
modifier|*
name|nsPtr
decl_stmt|;
comment|/*      * Decrement the reference count of the namespace. If there are no      * more references, free it up.      */
if|if
condition|(
name|resNamePtr
operator|!=
name|NULL
condition|)
block|{
name|resNamePtr
operator|->
name|refCount
operator|--
expr_stmt|;
if|if
condition|(
name|resNamePtr
operator|->
name|refCount
operator|==
literal|0
condition|)
block|{
comment|/* 	     * Decrement the reference count for the cached namespace.  If 	     * the namespace is dead, and there are no more references to 	     * it, free it. 	     */
name|nsPtr
operator|=
name|resNamePtr
operator|->
name|nsPtr
expr_stmt|;
name|nsPtr
operator|->
name|refCount
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|nsPtr
operator|->
name|refCount
operator|==
literal|0
operator|)
operator|&&
operator|(
name|nsPtr
operator|->
name|flags
operator|&
name|NS_DEAD
operator|)
condition|)
block|{
name|NamespaceFree
argument_list|(
name|nsPtr
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|resNamePtr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DupNsNameInternalRep --  *  *	Initializes the internal representation of a nsName object to a copy  *	of the internal representation of another nsName object.  *  * Results:  *	None.  *  * Side effects:  *	copyPtr's internal rep is set to refer to the same namespace  *	referenced by srcPtr's internal rep. Increments the ref count of  *	the ResolvedNsName structure used to hold the namespace reference.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|DupNsNameInternalRep
parameter_list|(
name|srcPtr
parameter_list|,
name|copyPtr
parameter_list|)
name|Tcl_Obj
modifier|*
name|srcPtr
decl_stmt|;
comment|/* Object with internal rep to copy. */
specifier|register
name|Tcl_Obj
modifier|*
name|copyPtr
decl_stmt|;
comment|/* Object with internal rep to set. */
block|{
specifier|register
name|ResolvedNsName
modifier|*
name|resNamePtr
init|=
operator|(
name|ResolvedNsName
operator|*
operator|)
name|srcPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
decl_stmt|;
name|copyPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
operator|=
operator|(
name|VOID
operator|*
operator|)
name|resNamePtr
expr_stmt|;
if|if
condition|(
name|resNamePtr
operator|!=
name|NULL
condition|)
block|{
name|resNamePtr
operator|->
name|refCount
operator|++
expr_stmt|;
block|}
name|copyPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclNsNameType
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SetNsNameFromAny --  *  *	Attempt to generate a nsName internal representation for a  *	Tcl object.  *  * Results:  *	Returns TCL_OK if the value could be converted to a proper  *	namespace reference. Otherwise, it returns TCL_ERROR, along  *	with an error message in the interpreter's result object.  *  * Side effects:  *	If successful, the object is made a nsName object. Its internal rep  *	is set to point to a ResolvedNsName, which contains a cached pointer  *	to the Namespace. Reference counts are kept on both the  *	ResolvedNsName and the Namespace, so we can keep track of their  *	usage and free them when appropriate.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SetNsNameFromAny
parameter_list|(
name|interp
parameter_list|,
name|objPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Points to the namespace in which to 				 * resolve name. Also used for error 				 * reporting if not NULL. */
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* The object to convert. */
block|{
specifier|register
name|Tcl_ObjType
modifier|*
name|oldTypePtr
init|=
name|objPtr
operator|->
name|typePtr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|dummy
decl_stmt|;
name|Namespace
modifier|*
name|nsPtr
decl_stmt|,
modifier|*
name|dummy1Ptr
decl_stmt|,
modifier|*
name|dummy2Ptr
decl_stmt|;
specifier|register
name|ResolvedNsName
modifier|*
name|resNamePtr
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|result
decl_stmt|;
comment|/*      * Get the string representation. Make it up-to-date if necessary.      */
name|name
operator|=
name|objPtr
operator|->
name|bytes
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|name
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/*      * Look for the namespace "name" in the current namespace. If there is      * an error parsing the (possibly qualified) name, return an error.      * If the namespace isn't found, we convert the object to an nsName      * object with a NULL ResolvedNsName* internal rep.      */
name|flags
operator|=
operator|(
operator|(
name|interp
operator|!=
name|NULL
operator|)
condition|?
name|TCL_LEAVE_ERR_MSG
else|:
literal|0
operator|)
operator||
name|FIND_ONLY_NS
expr_stmt|;
name|result
operator|=
name|TclGetNamespaceForQualName
argument_list|(
name|interp
argument_list|,
name|name
argument_list|,
operator|(
name|Namespace
operator|*
operator|)
name|NULL
argument_list|,
name|flags
argument_list|,
operator|&
name|nsPtr
argument_list|,
operator|&
name|dummy1Ptr
argument_list|,
operator|&
name|dummy2Ptr
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
comment|/*      * If we found a namespace, then create a new ResolvedNsName structure      * that holds a reference to it.      */
if|if
condition|(
name|nsPtr
operator|!=
name|NULL
condition|)
block|{
name|Namespace
modifier|*
name|currNsPtr
init|=
operator|(
name|Namespace
operator|*
operator|)
name|Tcl_GetCurrentNamespace
argument_list|(
name|interp
argument_list|)
decl_stmt|;
name|nsPtr
operator|->
name|refCount
operator|++
expr_stmt|;
name|resNamePtr
operator|=
operator|(
name|ResolvedNsName
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ResolvedNsName
argument_list|)
argument_list|)
expr_stmt|;
name|resNamePtr
operator|->
name|nsPtr
operator|=
name|nsPtr
expr_stmt|;
name|resNamePtr
operator|->
name|nsId
operator|=
name|nsPtr
operator|->
name|nsId
expr_stmt|;
name|resNamePtr
operator|->
name|refNsPtr
operator|=
name|currNsPtr
expr_stmt|;
name|resNamePtr
operator|->
name|refCount
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|resNamePtr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*      * Free the old internalRep before setting the new one.      * We do this as late as possible to allow the conversion code      * (in particular, Tcl_GetStringFromObj) to use that old internalRep.      */
if|if
condition|(
operator|(
name|oldTypePtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|oldTypePtr
operator|->
name|freeIntRepProc
operator|!=
name|NULL
operator|)
condition|)
block|{
name|oldTypePtr
operator|->
name|freeIntRepProc
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
name|objPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
operator|=
operator|(
name|VOID
operator|*
operator|)
name|resNamePtr
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclNsNameType
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * UpdateStringOfNsName --  *  *	Updates the string representation for a nsName object.  *	Note: This procedure does not free an existing old string rep  *	so storage will be lost if this has not already been done.  *  * Results:  *	None.  *  * Side effects:  *	The object's string is set to a copy of the fully qualified  *	namespace name.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|UpdateStringOfNsName
parameter_list|(
name|objPtr
parameter_list|)
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* nsName object with string rep to update. */
block|{
name|ResolvedNsName
modifier|*
name|resNamePtr
init|=
operator|(
name|ResolvedNsName
operator|*
operator|)
name|objPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
decl_stmt|;
specifier|register
name|Namespace
modifier|*
name|nsPtr
decl_stmt|;
name|char
modifier|*
name|name
init|=
literal|""
decl_stmt|;
name|int
name|length
decl_stmt|;
if|if
condition|(
operator|(
name|resNamePtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|resNamePtr
operator|->
name|nsId
operator|==
name|resNamePtr
operator|->
name|nsPtr
operator|->
name|nsId
operator|)
condition|)
block|{
name|nsPtr
operator|=
name|resNamePtr
operator|->
name|nsPtr
expr_stmt|;
if|if
condition|(
name|nsPtr
operator|->
name|flags
operator|&
name|NS_DEAD
condition|)
block|{
name|nsPtr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|nsPtr
operator|!=
name|NULL
condition|)
block|{
name|name
operator|=
name|nsPtr
operator|->
name|fullName
expr_stmt|;
block|}
block|}
comment|/*      * The following sets the string rep to an empty string on the heap      * if the internal rep is NULL.      */
name|length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|objPtr
operator|->
name|bytes
operator|=
name|tclEmptyStringRep
expr_stmt|;
block|}
else|else
block|{
name|objPtr
operator|->
name|bytes
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|length
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|objPtr
operator|->
name|bytes
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|name
argument_list|,
operator|(
name|unsigned
operator|)
name|length
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|bytes
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|objPtr
operator|->
name|length
operator|=
name|length
expr_stmt|;
block|}
end_function

end_unit

