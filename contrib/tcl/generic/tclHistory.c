begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclHistory.c --  *  *	This module implements history as an optional addition to Tcl.  *	It can be called to record commands ("events") before they are  *	executed, and it provides a command that may be used to perform  *	history substitutions.  *  * Copyright (c) 1990-1993 The Regents of the University of California.  * Copyright (c) 1994-1995 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclHistory.c 1.40 96/02/15 11:50:24  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * This history stuff is mostly straightforward, except for one thing  * that makes everything very complicated.  Suppose that the following  * commands get executed:  *	echo foo  *	history redo  * It's important that the history event recorded for the second command  * be "echo foo", not "history redo".  Otherwise, if another "history redo"  * command is typed, it will result in infinite recursions on the  * "history redo" command.  Thus, the actual recorded history must be  *	echo foo  *	echo foo  * To do this, the history command revises recorded history as part of  * its execution.  In the example above, when "history redo" starts  * execution, the current event is "history redo", but the history  * command arranges for the current event to be changed to "echo foo".  *  * There are three additional complications.  The first is that history  * substitution may only be part of a command, as in the following  * command sequence:  *	echo foo bar  *	echo [history word 3]  * In this case, the second event should be recorded as "echo bar".  Only  * part of the recorded event is to be modified.  Fortunately, Tcl_Eval  * helps with this by recording (in the evalFirst and evalLast fields of  * the intepreter) the location of the command being executed, so the  * history module can replace exactly the range of bytes corresponding  * to the history substitution command.  *  * The second complication is that there are two ways to revise history:  * replace a command, and replace the result of a command.  Consider the  * two examples below:  *	format {result is %d} $num	   |	format {result is %d} $num  *	print [history redo]		   |	print [history word 3]  * Recorded history for these two cases should be as follows:  *	format {result is %d} $num	   |	format {result is %d} $num  *	print [format {result is %d} $num] |	print $num  * In the left case, the history command was replaced with another command  * to be executed (the brackets were retained), but in the case on the  * right the result of executing the history command was replaced (i.e.  * brackets were replaced too).  *  * The third complication is that there could potentially be many  * history substitutions within a single command, as in:  *	echo [history word 3] [history word 2]  * There could even be nested history substitutions, as in:  *	history subs abc [history word 2]  * If history revisions were made immediately during each "history" command  * invocations, it would be very difficult to produce the correct cumulative  * effect from several substitutions in the same command.  To get around  * this problem, the actual history revision isn't made during the execution  * of the "history" command.  Information about the changes is just recorded,  * in xxx records, and the actual changes are made during the next call to  * Tcl_RecordHistory (when we know that execution of the previous command  * has finished).  */
end_comment

begin_comment
comment|/*  * Default space allocation for command strings:  */
end_comment

begin_define
define|#
directive|define
name|INITIAL_CMD_SIZE
value|40
end_define

begin_comment
comment|/*  * Forward declarations for procedures defined later in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DoRevs
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Interp
operator|*
name|iPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HistoryEvent
modifier|*
name|GetEvent
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Interp
operator|*
name|iPtr
operator|,
name|char
operator|*
name|string
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|GetWords
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Interp
operator|*
name|iPtr
operator|,
name|char
operator|*
name|command
operator|,
name|char
operator|*
name|words
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|InitHistory
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Interp
operator|*
name|iPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|InsertRev
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Interp
operator|*
name|iPtr
operator|,
name|HistoryRev
operator|*
name|revPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|MakeSpace
name|_ANSI_ARGS_
argument_list|(
operator|(
name|HistoryEvent
operator|*
name|hPtr
operator|,
name|int
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|RevCommand
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Interp
operator|*
name|iPtr
operator|,
name|char
operator|*
name|string
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|RevResult
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Interp
operator|*
name|iPtr
operator|,
name|char
operator|*
name|string
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SubsAndEval
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Interp
operator|*
name|iPtr
operator|,
name|char
operator|*
name|cmd
operator|,
name|char
operator|*
name|old
operator|,
name|char
operator|*
name|new
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InitHistory --  *  *	Initialize history-related state in an interpreter.  *  * Results:  *	None.  *  * Side effects:  *	History info is initialized in iPtr.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|InitHistory
parameter_list|(
name|iPtr
parameter_list|)
specifier|register
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Interpreter to initialize. */
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|numEvents
operator|!=
literal|0
condition|)
block|{
return|return;
block|}
name|iPtr
operator|->
name|numEvents
operator|=
literal|20
expr_stmt|;
name|iPtr
operator|->
name|events
operator|=
operator|(
name|HistoryEvent
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|iPtr
operator|->
name|numEvents
operator|*
sizeof|sizeof
argument_list|(
name|HistoryEvent
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iPtr
operator|->
name|numEvents
condition|;
name|i
operator|++
control|)
block|{
name|iPtr
operator|->
name|events
index|[
name|i
index|]
operator|.
name|command
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
name|INITIAL_CMD_SIZE
argument_list|)
expr_stmt|;
operator|*
name|iPtr
operator|->
name|events
index|[
name|i
index|]
operator|.
name|command
operator|=
literal|0
expr_stmt|;
name|iPtr
operator|->
name|events
index|[
name|i
index|]
operator|.
name|bytesAvl
operator|=
name|INITIAL_CMD_SIZE
expr_stmt|;
block|}
name|iPtr
operator|->
name|curEvent
operator|=
literal|0
expr_stmt|;
name|iPtr
operator|->
name|curEventNum
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_RecordAndEval --  *  *	This procedure adds its command argument to the current list of  *	recorded events and then executes the command by calling  *	Tcl_Eval.  *  * Results:  *	The return value is a standard Tcl return value, the result of  *	executing cmd.  *  * Side effects:  *	The command is recorded and executed.  In addition, pending history  *	revisions are carried out, and information is set up to enable  *	Tcl_Eval to identify history command ranges.  This procedure also  *	initializes history information for the interpreter, if it hasn't  *	already been initialized.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_RecordAndEval
parameter_list|(
name|interp
parameter_list|,
name|cmd
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Token for interpreter in which command 				 * will be executed. */
name|char
modifier|*
name|cmd
decl_stmt|;
comment|/* Command to record. */
name|int
name|flags
decl_stmt|;
comment|/* Additional flags.  TCL_NO_EVAL means 				 * only record: don't execute command. 				 * TCL_EVAL_GLOBAL means use Tcl_GlobalEval 				 * instead of Tcl_Eval. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
specifier|register
name|HistoryEvent
modifier|*
name|eventPtr
decl_stmt|;
name|int
name|length
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|numEvents
operator|==
literal|0
condition|)
block|{
name|InitHistory
argument_list|(
name|iPtr
argument_list|)
expr_stmt|;
block|}
name|DoRevs
argument_list|(
name|iPtr
argument_list|)
expr_stmt|;
comment|/*      * Don't record empty commands.      */
while|while
condition|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
condition|)
block|{
name|cmd
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'\0'
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
name|iPtr
operator|->
name|curEventNum
operator|++
expr_stmt|;
name|iPtr
operator|->
name|curEvent
operator|++
expr_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|curEvent
operator|>=
name|iPtr
operator|->
name|numEvents
condition|)
block|{
name|iPtr
operator|->
name|curEvent
operator|=
literal|0
expr_stmt|;
block|}
name|eventPtr
operator|=
operator|&
name|iPtr
operator|->
name|events
index|[
name|iPtr
operator|->
name|curEvent
index|]
expr_stmt|;
comment|/*      * Chop off trailing newlines before recording the command.      */
name|length
operator|=
name|strlen
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
while|while
condition|(
name|cmd
index|[
name|length
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|length
operator|--
expr_stmt|;
block|}
name|MakeSpace
argument_list|(
name|eventPtr
argument_list|,
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|eventPtr
operator|->
name|command
argument_list|,
name|cmd
argument_list|,
operator|(
name|size_t
operator|)
name|length
argument_list|)
expr_stmt|;
name|eventPtr
operator|->
name|command
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
comment|/*      * Execute the command.  Note: history revision isn't possible after      * a nested call to this procedure, because the event at the top of      * the history list no longer corresponds to what's going on when      * a nested call here returns.  Thus, must leave history revision      * disabled when we return.      */
name|result
operator|=
name|TCL_OK
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TCL_NO_EVAL
operator|)
condition|)
block|{
name|iPtr
operator|->
name|historyFirst
operator|=
name|cmd
expr_stmt|;
name|iPtr
operator|->
name|revDisables
operator|=
literal|0
expr_stmt|;
name|iPtr
operator|->
name|evalFlags
operator|=
operator|(
name|flags
operator|&
operator|~
name|TCL_EVAL_GLOBAL
operator|)
operator||
name|TCL_RECORD_BOUNDS
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TCL_EVAL_GLOBAL
condition|)
block|{
name|result
operator|=
name|Tcl_GlobalEval
argument_list|(
name|interp
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
name|iPtr
operator|->
name|revDisables
operator|=
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_HistoryCmd --  *  *	This procedure is invoked to process the "history" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_HistoryCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
specifier|register
name|HistoryEvent
modifier|*
name|eventPtr
decl_stmt|;
name|size_t
name|length
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|numEvents
operator|==
literal|0
condition|)
block|{
name|InitHistory
argument_list|(
name|iPtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * If no arguments, treat the same as "history info".      */
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
goto|goto
name|infoCmd
goto|;
block|}
name|c
operator|=
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'a'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"add"
argument_list|,
name|length
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|argc
operator|!=
literal|3
operator|)
operator|&&
operator|(
name|argc
operator|!=
literal|4
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" add event ?exec?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|argc
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|,
literal|"exec"
argument_list|,
name|strlen
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad argument \""
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
literal|"\": should be \"exec\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|Tcl_RecordAndEval
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|Tcl_RecordAndEval
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|TCL_NO_EVAL
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'c'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"change"
argument_list|,
name|length
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|argc
operator|!=
literal|3
operator|)
operator|&&
operator|(
name|argc
operator|!=
literal|4
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" change newValue ?event?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
block|{
name|eventPtr
operator|=
operator|&
name|iPtr
operator|->
name|events
index|[
name|iPtr
operator|->
name|curEvent
index|]
expr_stmt|;
name|iPtr
operator|->
name|revDisables
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
name|iPtr
operator|->
name|revPtr
operator|!=
name|NULL
condition|)
block|{
name|HistoryRev
modifier|*
name|nextPtr
decl_stmt|;
name|ckfree
argument_list|(
name|iPtr
operator|->
name|revPtr
operator|->
name|newBytes
argument_list|)
expr_stmt|;
name|nextPtr
operator|=
name|iPtr
operator|->
name|revPtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iPtr
operator|->
name|revPtr
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|revPtr
operator|=
name|nextPtr
expr_stmt|;
block|}
block|}
else|else
block|{
name|eventPtr
operator|=
name|GetEvent
argument_list|(
name|iPtr
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|eventPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
name|MakeSpace
argument_list|(
name|eventPtr
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|eventPtr
operator|->
name|command
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"event"
argument_list|,
name|length
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" event ?event?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|eventPtr
operator|=
name|GetEvent
argument_list|(
name|iPtr
argument_list|,
name|argc
operator|==
literal|2
condition|?
literal|"-1"
else|:
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|eventPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|RevResult
argument_list|(
name|iPtr
argument_list|,
name|eventPtr
operator|->
name|command
argument_list|)
expr_stmt|;
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|eventPtr
operator|->
name|command
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'i'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"info"
argument_list|,
name|length
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|count
decl_stmt|,
name|indx
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|newline
decl_stmt|;
if|if
condition|(
operator|(
name|argc
operator|!=
literal|2
operator|)
operator|&&
operator|(
name|argc
operator|!=
literal|3
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" info ?count?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|infoCmd
label|:
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|count
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|count
operator|>
name|iPtr
operator|->
name|numEvents
condition|)
block|{
name|count
operator|=
name|iPtr
operator|->
name|numEvents
expr_stmt|;
block|}
block|}
else|else
block|{
name|count
operator|=
name|iPtr
operator|->
name|numEvents
expr_stmt|;
block|}
name|newline
operator|=
literal|""
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|indx
operator|=
name|iPtr
operator|->
name|curEvent
operator|+
literal|1
operator|+
name|iPtr
operator|->
name|numEvents
operator|-
name|count
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|indx
operator|++
control|)
block|{
name|char
modifier|*
name|cur
decl_stmt|,
modifier|*
name|next
decl_stmt|,
name|savedChar
decl_stmt|;
name|char
name|serial
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|indx
operator|>=
name|iPtr
operator|->
name|numEvents
condition|)
block|{
name|indx
operator|-=
name|iPtr
operator|->
name|numEvents
expr_stmt|;
block|}
name|cur
operator|=
name|iPtr
operator|->
name|events
index|[
name|indx
index|]
operator|.
name|command
expr_stmt|;
if|if
condition|(
operator|*
name|cur
operator|==
literal|'\0'
condition|)
block|{
continue|continue;
comment|/* No command recorded here. */
block|}
name|sprintf
argument_list|(
name|serial
argument_list|,
literal|"%6d  "
argument_list|,
name|iPtr
operator|->
name|curEventNum
operator|+
literal|1
operator|-
operator|(
name|count
operator|-
name|i
operator|)
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|newline
argument_list|,
name|serial
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|newline
operator|=
literal|"\n"
expr_stmt|;
comment|/* 	     * Tricky formatting here:  for multi-line commands, indent 	     * the continuation lines. 	     */
while|while
condition|(
literal|1
condition|)
block|{
name|next
operator|=
name|strchr
argument_list|(
name|cur
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|next
operator|++
expr_stmt|;
name|savedChar
operator|=
operator|*
name|next
expr_stmt|;
operator|*
name|next
operator|=
literal|0
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|cur
argument_list|,
literal|"\t"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|next
operator|=
name|savedChar
expr_stmt|;
name|cur
operator|=
name|next
expr_stmt|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|cur
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'k'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"keep"
argument_list|,
name|length
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|count
decl_stmt|,
name|i
decl_stmt|,
name|src
decl_stmt|;
name|HistoryEvent
modifier|*
name|events
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" keep number\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|count
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|count
operator|<=
literal|0
operator|)
operator|||
operator|(
name|count
operator|>
literal|1000
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"illegal keep count \""
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/* 	 * Create a new history array and copy as much existing history 	 * as possible from the old array. 	 */
name|events
operator|=
operator|(
name|HistoryEvent
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|HistoryEvent
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|iPtr
operator|->
name|numEvents
condition|)
block|{
name|src
operator|=
name|iPtr
operator|->
name|curEvent
operator|+
literal|1
operator|-
name|count
expr_stmt|;
if|if
condition|(
name|src
operator|<
literal|0
condition|)
block|{
name|src
operator|+=
name|iPtr
operator|->
name|numEvents
expr_stmt|;
block|}
block|}
else|else
block|{
name|src
operator|=
name|iPtr
operator|->
name|curEvent
operator|+
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|src
operator|++
control|)
block|{
if|if
condition|(
name|src
operator|>=
name|iPtr
operator|->
name|numEvents
condition|)
block|{
name|src
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|iPtr
operator|->
name|numEvents
condition|)
block|{
name|events
index|[
name|i
index|]
operator|=
name|iPtr
operator|->
name|events
index|[
name|src
index|]
expr_stmt|;
name|iPtr
operator|->
name|events
index|[
name|src
index|]
operator|.
name|command
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|events
index|[
name|i
index|]
operator|.
name|command
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
name|INITIAL_CMD_SIZE
argument_list|)
expr_stmt|;
name|events
index|[
name|i
index|]
operator|.
name|command
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|events
index|[
name|i
index|]
operator|.
name|bytesAvl
operator|=
name|INITIAL_CMD_SIZE
expr_stmt|;
block|}
block|}
comment|/* 	 * Throw away everything left in the old history array, and 	 * substitute the new one for the old one. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iPtr
operator|->
name|numEvents
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|iPtr
operator|->
name|events
index|[
name|i
index|]
operator|.
name|command
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|iPtr
operator|->
name|events
index|[
name|i
index|]
operator|.
name|command
argument_list|)
expr_stmt|;
block|}
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iPtr
operator|->
name|events
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|events
operator|=
name|events
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|iPtr
operator|->
name|numEvents
condition|)
block|{
name|iPtr
operator|->
name|curEvent
operator|=
name|count
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|iPtr
operator|->
name|curEvent
operator|=
name|iPtr
operator|->
name|numEvents
operator|-
literal|1
expr_stmt|;
block|}
name|iPtr
operator|->
name|numEvents
operator|=
name|count
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'n'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"nextid"
argument_list|,
name|length
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" nextid\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|sprintf
argument_list|(
name|iPtr
operator|->
name|result
argument_list|,
literal|"%d"
argument_list|,
name|iPtr
operator|->
name|curEventNum
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'r'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"redo"
argument_list|,
name|length
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" redo ?event?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|eventPtr
operator|=
name|GetEvent
argument_list|(
name|iPtr
argument_list|,
name|argc
operator|==
literal|2
condition|?
literal|"-1"
else|:
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|eventPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|RevCommand
argument_list|(
name|iPtr
argument_list|,
name|eventPtr
operator|->
name|command
argument_list|)
expr_stmt|;
return|return
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|eventPtr
operator|->
name|command
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'s'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"substitute"
argument_list|,
name|length
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|argc
operator|>
literal|5
operator|)
operator|||
operator|(
name|argc
operator|<
literal|4
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" substitute old new ?event?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|eventPtr
operator|=
name|GetEvent
argument_list|(
name|iPtr
argument_list|,
name|argc
operator|==
literal|4
condition|?
literal|"-1"
else|:
name|argv
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|eventPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|SubsAndEval
argument_list|(
name|iPtr
argument_list|,
name|eventPtr
operator|->
name|command
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'w'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"words"
argument_list|,
name|length
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|words
decl_stmt|;
if|if
condition|(
operator|(
name|argc
operator|!=
literal|3
operator|)
operator|&&
operator|(
name|argc
operator|!=
literal|4
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" words num-num/pat ?event?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|eventPtr
operator|=
name|GetEvent
argument_list|(
name|iPtr
argument_list|,
name|argc
operator|==
literal|3
condition|?
literal|"-1"
else|:
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|eventPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|words
operator|=
name|GetWords
argument_list|(
name|iPtr
argument_list|,
name|eventPtr
operator|->
name|command
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|words
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|RevResult
argument_list|(
name|iPtr
argument_list|,
name|words
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|result
operator|=
name|words
expr_stmt|;
name|iPtr
operator|->
name|freeProc
operator|=
name|TCL_DYNAMIC
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": must be add, change, event, info, keep, nextid, "
argument_list|,
literal|"redo, substitute, or words"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * MakeSpace --  *  *	Given a history event, make sure it has enough space for  *	a string of a given length (enlarge the string area if  *	necessary).  *  * Results:  *	None.  *  * Side effects:  *	More memory may get allocated.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|MakeSpace
parameter_list|(
name|hPtr
parameter_list|,
name|size
parameter_list|)
name|HistoryEvent
modifier|*
name|hPtr
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* # of bytes needed in hPtr. */
block|{
if|if
condition|(
name|hPtr
operator|->
name|bytesAvl
operator|<
name|size
condition|)
block|{
name|ckfree
argument_list|(
name|hPtr
operator|->
name|command
argument_list|)
expr_stmt|;
name|hPtr
operator|->
name|command
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|size
argument_list|)
expr_stmt|;
name|hPtr
operator|->
name|bytesAvl
operator|=
name|size
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InsertRev --  *  *	Add a new revision to the list of those pending for iPtr.  *	Do it in a way that keeps the revision list sorted in  *	increasing order of firstIndex.  Also, eliminate revisions  *	that are subsets of other revisions.  *  * Results:  *	None.  *  * Side effects:  *	RevPtr is added to iPtr's revision list.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|InsertRev
parameter_list|(
name|iPtr
parameter_list|,
name|revPtr
parameter_list|)
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Interpreter to use. */
specifier|register
name|HistoryRev
modifier|*
name|revPtr
decl_stmt|;
comment|/* Revision to add to iPtr's list. */
block|{
specifier|register
name|HistoryRev
modifier|*
name|curPtr
decl_stmt|;
specifier|register
name|HistoryRev
modifier|*
name|prevPtr
decl_stmt|;
for|for
control|(
name|curPtr
operator|=
name|iPtr
operator|->
name|revPtr
operator|,
name|prevPtr
operator|=
name|NULL
init|;
name|curPtr
operator|!=
name|NULL
condition|;
name|prevPtr
operator|=
name|curPtr
operator|,
name|curPtr
operator|=
name|curPtr
operator|->
name|nextPtr
control|)
block|{
comment|/* 	 * If this revision includes the new one (or vice versa) then 	 * just eliminate the one that is a subset of the other. 	 */
if|if
condition|(
operator|(
name|revPtr
operator|->
name|firstIndex
operator|<=
name|curPtr
operator|->
name|firstIndex
operator|)
operator|&&
operator|(
name|revPtr
operator|->
name|lastIndex
operator|>=
name|curPtr
operator|->
name|firstIndex
operator|)
condition|)
block|{
name|curPtr
operator|->
name|firstIndex
operator|=
name|revPtr
operator|->
name|firstIndex
expr_stmt|;
name|curPtr
operator|->
name|lastIndex
operator|=
name|revPtr
operator|->
name|lastIndex
expr_stmt|;
name|curPtr
operator|->
name|newSize
operator|=
name|revPtr
operator|->
name|newSize
expr_stmt|;
name|ckfree
argument_list|(
name|curPtr
operator|->
name|newBytes
argument_list|)
expr_stmt|;
name|curPtr
operator|->
name|newBytes
operator|=
name|revPtr
operator|->
name|newBytes
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|revPtr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|revPtr
operator|->
name|firstIndex
operator|>=
name|curPtr
operator|->
name|firstIndex
operator|)
operator|&&
operator|(
name|revPtr
operator|->
name|lastIndex
operator|<=
name|curPtr
operator|->
name|lastIndex
operator|)
condition|)
block|{
name|ckfree
argument_list|(
name|revPtr
operator|->
name|newBytes
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|revPtr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|revPtr
operator|->
name|firstIndex
operator|<
name|curPtr
operator|->
name|firstIndex
condition|)
block|{
break|break;
block|}
block|}
comment|/*      * Insert revPtr just after prevPtr.      */
if|if
condition|(
name|prevPtr
operator|==
name|NULL
condition|)
block|{
name|revPtr
operator|->
name|nextPtr
operator|=
name|iPtr
operator|->
name|revPtr
expr_stmt|;
name|iPtr
operator|->
name|revPtr
operator|=
name|revPtr
expr_stmt|;
block|}
else|else
block|{
name|revPtr
operator|->
name|nextPtr
operator|=
name|prevPtr
operator|->
name|nextPtr
expr_stmt|;
name|prevPtr
operator|->
name|nextPtr
operator|=
name|revPtr
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * RevCommand --  *  *	This procedure is invoked by the "history" command to record  *	a command revision.  See the comments at the beginning of the  *	file for more information about revisions.  *  * Results:  *	None.  *  * Side effects:  *	Revision information is recorded.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|RevCommand
parameter_list|(
name|iPtr
parameter_list|,
name|string
parameter_list|)
specifier|register
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Interpreter in which to perform the 				 * substitution. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String to substitute. */
block|{
specifier|register
name|HistoryRev
modifier|*
name|revPtr
decl_stmt|;
if|if
condition|(
operator|(
name|iPtr
operator|->
name|evalFirst
operator|==
name|NULL
operator|)
operator|||
operator|(
name|iPtr
operator|->
name|revDisables
operator|>
literal|0
operator|)
condition|)
block|{
return|return;
block|}
name|revPtr
operator|=
operator|(
name|HistoryRev
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HistoryRev
argument_list|)
argument_list|)
expr_stmt|;
name|revPtr
operator|->
name|firstIndex
operator|=
name|iPtr
operator|->
name|evalFirst
operator|-
name|iPtr
operator|->
name|historyFirst
expr_stmt|;
name|revPtr
operator|->
name|lastIndex
operator|=
name|iPtr
operator|->
name|evalLast
operator|-
name|iPtr
operator|->
name|historyFirst
expr_stmt|;
name|revPtr
operator|->
name|newSize
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|revPtr
operator|->
name|newBytes
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|revPtr
operator|->
name|newSize
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|revPtr
operator|->
name|newBytes
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|InsertRev
argument_list|(
name|iPtr
argument_list|,
name|revPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * RevResult --  *  *	This procedure is invoked by the "history" command to record  *	a result revision.  See the comments at the beginning of the  *	file for more information about revisions.  *  * Results:  *	None.  *  * Side effects:  *	Revision information is recorded.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|RevResult
parameter_list|(
name|iPtr
parameter_list|,
name|string
parameter_list|)
specifier|register
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Interpreter in which to perform the 				 * substitution. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String to substitute. */
block|{
specifier|register
name|HistoryRev
modifier|*
name|revPtr
decl_stmt|;
name|char
modifier|*
name|evalFirst
decl_stmt|,
modifier|*
name|evalLast
decl_stmt|;
name|char
modifier|*
name|argv
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|iPtr
operator|->
name|evalFirst
operator|==
name|NULL
operator|)
operator|||
operator|(
name|iPtr
operator|->
name|revDisables
operator|>
literal|0
operator|)
condition|)
block|{
return|return;
block|}
comment|/*      * Expand the replacement range to include the brackets that surround      * the command.  If there aren't any brackets (i.e. this command was      * invoked at top-level) then don't do any revision.  Also, if there      * are several commands in brackets, of which this is just one,      * then don't do any revision.      */
name|evalFirst
operator|=
name|iPtr
operator|->
name|evalFirst
expr_stmt|;
name|evalLast
operator|=
name|iPtr
operator|->
name|evalLast
operator|+
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|evalFirst
operator|==
name|iPtr
operator|->
name|historyFirst
condition|)
block|{
return|return;
block|}
name|evalFirst
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|evalFirst
operator|==
literal|'['
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|evalFirst
argument_list|)
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
if|if
condition|(
operator|*
name|evalLast
operator|!=
literal|']'
condition|)
block|{
return|return;
block|}
name|revPtr
operator|=
operator|(
name|HistoryRev
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HistoryRev
argument_list|)
argument_list|)
expr_stmt|;
name|revPtr
operator|->
name|firstIndex
operator|=
name|evalFirst
operator|-
name|iPtr
operator|->
name|historyFirst
expr_stmt|;
name|revPtr
operator|->
name|lastIndex
operator|=
name|evalLast
operator|-
name|iPtr
operator|->
name|historyFirst
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|string
expr_stmt|;
name|revPtr
operator|->
name|newBytes
operator|=
name|Tcl_Merge
argument_list|(
literal|1
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|revPtr
operator|->
name|newSize
operator|=
name|strlen
argument_list|(
name|revPtr
operator|->
name|newBytes
argument_list|)
expr_stmt|;
name|InsertRev
argument_list|(
name|iPtr
argument_list|,
name|revPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DoRevs --  *  *	This procedure is called to apply the history revisions that  *	have been recorded in iPtr.  *  * Results:  *	None.  *  * Side effects:  *	The most recent entry in the history for iPtr may be modified.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|DoRevs
parameter_list|(
name|iPtr
parameter_list|)
specifier|register
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Interpreter whose history is to 				 * be modified. */
block|{
specifier|register
name|HistoryRev
modifier|*
name|revPtr
decl_stmt|;
specifier|register
name|HistoryEvent
modifier|*
name|eventPtr
decl_stmt|;
name|char
modifier|*
name|newCommand
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|int
name|bytesSeen
decl_stmt|,
name|count
decl_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|revPtr
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
comment|/*      * The revision is done in two passes.  The first pass computes the      * amount of space needed for the revised event, and the second pass      * pieces together the new event and frees up the revisions.      */
name|eventPtr
operator|=
operator|&
name|iPtr
operator|->
name|events
index|[
name|iPtr
operator|->
name|curEvent
index|]
expr_stmt|;
name|size
operator|=
name|strlen
argument_list|(
name|eventPtr
operator|->
name|command
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|revPtr
operator|=
name|iPtr
operator|->
name|revPtr
init|;
name|revPtr
operator|!=
name|NULL
condition|;
name|revPtr
operator|=
name|revPtr
operator|->
name|nextPtr
control|)
block|{
name|size
operator|-=
name|revPtr
operator|->
name|lastIndex
operator|+
literal|1
operator|-
name|revPtr
operator|->
name|firstIndex
expr_stmt|;
name|size
operator|+=
name|revPtr
operator|->
name|newSize
expr_stmt|;
block|}
name|newCommand
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|p
operator|=
name|newCommand
expr_stmt|;
name|bytesSeen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|revPtr
operator|=
name|iPtr
operator|->
name|revPtr
init|;
name|revPtr
operator|!=
name|NULL
condition|;
control|)
block|{
name|HistoryRev
modifier|*
name|nextPtr
init|=
name|revPtr
operator|->
name|nextPtr
decl_stmt|;
name|count
operator|=
name|revPtr
operator|->
name|firstIndex
operator|-
name|bytesSeen
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|p
argument_list|,
name|eventPtr
operator|->
name|command
operator|+
name|bytesSeen
argument_list|,
operator|(
name|size_t
operator|)
name|count
argument_list|)
expr_stmt|;
name|p
operator|+=
name|count
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|p
argument_list|,
name|revPtr
operator|->
name|newBytes
argument_list|,
operator|(
name|size_t
operator|)
name|revPtr
operator|->
name|newSize
argument_list|)
expr_stmt|;
name|p
operator|+=
name|revPtr
operator|->
name|newSize
expr_stmt|;
name|bytesSeen
operator|=
name|revPtr
operator|->
name|lastIndex
operator|+
literal|1
expr_stmt|;
name|ckfree
argument_list|(
name|revPtr
operator|->
name|newBytes
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|revPtr
argument_list|)
expr_stmt|;
name|revPtr
operator|=
name|nextPtr
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|p
argument_list|,
name|eventPtr
operator|->
name|command
operator|+
name|bytesSeen
argument_list|)
expr_stmt|;
comment|/*      * Replace the command in the event.      */
name|ckfree
argument_list|(
name|eventPtr
operator|->
name|command
argument_list|)
expr_stmt|;
name|eventPtr
operator|->
name|command
operator|=
name|newCommand
expr_stmt|;
name|eventPtr
operator|->
name|bytesAvl
operator|=
name|size
expr_stmt|;
name|iPtr
operator|->
name|revPtr
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * GetEvent --  *  *	Given a textual description of an event (see the manual page  *	for legal values) find the corresponding event and return its  *	command string.  *  * Results:  *	The return value is a pointer to the event named by "string".  *	If no such event exists, then NULL is returned and an error  *	message is left in iPtr.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|HistoryEvent
modifier|*
name|GetEvent
parameter_list|(
name|iPtr
parameter_list|,
name|string
parameter_list|)
specifier|register
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Interpreter in which to look. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Description of event. */
block|{
name|int
name|eventNum
decl_stmt|,
name|index
decl_stmt|;
specifier|register
name|HistoryEvent
modifier|*
name|eventPtr
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/*      * First check for a numeric specification of an event.      */
if|if
condition|(
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|string
argument_list|)
argument_list|)
operator|||
operator|(
operator|*
name|string
operator|==
literal|'-'
operator|)
condition|)
block|{
if|if
condition|(
name|Tcl_GetInt
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
name|string
argument_list|,
operator|&
name|eventNum
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|eventNum
operator|<
literal|0
condition|)
block|{
name|eventNum
operator|+=
name|iPtr
operator|->
name|curEventNum
expr_stmt|;
block|}
if|if
condition|(
name|eventNum
operator|>
name|iPtr
operator|->
name|curEventNum
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"event \""
argument_list|,
name|string
argument_list|,
literal|"\" hasn't occurred yet"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|eventNum
operator|<=
name|iPtr
operator|->
name|curEventNum
operator|-
name|iPtr
operator|->
name|numEvents
operator|)
operator|||
operator|(
name|eventNum
operator|<=
literal|0
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"event \""
argument_list|,
name|string
argument_list|,
literal|"\" is too far in the past"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|index
operator|=
name|iPtr
operator|->
name|curEvent
operator|+
operator|(
name|eventNum
operator|-
name|iPtr
operator|->
name|curEventNum
operator|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
name|index
operator|+=
name|iPtr
operator|->
name|numEvents
expr_stmt|;
block|}
return|return
operator|&
name|iPtr
operator|->
name|events
index|[
name|index
index|]
return|;
block|}
comment|/*      * Next, check for an event that contains the string as a prefix or      * that matches the string in the sense of Tcl_StringMatch.      */
name|length
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
name|iPtr
operator|->
name|curEvent
operator|-
literal|1
init|;
condition|;
name|index
operator|--
control|)
block|{
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
name|index
operator|+=
name|iPtr
operator|->
name|numEvents
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|==
name|iPtr
operator|->
name|curEvent
condition|)
block|{
break|break;
block|}
name|eventPtr
operator|=
operator|&
name|iPtr
operator|->
name|events
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|eventPtr
operator|->
name|command
argument_list|,
name|string
argument_list|,
operator|(
name|size_t
operator|)
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|||
name|Tcl_StringMatch
argument_list|(
name|eventPtr
operator|->
name|command
argument_list|,
name|string
argument_list|)
condition|)
block|{
return|return
name|eventPtr
return|;
block|}
block|}
name|Tcl_AppendResult
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"no event matches \""
argument_list|,
name|string
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SubsAndEval --  *  *	Generate a new command by making a textual substitution in  *	the "cmd" argument.  Then execute the new command.  *  * Results:  *	The return value is a standard Tcl error.  *  * Side effects:  *	History gets revised if the substitution is occurring on  *	a recorded command line.  Also, the re-executed command  *	may produce side-effects.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SubsAndEval
parameter_list|(
name|iPtr
parameter_list|,
name|cmd
parameter_list|,
name|old
parameter_list|,
name|new
parameter_list|)
specifier|register
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Interpreter in which to execute 				 * new command. */
name|char
modifier|*
name|cmd
decl_stmt|;
comment|/* Command in which to substitute. */
name|char
modifier|*
name|old
decl_stmt|;
comment|/* String to search for in command. */
name|char
modifier|*
name|new
decl_stmt|;
comment|/* Replacement string for "old". */
block|{
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
modifier|*
name|newCmd
decl_stmt|;
name|int
name|count
decl_stmt|,
name|oldLength
decl_stmt|,
name|newLength
decl_stmt|,
name|length
decl_stmt|,
name|result
decl_stmt|;
comment|/*      * Figure out how much space it will take to hold the      * substituted command (and complain if the old string      * doesn't appear in the original command).      */
name|oldLength
operator|=
name|strlen
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|newLength
operator|=
name|strlen
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|src
operator|=
name|cmd
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|src
operator|=
name|strstr
argument_list|(
name|src
argument_list|,
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|src
operator|+=
name|oldLength
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"\""
argument_list|,
name|old
argument_list|,
literal|"\" doesn't appear in event"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|length
operator|=
name|strlen
argument_list|(
name|cmd
argument_list|)
operator|+
name|count
operator|*
operator|(
name|newLength
operator|-
name|oldLength
operator|)
expr_stmt|;
comment|/*      * Generate a substituted command.      */
name|newCmd
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|length
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
name|newCmd
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|src
operator|=
name|strstr
argument_list|(
name|cmd
argument_list|,
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|==
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|dst
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
name|strncpy
argument_list|(
name|dst
argument_list|,
name|cmd
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|src
operator|-
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|src
operator|-
name|cmd
expr_stmt|;
name|strcpy
argument_list|(
name|dst
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|newLength
expr_stmt|;
name|cmd
operator|=
name|src
operator|+
name|oldLength
expr_stmt|;
block|}
name|RevCommand
argument_list|(
name|iPtr
argument_list|,
name|newCmd
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_Eval
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
name|newCmd
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|newCmd
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * GetWords --  *  *	Given a command string, return one or more words from the  *	command string.  *  * Results:  *	The return value is a pointer to a dynamically-allocated  *	string containing the words of command specified by "words".  *	If the word specifier has improper syntax then an error  *	message is placed in iPtr->result and NULL is returned.  *  * Side effects:  *	Memory is allocated.  It is the caller's responsibilty to  *	free the returned string..  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|GetWords
parameter_list|(
name|iPtr
parameter_list|,
name|command
parameter_list|,
name|words
parameter_list|)
specifier|register
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Tcl interpreter in which to place 				 * an error message if needed. */
name|char
modifier|*
name|command
decl_stmt|;
comment|/* Command string. */
name|char
modifier|*
name|words
decl_stmt|;
comment|/* Description of which words to extract 				 * from the command.  Either num[-num] or 				 * a pattern. */
block|{
name|char
modifier|*
name|result
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
specifier|register
name|char
modifier|*
name|next
decl_stmt|;
name|int
name|first
decl_stmt|;
comment|/* First word desired. -1 means last word 				 * only. */
name|int
name|last
decl_stmt|;
comment|/* Last word desired.  -1 means use everything 				 * up to the end. */
name|int
name|index
decl_stmt|;
comment|/* Index of current word. */
name|char
modifier|*
name|pattern
decl_stmt|;
comment|/*      * Figure out whether we're looking for a numerical range or for      * a pattern.      */
name|pattern
operator|=
name|NULL
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
name|last
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|words
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
name|words
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|first
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|words
argument_list|)
argument_list|)
condition|)
block|{
name|first
operator|=
name|strtoul
argument_list|(
name|words
argument_list|,
operator|&
name|start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|start
operator|==
literal|0
condition|)
block|{
name|last
operator|=
name|first
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|start
operator|==
literal|'-'
condition|)
block|{
name|start
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|start
operator|==
literal|'$'
condition|)
block|{
name|start
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|start
argument_list|)
argument_list|)
condition|)
block|{
name|last
operator|=
name|strtoul
argument_list|(
name|start
argument_list|,
operator|&
name|start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|*
name|start
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|first
operator|>
name|last
operator|)
operator|&&
operator|(
name|last
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
goto|goto
name|error
goto|;
block|}
block|}
else|else
block|{
name|pattern
operator|=
name|words
expr_stmt|;
block|}
comment|/*      * Scan through the words one at a time, copying those that are      * relevant into the result string.  Allocate a result area large      * enough to hold all the words if necessary.      */
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|command
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
name|result
expr_stmt|;
for|for
control|(
name|next
operator|=
name|command
init|;
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|next
argument_list|)
argument_list|)
condition|;
name|next
operator|++
control|)
block|{
comment|/* Empty loop body:  just find start of first word. */
block|}
for|for
control|(
name|index
operator|=
literal|0
init|;
operator|*
name|next
operator|!=
literal|0
condition|;
name|index
operator|++
control|)
block|{
name|start
operator|=
name|next
expr_stmt|;
name|end
operator|=
name|TclWordEnd
argument_list|(
name|next
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|!=
literal|0
condition|)
block|{
name|end
operator|++
expr_stmt|;
for|for
control|(
name|next
operator|=
name|end
init|;
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|next
argument_list|)
argument_list|)
condition|;
name|next
operator|++
control|)
block|{
comment|/* Empty loop body:  just find start of next word. */
block|}
block|}
if|if
condition|(
operator|(
name|first
operator|>
name|index
operator|)
operator|||
operator|(
operator|(
name|first
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|*
name|next
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|last
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|last
operator|<
name|index
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|pattern
operator|!=
name|NULL
condition|)
block|{
name|int
name|match
decl_stmt|;
name|char
name|savedChar
init|=
operator|*
name|end
decl_stmt|;
operator|*
name|end
operator|=
literal|0
expr_stmt|;
name|match
operator|=
name|Tcl_StringMatch
argument_list|(
name|start
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
name|savedChar
expr_stmt|;
if|if
condition|(
operator|!
name|match
condition|)
block|{
continue|continue;
block|}
block|}
if|if
condition|(
name|dst
operator|!=
name|result
condition|)
block|{
operator|*
name|dst
operator|=
literal|' '
expr_stmt|;
name|dst
operator|++
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|dst
argument_list|,
name|start
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|end
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|end
operator|-
name|start
expr_stmt|;
block|}
operator|*
name|dst
operator|=
literal|0
expr_stmt|;
comment|/*      * Check for an out-of-range argument index.      */
if|if
condition|(
operator|(
name|last
operator|>=
name|index
operator|)
operator|||
operator|(
name|first
operator|>=
name|index
operator|)
condition|)
block|{
name|ckfree
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"word selector \""
argument_list|,
name|words
argument_list|,
literal|"\" specified non-existent words"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|result
return|;
name|error
label|:
name|Tcl_AppendResult
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"bad word selector \""
argument_list|,
name|words
argument_list|,
literal|"\": should be num-num or pattern"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

end_unit

