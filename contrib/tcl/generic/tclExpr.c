begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclExpr.c --  *  *	This file contains the code to evaluate expressions for  *	Tcl.  *  *	This implementation of floating-point support was modelled  *	after an initial implementation by Bill Carpenter.  *  * Copyright (c) 1987-1994 The Regents of the University of California.  * Copyright (c) 1994 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclExpr.c 1.91 96/02/15 11:42:44  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NO_FLOAT_H
end_ifdef

begin_include
include|#
directive|include
file|"../compat/float.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<float.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TCL_NO_MATH
end_ifndef

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The stuff below is a bit of a hack so that this file can be used  * in environments that include no UNIX, i.e. no errno.  Just define  * errno here.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TCL_GENERIC_ONLY
end_ifndef

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NO_ERRNO_H
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_ERRNO_H
end_ifdef

begin_decl_stmt
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|EDOM
value|33
end_define

begin_define
define|#
directive|define
name|ERANGE
value|34
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The data structure below is used to describe an expression value,  * which can be either an integer (the usual case), a double-precision  * floating-point value, or a string.  A given number has only one  * value at a time.  */
end_comment

begin_define
define|#
directive|define
name|STATIC_STRING_SPACE
value|150
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|long
name|intValue
decl_stmt|;
comment|/* Integer value, if any. */
name|double
name|doubleValue
decl_stmt|;
comment|/* Floating-point value, if any. */
name|ParseValue
name|pv
decl_stmt|;
comment|/* Used to hold a string value, if any. */
name|char
name|staticSpace
index|[
name|STATIC_STRING_SPACE
index|]
decl_stmt|;
comment|/* Storage for small strings;  large ones 				 * are malloc-ed. */
name|int
name|type
decl_stmt|;
comment|/* Type of value:  TYPE_INT, TYPE_DOUBLE, 				 * or TYPE_STRING. */
block|}
name|Value
typedef|;
end_typedef

begin_comment
comment|/*  * Valid values for type:  */
end_comment

begin_define
define|#
directive|define
name|TYPE_INT
value|0
end_define

begin_define
define|#
directive|define
name|TYPE_DOUBLE
value|1
end_define

begin_define
define|#
directive|define
name|TYPE_STRING
value|2
end_define

begin_comment
comment|/*  * The data structure below describes the state of parsing an expression.  * It's passed among the routines in this module.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|originalExpr
decl_stmt|;
comment|/* The entire expression, as originally 				 * passed to Tcl_ExprString et al. */
name|char
modifier|*
name|expr
decl_stmt|;
comment|/* Position to the next character to be 				 * scanned from the expression string. */
name|int
name|token
decl_stmt|;
comment|/* Type of the last token to be parsed from 				 * expr.  See below for definitions. 				 * Corresponds to the characters just 				 * before expr. */
block|}
name|ExprInfo
typedef|;
end_typedef

begin_comment
comment|/*  * The token types are defined below.  In addition, there is a table  * associating a precedence with each operator.  The order of types  * is important.  Consult the code before changing it.  */
end_comment

begin_define
define|#
directive|define
name|VALUE
value|0
end_define

begin_define
define|#
directive|define
name|OPEN_PAREN
value|1
end_define

begin_define
define|#
directive|define
name|CLOSE_PAREN
value|2
end_define

begin_define
define|#
directive|define
name|COMMA
value|3
end_define

begin_define
define|#
directive|define
name|END
value|4
end_define

begin_define
define|#
directive|define
name|UNKNOWN
value|5
end_define

begin_comment
comment|/*  * Binary operators:  */
end_comment

begin_define
define|#
directive|define
name|MULT
value|8
end_define

begin_define
define|#
directive|define
name|DIVIDE
value|9
end_define

begin_define
define|#
directive|define
name|MOD
value|10
end_define

begin_define
define|#
directive|define
name|PLUS
value|11
end_define

begin_define
define|#
directive|define
name|MINUS
value|12
end_define

begin_define
define|#
directive|define
name|LEFT_SHIFT
value|13
end_define

begin_define
define|#
directive|define
name|RIGHT_SHIFT
value|14
end_define

begin_define
define|#
directive|define
name|LESS
value|15
end_define

begin_define
define|#
directive|define
name|GREATER
value|16
end_define

begin_define
define|#
directive|define
name|LEQ
value|17
end_define

begin_define
define|#
directive|define
name|GEQ
value|18
end_define

begin_define
define|#
directive|define
name|EQUAL
value|19
end_define

begin_define
define|#
directive|define
name|NEQ
value|20
end_define

begin_define
define|#
directive|define
name|BIT_AND
value|21
end_define

begin_define
define|#
directive|define
name|BIT_XOR
value|22
end_define

begin_define
define|#
directive|define
name|BIT_OR
value|23
end_define

begin_define
define|#
directive|define
name|AND
value|24
end_define

begin_define
define|#
directive|define
name|OR
value|25
end_define

begin_define
define|#
directive|define
name|QUESTY
value|26
end_define

begin_define
define|#
directive|define
name|COLON
value|27
end_define

begin_comment
comment|/*  * Unary operators:  */
end_comment

begin_define
define|#
directive|define
name|UNARY_MINUS
value|28
end_define

begin_define
define|#
directive|define
name|UNARY_PLUS
value|29
end_define

begin_define
define|#
directive|define
name|NOT
value|30
end_define

begin_define
define|#
directive|define
name|BIT_NOT
value|31
end_define

begin_comment
comment|/*  * Precedence table.  The values for non-operator token types are ignored.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|precTable
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
comment|/* MULT, DIVIDE, MOD */
literal|11
block|,
literal|11
block|,
comment|/* PLUS, MINUS */
literal|10
block|,
literal|10
block|,
comment|/* LEFT_SHIFT, RIGHT_SHIFT */
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
comment|/* LESS, GREATER, LEQ, GEQ */
literal|8
block|,
literal|8
block|,
comment|/* EQUAL, NEQ */
literal|7
block|,
comment|/* BIT_AND */
literal|6
block|,
comment|/* BIT_XOR */
literal|5
block|,
comment|/* BIT_OR */
literal|4
block|,
comment|/* AND */
literal|3
block|,
comment|/* OR */
literal|2
block|,
comment|/* QUESTY */
literal|1
block|,
comment|/* COLON */
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
comment|/* UNARY_MINUS, UNARY_PLUS, NOT, 					 * BIT_NOT */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Mapping from operator numbers to strings;  used for error messages.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|operatorStrings
index|[]
init|=
block|{
literal|"VALUE"
block|,
literal|"("
block|,
literal|")"
block|,
literal|","
block|,
literal|"END"
block|,
literal|"UNKNOWN"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"*"
block|,
literal|"/"
block|,
literal|"%"
block|,
literal|"+"
block|,
literal|"-"
block|,
literal|"<<"
block|,
literal|">>"
block|,
literal|"<"
block|,
literal|">"
block|,
literal|"<="
block|,
literal|">="
block|,
literal|"=="
block|,
literal|"!="
block|,
literal|"&"
block|,
literal|"^"
block|,
literal|"|"
block|,
literal|"&&"
block|,
literal|"||"
block|,
literal|"?"
block|,
literal|":"
block|,
literal|"-"
block|,
literal|"+"
block|,
literal|"!"
block|,
literal|"~"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The following slight modification to DBL_MAX is needed because of  * a compiler bug on Sprite (4/15/93).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|sprite
end_ifdef

begin_undef
undef|#
directive|undef
name|DBL_MAX
end_undef

begin_define
define|#
directive|define
name|DBL_MAX
value|1.797693134862316e+307
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Macros for testing floating-point values for certain special  * cases.  Test for not-a-number by comparing a value against  * itself;  test for infinity by comparing against the largest  * floating-point value.  */
end_comment

begin_define
define|#
directive|define
name|IS_NAN
parameter_list|(
name|v
parameter_list|)
value|((v) != (v))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DBL_MAX
end_ifdef

begin_define
define|#
directive|define
name|IS_INF
parameter_list|(
name|v
parameter_list|)
value|(((v)> DBL_MAX) || ((v)< -DBL_MAX))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|IS_INF
parameter_list|(
name|v
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The following global variable is use to signal matherr that Tcl  * is responsible for the arithmetic, so errors can be handled in a  * fashion appropriate for Tcl.  Zero means no Tcl math is in  * progress;  non-zero means Tcl is doing math.  */
end_comment

begin_decl_stmt
name|int
name|tcl_MathInProgress
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The variable below serves no useful purpose except to generate  * a reference to matherr, so that the Tcl version of matherr is  * linked in rather than the system version.  Without this reference  * the need for matherr won't be discovered during linking until after  * libtcl.a has been processed, so Tcl's version won't be used.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_MATHERR
end_ifdef

begin_function_decl
specifier|extern
name|int
name|matherr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|tclMatherrPtr
function_decl|)
parameter_list|()
init|=
name|matherr
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Declarations for local procedures to this file:  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ExprAbsFunc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Value
operator|*
name|args
operator|,
name|Tcl_Value
operator|*
name|resultPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ExprBinaryFunc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Value
operator|*
name|args
operator|,
name|Tcl_Value
operator|*
name|resultPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ExprDoubleFunc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Value
operator|*
name|args
operator|,
name|Tcl_Value
operator|*
name|resultPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ExprGetValue
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExprInfo
operator|*
name|infoPtr
operator|,
name|int
name|prec
operator|,
name|Value
operator|*
name|valuePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ExprIntFunc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Value
operator|*
name|args
operator|,
name|Tcl_Value
operator|*
name|resultPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ExprLex
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExprInfo
operator|*
name|infoPtr
operator|,
name|Value
operator|*
name|valuePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ExprLooksLikeInt
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ExprMakeString
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Value
operator|*
name|valuePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ExprMathFunc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExprInfo
operator|*
name|infoPtr
operator|,
name|Value
operator|*
name|valuePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ExprParseString
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|Value
operator|*
name|valuePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ExprRoundFunc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Value
operator|*
name|args
operator|,
name|Tcl_Value
operator|*
name|resultPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ExprTopLevel
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|Value
operator|*
name|valuePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ExprUnaryFunc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Value
operator|*
name|args
operator|,
name|Tcl_Value
operator|*
name|resultPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Built-in math functions:  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of function. */
name|int
name|numArgs
decl_stmt|;
comment|/* Number of arguments for function. */
name|Tcl_ValueType
name|argTypes
index|[
name|MAX_MATH_ARGS
index|]
decl_stmt|;
comment|/* Acceptable types for each argument. */
name|Tcl_MathProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure that implements this function. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Additional argument to pass to the function 				 * when invoking it. */
block|}
name|BuiltinFunc
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|BuiltinFunc
name|funcTable
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|TCL_NO_MATH
block|{
literal|"acos"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|acos
block|}
block|,
block|{
literal|"asin"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|asin
block|}
block|,
block|{
literal|"atan"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|atan
block|}
block|,
block|{
literal|"atan2"
block|,
literal|2
block|,
block|{
name|TCL_DOUBLE
block|,
name|TCL_DOUBLE
block|}
block|,
name|ExprBinaryFunc
block|,
operator|(
name|ClientData
operator|)
name|atan2
block|}
block|,
block|{
literal|"ceil"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|ceil
block|}
block|,
block|{
literal|"cos"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|cos
block|}
block|,
block|{
literal|"cosh"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|cosh
block|}
block|,
block|{
literal|"exp"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|exp
block|}
block|,
block|{
literal|"floor"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|floor
block|}
block|,
block|{
literal|"fmod"
block|,
literal|2
block|,
block|{
name|TCL_DOUBLE
block|,
name|TCL_DOUBLE
block|}
block|,
name|ExprBinaryFunc
block|,
operator|(
name|ClientData
operator|)
name|fmod
block|}
block|,
block|{
literal|"hypot"
block|,
literal|2
block|,
block|{
name|TCL_DOUBLE
block|,
name|TCL_DOUBLE
block|}
block|,
name|ExprBinaryFunc
block|,
operator|(
name|ClientData
operator|)
name|hypot
block|}
block|,
block|{
literal|"log"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|log
block|}
block|,
block|{
literal|"log10"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|log10
block|}
block|,
block|{
literal|"pow"
block|,
literal|2
block|,
block|{
name|TCL_DOUBLE
block|,
name|TCL_DOUBLE
block|}
block|,
name|ExprBinaryFunc
block|,
operator|(
name|ClientData
operator|)
name|pow
block|}
block|,
block|{
literal|"sin"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|sin
block|}
block|,
block|{
literal|"sinh"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|sinh
block|}
block|,
block|{
literal|"sqrt"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|sqrt
block|}
block|,
block|{
literal|"tan"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|tan
block|}
block|,
block|{
literal|"tanh"
block|,
literal|1
block|,
block|{
name|TCL_DOUBLE
block|}
block|,
name|ExprUnaryFunc
block|,
operator|(
name|ClientData
operator|)
name|tanh
block|}
block|,
endif|#
directive|endif
block|{
literal|"abs"
block|,
literal|1
block|,
block|{
name|TCL_EITHER
block|}
block|,
name|ExprAbsFunc
block|,
literal|0
block|}
block|,
block|{
literal|"double"
block|,
literal|1
block|,
block|{
name|TCL_EITHER
block|}
block|,
name|ExprDoubleFunc
block|,
literal|0
block|}
block|,
block|{
literal|"int"
block|,
literal|1
block|,
block|{
name|TCL_EITHER
block|}
block|,
name|ExprIntFunc
block|,
literal|0
block|}
block|,
block|{
literal|"round"
block|,
literal|1
block|,
block|{
name|TCL_EITHER
block|}
block|,
name|ExprRoundFunc
block|,
literal|0
block|}
block|,
block|{
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * ExprParseString --  *  *	Given a string (such as one coming from command or variable  *	substitution), make a Value based on the string.  The value  *	will be a floating-point or integer, if possible, or else it  *	will just be a copy of the string.  *  * Results:  *	TCL_OK is returned under normal circumstances, and TCL_ERROR  *	is returned if a floating-point overflow or underflow occurred  *	while reading in a number.  The value at *valuePtr is modified  *	to hold a number, if possible.  *  * Side effects:  *	None.  *  *--------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ExprParseString
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|valuePtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Where to store error message. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String to turn into value. */
name|Value
modifier|*
name|valuePtr
decl_stmt|;
comment|/* Where to store value information.  				 * Caller must have initialized pv field. */
block|{
name|char
modifier|*
name|term
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|start
decl_stmt|;
if|if
condition|(
operator|*
name|string
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ExprLooksLikeInt
argument_list|(
name|string
argument_list|)
condition|)
block|{
name|valuePtr
operator|->
name|type
operator|=
name|TYPE_INT
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* 	     * Note: use strtoul instead of strtol for integer conversions 	     * to allow full-size unsigned numbers, but don't depend on 	     * strtoul to handle sign characters;  it won't in some 	     * implementations. 	     */
for|for
control|(
name|p
operator|=
name|string
init|;
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|;
name|p
operator|++
control|)
block|{
comment|/* Empty loop body. */
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|start
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|valuePtr
operator|->
name|intValue
operator|=
operator|-
operator|(
operator|(
name|int
operator|)
name|strtoul
argument_list|(
name|start
argument_list|,
operator|&
name|term
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'+'
condition|)
block|{
name|start
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|valuePtr
operator|->
name|intValue
operator|=
name|strtoul
argument_list|(
name|start
argument_list|,
operator|&
name|term
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|p
expr_stmt|;
name|valuePtr
operator|->
name|intValue
operator|=
name|strtoul
argument_list|(
name|start
argument_list|,
operator|&
name|term
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|term
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ERANGE
condition|)
block|{
comment|/* 		     * This procedure is sometimes called with string in 		     * interp->result, so we have to clear the result before 		     * logging an error message. 		     */
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|interp
operator|->
name|result
operator|=
literal|"integer value too large to represent"
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"ARITH"
argument_list|,
literal|"IOVERFLOW"
argument_list|,
name|interp
operator|->
name|result
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
else|else
block|{
return|return
name|TCL_OK
return|;
block|}
block|}
block|}
else|else
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|valuePtr
operator|->
name|doubleValue
operator|=
name|strtod
argument_list|(
name|string
argument_list|,
operator|&
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|term
operator|!=
name|string
operator|)
operator|&&
operator|(
operator|*
name|term
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|TclExprFloatError
argument_list|(
name|interp
argument_list|,
name|valuePtr
operator|->
name|doubleValue
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|valuePtr
operator|->
name|type
operator|=
name|TYPE_DOUBLE
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
block|}
block|}
comment|/*      * Not a valid number.  Save a string value (but don't do anything      * if it's already the value).      */
name|valuePtr
operator|->
name|type
operator|=
name|TYPE_STRING
expr_stmt|;
if|if
condition|(
name|string
operator|!=
name|valuePtr
operator|->
name|pv
operator|.
name|buffer
condition|)
block|{
name|int
name|length
decl_stmt|,
name|shortfall
decl_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|valuePtr
operator|->
name|pv
operator|.
name|next
operator|=
name|valuePtr
operator|->
name|pv
operator|.
name|buffer
expr_stmt|;
name|shortfall
operator|=
name|length
operator|-
operator|(
name|valuePtr
operator|->
name|pv
operator|.
name|end
operator|-
name|valuePtr
operator|->
name|pv
operator|.
name|buffer
operator|)
expr_stmt|;
if|if
condition|(
name|shortfall
operator|>
literal|0
condition|)
block|{
call|(
modifier|*
name|valuePtr
operator|->
name|pv
operator|.
name|expandProc
call|)
argument_list|(
operator|&
name|valuePtr
operator|->
name|pv
argument_list|,
name|shortfall
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|valuePtr
operator|->
name|pv
operator|.
name|buffer
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * ExprLex --  *  *	Lexical analyzer for expression parser:  parses a single value,  *	operator, or other syntactic element from an expression string.  *  * Results:  *	TCL_OK is returned unless an error occurred while doing lexical  *	analysis or executing an embedded command.  In that case a  *	standard Tcl error is returned, using interp->result to hold  *	an error message.  In the event of a successful return, the token  *	and field in infoPtr is updated to refer to the next symbol in  *	the expression string, and the expr field is advanced past that  *	token;  if the token is a value, then the value is stored at  *	valuePtr.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ExprLex
parameter_list|(
name|interp
parameter_list|,
name|infoPtr
parameter_list|,
name|valuePtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for error 					 * reporting. */
specifier|register
name|ExprInfo
modifier|*
name|infoPtr
decl_stmt|;
comment|/* Describes the state of the parse. */
specifier|register
name|Value
modifier|*
name|valuePtr
decl_stmt|;
comment|/* Where to store value, if that is 					 * what's parsed from string.  Caller 					 * must have initialized pv field 					 * correctly. */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|var
decl_stmt|,
modifier|*
name|term
decl_stmt|;
name|int
name|result
decl_stmt|;
name|p
operator|=
name|infoPtr
operator|->
name|expr
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
name|infoPtr
operator|->
name|token
operator|=
name|END
expr_stmt|;
name|infoPtr
operator|->
name|expr
operator|=
name|p
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
comment|/*      * First try to parse the token as an integer or floating-point number.      * Don't want to check for a number if the first character is "+"      * or "-".  If we do, we might treat a binary operator as unary by      * mistake, which will eventually cause a syntax error.      */
if|if
condition|(
operator|(
operator|*
name|p
operator|!=
literal|'+'
operator|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|'-'
operator|)
condition|)
block|{
if|if
condition|(
name|ExprLooksLikeInt
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|valuePtr
operator|->
name|intValue
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|term
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ERANGE
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"integer value too large to represent"
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"ARITH"
argument_list|,
literal|"IOVERFLOW"
argument_list|,
name|interp
operator|->
name|result
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|infoPtr
operator|->
name|token
operator|=
name|VALUE
expr_stmt|;
name|infoPtr
operator|->
name|expr
operator|=
name|term
expr_stmt|;
name|valuePtr
operator|->
name|type
operator|=
name|TYPE_INT
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
else|else
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|valuePtr
operator|->
name|doubleValue
operator|=
name|strtod
argument_list|(
name|p
argument_list|,
operator|&
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
name|term
operator|!=
name|p
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|TclExprFloatError
argument_list|(
name|interp
argument_list|,
name|valuePtr
operator|->
name|doubleValue
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|infoPtr
operator|->
name|token
operator|=
name|VALUE
expr_stmt|;
name|infoPtr
operator|->
name|expr
operator|=
name|term
expr_stmt|;
name|valuePtr
operator|->
name|type
operator|=
name|TYPE_DOUBLE
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
block|}
block|}
name|infoPtr
operator|->
name|expr
operator|=
name|p
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'$'
case|:
comment|/* 	     * Variable.  Fetch its value, then see if it makes sense 	     * as an integer or floating-point number. 	     */
name|infoPtr
operator|->
name|token
operator|=
name|VALUE
expr_stmt|;
name|var
operator|=
name|Tcl_ParseVar
argument_list|(
name|interp
argument_list|,
name|p
argument_list|,
operator|&
name|infoPtr
operator|->
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|Interp
operator|*
operator|)
name|interp
operator|)
operator|->
name|noEval
condition|)
block|{
name|valuePtr
operator|->
name|type
operator|=
name|TYPE_INT
expr_stmt|;
name|valuePtr
operator|->
name|intValue
operator|=
literal|0
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
return|return
name|ExprParseString
argument_list|(
name|interp
argument_list|,
name|var
argument_list|,
name|valuePtr
argument_list|)
return|;
case|case
literal|'['
case|:
name|infoPtr
operator|->
name|token
operator|=
name|VALUE
expr_stmt|;
operator|(
operator|(
name|Interp
operator|*
operator|)
name|interp
operator|)
operator|->
name|evalFlags
operator|=
name|TCL_BRACKET_TERM
expr_stmt|;
name|result
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|infoPtr
operator|->
name|expr
operator|=
operator|(
operator|(
name|Interp
operator|*
operator|)
name|interp
operator|)
operator|->
name|termPtr
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
name|infoPtr
operator|->
name|expr
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|Interp
operator|*
operator|)
name|interp
operator|)
operator|->
name|noEval
condition|)
block|{
name|valuePtr
operator|->
name|type
operator|=
name|TYPE_INT
expr_stmt|;
name|valuePtr
operator|->
name|intValue
operator|=
literal|0
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
name|result
operator|=
name|ExprParseString
argument_list|(
name|interp
argument_list|,
name|interp
operator|->
name|result
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
case|case
literal|'"'
case|:
name|infoPtr
operator|->
name|token
operator|=
name|VALUE
expr_stmt|;
name|result
operator|=
name|TclParseQuotes
argument_list|(
name|interp
argument_list|,
name|infoPtr
operator|->
name|expr
argument_list|,
literal|'"'
argument_list|,
literal|0
argument_list|,
operator|&
name|infoPtr
operator|->
name|expr
argument_list|,
operator|&
name|valuePtr
operator|->
name|pv
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
return|return
name|ExprParseString
argument_list|(
name|interp
argument_list|,
name|valuePtr
operator|->
name|pv
operator|.
name|buffer
argument_list|,
name|valuePtr
argument_list|)
return|;
case|case
literal|'{'
case|:
name|infoPtr
operator|->
name|token
operator|=
name|VALUE
expr_stmt|;
name|result
operator|=
name|TclParseBraces
argument_list|(
name|interp
argument_list|,
name|infoPtr
operator|->
name|expr
argument_list|,
operator|&
name|infoPtr
operator|->
name|expr
argument_list|,
operator|&
name|valuePtr
operator|->
name|pv
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
return|return
name|ExprParseString
argument_list|(
name|interp
argument_list|,
name|valuePtr
operator|->
name|pv
operator|.
name|buffer
argument_list|,
name|valuePtr
argument_list|)
return|;
case|case
literal|'('
case|:
name|infoPtr
operator|->
name|token
operator|=
name|OPEN_PAREN
expr_stmt|;
return|return
name|TCL_OK
return|;
case|case
literal|')'
case|:
name|infoPtr
operator|->
name|token
operator|=
name|CLOSE_PAREN
expr_stmt|;
return|return
name|TCL_OK
return|;
case|case
literal|','
case|:
name|infoPtr
operator|->
name|token
operator|=
name|COMMA
expr_stmt|;
return|return
name|TCL_OK
return|;
case|case
literal|'*'
case|:
name|infoPtr
operator|->
name|token
operator|=
name|MULT
expr_stmt|;
return|return
name|TCL_OK
return|;
case|case
literal|'/'
case|:
name|infoPtr
operator|->
name|token
operator|=
name|DIVIDE
expr_stmt|;
return|return
name|TCL_OK
return|;
case|case
literal|'%'
case|:
name|infoPtr
operator|->
name|token
operator|=
name|MOD
expr_stmt|;
return|return
name|TCL_OK
return|;
case|case
literal|'+'
case|:
name|infoPtr
operator|->
name|token
operator|=
name|PLUS
expr_stmt|;
return|return
name|TCL_OK
return|;
case|case
literal|'-'
case|:
name|infoPtr
operator|->
name|token
operator|=
name|MINUS
expr_stmt|;
return|return
name|TCL_OK
return|;
case|case
literal|'?'
case|:
name|infoPtr
operator|->
name|token
operator|=
name|QUESTY
expr_stmt|;
return|return
name|TCL_OK
return|;
case|case
literal|':'
case|:
name|infoPtr
operator|->
name|token
operator|=
name|COLON
expr_stmt|;
return|return
name|TCL_OK
return|;
case|case
literal|'<'
case|:
switch|switch
condition|(
name|p
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'<'
case|:
name|infoPtr
operator|->
name|expr
operator|=
name|p
operator|+
literal|2
expr_stmt|;
name|infoPtr
operator|->
name|token
operator|=
name|LEFT_SHIFT
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|infoPtr
operator|->
name|expr
operator|=
name|p
operator|+
literal|2
expr_stmt|;
name|infoPtr
operator|->
name|token
operator|=
name|LEQ
expr_stmt|;
break|break;
default|default:
name|infoPtr
operator|->
name|token
operator|=
name|LESS
expr_stmt|;
break|break;
block|}
return|return
name|TCL_OK
return|;
case|case
literal|'>'
case|:
switch|switch
condition|(
name|p
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'>'
case|:
name|infoPtr
operator|->
name|expr
operator|=
name|p
operator|+
literal|2
expr_stmt|;
name|infoPtr
operator|->
name|token
operator|=
name|RIGHT_SHIFT
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|infoPtr
operator|->
name|expr
operator|=
name|p
operator|+
literal|2
expr_stmt|;
name|infoPtr
operator|->
name|token
operator|=
name|GEQ
expr_stmt|;
break|break;
default|default:
name|infoPtr
operator|->
name|token
operator|=
name|GREATER
expr_stmt|;
break|break;
block|}
return|return
name|TCL_OK
return|;
case|case
literal|'='
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
name|infoPtr
operator|->
name|expr
operator|=
name|p
operator|+
literal|2
expr_stmt|;
name|infoPtr
operator|->
name|token
operator|=
name|EQUAL
expr_stmt|;
block|}
else|else
block|{
name|infoPtr
operator|->
name|token
operator|=
name|UNKNOWN
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
case|case
literal|'!'
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
name|infoPtr
operator|->
name|expr
operator|=
name|p
operator|+
literal|2
expr_stmt|;
name|infoPtr
operator|->
name|token
operator|=
name|NEQ
expr_stmt|;
block|}
else|else
block|{
name|infoPtr
operator|->
name|token
operator|=
name|NOT
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
case|case
literal|'&'
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'&'
condition|)
block|{
name|infoPtr
operator|->
name|expr
operator|=
name|p
operator|+
literal|2
expr_stmt|;
name|infoPtr
operator|->
name|token
operator|=
name|AND
expr_stmt|;
block|}
else|else
block|{
name|infoPtr
operator|->
name|token
operator|=
name|BIT_AND
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
case|case
literal|'^'
case|:
name|infoPtr
operator|->
name|token
operator|=
name|BIT_XOR
expr_stmt|;
return|return
name|TCL_OK
return|;
case|case
literal|'|'
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'|'
condition|)
block|{
name|infoPtr
operator|->
name|expr
operator|=
name|p
operator|+
literal|2
expr_stmt|;
name|infoPtr
operator|->
name|token
operator|=
name|OR
expr_stmt|;
block|}
else|else
block|{
name|infoPtr
operator|->
name|token
operator|=
name|BIT_OR
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
case|case
literal|'~'
case|:
name|infoPtr
operator|->
name|token
operator|=
name|BIT_NOT
expr_stmt|;
return|return
name|TCL_OK
return|;
default|default:
if|if
condition|(
name|isalpha
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|infoPtr
operator|->
name|expr
operator|=
name|p
expr_stmt|;
return|return
name|ExprMathFunc
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|valuePtr
argument_list|)
return|;
block|}
name|infoPtr
operator|->
name|expr
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|infoPtr
operator|->
name|token
operator|=
name|UNKNOWN
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * ExprGetValue --  *  *	Parse a "value" from the remainder of the expression in infoPtr.  *  * Results:  *	Normally TCL_OK is returned.  The value of the expression is  *	returned in *valuePtr.  If an error occurred, then interp->result  *	contains an error message and TCL_ERROR is returned.  *	InfoPtr->token will be left pointing to the token AFTER the  *	expression, and infoPtr->expr will point to the character just  *	after the terminating token.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ExprGetValue
parameter_list|(
name|interp
parameter_list|,
name|infoPtr
parameter_list|,
name|prec
parameter_list|,
name|valuePtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for error 					 * reporting. */
specifier|register
name|ExprInfo
modifier|*
name|infoPtr
decl_stmt|;
comment|/* Describes the state of the parse 					 * just before the value (i.e. ExprLex 					 * will be called to get first token 					 * of value). */
name|int
name|prec
decl_stmt|;
comment|/* Treat any un-parenthesized operator 					 * with precedence<= this as the end 					 * of the expression. */
name|Value
modifier|*
name|valuePtr
decl_stmt|;
comment|/* Where to store the value of the 					 * expression.   Caller must have 					 * initialized pv field. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Value
name|value2
decl_stmt|;
comment|/* Second operand for current 					 * operator.  */
name|int
name|operator
decl_stmt|;
comment|/* Current operator (either unary 					 * or binary). */
name|int
name|badType
decl_stmt|;
comment|/* Type of offending argument;  used 					 * for error messages. */
name|int
name|gotOp
decl_stmt|;
comment|/* Non-zero means already lexed the 					 * operator (while picking up value 					 * for unary operator).  Don't lex 					 * again. */
name|int
name|result
decl_stmt|;
comment|/*      * There are two phases to this procedure.  First, pick off an initial      * value.  Then, parse (binary operator, value) pairs until done.      */
name|gotOp
operator|=
literal|0
expr_stmt|;
name|value2
operator|.
name|pv
operator|.
name|buffer
operator|=
name|value2
operator|.
name|pv
operator|.
name|next
operator|=
name|value2
operator|.
name|staticSpace
expr_stmt|;
name|value2
operator|.
name|pv
operator|.
name|end
operator|=
name|value2
operator|.
name|pv
operator|.
name|buffer
operator|+
name|STATIC_STRING_SPACE
operator|-
literal|1
expr_stmt|;
name|value2
operator|.
name|pv
operator|.
name|expandProc
operator|=
name|TclExpandParseValue
expr_stmt|;
name|value2
operator|.
name|pv
operator|.
name|clientData
operator|=
operator|(
name|ClientData
operator|)
name|NULL
expr_stmt|;
name|result
operator|=
name|ExprLex
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|infoPtr
operator|->
name|token
operator|==
name|OPEN_PAREN
condition|)
block|{
comment|/* 	 * Parenthesized sub-expression. 	 */
name|result
operator|=
name|ExprGetValue
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
operator|-
literal|1
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|infoPtr
operator|->
name|token
operator|!=
name|CLOSE_PAREN
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"unmatched parentheses in expression \""
argument_list|,
name|infoPtr
operator|->
name|originalExpr
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|infoPtr
operator|->
name|token
operator|==
name|MINUS
condition|)
block|{
name|infoPtr
operator|->
name|token
operator|=
name|UNARY_MINUS
expr_stmt|;
block|}
if|if
condition|(
name|infoPtr
operator|->
name|token
operator|==
name|PLUS
condition|)
block|{
name|infoPtr
operator|->
name|token
operator|=
name|UNARY_PLUS
expr_stmt|;
block|}
if|if
condition|(
name|infoPtr
operator|->
name|token
operator|>=
name|UNARY_MINUS
condition|)
block|{
comment|/* 	     * Process unary operators. 	     */
name|operator
operator|=
name|infoPtr
operator|->
name|token
expr_stmt|;
name|result
operator|=
name|ExprGetValue
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|precTable
index|[
name|infoPtr
operator|->
name|token
index|]
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|!
name|iPtr
operator|->
name|noEval
condition|)
block|{
switch|switch
condition|(
name|operator
condition|)
block|{
case|case
name|UNARY_MINUS
case|:
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_INT
condition|)
block|{
name|valuePtr
operator|->
name|intValue
operator|=
operator|-
name|valuePtr
operator|->
name|intValue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_DOUBLE
condition|)
block|{
name|valuePtr
operator|->
name|doubleValue
operator|=
operator|-
name|valuePtr
operator|->
name|doubleValue
expr_stmt|;
block|}
else|else
block|{
name|badType
operator|=
name|valuePtr
operator|->
name|type
expr_stmt|;
goto|goto
name|illegalType
goto|;
block|}
break|break;
case|case
name|UNARY_PLUS
case|:
if|if
condition|(
operator|(
name|valuePtr
operator|->
name|type
operator|!=
name|TYPE_INT
operator|)
operator|&&
operator|(
name|valuePtr
operator|->
name|type
operator|!=
name|TYPE_DOUBLE
operator|)
condition|)
block|{
name|badType
operator|=
name|valuePtr
operator|->
name|type
expr_stmt|;
goto|goto
name|illegalType
goto|;
block|}
break|break;
case|case
name|NOT
case|:
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_INT
condition|)
block|{
name|valuePtr
operator|->
name|intValue
operator|=
operator|!
name|valuePtr
operator|->
name|intValue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_DOUBLE
condition|)
block|{
comment|/* 			     * Theoretically, should be able to use 			     * "!valuePtr->intValue", but apparently some 			     * compilers can't handle it. 			     */
if|if
condition|(
name|valuePtr
operator|->
name|doubleValue
operator|==
literal|0.0
condition|)
block|{
name|valuePtr
operator|->
name|intValue
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|valuePtr
operator|->
name|intValue
operator|=
literal|0
expr_stmt|;
block|}
name|valuePtr
operator|->
name|type
operator|=
name|TYPE_INT
expr_stmt|;
block|}
else|else
block|{
name|badType
operator|=
name|valuePtr
operator|->
name|type
expr_stmt|;
goto|goto
name|illegalType
goto|;
block|}
break|break;
case|case
name|BIT_NOT
case|:
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_INT
condition|)
block|{
name|valuePtr
operator|->
name|intValue
operator|=
operator|~
name|valuePtr
operator|->
name|intValue
expr_stmt|;
block|}
else|else
block|{
name|badType
operator|=
name|valuePtr
operator|->
name|type
expr_stmt|;
goto|goto
name|illegalType
goto|;
block|}
break|break;
block|}
block|}
name|gotOp
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|infoPtr
operator|->
name|token
operator|!=
name|VALUE
condition|)
block|{
goto|goto
name|syntaxError
goto|;
block|}
block|}
comment|/*      * Got the first operand.  Now fetch (operator, operand) pairs.      */
if|if
condition|(
operator|!
name|gotOp
condition|)
block|{
name|result
operator|=
name|ExprLex
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
operator|&
name|value2
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|operator
operator|=
name|infoPtr
operator|->
name|token
expr_stmt|;
name|value2
operator|.
name|pv
operator|.
name|next
operator|=
name|value2
operator|.
name|pv
operator|.
name|buffer
expr_stmt|;
if|if
condition|(
operator|(
name|operator
operator|<
name|MULT
operator|)
operator|||
operator|(
name|operator
operator|>=
name|UNARY_MINUS
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|operator
operator|==
name|END
operator|)
operator|||
operator|(
name|operator
operator|==
name|CLOSE_PAREN
operator|)
operator|||
operator|(
name|operator
operator|==
name|COMMA
operator|)
condition|)
block|{
name|result
operator|=
name|TCL_OK
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
block|{
goto|goto
name|syntaxError
goto|;
block|}
block|}
if|if
condition|(
name|precTable
index|[
name|operator
index|]
operator|<=
name|prec
condition|)
block|{
name|result
operator|=
name|TCL_OK
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * If we're doing an AND or OR and the first operand already 	 * determines the result, don't execute anything in the 	 * second operand:  just parse.  Same style for ?: pairs. 	 */
if|if
condition|(
operator|(
name|operator
operator|==
name|AND
operator|)
operator|||
operator|(
name|operator
operator|==
name|OR
operator|)
operator|||
operator|(
name|operator
operator|==
name|QUESTY
operator|)
condition|)
block|{
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_DOUBLE
condition|)
block|{
name|valuePtr
operator|->
name|intValue
operator|=
name|valuePtr
operator|->
name|doubleValue
operator|!=
literal|0
expr_stmt|;
name|valuePtr
operator|->
name|type
operator|=
name|TYPE_INT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_STRING
condition|)
block|{
if|if
condition|(
operator|!
name|iPtr
operator|->
name|noEval
condition|)
block|{
name|badType
operator|=
name|TYPE_STRING
expr_stmt|;
goto|goto
name|illegalType
goto|;
block|}
comment|/* 		 * Must set valuePtr->intValue to avoid referencing 		 * uninitialized memory in the "if" below;  the atual 		 * value doesn't matter, since it will be ignored. 		 */
name|valuePtr
operator|->
name|intValue
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|operator
operator|==
name|AND
operator|)
operator|&&
operator|!
name|valuePtr
operator|->
name|intValue
operator|)
operator|||
operator|(
operator|(
name|operator
operator|==
name|OR
operator|)
operator|&&
name|valuePtr
operator|->
name|intValue
operator|)
condition|)
block|{
name|iPtr
operator|->
name|noEval
operator|++
expr_stmt|;
name|result
operator|=
name|ExprGetValue
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|precTable
index|[
name|operator
index|]
argument_list|,
operator|&
name|value2
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|noEval
operator|--
expr_stmt|;
if|if
condition|(
name|operator
operator|==
name|OR
condition|)
block|{
name|valuePtr
operator|->
name|intValue
operator|=
literal|1
expr_stmt|;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
name|operator
operator|==
name|QUESTY
condition|)
block|{
comment|/* 		 * Special note:  ?: operators must associate right to 		 * left.  To make this happen, use a precedence one lower 		 * than QUESTY when calling ExprGetValue recursively. 		 */
if|if
condition|(
name|valuePtr
operator|->
name|intValue
operator|!=
literal|0
condition|)
block|{
name|valuePtr
operator|->
name|pv
operator|.
name|next
operator|=
name|valuePtr
operator|->
name|pv
operator|.
name|buffer
expr_stmt|;
name|result
operator|=
name|ExprGetValue
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|precTable
index|[
name|QUESTY
index|]
operator|-
literal|1
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|infoPtr
operator|->
name|token
operator|!=
name|COLON
condition|)
block|{
goto|goto
name|syntaxError
goto|;
block|}
name|value2
operator|.
name|pv
operator|.
name|next
operator|=
name|value2
operator|.
name|pv
operator|.
name|buffer
expr_stmt|;
name|iPtr
operator|->
name|noEval
operator|++
expr_stmt|;
name|result
operator|=
name|ExprGetValue
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|precTable
index|[
name|QUESTY
index|]
operator|-
literal|1
argument_list|,
operator|&
name|value2
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|noEval
operator|--
expr_stmt|;
block|}
else|else
block|{
name|iPtr
operator|->
name|noEval
operator|++
expr_stmt|;
name|result
operator|=
name|ExprGetValue
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|precTable
index|[
name|QUESTY
index|]
operator|-
literal|1
argument_list|,
operator|&
name|value2
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|noEval
operator|--
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|infoPtr
operator|->
name|token
operator|!=
name|COLON
condition|)
block|{
goto|goto
name|syntaxError
goto|;
block|}
name|valuePtr
operator|->
name|pv
operator|.
name|next
operator|=
name|valuePtr
operator|->
name|pv
operator|.
name|buffer
expr_stmt|;
name|result
operator|=
name|ExprGetValue
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|precTable
index|[
name|QUESTY
index|]
operator|-
literal|1
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
else|else
block|{
name|result
operator|=
name|ExprGetValue
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|precTable
index|[
name|operator
index|]
argument_list|,
operator|&
name|value2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|result
operator|=
name|ExprGetValue
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|precTable
index|[
name|operator
index|]
argument_list|,
operator|&
name|value2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|infoPtr
operator|->
name|token
operator|<
name|MULT
operator|)
operator|&&
operator|(
name|infoPtr
operator|->
name|token
operator|!=
name|VALUE
operator|)
operator|&&
operator|(
name|infoPtr
operator|->
name|token
operator|!=
name|END
operator|)
operator|&&
operator|(
name|infoPtr
operator|->
name|token
operator|!=
name|COMMA
operator|)
operator|&&
operator|(
name|infoPtr
operator|->
name|token
operator|!=
name|CLOSE_PAREN
operator|)
condition|)
block|{
goto|goto
name|syntaxError
goto|;
block|}
if|if
condition|(
name|iPtr
operator|->
name|noEval
condition|)
block|{
continue|continue;
block|}
comment|/* 	 * At this point we've got two values and an operator.  Check 	 * to make sure that the particular data types are appropriate 	 * for the particular operator, and perform type conversion 	 * if necessary. 	 */
switch|switch
condition|(
name|operator
condition|)
block|{
comment|/* 	     * For the operators below, no strings are allowed and 	     * ints get converted to floats if necessary. 	     */
case|case
name|MULT
case|:
case|case
name|DIVIDE
case|:
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
if|if
condition|(
operator|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_STRING
operator|)
operator|||
operator|(
name|value2
operator|.
name|type
operator|==
name|TYPE_STRING
operator|)
condition|)
block|{
name|badType
operator|=
name|TYPE_STRING
expr_stmt|;
goto|goto
name|illegalType
goto|;
block|}
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_DOUBLE
condition|)
block|{
if|if
condition|(
name|value2
operator|.
name|type
operator|==
name|TYPE_INT
condition|)
block|{
name|value2
operator|.
name|doubleValue
operator|=
name|value2
operator|.
name|intValue
expr_stmt|;
name|value2
operator|.
name|type
operator|=
name|TYPE_DOUBLE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|value2
operator|.
name|type
operator|==
name|TYPE_DOUBLE
condition|)
block|{
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_INT
condition|)
block|{
name|valuePtr
operator|->
name|doubleValue
operator|=
name|valuePtr
operator|->
name|intValue
expr_stmt|;
name|valuePtr
operator|->
name|type
operator|=
name|TYPE_DOUBLE
expr_stmt|;
block|}
block|}
break|break;
comment|/* 	     * For the operators below, only integers are allowed. 	     */
case|case
name|MOD
case|:
case|case
name|LEFT_SHIFT
case|:
case|case
name|RIGHT_SHIFT
case|:
case|case
name|BIT_AND
case|:
case|case
name|BIT_XOR
case|:
case|case
name|BIT_OR
case|:
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|!=
name|TYPE_INT
condition|)
block|{
name|badType
operator|=
name|valuePtr
operator|->
name|type
expr_stmt|;
goto|goto
name|illegalType
goto|;
block|}
elseif|else
if|if
condition|(
name|value2
operator|.
name|type
operator|!=
name|TYPE_INT
condition|)
block|{
name|badType
operator|=
name|value2
operator|.
name|type
expr_stmt|;
goto|goto
name|illegalType
goto|;
block|}
break|break;
comment|/* 	     * For the operators below, any type is allowed but the 	     * two operands must have the same type.  Convert integers 	     * to floats and either to strings, if necessary. 	     */
case|case
name|LESS
case|:
case|case
name|GREATER
case|:
case|case
name|LEQ
case|:
case|case
name|GEQ
case|:
case|case
name|EQUAL
case|:
case|case
name|NEQ
case|:
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_STRING
condition|)
block|{
if|if
condition|(
name|value2
operator|.
name|type
operator|!=
name|TYPE_STRING
condition|)
block|{
name|ExprMakeString
argument_list|(
name|interp
argument_list|,
operator|&
name|value2
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|value2
operator|.
name|type
operator|==
name|TYPE_STRING
condition|)
block|{
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|!=
name|TYPE_STRING
condition|)
block|{
name|ExprMakeString
argument_list|(
name|interp
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_DOUBLE
condition|)
block|{
if|if
condition|(
name|value2
operator|.
name|type
operator|==
name|TYPE_INT
condition|)
block|{
name|value2
operator|.
name|doubleValue
operator|=
name|value2
operator|.
name|intValue
expr_stmt|;
name|value2
operator|.
name|type
operator|=
name|TYPE_DOUBLE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|value2
operator|.
name|type
operator|==
name|TYPE_DOUBLE
condition|)
block|{
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_INT
condition|)
block|{
name|valuePtr
operator|->
name|doubleValue
operator|=
name|valuePtr
operator|->
name|intValue
expr_stmt|;
name|valuePtr
operator|->
name|type
operator|=
name|TYPE_DOUBLE
expr_stmt|;
block|}
block|}
break|break;
comment|/* 	     * For the operators below, no strings are allowed, but 	     * no int->double conversions are performed. 	     */
case|case
name|AND
case|:
case|case
name|OR
case|:
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_STRING
condition|)
block|{
name|badType
operator|=
name|valuePtr
operator|->
name|type
expr_stmt|;
goto|goto
name|illegalType
goto|;
block|}
if|if
condition|(
name|value2
operator|.
name|type
operator|==
name|TYPE_STRING
condition|)
block|{
name|badType
operator|=
name|value2
operator|.
name|type
expr_stmt|;
goto|goto
name|illegalType
goto|;
block|}
break|break;
comment|/* 	     * For the operators below, type and conversions are 	     * irrelevant:  they're handled elsewhere. 	     */
case|case
name|QUESTY
case|:
case|case
name|COLON
case|:
break|break;
comment|/* 	     * Any other operator is an error. 	     */
default|default:
name|interp
operator|->
name|result
operator|=
literal|"unknown operator in expression"
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Carry out the function of the specified operator. 	 */
switch|switch
condition|(
name|operator
condition|)
block|{
case|case
name|MULT
case|:
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_INT
condition|)
block|{
name|valuePtr
operator|->
name|intValue
operator|=
name|valuePtr
operator|->
name|intValue
operator|*
name|value2
operator|.
name|intValue
expr_stmt|;
block|}
else|else
block|{
name|valuePtr
operator|->
name|doubleValue
operator|*=
name|value2
operator|.
name|doubleValue
expr_stmt|;
block|}
break|break;
case|case
name|DIVIDE
case|:
case|case
name|MOD
case|:
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_INT
condition|)
block|{
name|long
name|divisor
decl_stmt|,
name|quot
decl_stmt|,
name|rem
decl_stmt|;
name|int
name|negative
decl_stmt|;
if|if
condition|(
name|value2
operator|.
name|intValue
operator|==
literal|0
condition|)
block|{
name|divideByZero
label|:
name|interp
operator|->
name|result
operator|=
literal|"divide by zero"
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"ARITH"
argument_list|,
literal|"DIVZERO"
argument_list|,
name|interp
operator|->
name|result
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 		     * The code below is tricky because C doesn't guarantee 		     * much about the properties of the quotient or 		     * remainder, but Tcl does:  the remainder always has 		     * the same sign as the divisor and a smaller absolute 		     * value. 		     */
name|divisor
operator|=
name|value2
operator|.
name|intValue
expr_stmt|;
name|negative
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|divisor
operator|<
literal|0
condition|)
block|{
name|divisor
operator|=
operator|-
name|divisor
expr_stmt|;
name|valuePtr
operator|->
name|intValue
operator|=
operator|-
name|valuePtr
operator|->
name|intValue
expr_stmt|;
name|negative
operator|=
literal|1
expr_stmt|;
block|}
name|quot
operator|=
name|valuePtr
operator|->
name|intValue
operator|/
name|divisor
expr_stmt|;
name|rem
operator|=
name|valuePtr
operator|->
name|intValue
operator|%
name|divisor
expr_stmt|;
if|if
condition|(
name|rem
operator|<
literal|0
condition|)
block|{
name|rem
operator|+=
name|divisor
expr_stmt|;
name|quot
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|negative
condition|)
block|{
name|rem
operator|=
operator|-
name|rem
expr_stmt|;
block|}
name|valuePtr
operator|->
name|intValue
operator|=
operator|(
name|operator
operator|==
name|DIVIDE
operator|)
condition|?
name|quot
else|:
name|rem
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|value2
operator|.
name|doubleValue
operator|==
literal|0.0
condition|)
block|{
goto|goto
name|divideByZero
goto|;
block|}
name|valuePtr
operator|->
name|doubleValue
operator|/=
name|value2
operator|.
name|doubleValue
expr_stmt|;
block|}
break|break;
case|case
name|PLUS
case|:
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_INT
condition|)
block|{
name|valuePtr
operator|->
name|intValue
operator|=
name|valuePtr
operator|->
name|intValue
operator|+
name|value2
operator|.
name|intValue
expr_stmt|;
block|}
else|else
block|{
name|valuePtr
operator|->
name|doubleValue
operator|+=
name|value2
operator|.
name|doubleValue
expr_stmt|;
block|}
break|break;
case|case
name|MINUS
case|:
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_INT
condition|)
block|{
name|valuePtr
operator|->
name|intValue
operator|=
name|valuePtr
operator|->
name|intValue
operator|-
name|value2
operator|.
name|intValue
expr_stmt|;
block|}
else|else
block|{
name|valuePtr
operator|->
name|doubleValue
operator|-=
name|value2
operator|.
name|doubleValue
expr_stmt|;
block|}
break|break;
case|case
name|LEFT_SHIFT
case|:
name|valuePtr
operator|->
name|intValue
operator|<<=
name|value2
operator|.
name|intValue
expr_stmt|;
break|break;
case|case
name|RIGHT_SHIFT
case|:
comment|/* 		 * The following code is a bit tricky:  it ensures that 		 * right shifts propagate the sign bit even on machines 		 * where ">>" won't do it by default. 		 */
if|if
condition|(
name|valuePtr
operator|->
name|intValue
operator|<
literal|0
condition|)
block|{
name|valuePtr
operator|->
name|intValue
operator|=
operator|~
operator|(
operator|(
operator|~
name|valuePtr
operator|->
name|intValue
operator|)
operator|>>
name|value2
operator|.
name|intValue
operator|)
expr_stmt|;
block|}
else|else
block|{
name|valuePtr
operator|->
name|intValue
operator|>>=
name|value2
operator|.
name|intValue
expr_stmt|;
block|}
break|break;
case|case
name|LESS
case|:
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_INT
condition|)
block|{
name|valuePtr
operator|->
name|intValue
operator|=
name|valuePtr
operator|->
name|intValue
operator|<
name|value2
operator|.
name|intValue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_DOUBLE
condition|)
block|{
name|valuePtr
operator|->
name|intValue
operator|=
name|valuePtr
operator|->
name|doubleValue
operator|<
name|value2
operator|.
name|doubleValue
expr_stmt|;
block|}
else|else
block|{
name|valuePtr
operator|->
name|intValue
operator|=
name|strcmp
argument_list|(
name|valuePtr
operator|->
name|pv
operator|.
name|buffer
argument_list|,
name|value2
operator|.
name|pv
operator|.
name|buffer
argument_list|)
operator|<
literal|0
expr_stmt|;
block|}
name|valuePtr
operator|->
name|type
operator|=
name|TYPE_INT
expr_stmt|;
break|break;
case|case
name|GREATER
case|:
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_INT
condition|)
block|{
name|valuePtr
operator|->
name|intValue
operator|=
name|valuePtr
operator|->
name|intValue
operator|>
name|value2
operator|.
name|intValue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_DOUBLE
condition|)
block|{
name|valuePtr
operator|->
name|intValue
operator|=
name|valuePtr
operator|->
name|doubleValue
operator|>
name|value2
operator|.
name|doubleValue
expr_stmt|;
block|}
else|else
block|{
name|valuePtr
operator|->
name|intValue
operator|=
name|strcmp
argument_list|(
name|valuePtr
operator|->
name|pv
operator|.
name|buffer
argument_list|,
name|value2
operator|.
name|pv
operator|.
name|buffer
argument_list|)
operator|>
literal|0
expr_stmt|;
block|}
name|valuePtr
operator|->
name|type
operator|=
name|TYPE_INT
expr_stmt|;
break|break;
case|case
name|LEQ
case|:
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_INT
condition|)
block|{
name|valuePtr
operator|->
name|intValue
operator|=
name|valuePtr
operator|->
name|intValue
operator|<=
name|value2
operator|.
name|intValue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_DOUBLE
condition|)
block|{
name|valuePtr
operator|->
name|intValue
operator|=
name|valuePtr
operator|->
name|doubleValue
operator|<=
name|value2
operator|.
name|doubleValue
expr_stmt|;
block|}
else|else
block|{
name|valuePtr
operator|->
name|intValue
operator|=
name|strcmp
argument_list|(
name|valuePtr
operator|->
name|pv
operator|.
name|buffer
argument_list|,
name|value2
operator|.
name|pv
operator|.
name|buffer
argument_list|)
operator|<=
literal|0
expr_stmt|;
block|}
name|valuePtr
operator|->
name|type
operator|=
name|TYPE_INT
expr_stmt|;
break|break;
case|case
name|GEQ
case|:
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_INT
condition|)
block|{
name|valuePtr
operator|->
name|intValue
operator|=
name|valuePtr
operator|->
name|intValue
operator|>=
name|value2
operator|.
name|intValue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_DOUBLE
condition|)
block|{
name|valuePtr
operator|->
name|intValue
operator|=
name|valuePtr
operator|->
name|doubleValue
operator|>=
name|value2
operator|.
name|doubleValue
expr_stmt|;
block|}
else|else
block|{
name|valuePtr
operator|->
name|intValue
operator|=
name|strcmp
argument_list|(
name|valuePtr
operator|->
name|pv
operator|.
name|buffer
argument_list|,
name|value2
operator|.
name|pv
operator|.
name|buffer
argument_list|)
operator|>=
literal|0
expr_stmt|;
block|}
name|valuePtr
operator|->
name|type
operator|=
name|TYPE_INT
expr_stmt|;
break|break;
case|case
name|EQUAL
case|:
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_INT
condition|)
block|{
name|valuePtr
operator|->
name|intValue
operator|=
name|valuePtr
operator|->
name|intValue
operator|==
name|value2
operator|.
name|intValue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_DOUBLE
condition|)
block|{
name|valuePtr
operator|->
name|intValue
operator|=
name|valuePtr
operator|->
name|doubleValue
operator|==
name|value2
operator|.
name|doubleValue
expr_stmt|;
block|}
else|else
block|{
name|valuePtr
operator|->
name|intValue
operator|=
name|strcmp
argument_list|(
name|valuePtr
operator|->
name|pv
operator|.
name|buffer
argument_list|,
name|value2
operator|.
name|pv
operator|.
name|buffer
argument_list|)
operator|==
literal|0
expr_stmt|;
block|}
name|valuePtr
operator|->
name|type
operator|=
name|TYPE_INT
expr_stmt|;
break|break;
case|case
name|NEQ
case|:
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_INT
condition|)
block|{
name|valuePtr
operator|->
name|intValue
operator|=
name|valuePtr
operator|->
name|intValue
operator|!=
name|value2
operator|.
name|intValue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_DOUBLE
condition|)
block|{
name|valuePtr
operator|->
name|intValue
operator|=
name|valuePtr
operator|->
name|doubleValue
operator|!=
name|value2
operator|.
name|doubleValue
expr_stmt|;
block|}
else|else
block|{
name|valuePtr
operator|->
name|intValue
operator|=
name|strcmp
argument_list|(
name|valuePtr
operator|->
name|pv
operator|.
name|buffer
argument_list|,
name|value2
operator|.
name|pv
operator|.
name|buffer
argument_list|)
operator|!=
literal|0
expr_stmt|;
block|}
name|valuePtr
operator|->
name|type
operator|=
name|TYPE_INT
expr_stmt|;
break|break;
case|case
name|BIT_AND
case|:
name|valuePtr
operator|->
name|intValue
operator|&=
name|value2
operator|.
name|intValue
expr_stmt|;
break|break;
case|case
name|BIT_XOR
case|:
name|valuePtr
operator|->
name|intValue
operator|^=
name|value2
operator|.
name|intValue
expr_stmt|;
break|break;
case|case
name|BIT_OR
case|:
name|valuePtr
operator|->
name|intValue
operator||=
name|value2
operator|.
name|intValue
expr_stmt|;
break|break;
comment|/* 	     * For AND and OR, we know that the first value has already 	     * been converted to an integer.  Thus we need only consider 	     * the possibility of int vs. double for the second value. 	     */
case|case
name|AND
case|:
if|if
condition|(
name|value2
operator|.
name|type
operator|==
name|TYPE_DOUBLE
condition|)
block|{
name|value2
operator|.
name|intValue
operator|=
name|value2
operator|.
name|doubleValue
operator|!=
literal|0
expr_stmt|;
name|value2
operator|.
name|type
operator|=
name|TYPE_INT
expr_stmt|;
block|}
name|valuePtr
operator|->
name|intValue
operator|=
name|valuePtr
operator|->
name|intValue
operator|&&
name|value2
operator|.
name|intValue
expr_stmt|;
break|break;
case|case
name|OR
case|:
if|if
condition|(
name|value2
operator|.
name|type
operator|==
name|TYPE_DOUBLE
condition|)
block|{
name|value2
operator|.
name|intValue
operator|=
name|value2
operator|.
name|doubleValue
operator|!=
literal|0
expr_stmt|;
name|value2
operator|.
name|type
operator|=
name|TYPE_INT
expr_stmt|;
block|}
name|valuePtr
operator|->
name|intValue
operator|=
name|valuePtr
operator|->
name|intValue
operator|||
name|value2
operator|.
name|intValue
expr_stmt|;
break|break;
case|case
name|COLON
case|:
name|interp
operator|->
name|result
operator|=
literal|"can't have : operator without ? first"
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
if|if
condition|(
name|value2
operator|.
name|pv
operator|.
name|buffer
operator|!=
name|value2
operator|.
name|staticSpace
condition|)
block|{
name|ckfree
argument_list|(
name|value2
operator|.
name|pv
operator|.
name|buffer
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
name|syntaxError
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"syntax error in expression \""
argument_list|,
name|infoPtr
operator|->
name|originalExpr
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
name|illegalType
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"can't use "
argument_list|,
operator|(
name|badType
operator|==
name|TYPE_DOUBLE
operator|)
condition|?
literal|"floating-point value"
else|:
literal|"non-numeric string"
argument_list|,
literal|" as operand of \""
argument_list|,
name|operatorStrings
index|[
name|operator
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * ExprMakeString --  *  *	Convert a value from int or double representation to  *	a string.  *  * Results:  *	The information at *valuePtr gets converted to string  *	format, if it wasn't that way already.  *  * Side effects:  *	None.  *  *--------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ExprMakeString
parameter_list|(
name|interp
parameter_list|,
name|valuePtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for precision 					 * information. */
specifier|register
name|Value
modifier|*
name|valuePtr
decl_stmt|;
comment|/* Value to be converted. */
block|{
name|int
name|shortfall
decl_stmt|;
name|shortfall
operator|=
literal|150
operator|-
operator|(
name|valuePtr
operator|->
name|pv
operator|.
name|end
operator|-
name|valuePtr
operator|->
name|pv
operator|.
name|buffer
operator|)
expr_stmt|;
if|if
condition|(
name|shortfall
operator|>
literal|0
condition|)
block|{
call|(
modifier|*
name|valuePtr
operator|->
name|pv
operator|.
name|expandProc
call|)
argument_list|(
operator|&
name|valuePtr
operator|->
name|pv
argument_list|,
name|shortfall
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_INT
condition|)
block|{
name|sprintf
argument_list|(
name|valuePtr
operator|->
name|pv
operator|.
name|buffer
argument_list|,
literal|"%ld"
argument_list|,
name|valuePtr
operator|->
name|intValue
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_DOUBLE
condition|)
block|{
name|Tcl_PrintDouble
argument_list|(
name|interp
argument_list|,
name|valuePtr
operator|->
name|doubleValue
argument_list|,
name|valuePtr
operator|->
name|pv
operator|.
name|buffer
argument_list|)
expr_stmt|;
block|}
name|valuePtr
operator|->
name|type
operator|=
name|TYPE_STRING
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * ExprTopLevel --  *  *	This procedure provides top-level functionality shared by  *	procedures like Tcl_ExprInt, Tcl_ExprDouble, etc.  *  * Results:  *	The result is a standard Tcl return value.  If an error  *	occurs then an error message is left in interp->result.  *	The value of the expression is returned in *valuePtr, in  *	whatever form it ends up in (could be string or integer  *	or double).  Caller may need to convert result.  Caller  *	is also responsible for freeing string memory in *valuePtr,  *	if any was allocated.  *  * Side effects:  *	None.  *  *--------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ExprTopLevel
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|valuePtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Context in which to evaluate the 					 * expression. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Expression to evaluate. */
name|Value
modifier|*
name|valuePtr
decl_stmt|;
comment|/* Where to store result.  Should 					 * not be initialized by caller. */
block|{
name|ExprInfo
name|info
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/*      * Create the math functions the first time an expression is      * evaluated.      */
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
name|Interp
operator|*
operator|)
name|interp
operator|)
operator|->
name|flags
operator|&
name|EXPR_INITIALIZED
operator|)
condition|)
block|{
name|BuiltinFunc
modifier|*
name|funcPtr
decl_stmt|;
operator|(
operator|(
name|Interp
operator|*
operator|)
name|interp
operator|)
operator|->
name|flags
operator||=
name|EXPR_INITIALIZED
expr_stmt|;
for|for
control|(
name|funcPtr
operator|=
name|funcTable
init|;
name|funcPtr
operator|->
name|name
operator|!=
name|NULL
condition|;
name|funcPtr
operator|++
control|)
block|{
name|Tcl_CreateMathFunc
argument_list|(
name|interp
argument_list|,
name|funcPtr
operator|->
name|name
argument_list|,
name|funcPtr
operator|->
name|numArgs
argument_list|,
name|funcPtr
operator|->
name|argTypes
argument_list|,
name|funcPtr
operator|->
name|proc
argument_list|,
name|funcPtr
operator|->
name|clientData
argument_list|)
expr_stmt|;
block|}
block|}
name|info
operator|.
name|originalExpr
operator|=
name|string
expr_stmt|;
name|info
operator|.
name|expr
operator|=
name|string
expr_stmt|;
name|valuePtr
operator|->
name|pv
operator|.
name|buffer
operator|=
name|valuePtr
operator|->
name|pv
operator|.
name|next
operator|=
name|valuePtr
operator|->
name|staticSpace
expr_stmt|;
name|valuePtr
operator|->
name|pv
operator|.
name|end
operator|=
name|valuePtr
operator|->
name|pv
operator|.
name|buffer
operator|+
name|STATIC_STRING_SPACE
operator|-
literal|1
expr_stmt|;
name|valuePtr
operator|->
name|pv
operator|.
name|expandProc
operator|=
name|TclExpandParseValue
expr_stmt|;
name|valuePtr
operator|->
name|pv
operator|.
name|clientData
operator|=
operator|(
name|ClientData
operator|)
name|NULL
expr_stmt|;
name|result
operator|=
name|ExprGetValue
argument_list|(
name|interp
argument_list|,
operator|&
name|info
argument_list|,
operator|-
literal|1
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
if|if
condition|(
name|info
operator|.
name|token
operator|!=
name|END
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"syntax error in expression \""
argument_list|,
name|string
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_DOUBLE
operator|)
operator|&&
operator|(
name|IS_NAN
argument_list|(
name|valuePtr
operator|->
name|doubleValue
argument_list|)
operator|||
name|IS_INF
argument_list|(
name|valuePtr
operator|->
name|doubleValue
argument_list|)
operator|)
condition|)
block|{
comment|/* 	 * IEEE floating-point error. 	 */
name|TclExprFloatError
argument_list|(
name|interp
argument_list|,
name|valuePtr
operator|->
name|doubleValue
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * Tcl_ExprLong, Tcl_ExprDouble, Tcl_ExprBoolean --  *  *	Procedures to evaluate an expression and return its value  *	in a particular form.  *  * Results:  *	Each of the procedures below returns a standard Tcl result.  *	If an error occurs then an error message is left in  *	interp->result.  Otherwise the value of the expression,  *	in the appropriate form, is stored at *resultPtr.  If  *	the expression had a result that was incompatible with the  *	desired form then an error is returned.  *  * Side effects:  *	None.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_ExprLong
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|ptr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Context in which to evaluate the 					 * expression. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Expression to evaluate. */
name|long
modifier|*
name|ptr
decl_stmt|;
comment|/* Where to store result. */
block|{
name|Value
name|value
decl_stmt|;
name|int
name|result
decl_stmt|;
name|result
operator|=
name|ExprTopLevel
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|value
operator|.
name|type
operator|==
name|TYPE_INT
condition|)
block|{
operator|*
name|ptr
operator|=
name|value
operator|.
name|intValue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|.
name|type
operator|==
name|TYPE_DOUBLE
condition|)
block|{
operator|*
name|ptr
operator|=
operator|(
name|long
operator|)
name|value
operator|.
name|doubleValue
expr_stmt|;
block|}
else|else
block|{
name|interp
operator|->
name|result
operator|=
literal|"expression didn't have numeric value"
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|value
operator|.
name|pv
operator|.
name|buffer
operator|!=
name|value
operator|.
name|staticSpace
condition|)
block|{
name|ckfree
argument_list|(
name|value
operator|.
name|pv
operator|.
name|buffer
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|Tcl_ExprDouble
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|ptr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Context in which to evaluate the 					 * expression. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Expression to evaluate. */
name|double
modifier|*
name|ptr
decl_stmt|;
comment|/* Where to store result. */
block|{
name|Value
name|value
decl_stmt|;
name|int
name|result
decl_stmt|;
name|result
operator|=
name|ExprTopLevel
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|value
operator|.
name|type
operator|==
name|TYPE_INT
condition|)
block|{
operator|*
name|ptr
operator|=
name|value
operator|.
name|intValue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|.
name|type
operator|==
name|TYPE_DOUBLE
condition|)
block|{
operator|*
name|ptr
operator|=
name|value
operator|.
name|doubleValue
expr_stmt|;
block|}
else|else
block|{
name|interp
operator|->
name|result
operator|=
literal|"expression didn't have numeric value"
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|value
operator|.
name|pv
operator|.
name|buffer
operator|!=
name|value
operator|.
name|staticSpace
condition|)
block|{
name|ckfree
argument_list|(
name|value
operator|.
name|pv
operator|.
name|buffer
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|Tcl_ExprBoolean
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|ptr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Context in which to evaluate the 					 * expression. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Expression to evaluate. */
name|int
modifier|*
name|ptr
decl_stmt|;
comment|/* Where to store 0/1 result. */
block|{
name|Value
name|value
decl_stmt|;
name|int
name|result
decl_stmt|;
name|result
operator|=
name|ExprTopLevel
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|value
operator|.
name|type
operator|==
name|TYPE_INT
condition|)
block|{
operator|*
name|ptr
operator|=
name|value
operator|.
name|intValue
operator|!=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|.
name|type
operator|==
name|TYPE_DOUBLE
condition|)
block|{
operator|*
name|ptr
operator|=
name|value
operator|.
name|doubleValue
operator|!=
literal|0.0
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_GetBoolean
argument_list|(
name|interp
argument_list|,
name|value
operator|.
name|pv
operator|.
name|buffer
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|value
operator|.
name|pv
operator|.
name|buffer
operator|!=
name|value
operator|.
name|staticSpace
condition|)
block|{
name|ckfree
argument_list|(
name|value
operator|.
name|pv
operator|.
name|buffer
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------  *  * Tcl_ExprString --  *  *	Evaluate an expression and return its value in string form.  *  * Results:  *	A standard Tcl result.  If the result is TCL_OK, then the  *	interpreter's result is set to the string value of the  *	expression.  If the result is TCL_OK, then interp->result  *	contains an error message.  *  * Side effects:  *	None.  *  *--------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_ExprString
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Context in which to evaluate the 					 * expression. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Expression to evaluate. */
block|{
name|Value
name|value
decl_stmt|;
name|int
name|result
decl_stmt|;
name|result
operator|=
name|ExprTopLevel
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|value
operator|.
name|type
operator|==
name|TYPE_INT
condition|)
block|{
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"%ld"
argument_list|,
name|value
operator|.
name|intValue
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|.
name|type
operator|==
name|TYPE_DOUBLE
condition|)
block|{
name|Tcl_PrintDouble
argument_list|(
name|interp
argument_list|,
name|value
operator|.
name|doubleValue
argument_list|,
name|interp
operator|->
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|value
operator|.
name|pv
operator|.
name|buffer
operator|!=
name|value
operator|.
name|staticSpace
condition|)
block|{
name|interp
operator|->
name|result
operator|=
name|value
operator|.
name|pv
operator|.
name|buffer
expr_stmt|;
name|interp
operator|->
name|freeProc
operator|=
name|TCL_DYNAMIC
expr_stmt|;
name|value
operator|.
name|pv
operator|.
name|buffer
operator|=
name|value
operator|.
name|staticSpace
expr_stmt|;
block|}
else|else
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|value
operator|.
name|pv
operator|.
name|buffer
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|value
operator|.
name|pv
operator|.
name|buffer
operator|!=
name|value
operator|.
name|staticSpace
condition|)
block|{
name|ckfree
argument_list|(
name|value
operator|.
name|pv
operator|.
name|buffer
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CreateMathFunc --  *  *	Creates a new math function for expressions in a given  *	interpreter.  *  * Results:  *	None.  *  * Side effects:  *	The function defined by "name" is created;  if such a function  *	already existed then its definition is overriden.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_CreateMathFunc
parameter_list|(
name|interp
parameter_list|,
name|name
parameter_list|,
name|numArgs
parameter_list|,
name|argTypes
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which function is 					 * to be available. */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of function (e.g. "sin"). */
name|int
name|numArgs
decl_stmt|;
comment|/* Nnumber of arguments required by 					 * function. */
name|Tcl_ValueType
modifier|*
name|argTypes
decl_stmt|;
comment|/* Array of types acceptable for 					 * each argument. */
name|Tcl_MathProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure that implements the 					 * math function. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Additional value to pass to the 					 * function. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|MathFunc
modifier|*
name|mathFuncPtr
decl_stmt|;
name|int
name|new
decl_stmt|,
name|i
decl_stmt|;
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|mathFuncTable
argument_list|,
name|name
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|MathFunc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mathFuncPtr
operator|=
operator|(
name|MathFunc
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|numArgs
operator|>
name|MAX_MATH_ARGS
condition|)
block|{
name|numArgs
operator|=
name|MAX_MATH_ARGS
expr_stmt|;
block|}
name|mathFuncPtr
operator|->
name|numArgs
operator|=
name|numArgs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numArgs
condition|;
name|i
operator|++
control|)
block|{
name|mathFuncPtr
operator|->
name|argTypes
index|[
name|i
index|]
operator|=
name|argTypes
index|[
name|i
index|]
expr_stmt|;
block|}
name|mathFuncPtr
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|mathFuncPtr
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * ExprMathFunc --  *  *	This procedure is invoked to parse a math function from an  *	expression string, carry out the function, and return the  *	value computed.  *  * Results:  *	TCL_OK is returned if all went well and the function's value  *	was computed successfully.  If an error occurred, TCL_ERROR  *	is returned and an error message is left in interp->result.  *	After a successful return infoPtr has been updated to refer  *	to the character just after the function call, the token is  *	set to VALUE, and the value is stored in valuePtr.  *  * Side effects:  *	Embedded commands could have arbitrary side-effects.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ExprMathFunc
parameter_list|(
name|interp
parameter_list|,
name|infoPtr
parameter_list|,
name|valuePtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for error 					 * reporting. */
specifier|register
name|ExprInfo
modifier|*
name|infoPtr
decl_stmt|;
comment|/* Describes the state of the parse. 					 * infoPtr->expr must point to the 					 * first character of the function's 					 * name. */
specifier|register
name|Value
modifier|*
name|valuePtr
decl_stmt|;
comment|/* Where to store value, if that is 					 * what's parsed from string.  Caller 					 * must have initialized pv field 					 * correctly. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|MathFunc
modifier|*
name|mathFuncPtr
decl_stmt|;
comment|/* Info about math function. */
name|Tcl_Value
name|args
index|[
name|MAX_MATH_ARGS
index|]
decl_stmt|;
comment|/* Arguments for function call. */
name|Tcl_Value
name|funcResult
decl_stmt|;
comment|/* Result of function call. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|funcName
decl_stmt|,
name|savedChar
decl_stmt|;
name|int
name|i
decl_stmt|,
name|result
decl_stmt|;
comment|/*      * Find the end of the math function's name and lookup the MathFunc      * record for the function.      */
name|p
operator|=
name|funcName
operator|=
name|infoPtr
operator|->
name|expr
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'_'
operator|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
name|infoPtr
operator|->
name|expr
operator|=
name|p
expr_stmt|;
name|result
operator|=
name|ExprLex
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|infoPtr
operator|->
name|token
operator|!=
name|OPEN_PAREN
condition|)
block|{
goto|goto
name|syntaxError
goto|;
block|}
name|savedChar
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|mathFuncTable
argument_list|,
name|funcName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"unknown math function \""
argument_list|,
name|funcName
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|savedChar
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
operator|*
name|p
operator|=
name|savedChar
expr_stmt|;
name|mathFuncPtr
operator|=
operator|(
name|MathFunc
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
comment|/*      * Scan off the arguments for the function, if there are any.      */
if|if
condition|(
name|mathFuncPtr
operator|->
name|numArgs
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|ExprLex
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|!=
name|TCL_OK
operator|)
operator|||
operator|(
name|infoPtr
operator|->
name|token
operator|!=
name|CLOSE_PAREN
operator|)
condition|)
block|{
goto|goto
name|syntaxError
goto|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|valuePtr
operator|->
name|pv
operator|.
name|next
operator|=
name|valuePtr
operator|->
name|pv
operator|.
name|buffer
expr_stmt|;
name|result
operator|=
name|ExprGetValue
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
operator|-
literal|1
argument_list|,
name|valuePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_STRING
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"argument to math function didn't have numeric value"
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/* 	     * Copy the value to the argument record, converting it if 	     * necessary. 	     */
if|if
condition|(
name|valuePtr
operator|->
name|type
operator|==
name|TYPE_INT
condition|)
block|{
if|if
condition|(
name|mathFuncPtr
operator|->
name|argTypes
index|[
name|i
index|]
operator|==
name|TCL_DOUBLE
condition|)
block|{
name|args
index|[
name|i
index|]
operator|.
name|type
operator|=
name|TCL_DOUBLE
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|doubleValue
operator|=
name|valuePtr
operator|->
name|intValue
expr_stmt|;
block|}
else|else
block|{
name|args
index|[
name|i
index|]
operator|.
name|type
operator|=
name|TCL_INT
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|intValue
operator|=
name|valuePtr
operator|->
name|intValue
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|mathFuncPtr
operator|->
name|argTypes
index|[
name|i
index|]
operator|==
name|TCL_INT
condition|)
block|{
name|args
index|[
name|i
index|]
operator|.
name|type
operator|=
name|TCL_INT
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|intValue
operator|=
operator|(
name|long
operator|)
name|valuePtr
operator|->
name|doubleValue
expr_stmt|;
block|}
else|else
block|{
name|args
index|[
name|i
index|]
operator|.
name|type
operator|=
name|TCL_DOUBLE
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|doubleValue
operator|=
name|valuePtr
operator|->
name|doubleValue
expr_stmt|;
block|}
block|}
comment|/* 	     * Check for a comma separator between arguments or a close-paren 	     * to end the argument list. 	     */
if|if
condition|(
name|i
operator|==
operator|(
name|mathFuncPtr
operator|->
name|numArgs
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|infoPtr
operator|->
name|token
operator|==
name|CLOSE_PAREN
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|infoPtr
operator|->
name|token
operator|==
name|COMMA
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"too many arguments for math function"
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
else|else
block|{
goto|goto
name|syntaxError
goto|;
block|}
block|}
if|if
condition|(
name|infoPtr
operator|->
name|token
operator|!=
name|COMMA
condition|)
block|{
if|if
condition|(
name|infoPtr
operator|->
name|token
operator|==
name|CLOSE_PAREN
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"too few arguments for math function"
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
else|else
block|{
goto|goto
name|syntaxError
goto|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|iPtr
operator|->
name|noEval
condition|)
block|{
name|valuePtr
operator|->
name|type
operator|=
name|TYPE_INT
expr_stmt|;
name|valuePtr
operator|->
name|intValue
operator|=
literal|0
expr_stmt|;
name|infoPtr
operator|->
name|token
operator|=
name|VALUE
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
comment|/*      * Invoke the function and copy its result back into valuePtr.      */
name|tcl_MathInProgress
operator|++
expr_stmt|;
name|result
operator|=
call|(
modifier|*
name|mathFuncPtr
operator|->
name|proc
call|)
argument_list|(
name|mathFuncPtr
operator|->
name|clientData
argument_list|,
name|interp
argument_list|,
name|args
argument_list|,
operator|&
name|funcResult
argument_list|)
expr_stmt|;
name|tcl_MathInProgress
operator|--
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
if|if
condition|(
name|funcResult
operator|.
name|type
operator|==
name|TCL_INT
condition|)
block|{
name|valuePtr
operator|->
name|type
operator|=
name|TYPE_INT
expr_stmt|;
name|valuePtr
operator|->
name|intValue
operator|=
name|funcResult
operator|.
name|intValue
expr_stmt|;
block|}
else|else
block|{
name|valuePtr
operator|->
name|type
operator|=
name|TYPE_DOUBLE
expr_stmt|;
name|valuePtr
operator|->
name|doubleValue
operator|=
name|funcResult
operator|.
name|doubleValue
expr_stmt|;
block|}
name|infoPtr
operator|->
name|token
operator|=
name|VALUE
expr_stmt|;
return|return
name|TCL_OK
return|;
name|syntaxError
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"syntax error in expression \""
argument_list|,
name|infoPtr
operator|->
name|originalExpr
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclExprFloatError --  *  *	This procedure is called when an error occurs during a  *	floating-point operation.  It reads errno and sets  *	interp->result accordingly.  *  * Results:  *	Interp->result is set to hold an error message.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclExprFloatError
parameter_list|(
name|interp
parameter_list|,
name|value
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Where to store error message. */
name|double
name|value
decl_stmt|;
comment|/* Value returned after error;  used to 				 * distinguish underflows from overflows. */
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|errno
operator|==
name|EDOM
operator|)
operator|||
operator|(
name|value
operator|!=
name|value
operator|)
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"domain error: argument not in valid range"
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"ARITH"
argument_list|,
literal|"DOMAIN"
argument_list|,
name|interp
operator|->
name|result
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|errno
operator|==
name|ERANGE
operator|)
operator|||
name|IS_INF
argument_list|(
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|==
literal|0.0
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"floating-point value too small to represent"
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"ARITH"
argument_list|,
literal|"UNDERFLOW"
argument_list|,
name|interp
operator|->
name|result
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|interp
operator|->
name|result
operator|=
literal|"floating-point value too large to represent"
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"ARITH"
argument_list|,
literal|"OVERFLOW"
argument_list|,
name|interp
operator|->
name|result
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"unknown floating-point error, "
argument_list|,
literal|"errno = "
argument_list|,
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"ARITH"
argument_list|,
literal|"UNKNOWN"
argument_list|,
name|interp
operator|->
name|result
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Math Functions --  *  *	This page contains the procedures that implement all of the  *	built-in math functions for expressions.  *  * Results:  *	Each procedure returns TCL_OK if it succeeds and places result  *	information at *resultPtr.  If it fails it returns TCL_ERROR  *	and leaves an error message in interp->result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ExprUnaryFunc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|args
parameter_list|,
name|resultPtr
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Contains address of procedure that 					 * takes one double argument and 					 * returns a double result. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
name|Tcl_Value
modifier|*
name|args
decl_stmt|;
name|Tcl_Value
modifier|*
name|resultPtr
decl_stmt|;
block|{
name|double
argument_list|(
argument|*func
argument_list|)
name|_ANSI_ARGS_
argument_list|(
operator|(
name|double
operator|)
argument_list|)
operator|=
operator|(
name|double
argument_list|(
argument|*
argument_list|)
name|_ANSI_ARGS_
argument_list|(
operator|(
name|double
operator|)
argument_list|)
operator|)
name|clientData
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|resultPtr
operator|->
name|type
operator|=
name|TCL_DOUBLE
expr_stmt|;
name|resultPtr
operator|->
name|doubleValue
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|doubleValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|TclExprFloatError
argument_list|(
name|interp
argument_list|,
name|resultPtr
operator|->
name|doubleValue
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ExprBinaryFunc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|args
parameter_list|,
name|resultPtr
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Contains address of procedure that 					 * takes two double arguments and 					 * returns a double result. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
name|Tcl_Value
modifier|*
name|args
decl_stmt|;
name|Tcl_Value
modifier|*
name|resultPtr
decl_stmt|;
block|{
name|double
argument_list|(
argument|*func
argument_list|)
name|_ANSI_ARGS_
argument_list|(
operator|(
name|double
operator|,
name|double
operator|)
argument_list|)
operator|=
operator|(
name|double
argument_list|(
argument|*
argument_list|)
name|_ANSI_ARGS_
argument_list|(
operator|(
name|double
operator|,
name|double
operator|)
argument_list|)
operator|)
name|clientData
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|resultPtr
operator|->
name|type
operator|=
name|TCL_DOUBLE
expr_stmt|;
name|resultPtr
operator|->
name|doubleValue
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|doubleValue
argument_list|,
name|args
index|[
literal|1
index|]
operator|.
name|doubleValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|TclExprFloatError
argument_list|(
name|interp
argument_list|,
name|resultPtr
operator|->
name|doubleValue
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|ExprAbsFunc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|args
parameter_list|,
name|resultPtr
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
name|Tcl_Value
modifier|*
name|args
decl_stmt|;
name|Tcl_Value
modifier|*
name|resultPtr
decl_stmt|;
block|{
name|resultPtr
operator|->
name|type
operator|=
name|TCL_DOUBLE
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|type
operator|==
name|TCL_DOUBLE
condition|)
block|{
name|resultPtr
operator|->
name|type
operator|=
name|TCL_DOUBLE
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|doubleValue
operator|<
literal|0
condition|)
block|{
name|resultPtr
operator|->
name|doubleValue
operator|=
operator|-
name|args
index|[
literal|0
index|]
operator|.
name|doubleValue
expr_stmt|;
block|}
else|else
block|{
name|resultPtr
operator|->
name|doubleValue
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|doubleValue
expr_stmt|;
block|}
block|}
else|else
block|{
name|resultPtr
operator|->
name|type
operator|=
name|TCL_INT
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|intValue
operator|<
literal|0
condition|)
block|{
name|resultPtr
operator|->
name|intValue
operator|=
operator|-
name|args
index|[
literal|0
index|]
operator|.
name|intValue
expr_stmt|;
if|if
condition|(
name|resultPtr
operator|->
name|intValue
operator|<
literal|0
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"integer value too large to represent"
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"ARITH"
argument_list|,
literal|"IOVERFLOW"
argument_list|,
name|interp
operator|->
name|result
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
else|else
block|{
name|resultPtr
operator|->
name|intValue
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|intValue
expr_stmt|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|ExprDoubleFunc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|args
parameter_list|,
name|resultPtr
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
name|Tcl_Value
modifier|*
name|args
decl_stmt|;
name|Tcl_Value
modifier|*
name|resultPtr
decl_stmt|;
block|{
name|resultPtr
operator|->
name|type
operator|=
name|TCL_DOUBLE
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|type
operator|==
name|TCL_DOUBLE
condition|)
block|{
name|resultPtr
operator|->
name|doubleValue
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|doubleValue
expr_stmt|;
block|}
else|else
block|{
name|resultPtr
operator|->
name|doubleValue
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|intValue
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|ExprIntFunc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|args
parameter_list|,
name|resultPtr
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
name|Tcl_Value
modifier|*
name|args
decl_stmt|;
name|Tcl_Value
modifier|*
name|resultPtr
decl_stmt|;
block|{
name|resultPtr
operator|->
name|type
operator|=
name|TCL_INT
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|type
operator|==
name|TCL_INT
condition|)
block|{
name|resultPtr
operator|->
name|intValue
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|intValue
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|doubleValue
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|doubleValue
operator|<
operator|(
name|double
operator|)
operator|(
name|long
operator|)
name|LONG_MIN
condition|)
block|{
name|tooLarge
label|:
name|interp
operator|->
name|result
operator|=
literal|"integer value too large to represent"
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"ARITH"
argument_list|,
literal|"IOVERFLOW"
argument_list|,
name|interp
operator|->
name|result
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|doubleValue
operator|>
operator|(
name|double
operator|)
name|LONG_MAX
condition|)
block|{
goto|goto
name|tooLarge
goto|;
block|}
block|}
name|resultPtr
operator|->
name|intValue
operator|=
operator|(
name|long
operator|)
name|args
index|[
literal|0
index|]
operator|.
name|doubleValue
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|ExprRoundFunc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|args
parameter_list|,
name|resultPtr
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
name|Tcl_Value
modifier|*
name|args
decl_stmt|;
name|Tcl_Value
modifier|*
name|resultPtr
decl_stmt|;
block|{
name|resultPtr
operator|->
name|type
operator|=
name|TCL_INT
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|type
operator|==
name|TCL_INT
condition|)
block|{
name|resultPtr
operator|->
name|intValue
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|intValue
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|doubleValue
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|doubleValue
operator|<=
operator|(
operator|(
operator|(
name|double
operator|)
operator|(
name|long
operator|)
name|LONG_MIN
operator|)
operator|-
literal|0.5
operator|)
condition|)
block|{
name|tooLarge
label|:
name|interp
operator|->
name|result
operator|=
literal|"integer value too large to represent"
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"ARITH"
argument_list|,
literal|"IOVERFLOW"
argument_list|,
name|interp
operator|->
name|result
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|resultPtr
operator|->
name|intValue
operator|=
call|(
name|long
call|)
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|doubleValue
operator|-
literal|0.5
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|doubleValue
operator|>=
operator|(
operator|(
operator|(
name|double
operator|)
name|LONG_MAX
operator|+
literal|0.5
operator|)
operator|)
condition|)
block|{
goto|goto
name|tooLarge
goto|;
block|}
name|resultPtr
operator|->
name|intValue
operator|=
call|(
name|long
call|)
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|doubleValue
operator|+
literal|0.5
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * ExprLooksLikeInt --  *  *	This procedure decides whether the leading characters of a  *	string look like an integer or something else (such as a  *	floating-point number or string).  *  * Results:  *	The return value is 1 if the leading characters of p look  *	like a valid Tcl integer.  If they look like a floating-point  *	number (e.g. "e01" or "2.4"), or if they don't look like a  *	number at all, then 0 is returned.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ExprLooksLikeInt
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Pointer to string. */
block|{
while|while
condition|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'+'
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'-'
operator|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|p
operator|!=
literal|'.'
operator|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|'e'
operator|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|'E'
operator|)
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

