begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclInterp.c --  *  *	This file implements the "interp" command which allows creation  *	and manipulation of Tcl interpreters from within Tcl scripts.  *  * Copyright (c) 1995-1997 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclInterp.c 1.128 97/11/05 09:35:12  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*  * Counter for how many aliases were created (global)  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|aliasCounter
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  * struct Slave:  *  * Used by the "interp" command to record and find information about slave  * interpreters. Maps from a command name in the master to information about  * a slave interpreter, e.g. what aliases are defined in it.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|Tcl_Interp
modifier|*
name|masterInterp
decl_stmt|;
comment|/* Master interpreter for this slave. */
name|Tcl_HashEntry
modifier|*
name|slaveEntry
decl_stmt|;
comment|/* Hash entry in masters slave table for                                  * this slave interpreter. Used to find                                  * this record, and used when deleting the                                  * slave interpreter to delete it from the                                  * masters table. */
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* The slave interpreter. */
name|Tcl_Command
name|interpCmd
decl_stmt|;
comment|/* Interpreter object command. */
name|Tcl_HashTable
name|aliasTable
decl_stmt|;
comment|/* Table which maps from names of commands                                  * in slave interpreter to struct Alias                                  * defined below. */
block|}
name|Slave
typedef|;
end_typedef

begin_comment
comment|/*  * struct Alias:  *  * Stores information about an alias. Is stored in the slave interpreter  * and used by the source command to find the target command in the master  * when the source command is invoked.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|aliasName
decl_stmt|;
comment|/* Name of alias command. */
name|char
modifier|*
name|targetName
decl_stmt|;
comment|/* Name of target command in master interp. */
name|Tcl_Interp
modifier|*
name|targetInterp
decl_stmt|;
comment|/* Master interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Count of additional args to pass. */
name|Tcl_Obj
modifier|*
modifier|*
name|objv
decl_stmt|;
comment|/* Actual additional args to pass. */
name|Tcl_HashEntry
modifier|*
name|aliasEntry
decl_stmt|;
comment|/* Entry for the alias hash table in slave.                                  * This is used by alias deletion to remove                                  * the alias from the slave interpreter                                  * alias table. */
name|Tcl_HashEntry
modifier|*
name|targetEntry
decl_stmt|;
comment|/* Entry for target command in master.                                  * This is used in the master interpreter to                                  * map back from the target command to aliases                                  * redirecting to it. Random access to this                                  * hash table is never required - we are using                                  * a hash table only for convenience. */
name|Tcl_Command
name|slaveCmd
decl_stmt|;
comment|/* Source command in slave interpreter. */
block|}
name|Alias
typedef|;
end_typedef

begin_comment
comment|/*  * struct Target:  *  * Maps from master interpreter commands back to the source commands in slave  * interpreters. This is needed because aliases can be created between sibling  * interpreters and must be deleted when the target interpreter is deleted. In  * case they would not be deleted the source interpreter would be left with a  * "dangling pointer". One such record is stored in the Master record of the  * master interpreter (in the targetTable hashtable, see below) with the  * master for each alias which directs to a command in the master. These  * records are used to remove the source command for an from a slave if/when  * the master is deleted.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|Tcl_Command
name|slaveCmd
decl_stmt|;
comment|/* Command for alias in slave interp. */
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* Slave Interpreter. */
block|}
name|Target
typedef|;
end_typedef

begin_comment
comment|/*  * struct Master:  *  * This record is used for two purposes: First, slaveTable (a hashtable)  * maps from names of commands to slave interpreters. This hashtable is  * used to store information about slave interpreters of this interpreter,  * to map over all slaves, etc. The second purpose is to store information  * about all aliases in slaves (or siblings) which direct to target commands  * in this interpreter (using the targetTable hashtable).  *   * NB: the flags field in the interp structure, used with SAFE_INTERP  * mask denotes whether the interpreter is safe or not. Safe  * interpreters have restricted functionality, can only create safe slave  * interpreters and can only load safe extensions.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|Tcl_HashTable
name|slaveTable
decl_stmt|;
comment|/* Hash table for slave interpreters.                                  * Maps from command names to Slave records. */
name|Tcl_HashTable
name|targetTable
decl_stmt|;
comment|/* Hash table for Target Records. Contains                                  * all Target records which denote aliases                                  * from slaves or sibling interpreters that                                  * direct to commands in this interpreter. This                                  * table is used to remove dangling pointers                                  * from the slave (or sibling) interpreters                                  * when this interpreter is deleted. */
block|}
name|Master
typedef|;
end_typedef

begin_comment
comment|/*  * Prototypes for local static procedures:  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|AliasCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|currentInterp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|AliasCmdDeleteProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|AliasCreationHelper
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|curInterp
operator|,
name|Tcl_Interp
operator|*
name|slaveInterp
operator|,
name|Tcl_Interp
operator|*
name|masterInterp
operator|,
name|Master
operator|*
name|masterPtr
operator|,
name|char
operator|*
name|aliasName
operator|,
name|char
operator|*
name|targetName
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CreateInterpObject
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Master
operator|*
name|masterPtr
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Tcl_Interp
modifier|*
name|CreateSlave
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Master
operator|*
name|masterPtr
operator|,
name|char
operator|*
name|slavePath
operator|,
name|int
name|safe
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DeleteAlias
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Interp
operator|*
name|slaveInterp
operator|,
name|char
operator|*
name|aliasName
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DescribeAlias
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Interp
operator|*
name|slaveInterp
operator|,
name|char
operator|*
name|aliasName
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DeleteInterpObject
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Master
operator|*
name|masterPtr
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DeleteOneInterpObject
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Master
operator|*
name|masterPtr
operator|,
name|char
operator|*
name|path
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Tcl_Interp
modifier|*
name|GetInterp
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Master
operator|*
name|masterPtr
operator|,
name|char
operator|*
name|path
operator|,
name|Master
operator|*
operator|*
name|masterPtrPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|GetTarget
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|path
operator|,
name|char
operator|*
name|aliasName
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InterpAliasHelper
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Master
operator|*
name|masterPtr
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InterpAliasesHelper
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Master
operator|*
name|masterPtr
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InterpExistsHelper
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Master
operator|*
name|masterPtr
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InterpEvalHelper
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Master
operator|*
name|masterPtr
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InterpExposeHelper
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Master
operator|*
name|masterPtr
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InterpIsSafeHelper
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Master
operator|*
name|masterPtr
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InterpHideHelper
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Master
operator|*
name|masterPtr
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InterpHiddenHelper
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Master
operator|*
name|masterPtr
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InterpInvokeHiddenHelper
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Master
operator|*
name|masterPtr
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InterpMarkTrustedHelper
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Master
operator|*
name|masterPtr
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InterpSlavesHelper
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Master
operator|*
name|masterPtr
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InterpShareHelper
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Master
operator|*
name|masterPtr
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InterpTargetHelper
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Master
operator|*
name|masterPtr
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InterpTransferHelper
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Master
operator|*
name|masterPtr
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|MarkTrusted
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|MasterRecordDeleteProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SlaveAliasHelper
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Interp
operator|*
name|slaveInterp
operator|,
name|Slave
operator|*
name|slavePtr
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SlaveAliasesHelper
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Interp
operator|*
name|slaveInterp
operator|,
name|Slave
operator|*
name|slavePtr
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SlaveEvalHelper
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Interp
operator|*
name|slaveInterp
operator|,
name|Slave
operator|*
name|slavePtr
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SlaveExposeHelper
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Interp
operator|*
name|slaveInterp
operator|,
name|Slave
operator|*
name|slavePtr
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SlaveHideHelper
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Interp
operator|*
name|slaveInterp
operator|,
name|Slave
operator|*
name|slavePtr
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SlaveHiddenHelper
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Interp
operator|*
name|slaveInterp
operator|,
name|Slave
operator|*
name|slavePtr
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SlaveIsSafeHelper
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Interp
operator|*
name|slaveInterp
operator|,
name|Slave
operator|*
name|slavePtr
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SlaveInvokeHiddenHelper
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Interp
operator|*
name|slaveInterp
operator|,
name|Slave
operator|*
name|slavePtr
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SlaveMarkTrustedHelper
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Interp
operator|*
name|slaveInterp
operator|,
name|Slave
operator|*
name|slavePtr
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SlaveObjectCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|SlaveObjectDeleteProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|SlaveRecordDeleteProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclPreventAliasLoop --  *  *	When defining an alias or renaming a command, prevent an alias  *	loop from being formed.  *  * Results:  *	A standard Tcl object result.  *  * Side effects:  *	If TCL_ERROR is returned, the function also stores an error message  *	in the interpreter's result object.  *  * NOTE:  *	This function is public internal (instead of being static to  *	this file) because it is also used from TclRenameCommand.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclPreventAliasLoop
parameter_list|(
name|interp
parameter_list|,
name|cmdInterp
parameter_list|,
name|cmd
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interp in which to report errors. */
name|Tcl_Interp
modifier|*
name|cmdInterp
decl_stmt|;
comment|/* Interp in which the command is                                          * being defined. */
name|Tcl_Command
name|cmd
decl_stmt|;
comment|/* Tcl command we are attempting                                          * to define. */
block|{
name|Command
modifier|*
name|cmdPtr
init|=
operator|(
name|Command
operator|*
operator|)
name|cmd
decl_stmt|;
name|Alias
modifier|*
name|aliasPtr
decl_stmt|,
modifier|*
name|nextAliasPtr
decl_stmt|;
name|Tcl_Command
name|aliasCmd
decl_stmt|;
name|Command
modifier|*
name|aliasCmdPtr
decl_stmt|;
comment|/*      * If we are not creating or renaming an alias, then it is      * always OK to create or rename the command.      */
if|if
condition|(
name|cmdPtr
operator|->
name|objProc
operator|!=
name|AliasCmd
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
comment|/*      * OK, we are dealing with an alias, so traverse the chain of aliases.      * If we encounter the alias we are defining (or renaming to) any in      * the chain then we have a loop.      */
name|aliasPtr
operator|=
operator|(
name|Alias
operator|*
operator|)
name|cmdPtr
operator|->
name|objClientData
expr_stmt|;
name|nextAliasPtr
operator|=
name|aliasPtr
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/*          * If the target of the next alias in the chain is the same as          * the source alias, we have a loop. 	 */
name|aliasCmd
operator|=
name|Tcl_FindCommand
argument_list|(
name|nextAliasPtr
operator|->
name|targetInterp
argument_list|,
name|nextAliasPtr
operator|->
name|targetName
argument_list|,
name|Tcl_GetGlobalNamespace
argument_list|(
name|nextAliasPtr
operator|->
name|targetInterp
argument_list|)
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|aliasCmd
operator|==
operator|(
name|Tcl_Command
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
name|aliasCmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|aliasCmd
expr_stmt|;
if|if
condition|(
name|aliasCmdPtr
operator|==
name|cmdPtr
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"cannot define or rename alias \""
argument_list|,
name|aliasPtr
operator|->
name|aliasName
argument_list|,
literal|"\": would create a loop"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/* 	 * Otherwise, follow the chain one step further. See if the target          * command is an alias - if so, follow the loop to its target          * command. Otherwise we do not have a loop. 	 */
if|if
condition|(
name|aliasCmdPtr
operator|->
name|objProc
operator|!=
name|AliasCmd
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
name|nextAliasPtr
operator|=
operator|(
name|Alias
operator|*
operator|)
name|aliasCmdPtr
operator|->
name|objClientData
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * MarkTrusted --  *  *	Mark an interpreter as unsafe (i.e. remove the "safe" mark).  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Removes the "safe" mark from an interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|MarkTrusted
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to be marked unsafe. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|iPtr
operator|->
name|flags
operator|&=
operator|~
name|SAFE_INTERP
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_MakeSafe --  *  *	Makes its argument interpreter contain only functionality that is  *	defined to be part of Safe Tcl. Unsafe commands are hidden, the  *	env array is unset, and the standard channels are removed.  *  * Results:  *	None.  *  * Side effects:  *	Hides commands in its argument interpreter, and removes settings  *	and channels.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_MakeSafe
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to be made safe. */
block|{
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* Channel to remove from                                                  * safe interpreter. */
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|TclHideUnsafeCommands
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|flags
operator||=
name|SAFE_INTERP
expr_stmt|;
comment|/*      *  Unsetting variables : (which should not have been set       *  in the first place, but...)      */
comment|/*      * No env array in a safe slave.      */
name|Tcl_UnsetVar
argument_list|(
name|interp
argument_list|,
literal|"env"
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
comment|/*       * Remove unsafe parts of tcl_platform      */
name|Tcl_UnsetVar2
argument_list|(
name|interp
argument_list|,
literal|"tcl_platform"
argument_list|,
literal|"os"
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|Tcl_UnsetVar2
argument_list|(
name|interp
argument_list|,
literal|"tcl_platform"
argument_list|,
literal|"osVersion"
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|Tcl_UnsetVar2
argument_list|(
name|interp
argument_list|,
literal|"tcl_platform"
argument_list|,
literal|"machine"
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
comment|/*      * Unset path informations variables      * (the only one remaining is [info nameofexecutable])      */
name|Tcl_UnsetVar
argument_list|(
name|interp
argument_list|,
literal|"tcl_library"
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|Tcl_UnsetVar
argument_list|(
name|interp
argument_list|,
literal|"tcl_pkgPath"
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
comment|/*      * Remove the standard channels from the interpreter; safe interpreters      * do not ordinarily have access to stdin, stdout and stderr.      *      * NOTE: These channels are not added to the interpreter by the      * Tcl_CreateInterp call, but may be added later, by another I/O      * operation. We want to ensure that the interpreter does not have      * these channels even if it is being made safe after being used for      * some time..      */
name|chan
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|!=
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
name|Tcl_UnregisterChannel
argument_list|(
name|interp
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
name|chan
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|!=
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
name|Tcl_UnregisterChannel
argument_list|(
name|interp
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
name|chan
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|!=
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
name|Tcl_UnregisterChannel
argument_list|(
name|interp
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * GetInterp --  *  *	Helper function to find a slave interpreter given a pathname.  *  * Results:  *	Returns the slave interpreter known by that name in the calling  *	interpreter, or NULL if no interpreter known by that name exists.   *  * Side effects:  *	Assigns to the pointer variable passed in, if not NULL.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Tcl_Interp
modifier|*
name|GetInterp
parameter_list|(
name|interp
parameter_list|,
name|masterPtr
parameter_list|,
name|path
parameter_list|,
name|masterPtrPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interp. to start search from. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Its master record. */
name|char
modifier|*
name|path
decl_stmt|;
comment|/* The path (name) of interp. to be found. */
name|Master
modifier|*
modifier|*
name|masterPtrPtr
decl_stmt|;
comment|/* (Return) its master record. */
block|{
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Search element. */
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Interim slave record. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Split-up path (name) for interp to find. */
name|int
name|argc
decl_stmt|,
name|i
decl_stmt|;
comment|/* Loop indices. */
name|Tcl_Interp
modifier|*
name|searchInterp
decl_stmt|;
comment|/* Interim storage for interp. to find. */
if|if
condition|(
name|masterPtrPtr
operator|!=
operator|(
name|Master
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
operator|*
name|masterPtrPtr
operator|=
name|masterPtr
expr_stmt|;
block|}
if|if
condition|(
name|Tcl_SplitList
argument_list|(
name|interp
argument_list|,
name|path
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
return|;
block|}
for|for
control|(
name|searchInterp
operator|=
name|interp
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|slaveTable
operator|)
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
return|;
block|}
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
name|searchInterp
operator|=
name|slavePtr
operator|->
name|slaveInterp
expr_stmt|;
if|if
condition|(
name|searchInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
return|;
block|}
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|searchInterp
argument_list|,
literal|"tclMasterRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterPtrPtr
operator|!=
operator|(
name|Master
operator|*
operator|*
operator|)
name|NULL
condition|)
operator|*
name|masterPtrPtr
operator|=
name|masterPtr
expr_stmt|;
if|if
condition|(
name|masterPtr
operator|==
operator|(
name|Master
operator|*
operator|)
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
return|;
block|}
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
name|searchInterp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CreateSlave --  *  *	Helper function to do the actual work of creating a slave interp  *	and new object command. Also optionally makes the new slave  *	interpreter "safe".  *  * Results:  *	Returns the new Tcl_Interp * if successful or NULL if not. If failed,  *	the result of the invoking interpreter contains an error message.  *  * Side effects:  *	Creates a new slave interpreter and a new object command.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Tcl_Interp
modifier|*
name|CreateSlave
parameter_list|(
name|interp
parameter_list|,
name|masterPtr
parameter_list|,
name|slavePath
parameter_list|,
name|safe
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interp. to start search from. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record. */
name|char
modifier|*
name|slavePath
decl_stmt|;
comment|/* Path (name) of slave to create. */
name|int
name|safe
decl_stmt|;
comment|/* Should we make it "safe"? */
block|{
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* Ptr to slave interpreter. */
name|Tcl_Interp
modifier|*
name|masterInterp
decl_stmt|;
comment|/* Ptr to master interp for slave. */
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Slave record. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Entry into interp hashtable. */
name|int
name|new
decl_stmt|;
comment|/* Indicates whether new entry. */
name|int
name|argc
decl_stmt|;
comment|/* Count of elements in slavePath. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Elements in slavePath. */
name|char
modifier|*
name|masterPath
decl_stmt|;
comment|/* Path to its master. */
if|if
condition|(
name|Tcl_SplitList
argument_list|(
name|interp
argument_list|,
name|slavePath
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
return|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|masterInterp
operator|=
name|interp
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|slavePath
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|masterPath
operator|=
name|Tcl_Merge
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|masterInterp
operator|=
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|masterPath
argument_list|,
operator|&
name|masterPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"interpreter named \""
argument_list|,
name|masterPath
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|masterPath
argument_list|)
expr_stmt|;
return|return
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
return|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|masterPath
argument_list|)
expr_stmt|;
name|slavePath
operator|=
name|argv
index|[
name|argc
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|safe
condition|)
block|{
name|safe
operator|=
name|Tcl_IsSafe
argument_list|(
name|masterInterp
argument_list|)
expr_stmt|;
block|}
block|}
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|slaveTable
operator|)
argument_list|,
name|slavePath
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"interpreter named \""
argument_list|,
name|slavePath
argument_list|,
literal|"\" already exists, cannot create"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
return|;
block|}
name|slaveInterp
operator|=
name|Tcl_CreateInterp
argument_list|()
expr_stmt|;
if|if
condition|(
name|slaveInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"CreateSlave: out of memory while creating a new interpreter"
argument_list|)
expr_stmt|;
block|}
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|slaveInterp
argument_list|,
literal|"tclSlaveRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|slavePtr
operator|->
name|masterInterp
operator|=
name|masterInterp
expr_stmt|;
name|slavePtr
operator|->
name|slaveEntry
operator|=
name|hPtr
expr_stmt|;
name|slavePtr
operator|->
name|slaveInterp
operator|=
name|slaveInterp
expr_stmt|;
name|slavePtr
operator|->
name|interpCmd
operator|=
name|Tcl_CreateObjCommand
argument_list|(
name|masterInterp
argument_list|,
name|slavePath
argument_list|,
name|SlaveObjectCmd
argument_list|,
operator|(
name|ClientData
operator|)
name|slaveInterp
argument_list|,
name|SlaveObjectDeleteProc
argument_list|)
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
operator|&
operator|(
name|slavePtr
operator|->
name|aliasTable
operator|)
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Tcl_SetAssocData
argument_list|(
name|slaveInterp
argument_list|,
literal|"tclSlaveRecord"
argument_list|,
name|SlaveRecordDeleteProc
argument_list|,
operator|(
name|ClientData
operator|)
name|slavePtr
argument_list|)
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
operator|(
name|ClientData
operator|)
name|slavePtr
argument_list|)
expr_stmt|;
name|Tcl_SetVar
argument_list|(
name|slaveInterp
argument_list|,
literal|"tcl_interactive"
argument_list|,
literal|"0"
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
comment|/*      * Inherit the recursion limit.      */
operator|(
operator|(
name|Interp
operator|*
operator|)
name|slaveInterp
operator|)
operator|->
name|maxNestingDepth
operator|=
operator|(
operator|(
name|Interp
operator|*
operator|)
name|masterInterp
operator|)
operator|->
name|maxNestingDepth
expr_stmt|;
if|if
condition|(
name|safe
condition|)
block|{
if|if
condition|(
name|Tcl_MakeSafe
argument_list|(
name|slaveInterp
argument_list|)
operator|==
name|TCL_ERROR
condition|)
block|{
goto|goto
name|error
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|Tcl_Init
argument_list|(
name|slaveInterp
argument_list|)
operator|==
name|TCL_ERROR
condition|)
block|{
goto|goto
name|error
goto|;
block|}
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
name|slaveInterp
return|;
name|error
label|:
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
name|Tcl_GetVar2
argument_list|(
name|slaveInterp
argument_list|,
literal|"errorInfo"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|Tcl_GetVar2
argument_list|(
name|slaveInterp
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|slaveInterp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|slaveInterp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Tcl_DeleteCommand
argument_list|(
name|masterInterp
argument_list|,
name|slavePath
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CreateInterpObject -  *  *	Helper function to do the actual work of creating a new interpreter  *	and an object command.   *  * Results:  *	A Tcl result.  *  * Side effects:  *	See user documentation for details.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CreateInterpObject
parameter_list|(
name|interp
parameter_list|,
name|masterPtr
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Invoking interpreter. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record for same. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* with alias. */
block|{
name|int
name|safe
decl_stmt|;
comment|/* Create a safe interpreter? */
name|int
name|moreFlags
decl_stmt|;
comment|/* Expecting more flag args? */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Local pointer to object string. */
name|char
modifier|*
name|slavePath
decl_stmt|;
comment|/* Name of slave. */
name|char
name|localSlaveName
index|[
literal|200
index|]
decl_stmt|;
comment|/* Local area for creating names. */
name|int
name|i
decl_stmt|;
comment|/* Loop counter. */
name|int
name|len
decl_stmt|;
comment|/* Length of option argument. */
specifier|static
name|int
name|interpCounter
init|=
literal|0
decl_stmt|;
comment|/* Unique id for created names. */
name|moreFlags
operator|=
literal|1
expr_stmt|;
name|slavePath
operator|=
name|NULL
expr_stmt|;
name|safe
operator|=
name|Tcl_IsSafe
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|objc
operator|<
literal|2
operator|)
operator|||
operator|(
name|objc
operator|>
literal|5
operator|)
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?-safe? ?--? ?path?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|string
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|string
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|moreFlags
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|string
index|[
literal|1
index|]
operator|==
literal|'s'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|string
argument_list|,
literal|"-safe"
argument_list|,
operator|(
name|size_t
operator|)
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|len
operator|>
literal|1
operator|)
condition|)
block|{
name|safe
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|string
argument_list|,
literal|"--"
argument_list|,
operator|(
name|size_t
operator|)
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|len
operator|>
literal|1
operator|)
condition|)
block|{
name|moreFlags
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"bad option \""
argument_list|,
name|string
argument_list|,
literal|"\": should be -safe"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
else|else
block|{
name|slavePath
operator|=
name|string
expr_stmt|;
block|}
block|}
if|if
condition|(
name|slavePath
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/*          * Create an anonymous interpreter -- we choose its name and          * the name of the command. We check that the command name that          * we use for the interpreter does not collide with an existing          * command in the master interpreter.          */
while|while
condition|(
literal|1
condition|)
block|{
name|Tcl_CmdInfo
name|cmdInfo
decl_stmt|;
name|sprintf
argument_list|(
name|localSlaveName
argument_list|,
literal|"interp%d"
argument_list|,
name|interpCounter
argument_list|)
expr_stmt|;
name|interpCounter
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|Tcl_GetCommandInfo
argument_list|(
name|interp
argument_list|,
name|localSlaveName
argument_list|,
operator|&
name|cmdInfo
argument_list|)
operator|)
condition|)
block|{
break|break;
block|}
block|}
name|slavePath
operator|=
name|localSlaveName
expr_stmt|;
block|}
if|if
condition|(
name|CreateSlave
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|slavePath
argument_list|,
name|safe
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|slavePath
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
else|else
block|{
comment|/*          * CreateSlave already set the result if there was an error,          * so we do not do it here.          */
return|return
name|TCL_ERROR
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DeleteOneInterpObject --  *  *	Helper function for DeleteInterpObject. It deals with deleting one  *	interpreter at a time.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Deletes an interpreter and its interpreter object command.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|DeleteOneInterpObject
parameter_list|(
name|interp
parameter_list|,
name|masterPtr
parameter_list|,
name|path
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter for reporting errors. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Interim storage for master record.*/
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Path of interpreter to delete. */
block|{
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Interim storage for slave record. */
name|Tcl_Interp
modifier|*
name|masterInterp
decl_stmt|;
comment|/* Master of interp. to delete. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Search element. */
name|int
name|localArgc
decl_stmt|;
comment|/* Local copy of count of elements in                                          * path (name) of interp. to delete. */
name|char
modifier|*
modifier|*
name|localArgv
decl_stmt|;
comment|/* Local copy of path. */
name|char
modifier|*
name|slaveName
decl_stmt|;
comment|/* Last component in path. */
name|char
modifier|*
name|masterPath
decl_stmt|;
comment|/* One-before-last component in path.*/
if|if
condition|(
name|Tcl_SplitList
argument_list|(
name|interp
argument_list|,
name|path
argument_list|,
operator|&
name|localArgc
argument_list|,
operator|&
name|localArgv
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"bad interpreter path \""
argument_list|,
name|path
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|localArgc
operator|<
literal|2
condition|)
block|{
name|masterInterp
operator|=
name|interp
expr_stmt|;
if|if
condition|(
name|localArgc
operator|==
literal|0
condition|)
block|{
name|slaveName
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|slaveName
operator|=
name|localArgv
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|masterPath
operator|=
name|Tcl_Merge
argument_list|(
name|localArgc
operator|-
literal|1
argument_list|,
name|localArgv
argument_list|)
expr_stmt|;
name|masterInterp
operator|=
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|masterPath
argument_list|,
operator|&
name|masterPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"interpreter named \""
argument_list|,
name|masterPath
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|localArgv
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|masterPath
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|masterPath
argument_list|)
expr_stmt|;
name|slaveName
operator|=
name|localArgv
index|[
name|localArgc
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|slaveTable
operator|)
argument_list|,
name|slaveName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|localArgv
argument_list|)
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"interpreter named \""
argument_list|,
name|path
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_DeleteCommandFromToken
argument_list|(
name|masterInterp
argument_list|,
name|slavePtr
operator|->
name|interpCmd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|localArgv
argument_list|)
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"interpreter named \""
argument_list|,
name|path
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|localArgv
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DeleteInterpObject --  *  *	Helper function to do the work of deleting zero or more  *	interpreters and their interpreter object commands.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Deletes interpreters and their interpreter object command.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|DeleteInterpObject
parameter_list|(
name|interp
parameter_list|,
name|masterPtr
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter start search from. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Interim storage for master record.*/
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments in vector. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* with alias. */
block|{
name|int
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|DeleteOneInterpObject
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * AliasCreationHelper --  *  *	Helper function to do the work to actually create an alias or  *	delete an alias.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	An alias command is created and entered into the alias table  *	for the slave interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|AliasCreationHelper
parameter_list|(
name|curInterp
parameter_list|,
name|slaveInterp
parameter_list|,
name|masterInterp
parameter_list|,
name|masterPtr
parameter_list|,
name|aliasName
parameter_list|,
name|targetName
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|curInterp
decl_stmt|;
comment|/* Interp that invoked this proc. */
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* Interp where alias cmd will live                                          * or from which alias will be                                          * deleted. */
name|Tcl_Interp
modifier|*
name|masterInterp
decl_stmt|;
comment|/* Interp where target cmd will be. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record for target interp. */
name|char
modifier|*
name|aliasName
decl_stmt|;
comment|/* Name of alias cmd. */
name|char
modifier|*
name|targetName
decl_stmt|;
comment|/* Name of target cmd. */
name|int
name|objc
decl_stmt|;
comment|/* Additional arguments to store */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* with alias. */
block|{
name|Alias
modifier|*
name|aliasPtr
decl_stmt|;
comment|/* Storage for alias data. */
name|Alias
modifier|*
name|tmpAliasPtr
decl_stmt|;
comment|/* Temp storage for alias to delete. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Entry into interp hashtable. */
name|int
name|i
decl_stmt|;
comment|/* Loop index. */
name|int
name|new
decl_stmt|;
comment|/* Is it a new hash entry? */
name|Target
modifier|*
name|targetPtr
decl_stmt|;
comment|/* Maps from target command in master                                          * to source command in slave. */
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Maps from source command in slave                                          * to target command in master. */
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|slaveInterp
argument_list|,
literal|"tclSlaveRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*      * Slave record should be always present because it is created when      * the interpreter is created.      */
if|if
condition|(
name|slavePtr
operator|==
operator|(
name|Slave
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"AliasCreationHelper: could not find slave record"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|targetName
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
operator|||
operator|(
name|targetName
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
name|objc
operator|!=
literal|0
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|curInterp
argument_list|)
argument_list|,
literal|"malformed command: should be"
argument_list|,
literal|" \"alias "
argument_list|,
name|aliasName
argument_list|,
literal|" {}\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|DeleteAlias
argument_list|(
name|curInterp
argument_list|,
name|slaveInterp
argument_list|,
name|aliasName
argument_list|)
return|;
block|}
name|aliasPtr
operator|=
operator|(
name|Alias
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|Alias
argument_list|)
argument_list|)
expr_stmt|;
name|aliasPtr
operator|->
name|aliasName
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|aliasName
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|aliasPtr
operator|->
name|targetName
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|targetName
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|aliasPtr
operator|->
name|aliasName
argument_list|,
name|aliasName
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|aliasPtr
operator|->
name|targetName
argument_list|,
name|targetName
argument_list|)
expr_stmt|;
name|aliasPtr
operator|->
name|targetInterp
operator|=
name|masterInterp
expr_stmt|;
name|aliasPtr
operator|->
name|objv
operator|=
name|NULL
expr_stmt|;
name|aliasPtr
operator|->
name|objc
operator|=
name|objc
expr_stmt|;
if|if
condition|(
name|aliasPtr
operator|->
name|objc
operator|>
literal|0
condition|)
block|{
name|aliasPtr
operator|->
name|objv
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
operator|*
name|aliasPtr
operator|->
name|objc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|aliasPtr
operator|->
name|objv
index|[
name|i
index|]
operator|=
name|objv
index|[
name|i
index|]
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|aliasPtr
operator|->
name|slaveCmd
operator|=
name|Tcl_CreateObjCommand
argument_list|(
name|slaveInterp
argument_list|,
name|aliasName
argument_list|,
name|AliasCmd
argument_list|,
operator|(
name|ClientData
operator|)
name|aliasPtr
argument_list|,
name|AliasCmdDeleteProc
argument_list|)
expr_stmt|;
if|if
condition|(
name|TclPreventAliasLoop
argument_list|(
name|curInterp
argument_list|,
name|slaveInterp
argument_list|,
name|aliasPtr
operator|->
name|slaveCmd
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
comment|/*          *  Found an alias loop!  The last call to Tcl_CreateObjCommand          *  made the alias point to itself.  Delete the command and          *  its alias record.  Be careful to wipe out its client data          *  first, so the command doesn't try to delete itself.          */
name|Command
modifier|*
name|cmdPtr
init|=
operator|(
name|Command
operator|*
operator|)
name|aliasPtr
operator|->
name|slaveCmd
decl_stmt|;
name|cmdPtr
operator|->
name|clientData
operator|=
name|NULL
expr_stmt|;
name|cmdPtr
operator|->
name|deleteProc
operator|=
name|NULL
expr_stmt|;
name|cmdPtr
operator|->
name|deleteData
operator|=
name|NULL
expr_stmt|;
name|Tcl_DeleteCommandFromToken
argument_list|(
name|slaveInterp
argument_list|,
name|aliasPtr
operator|->
name|slaveCmd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|aliasPtr
operator|->
name|objv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aliasPtr
operator|->
name|objv
operator|!=
operator|(
name|Tcl_Obj
operator|*
name|CONST
operator|*
operator|)
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aliasPtr
operator|->
name|objv
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
name|aliasPtr
operator|->
name|aliasName
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|aliasPtr
operator|->
name|targetName
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aliasPtr
argument_list|)
expr_stmt|;
comment|/*          * The result was already set by TclPreventAliasLoop.          */
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Make an entry in the alias table. If it already exists delete      * the alias command. Then retry.      */
do|do
block|{
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
operator|(
name|slavePtr
operator|->
name|aliasTable
operator|)
argument_list|,
name|aliasName
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
block|{
name|tmpAliasPtr
operator|=
operator|(
name|Alias
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Tcl_DeleteCommandFromToken
argument_list|(
name|slaveInterp
argument_list|,
name|tmpAliasPtr
operator|->
name|slaveCmd
argument_list|)
expr_stmt|;
comment|/*              * The hash entry should be deleted by the Tcl_DeleteCommand              * above, in its command deletion callback (most likely this              * will be AliasCmdDeleteProc, which does the deletion).              */
block|}
block|}
do|while
condition|(
name|new
operator|==
literal|0
condition|)
do|;
name|aliasPtr
operator|->
name|aliasEntry
operator|=
name|hPtr
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
operator|(
name|ClientData
operator|)
name|aliasPtr
argument_list|)
expr_stmt|;
comment|/*      * Create the new command. We must do it after deleting any old command,      * because the alias may be pointing at a renamed alias, as in:      *      * interp alias {} foo {} bar		# Create an alias "foo"      * rename foo zop				# Now rename the alias      * interp alias {} foo {} zop		# Now recreate "foo"...      */
name|targetPtr
operator|=
operator|(
name|Target
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|Target
argument_list|)
argument_list|)
expr_stmt|;
name|targetPtr
operator|->
name|slaveCmd
operator|=
name|aliasPtr
operator|->
name|slaveCmd
expr_stmt|;
name|targetPtr
operator|->
name|slaveInterp
operator|=
name|slaveInterp
expr_stmt|;
do|do
block|{
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|targetTable
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|aliasCounter
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
name|aliasCounter
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|new
operator|==
literal|0
condition|)
do|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
operator|(
name|ClientData
operator|)
name|targetPtr
argument_list|)
expr_stmt|;
name|aliasPtr
operator|->
name|targetEntry
operator|=
name|hPtr
expr_stmt|;
comment|/*      * Make sure we clear out the object result when setting the string      * result.      */
name|Tcl_SetObjResult
argument_list|(
name|curInterp
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|aliasPtr
operator|->
name|aliasName
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InterpAliasesHelper --  *  *	Computes a list of aliases defined in an interpreter.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InterpAliasesHelper
parameter_list|(
name|interp
parameter_list|,
name|masterPtr
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Invoking interpreter. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record for current interp. */
name|int
name|objc
decl_stmt|;
comment|/* How many arguments? */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Actual arguments. */
block|{
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* A slave. */
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Record for slave interp. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Search variable. */
name|Tcl_HashSearch
name|hSearch
decl_stmt|;
comment|/* Iteration variable. */
name|int
name|len
decl_stmt|;
comment|/* Dummy length variable. */
name|Tcl_Obj
modifier|*
name|listObjPtr
decl_stmt|,
modifier|*
name|elemObjPtr
decl_stmt|;
comment|/* Local object pointers. */
if|if
condition|(
operator|(
name|objc
operator|!=
literal|2
operator|)
operator|&&
operator|(
name|objc
operator|!=
literal|3
operator|)
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?path?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|objc
operator|==
literal|3
condition|)
block|{
name|slaveInterp
operator|=
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slaveInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"interpreter \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
else|else
block|{
name|slaveInterp
operator|=
name|interp
expr_stmt|;
block|}
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|slaveInterp
argument_list|,
literal|"tclSlaveRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slavePtr
operator|==
operator|(
name|Slave
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
comment|/*      * Build a list to return the aliases:      */
name|listObjPtr
operator|=
name|Tcl_NewListObj
argument_list|(
literal|0
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
operator|(
name|slavePtr
operator|->
name|aliasTable
operator|)
argument_list|,
operator|&
name|hSearch
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|hSearch
argument_list|)
control|)
block|{
name|elemObjPtr
operator|=
name|Tcl_NewStringObj
argument_list|(
name|Tcl_GetHashKey
argument_list|(
operator|&
operator|(
name|slavePtr
operator|->
name|aliasTable
operator|)
argument_list|,
name|hPtr
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listObjPtr
argument_list|,
name|elemObjPtr
argument_list|)
expr_stmt|;
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|listObjPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InterpAliasHelper -  *  *	Handles the different forms of the "interp alias" command:  *	- interp alias slavePath aliasName  *		Describes an alias.  *	- interp alias slavePath aliasName {}  *		Deletes an alias.  *	- interp alias slavePath srcCmd masterPath targetCmd args...  *		Creates an alias.  *  * Results:  *	A Tcl result.  *  * Side effects:  *	See user documentation for details.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InterpAliasHelper
parameter_list|(
name|interp
parameter_list|,
name|masterPtr
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record for current interp. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|,
comment|/* Interpreters used when */
modifier|*
name|masterInterp
decl_stmt|;
comment|/* creating an alias btn siblings. */
name|Master
modifier|*
name|masterMasterPtr
decl_stmt|;
comment|/* Master record for master interp. */
name|int
name|len
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"slavePath slaveCmd masterPath masterCmd ?args ..?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|slaveInterp
operator|=
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slaveInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"could not find interpreter \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|objc
operator|==
literal|4
condition|)
block|{
return|return
name|DescribeAlias
argument_list|(
name|interp
argument_list|,
name|slaveInterp
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|objc
operator|==
literal|5
operator|&&
name|strcmp
argument_list|(
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|4
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|DeleteAlias
argument_list|(
name|interp
argument_list|,
name|slaveInterp
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|objc
operator|<
literal|6
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"slavePath slaveCmd masterPath masterCmd ?args ..?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|masterInterp
operator|=
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|4
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
operator|&
name|masterMasterPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"could not find interpreter \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|4
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|AliasCreationHelper
argument_list|(
name|interp
argument_list|,
name|slaveInterp
argument_list|,
name|masterInterp
argument_list|,
name|masterMasterPtr
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|5
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
name|objc
operator|-
literal|6
argument_list|,
name|objv
operator|+
literal|6
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InterpExistsHelper --  *  *	Computes whether a named interpreter exists or not.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InterpExistsHelper
parameter_list|(
name|interp
parameter_list|,
name|masterPtr
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record for current interp. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|objc
operator|>
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?path?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|objc
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
name|NULL
argument_list|)
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|objPtr
operator|=
name|Tcl_NewIntObj
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|objPtr
operator|=
name|Tcl_NewIntObj
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|objPtr
operator|=
name|Tcl_NewIntObj
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|objPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InterpEvalHelper --  *  *	Helper function to handle all the details of evaluating a  *	command in another interpreter.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Whatever the command itself does.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InterpEvalHelper
parameter_list|(
name|interp
parameter_list|,
name|masterPtr
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record for current interp. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* A slave. */
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Internal data type for slave. */
name|int
name|len
decl_stmt|;
comment|/* Dummy length variable. */
name|int
name|result
decl_stmt|;
name|Tcl_Obj
modifier|*
name|namePtr
decl_stmt|,
modifier|*
name|objPtr
decl_stmt|;
comment|/* Local object pointer. */
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"path arg ?arg ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|slaveInterp
operator|=
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slaveInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"interpreter named \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|objPtr
operator|=
name|Tcl_ConcatObj
argument_list|(
name|objc
operator|-
literal|3
argument_list|,
name|objv
operator|+
literal|3
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|Tcl_Preserve
argument_list|(
operator|(
name|ClientData
operator|)
name|slaveInterp
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_EvalObj
argument_list|(
name|slaveInterp
argument_list|,
name|objPtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
comment|/*      * Now make the result and any error information accessible. We      * have to be careful because the slave interpreter and the current      * interpreter can be the same - do not destroy the result.. This      * can happen if an interpreter contains an alias which is directed      * at a target command in the same interpreter.      */
if|if
condition|(
name|interp
operator|!=
name|slaveInterp
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
comment|/*              * An error occurred, so transfer error information from              * the target interpreter back to our interpreter.              */
name|iPtr
operator|=
operator|(
name|Interp
operator|*
operator|)
name|slaveInterp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|iPtr
operator|->
name|flags
operator|&
name|ERR_ALREADY_LOGGED
operator|)
condition|)
block|{
name|Tcl_AddErrorInfo
argument_list|(
name|slaveInterp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|iPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|ERR_ALREADY_LOGGED
operator|)
operator|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|namePtr
operator|=
name|Tcl_NewStringObj
argument_list|(
literal|"errorInfo"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|objPtr
operator|=
name|Tcl_ObjGetVar2
argument_list|(
name|slaveInterp
argument_list|,
name|namePtr
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|string
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|Tcl_GetVar2
argument_list|(
name|slaveInterp
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
block|}
comment|/*          * Move the result object from one interpreter to the          * other.          */
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|slaveInterp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|slaveInterp
argument_list|)
expr_stmt|;
block|}
name|Tcl_Release
argument_list|(
operator|(
name|ClientData
operator|)
name|slaveInterp
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InterpExposeHelper --  *  *	Helper function to handle the details of exposing a command in  *	another interpreter.  *  * Results:  *	Standard Tcl result.  *  * Side effects:  *	Exposes a command. From now on the command can be called by scripts  *	in the interpreter in which it was exposed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InterpExposeHelper
parameter_list|(
name|interp
parameter_list|,
name|masterPtr
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record for current interp. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* A slave. */
name|int
name|len
decl_stmt|;
comment|/* Dummy length variable. */
if|if
condition|(
operator|(
name|objc
operator|!=
literal|4
operator|)
operator|&&
operator|(
name|objc
operator|!=
literal|5
operator|)
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"path hiddenCmdName ?cmdName?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_IsSafe
argument_list|(
name|interp
argument_list|)
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"permission denied: safe interpreter cannot expose commands"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|slaveInterp
operator|=
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
operator|&
name|masterPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|slaveInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"interpreter \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_ExposeCommand
argument_list|(
name|slaveInterp
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
operator|(
name|objc
operator|==
literal|5
condition|?
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|4
index|]
argument_list|,
operator|&
name|len
argument_list|)
else|:
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|len
argument_list|)
operator|)
argument_list|)
operator|==
name|TCL_ERROR
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
name|slaveInterp
condition|)
block|{
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|slaveInterp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|slaveInterp
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InterpHideHelper --  *  *	Helper function that handles the details of hiding a command in  *	another interpreter.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Hides a command. From now on the command cannot be called by  *	scripts in that interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InterpHideHelper
parameter_list|(
name|interp
parameter_list|,
name|masterPtr
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record for interp. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* A slave. */
name|int
name|len
decl_stmt|;
comment|/* Dummy length variable. */
if|if
condition|(
operator|(
name|objc
operator|!=
literal|4
operator|)
operator|&&
operator|(
name|objc
operator|!=
literal|5
operator|)
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"path cmdName ?hiddenCmdName?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_IsSafe
argument_list|(
name|interp
argument_list|)
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"permission denied: safe interpreter cannot hide commands"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|slaveInterp
operator|=
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
operator|&
name|masterPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|slaveInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"interpreter \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_HideCommand
argument_list|(
name|slaveInterp
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
operator|(
name|objc
operator|==
literal|5
condition|?
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|4
index|]
argument_list|,
operator|&
name|len
argument_list|)
else|:
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|len
argument_list|)
operator|)
argument_list|)
operator|==
name|TCL_ERROR
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
name|slaveInterp
condition|)
block|{
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|slaveInterp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|slaveInterp
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InterpHiddenHelper --  *  *	Computes the list of hidden commands in a named interpreter.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InterpHiddenHelper
parameter_list|(
name|interp
parameter_list|,
name|masterPtr
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record for interp. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* A slave. */
name|int
name|len
decl_stmt|;
name|Tcl_HashTable
modifier|*
name|hTblPtr
decl_stmt|;
comment|/* Hidden command table. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Search variable. */
name|Tcl_HashSearch
name|hSearch
decl_stmt|;
comment|/* Iteration variable. */
name|Tcl_Obj
modifier|*
name|listObjPtr
decl_stmt|;
comment|/* Local object pointer. */
if|if
condition|(
name|objc
operator|>
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?path?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|objc
operator|==
literal|3
condition|)
block|{
name|slaveInterp
operator|=
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
operator|&
name|masterPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|slaveInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"interpreter \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
else|else
block|{
name|slaveInterp
operator|=
name|interp
expr_stmt|;
block|}
name|listObjPtr
operator|=
name|Tcl_NewListObj
argument_list|(
literal|0
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|hTblPtr
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|slaveInterp
argument_list|,
literal|"tclHiddenCmds"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hTblPtr
operator|!=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
condition|)
block|{
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|hTblPtr
argument_list|,
operator|&
name|hSearch
argument_list|)
init|;
name|hPtr
operator|!=
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|hSearch
argument_list|)
control|)
block|{
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listObjPtr
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|Tcl_GetHashKey
argument_list|(
name|hTblPtr
argument_list|,
name|hPtr
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|listObjPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InterpInvokeHiddenHelper --  *  *	Helper routine to handle the details of invoking a hidden  *	command in another interpreter.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Whatever the hidden command does.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InterpInvokeHiddenHelper
parameter_list|(
name|interp
parameter_list|,
name|masterPtr
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record for interp. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|int
name|doGlobal
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|result
decl_stmt|;
name|Tcl_Obj
modifier|*
name|namePtr
decl_stmt|,
modifier|*
name|objPtr
decl_stmt|;
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
name|Interp
modifier|*
name|iPtr
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"path ?-global? cmd ?arg ..?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_IsSafe
argument_list|(
name|interp
argument_list|)
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"not allowed to invoke hidden commands from safe interpreter"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
literal|"-global"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|doGlobal
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|objc
operator|<
literal|5
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"path ?-global? cmd ?arg ..?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
name|slaveInterp
operator|=
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
operator|&
name|masterPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|slaveInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"interpreter \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_Preserve
argument_list|(
operator|(
name|ClientData
operator|)
name|slaveInterp
argument_list|)
expr_stmt|;
if|if
condition|(
name|doGlobal
condition|)
block|{
name|result
operator|=
name|TclObjInvokeGlobal
argument_list|(
name|slaveInterp
argument_list|,
name|objc
operator|-
literal|4
argument_list|,
name|objv
operator|+
literal|4
argument_list|,
name|TCL_INVOKE_HIDDEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|TclObjInvoke
argument_list|(
name|slaveInterp
argument_list|,
name|objc
operator|-
literal|3
argument_list|,
name|objv
operator|+
literal|3
argument_list|,
name|TCL_INVOKE_HIDDEN
argument_list|)
expr_stmt|;
block|}
comment|/*      * Now make the result and any error information accessible. We      * have to be careful because the slave interpreter and the current      * interpreter can be the same - do not destroy the result.. This      * can happen if an interpreter contains an alias which is directed      * at a target command in the same interpreter.      */
if|if
condition|(
name|interp
operator|!=
name|slaveInterp
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
comment|/*              * An error occurred, so transfer error information from              * the target interpreter back to our interpreter.              */
name|iPtr
operator|=
operator|(
name|Interp
operator|*
operator|)
name|slaveInterp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|iPtr
operator|->
name|flags
operator|&
name|ERR_ALREADY_LOGGED
operator|)
condition|)
block|{
name|Tcl_AddErrorInfo
argument_list|(
name|slaveInterp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|iPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|ERR_ALREADY_LOGGED
operator|)
operator|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|namePtr
operator|=
name|Tcl_NewStringObj
argument_list|(
literal|"errorInfo"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|objPtr
operator|=
name|Tcl_ObjGetVar2
argument_list|(
name|slaveInterp
argument_list|,
name|namePtr
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
name|string
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|Tcl_GetVar2
argument_list|(
name|slaveInterp
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
block|}
comment|/*          * Move the result object from the slave to the master.          */
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|slaveInterp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|slaveInterp
argument_list|)
expr_stmt|;
block|}
name|Tcl_Release
argument_list|(
operator|(
name|ClientData
operator|)
name|slaveInterp
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InterpMarkTrustedHelper --  *  *	Helper function to handle the details of marking another  *	interpreter as trusted (unsafe).  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Henceforth the hard-wired checks for safety will not prevent  *	this interpreter from performing certain operations.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InterpMarkTrustedHelper
parameter_list|(
name|interp
parameter_list|,
name|masterPtr
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record for interp. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* A slave. */
name|int
name|len
decl_stmt|;
comment|/* Dummy length variable. */
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"path"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_IsSafe
argument_list|(
name|interp
argument_list|)
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"\""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|0
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
literal|" marktrusted\" can only"
argument_list|,
literal|" be invoked from a trusted interpreter"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|slaveInterp
operator|=
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
operator|&
name|masterPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|slaveInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"interpreter \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|MarkTrusted
argument_list|(
name|slaveInterp
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InterpIsSafeHelper --  *  *	Computes whether a named interpreter is safe.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InterpIsSafeHelper
parameter_list|(
name|interp
parameter_list|,
name|masterPtr
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record for interp. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* A slave. */
name|int
name|len
decl_stmt|;
comment|/* Dummy length variable. */
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Local object pointer. */
if|if
condition|(
name|objc
operator|>
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?path?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|objc
operator|==
literal|3
condition|)
block|{
name|slaveInterp
operator|=
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
operator|&
name|masterPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|slaveInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"interpreter \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|objPtr
operator|=
name|Tcl_NewIntObj
argument_list|(
name|Tcl_IsSafe
argument_list|(
name|slaveInterp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|objPtr
operator|=
name|Tcl_NewIntObj
argument_list|(
name|Tcl_IsSafe
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|objPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InterpSlavesHelper --  *  *	Computes a list of slave interpreters of a named interpreter.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InterpSlavesHelper
parameter_list|(
name|interp
parameter_list|,
name|masterPtr
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record for interp. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|int
name|len
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Search variable. */
name|Tcl_HashSearch
name|hSearch
decl_stmt|;
comment|/* Iteration variable. */
name|Tcl_Obj
modifier|*
name|listObjPtr
decl_stmt|;
comment|/* Local object pointers. */
if|if
condition|(
operator|(
name|objc
operator|!=
literal|2
operator|)
operator|&&
operator|(
name|objc
operator|!=
literal|3
operator|)
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?path?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|objc
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
operator|&
name|masterPtr
argument_list|)
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"interpreter \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
name|listObjPtr
operator|=
name|Tcl_NewListObj
argument_list|(
literal|0
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|slaveTable
operator|)
argument_list|,
operator|&
name|hSearch
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|hSearch
argument_list|)
control|)
block|{
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listObjPtr
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|Tcl_GetHashKey
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|slaveTable
operator|)
argument_list|,
name|hPtr
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|listObjPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InterpShareHelper --  *  *	Helper function to handle the details of sharing a channel between  *	interpreters.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	After this call the named channel will be shared between the  *	interpreters named in the arguments.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InterpShareHelper
parameter_list|(
name|interp
parameter_list|,
name|masterPtr
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record for interp. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* A slave. */
name|Tcl_Interp
modifier|*
name|masterInterp
decl_stmt|;
comment|/* Its master. */
name|int
name|len
decl_stmt|;
name|Tcl_Channel
name|chan
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|5
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"srcPath channelId destPath"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|masterInterp
operator|=
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"interpreter \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|slaveInterp
operator|=
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|4
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slaveInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"interpreter \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|4
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|chan
operator|=
name|Tcl_GetChannel
argument_list|(
name|masterInterp
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
name|masterInterp
condition|)
block|{
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|masterInterp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|masterInterp
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_RegisterChannel
argument_list|(
name|slaveInterp
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InterpTargetHelper --  *  *	Helper function to compute the target of an alias.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InterpTargetHelper
parameter_list|(
name|interp
parameter_list|,
name|masterPtr
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record for interp. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"path alias"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|GetTarget
argument_list|(
name|interp
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * InterpTransferHelper --  *  *	Helper function to handle the details of transferring ownership  *	of a channel between interpreters.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	After the call, the named channel will be registered in the target  *	interpreter and no longer available for use in the source interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|InterpTransferHelper
parameter_list|(
name|interp
parameter_list|,
name|masterPtr
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record for interp. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* A slave. */
name|Tcl_Interp
modifier|*
name|masterInterp
decl_stmt|;
comment|/* Its master. */
name|int
name|len
decl_stmt|;
name|Tcl_Channel
name|chan
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|5
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"srcPath channelId destPath"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|masterInterp
operator|=
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"interpreter \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|slaveInterp
operator|=
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|4
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slaveInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"interpreter \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|4
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|chan
operator|=
name|Tcl_GetChannel
argument_list|(
name|masterInterp
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
name|masterInterp
condition|)
block|{
comment|/*              * After fixing objresult, this code will change to:              * Tcl_SetObjResult(interp, Tcl_GetObjResult(masterInterp));              */
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|masterInterp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|masterInterp
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_RegisterChannel
argument_list|(
name|slaveInterp
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_UnregisterChannel
argument_list|(
name|masterInterp
argument_list|,
name|chan
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
name|masterInterp
condition|)
block|{
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|masterInterp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|masterInterp
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DescribeAlias --  *  *	Sets the interpreter's result object to a Tcl list describing  *	the given alias in the given interpreter: its target command  *	and the additional arguments to prepend to any invocation  *	of the alias.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|DescribeAlias
parameter_list|(
name|interp
parameter_list|,
name|slaveInterp
parameter_list|,
name|aliasName
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter for result& errors. */
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* Interpreter defining alias. */
name|char
modifier|*
name|aliasName
decl_stmt|;
comment|/* Name of alias to describe. */
block|{
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Slave interp slave record. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Search variable. */
name|Alias
modifier|*
name|aliasPtr
decl_stmt|;
comment|/* Structure describing alias. */
name|int
name|i
decl_stmt|;
comment|/* Loop variable. */
name|Tcl_Obj
modifier|*
name|listObjPtr
decl_stmt|;
comment|/* Local object pointer. */
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|slaveInterp
argument_list|,
literal|"tclSlaveRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*      * The slave record should always be present because it is created      * by Tcl_CreateInterp.      */
if|if
condition|(
name|slavePtr
operator|==
operator|(
name|Slave
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"DescribeAlias: could not find slave record"
argument_list|)
expr_stmt|;
block|}
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
operator|(
name|slavePtr
operator|->
name|aliasTable
operator|)
argument_list|,
name|aliasName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
name|aliasPtr
operator|=
operator|(
name|Alias
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
name|listObjPtr
operator|=
name|Tcl_NewListObj
argument_list|(
literal|0
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listObjPtr
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|aliasPtr
operator|->
name|targetName
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|aliasPtr
operator|->
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listObjPtr
argument_list|,
name|aliasPtr
operator|->
name|objv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|listObjPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DeleteAlias --  *  *	Deletes the given alias from the slave interpreter given.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Deletes the alias from the slave interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|DeleteAlias
parameter_list|(
name|interp
parameter_list|,
name|slaveInterp
parameter_list|,
name|aliasName
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter for result and errors. */
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* Interpreter defining alias. */
name|char
modifier|*
name|aliasName
decl_stmt|;
comment|/* Name of alias to delete. */
block|{
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Slave record for slave interpreter. */
name|Alias
modifier|*
name|aliasPtr
decl_stmt|;
comment|/* Points at alias structure to delete. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Search variable. */
name|char
modifier|*
name|tmpPtr
decl_stmt|,
modifier|*
name|namePtr
decl_stmt|;
comment|/* Local pointers to name of command to                                  * be deleted. */
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|slaveInterp
argument_list|,
literal|"tclSlaveRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slavePtr
operator|==
operator|(
name|Slave
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"alias \""
argument_list|,
name|aliasName
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Get the alias from the alias table, then delete the command. The      * deleteProc on the alias command will take care of removing the entry      * from the alias table.      */
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
operator|(
name|slavePtr
operator|->
name|aliasTable
operator|)
argument_list|,
name|aliasName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"alias \""
argument_list|,
name|aliasName
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|aliasPtr
operator|=
operator|(
name|Alias
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
comment|/*      * Get a copy of the real name of the command -- it might have      * been renamed, and we want to delete the renamed command, not      * the current command (if any) by the name of the original alias.      * We need the local copy because the name may get smashed when the      * command to delete is exposed, if it was hidden.      */
name|tmpPtr
operator|=
name|Tcl_GetCommandName
argument_list|(
name|slaveInterp
argument_list|,
name|aliasPtr
operator|->
name|slaveCmd
argument_list|)
expr_stmt|;
name|namePtr
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|tmpPtr
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|namePtr
argument_list|,
name|tmpPtr
argument_list|)
expr_stmt|;
comment|/*      * NOTE: The deleteProc for this command will delete the      * alias from the hash table. The deleteProc will also      * delete the target information from the master interpreter      * target table.      */
if|if
condition|(
name|Tcl_DeleteCommand
argument_list|(
name|slaveInterp
argument_list|,
name|namePtr
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Tcl_ExposeCommand
argument_list|(
name|slaveInterp
argument_list|,
name|namePtr
argument_list|,
name|namePtr
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|panic
argument_list|(
literal|"DeleteAlias: did not find alias to be deleted"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Tcl_DeleteCommand
argument_list|(
name|slaveInterp
argument_list|,
name|namePtr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"DeleteAlias: did not find alias to be deleted"
argument_list|)
expr_stmt|;
block|}
block|}
name|ckfree
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetInterpPath --  *  *	Sets the result of the asking interpreter to a proper Tcl list  *	containing the names of interpreters between the asking and  *	target interpreters. The target interpreter must be either the  *	same as the asking interpreter or one of its slaves (including  *	recursively).  *  * Results:  *	TCL_OK if the target interpreter is the same as, or a descendant  *	of, the asking interpreter; TCL_ERROR else. This way one can  *	distinguish between the case where the asking and target interps  *	are the same (an empty list is the result, and TCL_OK is returned)  *	and when the target is not a descendant of the asking interpreter  *	(in which case the Tcl result is an error message and the function  *	returns TCL_ERROR).  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_GetInterpPath
parameter_list|(
name|askingInterp
parameter_list|,
name|targetInterp
parameter_list|)
name|Tcl_Interp
modifier|*
name|askingInterp
decl_stmt|;
comment|/* Interpreter to start search from. */
name|Tcl_Interp
modifier|*
name|targetInterp
decl_stmt|;
comment|/* Interpreter to find. */
block|{
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Interim storage for Master record. */
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Interim storage for Slave record. */
if|if
condition|(
name|targetInterp
operator|==
name|askingInterp
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|targetInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|targetInterp
argument_list|,
literal|"tclSlaveRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slavePtr
operator|==
operator|(
name|Slave
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetInterpPath
argument_list|(
name|askingInterp
argument_list|,
name|slavePtr
operator|->
name|masterInterp
argument_list|)
operator|==
name|TCL_ERROR
condition|)
block|{
comment|/*          * The result of askingInterp was set by recursive call.          */
return|return
name|TCL_ERROR
return|;
block|}
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|slavePtr
operator|->
name|masterInterp
argument_list|,
literal|"tclMasterRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterPtr
operator|==
operator|(
name|Master
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_GetInterpPath: could not find master record"
argument_list|)
expr_stmt|;
block|}
name|Tcl_AppendElement
argument_list|(
name|askingInterp
argument_list|,
name|Tcl_GetHashKey
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|slaveTable
operator|)
argument_list|,
name|slavePtr
operator|->
name|slaveEntry
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * GetTarget --  *  *	Sets the result of the invoking interpreter to a path name for  *	the target interpreter of an alias in one of the slaves.  *  * Results:  *	TCL_OK if the target interpreter of the alias is a slave of the  *	invoking interpreter, TCL_ERROR else.  *  * Side effects:  *	Sets the result of the invoking interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|GetTarget
parameter_list|(
name|askingInterp
parameter_list|,
name|path
parameter_list|,
name|aliasName
parameter_list|)
name|Tcl_Interp
modifier|*
name|askingInterp
decl_stmt|;
comment|/* Interpreter to start search from. */
name|char
modifier|*
name|path
decl_stmt|;
comment|/* The path of the interp to find. */
name|char
modifier|*
name|aliasName
decl_stmt|;
comment|/* The target of this allias. */
block|{
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* Interim storage for slave. */
name|Slave
modifier|*
name|slaveSlavePtr
decl_stmt|;
comment|/* Its Slave record. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Interim storage for Master record. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Search element. */
name|Alias
modifier|*
name|aliasPtr
decl_stmt|;
comment|/* Data describing the alias. */
name|Tcl_ResetResult
argument_list|(
name|askingInterp
argument_list|)
expr_stmt|;
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|askingInterp
argument_list|,
literal|"tclMasterRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterPtr
operator|==
operator|(
name|Master
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"GetTarget: could not find master record"
argument_list|)
expr_stmt|;
block|}
name|slaveInterp
operator|=
name|GetInterp
argument_list|(
name|askingInterp
argument_list|,
name|masterPtr
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slaveInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|askingInterp
argument_list|)
argument_list|,
literal|"could not find interpreter \""
argument_list|,
name|path
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|slaveSlavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|slaveInterp
argument_list|,
literal|"tclSlaveRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slaveSlavePtr
operator|==
operator|(
name|Slave
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"GetTarget: could not find slave record"
argument_list|)
expr_stmt|;
block|}
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
operator|(
name|slaveSlavePtr
operator|->
name|aliasTable
operator|)
argument_list|,
name|aliasName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|askingInterp
argument_list|)
argument_list|,
literal|"alias \""
argument_list|,
name|aliasName
argument_list|,
literal|"\" in path \""
argument_list|,
name|path
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|aliasPtr
operator|=
operator|(
name|Alias
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|aliasPtr
operator|==
operator|(
name|Alias
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"GetTarget: could not find alias record"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Tcl_GetInterpPath
argument_list|(
name|askingInterp
argument_list|,
name|aliasPtr
operator|->
name|targetInterp
argument_list|)
operator|==
name|TCL_ERROR
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|askingInterp
argument_list|)
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|askingInterp
argument_list|)
argument_list|,
literal|"target interpreter for alias \""
argument_list|,
name|aliasName
argument_list|,
literal|"\" in path \""
argument_list|,
name|path
argument_list|,
literal|"\" is not my descendant"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_InterpCmd --  *  *	This procedure is invoked to process the "interp" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_InterpObjCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Unused. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument objects. */
block|{
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record for current interp. */
name|int
name|result
decl_stmt|;
comment|/* Local result variable. */
comment|/*      * These are all the different subcommands for this command:      */
specifier|static
name|char
modifier|*
name|subCmds
index|[]
init|=
block|{
literal|"alias"
block|,
literal|"aliases"
block|,
literal|"create"
block|,
literal|"delete"
block|,
literal|"eval"
block|,
literal|"exists"
block|,
literal|"expose"
block|,
literal|"hide"
block|,
literal|"hidden"
block|,
literal|"issafe"
block|,
literal|"invokehidden"
block|,
literal|"marktrusted"
block|,
literal|"slaves"
block|,
literal|"share"
block|,
literal|"target"
block|,
literal|"transfer"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
enum|enum
name|ISubCmdIdx
block|{
name|IAliasIdx
block|,
name|IAliasesIdx
block|,
name|ICreateIdx
block|,
name|IDeleteIdx
block|,
name|IEvalIdx
block|,
name|IExistsIdx
block|,
name|IExposeIdx
block|,
name|IHideIdx
block|,
name|IHiddenIdx
block|,
name|IIsSafeIdx
block|,
name|IInvokeHiddenIdx
block|,
name|IMarkTrustedIdx
block|,
name|ISlavesIdx
block|,
name|IShareIdx
block|,
name|ITargetIdx
block|,
name|ITransferIdx
block|}
name|index
enum|;
if|if
condition|(
name|objc
operator|<
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"cmd ?arg ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclMasterRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterPtr
operator|==
operator|(
name|Master
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_InterpCmd: could not find master record"
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|Tcl_GetIndexFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|,
name|subCmds
argument_list|,
literal|"option"
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|IAliasIdx
case|:
return|return
name|InterpAliasHelper
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
case|case
name|IAliasesIdx
case|:
return|return
name|InterpAliasesHelper
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
case|case
name|ICreateIdx
case|:
return|return
name|CreateInterpObject
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
case|case
name|IDeleteIdx
case|:
return|return
name|DeleteInterpObject
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
case|case
name|IEvalIdx
case|:
return|return
name|InterpEvalHelper
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
case|case
name|IExistsIdx
case|:
return|return
name|InterpExistsHelper
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
case|case
name|IExposeIdx
case|:
return|return
name|InterpExposeHelper
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
case|case
name|IHideIdx
case|:
return|return
name|InterpHideHelper
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
case|case
name|IHiddenIdx
case|:
return|return
name|InterpHiddenHelper
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
case|case
name|IIsSafeIdx
case|:
return|return
name|InterpIsSafeHelper
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
case|case
name|IInvokeHiddenIdx
case|:
return|return
name|InterpInvokeHiddenHelper
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
case|case
name|IMarkTrustedIdx
case|:
return|return
name|InterpMarkTrustedHelper
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
case|case
name|ISlavesIdx
case|:
return|return
name|InterpSlavesHelper
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
case|case
name|IShareIdx
case|:
return|return
name|InterpShareHelper
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
case|case
name|ITargetIdx
case|:
return|return
name|InterpTargetHelper
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
case|case
name|ITransferIdx
case|:
return|return
name|InterpTransferHelper
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SlaveAliasHelper --  *  *	Helper function to construct or query an alias for a slave  *	interpreter.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Potentially creates a new alias.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SlaveAliasHelper
parameter_list|(
name|interp
parameter_list|,
name|slaveInterp
parameter_list|,
name|slavePtr
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* The slave interpreter. */
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Its slave record. */
name|int
name|objc
decl_stmt|;
comment|/* Count of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Vector of arguments. */
block|{
name|Master
modifier|*
name|masterPtr
decl_stmt|;
name|int
name|len
decl_stmt|;
switch|switch
condition|(
name|objc
operator|-
literal|2
condition|)
block|{
case|case
literal|0
case|:
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"aliasName ?targetName? ?args..?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
case|case
literal|1
case|:
comment|/*              * Return the name of the command in the current              * interpreter for which the argument is an alias in the              * slave interpreter, and the list of saved arguments              */
return|return
name|DescribeAlias
argument_list|(
name|interp
argument_list|,
name|slaveInterp
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
return|;
default|default:
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclMasterRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterPtr
operator|==
operator|(
name|Master
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"SlaveObjectCmd: could not find master record"
argument_list|)
expr_stmt|;
block|}
return|return
name|AliasCreationHelper
argument_list|(
name|interp
argument_list|,
name|slaveInterp
argument_list|,
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
name|objc
operator|-
literal|4
argument_list|,
name|objv
operator|+
literal|4
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SlaveAliasesHelper --  *  *	Computes a list of aliases defined in a slave interpreter.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SlaveAliasesHelper
parameter_list|(
name|interp
parameter_list|,
name|slaveInterp
parameter_list|,
name|slavePtr
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* The slave interpreter. */
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Its slave record. */
name|int
name|objc
decl_stmt|;
comment|/* Count of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Vector of arguments. */
block|{
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* For local searches. */
name|Tcl_HashSearch
name|hSearch
decl_stmt|;
comment|/* For local searches. */
name|Tcl_Obj
modifier|*
name|listObjPtr
decl_stmt|;
comment|/* Local object pointer. */
name|Alias
modifier|*
name|aliasPtr
decl_stmt|;
comment|/* Alias information. */
comment|/*      * Return the names of all the aliases created in the      * slave interpreter.      */
name|listObjPtr
operator|=
name|Tcl_NewListObj
argument_list|(
literal|0
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
operator|(
name|slavePtr
operator|->
name|aliasTable
operator|)
argument_list|,
operator|&
name|hSearch
argument_list|)
init|;
name|hPtr
operator|!=
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|hSearch
argument_list|)
control|)
block|{
name|aliasPtr
operator|=
operator|(
name|Alias
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listObjPtr
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|aliasPtr
operator|->
name|aliasName
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|listObjPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SlaveEvalHelper --  *  *	Helper function to evaluate a command in a slave interpreter.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Whatever the command does.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SlaveEvalHelper
parameter_list|(
name|interp
parameter_list|,
name|slaveInterp
parameter_list|,
name|slavePtr
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* The slave interpreter. */
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Its slave record. */
name|int
name|objc
decl_stmt|;
comment|/* Count of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Vector of arguments. */
block|{
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Internal data type for slave. */
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Local object pointer. */
name|Tcl_Obj
modifier|*
name|namePtr
decl_stmt|;
comment|/* Local object pointer. */
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"arg ?arg ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|objPtr
operator|=
name|Tcl_ConcatObj
argument_list|(
name|objc
operator|-
literal|2
argument_list|,
name|objv
operator|+
literal|2
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|Tcl_Preserve
argument_list|(
operator|(
name|ClientData
operator|)
name|slaveInterp
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_EvalObj
argument_list|(
name|slaveInterp
argument_list|,
name|objPtr
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
comment|/*      * Make the result and any error information accessible. We have      * to be careful because the slave interpreter and the current      * interpreter can be the same - do not destroy the result.. This      * can happen if an interpreter contains an alias which is directed      * at a target command in the same interpreter.      */
if|if
condition|(
name|interp
operator|!=
name|slaveInterp
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
comment|/*              * An error occurred, so transfer error information from the              * destination interpreter back to our interpreter.               */
name|iPtr
operator|=
operator|(
name|Interp
operator|*
operator|)
name|slaveInterp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|iPtr
operator|->
name|flags
operator|&
name|ERR_ALREADY_LOGGED
operator|)
condition|)
block|{
name|Tcl_AddErrorInfo
argument_list|(
name|slaveInterp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|iPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|ERR_ALREADY_LOGGED
operator|)
operator|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|namePtr
operator|=
name|Tcl_NewStringObj
argument_list|(
literal|"errorInfo"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|objPtr
operator|=
name|Tcl_ObjGetVar2
argument_list|(
name|slaveInterp
argument_list|,
name|namePtr
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|string
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|Tcl_GetVar2
argument_list|(
name|slaveInterp
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
block|}
comment|/*          * Move the result object from one interpreter to the          * other.          */
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|slaveInterp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|slaveInterp
argument_list|)
expr_stmt|;
block|}
name|Tcl_Release
argument_list|(
operator|(
name|ClientData
operator|)
name|slaveInterp
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SlaveExposeHelper --  *  *	Helper function to expose a command in a slave interpreter.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	After this call scripts in the slave will be able to invoke  *	the newly exposed command.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SlaveExposeHelper
parameter_list|(
name|interp
parameter_list|,
name|slaveInterp
parameter_list|,
name|slavePtr
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* The slave interpreter. */
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Its slave record. */
name|int
name|objc
decl_stmt|;
comment|/* Count of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Vector of arguments. */
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|objc
operator|!=
literal|3
operator|)
operator|&&
operator|(
name|objc
operator|!=
literal|4
operator|)
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"hiddenCmdName ?cmdName?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_IsSafe
argument_list|(
name|interp
argument_list|)
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"permission denied: safe interpreter cannot expose commands"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_ExposeCommand
argument_list|(
name|slaveInterp
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
operator|(
name|objc
operator|==
literal|4
condition|?
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|len
argument_list|)
else|:
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
operator|)
argument_list|)
operator|==
name|TCL_ERROR
condition|)
block|{
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|slaveInterp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|slaveInterp
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SlaveHideHelper --  *  *	Helper function to hide a command in a slave interpreter.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	After this call scripts in the slave will no longer be able  *	to invoke the named command.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SlaveHideHelper
parameter_list|(
name|interp
parameter_list|,
name|slaveInterp
parameter_list|,
name|slavePtr
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* The slave interpreter. */
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Its slave record. */
name|int
name|objc
decl_stmt|;
comment|/* Count of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Vector of arguments. */
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|objc
operator|!=
literal|3
operator|)
operator|&&
operator|(
name|objc
operator|!=
literal|4
operator|)
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"cmdName ?hiddenCmdName?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_IsSafe
argument_list|(
name|interp
argument_list|)
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"permission denied: safe interpreter cannot hide commands"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_HideCommand
argument_list|(
name|slaveInterp
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
operator|(
name|objc
operator|==
literal|4
condition|?
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|len
argument_list|)
else|:
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
operator|)
argument_list|)
operator|==
name|TCL_ERROR
condition|)
block|{
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|slaveInterp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|slaveInterp
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SlaveHiddenHelper --  *  *	Helper function to compute list of hidden commands in a slave  *	interpreter.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SlaveHiddenHelper
parameter_list|(
name|interp
parameter_list|,
name|slaveInterp
parameter_list|,
name|slavePtr
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* The slave interpreter. */
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Its slave record. */
name|int
name|objc
decl_stmt|;
comment|/* Count of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Vector of arguments. */
block|{
name|Tcl_Obj
modifier|*
name|listObjPtr
decl_stmt|;
comment|/* Local object pointer. */
name|Tcl_HashTable
modifier|*
name|hTblPtr
decl_stmt|;
comment|/* For local searches. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* For local searches. */
name|Tcl_HashSearch
name|hSearch
decl_stmt|;
comment|/* For local searches. */
if|if
condition|(
name|objc
operator|!=
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|listObjPtr
operator|=
name|Tcl_NewListObj
argument_list|(
literal|0
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|hTblPtr
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|slaveInterp
argument_list|,
literal|"tclHiddenCmds"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hTblPtr
operator|!=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
condition|)
block|{
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|hTblPtr
argument_list|,
operator|&
name|hSearch
argument_list|)
init|;
name|hPtr
operator|!=
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|hSearch
argument_list|)
control|)
block|{
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|listObjPtr
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|Tcl_GetHashKey
argument_list|(
name|hTblPtr
argument_list|,
name|hPtr
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|listObjPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SlaveIsSafeHelper --  *  *	Helper function to compute whether a slave interpreter is safe.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SlaveIsSafeHelper
parameter_list|(
name|interp
parameter_list|,
name|slaveInterp
parameter_list|,
name|slavePtr
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* The slave interpreter. */
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Its slave record. */
name|int
name|objc
decl_stmt|;
comment|/* Count of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Vector of arguments. */
block|{
name|Tcl_Obj
modifier|*
name|resultPtr
decl_stmt|;
comment|/* Local object pointer. */
if|if
condition|(
name|objc
operator|>
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|resultPtr
operator|=
name|Tcl_NewIntObj
argument_list|(
name|Tcl_IsSafe
argument_list|(
name|slaveInterp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|resultPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SlaveInvokeHiddenHelper --  *  *	Helper function to invoke a hidden command in a slave interpreter.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Whatever the hidden command does.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SlaveInvokeHiddenHelper
parameter_list|(
name|interp
parameter_list|,
name|slaveInterp
parameter_list|,
name|slavePtr
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* The slave interpreter. */
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Its slave record. */
name|int
name|objc
decl_stmt|;
comment|/* Count of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Vector of arguments. */
block|{
name|Interp
modifier|*
name|iPtr
decl_stmt|;
name|Master
modifier|*
name|masterPtr
decl_stmt|;
name|int
name|doGlobal
init|=
literal|0
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|Tcl_Obj
modifier|*
name|namePtr
decl_stmt|,
modifier|*
name|objPtr
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?-global? cmd ?arg ..?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_IsSafe
argument_list|(
name|interp
argument_list|)
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"not allowed to invoke hidden commands from safe interpreter"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
literal|"-global"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|doGlobal
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|objc
operator|<
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"path ?-global? cmd ?arg ..?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|slaveInterp
argument_list|,
literal|"tclMasterRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterPtr
operator|==
operator|(
name|Master
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"SlaveObjectCmd: could not find master record"
argument_list|)
expr_stmt|;
block|}
name|Tcl_Preserve
argument_list|(
operator|(
name|ClientData
operator|)
name|slaveInterp
argument_list|)
expr_stmt|;
if|if
condition|(
name|doGlobal
condition|)
block|{
name|result
operator|=
name|TclObjInvokeGlobal
argument_list|(
name|slaveInterp
argument_list|,
name|objc
operator|-
literal|3
argument_list|,
name|objv
operator|+
literal|3
argument_list|,
name|TCL_INVOKE_HIDDEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|TclObjInvoke
argument_list|(
name|slaveInterp
argument_list|,
name|objc
operator|-
literal|2
argument_list|,
name|objv
operator|+
literal|2
argument_list|,
name|TCL_INVOKE_HIDDEN
argument_list|)
expr_stmt|;
block|}
comment|/*      * Now make the result and any error information accessible. We      * have to be careful because the slave interpreter and the current      * interpreter can be the same - do not destroy the result.. This      * can happen if an interpreter contains an alias which is directed      * at a target command in the same interpreter.      */
if|if
condition|(
name|interp
operator|!=
name|slaveInterp
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
comment|/*              * An error occurred, so transfer error information from              * the target interpreter back to our interpreter.              */
name|iPtr
operator|=
operator|(
name|Interp
operator|*
operator|)
name|slaveInterp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|iPtr
operator|->
name|flags
operator|&
name|ERR_ALREADY_LOGGED
operator|)
condition|)
block|{
name|Tcl_AddErrorInfo
argument_list|(
name|slaveInterp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|iPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|ERR_ALREADY_LOGGED
operator|)
operator|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|namePtr
operator|=
name|Tcl_NewStringObj
argument_list|(
literal|"errorInfo"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|objPtr
operator|=
name|Tcl_ObjGetVar2
argument_list|(
name|slaveInterp
argument_list|,
name|namePtr
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|string
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|Tcl_GetVar2
argument_list|(
name|slaveInterp
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
block|}
comment|/*          * Move the result object from the slave to the master.          */
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|slaveInterp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|slaveInterp
argument_list|)
expr_stmt|;
block|}
name|Tcl_Release
argument_list|(
operator|(
name|ClientData
operator|)
name|slaveInterp
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SlaveMarkTrustedHelper --  *  *	Helper function to mark a slave interpreter as trusted (unsafe).  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	After this call the hard-wired security checks in the core no  *	longer prevent the slave from performing certain operations.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SlaveMarkTrustedHelper
parameter_list|(
name|interp
parameter_list|,
name|slaveInterp
parameter_list|,
name|slavePtr
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* The slave interpreter. */
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Its slave record. */
name|int
name|objc
decl_stmt|;
comment|/* Count of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Vector of arguments. */
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_IsSafe
argument_list|(
name|interp
argument_list|)
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"\""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|0
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
literal|" marktrusted\""
argument_list|,
literal|" can only be invoked from a trusted interpreter"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|MarkTrusted
argument_list|(
name|slaveInterp
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SlaveObjectCmd --  *  *	Command to manipulate an interpreter, e.g. to send commands to it  *	to be evaluated. One such command exists for each slave interpreter.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See user documentation for details.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SlaveObjectCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Slave interpreter. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* The argument vector. */
block|{
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Slave record. */
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* Slave interpreter. */
name|int
name|result
decl_stmt|;
comment|/* Loop counter, status return. */
name|int
name|len
decl_stmt|;
comment|/* Length of command name. */
comment|/*      * These are all the different subcommands for this command:      */
specifier|static
name|char
modifier|*
name|subCmds
index|[]
init|=
block|{
literal|"alias"
block|,
literal|"aliases"
block|,
literal|"eval"
block|,
literal|"expose"
block|,
literal|"hide"
block|,
literal|"hidden"
block|,
literal|"issafe"
block|,
literal|"invokehidden"
block|,
literal|"marktrusted"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
enum|enum
name|ISubCmdIdx
block|{
name|IAliasIdx
block|,
name|IAliasesIdx
block|,
name|IEvalIdx
block|,
name|IExposeIdx
block|,
name|IHideIdx
block|,
name|IHiddenIdx
block|,
name|IIsSafeIdx
block|,
name|IInvokeHiddenIdx
block|,
name|IMarkTrustedIdx
block|}
name|index
enum|;
if|if
condition|(
name|objc
operator|<
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"cmd ?arg ...?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|slaveInterp
operator|=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|clientData
expr_stmt|;
if|if
condition|(
name|slaveInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"interpreter "
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|0
index|]
argument_list|,
operator|&
name|len
argument_list|)
argument_list|,
literal|" has been deleted"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|slaveInterp
argument_list|,
literal|"tclSlaveRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slavePtr
operator|==
operator|(
name|Slave
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"SlaveObjectCmd: could not find slave record"
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|Tcl_GetIndexFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|,
name|subCmds
argument_list|,
literal|"option"
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|IAliasIdx
case|:
return|return
name|SlaveAliasHelper
argument_list|(
name|interp
argument_list|,
name|slaveInterp
argument_list|,
name|slavePtr
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
case|case
name|IAliasesIdx
case|:
return|return
name|SlaveAliasesHelper
argument_list|(
name|interp
argument_list|,
name|slaveInterp
argument_list|,
name|slavePtr
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
case|case
name|IEvalIdx
case|:
return|return
name|SlaveEvalHelper
argument_list|(
name|interp
argument_list|,
name|slaveInterp
argument_list|,
name|slavePtr
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
case|case
name|IExposeIdx
case|:
return|return
name|SlaveExposeHelper
argument_list|(
name|interp
argument_list|,
name|slaveInterp
argument_list|,
name|slavePtr
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
case|case
name|IHideIdx
case|:
return|return
name|SlaveHideHelper
argument_list|(
name|interp
argument_list|,
name|slaveInterp
argument_list|,
name|slavePtr
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
case|case
name|IHiddenIdx
case|:
return|return
name|SlaveHiddenHelper
argument_list|(
name|interp
argument_list|,
name|slaveInterp
argument_list|,
name|slavePtr
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
case|case
name|IIsSafeIdx
case|:
return|return
name|SlaveIsSafeHelper
argument_list|(
name|interp
argument_list|,
name|slaveInterp
argument_list|,
name|slavePtr
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
case|case
name|IInvokeHiddenIdx
case|:
return|return
name|SlaveInvokeHiddenHelper
argument_list|(
name|interp
argument_list|,
name|slaveInterp
argument_list|,
name|slavePtr
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
case|case
name|IMarkTrustedIdx
case|:
return|return
name|SlaveMarkTrustedHelper
argument_list|(
name|interp
argument_list|,
name|slaveInterp
argument_list|,
name|slavePtr
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SlaveObjectDeleteProc --  *  *	Invoked when an object command for a slave interpreter is deleted;  *	cleans up all state associated with the slave interpreter and destroys  *	the slave interpreter.  *  * Results:  *	None.  *  * Side effects:  *	Cleans up all state associated with the slave interpreter and  *	destroys the slave interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|SlaveObjectDeleteProc
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* The SlaveRecord for the command. */
block|{
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Interim storage for Slave record. */
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* And for a slave interp. */
name|slaveInterp
operator|=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|clientData
expr_stmt|;
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|slaveInterp
argument_list|,
literal|"tclSlaveRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slavePtr
operator|==
operator|(
name|Slave
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"SlaveObjectDeleteProc: could not find slave record"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Delete the entry in the slave table in the master interpreter now.      * This is to avoid an infinite loop in the Master hash table cleanup in      * the master interpreter. This can happen if this slave is being deleted      * because the master is being deleted and the slave deletion is deferred      * because it is still active.      */
name|Tcl_DeleteHashEntry
argument_list|(
name|slavePtr
operator|->
name|slaveEntry
argument_list|)
expr_stmt|;
comment|/*      * Set to NULL so that when the slave record is cleaned up in the slave      * it does not try to delete the command causing all sorts of grief.      * See SlaveRecordDeleteProc().      */
name|slavePtr
operator|->
name|interpCmd
operator|=
name|NULL
expr_stmt|;
comment|/*      * Destroy the interpreter - this will cause all the deleteProcs for      * all commands (including aliases) to run.      *      * NOTE: WE ASSUME THAT THE INTERPRETER HAS NOT BEEN DELETED YET!!      */
name|Tcl_DeleteInterp
argument_list|(
name|slavePtr
operator|->
name|slaveInterp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * AliasCmd --  *  *	This is the procedure that services invocations of aliases in a  *	slave interpreter. One such command exists for each alias. When  *	invoked, this procedure redirects the invocation to the target  *	command in the master interpreter as designated by the Alias  *	record associated with this command.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Causes forwarding of the invocation; all possible side effects  *	may occur as a result of invoking the command to which the  *	invocation is forwarded.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|AliasCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Alias record. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|objc
decl_stmt|;
comment|/* Number of arguments. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument vector. */
block|{
name|Tcl_Interp
modifier|*
name|targetInterp
decl_stmt|;
comment|/* Target for alias exec. */
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Internal type of target. */
name|Alias
modifier|*
name|aliasPtr
decl_stmt|;
comment|/* Describes the alias. */
name|Tcl_Command
name|cmd
decl_stmt|;
comment|/* The target command. */
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
comment|/* Points to target command. */
name|Tcl_Namespace
modifier|*
name|targetNsPtr
decl_stmt|;
comment|/* Target command's namespace. */
name|int
name|result
decl_stmt|;
comment|/* Result of execution. */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|addObjc
decl_stmt|;
comment|/* Loop counters. */
name|int
name|localObjc
decl_stmt|;
comment|/* Local argument count. */
name|Tcl_Obj
modifier|*
modifier|*
name|localObjv
decl_stmt|;
comment|/* Local argument vector. */
name|Tcl_Obj
modifier|*
name|namePtr
decl_stmt|,
modifier|*
name|objPtr
decl_stmt|;
comment|/* Local object pointers. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Local object string rep. */
name|int
name|len
decl_stmt|;
comment|/* Dummy length arg. */
name|aliasPtr
operator|=
operator|(
name|Alias
operator|*
operator|)
name|clientData
expr_stmt|;
name|targetInterp
operator|=
name|aliasPtr
operator|->
name|targetInterp
expr_stmt|;
comment|/*      * Look for the target command in the global namespace of the target      * interpreter.      */
name|cmdPtr
operator|=
name|NULL
expr_stmt|;
name|targetNsPtr
operator|=
name|Tcl_GetGlobalNamespace
argument_list|(
name|aliasPtr
operator|->
name|targetInterp
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|Tcl_FindCommand
argument_list|(
name|targetInterp
argument_list|,
name|aliasPtr
operator|->
name|targetName
argument_list|,
name|targetNsPtr
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
operator|(
name|Tcl_Command
operator|)
name|NULL
condition|)
block|{
name|cmdPtr
operator|=
operator|(
name|Command
operator|*
operator|)
name|cmd
expr_stmt|;
block|}
name|iPtr
operator|=
operator|(
name|Interp
operator|*
operator|)
name|targetInterp
expr_stmt|;
comment|/*      * If the command does not exist, invoke "unknown" in the master.      */
if|if
condition|(
name|cmdPtr
operator|==
name|NULL
condition|)
block|{
name|addObjc
operator|=
name|aliasPtr
operator|->
name|objc
expr_stmt|;
name|localObjc
operator|=
name|addObjc
operator|+
name|objc
operator|+
literal|1
expr_stmt|;
name|localObjv
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
operator|*
name|localObjc
argument_list|)
expr_stmt|;
name|localObjv
index|[
literal|0
index|]
operator|=
name|Tcl_NewStringObj
argument_list|(
literal|"unknown"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|localObjv
index|[
literal|1
index|]
operator|=
name|Tcl_NewStringObj
argument_list|(
name|aliasPtr
operator|->
name|targetName
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|localObjv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|localObjv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|2
init|;
name|i
operator|<
name|addObjc
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|localObjv
index|[
name|j
index|]
operator|=
name|aliasPtr
operator|->
name|objv
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|localObjv
index|[
name|j
index|]
operator|=
name|objv
index|[
name|i
index|]
expr_stmt|;
block|}
name|Tcl_Preserve
argument_list|(
operator|(
name|ClientData
operator|)
name|targetInterp
argument_list|)
expr_stmt|;
name|result
operator|=
name|TclObjInvoke
argument_list|(
name|targetInterp
argument_list|,
name|localObjc
argument_list|,
name|localObjv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|localObjv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|localObjv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|localObjv
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetInterp
operator|!=
name|interp
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
comment|/*                  * An error occurred, so transfer error information from                  * the target interpreter back to our interpreter.                  */
if|if
condition|(
operator|!
operator|(
name|iPtr
operator|->
name|flags
operator|&
name|ERR_ALREADY_LOGGED
operator|)
condition|)
block|{
name|Tcl_AddErrorInfo
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|iPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|ERR_ALREADY_LOGGED
operator|)
operator|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|namePtr
operator|=
name|Tcl_NewStringObj
argument_list|(
literal|"errorInfo"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|objPtr
operator|=
name|Tcl_ObjGetVar2
argument_list|(
name|targetInterp
argument_list|,
name|namePtr
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|string
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|Tcl_GetVar2
argument_list|(
name|targetInterp
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
block|}
comment|/*              * Transfer the result from the target interpreter to the              * calling interpreter.              */
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|targetInterp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|targetInterp
argument_list|)
expr_stmt|;
block|}
name|Tcl_Release
argument_list|(
operator|(
name|ClientData
operator|)
name|targetInterp
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/*      * Otherwise invoke the regular target command.      */
if|if
condition|(
name|aliasPtr
operator|->
name|objc
operator|<=
literal|0
condition|)
block|{
name|localObjv
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|objv
expr_stmt|;
name|localObjc
operator|=
name|objc
expr_stmt|;
block|}
else|else
block|{
name|addObjc
operator|=
name|aliasPtr
operator|->
name|objc
expr_stmt|;
name|localObjc
operator|=
name|objc
operator|+
name|addObjc
expr_stmt|;
name|localObjv
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
operator|*
name|localObjc
argument_list|)
expr_stmt|;
name|localObjv
index|[
literal|0
index|]
operator|=
name|objv
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|1
init|;
name|i
operator|<
name|addObjc
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|localObjv
index|[
name|j
index|]
operator|=
name|aliasPtr
operator|->
name|objv
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|localObjv
index|[
name|j
index|]
operator|=
name|objv
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|iPtr
operator|->
name|numLevels
operator|++
expr_stmt|;
name|Tcl_Preserve
argument_list|(
operator|(
name|ClientData
operator|)
name|targetInterp
argument_list|)
expr_stmt|;
comment|/*      * Reset the interpreter to its clean state; we do not know what state      * it is in now..      */
name|Tcl_ResetResult
argument_list|(
name|targetInterp
argument_list|)
expr_stmt|;
name|result
operator|=
call|(
name|cmdPtr
operator|->
name|objProc
call|)
argument_list|(
name|cmdPtr
operator|->
name|objClientData
argument_list|,
name|targetInterp
argument_list|,
name|localObjc
argument_list|,
name|localObjv
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|numLevels
operator|--
expr_stmt|;
comment|/*      * Check if we are at the bottom of the stack for the target interpreter.      * If so, check for special return codes.      */
if|if
condition|(
name|iPtr
operator|->
name|numLevels
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_RETURN
condition|)
block|{
name|result
operator|=
name|TclUpdateReturnInfo
argument_list|(
name|iPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|result
operator|!=
name|TCL_OK
operator|)
operator|&&
operator|(
name|result
operator|!=
name|TCL_ERROR
operator|)
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|targetInterp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_BREAK
condition|)
block|{
name|Tcl_SetObjResult
argument_list|(
name|targetInterp
argument_list|,
name|Tcl_NewStringObj
argument_list|(
literal|"invoked \"break\" outside of a loop"
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|TCL_CONTINUE
condition|)
block|{
name|Tcl_SetObjResult
argument_list|(
name|targetInterp
argument_list|,
name|Tcl_NewStringObj
argument_list|(
literal|"invoked \"continue\" outside of a loop"
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"command returned bad code: %d"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|Tcl_SetObjResult
argument_list|(
name|targetInterp
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
block|}
comment|/*      * Clean up any locally allocated argument vector structure.      */
if|if
condition|(
name|localObjv
operator|!=
name|objv
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|localObjv
argument_list|)
expr_stmt|;
block|}
comment|/*      * Move the result from the target interpreter to the invoking      * interpreter if they are different.      *      * Note: We cannot use aliasPtr any more because the alias may have      * been deleted.      */
if|if
condition|(
name|interp
operator|!=
name|targetInterp
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
comment|/*              * An error occurred, so transfer the error information from              * the target interpreter back to our interpreter.              */
if|if
condition|(
operator|!
operator|(
name|iPtr
operator|->
name|flags
operator|&
name|ERR_ALREADY_LOGGED
operator|)
condition|)
block|{
name|Tcl_AddErrorInfo
argument_list|(
name|targetInterp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|iPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|ERR_ALREADY_LOGGED
operator|)
operator|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|namePtr
operator|=
name|Tcl_NewStringObj
argument_list|(
literal|"errorInfo"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|objPtr
operator|=
name|Tcl_ObjGetVar2
argument_list|(
name|targetInterp
argument_list|,
name|namePtr
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|string
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|Tcl_AddObjErrorInfo
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|Tcl_GetVar2
argument_list|(
name|targetInterp
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
block|}
comment|/*          * Move the result object from one interpreter to the          * other.          */
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|targetInterp
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|targetInterp
argument_list|)
expr_stmt|;
block|}
name|Tcl_Release
argument_list|(
operator|(
name|ClientData
operator|)
name|targetInterp
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * AliasCmdDeleteProc --  *  *	Is invoked when an alias command is deleted in a slave. Cleans up  *	all storage associated with this alias.  *  * Results:  *	None.  *  * Side effects:  *	Deletes the alias record and its entry in the alias table for  *	the interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|AliasCmdDeleteProc
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* The alias record for this alias. */
block|{
name|Alias
modifier|*
name|aliasPtr
decl_stmt|;
comment|/* Alias record for alias to delete. */
name|Target
modifier|*
name|targetPtr
decl_stmt|;
comment|/* Record for target of this alias. */
name|int
name|i
decl_stmt|;
comment|/* Loop counter. */
name|aliasPtr
operator|=
operator|(
name|Alias
operator|*
operator|)
name|clientData
expr_stmt|;
name|targetPtr
operator|=
operator|(
name|Target
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|aliasPtr
operator|->
name|targetEntry
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|targetPtr
argument_list|)
expr_stmt|;
name|Tcl_DeleteHashEntry
argument_list|(
name|aliasPtr
operator|->
name|targetEntry
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aliasPtr
operator|->
name|targetName
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aliasPtr
operator|->
name|aliasName
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|aliasPtr
operator|->
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|aliasPtr
operator|->
name|objv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aliasPtr
operator|->
name|objv
operator|!=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aliasPtr
operator|->
name|objv
argument_list|)
expr_stmt|;
block|}
name|Tcl_DeleteHashEntry
argument_list|(
name|aliasPtr
operator|->
name|aliasEntry
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aliasPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * MasterRecordDeleteProc -  *  *	Is invoked when an interpreter (which is using the "interp" facility)  *	is deleted, and it cleans up the storage associated with the  *	"tclMasterRecord" assoc-data entry.  *  * Results:  *	None.  *  * Side effects:  *	Cleans up storage.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|MasterRecordDeleteProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Master record for deleted interp. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter being deleted. */
block|{
name|Target
modifier|*
name|targetPtr
decl_stmt|;
comment|/* Loop variable. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Search element. */
name|Tcl_HashSearch
name|hSearch
decl_stmt|;
comment|/* Search record (internal). */
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Loop variable. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Interim storage. */
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|clientData
expr_stmt|;
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|slaveTable
operator|)
argument_list|,
operator|&
name|hSearch
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|hSearch
argument_list|)
control|)
block|{
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Tcl_DeleteCommandFromToken
argument_list|(
name|interp
argument_list|,
name|slavePtr
operator|->
name|interpCmd
argument_list|)
expr_stmt|;
block|}
name|Tcl_DeleteHashTable
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|slaveTable
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|targetTable
operator|)
argument_list|,
operator|&
name|hSearch
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|targetTable
operator|)
argument_list|,
operator|&
name|hSearch
argument_list|)
control|)
block|{
name|targetPtr
operator|=
operator|(
name|Target
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Tcl_DeleteCommandFromToken
argument_list|(
name|targetPtr
operator|->
name|slaveInterp
argument_list|,
name|targetPtr
operator|->
name|slaveCmd
argument_list|)
expr_stmt|;
block|}
name|Tcl_DeleteHashTable
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|targetTable
operator|)
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|masterPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SlaveRecordDeleteProc --  *  *	Is invoked when an interpreter (which is using the interp facility)  *	is deleted, and it cleans up the storage associated with the  *	tclSlaveRecord assoc-data entry.  *  * Results:  *	None  *  * Side effects:  *	Cleans up storage.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|SlaveRecordDeleteProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Slave record for deleted interp. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter being deleted. */
block|{
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Interim storage. */
name|Alias
modifier|*
name|aliasPtr
decl_stmt|;
name|Tcl_HashTable
modifier|*
name|hTblPtr
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|Tcl_HashSearch
name|hSearch
decl_stmt|;
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|clientData
expr_stmt|;
comment|/*      * In every case that we call SetAssocData on "tclSlaveRecord",      * slavePtr is not NULL. Otherwise we panic.      */
if|if
condition|(
name|slavePtr
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"SlaveRecordDeleteProc: NULL slavePtr"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|slavePtr
operator|->
name|interpCmd
operator|!=
operator|(
name|Tcl_Command
operator|)
name|NULL
condition|)
block|{
name|Command
modifier|*
name|cmdPtr
init|=
operator|(
name|Command
operator|*
operator|)
name|slavePtr
operator|->
name|interpCmd
decl_stmt|;
comment|/* 	 * The interpCmd has not been deleted in the master yet,  since 	 * it's callback sets interpCmd to NULL. 	 * 	 * Probably Tcl_DeleteInterp() was called on this interpreter directly, 	 * rather than via "interp delete", or equivalent (deletion of the 	 * command in the master). 	 * 	 * Perform the cleanup done by SlaveObjectDeleteProc() directly, 	 * and turn off the callback now (since we are about to free slavePtr 	 * and this interpreter is going away, while the deletion of commands 	 * in the master may be deferred). 	 */
name|Tcl_DeleteHashEntry
argument_list|(
name|slavePtr
operator|->
name|slaveEntry
argument_list|)
expr_stmt|;
name|cmdPtr
operator|->
name|clientData
operator|=
name|NULL
expr_stmt|;
name|cmdPtr
operator|->
name|deleteProc
operator|=
name|NULL
expr_stmt|;
name|cmdPtr
operator|->
name|deleteData
operator|=
name|NULL
expr_stmt|;
name|Tcl_DeleteCommandFromToken
argument_list|(
name|slavePtr
operator|->
name|masterInterp
argument_list|,
name|slavePtr
operator|->
name|interpCmd
argument_list|)
expr_stmt|;
block|}
comment|/*      * If there are any aliases, delete those now. This removes any      * dependency on the order of deletion between commands and the      * slave record.      */
name|hTblPtr
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
operator|&
operator|(
name|slavePtr
operator|->
name|aliasTable
operator|)
expr_stmt|;
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|hTblPtr
argument_list|,
operator|&
name|hSearch
argument_list|)
init|;
name|hPtr
operator|!=
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|hTblPtr
argument_list|,
operator|&
name|hSearch
argument_list|)
control|)
block|{
name|aliasPtr
operator|=
operator|(
name|Alias
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
comment|/*          * The call to Tcl_DeleteCommand will release the storage          * occupied by the hash entry and the alias record.          */
name|Tcl_DeleteCommandFromToken
argument_list|(
name|interp
argument_list|,
name|aliasPtr
operator|->
name|slaveCmd
argument_list|)
expr_stmt|;
block|}
comment|/*      * Finally dispose of the hash table and the slave record.      */
name|Tcl_DeleteHashTable
argument_list|(
name|hTblPtr
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|slavePtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclInterpInit --  *  *	Initializes the invoking interpreter for using the "interp"  *	facility. This is called from inside Tcl_Init.  *  * Results:  *	None.  *  * Side effects:  *	Adds the "interp" command to an interpreter and initializes several  *	records in the associated data of the invoking interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclInterpInit
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to initialize. */
block|{
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Its Master record. */
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* And its slave record. */
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|Master
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|slaveTable
operator|)
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|targetTable
operator|)
argument_list|,
name|TCL_ONE_WORD_KEYS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Tcl_SetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclMasterRecord"
argument_list|,
name|MasterRecordDeleteProc
argument_list|,
operator|(
name|ClientData
operator|)
name|masterPtr
argument_list|)
expr_stmt|;
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|Slave
argument_list|)
argument_list|)
expr_stmt|;
name|slavePtr
operator|->
name|masterInterp
operator|=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
expr_stmt|;
name|slavePtr
operator|->
name|slaveEntry
operator|=
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
expr_stmt|;
name|slavePtr
operator|->
name|slaveInterp
operator|=
name|interp
expr_stmt|;
name|slavePtr
operator|->
name|interpCmd
operator|=
operator|(
name|Tcl_Command
operator|)
name|NULL
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
operator|&
operator|(
name|slavePtr
operator|->
name|aliasTable
operator|)
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Tcl_SetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclSlaveRecord"
argument_list|,
name|SlaveRecordDeleteProc
argument_list|,
operator|(
name|ClientData
operator|)
name|slavePtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_IsSafe --  *  *	Determines whether an interpreter is safe  *  * Results:  *	1 if it is safe, 0 if it is not.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_IsSafe
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Is this interpreter "safe" ? */
block|{
name|Interp
modifier|*
name|iPtr
decl_stmt|;
if|if
condition|(
name|interp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
name|iPtr
operator|=
operator|(
name|Interp
operator|*
operator|)
name|interp
expr_stmt|;
return|return
operator|(
operator|(
name|iPtr
operator|->
name|flags
operator|)
operator|&
name|SAFE_INTERP
operator|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CreateSlave --  *  *	Creates a slave interpreter. The slavePath argument denotes the  *	name of the new slave relative to the current interpreter; the  *	slave is a direct descendant of the one-before-last component of  *	the path, e.g. it is a descendant of the current interpreter if  *	the slavePath argument contains only one component. Optionally makes  *	the slave interpreter safe.  *  * Results:  *	Returns the interpreter structure created, or NULL if an error  *	occurred.  *  * Side effects:  *	Creates a new interpreter and a new interpreter object command in  *	the interpreter indicated by the slavePath argument.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Interp
modifier|*
name|Tcl_CreateSlave
parameter_list|(
name|interp
parameter_list|,
name|slavePath
parameter_list|,
name|isSafe
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to start search at. */
name|char
modifier|*
name|slavePath
decl_stmt|;
comment|/* Name of slave to create. */
name|int
name|isSafe
decl_stmt|;
comment|/* Should new slave be "safe" ? */
block|{
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record for same. */
if|if
condition|(
operator|(
name|interp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
operator|)
operator|||
operator|(
name|slavePath
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclMasterRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterPtr
operator|==
operator|(
name|Master
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"CreatSlave: could not find master record"
argument_list|)
expr_stmt|;
block|}
return|return
name|CreateSlave
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|slavePath
argument_list|,
name|isSafe
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetSlave --  *  *	Finds a slave interpreter by its path name.  *  * Results:  *	Returns a Tcl_Interp * for the named interpreter or NULL if not  *	found.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Interp
modifier|*
name|Tcl_GetSlave
parameter_list|(
name|interp
parameter_list|,
name|slavePath
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to start search from. */
name|char
modifier|*
name|slavePath
decl_stmt|;
comment|/* Path of slave to find. */
block|{
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Interim storage for Master record. */
if|if
condition|(
operator|(
name|interp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
operator|)
operator|||
operator|(
name|slavePath
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclMasterRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterPtr
operator|==
operator|(
name|Master
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_GetSlave: could not find master record"
argument_list|)
expr_stmt|;
block|}
return|return
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|slavePath
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetMaster --  *  *	Finds the master interpreter of a slave interpreter.  *  * Results:  *	Returns a Tcl_Interp * for the master interpreter or NULL if none.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Interp
modifier|*
name|Tcl_GetMaster
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Get the master of this interpreter. */
block|{
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Slave record of this interpreter. */
if|if
condition|(
name|interp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclSlaveRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slavePtr
operator|==
operator|(
name|Slave
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|slavePtr
operator|->
name|masterInterp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CreateAlias --  *  *	Creates an alias between two interpreters.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Creates a new alias, manipulates the result field of slaveInterp.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_CreateAlias
parameter_list|(
name|slaveInterp
parameter_list|,
name|slaveCmd
parameter_list|,
name|targetInterp
parameter_list|,
name|targetCmd
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* Interpreter for source command. */
name|char
modifier|*
name|slaveCmd
decl_stmt|;
comment|/* Command to install in slave. */
name|Tcl_Interp
modifier|*
name|targetInterp
decl_stmt|;
comment|/* Interpreter for target command. */
name|char
modifier|*
name|targetCmd
decl_stmt|;
comment|/* Name of target command. */
name|int
name|argc
decl_stmt|;
comment|/* How many additional arguments? */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* These are the additional args. */
block|{
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record for target interp. */
name|Tcl_Obj
modifier|*
modifier|*
name|objv
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|slaveInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
operator|)
operator|||
operator|(
name|targetInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
operator|)
operator|||
operator|(
name|slaveCmd
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
operator|||
operator|(
name|targetCmd
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|targetInterp
argument_list|,
literal|"tclMasterRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterPtr
operator|==
operator|(
name|Master
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_CreateAlias: could not find master record"
argument_list|)
expr_stmt|;
block|}
name|objv
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
operator|*
name|argc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|objv
index|[
name|i
index|]
operator|=
name|Tcl_NewStringObj
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|AliasCreationHelper
argument_list|(
name|slaveInterp
argument_list|,
name|slaveInterp
argument_list|,
name|targetInterp
argument_list|,
name|masterPtr
argument_list|,
name|slaveCmd
argument_list|,
name|targetCmd
argument_list|,
name|argc
argument_list|,
name|objv
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|objv
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CreateAliasObj --  *  *	Object version: Creates an alias between two interpreters.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Creates a new alias.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_CreateAliasObj
parameter_list|(
name|slaveInterp
parameter_list|,
name|slaveCmd
parameter_list|,
name|targetInterp
parameter_list|,
name|targetCmd
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* Interpreter for source command. */
name|char
modifier|*
name|slaveCmd
decl_stmt|;
comment|/* Command to install in slave. */
name|Tcl_Interp
modifier|*
name|targetInterp
decl_stmt|;
comment|/* Interpreter for target command. */
name|char
modifier|*
name|targetCmd
decl_stmt|;
comment|/* Name of target command. */
name|int
name|objc
decl_stmt|;
comment|/* How many additional arguments? */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Argument vector. */
block|{
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record for target interp. */
if|if
condition|(
operator|(
name|slaveInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
operator|)
operator|||
operator|(
name|targetInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
operator|)
operator|||
operator|(
name|slaveCmd
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
operator|||
operator|(
name|targetCmd
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|targetInterp
argument_list|,
literal|"tclMasterRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterPtr
operator|==
operator|(
name|Master
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_CreateAlias: could not find master record"
argument_list|)
expr_stmt|;
block|}
return|return
name|AliasCreationHelper
argument_list|(
name|slaveInterp
argument_list|,
name|slaveInterp
argument_list|,
name|targetInterp
argument_list|,
name|masterPtr
argument_list|,
name|slaveCmd
argument_list|,
name|targetCmd
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetAlias --  *  *	Gets information about an alias.  *  * Results:  *	A standard Tcl result.   *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_GetAlias
parameter_list|(
name|interp
parameter_list|,
name|aliasName
parameter_list|,
name|targetInterpPtr
parameter_list|,
name|targetNamePtr
parameter_list|,
name|argcPtr
parameter_list|,
name|argvPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interp to start search from. */
name|char
modifier|*
name|aliasName
decl_stmt|;
comment|/* Name of alias to find. */
name|Tcl_Interp
modifier|*
modifier|*
name|targetInterpPtr
decl_stmt|;
comment|/* (Return) target interpreter. */
name|char
modifier|*
modifier|*
name|targetNamePtr
decl_stmt|;
comment|/* (Return) name of target command. */
name|int
modifier|*
name|argcPtr
decl_stmt|;
comment|/* (Return) count of addnl args. */
name|char
modifier|*
modifier|*
modifier|*
name|argvPtr
decl_stmt|;
comment|/* (Return) additional arguments. */
block|{
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Slave record for slave interp. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Search element. */
name|Alias
modifier|*
name|aliasPtr
decl_stmt|;
comment|/* Storage for alias found. */
name|int
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|interp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
operator|)
operator|||
operator|(
name|aliasName
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclSlaveRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slavePtr
operator|==
operator|(
name|Slave
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_GetAlias: could not find slave record"
argument_list|)
expr_stmt|;
block|}
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
operator|(
name|slavePtr
operator|->
name|aliasTable
operator|)
argument_list|,
name|aliasName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"alias \""
argument_list|,
name|aliasName
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|aliasPtr
operator|=
operator|(
name|Alias
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetInterpPtr
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
operator|*
name|targetInterpPtr
operator|=
name|aliasPtr
operator|->
name|targetInterp
expr_stmt|;
block|}
if|if
condition|(
name|targetNamePtr
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
operator|*
name|targetNamePtr
operator|=
name|aliasPtr
operator|->
name|targetName
expr_stmt|;
block|}
if|if
condition|(
name|argcPtr
operator|!=
operator|(
name|int
operator|*
operator|)
name|NULL
condition|)
block|{
operator|*
name|argcPtr
operator|=
name|aliasPtr
operator|->
name|objc
expr_stmt|;
block|}
if|if
condition|(
name|argvPtr
operator|!=
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
operator|*
name|argvPtr
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|aliasPtr
operator|->
name|objc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|aliasPtr
operator|->
name|objc
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|argvPtr
index|[
name|i
index|]
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|aliasPtr
operator|->
name|objv
index|[
name|i
index|]
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ObjGetAlias --  *  *	Object version: Gets information about an alias.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_GetAliasObj
parameter_list|(
name|interp
parameter_list|,
name|aliasName
parameter_list|,
name|targetInterpPtr
parameter_list|,
name|targetNamePtr
parameter_list|,
name|objcPtr
parameter_list|,
name|objvPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interp to start search from. */
name|char
modifier|*
name|aliasName
decl_stmt|;
comment|/* Name of alias to find. */
name|Tcl_Interp
modifier|*
modifier|*
name|targetInterpPtr
decl_stmt|;
comment|/* (Return) target interpreter. */
name|char
modifier|*
modifier|*
name|targetNamePtr
decl_stmt|;
comment|/* (Return) name of target command. */
name|int
modifier|*
name|objcPtr
decl_stmt|;
comment|/* (Return) count of addnl args. */
name|Tcl_Obj
modifier|*
modifier|*
modifier|*
name|objvPtr
decl_stmt|;
comment|/* (Return) additional args. */
block|{
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Slave record for slave interp. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Search element. */
name|Alias
modifier|*
name|aliasPtr
decl_stmt|;
comment|/* Storage for alias found. */
if|if
condition|(
operator|(
name|interp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
operator|)
operator|||
operator|(
name|aliasName
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclSlaveRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slavePtr
operator|==
operator|(
name|Slave
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_GetAlias: could not find slave record"
argument_list|)
expr_stmt|;
block|}
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
operator|(
name|slavePtr
operator|->
name|aliasTable
operator|)
argument_list|,
name|aliasName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"alias \""
argument_list|,
name|aliasName
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|aliasPtr
operator|=
operator|(
name|Alias
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetInterpPtr
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
operator|*
name|targetInterpPtr
operator|=
name|aliasPtr
operator|->
name|targetInterp
expr_stmt|;
block|}
if|if
condition|(
name|targetNamePtr
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
operator|*
name|targetNamePtr
operator|=
name|aliasPtr
operator|->
name|targetName
expr_stmt|;
block|}
if|if
condition|(
name|objcPtr
operator|!=
operator|(
name|int
operator|*
operator|)
name|NULL
condition|)
block|{
operator|*
name|objcPtr
operator|=
name|aliasPtr
operator|->
name|objc
expr_stmt|;
block|}
if|if
condition|(
name|objvPtr
operator|!=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
operator|*
name|objvPtr
operator|=
name|aliasPtr
operator|->
name|objv
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

end_unit

