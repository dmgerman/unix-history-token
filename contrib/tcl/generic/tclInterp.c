begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclInterp.c --  *  *	This file implements the "interp" command which allows creation  *	and manipulation of Tcl interpreters from within Tcl scripts.  *  * Copyright (c) 1995 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclInterp.c 1.73 96/06/11 18:14:22  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*  * Counter for how many aliases were created (global)  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|aliasCounter
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  * struct Slave:  *  * Used by the "interp" command to record and find information about slave  * interpreters. Maps from a command name in the master to information about  * a slave interpreter, e.g. what aliases are defined in it.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|Tcl_Interp
modifier|*
name|masterInterp
decl_stmt|;
comment|/* Master interpreter for this slave. */
name|Tcl_HashEntry
modifier|*
name|slaveEntry
decl_stmt|;
comment|/* Hash entry in masters slave table for                                  * this slave interpreter. Used to find                                  * this record, and used when deleting the                                  * slave interpreter to delete it from the                                  * masters table. */
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* The slave interpreter. */
name|Tcl_Command
name|interpCmd
decl_stmt|;
comment|/* Interpreter object command. */
name|Tcl_HashTable
name|aliasTable
decl_stmt|;
comment|/* Table which maps from names of commands                                  * in slave interpreter to struct Alias                                  * defined below. */
block|}
name|Slave
typedef|;
end_typedef

begin_comment
comment|/*  * struct Alias:  *  * Stores information about an alias. Is stored in the slave interpreter  * and used by the source command to find the target command in the master  * when the source command is invoked.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|aliasName
decl_stmt|;
comment|/* Name of alias command. */
name|char
modifier|*
name|targetName
decl_stmt|;
comment|/* Name of target command in master interp. */
name|Tcl_Interp
modifier|*
name|targetInterp
decl_stmt|;
comment|/* Master interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Count of additional args to pass. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Actual additional args to pass. */
name|Tcl_HashEntry
modifier|*
name|aliasEntry
decl_stmt|;
comment|/* Entry for the alias hash table in slave.                                  * This is used by alias deletion to remove                                  * the alias from the slave interpreter                                  * alias table. */
name|Tcl_HashEntry
modifier|*
name|targetEntry
decl_stmt|;
comment|/* Entry for target command in master.                                  * This is used in the master interpreter to                                  * map back from the target command to aliases                                  * redirecting to it. Random access to this                                  * hash table is never required - we are using                                  * a hash table only for convenience. */
name|Tcl_Command
name|slaveCmd
decl_stmt|;
comment|/* Source command in slave interpreter. */
block|}
name|Alias
typedef|;
end_typedef

begin_comment
comment|/*  * struct Target:  *  * Maps from master interpreter commands back to the source commands in slave  * interpreters. This is needed because aliases can be created between sibling  * interpreters and must be deleted when the target interpreter is deleted. In  * case they would not be deleted the source interpreter would be left with a  * "dangling pointer". One such record is stored in the Master record of the  * master interpreter (in the targetTable hashtable, see below) with the  * master for each alias which directs to a command in the master. These  * records are used to remove the source command for an from a slave if/when  * the master is deleted.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|Tcl_Command
name|slaveCmd
decl_stmt|;
comment|/* Command for alias in slave interp. */
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* Slave Interpreter. */
block|}
name|Target
typedef|;
end_typedef

begin_comment
comment|/*  * struct Master:  *  * This record is used for three purposes: First, slaveTable (a hashtable)  * maps from names of commands to slave interpreters. This hashtable is  * used to store information about slave interpreters of this interpreter,  * to map over all slaves, etc. The second purpose is to store information  * about all aliases in slaves (or siblings) which direct to target commands  * in this interpreter (using the targetTable hashtable). The third field in  * the record, isSafe, denotes whether the interpreter is safe or not. Safe  * interpreters have restricted functionality, can only create safe slave  * interpreters and can only load safe extensions.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|Tcl_HashTable
name|slaveTable
decl_stmt|;
comment|/* Hash table for slave interpreters.                                  * Maps from command names to Slave records. */
name|int
name|isSafe
decl_stmt|;
comment|/* Am I a "safe" interpreter? */
name|Tcl_HashTable
name|targetTable
decl_stmt|;
comment|/* Hash table for Target Records. Contains                                  * all Target records which denote aliases                                  * from slaves or sibling interpreters that                                  * direct to commands in this interpreter. This                                  * table is used to remove dangling pointers                                  * from the slave (or sibling) interpreters                                  * when this interpreter is deleted. */
block|}
name|Master
typedef|;
end_typedef

begin_comment
comment|/*  * Prototypes for local static procedures:  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|AliasCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|currentInterp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|AliasCmdDeleteProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|AliasHelper
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|curInterp
operator|,
name|Tcl_Interp
operator|*
name|slaveInterp
operator|,
name|Tcl_Interp
operator|*
name|masterInterp
operator|,
name|Master
operator|*
name|masterPtr
operator|,
name|char
operator|*
name|aliasName
operator|,
name|char
operator|*
name|targetName
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CreateInterpObject
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Tcl_Interp
modifier|*
name|CreateSlave
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|slavePath
operator|,
name|int
name|safe
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DeleteAlias
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Interp
operator|*
name|slaveInterp
operator|,
name|char
operator|*
name|aliasName
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DescribeAlias
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Interp
operator|*
name|slaveInterp
operator|,
name|char
operator|*
name|aliasName
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DeleteInterpObject
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DeleteOneInterpObject
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|path
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Tcl_Interp
modifier|*
name|GetInterp
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Master
operator|*
name|masterPtr
operator|,
name|char
operator|*
name|path
operator|,
name|Master
operator|*
operator|*
name|masterPtrPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|GetTarget
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|path
operator|,
name|char
operator|*
name|aliasName
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|MasterRecordDeleteProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|MakeSafe
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SlaveAliasHelper
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SlaveObjectCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|SlaveObjectDeleteProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|SlaveRecordDeleteProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  * These are all the Tcl core commands which are available in a safe  * interpeter:  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|TclCommandsToKeep
index|[]
init|=
block|{
literal|"after"
block|,
literal|"append"
block|,
literal|"array"
block|,
literal|"break"
block|,
literal|"case"
block|,
literal|"catch"
block|,
literal|"clock"
block|,
literal|"close"
block|,
literal|"concat"
block|,
literal|"continue"
block|,
literal|"eof"
block|,
literal|"error"
block|,
literal|"eval"
block|,
literal|"expr"
block|,
literal|"fblocked"
block|,
literal|"fileevent"
block|,
literal|"flush"
block|,
literal|"for"
block|,
literal|"foreach"
block|,
literal|"format"
block|,
literal|"gets"
block|,
literal|"global"
block|,
literal|"history"
block|,
literal|"if"
block|,
literal|"incr"
block|,
literal|"info"
block|,
literal|"interp"
block|,
literal|"join"
block|,
literal|"lappend"
block|,
literal|"lindex"
block|,
literal|"linsert"
block|,
literal|"list"
block|,
literal|"llength"
block|,
literal|"lower"
block|,
literal|"lrange"
block|,
literal|"lreplace"
block|,
literal|"lsearch"
block|,
literal|"lsort"
block|,
literal|"package"
block|,
literal|"pid"
block|,
literal|"proc"
block|,
literal|"puts"
block|,
literal|"read"
block|,
literal|"regexp"
block|,
literal|"regsub"
block|,
literal|"rename"
block|,
literal|"return"
block|,
literal|"scan"
block|,
literal|"seek"
block|,
literal|"set"
block|,
literal|"split"
block|,
literal|"string"
block|,
literal|"subst"
block|,
literal|"switch"
block|,
literal|"tell"
block|,
literal|"time"
block|,
literal|"trace"
block|,
literal|"unset"
block|,
literal|"unsupported0"
block|,
literal|"update"
block|,
literal|"uplevel"
block|,
literal|"upvar"
block|,
literal|"vwait"
block|,
literal|"while"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TclCommandsToKeepCt
init|=
operator|(
sizeof|sizeof
argument_list|(
name|TclCommandsToKeep
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclPreventAliasLoop --  *  *	When defining an alias or renaming a command, prevent an alias  *	loop from being formed.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	If TCL_ERROR is returned, the function also sets interp->result  *	to an error message.  *  * NOTE:  *	This function is public internal (instead of being static to  *	this file) because it is also used from Tcl_RenameCmd.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclPreventAliasLoop
parameter_list|(
name|interp
parameter_list|,
name|cmdInterp
parameter_list|,
name|cmdName
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interp in which to report errors. */
name|Tcl_Interp
modifier|*
name|cmdInterp
decl_stmt|;
comment|/* Interp in which the command is                                          * being defined. */
name|char
modifier|*
name|cmdName
decl_stmt|;
comment|/* Name of Tcl command we are                                          * attempting to define. */
name|Tcl_CmdProc
modifier|*
name|proc
decl_stmt|;
comment|/* The command procedure for the                                          * command being created. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* The client data associated with the                                          * command to be created. */
block|{
name|Alias
modifier|*
name|aliasPtr
decl_stmt|,
modifier|*
name|nextAliasPtr
decl_stmt|;
name|Tcl_CmdInfo
name|cmdInfo
decl_stmt|;
comment|/*      * If we are not creating or renaming an alias, then it is      * always OK to create or rename the command.      */
if|if
condition|(
name|proc
operator|!=
name|AliasCmd
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
comment|/*      * OK, we are dealing with an alias, so traverse the chain of aliases.      * If we encounter the alias we are defining (or renaming to) any in      * the chain then we have a loop.      */
name|aliasPtr
operator|=
operator|(
name|Alias
operator|*
operator|)
name|clientData
expr_stmt|;
name|nextAliasPtr
operator|=
name|aliasPtr
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/*          * If the target of the next alias in the chain is the same as the          * source alias, we have a loop.          */
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|nextAliasPtr
operator|->
name|targetName
argument_list|,
name|cmdName
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|nextAliasPtr
operator|->
name|targetInterp
operator|==
name|cmdInterp
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"cannot define or rename alias \""
argument_list|,
name|aliasPtr
operator|->
name|aliasName
argument_list|,
literal|"\": would create a loop"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*          * Otherwise, follow the chain one step further. If the target          * command is undefined then there is no loop.          */
if|if
condition|(
name|Tcl_GetCommandInfo
argument_list|(
name|nextAliasPtr
operator|->
name|targetInterp
argument_list|,
name|nextAliasPtr
operator|->
name|targetName
argument_list|,
operator|&
name|cmdInfo
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
comment|/*          * See if the target command is an alias - if so, follow the          * loop to its target command. Otherwise we do not have a loop.          */
if|if
condition|(
name|cmdInfo
operator|.
name|proc
operator|!=
name|AliasCmd
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
name|nextAliasPtr
operator|=
operator|(
name|Alias
operator|*
operator|)
name|cmdInfo
operator|.
name|clientData
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * MakeSafe --  *  *	Makes its argument interpreter contain only functionality that is  *	defined to be part of Safe Tcl.  *  * Results:  *	None.  *  * Side effects:  *	Removes commands from its argument interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|MakeSafe
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to be made safe. */
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Args for Tcl_Eval. */
name|int
name|argc
decl_stmt|,
name|keep
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Loop indices. */
name|char
modifier|*
name|cmdGetGlobalCmds
init|=
literal|"info commands"
decl_stmt|;
comment|/* What command to run. */
name|char
modifier|*
name|cmdNoEnv
init|=
literal|"unset env"
decl_stmt|;
comment|/* How to get rid of env. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record of interp                                                  * to be made safe. */
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* Channel to remove from                                                  * safe interpreter. */
comment|/*      * Below, Tcl_Eval sets interp->result, so we do not.      */
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|cmdGetGlobalCmds
argument_list|)
operator|==
name|TCL_ERROR
operator|)
operator|||
operator|(
name|Tcl_SplitList
argument_list|(
name|interp
argument_list|,
name|interp
operator|->
name|result
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
operator|!=
name|TCL_OK
operator|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|keep
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TclCommandsToKeepCt
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|TclCommandsToKeep
index|[
name|j
index|]
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|keep
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|keep
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|Tcl_DeleteCommand
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclMasterRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterPtr
operator|==
operator|(
name|Master
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"MakeSafe: could not find master record"
argument_list|)
expr_stmt|;
block|}
name|masterPtr
operator|->
name|isSafe
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|cmdNoEnv
argument_list|)
operator|==
name|TCL_ERROR
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Remove the standard channels from the interpreter; safe interpreters      * do not ordinarily have access to stdin, stdout and stderr.      */
name|chan
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|!=
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
name|Tcl_UnregisterChannel
argument_list|(
name|interp
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
name|chan
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|!=
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
name|Tcl_UnregisterChannel
argument_list|(
name|interp
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
name|chan
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|!=
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
name|Tcl_UnregisterChannel
argument_list|(
name|interp
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * GetInterp --  *  *	Helper function to find a slave interpreter given a pathname.  *  * Results:  *	Returns the slave interpreter known by that name in the calling  *	interpreter, or NULL if no interpreter known by that name exists.   *  * Side effects:  *	Assigns to the pointer variable passed in, if not NULL.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Tcl_Interp
modifier|*
name|GetInterp
parameter_list|(
name|interp
parameter_list|,
name|masterPtr
parameter_list|,
name|path
parameter_list|,
name|masterPtrPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interp. to start search from. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Its master record. */
name|char
modifier|*
name|path
decl_stmt|;
comment|/* The path (name) of interp. to be found. */
name|Master
modifier|*
modifier|*
name|masterPtrPtr
decl_stmt|;
comment|/* (Return) its master record. */
block|{
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Search element. */
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Interim slave record. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Split-up path (name) for interp to find. */
name|int
name|argc
decl_stmt|,
name|i
decl_stmt|;
comment|/* Loop indices. */
name|Tcl_Interp
modifier|*
name|searchInterp
decl_stmt|;
comment|/* Interim storage for interp. to find. */
if|if
condition|(
name|masterPtrPtr
operator|!=
operator|(
name|Master
operator|*
operator|*
operator|)
name|NULL
condition|)
operator|*
name|masterPtrPtr
operator|=
name|masterPtr
expr_stmt|;
if|if
condition|(
name|Tcl_SplitList
argument_list|(
name|interp
argument_list|,
name|path
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
return|;
block|}
for|for
control|(
name|searchInterp
operator|=
name|interp
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|slaveTable
operator|)
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
return|;
block|}
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
name|searchInterp
operator|=
name|slavePtr
operator|->
name|slaveInterp
expr_stmt|;
if|if
condition|(
name|searchInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
return|;
block|}
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|searchInterp
argument_list|,
literal|"tclMasterRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterPtrPtr
operator|!=
operator|(
name|Master
operator|*
operator|*
operator|)
name|NULL
condition|)
operator|*
name|masterPtrPtr
operator|=
name|masterPtr
expr_stmt|;
if|if
condition|(
name|masterPtr
operator|==
operator|(
name|Master
operator|*
operator|)
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
return|;
block|}
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
name|searchInterp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CreateSlave --  *  *	Helper function to do the actual work of creating a slave interp  *	and new object command. Also optionally makes the new slave  *	interpreter "safe".  *  * Results:  *	Returns the new Tcl_Interp * if successful or NULL if not. If failed,  *	the result of the invoking interpreter contains an error message.  *  * Side effects:  *	Creates a new slave interpreter and a new object command.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Tcl_Interp
modifier|*
name|CreateSlave
parameter_list|(
name|interp
parameter_list|,
name|slavePath
parameter_list|,
name|safe
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interp. to start search from. */
name|char
modifier|*
name|slavePath
decl_stmt|;
comment|/* Path (name) of slave to create. */
name|int
name|safe
decl_stmt|;
comment|/* Should we make it "safe"? */
block|{
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record. */
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* Ptr to slave interpreter. */
name|Tcl_Interp
modifier|*
name|masterInterp
decl_stmt|;
comment|/* Ptr to master interp for slave. */
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Slave record. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Entry into interp hashtable. */
name|int
name|new
decl_stmt|;
comment|/* Indicates whether new entry. */
name|int
name|argc
decl_stmt|;
comment|/* Count of elements in slavePath. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Elements in slavePath. */
name|char
modifier|*
name|masterPath
decl_stmt|;
comment|/* Path to its master. */
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclMasterRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterPtr
operator|==
operator|(
name|Master
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"CreatSlave: could not find master record"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Tcl_SplitList
argument_list|(
name|interp
argument_list|,
name|slavePath
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
return|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|masterInterp
operator|=
name|interp
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|slavePath
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|masterPath
operator|=
name|Tcl_Merge
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|masterInterp
operator|=
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|masterPath
argument_list|,
operator|&
name|masterPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"interpreter named \""
argument_list|,
name|masterPath
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|masterPath
argument_list|)
expr_stmt|;
return|return
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
return|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|masterPath
argument_list|)
expr_stmt|;
name|slavePath
operator|=
name|argv
index|[
name|argc
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|safe
condition|)
block|{
name|safe
operator|=
name|masterPtr
operator|->
name|isSafe
expr_stmt|;
block|}
block|}
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|slaveTable
operator|)
argument_list|,
name|slavePath
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"interpreter named \""
argument_list|,
name|slavePath
argument_list|,
literal|"\" already exists, cannot create"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
return|;
block|}
name|slaveInterp
operator|=
name|Tcl_CreateInterp
argument_list|()
expr_stmt|;
if|if
condition|(
name|slaveInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"CreateSlave: out of memory while creating a new interpreter"
argument_list|)
expr_stmt|;
block|}
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|Slave
argument_list|)
argument_list|)
expr_stmt|;
name|slavePtr
operator|->
name|masterInterp
operator|=
name|masterInterp
expr_stmt|;
name|slavePtr
operator|->
name|slaveEntry
operator|=
name|hPtr
expr_stmt|;
name|slavePtr
operator|->
name|slaveInterp
operator|=
name|slaveInterp
expr_stmt|;
name|slavePtr
operator|->
name|interpCmd
operator|=
name|Tcl_CreateCommand
argument_list|(
name|masterInterp
argument_list|,
name|slavePath
argument_list|,
name|SlaveObjectCmd
argument_list|,
operator|(
name|ClientData
operator|)
name|slaveInterp
argument_list|,
name|SlaveObjectDeleteProc
argument_list|)
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
operator|&
operator|(
name|slavePtr
operator|->
name|aliasTable
operator|)
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Tcl_SetAssocData
argument_list|(
name|slaveInterp
argument_list|,
literal|"tclSlaveRecord"
argument_list|,
name|SlaveRecordDeleteProc
argument_list|,
operator|(
name|ClientData
operator|)
name|slavePtr
argument_list|)
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
operator|(
name|ClientData
operator|)
name|slavePtr
argument_list|)
expr_stmt|;
name|Tcl_SetVar
argument_list|(
name|slaveInterp
argument_list|,
literal|"tcl_interactive"
argument_list|,
literal|"0"
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|safe
operator|)
operator|&&
operator|(
name|MakeSafe
argument_list|(
name|slaveInterp
argument_list|)
operator|==
name|TCL_ERROR
operator|)
operator|)
operator|||
operator|(
operator|(
operator|!
name|safe
operator|)
operator|&&
operator|(
name|Tcl_Init
argument_list|(
name|slaveInterp
argument_list|)
operator|==
name|TCL_ERROR
operator|)
operator|)
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
name|Tcl_GetVar2
argument_list|(
name|slaveInterp
argument_list|,
literal|"errorInfo"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|Tcl_GetVar2
argument_list|(
name|slaveInterp
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|slaveInterp
operator|->
name|freeProc
operator|!=
name|NULL
condition|)
block|{
name|interp
operator|->
name|result
operator|=
name|slaveInterp
operator|->
name|result
expr_stmt|;
name|interp
operator|->
name|freeProc
operator|=
name|slaveInterp
operator|->
name|freeProc
expr_stmt|;
name|slaveInterp
operator|->
name|freeProc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|slaveInterp
operator|->
name|result
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
name|Tcl_ResetResult
argument_list|(
name|slaveInterp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Tcl_DeleteCommand
argument_list|(
name|masterInterp
argument_list|,
name|slavePath
argument_list|)
expr_stmt|;
name|slaveInterp
operator|=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
name|slaveInterp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CreateInterpObject -  *  *	Helper function to do the actual work of creating a new interpreter  *	and an object command.   *  * Results:  *	A Tcl result.  *  * Side effects:  *	See user documentation for details.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CreateInterpObject
parameter_list|(
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Invoking interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|int
name|safe
decl_stmt|;
comment|/* Create a safe interpreter? */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record. */
name|int
name|moreFlags
decl_stmt|;
comment|/* Expecting more flag args? */
name|char
modifier|*
name|slavePath
decl_stmt|;
comment|/* Name of slave. */
name|char
name|localSlaveName
index|[
literal|200
index|]
decl_stmt|;
comment|/* Local area for creating names. */
name|int
name|i
decl_stmt|;
comment|/* Loop counter. */
name|size_t
name|len
decl_stmt|;
comment|/* Length of option argument. */
specifier|static
name|int
name|interpCounter
init|=
literal|0
decl_stmt|;
comment|/* Unique id for created names. */
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclMasterRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterPtr
operator|==
operator|(
name|Master
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"CreateInterpObject: could not find master record"
argument_list|)
expr_stmt|;
block|}
name|moreFlags
operator|=
literal|1
expr_stmt|;
name|slavePath
operator|=
name|NULL
expr_stmt|;
name|safe
operator|=
name|masterPtr
operator|->
name|isSafe
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
operator|||
name|argc
operator|>
literal|5
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" create ?-safe? ?--? ?path?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|moreFlags
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'s'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-safe"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|len
operator|>
literal|1
operator|)
condition|)
block|{
name|safe
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"--"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|len
operator|>
literal|1
operator|)
condition|)
block|{
name|moreFlags
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
literal|"\": should be -safe"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
else|else
block|{
name|slavePath
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|slavePath
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|localSlaveName
argument_list|,
literal|"interp%d"
argument_list|,
name|interpCounter
argument_list|)
expr_stmt|;
name|interpCounter
operator|++
expr_stmt|;
name|slavePath
operator|=
name|localSlaveName
expr_stmt|;
block|}
if|if
condition|(
name|CreateSlave
argument_list|(
name|interp
argument_list|,
name|slavePath
argument_list|,
name|safe
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|slavePath
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
else|else
block|{
comment|/*          * CreateSlave already set interp->result if there was an error,          * so we do not do it here.          */
return|return
name|TCL_ERROR
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DeleteOneInterpObject --  *  *	Helper function for DeleteInterpObject. It deals with deleting one  *	interpreter at a time.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Deletes an interpreter and its interpreter object command.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|DeleteOneInterpObject
parameter_list|(
name|interp
parameter_list|,
name|path
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter for reporting errors. */
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Path of interpreter to delete. */
block|{
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Interim storage for master record.*/
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Interim storage for slave record. */
name|Tcl_Interp
modifier|*
name|masterInterp
decl_stmt|;
comment|/* Master of interp. to delete. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Search element. */
name|int
name|localArgc
decl_stmt|;
comment|/* Local copy of count of elements in                                          * path (name) of interp. to delete. */
name|char
modifier|*
modifier|*
name|localArgv
decl_stmt|;
comment|/* Local copy of path. */
name|char
modifier|*
name|slaveName
decl_stmt|;
comment|/* Last component in path. */
name|char
modifier|*
name|masterPath
decl_stmt|;
comment|/* One-before-last component in path.*/
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclMasterRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterPtr
operator|==
operator|(
name|Master
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"DeleteInterpObject: could not find master record"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Tcl_SplitList
argument_list|(
name|interp
argument_list|,
name|path
argument_list|,
operator|&
name|localArgc
argument_list|,
operator|&
name|localArgv
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad interpreter path \""
argument_list|,
name|path
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|localArgc
operator|<
literal|2
condition|)
block|{
name|masterInterp
operator|=
name|interp
expr_stmt|;
if|if
condition|(
name|localArgc
operator|==
literal|0
condition|)
block|{
name|slaveName
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|slaveName
operator|=
name|localArgv
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|masterPath
operator|=
name|Tcl_Merge
argument_list|(
name|localArgc
operator|-
literal|1
argument_list|,
name|localArgv
argument_list|)
expr_stmt|;
name|masterInterp
operator|=
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|masterPath
argument_list|,
operator|&
name|masterPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"interpreter named \""
argument_list|,
name|masterPath
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|localArgv
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|masterPath
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|masterPath
argument_list|)
expr_stmt|;
name|slaveName
operator|=
name|localArgv
index|[
name|localArgc
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|slaveTable
operator|)
argument_list|,
name|slaveName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|localArgv
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"interpreter named \""
argument_list|,
name|path
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
name|slaveName
operator|=
name|Tcl_GetCommandName
argument_list|(
name|masterInterp
argument_list|,
name|slavePtr
operator|->
name|interpCmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_DeleteCommand
argument_list|(
name|masterInterp
argument_list|,
name|slaveName
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|localArgv
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"interpreter named \""
argument_list|,
name|path
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|localArgv
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DeleteInterpObject --  *  *	Helper function to do the work of deleting zero or more  *	interpreters and their interpreter object commands.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Deletes interpreters and their interpreter object command.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|DeleteInterpObject
parameter_list|(
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter start search from. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments in vector. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Contains path to interps to                                          * delete. */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|DeleteOneInterpObject
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * AliasHelper --  *  *	Helper function to do the work to actually create an alias or  *	delete an alias.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	An alias command is created and entered into the alias table  *	for the slave interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|AliasHelper
parameter_list|(
name|curInterp
parameter_list|,
name|slaveInterp
parameter_list|,
name|masterInterp
parameter_list|,
name|masterPtr
parameter_list|,
name|aliasName
parameter_list|,
name|targetName
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|Tcl_Interp
modifier|*
name|curInterp
decl_stmt|;
comment|/* Interp that invoked this proc. */
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* Interp where alias cmd will live                                          * or from which alias will be                                          * deleted. */
name|Tcl_Interp
modifier|*
name|masterInterp
decl_stmt|;
comment|/* Interp where target cmd will be. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record for target interp. */
name|char
modifier|*
name|aliasName
decl_stmt|;
comment|/* Name of alias cmd. */
name|char
modifier|*
name|targetName
decl_stmt|;
comment|/* Name of target cmd. */
name|int
name|argc
decl_stmt|;
comment|/* Additional arguments to store */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* with alias. */
block|{
name|Alias
modifier|*
name|aliasPtr
decl_stmt|;
comment|/* Storage for alias data. */
name|Alias
modifier|*
name|tmpAliasPtr
decl_stmt|;
comment|/* Temp storage for alias to delete. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Entry into interp hashtable. */
name|int
name|i
decl_stmt|;
comment|/* Loop index. */
name|int
name|new
decl_stmt|;
comment|/* Is it a new hash entry? */
name|Target
modifier|*
name|targetPtr
decl_stmt|;
comment|/* Maps from target command in master                                          * to source command in slave. */
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Maps from source command in slave                                          * to target command in master. */
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|slaveInterp
argument_list|,
literal|"tclSlaveRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*      * Fix it up if there is no slave record. This can happen if someone      * uses "" as the source for an alias.      */
if|if
condition|(
name|slavePtr
operator|==
operator|(
name|Slave
operator|*
operator|)
name|NULL
condition|)
block|{
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|Slave
argument_list|)
argument_list|)
expr_stmt|;
name|slavePtr
operator|->
name|masterInterp
operator|=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
expr_stmt|;
name|slavePtr
operator|->
name|slaveEntry
operator|=
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
expr_stmt|;
name|slavePtr
operator|->
name|slaveInterp
operator|=
name|slaveInterp
expr_stmt|;
name|slavePtr
operator|->
name|interpCmd
operator|=
operator|(
name|Tcl_Command
operator|)
name|NULL
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
operator|&
operator|(
name|slavePtr
operator|->
name|aliasTable
operator|)
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Tcl_SetAssocData
argument_list|(
name|slaveInterp
argument_list|,
literal|"tclSlaveRecord"
argument_list|,
name|SlaveRecordDeleteProc
argument_list|,
operator|(
name|ClientData
operator|)
name|slavePtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|targetName
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
operator|||
operator|(
name|targetName
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|curInterp
argument_list|,
literal|"malformed command: should be"
argument_list|,
literal|" \"alias "
argument_list|,
name|aliasName
argument_list|,
literal|" {}\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|DeleteAlias
argument_list|(
name|curInterp
argument_list|,
name|slaveInterp
argument_list|,
name|aliasName
argument_list|)
return|;
block|}
name|aliasPtr
operator|=
operator|(
name|Alias
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|Alias
argument_list|)
argument_list|)
expr_stmt|;
name|aliasPtr
operator|->
name|aliasName
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|aliasName
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|aliasPtr
operator|->
name|targetName
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|targetName
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|aliasPtr
operator|->
name|aliasName
argument_list|,
name|aliasName
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|aliasPtr
operator|->
name|targetName
argument_list|,
name|targetName
argument_list|)
expr_stmt|;
name|aliasPtr
operator|->
name|targetInterp
operator|=
name|masterInterp
expr_stmt|;
name|aliasPtr
operator|->
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
name|aliasPtr
operator|->
name|argc
operator|=
name|argc
expr_stmt|;
if|if
condition|(
name|aliasPtr
operator|->
name|argc
operator|>
literal|0
condition|)
block|{
name|aliasPtr
operator|->
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|aliasPtr
operator|->
name|argc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|aliasPtr
operator|->
name|argv
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|aliasPtr
operator|->
name|argv
index|[
name|i
index|]
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TclPreventAliasLoop
argument_list|(
name|curInterp
argument_list|,
name|slaveInterp
argument_list|,
name|aliasName
argument_list|,
name|AliasCmd
argument_list|,
operator|(
name|ClientData
operator|)
name|aliasPtr
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|ckfree
argument_list|(
name|aliasPtr
operator|->
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aliasPtr
operator|->
name|argv
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aliasPtr
operator|->
name|argv
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
name|aliasPtr
operator|->
name|aliasName
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|aliasPtr
operator|->
name|targetName
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aliasPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|aliasPtr
operator|->
name|slaveCmd
operator|=
name|Tcl_CreateCommand
argument_list|(
name|slaveInterp
argument_list|,
name|aliasName
argument_list|,
name|AliasCmd
argument_list|,
operator|(
name|ClientData
operator|)
name|aliasPtr
argument_list|,
name|AliasCmdDeleteProc
argument_list|)
expr_stmt|;
comment|/*      * Make an entry in the alias table. If it already exists delete      * the alias command. Then retry.      */
do|do
block|{
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
operator|(
name|slavePtr
operator|->
name|aliasTable
operator|)
argument_list|,
name|aliasName
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
condition|)
block|{
name|tmpAliasPtr
operator|=
operator|(
name|Alias
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Tcl_DeleteCommand
argument_list|(
name|slaveInterp
argument_list|,
name|tmpAliasPtr
operator|->
name|aliasName
argument_list|)
expr_stmt|;
name|Tcl_DeleteHashEntry
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|new
operator|==
literal|0
condition|)
do|;
name|aliasPtr
operator|->
name|aliasEntry
operator|=
name|hPtr
expr_stmt|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
operator|(
name|ClientData
operator|)
name|aliasPtr
argument_list|)
expr_stmt|;
name|targetPtr
operator|=
operator|(
name|Target
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|Target
argument_list|)
argument_list|)
expr_stmt|;
name|targetPtr
operator|->
name|slaveCmd
operator|=
name|aliasPtr
operator|->
name|slaveCmd
expr_stmt|;
name|targetPtr
operator|->
name|slaveInterp
operator|=
name|slaveInterp
expr_stmt|;
do|do
block|{
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|targetTable
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|aliasCounter
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
name|aliasCounter
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|new
operator|==
literal|0
condition|)
do|;
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
operator|(
name|ClientData
operator|)
name|targetPtr
argument_list|)
expr_stmt|;
name|aliasPtr
operator|->
name|targetEntry
operator|=
name|hPtr
expr_stmt|;
name|curInterp
operator|->
name|result
operator|=
name|aliasPtr
operator|->
name|aliasName
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SlaveAliasHelper -  *  *	Handles the different forms of the "interp alias" command:  *	- interp alias slavePath aliasName  *		Describes an alias.  *	- interp alias slavePath aliasName {}  *		Deletes an alias.  *	- interp alias slavePath srcCmd masterPath targetCmd args...  *		Creates an alias.  *  * Results:  *	A Tcl result.  *  * Side effects:  *	See user documentation for details.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SlaveAliasHelper
parameter_list|(
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record for current interp. */
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|,
comment|/* Interpreters used when */
modifier|*
name|masterInterp
decl_stmt|;
comment|/* creating an alias btn siblings. */
name|Master
modifier|*
name|masterMasterPtr
decl_stmt|;
comment|/* Master record for master interp. */
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclMasterRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterPtr
operator|==
operator|(
name|Master
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"SlaveAliasHelper: could not find master record"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|4
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" alias slavePath slaveCmd masterPath masterCmd ?args ..?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|slaveInterp
operator|=
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slaveInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"could not find interpreter \""
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|argc
operator|==
literal|4
condition|)
block|{
return|return
name|DescribeAlias
argument_list|(
name|interp
argument_list|,
name|slaveInterp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
return|;
block|}
if|if
condition|(
name|argc
operator|==
literal|5
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|DeleteAlias
argument_list|(
name|interp
argument_list|,
name|slaveInterp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
return|;
block|}
if|if
condition|(
name|argc
operator|<
literal|6
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" alias slavePath slaveCmd masterPath masterCmd ?args ..?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|masterInterp
operator|=
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
operator|&
name|masterMasterPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"could not find interpreter \""
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|AliasHelper
argument_list|(
name|interp
argument_list|,
name|slaveInterp
argument_list|,
name|masterInterp
argument_list|,
name|masterMasterPtr
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
name|argv
index|[
literal|5
index|]
argument_list|,
name|argc
operator|-
literal|6
argument_list|,
name|argv
operator|+
literal|6
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DescribeAlias --  *  *	Sets interp->result to a Tcl list describing the given alias in the  *	given interpreter: its target command and the additional arguments  *	to prepend to any invocation of the alias.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|DescribeAlias
parameter_list|(
name|interp
parameter_list|,
name|slaveInterp
parameter_list|,
name|aliasName
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter for result and errors. */
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* Interpreter defining alias. */
name|char
modifier|*
name|aliasName
decl_stmt|;
comment|/* Name of alias to describe. */
block|{
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Slave record for slave interpreter. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Search variable. */
name|Alias
modifier|*
name|aliasPtr
decl_stmt|;
comment|/* Structure describing alias. */
name|int
name|i
decl_stmt|;
comment|/* Loop variable. */
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|slaveInterp
argument_list|,
literal|"tclSlaveRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slavePtr
operator|==
operator|(
name|Slave
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"DescribeAlias: could not find slave record"
argument_list|)
expr_stmt|;
block|}
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
operator|(
name|slavePtr
operator|->
name|aliasTable
operator|)
argument_list|,
name|aliasName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
name|aliasPtr
operator|=
operator|(
name|Alias
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|aliasPtr
operator|->
name|targetName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|aliasPtr
operator|->
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|aliasPtr
operator|->
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DeleteAlias --  *  *	Deletes the given alias from the slave interpreter given.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Deletes the alias from the slave interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|DeleteAlias
parameter_list|(
name|interp
parameter_list|,
name|slaveInterp
parameter_list|,
name|aliasName
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter for result and errors. */
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* Interpreter defining alias. */
name|char
modifier|*
name|aliasName
decl_stmt|;
comment|/* Name of alias to delete. */
block|{
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Slave record for slave interpreter. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Search variable. */
name|Alias
modifier|*
name|aliasPtr
decl_stmt|;
comment|/* Structure describing alias to delete. */
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|slaveInterp
argument_list|,
literal|"tclSlaveRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slavePtr
operator|==
operator|(
name|Slave
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"DeleteAlias: could not find slave record"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Get the alias from the alias table, determine the current      * true name of the alias (it may have been renamed!) and then      * delete the true command name. The deleteProc on the alias      * command will take care of removing the entry from the alias      * table.      */
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
operator|(
name|slavePtr
operator|->
name|aliasTable
operator|)
argument_list|,
name|aliasName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"alias \""
argument_list|,
name|aliasName
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|aliasPtr
operator|=
operator|(
name|Alias
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
name|aliasName
operator|=
name|Tcl_GetCommandName
argument_list|(
name|slaveInterp
argument_list|,
name|aliasPtr
operator|->
name|slaveCmd
argument_list|)
expr_stmt|;
comment|/*      * NOTE: The deleteProc for this command will delete the      * alias from the hash table. The deleteProc will also      * delete the target information from the master interpreter      * target table.      */
if|if
condition|(
name|Tcl_DeleteCommand
argument_list|(
name|slaveInterp
argument_list|,
name|aliasName
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"DeleteAlias: did not find alias to be deleted"
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetInterpPath --  *  *	Sets the result of the asking interpreter to a proper Tcl list  *	containing the names of interpreters between the asking and  *	target interpreters. The target interpreter must be either the  *	same as the asking interpreter or one of its slaves (including  *	recursively).  *  * Results:  *	TCL_OK if the target interpreter is the same as, or a descendant  *	of, the asking interpreter; TCL_ERROR else. This way one can  *	distinguish between the case where the asking and target interps  *	are the same (an empty list is the result, and TCL_OK is returned)  *	and when the target is not a descendant of the asking interpreter  *	(in which case the Tcl result is an error message and the function  *	returns TCL_ERROR).  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_GetInterpPath
parameter_list|(
name|askingInterp
parameter_list|,
name|targetInterp
parameter_list|)
name|Tcl_Interp
modifier|*
name|askingInterp
decl_stmt|;
comment|/* Interpreter to start search from. */
name|Tcl_Interp
modifier|*
name|targetInterp
decl_stmt|;
comment|/* Interpreter to find. */
block|{
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Interim storage for Master record. */
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Interim storage for Slave record. */
if|if
condition|(
name|targetInterp
operator|==
name|askingInterp
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|targetInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|targetInterp
argument_list|,
literal|"tclSlaveRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slavePtr
operator|==
operator|(
name|Slave
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetInterpPath
argument_list|(
name|askingInterp
argument_list|,
name|slavePtr
operator|->
name|masterInterp
argument_list|)
operator|==
name|TCL_ERROR
condition|)
block|{
comment|/*          * AskingInterp->result was set by recursive call.          */
return|return
name|TCL_ERROR
return|;
block|}
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|slavePtr
operator|->
name|masterInterp
argument_list|,
literal|"tclMasterRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterPtr
operator|==
operator|(
name|Master
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_GetInterpPath: could not find master record"
argument_list|)
expr_stmt|;
block|}
name|Tcl_AppendElement
argument_list|(
name|askingInterp
argument_list|,
name|Tcl_GetHashKey
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|slaveTable
operator|)
argument_list|,
name|slavePtr
operator|->
name|slaveEntry
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * GetTarget --  *  *	Sets the result of the invoking interpreter to a path name for  *	the target interpreter of an alias in one of the slaves.  *  * Results:  *	TCL_OK if the target interpreter of the alias is a slave of the  *	invoking interpreter, TCL_ERROR else.  *  * Side effects:  *	Sets the result of the invoking interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|GetTarget
parameter_list|(
name|askingInterp
parameter_list|,
name|path
parameter_list|,
name|aliasName
parameter_list|)
name|Tcl_Interp
modifier|*
name|askingInterp
decl_stmt|;
comment|/* Interpreter to start search from. */
name|char
modifier|*
name|path
decl_stmt|;
comment|/* The path of the interp to find. */
name|char
modifier|*
name|aliasName
decl_stmt|;
comment|/* The target of this allias. */
block|{
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* Interim storage for slave. */
name|Slave
modifier|*
name|slaveSlavePtr
decl_stmt|;
comment|/* Its Slave record. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Interim storage for Master record. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Search element. */
name|Alias
modifier|*
name|aliasPtr
decl_stmt|;
comment|/* Data describing the alias. */
name|Tcl_ResetResult
argument_list|(
name|askingInterp
argument_list|)
expr_stmt|;
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|askingInterp
argument_list|,
literal|"tclMasterRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterPtr
operator|==
operator|(
name|Master
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"GetTarget: could not find master record"
argument_list|)
expr_stmt|;
block|}
name|slaveInterp
operator|=
name|GetInterp
argument_list|(
name|askingInterp
argument_list|,
name|masterPtr
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slaveInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|askingInterp
argument_list|,
literal|"could not find interpreter \""
argument_list|,
name|path
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|slaveSlavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|slaveInterp
argument_list|,
literal|"tclSlaveRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slaveSlavePtr
operator|==
operator|(
name|Slave
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"GetTarget: could not find slave record"
argument_list|)
expr_stmt|;
block|}
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
operator|(
name|slaveSlavePtr
operator|->
name|aliasTable
operator|)
argument_list|,
name|aliasName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|askingInterp
argument_list|,
literal|"alias \""
argument_list|,
name|aliasName
argument_list|,
literal|"\" in path \""
argument_list|,
name|path
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|aliasPtr
operator|=
operator|(
name|Alias
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|aliasPtr
operator|==
operator|(
name|Alias
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"GetTarget: could not find alias record"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Tcl_GetInterpPath
argument_list|(
name|askingInterp
argument_list|,
name|aliasPtr
operator|->
name|targetInterp
argument_list|)
operator|==
name|TCL_ERROR
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|askingInterp
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|askingInterp
argument_list|,
literal|"target interpreter for alias \""
argument_list|,
name|aliasName
argument_list|,
literal|"\" in path \""
argument_list|,
name|path
argument_list|,
literal|"\" is not my descendant"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_InterpCmd --  *  *	This procedure is invoked to process the "interp" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_InterpCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Unused. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* A slave. */
name|Tcl_Interp
modifier|*
name|masterInterp
decl_stmt|;
comment|/* A master. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record for current interp. */
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Record for slave interp. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|Tcl_HashSearch
name|hSearch
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/* Length of command name. */
name|int
name|result
decl_stmt|;
comment|/* Result of eval. */
name|char
modifier|*
name|cmdName
decl_stmt|;
comment|/* Name of sub command to do. */
name|char
modifier|*
name|cmd
decl_stmt|;
comment|/* Command to eval. */
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* Channel to share or transfer. */
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" cmd ?arg ...?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|cmdName
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclMasterRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterPtr
operator|==
operator|(
name|Master
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_InterpCmd: could not find master record"
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|cmdName
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdName
index|[
literal|0
index|]
operator|==
literal|'a'
condition|)
block|{
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|cmdName
argument_list|,
literal|"alias"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|len
operator|<=
literal|5
operator|)
condition|)
block|{
return|return
name|SlaveAliasHelper
argument_list|(
name|interp
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cmdName
argument_list|,
literal|"aliases"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
operator|&&
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" aliases ?path?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
block|{
name|slaveInterp
operator|=
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slaveInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"interpreter \""
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
else|else
block|{
name|slaveInterp
operator|=
name|interp
expr_stmt|;
block|}
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|slaveInterp
argument_list|,
literal|"tclSlaveRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slavePtr
operator|==
operator|(
name|Slave
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
operator|(
name|slavePtr
operator|->
name|aliasTable
operator|)
argument_list|,
operator|&
name|hSearch
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|hSearch
argument_list|)
control|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|Tcl_GetHashKey
argument_list|(
operator|&
operator|(
name|slavePtr
operator|->
name|aliasTable
operator|)
argument_list|,
name|hPtr
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
block|}
if|if
condition|(
operator|(
name|cmdName
index|[
literal|0
index|]
operator|==
literal|'c'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cmdName
argument_list|,
literal|"create"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|CreateInterpObject
argument_list|(
name|interp
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|cmdName
index|[
literal|0
index|]
operator|==
literal|'d'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cmdName
argument_list|,
literal|"delete"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|DeleteInterpObject
argument_list|(
name|interp
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
return|;
block|}
if|if
condition|(
name|cmdName
index|[
literal|0
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|cmdName
argument_list|,
literal|"exists"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|len
operator|>
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" exists ?path?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|)
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"0"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"1"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"1"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|cmdName
argument_list|,
literal|"eval"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|len
operator|>
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|4
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" eval path arg ?arg ...?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|slaveInterp
operator|=
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slaveInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"interpreter named \""
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|cmd
operator|=
name|Tcl_Concat
argument_list|(
name|argc
operator|-
literal|3
argument_list|,
name|argv
operator|+
literal|3
argument_list|)
expr_stmt|;
name|Tcl_Preserve
argument_list|(
operator|(
name|ClientData
operator|)
name|slaveInterp
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_Eval
argument_list|(
name|slaveInterp
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cmd
argument_list|)
expr_stmt|;
comment|/*              * Now make the result and any error information accessible. We              * have to be careful because the slave interpreter and the current              * interpreter can be the same - do not destroy the result.. This              * can happen if an interpreter contains an alias which is directed              * at a target command in the same interpreter.              */
if|if
condition|(
name|interp
operator|!=
name|slaveInterp
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
comment|/*                      * An error occurred, so transfer error information from                      * the target interpreter back to our interpreter.  Must                      * clear interp's result before calling Tcl_AddErrorInfo,                      * since Tcl_AddErrorInfo will store the interp's result in                      * errorInfo before appending slaveInterp's $errorInfo;                      * we've already got everything we need in the slave                      * interpreter's $errorInfo.                      */
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
name|Tcl_GetVar2
argument_list|(
name|slaveInterp
argument_list|,
literal|"errorInfo"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|Tcl_GetVar2
argument_list|(
name|slaveInterp
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|slaveInterp
operator|->
name|freeProc
operator|!=
name|NULL
condition|)
block|{
name|interp
operator|->
name|result
operator|=
name|slaveInterp
operator|->
name|result
expr_stmt|;
name|interp
operator|->
name|freeProc
operator|=
name|slaveInterp
operator|->
name|freeProc
expr_stmt|;
name|slaveInterp
operator|->
name|freeProc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|slaveInterp
operator|->
name|result
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
name|Tcl_ResetResult
argument_list|(
name|slaveInterp
argument_list|)
expr_stmt|;
block|}
name|Tcl_Release
argument_list|(
operator|(
name|ClientData
operator|)
name|slaveInterp
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
if|if
condition|(
operator|(
name|cmdName
index|[
literal|0
index|]
operator|==
literal|'i'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cmdName
argument_list|,
literal|"issafe"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" issafe ?path?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
block|{
name|slaveInterp
operator|=
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|masterPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|slaveInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"interpreter \""
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
if|if
condition|(
name|masterPtr
operator|->
name|isSafe
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"0"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"1"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|cmdName
index|[
literal|0
index|]
operator|==
literal|'s'
condition|)
block|{
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|cmdName
argument_list|,
literal|"slaves"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|len
operator|>
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
operator|&&
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" slaves ?path?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|masterPtr
argument_list|)
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"interpreter \""
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|slaveTable
operator|)
argument_list|,
operator|&
name|hSearch
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|hSearch
argument_list|)
control|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|Tcl_GetHashKey
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|slaveTable
operator|)
argument_list|,
name|hPtr
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|cmdName
argument_list|,
literal|"share"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|len
operator|>
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|5
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" share srcPath channelId destPath\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|masterInterp
operator|=
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"interpreter \""
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|slaveInterp
operator|=
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slaveInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"interpreter \""
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|chan
operator|=
name|Tcl_GetChannel
argument_list|(
name|masterInterp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
name|masterInterp
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|masterInterp
operator|->
name|result
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|masterInterp
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_RegisterChannel
argument_list|(
name|slaveInterp
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
block|}
if|if
condition|(
operator|(
name|cmdName
index|[
literal|0
index|]
operator|==
literal|'t'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cmdName
argument_list|,
literal|"target"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" target path alias\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|GetTarget
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|cmdName
index|[
literal|0
index|]
operator|==
literal|'t'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cmdName
argument_list|,
literal|"transfer"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|5
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" transfer srcPath channelId destPath\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|masterInterp
operator|=
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"interpreter \""
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|slaveInterp
operator|=
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slaveInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"interpreter \""
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|chan
operator|=
name|Tcl_GetChannel
argument_list|(
name|masterInterp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
name|masterInterp
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|masterInterp
operator|->
name|result
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|masterInterp
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_RegisterChannel
argument_list|(
name|slaveInterp
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_UnregisterChannel
argument_list|(
name|masterInterp
argument_list|,
name|chan
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
name|masterInterp
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|masterInterp
operator|->
name|result
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|masterInterp
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": should be alias, aliases, create, delete, exists, eval, "
argument_list|,
literal|"issafe, share, slaves, target or transfer"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SlaveObjectCmd --  *  *	Command to manipulate an interpreter, e.g. to send commands to it  *	to be evaluated. One such command exists for each slave interpreter.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See user documentation for details.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SlaveObjectCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Slave interpreter. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record for slave interp. */
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Slave record. */
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* Slave interpreter. */
name|char
modifier|*
name|cmdName
decl_stmt|;
comment|/* Name of command to do. */
name|char
modifier|*
name|cmd
decl_stmt|;
comment|/* Command to evaluate in slave                                          * interpreter. */
name|Alias
modifier|*
name|aliasPtr
decl_stmt|;
comment|/* Alias information. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* For local searches. */
name|Tcl_HashSearch
name|hSearch
decl_stmt|;
comment|/* For local searches. */
name|int
name|result
decl_stmt|;
comment|/* Loop counter, status return. */
name|size_t
name|len
decl_stmt|;
comment|/* Length of command name. */
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" cmd ?arg ...?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|slaveInterp
operator|=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|clientData
expr_stmt|;
if|if
condition|(
name|slaveInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"interpreter "
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" has been deleted"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|slaveInterp
argument_list|,
literal|"tclSlaveRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slavePtr
operator|==
operator|(
name|Slave
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"SlaveObjectCmd: could not find slave record"
argument_list|)
expr_stmt|;
block|}
name|cmdName
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|cmdName
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdName
index|[
literal|0
index|]
operator|==
literal|'a'
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|cmdName
argument_list|,
literal|"alias"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|argc
operator|-
literal|2
condition|)
block|{
case|case
literal|0
case|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" alias aliasName ?targetName? ?args..?"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
case|case
literal|1
case|:
comment|/*                      * Return the name of the command in the current                      * interpreter for which the argument is an alias in the                      * slave interpreter, and the list of saved arguments                      */
return|return
name|DescribeAlias
argument_list|(
name|interp
argument_list|,
name|slaveInterp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
return|;
default|default:
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclMasterRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterPtr
operator|==
operator|(
name|Master
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"SlaveObjectCmd: could not find master record"
argument_list|)
expr_stmt|;
block|}
return|return
name|AliasHelper
argument_list|(
name|interp
argument_list|,
name|slaveInterp
argument_list|,
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
name|argc
operator|-
literal|4
argument_list|,
name|argv
operator|+
literal|4
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|cmdName
argument_list|,
literal|"aliases"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/*              * Return the names of all the aliases created in the              * slave interpreter.              */
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
operator|(
name|slavePtr
operator|->
name|aliasTable
operator|)
argument_list|,
operator|&
name|hSearch
argument_list|)
init|;
name|hPtr
operator|!=
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|hSearch
argument_list|)
control|)
block|{
name|aliasPtr
operator|=
operator|(
name|Alias
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|aliasPtr
operator|->
name|aliasName
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
block|}
if|if
condition|(
operator|(
name|cmdName
index|[
literal|0
index|]
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cmdName
argument_list|,
literal|"eval"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" eval arg ?arg ...?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|cmd
operator|=
name|Tcl_Concat
argument_list|(
name|argc
operator|-
literal|2
argument_list|,
name|argv
operator|+
literal|2
argument_list|)
expr_stmt|;
name|Tcl_Preserve
argument_list|(
operator|(
name|ClientData
operator|)
name|slaveInterp
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_Eval
argument_list|(
name|slaveInterp
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cmd
argument_list|)
expr_stmt|;
comment|/*          * Now make the result and any error information accessible. We have          * to be careful because the slave interpreter and the current          * interpreter can be the same - do not destroy the result.. This          * can happen if an interpreter contains an alias which is directed          * at a target command in the same interpreter.          */
if|if
condition|(
name|interp
operator|!=
name|slaveInterp
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
comment|/*                 * An error occurred, so transfer error information from the                 * destination interpreter back to our interpreter.  Must clear                 * interp's result before calling Tcl_AddErrorInfo, since                 * Tcl_AddErrorInfo will store the interp's result in errorInfo                 * before appending slaveInterp's $errorInfo;                 * we've already got everything we need in the slave                 * interpreter's $errorInfo.                 */
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
name|Tcl_GetVar2
argument_list|(
name|slaveInterp
argument_list|,
literal|"errorInfo"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|Tcl_GetVar2
argument_list|(
name|slaveInterp
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|slaveInterp
operator|->
name|freeProc
operator|!=
name|NULL
condition|)
block|{
name|interp
operator|->
name|result
operator|=
name|slaveInterp
operator|->
name|result
expr_stmt|;
name|interp
operator|->
name|freeProc
operator|=
name|slaveInterp
operator|->
name|freeProc
expr_stmt|;
name|slaveInterp
operator|->
name|freeProc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|slaveInterp
operator|->
name|result
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
name|Tcl_ResetResult
argument_list|(
name|slaveInterp
argument_list|)
expr_stmt|;
block|}
name|Tcl_Release
argument_list|(
operator|(
name|ClientData
operator|)
name|slaveInterp
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
operator|(
name|cmdName
index|[
literal|0
index|]
operator|==
literal|'i'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cmdName
argument_list|,
literal|"issafe"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" issafe\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|slaveInterp
argument_list|,
literal|"tclMasterRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterPtr
operator|==
operator|(
name|Master
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"SlaveObjectCmd: could not find master record"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|masterPtr
operator|->
name|isSafe
operator|==
literal|1
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"1"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"0"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": should be alias, aliases, eval or issafe"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SlaveObjectDeleteProc --  *  *	Invoked when an object command for a slave interpreter is deleted;  *	cleans up all state associated with the slave interpreter and destroys  *	the slave interpreter.  *  * Results:  *	None.  *  * Side effects:  *	Cleans up all state associated with the slave interpreter and  *	destroys the slave interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|SlaveObjectDeleteProc
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* The SlaveRecord for the command. */
block|{
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Interim storage for Slave record. */
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* And for a slave interp. */
name|slaveInterp
operator|=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|clientData
expr_stmt|;
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|slaveInterp
argument_list|,
literal|"tclSlaveRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slavePtr
operator|==
operator|(
name|Slave
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"SlaveObjectDeleteProc: could not find slave record"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Delete the entry in the slave table in the master interpreter now.      * This is to avoid an infinite loop in the Master hash table cleanup in      * the master interpreter. This can happen if this slave is being deleted      * because the master is being deleted and the slave deletion is deferred      * because it is still active.      */
name|Tcl_DeleteHashEntry
argument_list|(
name|slavePtr
operator|->
name|slaveEntry
argument_list|)
expr_stmt|;
comment|/*      * Set to NULL so that when the slave record is cleaned up in the slave      * it does not try to delete the command causing all sorts of grief.      * See SlaveRecordDeleteProc().      */
name|slavePtr
operator|->
name|interpCmd
operator|=
name|NULL
expr_stmt|;
comment|/*      * Destroy the interpreter - this will cause all the deleteProcs for      * all commands (including aliases) to run.      *      * NOTE: WE ASSUME THAT THE INTERPRETER HAS NOT BEEN DELETED YET!!      */
name|Tcl_DeleteInterp
argument_list|(
name|slavePtr
operator|->
name|slaveInterp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * AliasCmd --  *  *	This is the procedure that services invocations of aliases in a  *	slave interpreter. One such command exists for each alias. When  *	invoked, this procedure redirects the invocation to the target  *	command in the master interpreter as designated by the Alias  *	record associated with this command.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Causes forwarding of the invocation; all possible side effects  *	may occur as a result of invoking the command to which the  *	invocation is forwarded.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|AliasCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Alias record. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Alias
modifier|*
name|aliasPtr
decl_stmt|;
comment|/* Describes the alias. */
name|Tcl_CmdInfo
name|cmdInfo
decl_stmt|;
comment|/* Info about target command. */
name|int
name|result
decl_stmt|;
comment|/* Result of execution. */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|addArgc
decl_stmt|;
comment|/* Loop counters. */
name|int
name|localArgc
decl_stmt|;
comment|/* Local argument count. */
name|char
modifier|*
modifier|*
name|localArgv
decl_stmt|;
comment|/* Local argument vector. */
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* The target interpreter. */
name|aliasPtr
operator|=
operator|(
name|Alias
operator|*
operator|)
name|clientData
expr_stmt|;
name|result
operator|=
name|Tcl_GetCommandInfo
argument_list|(
name|aliasPtr
operator|->
name|targetInterp
argument_list|,
name|aliasPtr
operator|->
name|targetName
argument_list|,
operator|&
name|cmdInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"aliased target \""
argument_list|,
name|aliasPtr
operator|->
name|targetName
argument_list|,
literal|"\" for \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|aliasPtr
operator|->
name|argc
operator|<=
literal|0
condition|)
block|{
name|localArgv
operator|=
name|argv
expr_stmt|;
name|localArgc
operator|=
name|argc
expr_stmt|;
block|}
else|else
block|{
name|addArgc
operator|=
name|aliasPtr
operator|->
name|argc
expr_stmt|;
name|localArgc
operator|=
name|argc
operator|+
name|addArgc
expr_stmt|;
name|localArgv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|localArgc
argument_list|)
expr_stmt|;
name|localArgv
index|[
literal|0
index|]
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|1
init|;
name|i
operator|<
name|addArgc
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|localArgv
index|[
name|j
index|]
operator|=
name|aliasPtr
operator|->
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|localArgv
index|[
name|j
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|/*      * Invoke the redirected command in the target interpreter. Note      * that we are not calling eval because of possible security holes with      * $ substitution and bracketed command evaluation.      *      * We duplicate some code here from Tcl_Eval to implement recursion      * level counting and correct deletion of the target interpreter if      * that was requested but delayed because of in-progress evaluations.      */
name|iPtr
operator|=
operator|(
name|Interp
operator|*
operator|)
name|aliasPtr
operator|->
name|targetInterp
expr_stmt|;
name|iPtr
operator|->
name|numLevels
operator|++
expr_stmt|;
name|Tcl_Preserve
argument_list|(
operator|(
name|ClientData
operator|)
name|iPtr
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|)
expr_stmt|;
name|result
operator|=
call|(
name|cmdInfo
operator|.
name|proc
call|)
argument_list|(
name|cmdInfo
operator|.
name|clientData
argument_list|,
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
name|localArgc
argument_list|,
name|localArgv
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|numLevels
operator|--
expr_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|numLevels
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_RETURN
condition|)
block|{
name|result
operator|=
name|TclUpdateReturnInfo
argument_list|(
name|iPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|result
operator|!=
name|TCL_OK
operator|)
operator|&&
operator|(
name|result
operator|!=
name|TCL_ERROR
operator|)
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_BREAK
condition|)
block|{
name|iPtr
operator|->
name|result
operator|=
literal|"invoked \"break\" outside of a loop"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|TCL_CONTINUE
condition|)
block|{
name|iPtr
operator|->
name|result
operator|=
literal|"invoked \"continue\" outside of a loop"
expr_stmt|;
block|}
else|else
block|{
name|iPtr
operator|->
name|result
operator|=
name|iPtr
operator|->
name|resultSpace
expr_stmt|;
name|sprintf
argument_list|(
name|iPtr
operator|->
name|resultSpace
argument_list|,
literal|"command returned bad code: %d"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
block|}
comment|/*      * Clean up any locally allocated argument vector structure.      */
if|if
condition|(
name|localArgv
operator|!=
name|argv
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|localArgv
argument_list|)
expr_stmt|;
block|}
comment|/*      *      * NOTE: Need to be careful if the target interpreter and the current      * interpreter are the same - must not destroy result. This may happen      * if an alias is created which redirects to a command in the same      * interpreter as the one in which the source command will be defined.      * Also: We cannot use aliasPtr any more because the alias may have      * been deleted.      */
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
comment|/* 	     * An error occurred, so transfer error information from the 	     * destination interpreter back to our interpreter.  Some tricky 	     * points: 	     * 1. Must call Tcl_AddErrorInfo in destination interpreter to 	     *    make sure that the errorInfo variable has been initialized 	     *    (it's initialized lazily and might not have been initialized 	     *    yet). 	     * 2. Must clear interp's result before calling Tcl_AddErrorInfo, 	     *    since Tcl_AddErrorInfo will store the interp's result in 	     *    errorInfo before appending aliasPtr->interp's $errorInfo; 	     *    we've already got everything we need in the redirected 	     *    interpreter's $errorInfo. 	     */
if|if
condition|(
operator|!
operator|(
name|iPtr
operator|->
name|flags
operator|&
name|ERR_ALREADY_LOGGED
operator|)
condition|)
block|{
name|Tcl_AddErrorInfo
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|iPtr
operator|->
name|flags
operator|&=
operator|~
name|ERR_ALREADY_LOGGED
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
name|Tcl_GetVar2
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"errorInfo"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|Tcl_GetVar2
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iPtr
operator|->
name|freeProc
operator|!=
name|NULL
condition|)
block|{
name|interp
operator|->
name|result
operator|=
name|iPtr
operator|->
name|result
expr_stmt|;
name|interp
operator|->
name|freeProc
operator|=
name|iPtr
operator|->
name|freeProc
expr_stmt|;
name|iPtr
operator|->
name|freeProc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|iPtr
operator|->
name|result
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
name|Tcl_ResetResult
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|)
expr_stmt|;
block|}
name|Tcl_Release
argument_list|(
operator|(
name|ClientData
operator|)
name|iPtr
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * AliasCmdDeleteProc --  *  *	Is invoked when an alias command is deleted in a slave. Cleans up  *	all storage associated with this alias.  *  * Results:  *	None.  *  * Side effects:  *	Deletes the alias record and its entry in the alias table for  *	the interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|AliasCmdDeleteProc
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* The alias record for this alias. */
block|{
name|Alias
modifier|*
name|aliasPtr
decl_stmt|;
comment|/* Alias record for alias to delete. */
name|Target
modifier|*
name|targetPtr
decl_stmt|;
comment|/* Record for target of this alias. */
name|int
name|i
decl_stmt|;
comment|/* Loop counter. */
name|aliasPtr
operator|=
operator|(
name|Alias
operator|*
operator|)
name|clientData
expr_stmt|;
name|targetPtr
operator|=
operator|(
name|Target
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|aliasPtr
operator|->
name|targetEntry
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|targetPtr
argument_list|)
expr_stmt|;
name|Tcl_DeleteHashEntry
argument_list|(
name|aliasPtr
operator|->
name|targetEntry
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aliasPtr
operator|->
name|targetName
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aliasPtr
operator|->
name|aliasName
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|aliasPtr
operator|->
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aliasPtr
operator|->
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aliasPtr
operator|->
name|argv
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aliasPtr
operator|->
name|argv
argument_list|)
expr_stmt|;
block|}
name|Tcl_DeleteHashEntry
argument_list|(
name|aliasPtr
operator|->
name|aliasEntry
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aliasPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * MasterRecordDeleteProc -  *  *	Is invoked when an interpreter (which is using the "interp" facility)  *	is deleted, and it cleans up the storage associated with the  *	"tclMasterRecord" assoc-data entry.  *  * Results:  *	None.  *  * Side effects:  *	Cleans up storage.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|MasterRecordDeleteProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Master record for deleted interp. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter being deleted. */
block|{
name|Target
modifier|*
name|targetPtr
decl_stmt|;
comment|/* Loop variable. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Search element. */
name|Tcl_HashSearch
name|hSearch
decl_stmt|;
comment|/* Search record (internal). */
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Loop variable. */
name|char
modifier|*
name|cmdName
decl_stmt|;
comment|/* Name of command to delete. */
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Interim storage. */
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|clientData
expr_stmt|;
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|slaveTable
operator|)
argument_list|,
operator|&
name|hSearch
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|hSearch
argument_list|)
control|)
block|{
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
name|cmdName
operator|=
name|Tcl_GetCommandName
argument_list|(
name|interp
argument_list|,
name|slavePtr
operator|->
name|interpCmd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Tcl_DeleteCommand
argument_list|(
name|interp
argument_list|,
name|cmdName
argument_list|)
expr_stmt|;
block|}
name|Tcl_DeleteHashTable
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|slaveTable
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|targetTable
operator|)
argument_list|,
operator|&
name|hSearch
argument_list|)
init|;
name|hPtr
operator|!=
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|targetTable
operator|)
argument_list|,
operator|&
name|hSearch
argument_list|)
control|)
block|{
name|targetPtr
operator|=
operator|(
name|Target
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
name|cmdName
operator|=
name|Tcl_GetCommandName
argument_list|(
name|targetPtr
operator|->
name|slaveInterp
argument_list|,
name|targetPtr
operator|->
name|slaveCmd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Tcl_DeleteCommand
argument_list|(
name|targetPtr
operator|->
name|slaveInterp
argument_list|,
name|cmdName
argument_list|)
expr_stmt|;
block|}
name|Tcl_DeleteHashTable
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|targetTable
operator|)
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|masterPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SlaveRecordDeleteProc --  *  *	Is invoked when an interpreter (which is using the interp facility)  *	is deleted, and it cleans up the storage associated with the  *	tclSlaveRecord assoc-data entry.  *  * Results:  *	None  *  * Side effects:  *	Cleans up storage.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|SlaveRecordDeleteProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Slave record for deleted interp. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter being deleted. */
block|{
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Interim storage. */
name|Alias
modifier|*
name|aliasPtr
decl_stmt|;
name|Tcl_HashTable
modifier|*
name|hTblPtr
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|Tcl_HashSearch
name|hSearch
decl_stmt|;
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|clientData
expr_stmt|;
comment|/*      * In every case that we call SetAssocData on "tclSlaveRecord",      * slavePtr is not NULL. Otherwise we panic.      */
if|if
condition|(
name|slavePtr
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"SlaveRecordDeleteProc: NULL slavePtr"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|slavePtr
operator|->
name|interpCmd
operator|!=
operator|(
name|Tcl_Command
operator|)
name|NULL
condition|)
block|{
name|Command
modifier|*
name|cmdPtr
init|=
operator|(
name|Command
operator|*
operator|)
name|slavePtr
operator|->
name|interpCmd
decl_stmt|;
comment|/* 	 * The interpCmd has not been deleted in the master yet,  since 	 * it's callback sets interpCmd to NULL. 	 * 	 * Probably Tcl_DeleteInterp() was called on this interpreter directly, 	 * rather than via "interp delete", or equivalent (deletion of the 	 * command in the master). 	 * 	 * Perform the cleanup done by SlaveObjectDeleteProc() directly, 	 * and turn off the callback now (since we are about to free slavePtr 	 * and this interpreter is going away, while the deletion of commands 	 * in the master may be deferred). 	 */
name|Tcl_DeleteHashEntry
argument_list|(
name|slavePtr
operator|->
name|slaveEntry
argument_list|)
expr_stmt|;
name|cmdPtr
operator|->
name|clientData
operator|=
name|NULL
expr_stmt|;
name|cmdPtr
operator|->
name|deleteProc
operator|=
name|NULL
expr_stmt|;
name|cmdPtr
operator|->
name|deleteData
operator|=
name|NULL
expr_stmt|;
comment|/*          * Get the command name from the master interpreter instead of          * relying on the stored name; the command may have been renamed.          */
name|Tcl_DeleteCommand
argument_list|(
name|slavePtr
operator|->
name|masterInterp
argument_list|,
name|Tcl_GetCommandName
argument_list|(
name|slavePtr
operator|->
name|masterInterp
argument_list|,
name|slavePtr
operator|->
name|interpCmd
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*      * If there are any aliases, delete those now. This removes any      * dependency on the order of deletion between commands and the      * slave record.      */
name|hTblPtr
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
operator|&
operator|(
name|slavePtr
operator|->
name|aliasTable
operator|)
expr_stmt|;
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|hTblPtr
argument_list|,
operator|&
name|hSearch
argument_list|)
init|;
name|hPtr
operator|!=
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|hTblPtr
argument_list|,
operator|&
name|hSearch
argument_list|)
control|)
block|{
name|aliasPtr
operator|=
operator|(
name|Alias
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
comment|/*          * The call to Tcl_DeleteCommand will release the storage          * occuppied by the hash entry and the alias record.          * NOTE that we cannot use the alias name directly because its          * storage will be deleted in the command deletion callback. Hence          * we must use the name for the command as stored in the hash table.          */
name|Tcl_DeleteCommand
argument_list|(
name|interp
argument_list|,
name|Tcl_GetCommandName
argument_list|(
name|interp
argument_list|,
name|aliasPtr
operator|->
name|slaveCmd
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*      * Finally dispose of the slave record itself.      */
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|slavePtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclInterpInit --  *  *	Initializes the invoking interpreter for using the "interp"  *	facility. This is called from inside Tcl_Init.  *  * Results:  *	None.  *  * Side effects:  *	Adds the "interp" command to an interpreter and initializes several  *	records in the associated data of the invoking interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclInterpInit
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to initialize. */
block|{
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Its Master record. */
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|Master
argument_list|)
argument_list|)
expr_stmt|;
name|masterPtr
operator|->
name|isSafe
operator|=
literal|0
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|slaveTable
operator|)
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
operator|&
operator|(
name|masterPtr
operator|->
name|targetTable
operator|)
argument_list|,
name|TCL_ONE_WORD_KEYS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Tcl_SetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclMasterRecord"
argument_list|,
name|MasterRecordDeleteProc
argument_list|,
operator|(
name|ClientData
operator|)
name|masterPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_IsSafe --  *  *	Determines whether an interpreter is safe  *  * Results:  *	1 if it is safe, 0 if it is not.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_IsSafe
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Is this interpreter "safe" ? */
block|{
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Its master record. */
if|if
condition|(
name|interp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclMasterRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterPtr
operator|==
operator|(
name|Master
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_IsSafe: could not find master record"
argument_list|)
expr_stmt|;
block|}
return|return
name|masterPtr
operator|->
name|isSafe
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_MakeSafe --  *  *	Makes an interpreter safe.  *  * Results:  *	TCL_OK if it succeeds, TCL_ERROR else.  *  * Side effects:  *	Removes functionality from an interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_MakeSafe
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Make this interpreter "safe". */
block|{
if|if
condition|(
name|interp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|MakeSafe
argument_list|(
name|interp
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CreateSlave --  *  *	Creates a slave interpreter. The slavePath argument denotes the  *	name of the new slave relative to the current interpreter; the  *	slave is a direct descendant of the one-before-last component of  *	the path, e.g. it is a descendant of the current interpreter if  *	the slavePath argument contains only one component. Optionally makes  *	the slave interpreter safe.  *  * Results:  *	Returns the interpreter structure created, or NULL if an error  *	occurred.  *  * Side effects:  *	Creates a new interpreter and a new interpreter object command in  *	the interpreter indicated by the slavePath argument.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Interp
modifier|*
name|Tcl_CreateSlave
parameter_list|(
name|interp
parameter_list|,
name|slavePath
parameter_list|,
name|isSafe
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to start search at. */
name|char
modifier|*
name|slavePath
decl_stmt|;
comment|/* Name of slave to create. */
name|int
name|isSafe
decl_stmt|;
comment|/* Should new slave be "safe" ? */
block|{
if|if
condition|(
operator|(
name|interp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
operator|)
operator|||
operator|(
name|slavePath
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|CreateSlave
argument_list|(
name|interp
argument_list|,
name|slavePath
argument_list|,
name|isSafe
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetSlave --  *  *	Finds a slave interpreter by its path name.  *  * Results:  *	Returns a Tcl_Interp * for the named interpreter or NULL if not  *	found.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Interp
modifier|*
name|Tcl_GetSlave
parameter_list|(
name|interp
parameter_list|,
name|slavePath
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to start search from. */
name|char
modifier|*
name|slavePath
decl_stmt|;
comment|/* Path of slave to find. */
block|{
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Interim storage for Master record. */
if|if
condition|(
operator|(
name|interp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
operator|)
operator|||
operator|(
name|slavePath
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclMasterRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterPtr
operator|==
operator|(
name|Master
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_GetSlave: could not find master record"
argument_list|)
expr_stmt|;
block|}
return|return
name|GetInterp
argument_list|(
name|interp
argument_list|,
name|masterPtr
argument_list|,
name|slavePath
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetMaster --  *  *	Finds the master interpreter of a slave interpreter.  *  * Results:  *	Returns a Tcl_Interp * for the master interpreter or NULL if none.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Interp
modifier|*
name|Tcl_GetMaster
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Get the master of this interpreter. */
block|{
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Slave record of this interpreter. */
if|if
condition|(
name|interp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclSlaveRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slavePtr
operator|==
operator|(
name|Slave
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|slavePtr
operator|->
name|masterInterp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CreateAlias --  *  *	Creates an alias between two interpreters.  *  * Results:  *	TCL_OK if successful, TCL_ERROR if failed. If TCL_ERROR is returned  *	the result of slaveInterp will contain an error message.  *  * Side effects:  *	Creates a new alias, manipulates the result field of slaveInterp.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_CreateAlias
parameter_list|(
name|slaveInterp
parameter_list|,
name|slaveCmd
parameter_list|,
name|targetInterp
parameter_list|,
name|targetCmd
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|Tcl_Interp
modifier|*
name|slaveInterp
decl_stmt|;
comment|/* Interpreter for source command. */
name|char
modifier|*
name|slaveCmd
decl_stmt|;
comment|/* Command to install in slave. */
name|Tcl_Interp
modifier|*
name|targetInterp
decl_stmt|;
comment|/* Interpreter for target command. */
name|char
modifier|*
name|targetCmd
decl_stmt|;
comment|/* Name of target command. */
name|int
name|argc
decl_stmt|;
comment|/* How many additional arguments? */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* These are the additional args. */
block|{
name|Master
modifier|*
name|masterPtr
decl_stmt|;
comment|/* Master record for target interp. */
if|if
condition|(
operator|(
name|slaveInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
operator|)
operator|||
operator|(
name|targetInterp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
operator|)
operator|||
operator|(
name|slaveCmd
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
operator|||
operator|(
name|targetCmd
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|masterPtr
operator|=
operator|(
name|Master
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|targetInterp
argument_list|,
literal|"tclMasterRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterPtr
operator|==
operator|(
name|Master
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_CreateAlias: could not find master record"
argument_list|)
expr_stmt|;
block|}
return|return
name|AliasHelper
argument_list|(
name|slaveInterp
argument_list|,
name|slaveInterp
argument_list|,
name|targetInterp
argument_list|,
name|masterPtr
argument_list|,
name|slaveCmd
argument_list|,
name|targetCmd
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetAlias --  *  *	Gets information about an alias.  *  * Results:  *	TCL_OK if successful, TCL_ERROR else. If TCL_ERROR is returned, the  *	result field of the interpreter given as argument will contain an  *	error message.  *  * Side effects:  *	Manipulates the result field of the interpreter given as argument.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_GetAlias
parameter_list|(
name|interp
parameter_list|,
name|aliasName
parameter_list|,
name|targetInterpPtr
parameter_list|,
name|targetNamePtr
parameter_list|,
name|argcPtr
parameter_list|,
name|argvPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interp to start search from. */
name|char
modifier|*
name|aliasName
decl_stmt|;
comment|/* Name of alias to find. */
name|Tcl_Interp
modifier|*
modifier|*
name|targetInterpPtr
decl_stmt|;
comment|/* (Return) target interpreter. */
name|char
modifier|*
modifier|*
name|targetNamePtr
decl_stmt|;
comment|/* (Return) name of target command. */
name|int
modifier|*
name|argcPtr
decl_stmt|;
comment|/* (Return) count of addnl args. */
name|char
modifier|*
modifier|*
modifier|*
name|argvPtr
decl_stmt|;
comment|/* (Return) additional arguments. */
block|{
name|Slave
modifier|*
name|slavePtr
decl_stmt|;
comment|/* Slave record for slave interp. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Search element. */
name|Alias
modifier|*
name|aliasPtr
decl_stmt|;
comment|/* Storage for alias found. */
if|if
condition|(
operator|(
name|interp
operator|==
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
operator|)
operator|||
operator|(
name|aliasName
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|slavePtr
operator|=
operator|(
name|Slave
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclSlaveRecord"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slavePtr
operator|==
operator|(
name|Slave
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_GetAlias: could not find slave record"
argument_list|)
expr_stmt|;
block|}
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
operator|(
name|slavePtr
operator|->
name|aliasTable
operator|)
argument_list|,
name|aliasName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"alias \""
argument_list|,
name|aliasName
argument_list|,
literal|"\" not found"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|aliasPtr
operator|=
operator|(
name|Alias
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetInterpPtr
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
operator|*
name|targetInterpPtr
operator|=
name|aliasPtr
operator|->
name|targetInterp
expr_stmt|;
block|}
if|if
condition|(
name|targetNamePtr
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
operator|*
name|targetNamePtr
operator|=
name|aliasPtr
operator|->
name|targetName
expr_stmt|;
block|}
if|if
condition|(
name|argcPtr
operator|!=
operator|(
name|int
operator|*
operator|)
name|NULL
condition|)
block|{
operator|*
name|argcPtr
operator|=
name|aliasPtr
operator|->
name|argc
expr_stmt|;
block|}
if|if
condition|(
name|argvPtr
operator|!=
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
operator|*
name|argvPtr
operator|=
name|aliasPtr
operator|->
name|argv
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

end_unit

