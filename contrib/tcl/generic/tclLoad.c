begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclLoad.c --  *  *	This file provides the generic portion (those that are the same  *	on all platforms) of Tcl's dynamic loading facilities.  *  * Copyright (c) 1995 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclLoad.c 1.17 97/07/24 20:05:04  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_comment
comment|/*  * The following structure describes a package that has been loaded  * either dynamically (with the "load" command) or statically (as  * indicated by a call to Tcl_PackageLoaded).  All such packages  * are linked together into a single list for the process.  Packages  * are never unloaded, so these structures are never freed.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|LoadedPackage
block|{
name|char
modifier|*
name|fileName
decl_stmt|;
comment|/* Name of the file from which the 				 * package was loaded.  An empty string 				 * means the package is loaded statically. 				 * Malloc-ed. */
name|char
modifier|*
name|packageName
decl_stmt|;
comment|/* Name of package prefix for the package, 				 * properly capitalized (first letter UC, 				 * others LC), no "_", as in "Net".  				 * Malloc-ed. */
name|Tcl_PackageInitProc
modifier|*
name|initProc
decl_stmt|;
comment|/* Initialization procedure to call to 				 * incorporate this package into a trusted 				 * interpreter. */
name|Tcl_PackageInitProc
modifier|*
name|safeInitProc
decl_stmt|;
comment|/* Initialization procedure to call to 				 * incorporate this package into a safe 				 * interpreter (one that will execute 				 * untrusted scripts).   NULL means the 				 * package can't be used in unsafe 				 * interpreters. */
name|struct
name|LoadedPackage
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next in list of all packages loaded into 				 * this application process.  NULL means 				 * end of list. */
block|}
name|LoadedPackage
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|LoadedPackage
modifier|*
name|firstPackagePtr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First in list of all packages loaded into 				 * this process. */
end_comment

begin_comment
comment|/*  * The following structure represents a particular package that has  * been incorporated into a particular interpreter (by calling its  * initialization procedure).  There is a list of these structures for  * each interpreter, with an AssocData value (key "load") for the  * interpreter that points to the first package (if any).  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|InterpPackage
block|{
name|LoadedPackage
modifier|*
name|pkgPtr
decl_stmt|;
comment|/* Points to detailed information about 				 * package. */
name|struct
name|InterpPackage
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next package in this interpreter, or 				 * NULL for end of list. */
block|}
name|InterpPackage
typedef|;
end_typedef

begin_comment
comment|/*  * Prototypes for procedures that are private to this file:  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|LoadCleanupProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|LoadExitProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_LoadCmd --  *  *	This procedure is invoked to process the "load" Tcl command.  *	See the user documentation for details on what it does.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	See the user documentation.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_LoadCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Tcl_Interp
modifier|*
name|target
decl_stmt|;
name|LoadedPackage
modifier|*
name|pkgPtr
decl_stmt|,
modifier|*
name|defaultPtr
decl_stmt|;
name|Tcl_DString
name|pkgName
decl_stmt|,
name|initName
decl_stmt|,
name|safeInitName
decl_stmt|,
name|fileName
decl_stmt|;
name|Tcl_PackageInitProc
modifier|*
name|initProc
decl_stmt|,
modifier|*
name|safeInitProc
decl_stmt|;
name|InterpPackage
modifier|*
name|ipFirstPtr
decl_stmt|,
modifier|*
name|ipPtr
decl_stmt|;
name|int
name|code
decl_stmt|,
name|c
decl_stmt|,
name|gotPkgName
decl_stmt|,
name|namesMatch
decl_stmt|,
name|filesMatch
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|fullFileName
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
if|if
condition|(
operator|(
name|argc
operator|<
literal|2
operator|)
operator|||
operator|(
name|argc
operator|>
literal|4
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" fileName ?packageName? ?interp?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|fullFileName
operator|=
name|Tcl_TranslateFileName
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|fileName
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullFileName
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_DStringInit
argument_list|(
operator|&
name|pkgName
argument_list|)
expr_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|initName
argument_list|)
expr_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|safeInitName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|argc
operator|>=
literal|3
operator|)
operator|&&
operator|(
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|gotPkgName
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|gotPkgName
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fullFileName
index|[
literal|0
index|]
operator|==
literal|0
operator|)
operator|&&
operator|!
name|gotPkgName
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"must specify either file name or package name"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*      * Figure out which interpreter we're going to load the package into.      */
name|target
operator|=
name|interp
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|4
condition|)
block|{
name|target
operator|=
name|Tcl_GetSlave
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't find slave interpreter named \""
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
comment|/*      * Scan through the packages that are currently loaded to see if the      * package we want is already loaded.  We'll use a loaded package if      * it meets any of the following conditions:      *  - Its name and file match the once we're looking for.      *  - Its file matches, and we weren't given a name.      *  - Its name matches, the file name was specified as empty, and there      *    is only no statically loaded package with the same name.      */
name|defaultPtr
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|pkgPtr
operator|=
name|firstPackagePtr
init|;
name|pkgPtr
operator|!=
name|NULL
condition|;
name|pkgPtr
operator|=
name|pkgPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
operator|!
name|gotPkgName
condition|)
block|{
name|namesMatch
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|namesMatch
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|p1
operator|=
name|argv
index|[
literal|2
index|]
operator|,
name|p2
operator|=
name|pkgPtr
operator|->
name|packageName
init|;
condition|;
name|p1
operator|++
operator|,
name|p2
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|isupper
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p1
argument_list|)
argument_list|)
condition|?
name|tolower
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p1
argument_list|)
argument_list|)
else|:
operator|*
name|p1
operator|)
operator|!=
operator|(
name|isupper
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p2
argument_list|)
argument_list|)
condition|?
name|tolower
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p2
argument_list|)
argument_list|)
else|:
operator|*
name|p2
operator|)
condition|)
block|{
name|namesMatch
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|p1
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
block|}
name|filesMatch
operator|=
operator|(
name|strcmp
argument_list|(
name|pkgPtr
operator|->
name|fileName
argument_list|,
name|fullFileName
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|filesMatch
operator|&&
operator|(
name|namesMatch
operator|||
operator|!
name|gotPkgName
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|namesMatch
operator|&&
operator|(
name|fullFileName
index|[
literal|0
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|defaultPtr
operator|=
name|pkgPtr
expr_stmt|;
block|}
if|if
condition|(
name|filesMatch
operator|&&
operator|!
name|namesMatch
operator|&&
operator|(
name|fullFileName
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 	     * Can't have two different packages loaded from the same 	     * file. 	     */
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"file \""
argument_list|,
name|fullFileName
argument_list|,
literal|"\" is already loaded for package \""
argument_list|,
name|pkgPtr
operator|->
name|packageName
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|pkgPtr
operator|==
name|NULL
condition|)
block|{
name|pkgPtr
operator|=
name|defaultPtr
expr_stmt|;
block|}
comment|/*      * Scan through the list of packages already loaded in the target      * interpreter.  If the package we want is already loaded there,      * then there's nothing for us to to.      */
if|if
condition|(
name|pkgPtr
operator|!=
name|NULL
condition|)
block|{
name|ipFirstPtr
operator|=
operator|(
name|InterpPackage
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|target
argument_list|,
literal|"tclLoad"
argument_list|,
operator|(
name|Tcl_InterpDeleteProc
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|ipPtr
operator|=
name|ipFirstPtr
init|;
name|ipPtr
operator|!=
name|NULL
condition|;
name|ipPtr
operator|=
name|ipPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|ipPtr
operator|->
name|pkgPtr
operator|==
name|pkgPtr
condition|)
block|{
name|code
operator|=
name|TCL_OK
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
if|if
condition|(
name|pkgPtr
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * The desired file isn't currently loaded, so load it.  It's an 	 * error if the desired package is a static one. 	 */
if|if
condition|(
name|fullFileName
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"package \""
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"\" isn't loaded statically"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Figure out the module name if it wasn't provided explicitly. 	 */
if|if
condition|(
name|gotPkgName
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|pkgName
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|TclGuessPackageName
argument_list|(
name|fullFileName
argument_list|,
operator|&
name|pkgName
argument_list|)
condition|)
block|{
name|int
name|pargc
decl_stmt|;
name|char
modifier|*
modifier|*
name|pargv
decl_stmt|,
modifier|*
name|pkgGuess
decl_stmt|;
comment|/* 		 * The platform-specific code couldn't figure out the 		 * module name.  Make a guess by taking the last element 		 * of the file name, stripping off any leading "lib", 		 * and then using all of the alphabetic and underline 		 * characters that follow that. 		 */
name|Tcl_SplitPath
argument_list|(
name|fullFileName
argument_list|,
operator|&
name|pargc
argument_list|,
operator|&
name|pargv
argument_list|)
expr_stmt|;
name|pkgGuess
operator|=
name|pargv
index|[
name|pargc
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|pkgGuess
index|[
literal|0
index|]
operator|==
literal|'l'
operator|)
operator|&&
operator|(
name|pkgGuess
index|[
literal|1
index|]
operator|==
literal|'i'
operator|)
operator|&&
operator|(
name|pkgGuess
index|[
literal|2
index|]
operator|==
literal|'b'
operator|)
condition|)
block|{
name|pkgGuess
operator|+=
literal|3
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|pkgGuess
init|;
name|isalpha
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'_'
operator|)
condition|;
name|p
operator|++
control|)
block|{
comment|/* Empty loop body. */
block|}
if|if
condition|(
name|p
operator|==
name|pkgGuess
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pargv
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't figure out package name for "
argument_list|,
name|fullFileName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|Tcl_DStringAppend
argument_list|(
operator|&
name|pkgName
argument_list|,
name|pkgGuess
argument_list|,
operator|(
name|p
operator|-
name|pkgGuess
operator|)
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pargv
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Fix the capitalization in the package name so that the first 	 * character is in caps but the others are all lower-case. 	 */
name|p
operator|=
name|Tcl_DStringValue
argument_list|(
operator|&
name|pkgName
argument_list|)
expr_stmt|;
name|c
operator|=
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|islower
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|*
name|p
operator|=
operator|(
name|char
operator|)
name|toupper
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|*
name|p
operator|=
operator|(
name|char
operator|)
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Compute the names of the two initialization procedures, 	 * based on the package name. 	 */
name|Tcl_DStringAppend
argument_list|(
operator|&
name|initName
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|pkgName
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|initName
argument_list|,
literal|"_Init"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|safeInitName
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|pkgName
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|safeInitName
argument_list|,
literal|"_SafeInit"
argument_list|,
literal|9
argument_list|)
expr_stmt|;
comment|/* 	 * Call platform-specific code to load the package and find the 	 * two initialization procedures. 	 */
name|code
operator|=
name|TclLoadFile
argument_list|(
name|interp
argument_list|,
name|fullFileName
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|initName
argument_list|)
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|safeInitName
argument_list|)
argument_list|,
operator|&
name|initProc
argument_list|,
operator|&
name|safeInitProc
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|initProc
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't find procedure "
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|initName
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Create a new record to describe this package. 	 */
if|if
condition|(
name|firstPackagePtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_CreateExitHandler
argument_list|(
name|LoadExitProc
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|pkgPtr
operator|=
operator|(
name|LoadedPackage
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|LoadedPackage
argument_list|)
argument_list|)
expr_stmt|;
name|pkgPtr
operator|->
name|fileName
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|fullFileName
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|pkgPtr
operator|->
name|fileName
argument_list|,
name|fullFileName
argument_list|)
expr_stmt|;
name|pkgPtr
operator|->
name|packageName
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|Tcl_DStringLength
argument_list|(
operator|&
name|pkgName
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|pkgPtr
operator|->
name|packageName
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|pkgName
argument_list|)
argument_list|)
expr_stmt|;
name|pkgPtr
operator|->
name|initProc
operator|=
name|initProc
expr_stmt|;
name|pkgPtr
operator|->
name|safeInitProc
operator|=
name|safeInitProc
expr_stmt|;
name|pkgPtr
operator|->
name|nextPtr
operator|=
name|firstPackagePtr
expr_stmt|;
name|firstPackagePtr
operator|=
name|pkgPtr
expr_stmt|;
block|}
comment|/*      * Invoke the package's initialization procedure (either the      * normal one or the safe one, depending on whether or not the      * interpreter is safe).      */
if|if
condition|(
name|Tcl_IsSafe
argument_list|(
name|target
argument_list|)
condition|)
block|{
if|if
condition|(
name|pkgPtr
operator|->
name|safeInitProc
operator|!=
name|NULL
condition|)
block|{
name|code
operator|=
call|(
modifier|*
name|pkgPtr
operator|->
name|safeInitProc
call|)
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"can't use package in a safe interpreter: "
argument_list|,
literal|"no "
argument_list|,
name|pkgPtr
operator|->
name|packageName
argument_list|,
literal|"_SafeInit procedure"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|code
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
name|code
operator|=
call|(
modifier|*
name|pkgPtr
operator|->
name|initProc
call|)
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|code
operator|==
name|TCL_ERROR
operator|)
operator|&&
operator|(
name|target
operator|!=
name|interp
operator|)
condition|)
block|{
comment|/* 	 * An error occurred, so transfer error information from the 	 * destination interpreter back to our interpreter.  Must clear 	 * interp's result before calling Tcl_AddErrorInfo, since 	 * Tcl_AddErrorInfo will store the interp's result in errorInfo 	 * before appending target's $errorInfo;  we've already got 	 * everything we need in target's $errorInfo. 	 */
comment|/*          * It is (abusively) assumed that errorInfo and errorCode vars exists.          * we changed SetVar2 to accept NULL values to avoid crashes. --dl 	 */
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
name|Tcl_GetVar2
argument_list|(
name|target
argument_list|,
literal|"errorInfo"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|Tcl_GetVar2
argument_list|(
name|target
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|target
operator|->
name|result
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
comment|/*      * Record the fact that the package has been loaded in the      * target interpreter.      */
if|if
condition|(
name|code
operator|==
name|TCL_OK
condition|)
block|{
comment|/* 	 * Refetch ipFirstPtr: loading the package may have introduced 	 * additional static packages at the head of the linked list! 	 */
name|ipFirstPtr
operator|=
operator|(
name|InterpPackage
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|target
argument_list|,
literal|"tclLoad"
argument_list|,
operator|(
name|Tcl_InterpDeleteProc
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ipPtr
operator|=
operator|(
name|InterpPackage
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|InterpPackage
argument_list|)
argument_list|)
expr_stmt|;
name|ipPtr
operator|->
name|pkgPtr
operator|=
name|pkgPtr
expr_stmt|;
name|ipPtr
operator|->
name|nextPtr
operator|=
name|ipFirstPtr
expr_stmt|;
name|Tcl_SetAssocData
argument_list|(
name|target
argument_list|,
literal|"tclLoad"
argument_list|,
name|LoadCleanupProc
argument_list|,
operator|(
name|ClientData
operator|)
name|ipPtr
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|Tcl_DStringFree
argument_list|(
operator|&
name|pkgName
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|initName
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|safeInitName
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|fileName
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_StaticPackage --  *  *	This procedure is invoked to indicate that a particular  *	package has been linked statically with an application.  *  * Results:  *	None.  *  * Side effects:  *	Once this procedure completes, the package becomes loadable  *	via the "load" command with an empty file name.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_StaticPackage
parameter_list|(
name|interp
parameter_list|,
name|pkgName
parameter_list|,
name|initProc
parameter_list|,
name|safeInitProc
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* If not NULL, it means that the 					 * package has already been loaded 					 * into the given interpreter by 					 * calling the appropriate init proc. */
name|char
modifier|*
name|pkgName
decl_stmt|;
comment|/* Name of package (must be properly 					 * capitalized: first letter upper 					 * case, others lower case). */
name|Tcl_PackageInitProc
modifier|*
name|initProc
decl_stmt|;
comment|/* Procedure to call to incorporate 					 * this package into a trusted 					 * interpreter. */
name|Tcl_PackageInitProc
modifier|*
name|safeInitProc
decl_stmt|;
comment|/* Procedure to call to incorporate 					 * this package into a safe interpreter 					 * (one that will execute untrusted 					 * scripts).   NULL means the package 					 * can't be used in safe 					 * interpreters. */
block|{
name|LoadedPackage
modifier|*
name|pkgPtr
decl_stmt|;
name|InterpPackage
modifier|*
name|ipPtr
decl_stmt|,
modifier|*
name|ipFirstPtr
decl_stmt|;
comment|/*      * Check to see if someone else has already reported this package as      * statically loaded.  If this call is redundant then just return.      */
for|for
control|(
name|pkgPtr
operator|=
name|firstPackagePtr
init|;
name|pkgPtr
operator|!=
name|NULL
condition|;
name|pkgPtr
operator|=
name|pkgPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
operator|(
name|pkgPtr
operator|->
name|initProc
operator|==
name|initProc
operator|)
operator|&&
operator|(
name|pkgPtr
operator|->
name|safeInitProc
operator|==
name|safeInitProc
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|pkgPtr
operator|->
name|packageName
argument_list|,
name|pkgName
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return;
block|}
block|}
if|if
condition|(
name|firstPackagePtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_CreateExitHandler
argument_list|(
name|LoadExitProc
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|pkgPtr
operator|=
operator|(
name|LoadedPackage
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|LoadedPackage
argument_list|)
argument_list|)
expr_stmt|;
name|pkgPtr
operator|->
name|fileName
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|)
expr_stmt|;
name|pkgPtr
operator|->
name|fileName
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|pkgPtr
operator|->
name|packageName
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|pkgName
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|pkgPtr
operator|->
name|packageName
argument_list|,
name|pkgName
argument_list|)
expr_stmt|;
name|pkgPtr
operator|->
name|initProc
operator|=
name|initProc
expr_stmt|;
name|pkgPtr
operator|->
name|safeInitProc
operator|=
name|safeInitProc
expr_stmt|;
name|pkgPtr
operator|->
name|nextPtr
operator|=
name|firstPackagePtr
expr_stmt|;
name|firstPackagePtr
operator|=
name|pkgPtr
expr_stmt|;
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|ipFirstPtr
operator|=
operator|(
name|InterpPackage
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclLoad"
argument_list|,
operator|(
name|Tcl_InterpDeleteProc
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ipPtr
operator|=
operator|(
name|InterpPackage
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|InterpPackage
argument_list|)
argument_list|)
expr_stmt|;
name|ipPtr
operator|->
name|pkgPtr
operator|=
name|pkgPtr
expr_stmt|;
name|ipPtr
operator|->
name|nextPtr
operator|=
name|ipFirstPtr
expr_stmt|;
name|Tcl_SetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclLoad"
argument_list|,
name|LoadCleanupProc
argument_list|,
operator|(
name|ClientData
operator|)
name|ipPtr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclGetLoadedPackages --  *  *	This procedure returns information about all of the files  *	that are loaded (either in a particular intepreter, or  *	for all interpreters).  *  * Results:  *	The return value is a standard Tcl completion code.  If  *	successful, a list of lists is placed in interp->result.  *	Each sublist corresponds to one loaded file;  its first  *	element is the name of the file (or an empty string for  *	something that's statically loaded) and the second element  *	is the name of the package in that file.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclGetLoadedPackages
parameter_list|(
name|interp
parameter_list|,
name|targetName
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to return 				 * information or error message. */
name|char
modifier|*
name|targetName
decl_stmt|;
comment|/* Name of target interpreter or NULL. 				 * If NULL, return info about all interps; 				 * otherwise, just return info about this 				 * interpreter. */
block|{
name|Tcl_Interp
modifier|*
name|target
decl_stmt|;
name|LoadedPackage
modifier|*
name|pkgPtr
decl_stmt|;
name|InterpPackage
modifier|*
name|ipPtr
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
if|if
condition|(
name|targetName
operator|==
name|NULL
condition|)
block|{
comment|/*  	 * Return information about all of the available packages. 	 */
name|prefix
operator|=
literal|"{"
expr_stmt|;
for|for
control|(
name|pkgPtr
operator|=
name|firstPackagePtr
init|;
name|pkgPtr
operator|!=
name|NULL
condition|;
name|pkgPtr
operator|=
name|pkgPtr
operator|->
name|nextPtr
control|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|prefix
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|pkgPtr
operator|->
name|fileName
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|pkgPtr
operator|->
name|packageName
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"}"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|prefix
operator|=
literal|" {"
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
comment|/*      * Return information about only the packages that are loaded in      * a given interpreter.      */
name|target
operator|=
name|Tcl_GetSlave
argument_list|(
name|interp
argument_list|,
name|targetName
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't find slave interpreter named \""
argument_list|,
name|targetName
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|ipPtr
operator|=
operator|(
name|InterpPackage
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|target
argument_list|,
literal|"tclLoad"
argument_list|,
operator|(
name|Tcl_InterpDeleteProc
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|prefix
operator|=
literal|"{"
expr_stmt|;
for|for
control|(
init|;
name|ipPtr
operator|!=
name|NULL
condition|;
name|ipPtr
operator|=
name|ipPtr
operator|->
name|nextPtr
control|)
block|{
name|pkgPtr
operator|=
name|ipPtr
operator|->
name|pkgPtr
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|prefix
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|pkgPtr
operator|->
name|fileName
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|pkgPtr
operator|->
name|packageName
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"}"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|prefix
operator|=
literal|" {"
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * LoadCleanupProc --  *  *	This procedure is called to delete all of the InterpPackage  *	structures for an interpreter when the interpreter is deleted.  *	It gets invoked via the Tcl AssocData mechanism.  *  * Results:  *	None.  *  * Side effects:  *	Storage for all of the InterpPackage procedures for interp  *	get deleted.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|LoadCleanupProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Pointer to first InterpPackage structure 				 * for interp. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter that is being deleted. */
block|{
name|InterpPackage
modifier|*
name|ipPtr
decl_stmt|,
modifier|*
name|nextPtr
decl_stmt|;
name|ipPtr
operator|=
operator|(
name|InterpPackage
operator|*
operator|)
name|clientData
expr_stmt|;
while|while
condition|(
name|ipPtr
operator|!=
name|NULL
condition|)
block|{
name|nextPtr
operator|=
name|ipPtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ipPtr
argument_list|)
expr_stmt|;
name|ipPtr
operator|=
name|nextPtr
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * LoadExitProc --  *  *	This procedure is invoked just before the application exits.  *	It frees all of the LoadedPackage structures.  *  * Results:  *	None.  *  * Side effects:  *	Memory is freed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|LoadExitProc
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
block|{
name|LoadedPackage
modifier|*
name|pkgPtr
decl_stmt|;
while|while
condition|(
name|firstPackagePtr
operator|!=
name|NULL
condition|)
block|{
name|pkgPtr
operator|=
name|firstPackagePtr
expr_stmt|;
name|firstPackagePtr
operator|=
name|pkgPtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
name|pkgPtr
operator|->
name|fileName
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|pkgPtr
operator|->
name|packageName
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pkgPtr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

