begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * tclInt.h --  *  *	Declarations of things used internally by the Tcl interpreter.  *  * Copyright (c) 1987-1993 The Regents of the University of California.  * Copyright (c) 1994-1997 Sun Microsystems, Inc.  * Copyright (c) 1993-1997 Lucent Technologies.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  *SCCS: @(#) tclInt.h 1.293 97/08/12 17:07:02  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_TCLINT
end_ifndef

begin_define
define|#
directive|define
name|_TCLINT
end_define

begin_comment
comment|/*  * Common include files needed by most of the Tcl source files are  * included here, so that system-dependent personalizations for the  * include files only have to be made in once place.  This results  * in a few extra includes, but greater modularity.  The order of  * the three groups of #includes is important.  For example, stdio.h  * is needed by tcl.h, and the _ANSI_ARGS_ declaration in tcl.h is  * needed by stdlib.h in some configurations.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_TCL
end_ifndef

begin_include
include|#
directive|include
file|"tcl.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_REGEXP
end_ifndef

begin_include
include|#
directive|include
file|"tclRegexp.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NO_LIMITS_H
end_ifdef

begin_include
include|#
directive|include
file|"../compat/limits.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|"../compat/stdlib.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|"../compat/string.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_STDARG
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *----------------------------------------------------------------  * Data structures related to namespaces.  *----------------------------------------------------------------  */
end_comment

begin_comment
comment|/*  * The structure below defines a namespace.  * Note: the first five fields must match exactly the fields in a  * Tcl_Namespace structure (see tcl.h). If you change one, be sure to  * change the other.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Namespace
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The namespace's simple (unqualified) 				  * name. This contains no ::'s. The name of 				  * the global namespace is "" although "::" 				  * is an synonym. */
name|char
modifier|*
name|fullName
decl_stmt|;
comment|/* The namespace's fully qualified name. 				  * This starts with ::. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* An arbitrary value associated with this 				  * namespace. */
name|Tcl_NamespaceDeleteProc
modifier|*
name|deleteProc
decl_stmt|;
comment|/* Procedure invoked when deleting the 				  * namespace to, e.g., free clientData. */
name|struct
name|Namespace
modifier|*
name|parentPtr
decl_stmt|;
comment|/* Points to the namespace that contains 				  * this one. NULL if this is the global 				  * namespace. */
name|Tcl_HashTable
name|childTable
decl_stmt|;
comment|/* Contains any child namespaces. Indexed                                   * by strings; values have type 				  * (Namespace *). */
name|long
name|nsId
decl_stmt|;
comment|/* Unique id for the namespace. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interpreter containing this 				  * namespace. */
name|int
name|flags
decl_stmt|;
comment|/* OR-ed combination of the namespace 				  * status flags NS_DYING and NS_DEAD 				  * listed below. */
name|int
name|activationCount
decl_stmt|;
comment|/* Number of "activations" or active call 				  * frames for this namespace that are on 				  * the Tcl call stack. The namespace won't 				  * be freed until activationCount becomes 				  * zero. */
name|int
name|refCount
decl_stmt|;
comment|/* Count of references by namespaceName * 				  * objects. The namespace can't be freed 				  * until refCount becomes zero. */
name|Tcl_HashTable
name|cmdTable
decl_stmt|;
comment|/* Contains all the commands currently                                   * registered in the namespace. Indexed by                                   * strings; values have type (Command *). 				  * Commands imported by Tcl_Import have 				  * Command structures that point (via an 				  * ImportedCmdRef structure) to the 				  * Command structure in the source 				  * namespace's command table. */
name|Tcl_HashTable
name|varTable
decl_stmt|;
comment|/* Contains all the (global) variables 				  * currently in this namespace. Indexed                                   * by strings; values have type (Var *). */
name|char
modifier|*
modifier|*
name|exportArrayPtr
decl_stmt|;
comment|/* Points to an array of string patterns 				  * specifying which commands are exported. 				  * A pattern may include "string match" 				  * style wildcard characters to specify 				  * multiple commands; however, no namespace 				  * qualifiers are allowed. NULL if no 				  * export patterns are registered. */
name|int
name|numExportPatterns
decl_stmt|;
comment|/* Number of export patterns currently 				  * registered using "namespace export". */
name|int
name|maxExportPatterns
decl_stmt|;
comment|/* Mumber of export patterns for which 				  * space is currently allocated. */
name|int
name|cmdRefEpoch
decl_stmt|;
comment|/* Incremented if a newly added command 				  * shadows a command for which this 				  * namespace has already cached a Command * 				  * pointer; this causes all its cached 				  * Command* pointers to be invalidated. */
block|}
name|Namespace
typedef|;
end_typedef

begin_comment
comment|/*  * Flags used to represent the status of a namespace:  *  * NS_DYING -	1 means Tcl_DeleteNamespace has been called to delete the  *		namespace but there are still active call frames on the Tcl  *		stack that refer to the namespace. When the last call frame  *		referring to it has been popped, it's variables and command  *		will be destroyed and it will be marked "dead" (NS_DEAD).  *		The namespace can no longer be looked up by name.  * NS_DEAD -	1 means Tcl_DeleteNamespace has been called to delete the  *		namespace and no call frames still refer to it. Its  *		variables and command have already been destroyed. This bit  *		allows the namespace resolution code to recognize that the  *		namespace is "deleted". When the last namespaceName object  *		in any byte code code unit that refers to the namespace has  *		been freed (i.e., when the namespace's refCount is 0), the  *		namespace's storage will be freed.  */
end_comment

begin_define
define|#
directive|define
name|NS_DYING
value|0x01
end_define

begin_define
define|#
directive|define
name|NS_DEAD
value|0x02
end_define

begin_comment
comment|/*  * Flag passed to TclGetNamespaceForQualName to have it create all namespace  * components of a namespace-qualified name that cannot be found. The new  * namespaces are created within their specified parent. Note that this  * flag's value must not conflict with the values of the flags  * TCL_GLOBAL_ONLY, TCL_NAMESPACE_ONLY, and FIND_ONLY_NS (defined in  * tclNamesp.c).  */
end_comment

begin_define
define|#
directive|define
name|CREATE_NS_IF_UNKNOWN
value|0x800
end_define

begin_comment
comment|/*  *----------------------------------------------------------------  * Data structures related to variables.   These are used primarily  * in tclVar.c  *----------------------------------------------------------------  */
end_comment

begin_comment
comment|/*  * The following structure defines a variable trace, which is used to  * invoke a specific C procedure whenever certain operations are performed  * on a variable.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|VarTrace
block|{
name|Tcl_VarTraceProc
modifier|*
name|traceProc
decl_stmt|;
comment|/* Procedure to call when operations given 				 * by flags are performed on variable. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Argument to pass to proc. */
name|int
name|flags
decl_stmt|;
comment|/* What events the trace procedure is 				 * interested in:  OR-ed combination of 				 * TCL_TRACE_READS, TCL_TRACE_WRITES, and 				 * TCL_TRACE_UNSETS. */
name|struct
name|VarTrace
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next in list of traces associated with 				 * a particular variable. */
block|}
name|VarTrace
typedef|;
end_typedef

begin_comment
comment|/*  * When a variable trace is active (i.e. its associated procedure is  * executing), one of the following structures is linked into a list  * associated with the variable's interpreter.  The information in  * the structure is needed in order for Tcl to behave reasonably  * if traces are deleted while traces are active.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ActiveVarTrace
block|{
name|struct
name|Var
modifier|*
name|varPtr
decl_stmt|;
comment|/* Variable that's being traced. */
name|struct
name|ActiveVarTrace
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next in list of all active variable 				 * traces for the interpreter, or NULL 				 * if no more. */
name|VarTrace
modifier|*
name|nextTracePtr
decl_stmt|;
comment|/* Next trace to check after current 				 * trace procedure returns;  if this 				 * trace gets deleted, must update pointer 				 * to avoid using free'd memory. */
block|}
name|ActiveVarTrace
typedef|;
end_typedef

begin_comment
comment|/*  * The following structure describes an enumerative search in progress on  * an array variable;  this are invoked with options to the "array"  * command.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ArraySearch
block|{
name|int
name|id
decl_stmt|;
comment|/* Integer id used to distinguish among 				 * multiple concurrent searches for the 				 * same array. */
name|struct
name|Var
modifier|*
name|varPtr
decl_stmt|;
comment|/* Pointer to array variable that's being 				 * searched. */
name|Tcl_HashSearch
name|search
decl_stmt|;
comment|/* Info kept by the hash module about 				 * progress through the array. */
name|Tcl_HashEntry
modifier|*
name|nextEntry
decl_stmt|;
comment|/* Non-null means this is the next element 			 	 * to be enumerated (it's leftover from 				 * the Tcl_FirstHashEntry call or from 				 * an "array anymore" command).  NULL 				 * means must call Tcl_NextHashEntry 				 * to get value to return. */
name|struct
name|ArraySearch
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next in list of all active searches 				 * for this variable, or NULL if this is 				 * the last one. */
block|}
name|ArraySearch
typedef|;
end_typedef

begin_comment
comment|/*  * The structure below defines a variable, which associates a string name  * with a Tcl_Obj value. These structures are kept in procedure call frames  * (for local variables recognized by the compiler) or in the heap (for  * global variables and any variable not known to the compiler). For each  * Var structure in the heap, a hash table entry holds the variable name and  * a pointer to the Var structure.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Var
block|{
union|union
block|{
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* The variable's object value. Used for  				 * scalar variables and array elements. */
name|Tcl_HashTable
modifier|*
name|tablePtr
decl_stmt|;
comment|/* For array variables, this points to 				 * information about the hash table used 				 * to implement the associative array.  				 * Points to malloc-ed data. */
name|struct
name|Var
modifier|*
name|linkPtr
decl_stmt|;
comment|/* If this is a global variable being 				 * referred to in a procedure, or a variable 				 * created by "upvar", this field points to 				 * the referenced variable's Var struct. */
block|}
name|value
union|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* NULL if the variable is in a hashtable, 				 * otherwise points to the variable's 				 * name. It is used, e.g., by TclLookupVar 				 * and "info locals". The storage for the 				 * characters of the name is not owned by 				 * the Var and must not be freed when 				 * freeing the Var. */
name|Namespace
modifier|*
name|nsPtr
decl_stmt|;
comment|/* Points to the namespace that contains 				 * this variable or NULL if the variable is 				 * a local variable in a Tcl procedure. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* If variable is in a hashtable, either the 				 * hash table entry that refers to this 				 * variable or NULL if the variable has been 				 * detached from its hash table (e.g. an 				 * array is deleted, but some of its 				 * elements are still referred to in 				 * upvars). NULL if the variable is not in a 				 * hashtable. This is used to delete an 				 * variable from its hashtable if it is no 				 * longer needed. */
name|int
name|refCount
decl_stmt|;
comment|/* Counts number of active uses of this 				 * variable, not including its entry in the 				 * call frame or the hash table: 1 for each 				 * additional variable whose linkPtr points 				 * here, 1 for each nested trace active on 				 * variable, and 1 if the variable is a  				 * namespace variable. This record can't be 				 * deleted until refCount becomes 0. */
name|VarTrace
modifier|*
name|tracePtr
decl_stmt|;
comment|/* First in list of all traces set for this 				 * variable. */
name|ArraySearch
modifier|*
name|searchPtr
decl_stmt|;
comment|/* First in list of all searches active 				 * for this variable, or NULL if none. */
name|int
name|flags
decl_stmt|;
comment|/* Miscellaneous bits of information about 				 * variable. See below for definitions. */
block|}
name|Var
typedef|;
end_typedef

begin_comment
comment|/*  * Flag bits for variables. The first three (VAR_SCALAR, VAR_ARRAY, and  * VAR_LINK) are mutually exclusive and give the "type" of the variable.  * VAR_UNDEFINED is independent of the variable's type.   *  * VAR_SCALAR -			1 means this is a scalar variable and not  *				an array or link. The "objPtr" field points  *				to the variable's value, a Tcl object.  * VAR_ARRAY -			1 means this is an array variable rather  *				than a scalar variable or link. The  *				"tablePtr" field points to the array's  *				hashtable for its elements.  * VAR_LINK - 			1 means this Var structure contains a  *				pointer to another Var structure that  *				either has the real value or is itself  *				another VAR_LINK pointer. Variables like  *				this come about through "upvar" and "global"  *				commands, or through references to variables  *				in enclosing namespaces.  * VAR_UNDEFINED -		1 means that the variable is in the process  *				of being deleted. An undefined variable  *				logically does not exist and survives only  *				while it has a trace, or if it is a global  *				variable currently being used by some  *				procedure.  * VAR_IN_HASHTABLE -		1 means this variable is in a hashtable and  *				the Var structure is malloced. 0 if it is  *				a local variable that was assigned a slot  *				in a procedure frame by	the compiler so the  *				Var storage is part of the call frame.  * VAR_TRACE_ACTIVE -		1 means that trace processing is currently  *				underway for a read or write access, so  *				new read or write accesses should not cause  *				trace procedures to be called and the  *				variable can't be deleted.  * VAR_ARRAY_ELEMENT -		1 means that this variable is an array  *				element, so it is not legal for it to be  *				an array itself (the VAR_ARRAY flag had  *				better not be set).  * VAR_NAMESPACE_VAR -		1 means that this variable was declared  *				as a namespace variable. This flag ensures  *				it persists until its namespace is  *				destroyed or until the variable is unset;  *				it will persist even if it has not been  *				initialized and is marked undefined.  *				The variable's refCount is incremented to  *				reflect the "reference" from its namespace.  */
end_comment

begin_define
define|#
directive|define
name|VAR_SCALAR
value|0x1
end_define

begin_define
define|#
directive|define
name|VAR_ARRAY
value|0x2
end_define

begin_define
define|#
directive|define
name|VAR_LINK
value|0x4
end_define

begin_define
define|#
directive|define
name|VAR_UNDEFINED
value|0x8
end_define

begin_define
define|#
directive|define
name|VAR_IN_HASHTABLE
value|0x10
end_define

begin_define
define|#
directive|define
name|VAR_TRACE_ACTIVE
value|0x20
end_define

begin_define
define|#
directive|define
name|VAR_ARRAY_ELEMENT
value|0x40
end_define

begin_define
define|#
directive|define
name|VAR_NAMESPACE_VAR
value|0x80
end_define

begin_comment
comment|/*  * Macros to ensure that various flag bits are set properly for variables.  * The ANSI C "prototypes" for these macros are:  *  * EXTERN void	TclSetVarScalar _ANSI_ARGS_((Var *varPtr));  * EXTERN void	TclSetVarArray _ANSI_ARGS_((Var *varPtr));  * EXTERN void	TclSetVarLink _ANSI_ARGS_((Var *varPtr));  * EXTERN void	TclSetVarArrayElement _ANSI_ARGS_((Var *varPtr));  * EXTERN void	TclSetVarUndefined _ANSI_ARGS_((Var *varPtr));  * EXTERN void	TclClearVarUndefined _ANSI_ARGS_((Var *varPtr));  */
end_comment

begin_define
define|#
directive|define
name|TclSetVarScalar
parameter_list|(
name|varPtr
parameter_list|)
define|\
value|(varPtr)->flags = ((varPtr)->flags& ~(VAR_ARRAY|VAR_LINK)) | VAR_SCALAR
end_define

begin_define
define|#
directive|define
name|TclSetVarArray
parameter_list|(
name|varPtr
parameter_list|)
define|\
value|(varPtr)->flags = ((varPtr)->flags& ~(VAR_SCALAR|VAR_LINK)) | VAR_ARRAY
end_define

begin_define
define|#
directive|define
name|TclSetVarLink
parameter_list|(
name|varPtr
parameter_list|)
define|\
value|(varPtr)->flags = ((varPtr)->flags& ~(VAR_SCALAR|VAR_ARRAY)) | VAR_LINK
end_define

begin_define
define|#
directive|define
name|TclSetVarArrayElement
parameter_list|(
name|varPtr
parameter_list|)
define|\
value|(varPtr)->flags = ((varPtr)->flags& ~VAR_ARRAY) | VAR_ARRAY_ELEMENT
end_define

begin_define
define|#
directive|define
name|TclSetVarUndefined
parameter_list|(
name|varPtr
parameter_list|)
define|\
value|(varPtr)->flags |= VAR_UNDEFINED
end_define

begin_define
define|#
directive|define
name|TclClearVarUndefined
parameter_list|(
name|varPtr
parameter_list|)
define|\
value|(varPtr)->flags&= ~VAR_UNDEFINED
end_define

begin_comment
comment|/*  * Macros to read various flag bits of variables.  * The ANSI C "prototypes" for these macros are:  *  * EXTERN int	TclIsVarScalar _ANSI_ARGS_((Var *varPtr));  * EXTERN int	TclIsVarLink _ANSI_ARGS_((Var *varPtr));  * EXTERN int	TclIsVarArray _ANSI_ARGS_((Var *varPtr));  * EXTERN int	TclIsVarUndefined _ANSI_ARGS_((Var *varPtr));  * EXTERN int	TclIsVarArrayElement _ANSI_ARGS_((Var *varPtr));  */
end_comment

begin_define
define|#
directive|define
name|TclIsVarScalar
parameter_list|(
name|varPtr
parameter_list|)
define|\
value|((varPtr)->flags& VAR_SCALAR)
end_define

begin_define
define|#
directive|define
name|TclIsVarLink
parameter_list|(
name|varPtr
parameter_list|)
define|\
value|((varPtr)->flags& VAR_LINK)
end_define

begin_define
define|#
directive|define
name|TclIsVarArray
parameter_list|(
name|varPtr
parameter_list|)
define|\
value|((varPtr)->flags& VAR_ARRAY)
end_define

begin_define
define|#
directive|define
name|TclIsVarUndefined
parameter_list|(
name|varPtr
parameter_list|)
define|\
value|((varPtr)->flags& VAR_UNDEFINED)
end_define

begin_define
define|#
directive|define
name|TclIsVarArrayElement
parameter_list|(
name|varPtr
parameter_list|)
define|\
value|((varPtr)->flags& VAR_ARRAY_ELEMENT)
end_define

begin_comment
comment|/*  *----------------------------------------------------------------  * Data structures related to procedures.  These are used primarily  * in tclProc.c, tclCompile.c, and tclExecute.c.  *----------------------------------------------------------------  */
end_comment

begin_comment
comment|/*  * Forward declaration to prevent an error when the forward reference to  * Command is encountered in the Proc and ImportRef types declared below.  */
end_comment

begin_struct_decl
struct_decl|struct
name|Command
struct_decl|;
end_struct_decl

begin_comment
comment|/*  * The variable-length structure below describes a local variable of a  * procedure that was recognized by the compiler. These variables have a  * name, an element in the array of compiler-assigned local variables in the  * procedure's call frame, and various other items of information. If the  * local variable is a formal argument, it may also have a default value.  * The compiler can't recognize local variables whose names are  * expressions (these names are only known at runtime when the expressions  * are evaluated) or local variables that are created as a result of an  * "upvar" or "uplevel" command. These other local variables are kept  * separately in a hash table in the call frame.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|CompiledLocal
block|{
name|struct
name|CompiledLocal
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next compiler-recognized local variable 				 * for this procedure, or NULL if this is 				 * the last local. */
name|int
name|nameLength
decl_stmt|;
comment|/* The number of characters in local 				 * variable's name. Used to speed up 				 * variable lookups. */
name|int
name|frameIndex
decl_stmt|;
comment|/* Index in the array of compiler-assigned 				 * variables in the procedure call frame. */
name|int
name|isArg
decl_stmt|;
comment|/* 1 if the local variable is a formal 				 * argument. */
name|int
name|isTemp
decl_stmt|;
comment|/* 1 if the local variable is an anonymous 				 * temporary variable. Temporaries have 				 * a NULL name. */
name|int
name|flags
decl_stmt|;
comment|/* Flag bits for the local variable. Same as 				 * the flags for the Var structure above, 				 * although only VAR_SCALAR, VAR_ARRAY, and 				 * VAR_LINK make sense. */
name|Tcl_Obj
modifier|*
name|defValuePtr
decl_stmt|;
comment|/* Pointer to the default value of an 				 * argument, if any. NULL if not an argument 				 * or, if an argument, no default value. */
name|char
name|name
index|[
literal|4
index|]
decl_stmt|;
comment|/* Name of the local variable starts here. 				 * If the name is NULL, this will just be 				 * '\0'. The actual size of this field will 				 * be large enough to hold the name. MUST 				 * BE THE LAST FIELD IN THE STRUCTURE! */
block|}
name|CompiledLocal
typedef|;
end_typedef

begin_comment
comment|/*  * The structure below defines a command procedure, which consists of a  * collection of Tcl commands plus information about arguments and other  * local variables recognized at compile time.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Proc
block|{
name|struct
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Interpreter for which this command 				   * is defined. */
name|int
name|refCount
decl_stmt|;
comment|/* Reference count: 1 if still present 				   * in command table plus 1 for each call 				   * to the procedure that is currently 				   * active. This structure can be freed 				   * when refCount becomes zero. */
name|struct
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
comment|/* Points to the Command structure for 				   * this procedure. This is used to get 				   * the namespace in which to execute 				   * the procedure. */
name|Tcl_Obj
modifier|*
name|bodyPtr
decl_stmt|;
comment|/* Points to the ByteCode object for 				   * procedure's body command. */
name|int
name|numArgs
decl_stmt|;
comment|/* Number of formal parameters. */
name|int
name|numCompiledLocals
decl_stmt|;
comment|/* Count of local variables recognized by 				   * the compiler including arguments and 				   * temporaries. */
name|CompiledLocal
modifier|*
name|firstLocalPtr
decl_stmt|;
comment|/* Pointer to first of the procedure's 				   * compiler-allocated local variables, or 				   * NULL if none. The first numArgs entries 				   * in this list describe the procedure's 				   * formal arguments. */
name|CompiledLocal
modifier|*
name|lastLocalPtr
decl_stmt|;
comment|/* Pointer to the last allocated local 				   * variable or NULL if none. This has 				   * frame index (numCompiledLocals-1). */
block|}
name|Proc
typedef|;
end_typedef

begin_comment
comment|/*  * The structure below defines a command trace.  This is used to allow Tcl  * clients to find out whenever a command is about to be executed.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Trace
block|{
name|int
name|level
decl_stmt|;
comment|/* Only trace commands at nesting level 				 * less than or equal to this. */
name|Tcl_CmdTraceProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to call to trace command. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary value to pass to proc. */
name|struct
name|Trace
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next in list of traces for this interp. */
block|}
name|Trace
typedef|;
end_typedef

begin_comment
comment|/*  * The structure below defines an entry in the assocData hash table which  * is associated with an interpreter. The entry contains a pointer to a  * function to call when the interpreter is deleted, and a pointer to  * a user-defined piece of data.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|AssocData
block|{
name|Tcl_InterpDeleteProc
modifier|*
name|proc
decl_stmt|;
comment|/* Proc to call when deleting. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Value to pass to proc. */
block|}
name|AssocData
typedef|;
end_typedef

begin_comment
comment|/*  * The structure below defines a call frame. A call frame defines a naming  * context for a procedure call: its local naming scope (for local  * variables) and its global naming scope (a namespace, perhaps the global  * :: namespace). A call frame can also define the naming context for a  * namespace eval or namespace inscope command: the namespace in which the  * command's code should execute. The Tcl_CallFrame structures exist only  * while procedures or namespace eval/inscope's are being executed, and  * provide a kind of Tcl call stack.  *   * WARNING!! The structure definition must be kept consistent with the  * Tcl_CallFrame structure in tcl.h. If you change one, change the other.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|CallFrame
block|{
name|Namespace
modifier|*
name|nsPtr
decl_stmt|;
comment|/* Points to the namespace used to resolve 				 * commands and global variables. */
name|int
name|isProcCallFrame
decl_stmt|;
comment|/* If nonzero, the frame was pushed to 				 * execute a Tcl procedure and may have 				 * local vars. If 0, the frame was pushed 				 * to execute a namespace command and var 				 * references are treated as references to 				 * namespace vars; varTablePtr and 				 * compiledLocals are ignored. */
name|int
name|objc
decl_stmt|;
comment|/* This and objv below describe the 				 * arguments for this procedure call. */
name|Tcl_Obj
modifier|*
name|CONST
modifier|*
name|objv
decl_stmt|;
comment|/* Array of argument objects. */
name|struct
name|CallFrame
modifier|*
name|callerPtr
decl_stmt|;
comment|/* Value of interp->framePtr when this 				 * procedure was invoked (i.e. next higher 				 * in stack of all active procedures). */
name|struct
name|CallFrame
modifier|*
name|callerVarPtr
decl_stmt|;
comment|/* Value of interp->varFramePtr when this 				 * procedure was invoked (i.e. determines 				 * variable scoping within caller). Same 				 * as callerPtr unless an "uplevel" command 				 * or something equivalent was active in 				 * the caller). */
name|int
name|level
decl_stmt|;
comment|/* Level of this procedure, for "uplevel" 				 * purposes (i.e. corresponds to nesting of 				 * callerVarPtr's, not callerPtr's). 1 for 				 * outermost procedure, 0 for top-level. */
name|Proc
modifier|*
name|procPtr
decl_stmt|;
comment|/* Points to the structure defining the 				 * called procedure. Used to get information 				 * such as the number of compiled local 				 * variables (local variables assigned 				 * entries ["slots"] in the compiledLocals 				 * array below). */
name|Tcl_HashTable
modifier|*
name|varTablePtr
decl_stmt|;
comment|/* Hash table containing local variables not 				 * recognized by the compiler, or created at 				 * execution time through, e.g., upvar. 				 * Initially NULL and created if needed. */
name|int
name|numCompiledLocals
decl_stmt|;
comment|/* Count of local variables recognized by 				 * the compiler including arguments. */
name|Var
modifier|*
name|compiledLocals
decl_stmt|;
comment|/* Points to the array of local variables 				 * recognized by the compiler. The compiler 				 * emits code that refers to these variables 				 * using an index into this array. */
block|}
name|CallFrame
typedef|;
end_typedef

begin_comment
comment|/*  *----------------------------------------------------------------  * Data structures related to history.   These are used primarily  * in tclHistory.c  *----------------------------------------------------------------  */
end_comment

begin_comment
comment|/*  * The structure below defines one history event (a previously-executed  * command that can be re-executed in whole or in part).  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|command
decl_stmt|;
comment|/* String containing previously-executed 				 * command. */
name|int
name|bytesAvl
decl_stmt|;
comment|/* Total # of bytes available at *event (not 				 * all are necessarily in use now). */
block|}
name|HistoryEvent
typedef|;
end_typedef

begin_comment
comment|/*  * The structure below defines a pending revision to the most recent  * history event.  Changes are linked together into a list and applied  * during the next call to Tcl_RecordHistory.  See the comments at the  * beginning of tclHistory.c for information on revisions.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|HistoryRev
block|{
name|int
name|firstIndex
decl_stmt|;
comment|/* Index of the first byte to replace in 				 * current history event. */
name|int
name|lastIndex
decl_stmt|;
comment|/* Index of last byte to replace in 				 * current history event. */
name|int
name|newSize
decl_stmt|;
comment|/* Number of bytes in newBytes. */
name|char
modifier|*
name|newBytes
decl_stmt|;
comment|/* Replacement for the range given by 				 * firstIndex and lastIndex (malloced). */
name|struct
name|HistoryRev
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next in chain of revisions to apply, or 				 * NULL for end of list. */
block|}
name|HistoryRev
typedef|;
end_typedef

begin_comment
comment|/*  *----------------------------------------------------------------  * Data structures related to expressions.  These are used only in  * tclExpr.c.  *----------------------------------------------------------------  */
end_comment

begin_comment
comment|/*  * The data structure below defines a math function (e.g. sin or hypot)  * for use in Tcl expressions.  */
end_comment

begin_define
define|#
directive|define
name|MAX_MATH_ARGS
value|5
end_define

begin_typedef
typedef|typedef
struct|struct
name|MathFunc
block|{
name|int
name|builtinFuncIndex
decl_stmt|;
comment|/* If this is a builtin math function, its 				 * index in the array of builtin functions. 				 * (tclCompilation.h lists these indices.) 				 * The value is -1 if this is a new function 				 * defined by Tcl_CreateMathFunc. The value 				 * is also -1 if a builtin function is 				 * replaced by a Tcl_CreateMathFunc call. */
name|int
name|numArgs
decl_stmt|;
comment|/* Number of arguments for function. */
name|Tcl_ValueType
name|argTypes
index|[
name|MAX_MATH_ARGS
index|]
decl_stmt|;
comment|/* Acceptable types for each argument. */
name|Tcl_MathProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure that implements this function. 				 * NULL if isBuiltinFunc is 1. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Additional argument to pass to the 				 * function when invoking it. NULL if 				 * isBuiltinFunc is 1. */
block|}
name|MathFunc
typedef|;
end_typedef

begin_comment
comment|/*  *----------------------------------------------------------------  * Data structures related to bytecode compilation and execution.  * These are used primarily in tclCompile.c, tclExecute.c, and  * tclBasic.c.  *----------------------------------------------------------------  */
end_comment

begin_comment
comment|/*  * Forward declaration to prevent an error when the forward reference to  * CompileEnv is encountered in the procedure type CompileProc declared  * below.  */
end_comment

begin_struct_decl
struct_decl|struct
name|CompileEnv
struct_decl|;
end_struct_decl

begin_comment
comment|/*  * The type of procedures called by the Tcl bytecode compiler to compile  * commands. Pointers to these procedures are kept in the Command structure  * describing each command. When a CompileProc returns, the interpreter's  * result is set to error information, if any. In addition, the CompileProc  * returns an integer value, which is one of the following:  *  * TCL_OK		Compilation completed normally.  * TCL_ERROR		Compilation failed because of an error;  *			the interpreter's result describes what went wrong.  * TCL_OUT_LINE_COMPILE	Compilation failed because, e.g., the command is  *			too complex for effective inline compilation. The  *			CompileProc believes the command is legal but   *			should be compiled "out of line" by emitting code  *			to invoke its command procedure at runtime.  */
end_comment

begin_define
define|#
directive|define
name|TCL_OUT_LINE_COMPILE
value|(TCL_CONTINUE + 1)
end_define

begin_typedef
typedef|typedef
name|int
argument_list|(
argument|CompileProc
argument_list|)
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|char
operator|*
name|lastChar
operator|,
name|int
name|compileFlags
operator|,
expr|struct
name|CompileEnv
operator|*
name|compEnvPtr
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_comment
comment|/*  * The data structure defining the execution environment for ByteCode's.  * There is one ExecEnv structure per Tcl interpreter. It holds the  * evaluation stack that holds command operands and results. The stack grows  * towards increasing addresses. The "stackTop" member is cached by  * TclExecuteByteCode in a local variable: it must be set before calling  * TclExecuteByteCode and will be restored by TclExecuteByteCode before it  * returns.  */
end_comment

begin_typedef
typedef|typedef
union|union
name|StackItem
block|{
name|Tcl_Obj
modifier|*
name|o
decl_stmt|;
comment|/* Stack item as a pointer to a Tcl_Obj. */
name|int
name|i
decl_stmt|;
comment|/* Stack item as an integer. */
name|VOID
modifier|*
name|p
decl_stmt|;
comment|/* Stack item as an arbitrary pointer. */
block|}
name|StackItem
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|ExecEnv
block|{
name|StackItem
modifier|*
name|stackPtr
decl_stmt|;
comment|/* Points to the first item in the 				 * evaluation stack on the heap. */
name|int
name|stackTop
decl_stmt|;
comment|/* Index of current top of stack; -1 when 				 * the stack is empty. */
name|int
name|stackEnd
decl_stmt|;
comment|/* Index of last usable item in stack. */
block|}
name|ExecEnv
typedef|;
end_typedef

begin_comment
comment|/*  *----------------------------------------------------------------  * Data structures related to commands.  *----------------------------------------------------------------  */
end_comment

begin_comment
comment|/*  * An imported command is created in an namespace when it imports a "real"  * command from another namespace. An imported command has a Command  * structure that points (via its ClientData value) to the "real" Command  * structure in the source namespace's command table. The real command  * records all the imported commands that refer to it in a list of ImportRef  * structures so that they can be deleted when the real command is deleted.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ImportRef
block|{
name|struct
name|Command
modifier|*
name|importedCmdPtr
decl_stmt|;
comment|/* Points to the imported command created in 				 * an importing namespace; this command 				 * redirects its invocations to the "real" 				 * command. */
name|struct
name|ImportRef
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next element on the linked list of 				 * imported commands that refer to the 				 * "real" command. The real command deletes 				 * these imported commands on this list when 				 * it is deleted. */
block|}
name|ImportRef
typedef|;
end_typedef

begin_comment
comment|/*  * A Command structure exists for each command in a namespace. The  * Tcl_Command opaque type actually refers to these structures.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Command
block|{
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Pointer to the hash table entry that 				 * refers to this command. The hash table is 				 * either a namespace's command table or an 				 * interpreter's hidden command table. This 				 * pointer is used to get a command's name 				 * from its Tcl_Command handle. NULL means 				 * that the hash table entry has been 				 * removed already (this can happen if 				 * deleteProc causes the command to be 				 * deleted or recreated). */
name|Namespace
modifier|*
name|nsPtr
decl_stmt|;
comment|/* Points to the namespace containing this 				 * command. */
name|int
name|refCount
decl_stmt|;
comment|/* 1 if in command hashtable plus 1 for each 				 * reference from a CmdName Tcl object 				 * representing a command's name in a 				 * ByteCode instruction sequence. This 				 * structure can be freed when refCount 				 * becomes zero. */
name|int
name|cmdEpoch
decl_stmt|;
comment|/* Incremented to invalidate any references                                  * that point to this command when it is 				 * renamed, deleted, hidden, or exposed. */
name|CompileProc
modifier|*
name|compileProc
decl_stmt|;
comment|/* Procedure called to compile command. NULL 				 * if no compile proc exists for command. */
name|Tcl_ObjCmdProc
modifier|*
name|objProc
decl_stmt|;
comment|/* Object-based command procedure. */
name|ClientData
name|objClientData
decl_stmt|;
comment|/* Arbitrary value passed to object proc. */
name|Tcl_CmdProc
modifier|*
name|proc
decl_stmt|;
comment|/* String-based command procedure. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary value passed to string proc. */
name|Tcl_CmdDeleteProc
modifier|*
name|deleteProc
decl_stmt|;
comment|/* Procedure invoked when deleting command 				 * to, e.g., free all client data. */
name|ClientData
name|deleteData
decl_stmt|;
comment|/* Arbitrary value passed to deleteProc. */
name|int
name|deleted
decl_stmt|;
comment|/* Means that the command is in the process 				 * of being deleted (its deleteProc is 				 * currently executing). Other attempts to 				 * delete the command should be ignored. */
name|ImportRef
modifier|*
name|importRefPtr
decl_stmt|;
comment|/* List of each imported Command created in 				 * another namespace when this command is 				 * imported. These imported commands 				 * redirect invocations back to this 				 * command. The list is used to remove all 				 * those imported commands when deleting 				 * this "real" command. */
block|}
name|Command
typedef|;
end_typedef

begin_comment
comment|/*  *----------------------------------------------------------------  * This structure defines an interpreter, which is a collection of  * commands plus other state information related to interpreting  * commands, such as variable storage. Primary responsibility for  * this data structure is in tclBasic.c, but almost every Tcl  * source file uses something in here.  *----------------------------------------------------------------  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Interp
block|{
comment|/*      * Note:  the first three fields must match exactly the fields in      * a Tcl_Interp struct (see tcl.h).  If you change one, be sure to      * change the other.      *      * The interpreter's result is held in both the string and the      * objResultPtr fields. These fields hold, respectively, the result's      * string or object value. The interpreter's result is always in the      * result field if that is non-empty, otherwise it is in objResultPtr.      * The two fields are kept consistent unless some C code sets      * interp->result directly. Programs should not access result and      * objResultPtr directly; instead, they should always get and set the      * result using procedures such as Tcl_SetObjResult, Tcl_GetObjResult,      * and Tcl_GetStringResult. See the SetResult man page for details.      */
name|char
modifier|*
name|result
decl_stmt|;
comment|/* If the last command returned a string 				 * result, this points to it. Should not be 				 * accessed directly; see comment above. */
name|Tcl_FreeProc
modifier|*
name|freeProc
decl_stmt|;
comment|/* Zero means a string result is statically                                  * allocated. TCL_DYNAMIC means string                                  * result was allocated with ckalloc and                                  * should be freed with ckfree. Other values                                  * give address of procedure to invoke to                                  * free the string result. Tcl_Eval must                                  * free it before executing next command. */
name|int
name|errorLine
decl_stmt|;
comment|/* When TCL_ERROR is returned, this gives 				 * the line number in the command where the 				 * error occurred (1 means first line). */
name|Tcl_Obj
modifier|*
name|objResultPtr
decl_stmt|;
comment|/* If the last command returned an object 				 * result, this points to it. Should not be 				 * accessed directly; see comment above. */
name|Namespace
modifier|*
name|globalNsPtr
decl_stmt|;
comment|/* The interpreter's global namespace. */
name|Tcl_HashTable
name|mathFuncTable
decl_stmt|;
comment|/* Contains all the math functions currently 				 * defined for the interpreter.  Indexed by 				 * strings (function names); values have 				 * type (MathFunc *). */
comment|/*      * Information related to procedures and variables. See tclProc.c      * and tclvar.c for usage.      */
name|int
name|numLevels
decl_stmt|;
comment|/* Keeps track of how many nested calls to 				 * Tcl_Eval are in progress for this 				 * interpreter.  It's used to delay deletion 				 * of the table until all Tcl_Eval 				 * invocations are completed. */
name|int
name|maxNestingDepth
decl_stmt|;
comment|/* If numLevels exceeds this value then Tcl 				 * assumes that infinite recursion has 				 * occurred and it generates an error. */
name|CallFrame
modifier|*
name|framePtr
decl_stmt|;
comment|/* Points to top-most in stack of all nested 				 * procedure invocations.  NULL means there 				 * are no active procedures. */
name|CallFrame
modifier|*
name|varFramePtr
decl_stmt|;
comment|/* Points to the call frame whose variables 				 * are currently in use (same as framePtr 				 * unless an "uplevel" command is 				 * executing). NULL means no procedure is 				 * active or "uplevel 0" is executing. */
name|ActiveVarTrace
modifier|*
name|activeTracePtr
decl_stmt|;
comment|/* First in list of active traces for 				 * interp, or NULL if no active traces. */
name|int
name|returnCode
decl_stmt|;
comment|/* Completion code to return if current 				 * procedure exits with TCL_RETURN code. */
name|char
modifier|*
name|errorInfo
decl_stmt|;
comment|/* Value to store in errorInfo if returnCode 				 * is TCL_ERROR.  Malloc'ed, may be NULL */
name|char
modifier|*
name|errorCode
decl_stmt|;
comment|/* Value to store in errorCode if returnCode 				 * is TCL_ERROR.  Malloc'ed, may be NULL */
comment|/*      * Information used by Tcl_AppendResult to keep track of partial      * results.  See Tcl_AppendResult code for details.      */
name|char
modifier|*
name|appendResult
decl_stmt|;
comment|/* Storage space for results generated 				 * by Tcl_AppendResult.  Malloc-ed.  NULL 				 * means not yet allocated. */
name|int
name|appendAvl
decl_stmt|;
comment|/* Total amount of space available at 				 * partialResult. */
name|int
name|appendUsed
decl_stmt|;
comment|/* Number of non-null bytes currently 				 * stored at partialResult. */
comment|/*      * A cache of compiled regular expressions.  See Tcl_RegExpCompile      * in tclUtil.c for details.      */
define|#
directive|define
name|NUM_REGEXPS
value|5
name|char
modifier|*
name|patterns
index|[
name|NUM_REGEXPS
index|]
decl_stmt|;
comment|/* Strings corresponding to compiled 				 * regular expression patterns.  NULL 				 * means that this slot isn't used. 				 * Malloc-ed. */
name|int
name|patLengths
index|[
name|NUM_REGEXPS
index|]
decl_stmt|;
comment|/* Number of non-null characters in 				 * corresponding entry in patterns. 				 * -1 means entry isn't used. */
name|regexp
modifier|*
name|regexps
index|[
name|NUM_REGEXPS
index|]
decl_stmt|;
comment|/* Compiled forms of above strings.  Also 				 * malloc-ed, or NULL if not in use yet. */
comment|/*      * Information about packages.  Used only in tclPkg.c.      */
name|Tcl_HashTable
name|packageTable
decl_stmt|;
comment|/* Describes all of the packages loaded 				 * in or available to this interpreter. 				 * Keys are package names, values are 				 * (Package *) pointers. */
name|char
modifier|*
name|packageUnknown
decl_stmt|;
comment|/* Command to invoke during "package 				 * require" commands for packages that 				 * aren't described in packageTable.  				 * Malloc'ed, may be NULL. */
comment|/*      * Miscellaneous information:      */
name|int
name|cmdCount
decl_stmt|;
comment|/* Total number of times a command procedure 				 * has been called for this interpreter. */
name|int
name|evalFlags
decl_stmt|;
comment|/* Flags to control next call to Tcl_Eval. 				 * Normally zero, but may be set before 				 * calling Tcl_Eval.  See below for valid 				 * values. */
name|int
name|termOffset
decl_stmt|;
comment|/* Offset of character just after last one 				 * compiled or executed by Tcl_EvalObj. */
name|int
name|compileEpoch
decl_stmt|;
comment|/* Holds the current "compilation epoch" 				 * for this interpreter. This is 				 * incremented to invalidate existing 				 * ByteCodes when, e.g., a command with a 				 * compile procedure is redefined. */
name|Proc
modifier|*
name|compiledProcPtr
decl_stmt|;
comment|/* If a procedure is being compiled, a 				 * pointer to its Proc structure; otherwise, 				 * this is NULL. Set by ObjInterpProc in 				 * tclProc.c and used by tclCompile.c to 				 * process local variables appropriately. */
name|char
modifier|*
name|scriptFile
decl_stmt|;
comment|/* NULL means there is no nested source 				 * command active;  otherwise this points to 				 * the name of the file being sourced (it's 				 * not malloc-ed:  it points to an argument 				 * to Tcl_EvalFile. */
name|int
name|flags
decl_stmt|;
comment|/* Various flag bits.  See below. */
name|long
name|randSeed
decl_stmt|;
comment|/* Seed used for rand() function. */
name|Trace
modifier|*
name|tracePtr
decl_stmt|;
comment|/* List of traces for this interpreter. */
name|Tcl_HashTable
modifier|*
name|assocData
decl_stmt|;
comment|/* Hash table for associating data with                                  * this interpreter. Cleaned up when                                  * this interpreter is deleted. */
name|struct
name|ExecEnv
modifier|*
name|execEnvPtr
decl_stmt|;
comment|/* Execution environment for Tcl bytecode                                  * execution. Contains a pointer to the 				 * Tcl evaluation stack. */
name|Tcl_Obj
modifier|*
name|emptyObjPtr
decl_stmt|;
comment|/* Points to an object holding an empty 				 * string. Returned by Tcl_ObjSetVar2 when 				 * variable traces change a variable in a 				 * gross way. */
name|char
name|resultSpace
index|[
name|TCL_RESULT_SIZE
operator|+
literal|1
index|]
decl_stmt|;
comment|/* Static space holding small results. */
block|}
name|Interp
typedef|;
end_typedef

begin_comment
comment|/*  * EvalFlag bits for Interp structures:  *  * TCL_BRACKET_TERM	1 means that the current script is terminated by  *			a close bracket rather than the end of the string.  * TCL_ALLOW_EXCEPTIONS	1 means it's OK for the script to terminate with  *			a code other than TCL_OK or TCL_ERROR;  0 means  *			codes other than these should be turned into errors.  */
end_comment

begin_define
define|#
directive|define
name|TCL_BRACKET_TERM
value|1
end_define

begin_define
define|#
directive|define
name|TCL_ALLOW_EXCEPTIONS
value|4
end_define

begin_comment
comment|/*  * Flag bits for Interp structures:  *  * DELETED:		Non-zero means the interpreter has been deleted:  *			don't process any more commands for it, and destroy  *			the structure as soon as all nested invocations of  *			Tcl_Eval are done.  * ERR_IN_PROGRESS:	Non-zero means an error unwind is already in  *			progress. Zero means a command proc has been  *			invoked since last error occured.  * ERR_ALREADY_LOGGED:	Non-zero means information has already been logged  *			in $errorInfo for the current Tcl_Eval instance,  *			so Tcl_Eval needn't log it (used to implement the  *			"error message log" command).  * ERROR_CODE_SET:	Non-zero means that Tcl_SetErrorCode has been  *			called to record information for the current  *			error.  Zero means Tcl_Eval must clear the  *			errorCode variable if an error is returned.  * EXPR_INITIALIZED:	Non-zero means initialization specific to  *			expressions has	been carried out.  * DONT_COMPILE_CMDS_INLINE: Non-zero means that the bytecode compiler  *			should not compile any commands into an inline  *			sequence of instructions. This is set 1, for  *			example, when command traces are requested.  * RAND_SEED_INITIALIZED: Non-zero means that the randSeed value of the  *			interp has not be initialized.  This is set 1  *			when we first use the rand() or srand() functions.  * SAFE_INTERP:         Non zero means that the current interp is a  *                      safe interp (ie it has only the safe commands  *                      installed, less priviledge than a regular interp).  */
end_comment

begin_define
define|#
directive|define
name|DELETED
value|1
end_define

begin_define
define|#
directive|define
name|ERR_IN_PROGRESS
value|2
end_define

begin_define
define|#
directive|define
name|ERR_ALREADY_LOGGED
value|4
end_define

begin_define
define|#
directive|define
name|ERROR_CODE_SET
value|8
end_define

begin_define
define|#
directive|define
name|EXPR_INITIALIZED
value|0x10
end_define

begin_define
define|#
directive|define
name|DONT_COMPILE_CMDS_INLINE
value|0x20
end_define

begin_define
define|#
directive|define
name|RAND_SEED_INITIALIZED
value|0x40
end_define

begin_define
define|#
directive|define
name|SAFE_INTERP
value|0x80
end_define

begin_comment
comment|/*  *----------------------------------------------------------------  * Data structures related to command parsing. These are used in  * tclParse.c and its clients.  *----------------------------------------------------------------  */
end_comment

begin_comment
comment|/*  * The following data structure is used by various parsing procedures  * to hold information about where to store the results of parsing  * (e.g. the substituted contents of a quoted argument, or the result  * of a nested command).  At any given time, the space available  * for output is fixed, but a procedure may be called to expand the  * space available if the current space runs out.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ParseValue
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* Address of first character in 				 * output buffer. */
name|char
modifier|*
name|next
decl_stmt|;
comment|/* Place to store next character in 				 * output buffer. */
name|char
modifier|*
name|end
decl_stmt|;
comment|/* Address of the last usable character 				 * in the buffer. */
name|void
argument_list|(
argument|*expandProc
argument_list|)
name|_ANSI_ARGS_
argument_list|(
operator|(
expr|struct
name|ParseValue
operator|*
name|pvPtr
operator|,
name|int
name|needed
operator|)
argument_list|)
expr_stmt|;
comment|/* Procedure to call when space runs out; 				 * it will make more space. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary information for use of 				 * expandProc. */
block|}
name|ParseValue
typedef|;
end_typedef

begin_comment
comment|/*  * A table used to classify input characters to assist in parsing  * Tcl commands.  The table should be indexed with a signed character  * using the CHAR_TYPE macro.  The character may have a negative  * value.  The CHAR_TYPE macro takes a pointer to a signed character  * and a pointer to the last character in the source string.  If the  * src pointer is pointing at the terminating null of the string,  * CHAR_TYPE returns TCL_COMMAND_END.  */
end_comment

begin_decl_stmt
specifier|extern
name|unsigned
name|char
name|tclTypeTable
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CHAR_TYPE
parameter_list|(
name|src
parameter_list|,
name|last
parameter_list|)
define|\
value|(((src)==(last))?TCL_COMMAND_END:(tclTypeTable+128)[*(src)])
end_define

begin_comment
comment|/*  * Possible values returned by CHAR_TYPE. Note that except for TCL_DOLLAR,  * these are all one byte values with a single bit set 1. This means these  * values may be bit-or'ed together (except for TCL_DOLLAR) to quickly test  * whether a character is one of several different kinds of characters.  *  * TCL_NORMAL -		All characters that don't have special significance  *			to the Tcl language.  * TCL_SPACE -		Character is space, tab, or return.  * TCL_COMMAND_END -	Character is newline or semicolon or close-bracket  *			or terminating null.  * TCL_QUOTE -		Character is a double-quote.  * TCL_OPEN_BRACKET -	Character is a "[".  * TCL_OPEN_BRACE -	Character is a "{".  * TCL_CLOSE_BRACE -	Character is a "}".  * TCL_BACKSLASH -	Character is a "\".  * TCL_DOLLAR - 	Character is a "$".  */
end_comment

begin_define
define|#
directive|define
name|TCL_NORMAL
value|0x01
end_define

begin_define
define|#
directive|define
name|TCL_SPACE
value|0x02
end_define

begin_define
define|#
directive|define
name|TCL_COMMAND_END
value|0x04
end_define

begin_define
define|#
directive|define
name|TCL_QUOTE
value|0x08
end_define

begin_define
define|#
directive|define
name|TCL_OPEN_BRACKET
value|0x10
end_define

begin_define
define|#
directive|define
name|TCL_OPEN_BRACE
value|0x20
end_define

begin_define
define|#
directive|define
name|TCL_CLOSE_BRACE
value|0x40
end_define

begin_define
define|#
directive|define
name|TCL_BACKSLASH
value|0x80
end_define

begin_define
define|#
directive|define
name|TCL_DOLLAR
value|0x00
end_define

begin_comment
comment|/*  * Maximum number of levels of nesting permitted in Tcl commands (used  * to catch infinite recursion).  */
end_comment

begin_define
define|#
directive|define
name|MAX_NESTING_DEPTH
value|1000
end_define

begin_comment
comment|/*  * The macro below is used to modify a "char" value (e.g. by casting  * it to an unsigned character) so that it can be used safely with  * macros such as isspace.  */
end_comment

begin_define
define|#
directive|define
name|UCHAR
parameter_list|(
name|c
parameter_list|)
value|((unsigned char) (c))
end_define

begin_comment
comment|/*  * This macro is used to determine the offset needed to safely allocate any  * data structure in memory. Given a starting offset or size, it "rounds up"  * or "aligns" the offset to the next 8-byte boundary so that any data  * structure can be placed at the resulting offset without fear of an  * alignment error.  *  * WARNING!! DO NOT USE THIS MACRO TO ALIGN POINTERS: it will produce  * the wrong result on platforms that allocate addresses that are divisible  * by 4 or 2. Only use it for offsets or sizes.  */
end_comment

begin_define
define|#
directive|define
name|TCL_ALIGN
parameter_list|(
name|x
parameter_list|)
value|(((int)(x) + 7)& ~7)
end_define

begin_comment
comment|/*  * The following macros are used to specify the runtime platform  * setting of the tclPlatform variable.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|TCL_PLATFORM_UNIX
block|,
comment|/* Any Unix-like OS. */
name|TCL_PLATFORM_MAC
block|,
comment|/* MacOS. */
name|TCL_PLATFORM_WINDOWS
comment|/* Any Microsoft Windows OS. */
block|}
name|TclPlatformType
typedef|;
end_typedef

begin_comment
comment|/*  * Flags for TclInvoke:  *  * TCL_INVOKE_HIDDEN		Invoke a hidden command; if not set,  *				invokes an exposed command.  * TCL_INVOKE_NO_UNKNOWN	If set, "unknown" is not invoked if  *				the command to be invoked is not found.  *				Only has an effect if invoking an exposed  *				command, i.e. if TCL_INVOKE_HIDDEN is not  *				also set.  */
end_comment

begin_define
define|#
directive|define
name|TCL_INVOKE_HIDDEN
value|(1<<0)
end_define

begin_define
define|#
directive|define
name|TCL_INVOKE_NO_UNKNOWN
value|(1<<1)
end_define

begin_comment
comment|/*  * The structure used as the internal representation of Tcl list  * objects. This is an array of pointers to the element objects. This array  * is grown (reallocated and copied) as necessary to hold all the list's  * element pointers. The array might contain more slots than currently used  * to hold all element pointers. This is done to make append operations  * faster.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|List
block|{
name|int
name|maxElemCount
decl_stmt|;
comment|/* Total number of element array slots. */
name|int
name|elemCount
decl_stmt|;
comment|/* Current number of list elements. */
name|Tcl_Obj
modifier|*
modifier|*
name|elements
decl_stmt|;
comment|/* Array of pointers to element objects. */
block|}
name|List
typedef|;
end_typedef

begin_comment
comment|/*  * The following types are used for getting and storing platform-specific  * file attributes in tclFCmd.c and the various platform-versions of  * that file. This is done to have as much common code as possible  * in the file attributes code. For more information about the callbacks,  * see TclFileAttrsCmd in tclFCmd.c.  */
end_comment

begin_typedef
typedef|typedef
name|int
argument_list|(
argument|TclGetFileAttrProc
argument_list|)
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objIndex
operator|,
name|char
operator|*
name|fileName
operator|,
name|Tcl_Obj
operator|*
operator|*
name|attrObjPtrPtr
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|int
argument_list|(
argument|TclSetFileAttrProc
argument_list|)
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objIndex
operator|,
name|char
operator|*
name|fileName
operator|,
name|Tcl_Obj
operator|*
name|attrObjPtr
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|TclFileAttrProcs
block|{
name|TclGetFileAttrProc
modifier|*
name|getProc
decl_stmt|;
comment|/* The procedure for getting attrs. */
name|TclSetFileAttrProc
modifier|*
name|setProc
decl_stmt|;
comment|/* The procedure for setting attrs. */
block|}
name|TclFileAttrProcs
typedef|;
end_typedef

begin_comment
comment|/*  * Opaque handle used in pipeline routines to encapsulate platform-dependent  * state.   */
end_comment

begin_typedef
typedef|typedef
name|struct
name|TclFile_
modifier|*
name|TclFile
typedef|;
end_typedef

begin_comment
comment|/*  *----------------------------------------------------------------  * Variables shared among Tcl modules but not used by the outside world.  *----------------------------------------------------------------  */
end_comment

begin_decl_stmt
specifier|extern
name|Tcl_Time
name|tclBlockTime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tclBlockTimeSet
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tclExecutableName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Tcl_ChannelType
name|tclFileChannelType
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tclMemDumpFileName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|TclPlatformType
name|tclPlatform
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tclpFileAttrStrings
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CONST
name|TclFileAttrProcs
name|tclpFileAttrProcs
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Variables denoting the Tcl object types defined in the core.  */
end_comment

begin_decl_stmt
specifier|extern
name|Tcl_ObjType
name|tclBooleanType
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Tcl_ObjType
name|tclByteCodeType
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Tcl_ObjType
name|tclDoubleType
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Tcl_ObjType
name|tclIntType
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Tcl_ObjType
name|tclListType
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Tcl_ObjType
name|tclStringType
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The head of the list of free Tcl objects, and the total number of Tcl  * objects ever allocated and freed.  */
end_comment

begin_decl_stmt
specifier|extern
name|Tcl_Obj
modifier|*
name|tclFreeObjList
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_COMPILE_STATS
end_ifdef

begin_decl_stmt
specifier|extern
name|long
name|tclObjsAlloced
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|tclObjsFreed
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_COMPILE_STATS */
end_comment

begin_comment
comment|/*  * Pointer to a heap-allocated string of length zero that the Tcl core uses  * as the value of an empty string representation for an object. This value  * is shared by all new objects allocated by Tcl_NewObj.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tclEmptyStringRep
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *----------------------------------------------------------------  * Procedures shared among Tcl modules but not used by the outside  * world:  *----------------------------------------------------------------  */
end_comment

begin_decl_stmt
name|EXTERN
name|void
name|panic
name|_ANSI_ARGS_
argument_list|(
name|TCL_VARARGS
argument_list|(
name|char
operator|*
argument_list|,
name|format
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclAllocateFreeObjects
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclChdir
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|dirName
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclCleanupChildren
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|numPids
operator|,
name|Tcl_Pid
operator|*
name|pidPtr
operator|,
name|Tcl_Channel
name|errorChan
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclCleanupCommand
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Command
operator|*
name|cmdPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|char
modifier|*
name|TclConvertToNative
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|name
operator|,
name|Tcl_DString
operator|*
name|bufferPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|char
modifier|*
name|TclConvertToNetwork
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|name
operator|,
name|Tcl_DString
operator|*
name|bufferPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclCopyAndCollapse
name|_ANSI_ARGS_
argument_list|(
operator|(
name|int
name|count
operator|,
name|char
operator|*
name|src
operator|,
name|char
operator|*
name|dst
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclCopyChannel
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Channel
name|inChan
operator|,
name|Tcl_Channel
name|outChan
operator|,
name|int
name|toRead
operator|,
name|Tcl_Obj
operator|*
name|cmdPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * TclCreatePipeline unofficially exported for use by BLT.  */
end_comment

begin_decl_stmt
name|EXTERN
name|int
name|TclCreatePipeline
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|Tcl_Pid
operator|*
operator|*
name|pidArrayPtr
operator|,
name|TclFile
operator|*
name|inPipePtr
operator|,
name|TclFile
operator|*
name|outPipePtr
operator|,
name|TclFile
operator|*
name|errFilePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclCreateProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Namespace
operator|*
name|nsPtr
operator|,
name|char
operator|*
name|procName
operator|,
name|Tcl_Obj
operator|*
name|argsPtr
operator|,
name|Tcl_Obj
operator|*
name|bodyPtr
operator|,
name|Proc
operator|*
operator|*
name|procPtrPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclDeleteCompiledLocalVars
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Interp
operator|*
name|iPtr
operator|,
name|CallFrame
operator|*
name|framePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclDeleteVars
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Interp
operator|*
name|iPtr
operator|,
name|Tcl_HashTable
operator|*
name|tablePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclDoGlob
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|separators
operator|,
name|Tcl_DString
operator|*
name|headPtr
operator|,
name|char
operator|*
name|tail
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclDumpMemoryInfo
name|_ANSI_ARGS_
argument_list|(
operator|(
name|FILE
operator|*
name|outFile
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclExpandParseValue
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ParseValue
operator|*
name|pvPtr
operator|,
name|int
name|needed
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclExprFloatError
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|double
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclFileAttrsCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclFileCopyCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclFileDeleteCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclFileMakeDirsCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclFileRenameCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclFinalizeCompExecEnv
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclFinalizeEnvironment
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclFinalizeExecEnv
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclFindElement
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|list
operator|,
name|int
name|listLength
operator|,
name|char
operator|*
operator|*
name|elementPtr
operator|,
name|char
operator|*
operator|*
name|nextPtr
operator|,
name|int
operator|*
name|sizePtr
operator|,
name|int
operator|*
name|bracePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|Proc
modifier|*
name|TclFindProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Interp
operator|*
name|iPtr
operator|,
name|char
operator|*
name|procName
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclFormatInt
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|buffer
operator|,
name|long
name|n
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclFreePackageInfo
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Interp
operator|*
name|iPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclGetAndDetachPids
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Channel
name|chan
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|char
modifier|*
name|TclGetCwd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclGetDate
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|p
operator|,
name|unsigned
name|long
name|now
operator|,
name|long
name|zone
operator|,
name|unsigned
name|long
operator|*
name|timePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|Tcl_Channel
name|TclGetDefaultStdChannel
name|_ANSI_ARGS_
argument_list|(
operator|(
name|int
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|Tcl_Obj
modifier|*
name|TclGetElementOfIndexedArray
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|localIndex
operator|,
name|Tcl_Obj
operator|*
name|elemPtr
operator|,
name|int
name|leaveErrorMsg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|char
modifier|*
name|TclGetEnv
name|_ANSI_ARGS_
argument_list|(
operator|(
name|CONST
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|char
modifier|*
name|TclGetExtension
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclGetFrame
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|CallFrame
operator|*
operator|*
name|framePtrPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclGetIdleGeneration
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclGetIntForIndex
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Obj
operator|*
name|objPtr
operator|,
name|int
name|endValue
operator|,
name|int
operator|*
name|indexPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|Tcl_Obj
modifier|*
name|TclGetIndexedScalar
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|localIndex
operator|,
name|int
name|leaveErrorMsg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclGetLong
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|long
operator|*
name|longPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclGetLoadedPackages
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|targetName
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclGetNamespaceForQualName
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|qualName
operator|,
name|Namespace
operator|*
name|cxtNsPtr
operator|,
name|int
name|flags
operator|,
name|Namespace
operator|*
operator|*
name|nsPtrPtr
operator|,
name|Namespace
operator|*
operator|*
name|altNsPtrPtr
operator|,
name|Namespace
operator|*
operator|*
name|actualCxtPtrPtr
operator|,
name|char
operator|*
operator|*
name|simpleNamePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclGetOpenMode
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|int
operator|*
name|seekFlagPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|Tcl_Command
name|TclGetOriginalCommand
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Command
name|command
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|char
modifier|*
name|TclGetUserHome
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
name|Tcl_DString
operator|*
name|bufferPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclGlobalInvoke
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclGuessPackageName
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|fileName
operator|,
name|Tcl_DString
operator|*
name|bufPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclHasPipes
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclHasSockets
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclHideUnsafeCommands
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclIdlePending
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclInExit
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|Tcl_Obj
modifier|*
name|TclIncrElementOfIndexedArray
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|localIndex
operator|,
name|Tcl_Obj
operator|*
name|elemPtr
operator|,
name|long
name|incrAmount
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|Tcl_Obj
modifier|*
name|TclIncrIndexedScalar
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|localIndex
operator|,
name|long
name|incrAmount
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|Tcl_Obj
modifier|*
name|TclIncrVar2
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Obj
operator|*
name|part1Ptr
operator|,
name|Tcl_Obj
operator|*
name|part2Ptr
operator|,
name|long
name|incrAmount
operator|,
name|int
name|part1NotParsed
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclInitNamespaces
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclInterpInit
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclInvoke
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclInvokeObjectCommand
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclInvokeStringCommand
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|Proc
modifier|*
name|TclIsProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Command
operator|*
name|cmdPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclLoadFile
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|fileName
operator|,
name|char
operator|*
name|sym1
operator|,
name|char
operator|*
name|sym2
operator|,
name|Tcl_PackageInitProc
operator|*
operator|*
name|proc1Ptr
operator|,
name|Tcl_PackageInitProc
operator|*
operator|*
name|proc2Ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclLooksLikeInt
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|Var
modifier|*
name|TclLookupVar
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|part1
operator|,
name|char
operator|*
name|part2
operator|,
name|int
name|flags
operator|,
name|char
operator|*
name|msg
operator|,
name|int
name|createPart1
operator|,
name|int
name|createPart2
operator|,
name|Var
operator|*
operator|*
name|arrayPtrPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclMakeFileTable
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|noStdio
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclMatchFiles
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|separators
operator|,
name|Tcl_DString
operator|*
name|dirPtr
operator|,
name|char
operator|*
name|pattern
operator|,
name|char
operator|*
name|tail
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclNeedSpace
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|start
operator|,
name|char
operator|*
name|end
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclObjCommandComplete
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Obj
operator|*
name|cmdPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclObjInterpProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclObjInvoke
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclObjInvokeGlobal
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|char
modifier|*
name|TclpAlloc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|unsigned
name|int
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * On a Mac, we can exit gracefully if the stack gets too small.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAC_TCL
end_ifdef

begin_decl_stmt
name|EXTERN
name|int
name|TclpCheckStackSpace
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TclpCheckStackSpace
parameter_list|()
value|(1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|EXTERN
name|int
name|TclpCloseFile
name|_ANSI_ARGS_
argument_list|(
operator|(
name|TclFile
name|file
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclpCopyFile
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|source
operator|,
name|char
operator|*
name|dest
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclpCopyDirectory
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|source
operator|,
name|char
operator|*
name|dest
operator|,
name|Tcl_DString
operator|*
name|errorPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|Tcl_Channel
name|TclpCreateCommandChannel
name|_ANSI_ARGS_
argument_list|(
operator|(
name|TclFile
name|readFile
operator|,
name|TclFile
name|writeFile
operator|,
name|TclFile
name|errorFile
operator|,
name|int
name|numPids
operator|,
name|Tcl_Pid
operator|*
name|pidPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclpCreateDirectory
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|path
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclpCreatePipe
name|_ANSI_ARGS_
argument_list|(
operator|(
name|TclFile
operator|*
name|readPipe
operator|,
name|TclFile
operator|*
name|writePipe
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclpCreateProcess
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|TclFile
name|inputFile
operator|,
name|TclFile
name|outputFile
operator|,
name|TclFile
name|errorFile
operator|,
name|Tcl_Pid
operator|*
name|pidPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|TclFile
name|TclpCreateTempFile
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|contents
operator|,
name|Tcl_DString
operator|*
name|namePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclpDeleteFile
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|path
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclpFree
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|unsigned
name|long
name|TclpGetClicks
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|unsigned
name|long
name|TclpGetSeconds
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclpGetTime
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Time
operator|*
name|time
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclpGetTimeZone
name|_ANSI_ARGS_
argument_list|(
operator|(
name|unsigned
name|long
name|time
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|char
modifier|*
name|TclpGetTZName
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclpListVolumes
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|TclFile
name|TclpMakeFile
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Channel
name|channel
operator|,
name|int
name|direction
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|TclFile
name|TclpOpenFile
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|fname
operator|,
name|int
name|mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|char
modifier|*
name|TclpRealloc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|ptr
operator|,
name|unsigned
name|int
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclpRemoveDirectory
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|path
operator|,
name|int
name|recursive
operator|,
name|Tcl_DString
operator|*
name|errorPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclpRenameFile
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|source
operator|,
name|char
operator|*
name|dest
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|char
modifier|*
name|TclpSetEnv
name|_ANSI_ARGS_
argument_list|(
operator|(
name|CONST
name|char
operator|*
name|name
operator|,
name|CONST
name|char
operator|*
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|TclpSysAlloc
end_ifndef

begin_decl_stmt
name|EXTERN
name|VOID
modifier|*
name|TclpSysAlloc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|long
name|size
operator|,
name|int
name|isBin
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TclpSysFree
end_ifndef

begin_decl_stmt
name|EXTERN
name|void
name|TclpSysFree
name|_ANSI_ARGS_
argument_list|(
operator|(
name|VOID
operator|*
name|ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TclpSysRealloc
end_ifndef

begin_decl_stmt
name|EXTERN
name|VOID
modifier|*
name|TclpSysRealloc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|VOID
operator|*
name|cp
operator|,
name|unsigned
name|int
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|EXTERN
name|int
name|TclParseBraces
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|char
operator|*
operator|*
name|termPtr
operator|,
name|ParseValue
operator|*
name|pvPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclParseNestedCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|int
name|flags
operator|,
name|char
operator|*
operator|*
name|termPtr
operator|,
name|ParseValue
operator|*
name|pvPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclParseQuotes
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|int
name|termChar
operator|,
name|int
name|flags
operator|,
name|char
operator|*
operator|*
name|termPtr
operator|,
name|ParseValue
operator|*
name|pvPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclPlatformExit
name|_ANSI_ARGS_
argument_list|(
operator|(
name|int
name|status
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclPlatformInit
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|char
modifier|*
name|TclPrecTraceProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|name1
operator|,
name|char
operator|*
name|name2
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclPreventAliasLoop
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Interp
operator|*
name|cmdInterp
operator|,
name|Tcl_Command
name|cmd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclPrintByteCodeObj
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Obj
operator|*
name|objPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclRenameCommand
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|oldName
operator|,
name|char
operator|*
name|newName
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclResetShadowedCmdRefs
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Command
operator|*
name|newCmdPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclServiceIdle
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|Tcl_Obj
modifier|*
name|TclSetElementOfIndexedArray
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|localIndex
operator|,
name|Tcl_Obj
operator|*
name|elemPtr
operator|,
name|Tcl_Obj
operator|*
name|objPtr
operator|,
name|int
name|leaveErrorMsg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|Tcl_Obj
modifier|*
name|TclSetIndexedScalar
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|localIndex
operator|,
name|Tcl_Obj
operator|*
name|objPtr
operator|,
name|int
name|leaveErrorMsg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclSetupEnv
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclSockGetPort
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|char
operator|*
name|proto
operator|,
name|int
operator|*
name|portPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclSockMinimumBuffers
name|_ANSI_ARGS_
argument_list|(
operator|(
name|int
name|sock
operator|,
name|int
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclTeardownNamespace
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Namespace
operator|*
name|nsPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclTestChannelCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclTestChannelEventCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclUpdateReturnInfo
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Interp
operator|*
name|iPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|char
modifier|*
name|TclWordEnd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|start
operator|,
name|char
operator|*
name|lastChar
operator|,
name|int
name|nested
operator|,
name|int
operator|*
name|semiPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *----------------------------------------------------------------  * Command procedures in the generic core:  *----------------------------------------------------------------  */
end_comment

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_AfterObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_AppendObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ArrayObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_BinaryObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_BreakCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_CaseObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_CatchObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_CdObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ClockObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_CloseObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ConcatObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ContinueCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_EofObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ErrorObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_EvalObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ExecCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ExitObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ExprObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_FblockedObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_FconfigureCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_FcopyObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_FileObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_FileEventCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_FlushObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ForCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ForeachObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_FormatObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|dummy
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_GetsObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_GlobalObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_GlobCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_HistoryCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_IfCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_IncrCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_InfoObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_InterpObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_JoinObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_LappendObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_LindexObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_LinsertObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_LlengthObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ListObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_LoadCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_LrangeObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_LreplaceObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_LsearchObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_LsortObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_NamespaceObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_OpenCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_PackageCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_PidObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ProcObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_PutsObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_PwdCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ReadObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_RegexpCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_RegsubCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_RenameObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ReturnObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ScanCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_SeekCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_SetCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_SplitObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_SocketCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_SourceObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_StringObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_SubstCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_SwitchObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_TellCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_TimeObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_TraceCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_UnsetObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_UpdateCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_UplevelObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_UpvarObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_VariableObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_VwaitCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_WhileCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *----------------------------------------------------------------  * Command procedures found only in the Mac version of the core:  *----------------------------------------------------------------  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAC_TCL
end_ifdef

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_EchoCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_LsCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_BeepObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_MacSourceObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ResourceObjCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|objc
operator|,
name|Tcl_Obj
operator|*
name|CONST
name|objv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *----------------------------------------------------------------  * Compilation procedures for commands in the generic core:  *----------------------------------------------------------------  */
end_comment

begin_decl_stmt
name|EXTERN
name|int
name|TclCompileBreakCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|char
operator|*
name|lastChar
operator|,
name|int
name|compileFlags
operator|,
expr|struct
name|CompileEnv
operator|*
name|compileEnvPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclCompileCatchCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|char
operator|*
name|lastChar
operator|,
name|int
name|compileFlags
operator|,
expr|struct
name|CompileEnv
operator|*
name|compileEnvPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclCompileContinueCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|char
operator|*
name|lastChar
operator|,
name|int
name|compileFlags
operator|,
expr|struct
name|CompileEnv
operator|*
name|compileEnvPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclCompileExprCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|char
operator|*
name|lastChar
operator|,
name|int
name|compileFlags
operator|,
expr|struct
name|CompileEnv
operator|*
name|compileEnvPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclCompileForCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|char
operator|*
name|lastChar
operator|,
name|int
name|compileFlags
operator|,
expr|struct
name|CompileEnv
operator|*
name|compileEnvPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclCompileForeachCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|char
operator|*
name|lastChar
operator|,
name|int
name|compileFlags
operator|,
expr|struct
name|CompileEnv
operator|*
name|compileEnvPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclCompileIfCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|char
operator|*
name|lastChar
operator|,
name|int
name|compileFlags
operator|,
expr|struct
name|CompileEnv
operator|*
name|compileEnvPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclCompileIncrCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|char
operator|*
name|lastChar
operator|,
name|int
name|compileFlags
operator|,
expr|struct
name|CompileEnv
operator|*
name|compileEnvPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclCompileSetCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|char
operator|*
name|lastChar
operator|,
name|int
name|compileFlags
operator|,
expr|struct
name|CompileEnv
operator|*
name|compileEnvPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclCompileWhileCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|char
operator|*
name|lastChar
operator|,
name|int
name|compileFlags
operator|,
expr|struct
name|CompileEnv
operator|*
name|compileEnvPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *----------------------------------------------------------------  * Macros used by the Tcl core to create and release Tcl objects.  * TclNewObj(objPtr) creates a new object denoting an empty string.  * TclDecrRefCount(objPtr) decrements the object's reference count,  * and frees the object if its reference count is zero.  * These macros are inline versions of Tcl_NewObj() and  * Tcl_DecrRefCount(). Notice that the names differ in not having  * a "_" after the "Tcl". Notice also that these macros reference  * their argument more than once, so you should avoid calling them  * with an expression that is expensive to compute or has  * side effects. The ANSI C "prototypes" for these macros are:  *  * EXTERN void	TclNewObj _ANSI_ARGS_((Tcl_Obj *objPtr));  * EXTERN void	TclDecrRefCount _ANSI_ARGS_((Tcl_Obj *objPtr));  *----------------------------------------------------------------  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_COMPILE_STATS
end_ifdef

begin_define
define|#
directive|define
name|TclIncrObjsAllocated
parameter_list|()
define|\
value|tclObjsAlloced++
end_define

begin_define
define|#
directive|define
name|TclIncrObjsFreed
parameter_list|()
define|\
value|tclObjsFreed++
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TclIncrObjsAllocated
parameter_list|()
end_define

begin_define
define|#
directive|define
name|TclIncrObjsFreed
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_COMPILE_STATS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|TclNewObj
parameter_list|(
name|objPtr
parameter_list|)
define|\
value|(objPtr) = (Tcl_Obj *) Tcl_DbCkalloc(sizeof(Tcl_Obj), __FILE__, __LINE__); \     (objPtr)->refCount = 0; \     (objPtr)->bytes    = tclEmptyStringRep; \     (objPtr)->length   = 0; \     (objPtr)->typePtr  = NULL; \     TclIncrObjsAllocated()
end_define

begin_define
define|#
directive|define
name|TclDbNewObj
parameter_list|(
name|objPtr
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
define|\
value|(objPtr) = (Tcl_Obj *) Tcl_DbCkalloc(sizeof(Tcl_Obj), (file), (line)); \     (objPtr)->refCount = 0; \     (objPtr)->bytes    = tclEmptyStringRep; \     (objPtr)->length   = 0; \     (objPtr)->typePtr  = NULL; \     TclIncrObjsAllocated()
end_define

begin_define
define|#
directive|define
name|TclDecrRefCount
parameter_list|(
name|objPtr
parameter_list|)
define|\
value|if (--(objPtr)->refCount<= 0) { \  	if ((objPtr)->refCount< -1) \             panic("Reference count for %lx was negative: %s line %d", \ 		  (objPtr), __FILE__, __LINE__); \         if (((objPtr)->bytes != NULL) \&& ((objPtr)->bytes != tclEmptyStringRep)) { \ 	    ckfree((char *) (objPtr)->bytes); \         } \         if (((objPtr)->typePtr != NULL) \&& ((objPtr)->typePtr->freeIntRepProc != NULL)) { \ 	    (objPtr)->typePtr->freeIntRepProc(objPtr); \         } \         ckfree((char *) (objPtr)); \         TclIncrObjsFreed(); \     }
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not TCL_MEM_DEBUG */
end_comment

begin_define
define|#
directive|define
name|TclNewObj
parameter_list|(
name|objPtr
parameter_list|)
define|\
value|if (tclFreeObjList == NULL) { \ 	TclAllocateFreeObjects(); \     } \     (objPtr) = tclFreeObjList; \     tclFreeObjList = (Tcl_Obj *) \ 	tclFreeObjList->internalRep.otherValuePtr; \     (objPtr)->refCount = 0; \     (objPtr)->bytes    = tclEmptyStringRep; \     (objPtr)->length   = 0; \     (objPtr)->typePtr  = NULL; \     TclIncrObjsAllocated()
end_define

begin_define
define|#
directive|define
name|TclDecrRefCount
parameter_list|(
name|objPtr
parameter_list|)
define|\
value|if (--(objPtr)->refCount<= 0) { \         if (((objPtr)->bytes != NULL) \&& ((objPtr)->bytes != tclEmptyStringRep)) { \ 	    ckfree((char *) (objPtr)->bytes); \         } \         if (((objPtr)->typePtr != NULL) \&& ((objPtr)->typePtr->freeIntRepProc != NULL)) { \ 	    (objPtr)->typePtr->freeIntRepProc(objPtr); \         } \         (objPtr)->internalRep.otherValuePtr = (VOID *) tclFreeObjList; \         tclFreeObjList = (objPtr); \         TclIncrObjsFreed(); \     }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_MEM_DEBUG */
end_comment

begin_comment
comment|/*  *----------------------------------------------------------------  * Macro used by the Tcl core to set a Tcl_Obj's string representation  * to a copy of the "len" bytes starting at "bytePtr". This code  * works even if the byte array contains NULLs as long as the length  * is correct. Because "len" is referenced multiple times, it should  * be as simple an expression as possible. The ANSI C "prototype" for  * this macro is:  *  * EXTERN void	TclInitStringRep _ANSI_ARGS_((Tcl_Obj *objPtr,  *		    char *bytePtr, int len));  *----------------------------------------------------------------  */
end_comment

begin_define
define|#
directive|define
name|TclInitStringRep
parameter_list|(
name|objPtr
parameter_list|,
name|bytePtr
parameter_list|,
name|len
parameter_list|)
define|\
value|if ((len) == 0) { \         (objPtr)->bytes  = tclEmptyStringRep; \ 	(objPtr)->length = 0; \     } else { \ 	(objPtr)->bytes = (char *) ckalloc((unsigned) ((len) + 1)); \ 	memcpy((VOID *) (objPtr)->bytes, (VOID *) (bytePtr), \ 	        (unsigned) (len)); \ 	(objPtr)->bytes[len] = '\0'; \ 	(objPtr)->length = (len); \     }
end_define

begin_comment
comment|/*  *----------------------------------------------------------------  * Macro used by the Tcl core to get the string representation's  * byte array pointer and length from a Tcl_Obj. This is an inline  * version of Tcl_GetStringFromObj(). "lengthPtr" must be the  * address of an integer variable or NULL; If non-NULL, that variable  * will be set to the string rep's length. The macro's expression  * result is the string rep's byte pointer which might be NULL.  * Note that the bytes referenced by this pointer must not be modified  * by the caller. The ANSI C "prototype" for this macro is:  *  * EXTERN char *  TclGetStringFromObj _ANSI_ARGS_((Tcl_Obj *objPtr,  *		       int *lengthPtr));  *----------------------------------------------------------------  */
end_comment

begin_define
define|#
directive|define
name|TclGetStringFromObj
parameter_list|(
name|objPtr
parameter_list|,
name|lengthPtr
parameter_list|)
define|\
value|((objPtr)->bytes? \         ((lengthPtr)? \ 	    ((*(lengthPtr) = (objPtr)->length), (objPtr)->bytes) : \ 	    (objPtr)->bytes) : \         Tcl_GetStringFromObj((objPtr), (lengthPtr)))
end_define

begin_comment
comment|/*  *----------------------------------------------------------------  * Macro used by the Tcl core to reset an interpreter's Tcl object  * result to an unshared empty string object with ref count one.  * This does not clear any error information for the interpreter.  * The ANSI C "prototype" for this macro is:  *  * EXTERN void	TclResetObjResult _ANSI_ARGS_((Tcl_Interp *interp));  *---------------------------------------------------------------  */
end_comment

begin_define
define|#
directive|define
name|TclResetObjResult
parameter_list|(
name|interp
parameter_list|)
define|\
value|{ \         register Tcl_Obj *objResultPtr = ((Interp *) interp)->objResultPtr; \         if (Tcl_IsShared(objResultPtr)) { \ 	    TclDecrRefCount(objResultPtr); \ 	    TclNewObj(objResultPtr); \ 	    Tcl_IncrRefCount(objResultPtr); \ 	    ((Interp *) interp)->objResultPtr = objResultPtr; \         } else { \ 	    if ((objResultPtr->bytes != NULL) \&& (objResultPtr->bytes != tclEmptyStringRep)) { \ 	        ckfree((char *) objResultPtr->bytes); \ 	    } \ 	    objResultPtr->bytes  = tclEmptyStringRep; \ 	    objResultPtr->length = 0; \ 	    if ((objResultPtr->typePtr != NULL) \&& (objResultPtr->typePtr->freeIntRepProc != NULL)) { \ 	        objResultPtr->typePtr->freeIntRepProc(objResultPtr); \ 	    } \ 	    objResultPtr->typePtr = (Tcl_ObjType *) NULL; \         } \     }
end_define

begin_comment
comment|/*  *----------------------------------------------------------------  * Procedures used in conjunction with Tcl namespaces. They are  * defined here instead of in tcl.h since they are not stable yet.  *----------------------------------------------------------------  */
end_comment

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_AppendExportList
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Namespace
operator|*
name|nsPtr
operator|,
name|Tcl_Obj
operator|*
name|objPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|Tcl_Namespace
modifier|*
name|Tcl_CreateNamespace
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|name
operator|,
name|ClientData
name|clientData
operator|,
name|Tcl_NamespaceDeleteProc
operator|*
name|deleteProc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|Tcl_DeleteNamespace
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Namespace
operator|*
name|nsPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_Export
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Namespace
operator|*
name|nsPtr
operator|,
name|char
operator|*
name|pattern
operator|,
name|int
name|resetListFirst
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|Tcl_Command
name|Tcl_FindCommand
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|name
operator|,
name|Tcl_Namespace
operator|*
name|contextNsPtr
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|Tcl_Namespace
modifier|*
name|Tcl_FindNamespace
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|name
operator|,
name|Tcl_Namespace
operator|*
name|contextNsPtr
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|Tcl_Var
name|Tcl_FindNamespaceVar
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|name
operator|,
name|Tcl_Namespace
operator|*
name|contextNsPtr
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ForgetImport
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Namespace
operator|*
name|nsPtr
operator|,
name|char
operator|*
name|pattern
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|Tcl_Command
name|Tcl_GetCommandFromObj
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Obj
operator|*
name|objPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|Tcl_GetCommandFullName
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Command
name|command
operator|,
name|Tcl_Obj
operator|*
name|objPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|Tcl_Namespace
modifier|*
name|Tcl_GetCurrentNamespace
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|Tcl_Namespace
modifier|*
name|Tcl_GetGlobalNamespace
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|Tcl_GetVariableFullName
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Var
name|variable
operator|,
name|Tcl_Obj
operator|*
name|objPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_Import
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Namespace
operator|*
name|nsPtr
operator|,
name|char
operator|*
name|pattern
operator|,
name|int
name|allowOverwrite
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|Tcl_PopCallFrame
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_PushCallFrame
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_CallFrame
operator|*
name|framePtr
operator|,
name|Tcl_Namespace
operator|*
name|nsPtr
operator|,
name|int
name|isProcCallFrame
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _TCLINT */
end_comment

end_unit

