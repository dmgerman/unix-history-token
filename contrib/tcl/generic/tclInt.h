begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * tclInt.h --  *  *	Declarations of things used internally by the Tcl interpreter.  *  * Copyright (c) 1987-1993 The Regents of the University of California.  * Copyright (c) 1994-1996 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclInt.h 1.200 96/04/11 17:24:12  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_TCLINT
end_ifndef

begin_define
define|#
directive|define
name|_TCLINT
end_define

begin_comment
comment|/*  * Common include files needed by most of the Tcl source files are  * included here, so that system-dependent personalizations for the  * include files only have to be made in once place.  This results  * in a few extra includes, but greater modularity.  The order of  * the three groups of #includes is important.  For example, stdio.h  * is needed by tcl.h, and the _ANSI_ARGS_ declaration in tcl.h is  * needed by stdlib.h in some configurations.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_TCL
end_ifndef

begin_include
include|#
directive|include
file|"tcl.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_REGEXP
end_ifndef

begin_include
include|#
directive|include
file|"tclRegexp.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NO_LIMITS_H
end_ifdef

begin_include
include|#
directive|include
file|"../compat/limits.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|"../compat/stdlib.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|"../compat/string.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_STDARG
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *----------------------------------------------------------------  * Data structures related to variables.   These are used primarily  * in tclVar.c  *----------------------------------------------------------------  */
end_comment

begin_comment
comment|/*  * The following structure defines a variable trace, which is used to  * invoke a specific C procedure whenever certain operations are performed  * on a variable.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|VarTrace
block|{
name|Tcl_VarTraceProc
modifier|*
name|traceProc
decl_stmt|;
comment|/* Procedure to call when operations given 				 * by flags are performed on variable. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Argument to pass to proc. */
name|int
name|flags
decl_stmt|;
comment|/* What events the trace procedure is 				 * interested in:  OR-ed combination of 				 * TCL_TRACE_READS, TCL_TRACE_WRITES, and 				 * TCL_TRACE_UNSETS. */
name|struct
name|VarTrace
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next in list of traces associated with 				 * a particular variable. */
block|}
name|VarTrace
typedef|;
end_typedef

begin_comment
comment|/*  * When a variable trace is active (i.e. its associated procedure is  * executing), one of the following structures is linked into a list  * associated with the variable's interpreter.  The information in  * the structure is needed in order for Tcl to behave reasonably  * if traces are deleted while traces are active.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ActiveVarTrace
block|{
name|struct
name|Var
modifier|*
name|varPtr
decl_stmt|;
comment|/* Variable that's being traced. */
name|struct
name|ActiveVarTrace
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next in list of all active variable 				 * traces for the interpreter, or NULL 				 * if no more. */
name|VarTrace
modifier|*
name|nextTracePtr
decl_stmt|;
comment|/* Next trace to check after current 				 * trace procedure returns;  if this 				 * trace gets deleted, must update pointer 				 * to avoid using free'd memory. */
block|}
name|ActiveVarTrace
typedef|;
end_typedef

begin_comment
comment|/*  * The following structure describes an enumerative search in progress on  * an array variable;  this are invoked with options to the "array"  * command.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ArraySearch
block|{
name|int
name|id
decl_stmt|;
comment|/* Integer id used to distinguish among 				 * multiple concurrent searches for the 				 * same array. */
name|struct
name|Var
modifier|*
name|varPtr
decl_stmt|;
comment|/* Pointer to array variable that's being 				 * searched. */
name|Tcl_HashSearch
name|search
decl_stmt|;
comment|/* Info kept by the hash module about 				 * progress through the array. */
name|Tcl_HashEntry
modifier|*
name|nextEntry
decl_stmt|;
comment|/* Non-null means this is the next element 				 * to be enumerated (it's leftover from 				 * the Tcl_FirstHashEntry call or from 				 * an "array anymore" command).  NULL 				 * means must call Tcl_NextHashEntry 				 * to get value to return. */
name|struct
name|ArraySearch
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next in list of all active searches 				 * for this variable, or NULL if this is 				 * the last one. */
block|}
name|ArraySearch
typedef|;
end_typedef

begin_comment
comment|/*  * The structure below defines a variable, which associates a string name  * with a string value.  Pointers to these structures are kept as the  * values of hash table entries, and the name of each variable is stored  * in the hash entry.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Var
block|{
name|int
name|valueLength
decl_stmt|;
comment|/* Holds the number of non-null bytes 				 * actually occupied by the variable's 				 * current value in value.string (extra 				 * space is sometimes left for expansion). 				 * For array and global variables this is 				 * meaningless. */
name|int
name|valueSpace
decl_stmt|;
comment|/* Total number of bytes of space allocated 				 * at value.string.  0 means there is no 				 * space allocated. */
union|union
block|{
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String value of variable, used for scalar 				 * variables and array elements.  Malloc-ed. */
name|Tcl_HashTable
modifier|*
name|tablePtr
decl_stmt|;
comment|/* For array variables, this points to 				 * information about the hash table used 				 * to implement the associative array.  				 * Points to malloc-ed data. */
name|struct
name|Var
modifier|*
name|upvarPtr
decl_stmt|;
comment|/* If this is a global variable being 				 * referred to in a procedure, or a variable 				 * created by "upvar", this field points to 				 * the record for the higher-level variable. */
block|}
name|value
union|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Hash table entry that refers to this 				 * variable, or NULL if the variable has 				 * been detached from its hash table (e.g. 				 * an array is deleted, but some of its 				 * elements are still referred to in upvars). */
name|int
name|refCount
decl_stmt|;
comment|/* Counts number of active uses of this 				 * variable, not including its main hash 				 * table entry: 1 for each additional variable 				 * whose upVarPtr points here, 1 for each 				 * nested trace active on variable.  This 				 * record can't be deleted until refCount 				 * becomes 0. */
name|VarTrace
modifier|*
name|tracePtr
decl_stmt|;
comment|/* First in list of all traces set for this 				 * variable. */
name|ArraySearch
modifier|*
name|searchPtr
decl_stmt|;
comment|/* First in list of all searches active 				 * for this variable, or NULL if none. */
name|int
name|flags
decl_stmt|;
comment|/* Miscellaneous bits of information about 				 * variable.  See below for definitions. */
block|}
name|Var
typedef|;
end_typedef

begin_comment
comment|/*  * Flag bits for variables:  *  * VAR_ARRAY	-		1 means this is an array variable rather  *				than a scalar variable.  * VAR_UPVAR - 			1 means this variable just contains a  *				pointer to another variable that has the  *				real value.  Variables like this come  *				about through the "upvar" and "global"  *				commands.  * VAR_UNDEFINED -		1 means that the variable is currently  *				undefined.  Undefined variables usually  *				go away completely, but if an undefined  *				variable has a trace on it, or if it is  *				a global variable being used by a procedure,  *				then it stays around even when undefined.  * VAR_TRACE_ACTIVE -		1 means that trace processing is currently  *				underway for a read or write access, so  *				new read or write accesses should not cause  *				trace procedures to be called and the  *				variable can't be deleted.  */
end_comment

begin_define
define|#
directive|define
name|VAR_ARRAY
value|1
end_define

begin_define
define|#
directive|define
name|VAR_UPVAR
value|2
end_define

begin_define
define|#
directive|define
name|VAR_UNDEFINED
value|4
end_define

begin_define
define|#
directive|define
name|VAR_TRACE_ACTIVE
value|0x10
end_define

begin_comment
comment|/*  *----------------------------------------------------------------  * Data structures related to procedures.   These are used primarily  * in tclProc.c  *----------------------------------------------------------------  */
end_comment

begin_comment
comment|/*  * The structure below defines an argument to a procedure, which  * consists of a name and an (optional) default value.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Arg
block|{
name|struct
name|Arg
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next argument for this procedure, 				 * or NULL if this is the last argument. */
name|char
modifier|*
name|defValue
decl_stmt|;
comment|/* Pointer to arg's default value, or NULL 				 * if no default value. */
name|char
name|name
index|[
literal|4
index|]
decl_stmt|;
comment|/* Name of argument starts here.  The name 				 * is followed by space for the default, 				 * if there is one.  The actual size of this 				 * field will be as large as necessary to 				 * hold both name and default value.  THIS 				 * MUST BE THE LAST FIELD IN THE STRUCTURE!! */
block|}
name|Arg
typedef|;
end_typedef

begin_comment
comment|/*  * The structure below defines a command procedure, which consists of  * a collection of Tcl commands plus information about arguments and  * variables.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Proc
block|{
name|struct
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Interpreter for which this command 				 * is defined. */
name|int
name|refCount
decl_stmt|;
comment|/* Reference count:  1 if still present 				 * in command table plus 1 for each call 				 * to the procedure that is currently 				 * active.  This structure can be freed 				 * when refCount becomes zero. */
name|char
modifier|*
name|command
decl_stmt|;
comment|/* Command that constitutes the body of 				 * the procedure (dynamically allocated). */
name|Arg
modifier|*
name|argPtr
decl_stmt|;
comment|/* Pointer to first of procedure's formal 				 * arguments, or NULL if none. */
block|}
name|Proc
typedef|;
end_typedef

begin_comment
comment|/*  * The structure below defines a command trace.  This is used to allow Tcl  * clients to find out whenever a command is about to be executed.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Trace
block|{
name|int
name|level
decl_stmt|;
comment|/* Only trace commands at nesting level 				 * less than or equal to this. */
name|Tcl_CmdTraceProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to call to trace command. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary value to pass to proc. */
name|struct
name|Trace
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next in list of traces for this interp. */
block|}
name|Trace
typedef|;
end_typedef

begin_comment
comment|/*  * The structure below defines an entry in the assocData hash table which  * is associated with an interpreter. The entry contains a pointer to a  * function to call when the interpreter is deleted, and a pointer to  * a user-defined piece of data.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|AssocData
block|{
name|Tcl_InterpDeleteProc
modifier|*
name|proc
decl_stmt|;
comment|/* Proc to call when deleting. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Value to pass to proc. */
block|}
name|AssocData
typedef|;
end_typedef

begin_comment
comment|/*  * The structure below defines a frame, which is a procedure invocation.  * These structures exist only while procedures are being executed, and  * provide a sort of call stack.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|CallFrame
block|{
name|Tcl_HashTable
name|varTable
decl_stmt|;
comment|/* Hash table containing all of procedure's 				 * local variables. */
name|int
name|level
decl_stmt|;
comment|/* Level of this procedure, for "uplevel" 				 * purposes (i.e. corresponds to nesting of 				 * callerVarPtr's, not callerPtr's).  1 means 				 * outer-most procedure, 0 means top-level. */
name|int
name|argc
decl_stmt|;
comment|/* This and argv below describe name and 				 * arguments for this procedure invocation. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Array of arguments. */
name|struct
name|CallFrame
modifier|*
name|callerPtr
decl_stmt|;
comment|/* Value of interp->framePtr when this 				 * procedure was invoked (i.e. next in 				 * stack of all active procedures). */
name|struct
name|CallFrame
modifier|*
name|callerVarPtr
decl_stmt|;
comment|/* Value of interp->varFramePtr when this 				 * procedure was invoked (i.e. determines 				 * variable scoping within caller;  same 				 * as callerPtr unless an "uplevel" command 				 * or something equivalent was active in 				 * the caller). */
block|}
name|CallFrame
typedef|;
end_typedef

begin_comment
comment|/*  * The structure below defines one history event (a previously-executed  * command that can be re-executed in whole or in part).  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|command
decl_stmt|;
comment|/* String containing previously-executed 				 * command. */
name|int
name|bytesAvl
decl_stmt|;
comment|/* Total # of bytes available at *event (not 				 * all are necessarily in use now). */
block|}
name|HistoryEvent
typedef|;
end_typedef

begin_comment
comment|/*  *----------------------------------------------------------------  * Data structures related to history.   These are used primarily  * in tclHistory.c  *----------------------------------------------------------------  */
end_comment

begin_comment
comment|/*  * The structure below defines a pending revision to the most recent  * history event.  Changes are linked together into a list and applied  * during the next call to Tcl_RecordHistory.  See the comments at the  * beginning of tclHistory.c for information on revisions.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|HistoryRev
block|{
name|int
name|firstIndex
decl_stmt|;
comment|/* Index of the first byte to replace in 				 * current history event. */
name|int
name|lastIndex
decl_stmt|;
comment|/* Index of last byte to replace in 				 * current history event. */
name|int
name|newSize
decl_stmt|;
comment|/* Number of bytes in newBytes. */
name|char
modifier|*
name|newBytes
decl_stmt|;
comment|/* Replacement for the range given by 				 * firstIndex and lastIndex (malloced). */
name|struct
name|HistoryRev
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next in chain of revisions to apply, or 				 * NULL for end of list. */
block|}
name|HistoryRev
typedef|;
end_typedef

begin_comment
comment|/*  *----------------------------------------------------------------  * Data structures related to expressions.  These are used only in  * tclExpr.c.  *----------------------------------------------------------------  */
end_comment

begin_comment
comment|/*  * The data structure below defines a math function (e.g. sin or hypot)  * for use in Tcl expressions.  */
end_comment

begin_define
define|#
directive|define
name|MAX_MATH_ARGS
value|5
end_define

begin_typedef
typedef|typedef
struct|struct
name|MathFunc
block|{
name|int
name|numArgs
decl_stmt|;
comment|/* Number of arguments for function. */
name|Tcl_ValueType
name|argTypes
index|[
name|MAX_MATH_ARGS
index|]
decl_stmt|;
comment|/* Acceptable types for each argument. */
name|Tcl_MathProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure that implements this function. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Additional argument to pass to the function 				 * when invoking it. */
block|}
name|MathFunc
typedef|;
end_typedef

begin_comment
comment|/*  *----------------------------------------------------------------  * One of the following structures exists for each command in  * an interpreter.  The Tcl_Command opaque type actually refers  * to these structures.  *----------------------------------------------------------------  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Command
block|{
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Pointer to the hash table entry in 				 * interp->commandTable that refers to 				 * this command.  Used to get a command's 				 * name from its Tcl_Command handle.  NULL 				 * means that the hash table entry has 				 * been removed already (this can happen 				 * if deleteProc causes the command to be 				 * deleted or recreated). */
name|Tcl_CmdProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to process command. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary value to pass to proc. */
name|Tcl_CmdDeleteProc
modifier|*
name|deleteProc
decl_stmt|;
comment|/* Procedure to invoke when deleting 				 * command. */
name|ClientData
name|deleteData
decl_stmt|;
comment|/* Arbitrary value to pass to deleteProc 				 * (usually the same as clientData). */
name|int
name|deleted
decl_stmt|;
comment|/* Means that the command is in the process 				 * of being deleted (its deleteProc is 				 * currently executing).  Any other attempts 				 * to delete the command should be ignored. */
block|}
name|Command
typedef|;
end_typedef

begin_comment
comment|/*  *----------------------------------------------------------------  * This structure defines an interpreter, which is a collection of  * commands plus other state information related to interpreting  * commands, such as variable storage.  Primary responsibility for  * this data structure is in tclBasic.c, but almost every Tcl  * source file uses something in here.  *----------------------------------------------------------------  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Interp
block|{
comment|/*      * Note:  the first three fields must match exactly the fields in      * a Tcl_Interp struct (see tcl.h).  If you change one, be sure to      * change the other.      */
name|char
modifier|*
name|result
decl_stmt|;
comment|/* Points to result returned by last 				 * command. */
name|Tcl_FreeProc
modifier|*
name|freeProc
decl_stmt|;
comment|/* Zero means result is statically allocated. 				 * TCL_DYNAMIC means result was allocated with 				 * ckalloc and should be freed with ckfree. 				 * Other values give address of procedure 				 * to invoke to free the result.  Must be 				 * freed by Tcl_Eval before executing next 				 * command. */
name|int
name|errorLine
decl_stmt|;
comment|/* When TCL_ERROR is returned, this gives 				 * the line number within the command where 				 * the error occurred (1 means first line). */
name|Tcl_HashTable
name|commandTable
decl_stmt|;
comment|/* Contains all of the commands currently 				 * registered in this interpreter.  Indexed 				 * by strings; values have type (Command *). */
name|Tcl_HashTable
name|mathFuncTable
decl_stmt|;
comment|/* Contains all of the math functions currently 				 * defined for the interpreter.  Indexed by 				 * strings (function names);  values have 				 * type (MathFunc *). */
comment|/*      * Information related to procedures and variables.  See tclProc.c      * and tclvar.c for usage.      */
name|Tcl_HashTable
name|globalTable
decl_stmt|;
comment|/* Contains all global variables for 				 * interpreter. */
name|int
name|numLevels
decl_stmt|;
comment|/* Keeps track of how many nested calls to 				 * Tcl_Eval are in progress for this 				 * interpreter.  It's used to delay deletion 				 * of the table until all Tcl_Eval invocations 				 * are completed. */
name|int
name|maxNestingDepth
decl_stmt|;
comment|/* If numLevels exceeds this value then Tcl 				 * assumes that infinite recursion has 				 * occurred and it generates an error. */
name|CallFrame
modifier|*
name|framePtr
decl_stmt|;
comment|/* Points to top-most in stack of all nested 				 * procedure invocations.  NULL means there 				 * are no active procedures. */
name|CallFrame
modifier|*
name|varFramePtr
decl_stmt|;
comment|/* Points to the call frame whose variables 				 * are currently in use (same as framePtr 				 * unless an "uplevel" command is being 				 * executed).  NULL means no procedure is 				 * active or "uplevel 0" is being exec'ed. */
name|ActiveVarTrace
modifier|*
name|activeTracePtr
decl_stmt|;
comment|/* First in list of active traces for interp, 				 * or NULL if no active traces. */
name|int
name|returnCode
decl_stmt|;
comment|/* Completion code to return if current 				 * procedure exits with a TCL_RETURN code. */
name|char
modifier|*
name|errorInfo
decl_stmt|;
comment|/* Value to store in errorInfo if returnCode 				 * is TCL_ERROR.  Malloc'ed, may be NULL */
name|char
modifier|*
name|errorCode
decl_stmt|;
comment|/* Value to store in errorCode if returnCode 				 * is TCL_ERROR.  Malloc'ed, may be NULL */
comment|/*      * Information related to history:      */
name|int
name|numEvents
decl_stmt|;
comment|/* Number of previously-executed commands 				 * to retain. */
name|HistoryEvent
modifier|*
name|events
decl_stmt|;
comment|/* Array containing numEvents entries 				 * (dynamically allocated). */
name|int
name|curEvent
decl_stmt|;
comment|/* Index into events of place where current 				 * (or most recent) command is recorded. */
name|int
name|curEventNum
decl_stmt|;
comment|/* Event number associated with the slot 				 * given by curEvent. */
name|HistoryRev
modifier|*
name|revPtr
decl_stmt|;
comment|/* First in list of pending revisions. */
name|char
modifier|*
name|historyFirst
decl_stmt|;
comment|/* First char. of current command executed 				 * from history module or NULL if none. */
name|int
name|revDisables
decl_stmt|;
comment|/* 0 means history revision OK;> 0 gives 				 * a count of number of times revision has 				 * been disabled. */
name|char
modifier|*
name|evalFirst
decl_stmt|;
comment|/* If TCL_RECORD_BOUNDS flag set, Tcl_Eval 				 * sets this field to point to the first 				 * char. of text from which the current 				 * command came.  Otherwise Tcl_Eval sets 				 * this to NULL. */
name|char
modifier|*
name|evalLast
decl_stmt|;
comment|/* Similar to evalFirst, except points to 				 * last character of current command. */
comment|/*      * Information used by Tcl_AppendResult to keep track of partial      * results.  See Tcl_AppendResult code for details.      */
name|char
modifier|*
name|appendResult
decl_stmt|;
comment|/* Storage space for results generated 				 * by Tcl_AppendResult.  Malloc-ed.  NULL 				 * means not yet allocated. */
name|int
name|appendAvl
decl_stmt|;
comment|/* Total amount of space available at 				 * partialResult. */
name|int
name|appendUsed
decl_stmt|;
comment|/* Number of non-null bytes currently 				 * stored at partialResult. */
comment|/*      * A cache of compiled regular expressions.  See Tcl_RegExpCompile      * in tclUtil.c for details.      */
define|#
directive|define
name|NUM_REGEXPS
value|5
name|char
modifier|*
name|patterns
index|[
name|NUM_REGEXPS
index|]
decl_stmt|;
comment|/* Strings corresponding to compiled 				 * regular expression patterns.  NULL 				 * means that this slot isn't used. 				 * Malloc-ed. */
name|int
name|patLengths
index|[
name|NUM_REGEXPS
index|]
decl_stmt|;
comment|/* Number of non-null characters in 				 * corresponding entry in patterns. 				 * -1 means entry isn't used. */
name|regexp
modifier|*
name|regexps
index|[
name|NUM_REGEXPS
index|]
decl_stmt|;
comment|/* Compiled forms of above strings.  Also 				 * malloc-ed, or NULL if not in use yet. */
comment|/*      * Information about packages.  Used only in tclPkg.c.      */
name|Tcl_HashTable
name|packageTable
decl_stmt|;
comment|/* Describes all of the packages loaded 				 * in or available to this interpreter. 				 * Keys are package names, values are 				 * (Package *) pointers. */
name|char
modifier|*
name|packageUnknown
decl_stmt|;
comment|/* Command to invoke during "package 				 * require" commands for packages that 				 * aren't described in packageTable.  				 * Malloc'ed, may be NULL. */
comment|/*      * Information used by Tcl_PrintDouble:      */
name|char
name|pdFormat
index|[
literal|10
index|]
decl_stmt|;
comment|/* Format string used by Tcl_PrintDouble. */
name|int
name|pdPrec
decl_stmt|;
comment|/* Current precision (used to restore the 				 * the tcl_precision variable after a bogus 				 * value has been put into it). */
comment|/*      * Miscellaneous information:      */
name|int
name|cmdCount
decl_stmt|;
comment|/* Total number of times a command procedure 				 * has been called for this interpreter. */
name|int
name|noEval
decl_stmt|;
comment|/* Non-zero means no commands should actually 				 * be executed:  just parse only.  Used in 				 * expressions when the result is already 				 * determined. */
name|int
name|evalFlags
decl_stmt|;
comment|/* Flags to control next call to Tcl_Eval. 				 * Normally zero, but may be set before 				 * calling Tcl_Eval.  See below for valid 				 * values. */
name|char
modifier|*
name|termPtr
decl_stmt|;
comment|/* Character just after the last one in 				 * a command.  Set by Tcl_Eval before 				 * returning. */
name|char
modifier|*
name|scriptFile
decl_stmt|;
comment|/* NULL means there is no nested source 				 * command active;  otherwise this points to 				 * the name of the file being sourced (it's 				 * not malloc-ed:  it points to an argument 				 * to Tcl_EvalFile. */
name|int
name|flags
decl_stmt|;
comment|/* Various flag bits.  See below. */
name|Trace
modifier|*
name|tracePtr
decl_stmt|;
comment|/* List of traces for this interpreter. */
name|Tcl_HashTable
modifier|*
name|assocData
decl_stmt|;
comment|/* Hash table for associating data with                                  * this interpreter. Cleaned up when                                  * this interpreter is deleted. */
name|char
name|resultSpace
index|[
name|TCL_RESULT_SIZE
operator|+
literal|1
index|]
decl_stmt|;
comment|/* Static space for storing small results. */
block|}
name|Interp
typedef|;
end_typedef

begin_comment
comment|/*  * EvalFlag bits for Interp structures:  *  * TCL_BRACKET_TERM	1 means that the current script is terminated by  *			a close bracket rather than the end of the string.  * TCL_RECORD_BOUNDS	Tells Tcl_Eval to record information in the  *			evalFirst and evalLast fields for each command  *			executed directly from the string (top-level  *			commands and those from command substitution).  * TCL_ALLOW_EXCEPTIONS	1 means it's OK for the script to terminate with  *			a code other than TCL_OK or TCL_ERROR;  0 means  *			codes other than these should be turned into errors.  */
end_comment

begin_define
define|#
directive|define
name|TCL_BRACKET_TERM
value|1
end_define

begin_define
define|#
directive|define
name|TCL_RECORD_BOUNDS
value|2
end_define

begin_define
define|#
directive|define
name|TCL_ALLOW_EXCEPTIONS
value|4
end_define

begin_comment
comment|/*  * Flag bits for Interp structures:  *  * DELETED:		Non-zero means the interpreter has been deleted:  *			don't process any more commands for it, and destroy  *			the structure as soon as all nested invocations of  *			Tcl_Eval are done.  * ERR_IN_PROGRESS:	Non-zero means an error unwind is already in progress.  *			Zero means a command proc has been invoked since last  *			error occured.  * ERR_ALREADY_LOGGED:	Non-zero means information has already been logged  *			in $errorInfo for the current Tcl_Eval instance,  *			so Tcl_Eval needn't log it (used to implement the  *			"error message log" command).  * ERROR_CODE_SET:	Non-zero means that Tcl_SetErrorCode has been  *			called to record information for the current  *			error.  Zero means Tcl_Eval must clear the  *			errorCode variable if an error is returned.  * EXPR_INITIALIZED:	1 means initialization specific to expressions has  *			been carried out.  */
end_comment

begin_define
define|#
directive|define
name|DELETED
value|1
end_define

begin_define
define|#
directive|define
name|ERR_IN_PROGRESS
value|2
end_define

begin_define
define|#
directive|define
name|ERR_ALREADY_LOGGED
value|4
end_define

begin_define
define|#
directive|define
name|ERROR_CODE_SET
value|8
end_define

begin_define
define|#
directive|define
name|EXPR_INITIALIZED
value|0x10
end_define

begin_comment
comment|/*  * Default value for the pdPrec and pdFormat fields of interpreters:  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_PD_PREC
value|6
end_define

begin_define
define|#
directive|define
name|DEFAULT_PD_FORMAT
value|"%g"
end_define

begin_comment
comment|/*  *----------------------------------------------------------------  * Data structures related to command parsing.   These are used in  * tclParse.c and its clients.  *----------------------------------------------------------------  */
end_comment

begin_comment
comment|/*  * The following data structure is used by various parsing procedures  * to hold information about where to store the results of parsing  * (e.g. the substituted contents of a quoted argument, or the result  * of a nested command).  At any given time, the space available  * for output is fixed, but a procedure may be called to expand the  * space available if the current space runs out.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ParseValue
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* Address of first character in 				 * output buffer. */
name|char
modifier|*
name|next
decl_stmt|;
comment|/* Place to store next character in 				 * output buffer. */
name|char
modifier|*
name|end
decl_stmt|;
comment|/* Address of the last usable character 				 * in the buffer. */
name|void
argument_list|(
argument|*expandProc
argument_list|)
name|_ANSI_ARGS_
argument_list|(
operator|(
expr|struct
name|ParseValue
operator|*
name|pvPtr
operator|,
name|int
name|needed
operator|)
argument_list|)
expr_stmt|;
comment|/* Procedure to call when space runs out; 				 * it will make more space. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary information for use of 				 * expandProc. */
block|}
name|ParseValue
typedef|;
end_typedef

begin_comment
comment|/*  * A table used to classify input characters to assist in parsing  * Tcl commands.  The table should be indexed with a signed character  * using the CHAR_TYPE macro.  The character may have a negative  * value.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|tclTypeTable
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CHAR_TYPE
parameter_list|(
name|c
parameter_list|)
value|(tclTypeTable+128)[c]
end_define

begin_comment
comment|/*  * Possible values returned by CHAR_TYPE:  *  * TCL_NORMAL -		All characters that don't have special significance  *			to the Tcl language.  * TCL_SPACE -		Character is space, tab, or return.  * TCL_COMMAND_END -	Character is newline or null or semicolon or  *			close-bracket.  * TCL_QUOTE -		Character is a double-quote.  * TCL_OPEN_BRACKET -	Character is a "[".  * TCL_OPEN_BRACE -	Character is a "{".  * TCL_CLOSE_BRACE -	Character is a "}".  * TCL_BACKSLASH -	Character is a "\".  * TCL_DOLLAR -		Character is a "$".  */
end_comment

begin_define
define|#
directive|define
name|TCL_NORMAL
value|0
end_define

begin_define
define|#
directive|define
name|TCL_SPACE
value|1
end_define

begin_define
define|#
directive|define
name|TCL_COMMAND_END
value|2
end_define

begin_define
define|#
directive|define
name|TCL_QUOTE
value|3
end_define

begin_define
define|#
directive|define
name|TCL_OPEN_BRACKET
value|4
end_define

begin_define
define|#
directive|define
name|TCL_OPEN_BRACE
value|5
end_define

begin_define
define|#
directive|define
name|TCL_CLOSE_BRACE
value|6
end_define

begin_define
define|#
directive|define
name|TCL_BACKSLASH
value|7
end_define

begin_define
define|#
directive|define
name|TCL_DOLLAR
value|8
end_define

begin_comment
comment|/*  * Maximum number of levels of nesting permitted in Tcl commands (used  * to catch infinite recursion).  */
end_comment

begin_define
define|#
directive|define
name|MAX_NESTING_DEPTH
value|1000
end_define

begin_comment
comment|/*  * The macro below is used to modify a "char" value (e.g. by casting  * it to an unsigned character) so that it can be used safely with  * macros such as isspace.  */
end_comment

begin_define
define|#
directive|define
name|UCHAR
parameter_list|(
name|c
parameter_list|)
value|((unsigned char) (c))
end_define

begin_comment
comment|/*  * Given a size or address, the macro below "aligns" it to the machine's  * memory unit size (e.g. an 8-byte boundary) so that anything can be  * placed at the aligned address without fear of an alignment error.  */
end_comment

begin_define
define|#
directive|define
name|TCL_ALIGN
parameter_list|(
name|x
parameter_list|)
value|((x + 7)& ~7)
end_define

begin_comment
comment|/*  * For each event source (created with Tcl_CreateEventSource) there  * is a structure of the following type:  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|TclEventSource
block|{
name|Tcl_EventSetupProc
modifier|*
name|setupProc
decl_stmt|;
comment|/* This procedure is called by 					 * Tcl_DoOneEvent to set up information 					 * for the wait operation, such as 					 * files to wait for or maximum 					 * timeout. */
name|Tcl_EventCheckProc
modifier|*
name|checkProc
decl_stmt|;
comment|/* This procedure is called by 					 * Tcl_DoOneEvent after its wait 					 * operation to see what events 					 * are ready and queue them. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary one-word argument to pass 					 * to setupProc and checkProc. */
name|struct
name|TclEventSource
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next in list of all event sources 					 * defined for applicaton. */
block|}
name|TclEventSource
typedef|;
end_typedef

begin_comment
comment|/*  * The following macros are used to specify the runtime platform  * setting of the tclPlatform variable.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|TCL_PLATFORM_UNIX
block|,
comment|/* Any Unix-like OS. */
name|TCL_PLATFORM_MAC
block|,
comment|/* MacOS. */
name|TCL_PLATFORM_WINDOWS
comment|/* Any Microsoft Windows OS. */
block|}
name|TclPlatformType
typedef|;
end_typedef

begin_comment
comment|/*  *----------------------------------------------------------------  * Variables shared among Tcl modules but not used by the outside  * world:  *----------------------------------------------------------------  */
end_comment

begin_decl_stmt
specifier|extern
name|Tcl_Time
name|tclBlockTime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tclBlockTimeSet
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tclExecutableName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|TclEventSource
modifier|*
name|tclFirstEventSourcePtr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Tcl_ChannelType
name|tclFileChannelType
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tclMemDumpFileName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|TclPlatformType
name|tclPlatform
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *----------------------------------------------------------------  * Procedures shared among Tcl modules but not used by the outside  * world:  *----------------------------------------------------------------  */
end_comment

begin_function_decl
name|EXTERN
name|void
name|panic
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|EXTERN
name|int
name|TclCleanupChildren
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|numPids
operator|,
name|int
operator|*
name|pidPtr
operator|,
name|Tcl_Channel
name|errorChan
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclCloseFile
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_File
name|file
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|char
modifier|*
name|TclConvertToNative
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|name
operator|,
name|Tcl_DString
operator|*
name|bufferPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|char
modifier|*
name|TclConvertToNetwork
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|name
operator|,
name|Tcl_DString
operator|*
name|bufferPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclCopyAndCollapse
name|_ANSI_ARGS_
argument_list|(
operator|(
name|int
name|count
operator|,
name|char
operator|*
name|src
operator|,
name|char
operator|*
name|dst
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclChdir
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|dirName
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclClosePipeFile
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_File
name|file
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|Tcl_Channel
name|TclCreateCommandChannel
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_File
name|readFile
operator|,
name|Tcl_File
name|writeFile
operator|,
name|Tcl_File
name|errorFile
operator|,
name|int
name|numPids
operator|,
name|int
operator|*
name|pidPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclCreatePipe
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_File
operator|*
name|readPipe
operator|,
name|Tcl_File
operator|*
name|writePipe
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclCreatePipeline
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|int
operator|*
operator|*
name|pidArrayPtr
operator|,
name|Tcl_File
operator|*
name|inPipePtr
operator|,
name|Tcl_File
operator|*
name|outPipePtr
operator|,
name|Tcl_File
operator|*
name|errFilePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|Tcl_File
name|TclCreateTempFile
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|contents
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclDeleteVars
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Interp
operator|*
name|iPtr
operator|,
name|Tcl_HashTable
operator|*
name|tablePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclDoGlob
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|separators
operator|,
name|Tcl_DString
operator|*
name|headPtr
operator|,
name|char
operator|*
name|tail
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclExpandParseValue
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ParseValue
operator|*
name|pvPtr
operator|,
name|int
name|needed
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclExprFloatError
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|double
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclFindElement
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|list
operator|,
name|char
operator|*
operator|*
name|elementPtr
operator|,
name|char
operator|*
operator|*
name|nextPtr
operator|,
name|int
operator|*
name|sizePtr
operator|,
name|int
operator|*
name|bracePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|Proc
modifier|*
name|TclFindProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Interp
operator|*
name|iPtr
operator|,
name|char
operator|*
name|procName
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclFreePackageInfo
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Interp
operator|*
name|iPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|char
modifier|*
name|TclGetCwd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|unsigned
name|long
name|TclGetClicks
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|char
modifier|*
name|TclGetExtension
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclGetAndDetachPids
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Channel
name|chan
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclGetDate
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|p
operator|,
name|unsigned
name|long
name|now
operator|,
name|long
name|zone
operator|,
name|unsigned
name|long
operator|*
name|timePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|Tcl_Channel
name|TclGetDefaultStdChannel
name|_ANSI_ARGS_
argument_list|(
operator|(
name|int
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|char
modifier|*
name|TclGetEnv
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclGetFrame
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|CallFrame
operator|*
operator|*
name|framePtrPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclGetOpenMode
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|int
operator|*
name|seekFlagPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|unsigned
name|long
name|TclGetSeconds
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclGetTime
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Time
operator|*
name|time
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclGetTimeZone
name|_ANSI_ARGS_
argument_list|(
operator|(
name|unsigned
name|long
name|time
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|char
modifier|*
name|TclGetUserHome
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
name|Tcl_DString
operator|*
name|bufferPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclGetListIndex
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|int
operator|*
name|indexPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclGetLoadedPackages
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|targetName
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|char
modifier|*
name|TclGetUserHome
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
name|Tcl_DString
operator|*
name|bufferPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclGuessPackageName
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|fileName
operator|,
name|Tcl_DString
operator|*
name|bufPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclHasPipes
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclHasSockets
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclIdlePending
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclInterpInit
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|Proc
modifier|*
name|TclIsProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Command
operator|*
name|cmdPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclLoadFile
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|fileName
operator|,
name|char
operator|*
name|sym1
operator|,
name|char
operator|*
name|sym2
operator|,
name|Tcl_PackageInitProc
operator|*
operator|*
name|proc1Ptr
operator|,
name|Tcl_PackageInitProc
operator|*
operator|*
name|proc2Ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclMakeFileTable
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|noStdio
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclMatchFiles
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|separators
operator|,
name|Tcl_DString
operator|*
name|dirPtr
operator|,
name|char
operator|*
name|pattern
operator|,
name|char
operator|*
name|tail
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclNeedSpace
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|start
operator|,
name|char
operator|*
name|end
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|Tcl_File
name|TclOpenFile
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|fname
operator|,
name|int
name|mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclParseBraces
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|char
operator|*
operator|*
name|termPtr
operator|,
name|ParseValue
operator|*
name|pvPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclParseNestedCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|int
name|flags
operator|,
name|char
operator|*
operator|*
name|termPtr
operator|,
name|ParseValue
operator|*
name|pvPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclParseQuotes
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|int
name|termChar
operator|,
name|int
name|flags
operator|,
name|char
operator|*
operator|*
name|termPtr
operator|,
name|ParseValue
operator|*
name|pvPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclParseWords
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|int
name|flags
operator|,
name|int
name|maxWords
operator|,
name|char
operator|*
operator|*
name|termPtr
operator|,
name|int
operator|*
name|argcPtr
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|ParseValue
operator|*
name|pvPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclPlatformExit
name|_ANSI_ARGS_
argument_list|(
operator|(
name|int
name|status
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclPlatformInit
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|char
modifier|*
name|TclPrecTraceProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|name1
operator|,
name|char
operator|*
name|name2
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclPreventAliasLoop
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Interp
operator|*
name|cmdInterp
operator|,
name|char
operator|*
name|cmdName
operator|,
name|Tcl_CmdProc
operator|*
name|proc
operator|,
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclReadFile
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_File
name|file
operator|,
name|int
name|shouldBlock
operator|,
name|char
operator|*
name|buf
operator|,
name|int
name|toRead
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclSeekFile
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_File
name|file
operator|,
name|int
name|offset
operator|,
name|int
name|whence
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclServiceIdle
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclSetupEnv
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclSockGetPort
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|char
operator|*
name|proto
operator|,
name|int
operator|*
name|portPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclSockMinimumBuffers
name|_ANSI_ARGS_
argument_list|(
operator|(
name|int
name|sock
operator|,
name|int
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclSpawnPipeline
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
operator|*
name|pidPtr
operator|,
name|int
operator|*
name|numPids
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|Tcl_File
name|inputFile
operator|,
name|Tcl_File
name|outputFile
operator|,
name|Tcl_File
name|errorFile
operator|,
name|char
operator|*
name|intIn
operator|,
name|char
operator|*
name|finalOut
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclTestChannelCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclTestChannelEventCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclUpdateReturnInfo
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Interp
operator|*
name|iPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclWaitForFile
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_File
name|file
operator|,
name|int
name|mask
operator|,
name|int
name|timeout
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|char
modifier|*
name|TclWordEnd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|start
operator|,
name|int
name|nested
operator|,
name|int
operator|*
name|semiPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclWriteFile
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_File
name|file
operator|,
name|int
name|shouldBlock
operator|,
name|char
operator|*
name|buf
operator|,
name|int
name|toWrite
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *----------------------------------------------------------------  * Command procedures in the generic core:  *----------------------------------------------------------------  */
end_comment

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_AfterCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_AppendCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ArrayCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_BreakCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_CaseCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_CatchCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_CdCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ClockCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_CloseCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ConcatCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ContinueCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_CpCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_EchoCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_EofCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ErrorCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_EvalCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ExecCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ExitCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ExprCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_FblockedCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_FconfigureCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_FileCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_FileEventCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_FlushCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ForCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ForeachCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_FormatCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_GetsCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_GlobalCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_GlobCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_HistoryCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_IfCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_IncrCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_InfoCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_InterpCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_JoinCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_LappendCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_LindexCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_LinsertCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_LlengthCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ListCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_LoadCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_LrangeCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_LreplaceCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_LsCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_LsearchCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_LsortCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_MacBeepCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_MacSourceCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_MkdirCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_MvCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_OpenCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_PackageCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_PidCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ProcCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_PutsCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_PwdCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ReadCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_RegexpCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_RegsubCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_RenameCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ReturnCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_RmCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_RmdirCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_ScanCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_SeekCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_SetCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_SplitCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_SocketCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_SourceCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_StringCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_SubstCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_SwitchCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_TellCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_TimeCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_TraceCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_UnsetCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_UpdateCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_UplevelCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_UpvarCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_VwaitCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|Tcl_WhileCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclUnsupported0Cmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _TCLINT */
end_comment

end_unit

