begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclCkalloc.c --  *  *    Interface to malloc and free that provides support for debugging problems  *    involving overwritten, double freeing memory and loss of memory.  *  * Copyright (c) 1991-1994 The Regents of the University of California.  * Copyright (c) 1994-1996 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * This code contributed by Karl Lehenbauer and Mark Diekhans  *  *  * SCCS: @(#) tclCkalloc.c 1.17 96/03/14 13:05:56  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|TCL_GENERIC_ONLY
end_ifndef

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * One of the following structures is allocated each time the  * "memory tag" command is invoked, to hold the current tag.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|MemTag
block|{
name|int
name|refCount
decl_stmt|;
comment|/* Number of mem_headers referencing 				 * this tag. */
name|char
name|string
index|[
literal|4
index|]
decl_stmt|;
comment|/* Actual size of string will be as 				 * large as needed for actual tag.  This 				 * must be the last field in the structure. */
block|}
name|MemTag
typedef|;
end_typedef

begin_define
define|#
directive|define
name|TAG_SIZE
parameter_list|(
name|bytesInString
parameter_list|)
value|((unsigned) sizeof(MemTag) + bytesInString - 3)
end_define

begin_decl_stmt
specifier|static
name|MemTag
modifier|*
name|curTagPtr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tag to use in all future mem_headers 				 * (set by "memory tag" command). */
end_comment

begin_comment
comment|/*  * One of the following structures is allocated just before each  * dynamically allocated chunk of memory, both to record information  * about the chunk and to help detect chunk under-runs.  */
end_comment

begin_define
define|#
directive|define
name|LOW_GUARD_SIZE
value|(8 + (32 - (sizeof(long) + sizeof(int)))%8)
end_define

begin_struct
struct|struct
name|mem_header
block|{
name|struct
name|mem_header
modifier|*
name|flink
decl_stmt|;
name|struct
name|mem_header
modifier|*
name|blink
decl_stmt|;
name|MemTag
modifier|*
name|tagPtr
decl_stmt|;
comment|/* Tag from "memory tag" command;  may be 				 * NULL. */
name|char
modifier|*
name|file
decl_stmt|;
name|long
name|length
decl_stmt|;
name|int
name|line
decl_stmt|;
name|unsigned
name|char
name|low_guard
index|[
name|LOW_GUARD_SIZE
index|]
decl_stmt|;
comment|/* Aligns body on 8-byte boundary, plus 				 * provides at least 8 additional guard bytes 				 * to detect underruns. */
name|char
name|body
index|[
literal|1
index|]
decl_stmt|;
comment|/* First byte of client's space.  Actual 				 * size of this field will be larger than 				 * one. */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|mem_header
modifier|*
name|allocHead
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of allocated structures */
end_comment

begin_define
define|#
directive|define
name|GUARD_VALUE
value|0141
end_define

begin_comment
comment|/*  * The following macro determines the amount of guard space *above* each  * chunk of memory.  */
end_comment

begin_define
define|#
directive|define
name|HIGH_GUARD_SIZE
value|8
end_define

begin_comment
comment|/*  * The following macro computes the offset of the "body" field within  * mem_header.  It is used to get back to the header pointer from the  * body pointer that's used by clients.  */
end_comment

begin_define
define|#
directive|define
name|BODY_OFFSET
define|\
value|((unsigned long) (&((struct mem_header *) 0)->body))
end_define

begin_decl_stmt
specifier|static
name|int
name|total_mallocs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_frees
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_bytes_malloced
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maximum_bytes_malloced
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_malloc_packets
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maximum_malloc_packets
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|break_on_malloc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|trace_on_at_malloc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|alloc_tracing
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|init_malloced_bodies
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MEM_VALIDATE
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|validate_memory
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|validate_memory
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Prototypes for procedures defined in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|MemoryCmd
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * dump_memory_info --  *     Display the global memory management statistics.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|dump_memory_info
parameter_list|(
name|outFile
parameter_list|)
name|FILE
modifier|*
name|outFile
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|outFile
argument_list|,
literal|"total mallocs             %10d\n"
argument_list|,
name|total_mallocs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outFile
argument_list|,
literal|"total frees               %10d\n"
argument_list|,
name|total_frees
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outFile
argument_list|,
literal|"current packets allocated %10d\n"
argument_list|,
name|current_malloc_packets
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outFile
argument_list|,
literal|"current bytes allocated   %10d\n"
argument_list|,
name|current_bytes_malloced
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outFile
argument_list|,
literal|"maximum packets allocated %10d\n"
argument_list|,
name|maximum_malloc_packets
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outFile
argument_list|,
literal|"maximum bytes allocated   %10d\n"
argument_list|,
name|maximum_bytes_malloced
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * ValidateMemory --  *     Procedure to validate allocted memory guard zones.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ValidateMemory
parameter_list|(
name|memHeaderP
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|,
name|nukeGuards
parameter_list|)
name|struct
name|mem_header
modifier|*
name|memHeaderP
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
name|nukeGuards
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|hiPtr
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|int
name|guard_failed
init|=
name|FALSE
decl_stmt|;
name|int
name|byte
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|LOW_GUARD_SIZE
condition|;
name|idx
operator|++
control|)
block|{
name|byte
operator|=
operator|*
operator|(
name|memHeaderP
operator|->
name|low_guard
operator|+
name|idx
operator|)
expr_stmt|;
if|if
condition|(
name|byte
operator|!=
name|GUARD_VALUE
condition|)
block|{
name|guard_failed
operator|=
name|TRUE
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|byte
operator|&=
literal|0xff
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"low guard byte %d is 0x%x  \t%c\n"
argument_list|,
name|idx
argument_list|,
name|byte
argument_list|,
operator|(
name|isprint
argument_list|(
name|UCHAR
argument_list|(
name|byte
argument_list|)
argument_list|)
condition|?
name|byte
else|:
literal|' '
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|guard_failed
condition|)
block|{
name|dump_memory_info
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"low guard failed at %lx, %s %d\n"
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|memHeaderP
operator|->
name|body
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* In case name pointer is bad. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld bytes allocated at (%s %d)\n"
argument_list|,
name|memHeaderP
operator|->
name|length
argument_list|,
name|memHeaderP
operator|->
name|file
argument_list|,
name|memHeaderP
operator|->
name|line
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Memory validation failure"
argument_list|)
expr_stmt|;
block|}
name|hiPtr
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|memHeaderP
operator|->
name|body
operator|+
name|memHeaderP
operator|->
name|length
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|HIGH_GUARD_SIZE
condition|;
name|idx
operator|++
control|)
block|{
name|byte
operator|=
operator|*
operator|(
name|hiPtr
operator|+
name|idx
operator|)
expr_stmt|;
if|if
condition|(
name|byte
operator|!=
name|GUARD_VALUE
condition|)
block|{
name|guard_failed
operator|=
name|TRUE
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|byte
operator|&=
literal|0xff
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"hi guard byte %d is 0x%x  \t%c\n"
argument_list|,
name|idx
argument_list|,
name|byte
argument_list|,
operator|(
name|isprint
argument_list|(
name|UCHAR
argument_list|(
name|byte
argument_list|)
argument_list|)
condition|?
name|byte
else|:
literal|' '
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|guard_failed
condition|)
block|{
name|dump_memory_info
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"high guard failed at %lx, %s %d\n"
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|memHeaderP
operator|->
name|body
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* In case name pointer is bad. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld bytes allocated at (%s %d)\n"
argument_list|,
name|memHeaderP
operator|->
name|length
argument_list|,
name|memHeaderP
operator|->
name|file
argument_list|,
name|memHeaderP
operator|->
name|line
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Memory validation failure"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nukeGuards
condition|)
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|memHeaderP
operator|->
name|low_guard
argument_list|,
literal|0
argument_list|,
name|LOW_GUARD_SIZE
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hiPtr
argument_list|,
literal|0
argument_list|,
name|HIGH_GUARD_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ValidateAllMemory --  *     Validates guard regions for all allocated memory.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_ValidateAllMemory
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|struct
name|mem_header
modifier|*
name|memScanP
decl_stmt|;
for|for
control|(
name|memScanP
operator|=
name|allocHead
init|;
name|memScanP
operator|!=
name|NULL
condition|;
name|memScanP
operator|=
name|memScanP
operator|->
name|flink
control|)
name|ValidateMemory
argument_list|(
name|memScanP
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DumpActiveMemory --  *     Displays all allocated memory to stderr.  *  * Results:  *     Return TCL_ERROR if an error accessing the file occures, `errno'   *     will have the file error number left in it.  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_DumpActiveMemory
parameter_list|(
name|fileName
parameter_list|)
name|char
modifier|*
name|fileName
decl_stmt|;
block|{
name|FILE
modifier|*
name|fileP
decl_stmt|;
name|struct
name|mem_header
modifier|*
name|memScanP
decl_stmt|;
name|char
modifier|*
name|address
decl_stmt|;
name|fileP
operator|=
name|fopen
argument_list|(
name|fileName
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileP
operator|==
name|NULL
condition|)
return|return
name|TCL_ERROR
return|;
for|for
control|(
name|memScanP
operator|=
name|allocHead
init|;
name|memScanP
operator|!=
name|NULL
condition|;
name|memScanP
operator|=
name|memScanP
operator|->
name|flink
control|)
block|{
name|address
operator|=
operator|&
name|memScanP
operator|->
name|body
index|[
literal|0
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|fileP
argument_list|,
literal|"%8lx - %8lx  %7ld @ %s %d %s"
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|address
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|address
operator|+
name|memScanP
operator|->
name|length
operator|-
literal|1
argument_list|,
name|memScanP
operator|->
name|length
argument_list|,
name|memScanP
operator|->
name|file
argument_list|,
name|memScanP
operator|->
name|line
argument_list|,
operator|(
name|memScanP
operator|->
name|tagPtr
operator|==
name|NULL
operator|)
condition|?
literal|""
else|:
name|memScanP
operator|->
name|tagPtr
operator|->
name|string
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|fileP
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fileP
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DbCkalloc - debugging ckalloc  *  *        Allocate the requested amount of space plus some extra for  *        guard bands at both ends of the request, plus a size, panicing   *        if there isn't enough space, then write in the guard bands  *        and return the address of the space in the middle that the  *        user asked for.  *  *        The second and third arguments are file and line, these contain  *        the filename and line number corresponding to the caller.  *        These are sent by the ckalloc macro; it uses the preprocessor  *        autodefines __FILE__ and __LINE__.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_DbCkalloc
parameter_list|(
name|size
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|unsigned
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|struct
name|mem_header
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|validate_memory
condition|)
name|Tcl_ValidateAllMemory
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
expr|struct
name|mem_header
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mem_header
argument_list|)
operator|+
name|HIGH_GUARD_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|dump_memory_info
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"unable to alloc %d bytes, %s line %d"
argument_list|,
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
comment|/*      * Fill in guard zones and size.  Also initialize the contents of      * the block with bogus bytes to detect uses of initialized data.      * Link into allocated list.      */
if|if
condition|(
name|init_malloced_bodies
condition|)
block|{
name|memset
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|result
argument_list|,
name|GUARD_VALUE
argument_list|,
name|size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mem_header
argument_list|)
operator|+
name|HIGH_GUARD_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|result
operator|->
name|low_guard
argument_list|,
name|GUARD_VALUE
argument_list|,
name|LOW_GUARD_SIZE
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|result
operator|->
name|body
operator|+
name|size
argument_list|,
name|GUARD_VALUE
argument_list|,
name|HIGH_GUARD_SIZE
argument_list|)
expr_stmt|;
block|}
name|result
operator|->
name|length
operator|=
name|size
expr_stmt|;
name|result
operator|->
name|tagPtr
operator|=
name|curTagPtr
expr_stmt|;
if|if
condition|(
name|curTagPtr
operator|!=
name|NULL
condition|)
block|{
name|curTagPtr
operator|->
name|refCount
operator|++
expr_stmt|;
block|}
name|result
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|result
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|result
operator|->
name|flink
operator|=
name|allocHead
expr_stmt|;
name|result
operator|->
name|blink
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|allocHead
operator|!=
name|NULL
condition|)
name|allocHead
operator|->
name|blink
operator|=
name|result
expr_stmt|;
name|allocHead
operator|=
name|result
expr_stmt|;
name|total_mallocs
operator|++
expr_stmt|;
if|if
condition|(
name|trace_on_at_malloc
operator|&&
operator|(
name|total_mallocs
operator|>=
name|trace_on_at_malloc
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"reached malloc trace enable point (%d)\n"
argument_list|,
name|total_mallocs
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|alloc_tracing
operator|=
name|TRUE
expr_stmt|;
name|trace_on_at_malloc
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|alloc_tracing
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ckalloc %lx %d %s %d\n"
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|result
operator|->
name|body
argument_list|,
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|break_on_malloc
operator|&&
operator|(
name|total_mallocs
operator|>=
name|break_on_malloc
operator|)
condition|)
block|{
name|break_on_malloc
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"reached malloc break limit (%d)\n"
argument_list|,
name|total_mallocs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"program will now enter C debugger\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|current_malloc_packets
operator|++
expr_stmt|;
if|if
condition|(
name|current_malloc_packets
operator|>
name|maximum_malloc_packets
condition|)
name|maximum_malloc_packets
operator|=
name|current_malloc_packets
expr_stmt|;
name|current_bytes_malloced
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|current_bytes_malloced
operator|>
name|maximum_bytes_malloced
condition|)
name|maximum_bytes_malloced
operator|=
name|current_bytes_malloced
expr_stmt|;
return|return
name|result
operator|->
name|body
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DbCkfree - debugging ckfree  *  *        Verify that the low and high guards are intact, and if so  *        then free the buffer else panic.  *  *        The guards are erased after being checked to catch duplicate  *        frees.  *  *        The second and third arguments are file and line, these contain  *        the filename and line number corresponding to the caller.  *        These are sent by the ckfree macro; it uses the preprocessor  *        autodefines __FILE__ and __LINE__.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_DbCkfree
parameter_list|(
name|ptr
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
comment|/*      * The following cast is *very* tricky.  Must convert the pointer      * to an integer before doing arithmetic on it, because otherwise      * the arithmetic will be done differently (and incorrectly) on      * word-addressed machines such as Crays (will subtract only bytes,      * even though BODY_OFFSET is in words on these machines).      */
name|struct
name|mem_header
modifier|*
name|memp
init|=
operator|(
expr|struct
name|mem_header
operator|*
operator|)
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|ptr
operator|)
operator|-
name|BODY_OFFSET
operator|)
decl_stmt|;
if|if
condition|(
name|alloc_tracing
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ckfree %lx %ld %s %d\n"
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|memp
operator|->
name|body
argument_list|,
name|memp
operator|->
name|length
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|validate_memory
condition|)
name|Tcl_ValidateAllMemory
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|ValidateMemory
argument_list|(
name|memp
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_malloced_bodies
condition|)
block|{
name|memset
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|ptr
argument_list|,
name|GUARD_VALUE
argument_list|,
operator|(
name|size_t
operator|)
name|memp
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
name|total_frees
operator|++
expr_stmt|;
name|current_malloc_packets
operator|--
expr_stmt|;
name|current_bytes_malloced
operator|-=
name|memp
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|memp
operator|->
name|tagPtr
operator|!=
name|NULL
condition|)
block|{
name|memp
operator|->
name|tagPtr
operator|->
name|refCount
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|memp
operator|->
name|tagPtr
operator|->
name|refCount
operator|==
literal|0
operator|)
operator|&&
operator|(
name|curTagPtr
operator|!=
name|memp
operator|->
name|tagPtr
operator|)
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|memp
operator|->
name|tagPtr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Delink from allocated list      */
if|if
condition|(
name|memp
operator|->
name|flink
operator|!=
name|NULL
condition|)
name|memp
operator|->
name|flink
operator|->
name|blink
operator|=
name|memp
operator|->
name|blink
expr_stmt|;
if|if
condition|(
name|memp
operator|->
name|blink
operator|!=
name|NULL
condition|)
name|memp
operator|->
name|blink
operator|->
name|flink
operator|=
name|memp
operator|->
name|flink
expr_stmt|;
if|if
condition|(
name|allocHead
operator|==
name|memp
condition|)
name|allocHead
operator|=
name|memp
operator|->
name|flink
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|memp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *--------------------------------------------------------------------  *  * Tcl_DbCkrealloc - debugging ckrealloc  *  *	Reallocate a chunk of memory by allocating a new one of the  *	right size, copying the old data to the new location, and then  *	freeing the old memory space, using all the memory checking  *	features of this package.  *  *--------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_DbCkrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|char
modifier|*
name|new
decl_stmt|;
name|unsigned
name|int
name|copySize
decl_stmt|;
comment|/*      * See comment from Tcl_DbCkfree before you change the following      * line.      */
name|struct
name|mem_header
modifier|*
name|memp
init|=
operator|(
expr|struct
name|mem_header
operator|*
operator|)
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|ptr
operator|)
operator|-
name|BODY_OFFSET
operator|)
decl_stmt|;
name|copySize
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|copySize
operator|>
name|memp
operator|->
name|length
condition|)
block|{
name|copySize
operator|=
name|memp
operator|->
name|length
expr_stmt|;
block|}
name|new
operator|=
name|Tcl_DbCkalloc
argument_list|(
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|new
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|ptr
argument_list|,
operator|(
name|size_t
operator|)
name|copySize
argument_list|)
expr_stmt|;
name|Tcl_DbCkfree
argument_list|(
name|ptr
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * MemoryCmd --  *     Implements the TCL memory command:  *       memory info  *       memory display  *       break_on_malloc count  *       trace_on_at_malloc count  *       trace on|off  *       validate on|off  *  * Results:  *     Standard TCL results.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|MemoryCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|fileName
decl_stmt|;
name|Tcl_DString
name|buffer
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" option [args..]\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"active"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" active file\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|fileName
operator|=
name|Tcl_TranslateFileName
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileName
operator|==
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|result
operator|=
name|Tcl_DumpActiveMemory
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"error accessing "
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"break_on_malloc"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
goto|goto
name|argError
goto|;
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|break_on_malloc
argument_list|)
operator|!=
name|TCL_OK
condition|)
return|return
name|TCL_ERROR
return|;
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"info"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dump_memory_info
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"init"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
goto|goto
name|bad_suboption
goto|;
name|init_malloced_bodies
operator|=
operator|(
name|strcmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"tag"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" tag string\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|curTagPtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|curTagPtr
operator|->
name|refCount
operator|==
literal|0
operator|)
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|curTagPtr
argument_list|)
expr_stmt|;
block|}
name|curTagPtr
operator|=
operator|(
name|MemTag
operator|*
operator|)
name|malloc
argument_list|(
name|TAG_SIZE
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|curTagPtr
operator|->
name|refCount
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|curTagPtr
operator|->
name|string
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"trace"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
goto|goto
name|bad_suboption
goto|;
name|alloc_tracing
operator|=
operator|(
name|strcmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"trace_on_at_malloc"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
goto|goto
name|argError
goto|;
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|trace_on_at_malloc
argument_list|)
operator|!=
name|TCL_OK
condition|)
return|return
name|TCL_ERROR
return|;
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"validate"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
goto|goto
name|bad_suboption
goto|;
name|validate_memory
operator|=
operator|(
name|strcmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\": should be active, break_on_malloc, info, init, "
argument_list|,
literal|"tag, trace, trace_on_at_malloc, or validate"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
name|argError
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" "
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|" count\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
name|bad_suboption
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" "
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|" on|off\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_InitMemory --  *     Initialize the memory command.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_InitMemory
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
block|{
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"memory"
argument_list|,
name|MemoryCmd
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|,
operator|(
name|Tcl_CmdDeleteProc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_Ckalloc --  *     Interface to malloc when TCL_MEM_DEBUG is disabled.  It does check  *     that memory was actually allocated.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|VOID
modifier|*
name|Tcl_Ckalloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"unable to alloc %d bytes"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|char
modifier|*
name|Tcl_DbCkalloc
parameter_list|(
name|size
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|unsigned
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|char
modifier|*
name|result
decl_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"unable to alloc %d bytes, %s line %d"
argument_list|,
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|Tcl_DbCkrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|char
modifier|*
name|result
decl_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"unable to realloc %d bytes, %s line %d"
argument_list|,
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TckCkfree --  *     Interface to free when TCL_MEM_DEBUG is disabled.  Done here rather  *     in the macro to keep some modules from being compiled with   *     TCL_MEM_DEBUG enabled and some with it disabled.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_Ckfree
parameter_list|(
name|ptr
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
block|{
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|Tcl_DbCkfree
parameter_list|(
name|ptr
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_InitMemory --  *     Dummy initialization for memory command, which is only available   *     if TCL_MEM_DEBUG is on.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|Tcl_InitMemory
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
block|{ }
end_function

begin_undef
undef|#
directive|undef
name|Tcl_DumpActiveMemory
end_undef

begin_undef
undef|#
directive|undef
name|Tcl_ValidateAllMemory
end_undef

begin_decl_stmt
specifier|extern
name|int
name|Tcl_DumpActiveMemory
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|fileName
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|Tcl_ValidateAllMemory
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|int
name|line
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|Tcl_DumpActiveMemory
parameter_list|(
name|fileName
parameter_list|)
name|char
modifier|*
name|fileName
decl_stmt|;
block|{
return|return
name|TCL_OK
return|;
block|}
end_function

begin_function
name|void
name|Tcl_ValidateAllMemory
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

