begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * tclCompile.h --  *  * Copyright (c) 1996-1997 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclCompile.h 1.37 97/08/07 19:11:50  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_TCLCOMPILATION
end_ifndef

begin_define
define|#
directive|define
name|_TCLCOMPILATION
value|1
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|_TCLINT
end_ifndef

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _TCLINT */
end_comment

begin_comment
comment|/*  *------------------------------------------------------------------------  * Variables related to compilation. These are used in tclCompile.c,  * tclExecute.c, tclBasic.c, and their clients.  *------------------------------------------------------------------------  */
end_comment

begin_comment
comment|/*  * Variable that denotes the command name Tcl object type. Objects of this  * type cache the Command pointer that results from looking up command names  * in the command hashtable.  */
end_comment

begin_decl_stmt
specifier|extern
name|Tcl_ObjType
name|tclCmdNameType
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Variable that controls whether compilation tracing is enabled and, if so,  * what level of tracing is desired:  *    0: no compilation tracing  *    1: summarize compilation of top level cmds and proc bodies  *    2: display all instructions of each ByteCode compiled  * This variable is linked to the Tcl variable "tcl_traceCompile".  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|tclTraceCompile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Variable that controls whether execution tracing is enabled and, if so,  * what level of tracing is desired:  *    0: no execution tracing  *    1: trace invocations of Tcl procs only  *    2: trace invocations of all (not compiled away) commands  *    3: display each instruction executed  * This variable is linked to the Tcl variable "tcl_traceExec".  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|tclTraceExec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The number of bytecode compilations and various other compilation-related  * statistics. The tclByteCodeCount and tclSourceCount arrays are used to  * hold the count of ByteCodes and sources whose sizes fall into various  * binary decades; e.g., tclByteCodeCount[5] is a count of the ByteCodes  * with size larger than 2**4 and less than or equal to 2**5.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_COMPILE_STATS
end_ifdef

begin_decl_stmt
specifier|extern
name|long
name|tclNumCompilations
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|double
name|tclTotalSourceBytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|double
name|tclTotalCodeBytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|double
name|tclTotalInstBytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|double
name|tclTotalObjBytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|double
name|tclTotalExceptBytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|double
name|tclTotalAuxBytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|double
name|tclTotalCmdMapBytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|double
name|tclCurrentSourceBytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|double
name|tclCurrentCodeBytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tclSourceCount
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tclByteCodeCount
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_COMPILE_STATS */
end_comment

begin_comment
comment|/*  *------------------------------------------------------------------------  * Data structures related to compilation.  *------------------------------------------------------------------------  */
end_comment

begin_comment
comment|/*  * The structure used to implement Tcl "exceptions" (exceptional returns):  * for example, those generated in loops by the break and continue commands,  * and those generated by scripts and caught by the catch command. This  * ExceptionRange structure describes a range of code (e.g., a loop body),  * the kind of exceptions (e.g., a break or continue) that might occur, and  * the PC offsets to jump to if a matching exception does occur. Exception  * ranges can nest so this structure includes a nesting level that is used  * at runtime to find the closest exception range surrounding a PC. For  * example, when a break command is executed, the ExceptionRange structure  * for the most deeply nested loop, if any, is found and used. These  * structures are also generated for the "next" subcommands of for loops  * since a break there terminates the for command. This means a for command  * actually generates two LoopInfo structures.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|LOOP_EXCEPTION_RANGE
block|,
comment|/* Code range is part of a loop command. 				 * break and continue "exceptions" cause 				 * jumps to appropriate PC offsets. */
name|CATCH_EXCEPTION_RANGE
comment|/* Code range is controlled by a catch 				 * command. Errors in the range cause a 				 * jump to a particular PC offset. */
block|}
name|ExceptionRangeType
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|ExceptionRange
block|{
name|ExceptionRangeType
name|type
decl_stmt|;
comment|/* The kind of ExceptionRange. */
name|int
name|nestingLevel
decl_stmt|;
comment|/* Static depth of the exception range. 				 * Used to find the most deeply-nested 				 * range surrounding a PC at runtime. */
name|int
name|codeOffset
decl_stmt|;
comment|/* Offset of the first instruction byte of 				 * the code range. */
name|int
name|numCodeBytes
decl_stmt|;
comment|/* Number of bytes in the code range. */
name|int
name|breakOffset
decl_stmt|;
comment|/* If a LOOP_EXCEPTION_RANGE, the target 				 * PC offset for a break command in the 				 * range. */
name|int
name|continueOffset
decl_stmt|;
comment|/* If a LOOP_EXCEPTION_RANGE and not -1, 				 * the target PC offset for a continue 				 * command in the code range. Otherwise, 				 * ignore this range when processing a 				 * continue command. */
name|int
name|catchOffset
decl_stmt|;
comment|/* If a CATCH_EXCEPTION_RANGE, the target PC 				 * offset for an "exception" in range. */
block|}
name|ExceptionRange
typedef|;
end_typedef

begin_comment
comment|/*  * Structure used to map between instruction pc and source locations. It  * defines for each compiled Tcl command its code's starting offset and   * its source's starting offset and length. Note that the code offset  * increases monotonically: that is, the table is sorted in code offset  * order. The source offset is not monotonic.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|CmdLocation
block|{
name|int
name|codeOffset
decl_stmt|;
comment|/* Offset of first byte of command code. */
name|int
name|numCodeBytes
decl_stmt|;
comment|/* Number of bytes for command's code. */
name|int
name|srcOffset
decl_stmt|;
comment|/* Offset of first char of the command. */
name|int
name|numSrcChars
decl_stmt|;
comment|/* Number of command source chars. */
block|}
name|CmdLocation
typedef|;
end_typedef

begin_comment
comment|/*  * CompileProcs need the ability to record information during compilation  * that can be used by bytecode instructions during execution. The AuxData  * structure provides this "auxiliary data" mechanism. An arbitrary number  * of these structures can be stored in the ByteCode record (during  * compilation they are stored in a CompileEnv structure). Each AuxData  * record holds one word of client-specified data (often a pointer) and is  * given an index that instructions can later use to look up the structure  * and its data.  *  * The following definitions declare the types of procedures that are called  * to duplicate or free this auxiliary data when the containing ByteCode  * objects are duplicated and freed. Pointers to these procedures are kept  * in the AuxData structure.  */
end_comment

begin_typedef
typedef|typedef
name|ClientData
argument_list|(
argument|AuxDataDupProc
argument_list|)
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|void
argument_list|(
argument|AuxDataFreeProc
argument_list|)
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_comment
comment|/*  * The definition of the AuxData structure that holds information created  * during compilation by CompileProcs and used by instructions during  * execution.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|AuxData
block|{
name|ClientData
name|clientData
decl_stmt|;
comment|/* The compilation data itself. */
name|AuxDataDupProc
modifier|*
name|dupProc
decl_stmt|;
comment|/* Callback procedure to invoke when the 				 * aux data is duplicated (e.g., when the 				 * ByteCode structure containing the aux 				 * data is duplicated). NULL means just 				 * copy the source clientData bits; no 				 * proc need be called. */
name|AuxDataFreeProc
modifier|*
name|freeProc
decl_stmt|;
comment|/* Callback procedure to invoke when the 				 * aux data is freed. NULL means no 				 * proc need be called. */
block|}
name|AuxData
typedef|;
end_typedef

begin_comment
comment|/*  * Structure defining the compilation environment. After compilation, fields  * describing bytecode instructions are copied out into the more compact  * ByteCode structure defined below.  */
end_comment

begin_define
define|#
directive|define
name|COMPILEENV_INIT_CODE_BYTES
value|250
end_define

begin_define
define|#
directive|define
name|COMPILEENV_INIT_NUM_OBJECTS
value|40
end_define

begin_define
define|#
directive|define
name|COMPILEENV_INIT_EXCEPT_RANGES
value|5
end_define

begin_define
define|#
directive|define
name|COMPILEENV_INIT_CMD_MAP_SIZE
value|40
end_define

begin_define
define|#
directive|define
name|COMPILEENV_INIT_AUX_DATA_SIZE
value|5
end_define

begin_typedef
typedef|typedef
struct|struct
name|CompileEnv
block|{
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Interpreter containing the code being 				 * compiled. Commands and their compile 				 * procs are specific to an interpreter so 				 * the code emitted will depend on the 				 * interpreter. */
name|char
modifier|*
name|source
decl_stmt|;
comment|/* The source string being compiled by 				 * SetByteCodeFromAny. This pointer is not 				 * owned by the CompileEnv and must not be 				 * freed or changed by it. */
name|Proc
modifier|*
name|procPtr
decl_stmt|;
comment|/* If a procedure is being compiled, a 				 * pointer to its Proc structure; otherwise 				 * NULL. Used to compile local variables. 				 * Set from information provided by 				 * ObjInterpProc in tclProc.c. */
name|int
name|numCommands
decl_stmt|;
comment|/* Number of commands compiled. */
name|int
name|excRangeDepth
decl_stmt|;
comment|/* Current exception range nesting level; 				 * -1 if not in any range currently. */
name|int
name|maxExcRangeDepth
decl_stmt|;
comment|/* Max nesting level of exception ranges; 				 * -1 if no ranges have been compiled. */
name|int
name|maxStackDepth
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute the code. Set by compilation 				 * procedures before returning. */
name|Tcl_HashTable
name|objTable
decl_stmt|;
comment|/* Contains all Tcl objects referenced by 				 * the compiled code. Indexed by the string 				 * representations of the objects. Used to 				 * avoid creating duplicate objects. */
name|int
name|pushSimpleWords
decl_stmt|;
comment|/* Set 1 by callers of compilation routines 				 * if they should emit instructions to push 				 * "simple" command words (those that are 				 * just a sequence of characters). If 0, the 				 * callers are responsible for compiling 				 * simple words. */
name|int
name|wordIsSimple
decl_stmt|;
comment|/* Set 1 by compilation procedures before 				 * returning if the previous command word 				 * was just a sequence of characters, 				 * otherwise 0. Used to help determine the 				 * command being compiled. */
name|int
name|numSimpleWordChars
decl_stmt|;
comment|/* If wordIsSimple is 1 then the number of 				 * characters in the simple word, else 0. */
name|int
name|exprIsJustVarRef
decl_stmt|;
comment|/* Set 1 if the expression last compiled by 				 * TclCompileExpr consisted of just a 				 * variable reference as in the expression 				 * of "if $b then...". Otherwise 0. Used 				 * to implement expr's 2 level substitution 				 * semantics properly. */
name|int
name|exprIsComparison
decl_stmt|;
comment|/* Set 1 if the top-level operator in the 				 * expression last compiled is a comparison. 				 * Otherwise 0. If 1, since the operands 				 * might be strings, the expr is compiled 				 * out-of-line to implement expr's 2 level 				 * substitution semantics properly. */
name|int
name|termOffset
decl_stmt|;
comment|/* Offset of character just after the last 				 * one compiled. Set by compilation 				 * procedures before returning. */
name|unsigned
name|char
modifier|*
name|codeStart
decl_stmt|;
comment|/* Points to the first byte of the code. */
name|unsigned
name|char
modifier|*
name|codeNext
decl_stmt|;
comment|/* Points to next code array byte to use. */
name|unsigned
name|char
modifier|*
name|codeEnd
decl_stmt|;
comment|/* Points just after the last allocated 				 * code array byte. */
name|int
name|mallocedCodeArray
decl_stmt|;
comment|/* Set 1 if code array was expanded  				 * and codeStart points into the heap.*/
name|Tcl_Obj
modifier|*
modifier|*
name|objArrayPtr
decl_stmt|;
comment|/* Points to start of object array. */
name|int
name|objArrayNext
decl_stmt|;
comment|/* Index of next free object array entry. */
name|int
name|objArrayEnd
decl_stmt|;
comment|/* Index just after last obj array entry. */
name|int
name|mallocedObjArray
decl_stmt|;
comment|/* 1 if object array was expanded and                                  * objArray points into the heap, else 0. */
name|ExceptionRange
modifier|*
name|excRangeArrayPtr
decl_stmt|;
comment|/* Points to start of the ExceptionRange 				 * array. */
name|int
name|excRangeArrayNext
decl_stmt|;
comment|/* Next free ExceptionRange array index. 				 * excRangeArrayNext is the number of ranges 				 * and (excRangeArrayNext-1) is the index of 				 * the current range's array entry. */
name|int
name|excRangeArrayEnd
decl_stmt|;
comment|/* Index after the last ExceptionRange 				 * array entry. */
name|int
name|mallocedExcRangeArray
decl_stmt|;
comment|/* 1 if ExceptionRange array was expanded 				 * and excRangeArrayPtr points in heap, 				 * else 0. */
name|CmdLocation
modifier|*
name|cmdMapPtr
decl_stmt|;
comment|/* Points to start of CmdLocation array. 				 * numCommands is the index of the next 				 * entry to use; (numCommands-1) is the 				 * entry index for the last command. */
name|int
name|cmdMapEnd
decl_stmt|;
comment|/* Index after last CmdLocation entry. */
name|int
name|mallocedCmdMap
decl_stmt|;
comment|/* 1 if command map array was expanded and 				 * cmdMapPtr points in the heap, else 0. */
name|AuxData
modifier|*
name|auxDataArrayPtr
decl_stmt|;
comment|/* Points to auxiliary data array start. */
name|int
name|auxDataArrayNext
decl_stmt|;
comment|/* Next free compile aux data array index. 				 * auxDataArrayNext is the number of aux 				 * data items and (auxDataArrayNext-1) is 				 * index of current aux data array entry. */
name|int
name|auxDataArrayEnd
decl_stmt|;
comment|/* Index after last aux data array entry. */
name|int
name|mallocedAuxDataArray
decl_stmt|;
comment|/* 1 if aux data array was expanded and 				 * auxDataArrayPtr points in heap else 0. */
name|unsigned
name|char
name|staticCodeSpace
index|[
name|COMPILEENV_INIT_CODE_BYTES
index|]
decl_stmt|;
comment|/* Initial storage for code. */
name|Tcl_Obj
modifier|*
name|staticObjArraySpace
index|[
name|COMPILEENV_INIT_NUM_OBJECTS
index|]
decl_stmt|;
comment|/* Initial storage for object array. */
name|ExceptionRange
name|staticExcRangeArraySpace
index|[
name|COMPILEENV_INIT_EXCEPT_RANGES
index|]
decl_stmt|;
comment|/* Initial ExceptionRange array storage. */
name|CmdLocation
name|staticCmdMapSpace
index|[
name|COMPILEENV_INIT_CMD_MAP_SIZE
index|]
decl_stmt|;
comment|/* Initial storage for cmd location map. */
name|AuxData
name|staticAuxDataArraySpace
index|[
name|COMPILEENV_INIT_AUX_DATA_SIZE
index|]
decl_stmt|;
comment|/* Initial storage for aux data array. */
block|}
name|CompileEnv
typedef|;
end_typedef

begin_comment
comment|/*  * The structure defining the bytecode instructions resulting from compiling  * a Tcl script. Note that this structure is variable length: a single heap  * object is allocated to hold the ByteCode structure immediately followed  * by the code bytes, the object array, the ExceptionRange array, the  * CmdLocation map, and the compilation AuxData array.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ByteCode
block|{
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Interpreter containing the code being 				 * compiled. Commands and their compile 				 * procs are specific to an interpreter so 				 * the code emitted will depend on the 				 * interpreter. */
name|int
name|compileEpoch
decl_stmt|;
comment|/* Value of iPtr->compileEpoch when this 				 * ByteCode was compiled. Used to invalidate 				 * code when, e.g., commands with compile 				 * procs are redefined. */
name|int
name|refCount
decl_stmt|;
comment|/* Reference count: set 1 when created 				 * plus 1 for each execution of the code 				 * currently active. This structure can be 				 * freed when refCount becomes zero. */
name|char
modifier|*
name|source
decl_stmt|;
comment|/* The source string from which this 				 * ByteCode was compiled. Note that this 				 * pointer is not owned by the ByteCode and 				 * must not be freed or modified by it. */
name|Proc
modifier|*
name|procPtr
decl_stmt|;
comment|/* If the ByteCode was compiled from a 				 * procedure body, this is a pointer to its 				 * Proc structure; otherwise NULL. This 				 * pointer is also not owned by the ByteCode 				 * and must not be freed by it. Used for 				 * debugging. */
name|size_t
name|totalSize
decl_stmt|;
comment|/* Total number of bytes required for this 				 * ByteCode structure including the storage 				 * for Tcl objects in its object array. */
name|int
name|numCommands
decl_stmt|;
comment|/* Number of commands compiled. */
name|int
name|numSrcChars
decl_stmt|;
comment|/* Number of source chars compiled. */
name|int
name|numCodeBytes
decl_stmt|;
comment|/* Number of code bytes. */
name|int
name|numObjects
decl_stmt|;
comment|/* Number of Tcl objects in object array. */
name|int
name|numExcRanges
decl_stmt|;
comment|/* Number of ExceptionRange array elems. */
name|int
name|numAuxDataItems
decl_stmt|;
comment|/* Number of AuxData items. */
name|int
name|numCmdLocBytes
decl_stmt|;
comment|/* Number of bytes needed for encoded 				 * command location information. */
name|int
name|maxExcRangeDepth
decl_stmt|;
comment|/* Maximum nesting level of ExceptionRanges; 				 * -1 if no ranges were compiled. */
name|int
name|maxStackDepth
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute the code. */
name|unsigned
name|char
modifier|*
name|codeStart
decl_stmt|;
comment|/* Points to the first byte of the code. 				 * This is just after the final ByteCode 				 * member cmdMapPtr. */
name|Tcl_Obj
modifier|*
modifier|*
name|objArrayPtr
decl_stmt|;
comment|/* Points to the start of the object array. 				 * This is just after the last code byte. */
name|ExceptionRange
modifier|*
name|excRangeArrayPtr
decl_stmt|;
comment|/* Points to the start of the ExceptionRange 				 * array. This is just after the last 				 * object in the object array. */
name|AuxData
modifier|*
name|auxDataArrayPtr
decl_stmt|;
comment|/* Points to the start of the auxiliary data 				 * array. This is just after the last entry 				 * in the ExceptionRange array. */
name|unsigned
name|char
modifier|*
name|codeDeltaStart
decl_stmt|;
comment|/* Points to the first of a sequence of 				 * bytes that encode the change in the 				 * starting offset of each command's code. 				 * If -127<=delta<=127, it is encoded as 1 				 * byte, otherwise 0xFF (128) appears and 				 * the delta is encoded by the next 4 bytes. 				 * Code deltas are always positive. This 				 * sequence is just after the last entry in 				 * the AuxData array. */
name|unsigned
name|char
modifier|*
name|codeLengthStart
decl_stmt|;
comment|/* Points to the first of a sequence of 				 * bytes that encode the length of each 				 * command's code. The encoding is the same 				 * as for code deltas. Code lengths are 				 * always positive. This sequence is just 				 * after the last entry in the code delta 				 * sequence. */
name|unsigned
name|char
modifier|*
name|srcDeltaStart
decl_stmt|;
comment|/* Points to the first of a sequence of 				 * bytes that encode the change in the 				 * starting offset of each command's source. 				 * The encoding is the same as for code 				 * deltas. Source deltas can be negative. 				 * This sequence is just after the last byte 				 * in the code length sequence. */
name|unsigned
name|char
modifier|*
name|srcLengthStart
decl_stmt|;
comment|/* Points to the first of a sequence of 				 * bytes that encode the length of each 				 * command's source. The encoding is the 				 * same as for code deltas. Source lengths 				 * are always positive. This sequence is 				 * just after the last byte in the source 				 * delta sequence. */
block|}
name|ByteCode
typedef|;
end_typedef

begin_comment
comment|/*  * Opcodes for the Tcl bytecode instructions. These opcodes must correspond  * to the entries in the table of instruction descriptions in tclCompile.c.  * Also, the order and number of the expression opcodes (e.g., INST_LOR)  * must match the entries in the array operatorStrings in tclExecute.c.  */
end_comment

begin_comment
comment|/* Opcodes 0 to 9 */
end_comment

begin_define
define|#
directive|define
name|INST_DONE
value|0
end_define

begin_define
define|#
directive|define
name|INST_PUSH1
value|(INST_DONE + 1)
end_define

begin_define
define|#
directive|define
name|INST_PUSH4
value|(INST_DONE + 2)
end_define

begin_define
define|#
directive|define
name|INST_POP
value|(INST_DONE + 3)
end_define

begin_define
define|#
directive|define
name|INST_DUP
value|(INST_DONE + 4)
end_define

begin_define
define|#
directive|define
name|INST_CONCAT1
value|(INST_DONE + 5)
end_define

begin_define
define|#
directive|define
name|INST_INVOKE_STK1
value|(INST_DONE + 6)
end_define

begin_define
define|#
directive|define
name|INST_INVOKE_STK4
value|(INST_DONE + 7)
end_define

begin_define
define|#
directive|define
name|INST_EVAL_STK
value|(INST_DONE + 8)
end_define

begin_define
define|#
directive|define
name|INST_EXPR_STK
value|(INST_DONE + 9)
end_define

begin_comment
comment|/* Opcodes 10 to 23 */
end_comment

begin_define
define|#
directive|define
name|INST_LOAD_SCALAR1
value|(INST_EXPR_STK + 1)
end_define

begin_define
define|#
directive|define
name|INST_LOAD_SCALAR4
value|(INST_LOAD_SCALAR1 + 1)
end_define

begin_define
define|#
directive|define
name|INST_LOAD_SCALAR_STK
value|(INST_LOAD_SCALAR1 + 2)
end_define

begin_define
define|#
directive|define
name|INST_LOAD_ARRAY1
value|(INST_LOAD_SCALAR1 + 3)
end_define

begin_define
define|#
directive|define
name|INST_LOAD_ARRAY4
value|(INST_LOAD_SCALAR1 + 4)
end_define

begin_define
define|#
directive|define
name|INST_LOAD_ARRAY_STK
value|(INST_LOAD_SCALAR1 + 5)
end_define

begin_define
define|#
directive|define
name|INST_LOAD_STK
value|(INST_LOAD_SCALAR1 + 6)
end_define

begin_define
define|#
directive|define
name|INST_STORE_SCALAR1
value|(INST_LOAD_SCALAR1 + 7)
end_define

begin_define
define|#
directive|define
name|INST_STORE_SCALAR4
value|(INST_LOAD_SCALAR1 + 8)
end_define

begin_define
define|#
directive|define
name|INST_STORE_SCALAR_STK
value|(INST_LOAD_SCALAR1 + 9)
end_define

begin_define
define|#
directive|define
name|INST_STORE_ARRAY1
value|(INST_LOAD_SCALAR1 + 10)
end_define

begin_define
define|#
directive|define
name|INST_STORE_ARRAY4
value|(INST_LOAD_SCALAR1 + 11)
end_define

begin_define
define|#
directive|define
name|INST_STORE_ARRAY_STK
value|(INST_LOAD_SCALAR1 + 12)
end_define

begin_define
define|#
directive|define
name|INST_STORE_STK
value|(INST_LOAD_SCALAR1 + 13)
end_define

begin_comment
comment|/* Opcodes 24 to 33 */
end_comment

begin_define
define|#
directive|define
name|INST_INCR_SCALAR1
value|(INST_STORE_STK + 1)
end_define

begin_define
define|#
directive|define
name|INST_INCR_SCALAR_STK
value|(INST_INCR_SCALAR1 + 1)
end_define

begin_define
define|#
directive|define
name|INST_INCR_ARRAY1
value|(INST_INCR_SCALAR1 + 2)
end_define

begin_define
define|#
directive|define
name|INST_INCR_ARRAY_STK
value|(INST_INCR_SCALAR1 + 3)
end_define

begin_define
define|#
directive|define
name|INST_INCR_STK
value|(INST_INCR_SCALAR1 + 4)
end_define

begin_define
define|#
directive|define
name|INST_INCR_SCALAR1_IMM
value|(INST_INCR_SCALAR1 + 5)
end_define

begin_define
define|#
directive|define
name|INST_INCR_SCALAR_STK_IMM
value|(INST_INCR_SCALAR1 + 6)
end_define

begin_define
define|#
directive|define
name|INST_INCR_ARRAY1_IMM
value|(INST_INCR_SCALAR1 + 7)
end_define

begin_define
define|#
directive|define
name|INST_INCR_ARRAY_STK_IMM
value|(INST_INCR_SCALAR1 + 8)
end_define

begin_define
define|#
directive|define
name|INST_INCR_STK_IMM
value|(INST_INCR_SCALAR1 + 9)
end_define

begin_comment
comment|/* Opcodes 34 to 39 */
end_comment

begin_define
define|#
directive|define
name|INST_JUMP1
value|(INST_INCR_STK_IMM + 1)
end_define

begin_define
define|#
directive|define
name|INST_JUMP4
value|(INST_JUMP1 + 1)
end_define

begin_define
define|#
directive|define
name|INST_JUMP_TRUE1
value|(INST_JUMP1 + 2)
end_define

begin_define
define|#
directive|define
name|INST_JUMP_TRUE4
value|(INST_JUMP1 + 3)
end_define

begin_define
define|#
directive|define
name|INST_JUMP_FALSE1
value|(INST_JUMP1 + 4)
end_define

begin_define
define|#
directive|define
name|INST_JUMP_FALSE4
value|(INST_JUMP1 + 5)
end_define

begin_comment
comment|/* Opcodes 40 to 64 */
end_comment

begin_define
define|#
directive|define
name|INST_LOR
value|(INST_JUMP_FALSE4 + 1)
end_define

begin_define
define|#
directive|define
name|INST_LAND
value|(INST_LOR + 1)
end_define

begin_define
define|#
directive|define
name|INST_BITOR
value|(INST_LOR + 2)
end_define

begin_define
define|#
directive|define
name|INST_BITXOR
value|(INST_LOR + 3)
end_define

begin_define
define|#
directive|define
name|INST_BITAND
value|(INST_LOR + 4)
end_define

begin_define
define|#
directive|define
name|INST_EQ
value|(INST_LOR + 5)
end_define

begin_define
define|#
directive|define
name|INST_NEQ
value|(INST_LOR + 6)
end_define

begin_define
define|#
directive|define
name|INST_LT
value|(INST_LOR + 7)
end_define

begin_define
define|#
directive|define
name|INST_GT
value|(INST_LOR + 8)
end_define

begin_define
define|#
directive|define
name|INST_LE
value|(INST_LOR + 9)
end_define

begin_define
define|#
directive|define
name|INST_GE
value|(INST_LOR + 10)
end_define

begin_define
define|#
directive|define
name|INST_LSHIFT
value|(INST_LOR + 11)
end_define

begin_define
define|#
directive|define
name|INST_RSHIFT
value|(INST_LOR + 12)
end_define

begin_define
define|#
directive|define
name|INST_ADD
value|(INST_LOR + 13)
end_define

begin_define
define|#
directive|define
name|INST_SUB
value|(INST_LOR + 14)
end_define

begin_define
define|#
directive|define
name|INST_MULT
value|(INST_LOR + 15)
end_define

begin_define
define|#
directive|define
name|INST_DIV
value|(INST_LOR + 16)
end_define

begin_define
define|#
directive|define
name|INST_MOD
value|(INST_LOR + 17)
end_define

begin_define
define|#
directive|define
name|INST_UPLUS
value|(INST_LOR + 18)
end_define

begin_define
define|#
directive|define
name|INST_UMINUS
value|(INST_LOR + 19)
end_define

begin_define
define|#
directive|define
name|INST_BITNOT
value|(INST_LOR + 20)
end_define

begin_define
define|#
directive|define
name|INST_LNOT
value|(INST_LOR + 21)
end_define

begin_define
define|#
directive|define
name|INST_CALL_BUILTIN_FUNC1
value|(INST_LOR + 22)
end_define

begin_define
define|#
directive|define
name|INST_CALL_FUNC1
value|(INST_LOR + 23)
end_define

begin_define
define|#
directive|define
name|INST_TRY_CVT_TO_NUMERIC
value|(INST_LOR + 24)
end_define

begin_comment
comment|/* Opcodes 65 to 66 */
end_comment

begin_define
define|#
directive|define
name|INST_BREAK
value|(INST_TRY_CVT_TO_NUMERIC + 1)
end_define

begin_define
define|#
directive|define
name|INST_CONTINUE
value|(INST_BREAK + 1)
end_define

begin_comment
comment|/* Opcodes 67 to 68 */
end_comment

begin_define
define|#
directive|define
name|INST_FOREACH_START4
value|(INST_CONTINUE + 1)
end_define

begin_define
define|#
directive|define
name|INST_FOREACH_STEP4
value|(INST_FOREACH_START4 + 1)
end_define

begin_comment
comment|/* Opcodes 69 to 72 */
end_comment

begin_define
define|#
directive|define
name|INST_BEGIN_CATCH4
value|(INST_FOREACH_STEP4 + 1)
end_define

begin_define
define|#
directive|define
name|INST_END_CATCH
value|(INST_BEGIN_CATCH4 + 1)
end_define

begin_define
define|#
directive|define
name|INST_PUSH_RESULT
value|(INST_BEGIN_CATCH4 + 2)
end_define

begin_define
define|#
directive|define
name|INST_PUSH_RETURN_CODE
value|(INST_BEGIN_CATCH4 + 3)
end_define

begin_comment
comment|/* The last opcode */
end_comment

begin_define
define|#
directive|define
name|LAST_INST_OPCODE
value|INST_PUSH_RETURN_CODE
end_define

begin_comment
comment|/*  * Table describing the Tcl bytecode instructions: their name (for  * displaying code), total number of code bytes required (including  * operand bytes), and a description of the type of each operand.  * These operand types include signed and unsigned integers of length  * one and four bytes. The unsigned integers are used for indexes or  * for, e.g., the count of objects to push in a "push" instruction.  */
end_comment

begin_define
define|#
directive|define
name|MAX_INSTRUCTION_OPERANDS
value|2
end_define

begin_typedef
typedef|typedef
enum|enum
name|InstOperandType
block|{
name|OPERAND_NONE
block|,
name|OPERAND_INT1
block|,
comment|/* One byte signed integer. */
name|OPERAND_INT4
block|,
comment|/* Four byte signed integer. */
name|OPERAND_UINT1
block|,
comment|/* One byte unsigned integer. */
name|OPERAND_UINT4
comment|/* Four byte unsigned integer. */
block|}
name|InstOperandType
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|InstructionDesc
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of instruction. */
name|int
name|numBytes
decl_stmt|;
comment|/* Total number of bytes for instruction. */
name|int
name|numOperands
decl_stmt|;
comment|/* Number of operands. */
name|InstOperandType
name|opTypes
index|[
name|MAX_INSTRUCTION_OPERANDS
index|]
decl_stmt|;
comment|/* The type of each operand. */
block|}
name|InstructionDesc
typedef|;
end_typedef

begin_decl_stmt
specifier|extern
name|InstructionDesc
name|instructionTable
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Definitions of the values of the INST_CALL_BUILTIN_FUNC instruction's  * operand byte. Each value denotes a builtin Tcl math function. These  * values must correspond to the entries in the builtinFuncTable array  * below and to the values stored in the tclInt.h MathFunc structure's  * builtinFuncIndex field.  */
end_comment

begin_define
define|#
directive|define
name|BUILTIN_FUNC_ACOS
value|0
end_define

begin_define
define|#
directive|define
name|BUILTIN_FUNC_ASIN
value|1
end_define

begin_define
define|#
directive|define
name|BUILTIN_FUNC_ATAN
value|2
end_define

begin_define
define|#
directive|define
name|BUILTIN_FUNC_ATAN2
value|3
end_define

begin_define
define|#
directive|define
name|BUILTIN_FUNC_CEIL
value|4
end_define

begin_define
define|#
directive|define
name|BUILTIN_FUNC_COS
value|5
end_define

begin_define
define|#
directive|define
name|BUILTIN_FUNC_COSH
value|6
end_define

begin_define
define|#
directive|define
name|BUILTIN_FUNC_EXP
value|7
end_define

begin_define
define|#
directive|define
name|BUILTIN_FUNC_FLOOR
value|8
end_define

begin_define
define|#
directive|define
name|BUILTIN_FUNC_FMOD
value|9
end_define

begin_define
define|#
directive|define
name|BUILTIN_FUNC_HYPOT
value|10
end_define

begin_define
define|#
directive|define
name|BUILTIN_FUNC_LOG
value|11
end_define

begin_define
define|#
directive|define
name|BUILTIN_FUNC_LOG10
value|12
end_define

begin_define
define|#
directive|define
name|BUILTIN_FUNC_POW
value|13
end_define

begin_define
define|#
directive|define
name|BUILTIN_FUNC_SIN
value|14
end_define

begin_define
define|#
directive|define
name|BUILTIN_FUNC_SINH
value|15
end_define

begin_define
define|#
directive|define
name|BUILTIN_FUNC_SQRT
value|16
end_define

begin_define
define|#
directive|define
name|BUILTIN_FUNC_TAN
value|17
end_define

begin_define
define|#
directive|define
name|BUILTIN_FUNC_TANH
value|18
end_define

begin_define
define|#
directive|define
name|BUILTIN_FUNC_ABS
value|19
end_define

begin_define
define|#
directive|define
name|BUILTIN_FUNC_DOUBLE
value|20
end_define

begin_define
define|#
directive|define
name|BUILTIN_FUNC_INT
value|21
end_define

begin_define
define|#
directive|define
name|BUILTIN_FUNC_RAND
value|22
end_define

begin_define
define|#
directive|define
name|BUILTIN_FUNC_ROUND
value|23
end_define

begin_define
define|#
directive|define
name|BUILTIN_FUNC_SRAND
value|24
end_define

begin_define
define|#
directive|define
name|LAST_BUILTIN_FUNC
value|BUILTIN_FUNC_SRAND
end_define

begin_comment
comment|/*  * Table describing the built-in math functions. Entries in this table are  * indexed by the values of the INST_CALL_BUILTIN_FUNC instruction's  * operand byte.  */
end_comment

begin_typedef
typedef|typedef
name|int
argument_list|(
argument|CallBuiltinFuncProc
argument_list|)
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExecEnv
operator|*
name|eePtr
operator|,
name|ClientData
name|clientData
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of function. */
name|int
name|numArgs
decl_stmt|;
comment|/* Number of arguments for function. */
name|Tcl_ValueType
name|argTypes
index|[
name|MAX_MATH_ARGS
index|]
decl_stmt|;
comment|/* Acceptable types for each argument. */
name|CallBuiltinFuncProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure implementing this function. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Additional argument to pass to the 				 * function when invoking it. */
block|}
name|BuiltinFunc
typedef|;
end_typedef

begin_decl_stmt
specifier|extern
name|BuiltinFunc
name|builtinFuncTable
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The structure used to hold information about the start and end of each  * argument word in a command.   */
end_comment

begin_define
define|#
directive|define
name|ARGINFO_INIT_ENTRIES
value|5
end_define

begin_typedef
typedef|typedef
struct|struct
name|ArgInfo
block|{
name|int
name|numArgs
decl_stmt|;
comment|/* Number of argument words in command. */
name|char
modifier|*
modifier|*
name|startArray
decl_stmt|;
comment|/* Array of pointers to the first character 				 * of each argument word. */
name|char
modifier|*
modifier|*
name|endArray
decl_stmt|;
comment|/* Array of pointers to the last character 				 * of each argument word. */
name|int
name|allocArgs
decl_stmt|;
comment|/* Number of array entries currently 				 * allocated. */
name|int
name|mallocedArrays
decl_stmt|;
comment|/* 1 if the arrays were expanded and 				 * wordStartArray/wordEndArray point into 				 * the heap, else 0. */
name|char
modifier|*
name|staticStartSpace
index|[
name|ARGINFO_INIT_ENTRIES
index|]
decl_stmt|;
comment|/* Initial storage for word start array. */
name|char
modifier|*
name|staticEndSpace
index|[
name|ARGINFO_INIT_ENTRIES
index|]
decl_stmt|;
comment|/* Initial storage for word end array. */
block|}
name|ArgInfo
typedef|;
end_typedef

begin_comment
comment|/*  * Compilation of some Tcl constructs such as if commands and the logical or  * (||) and logical and (&&) operators in expressions requires the  * generation of forward jumps. Since the PC target of these jumps isn't  * known when the jumps are emitted, we record the offset of each jump in an  * array of JumpFixup structures. There is one array for each sequence of  * jumps to one target PC. When we learn the target PC, we update the jumps  * with the correct distance. Also, if the distance is too great (> 127  * bytes), we replace the single-byte jump with a four byte jump  * instruction, move the instructions after the jump down, and update the  * code offsets for any commands between the jump and the target.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|TCL_UNCONDITIONAL_JUMP
block|,
name|TCL_TRUE_JUMP
block|,
name|TCL_FALSE_JUMP
block|}
name|TclJumpType
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|JumpFixup
block|{
name|TclJumpType
name|jumpType
decl_stmt|;
comment|/* Indicates the kind of jump. */
name|int
name|codeOffset
decl_stmt|;
comment|/* Offset of the first byte of the one-byte 				 * forward jump's code. */
name|int
name|cmdIndex
decl_stmt|;
comment|/* Index of the first command after the one 				 * for which the jump was emitted. Used to 				 * update the code offsets for subsequent 				 * commands if the two-byte jump at jumpPc 				 * must be replaced with a five-byte one. */
name|int
name|excRangeIndex
decl_stmt|;
comment|/* Index of the first range entry in the 				 * ExceptionRange array after the current 				 * one. This field is used to adjust the 				 * code offsets in subsequent ExceptionRange 				 * records when a jump is grown from 2 bytes 				 * to 5 bytes. */
block|}
name|JumpFixup
typedef|;
end_typedef

begin_define
define|#
directive|define
name|JUMPFIXUP_INIT_ENTRIES
value|10
end_define

begin_typedef
typedef|typedef
struct|struct
name|JumpFixupArray
block|{
name|JumpFixup
modifier|*
name|fixup
decl_stmt|;
comment|/* Points to start of jump fixup array. */
name|int
name|next
decl_stmt|;
comment|/* Index of next free array entry. */
name|int
name|end
decl_stmt|;
comment|/* Index of last usable entry in array. */
name|int
name|mallocedArray
decl_stmt|;
comment|/* 1 if array was expanded and fixups points 				 * into the heap, else 0. */
name|JumpFixup
name|staticFixupSpace
index|[
name|JUMPFIXUP_INIT_ENTRIES
index|]
decl_stmt|;
comment|/* Initial storage for jump fixup array. */
block|}
name|JumpFixupArray
typedef|;
end_typedef

begin_comment
comment|/*  * The structure describing one variable list of a foreach command. Note  * that only foreach commands inside procedure bodies are compiled inline so  * a ForeachVarList structure always describes local variables. Furthermore,  * only scalar variables are supported for inline-compiled foreach loops.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ForeachVarList
block|{
name|int
name|numVars
decl_stmt|;
comment|/* The number of variables in the list. */
name|int
name|varIndexes
index|[
literal|1
index|]
decl_stmt|;
comment|/* An array of the indexes ("slot numbers") 				 * for each variable in the procedure's 				 * array of local variables. Only scalar 				 * variables are supported. The actual 				 * size of this field will be large enough 				 * to numVars indexes. THIS MUST BE THE 				 * LAST FIELD IN THE STRUCTURE! */
block|}
name|ForeachVarList
typedef|;
end_typedef

begin_comment
comment|/*  * Structure used to hold information about a foreach command that is needed  * during program execution. These structures are stored in CompileEnv and  * ByteCode structures as auxiliary data.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ForeachInfo
block|{
name|int
name|numLists
decl_stmt|;
comment|/* The number of both the variable and value 				 * lists of the foreach command. */
name|int
name|firstListTmp
decl_stmt|;
comment|/* The slot number of the first temporary 				 * variable holding the lists themselves. */
name|int
name|loopIterNumTmp
decl_stmt|;
comment|/* The slot number of the temp var holding 				 * the count of times the loop body has been 				 * executed. This is used to determine which 				 * list element to assign each loop var. */
name|ForeachVarList
modifier|*
name|varLists
index|[
literal|1
index|]
decl_stmt|;
comment|/* An array of pointers to ForeachVarList 				 * structures describing each var list. The 				 * actual size of this field will be large 				 * enough to numVars indexes. THIS MUST BE 				 * THE LAST FIELD IN THE STRUCTURE! */
block|}
name|ForeachInfo
typedef|;
end_typedef

begin_comment
comment|/*  * Structure containing a cached pointer to a command that is the result  * of resolving the command's name in some namespace. It is the internal  * representation for a cmdName object. It contains the pointer along  * with some information that is used to check the pointer's validity.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ResolvedCmdName
block|{
name|Command
modifier|*
name|cmdPtr
decl_stmt|;
comment|/* A cached Command pointer. */
name|Namespace
modifier|*
name|refNsPtr
decl_stmt|;
comment|/* Points to the namespace containing the 				 * reference (not the namespace that 				 * contains the referenced command). */
name|long
name|refNsId
decl_stmt|;
comment|/* refNsPtr's unique namespace id. Used to 				 * verify that refNsPtr is still valid 				 * (e.g., it's possible that the cmd's 				 * containing namespace was deleted and a 				 * new one created at the same address). */
name|int
name|refNsCmdEpoch
decl_stmt|;
comment|/* Value of the referencing namespace's 				 * cmdRefEpoch when the pointer was cached. 				 * Before using the cached pointer, we check 				 * if the namespace's epoch was incremented; 				 * if so, this cached pointer is invalid. */
name|int
name|cmdEpoch
decl_stmt|;
comment|/* Value of the command's cmdEpoch when this 				 * pointer was cached. Before using the 				 * cached pointer, we check if the cmd's 				 * epoch was incremented; if so, the cmd was 				 * renamed, deleted, hidden, or exposed, and 				 * so the pointer is invalid. */
name|int
name|refCount
decl_stmt|;
comment|/* Reference count: 1 for each cmdName 				 * object that has a pointer to this 				 * ResolvedCmdName structure as its internal 				 * rep. This structure can be freed when 				 * refCount becomes zero. */
block|}
name|ResolvedCmdName
typedef|;
end_typedef

begin_comment
comment|/*  *----------------------------------------------------------------  * Procedures shared among Tcl bytecode compilation and execution  * modules but not used outside:  *----------------------------------------------------------------  */
end_comment

begin_decl_stmt
name|EXTERN
name|void
name|TclCleanupByteCode
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ByteCode
operator|*
name|codePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclCompileExpr
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|char
operator|*
name|lastChar
operator|,
name|int
name|flags
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclCompileQuotes
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|char
operator|*
name|lastChar
operator|,
name|int
name|termChar
operator|,
name|int
name|flags
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclCompileString
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|char
operator|*
name|lastChar
operator|,
name|int
name|flags
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclCompileDollarVar
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|string
operator|,
name|char
operator|*
name|lastChar
operator|,
name|int
name|flags
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclCreateAuxData
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|AuxDataDupProc
operator|*
name|dupProc
operator|,
name|AuxDataFreeProc
operator|*
name|freeProc
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|ExecEnv
modifier|*
name|TclCreateExecEnv
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclDeleteExecEnv
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ExecEnv
operator|*
name|eePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclEmitForwardJump
name|_ANSI_ARGS_
argument_list|(
operator|(
name|CompileEnv
operator|*
name|envPtr
operator|,
name|TclJumpType
name|jumpType
operator|,
name|JumpFixup
operator|*
name|jumpFixupPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|ExceptionRange
modifier|*
name|TclGetExceptionRangeForPc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|unsigned
name|char
operator|*
name|pc
operator|,
name|int
name|catchOnly
operator|,
name|ByteCode
operator|*
name|codePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclExecuteByteCode
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ByteCode
operator|*
name|codePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclExpandCodeArray
name|_ANSI_ARGS_
argument_list|(
operator|(
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclExpandJumpFixupArray
name|_ANSI_ARGS_
argument_list|(
operator|(
name|JumpFixupArray
operator|*
name|fixupArrayPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclFixupForwardJump
name|_ANSI_ARGS_
argument_list|(
operator|(
name|CompileEnv
operator|*
name|envPtr
operator|,
name|JumpFixup
operator|*
name|jumpFixupPtr
operator|,
name|int
name|jumpDist
operator|,
name|int
name|distThreshold
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclFreeCompileEnv
name|_ANSI_ARGS_
argument_list|(
operator|(
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclFreeJumpFixupArray
name|_ANSI_ARGS_
argument_list|(
operator|(
name|JumpFixupArray
operator|*
name|fixupArrayPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclInitByteCodeObj
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Obj
operator|*
name|objPtr
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclInitCompileEnv
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|,
name|char
operator|*
name|string
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclInitJumpFixupArray
name|_ANSI_ARGS_
argument_list|(
operator|(
name|JumpFixupArray
operator|*
name|fixupArrayPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_COMPILE_STATS
end_ifdef

begin_decl_stmt
name|EXTERN
name|int
name|TclLog2
name|_ANSI_ARGS_
argument_list|(
operator|(
name|int
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*TCL_COMPILE_STATS*/
end_comment

begin_decl_stmt
name|EXTERN
name|int
name|TclObjIndexForString
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|start
operator|,
name|int
name|length
operator|,
name|int
name|allocStrRep
operator|,
name|int
name|inHeap
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|TclPrintInstruction
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ByteCode
operator|*
name|codePtr
operator|,
name|unsigned
name|char
operator|*
name|pc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|void
name|TclPrintSource
name|_ANSI_ARGS_
argument_list|(
operator|(
name|FILE
operator|*
name|outFile
operator|,
name|char
operator|*
name|string
operator|,
name|int
name|maxChars
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *----------------------------------------------------------------  * Macros used by Tcl bytecode compilation and execution modules  * inside the Tcl core but not used outside.  *----------------------------------------------------------------  */
end_comment

begin_comment
comment|/*  * Macros to ensure there is enough room in a CompileEnv's code array.  * The ANSI C "prototypes" for these macros are:  *  * EXTERN void	TclEnsureCodeSpace1 _ANSI_ARGS_((CompileEnv *envPtr));  * EXTERN void	TclEnsureCodeSpace _ANSI_ARGS_((int nBytes,  *		    CompileEnv *envPtr));  */
end_comment

begin_define
define|#
directive|define
name|TclEnsureCodeSpace1
parameter_list|(
name|envPtr
parameter_list|)
define|\
value|if ((envPtr)->codeNext == (envPtr)->codeEnd) \         TclExpandCodeArray(envPtr)
end_define

begin_define
define|#
directive|define
name|TclEnsureCodeSpace
parameter_list|(
name|nBytes
parameter_list|,
name|envPtr
parameter_list|)
define|\
value|if (((envPtr)->codeNext + nBytes)> (envPtr)->codeEnd) \         TclExpandCodeArray(envPtr)
end_define

begin_comment
comment|/*  * Macro to emit an opcode byte into a CompileEnv's code array.  * The ANSI C "prototype" for this macro is:  *  * EXTERN void	TclEmitOpcode _ANSI_ARGS_((unsigned char op,  *		    CompileEnv *envPtr));  */
end_comment

begin_define
define|#
directive|define
name|TclEmitOpcode
parameter_list|(
name|op
parameter_list|,
name|envPtr
parameter_list|)
define|\
value|TclEnsureCodeSpace1(envPtr); \     *(envPtr)->codeNext++ = (unsigned char) (op)
end_define

begin_comment
comment|/*  * Macros to emit a (signed or unsigned) int operand. The two variants  * depend on the number of bytes needed for the int. Four byte integers  * are stored in "big-endian" order with the high order byte stored at  * the lowest address. The ANSI C "prototypes" for these macros are:  *  * EXTERN void	TclEmitInt1 _ANSI_ARGS_((int i, CompileEnv *envPtr));  * EXTERN void	TclEmitInt4 _ANSI_ARGS_((int i, CompileEnv *envPtr));  */
end_comment

begin_define
define|#
directive|define
name|TclEmitInt1
parameter_list|(
name|i
parameter_list|,
name|envPtr
parameter_list|)
define|\
value|TclEnsureCodeSpace(1, (envPtr)); \     *(envPtr)->codeNext++ = (unsigned char) ((unsigned int) (i))
end_define

begin_define
define|#
directive|define
name|TclEmitInt4
parameter_list|(
name|i
parameter_list|,
name|envPtr
parameter_list|)
define|\
value|TclEnsureCodeSpace(4, (envPtr)); \     *(envPtr)->codeNext++ = \         (unsigned char) ((unsigned int) (i)>> 24); \     *(envPtr)->codeNext++ = \         (unsigned char) ((unsigned int) (i)>> 16); \     *(envPtr)->codeNext++ = \         (unsigned char) ((unsigned int) (i)>>  8); \     *(envPtr)->codeNext++ = \         (unsigned char) ((unsigned int) (i)      )
end_define

begin_comment
comment|/*  * Macros to emit an instruction with signed or unsigned int operands.  * The ANSI C "prototypes" for these macros are:  *  * EXTERN void	TclEmitInstInt1 _ANSI_ARGS_((unsigned char op, int i,   *		    CompileEnv *envPtr));  * EXTERN void	TclEmitInstInt4 _ANSI_ARGS_((unsigned char op, int i,   *		    CompileEnv *envPtr));  * EXTERN void	TclEmitInstUInt1 _ANSI_ARGS_((unsigned char op,  *		    unsigned int i, CompileEnv *envPtr));  * EXTERN void	TclEmitInstUInt4 _ANSI_ARGS_((unsigned char op,  *		    unsigned int i, CompileEnv *envPtr));  */
end_comment

begin_define
define|#
directive|define
name|TclEmitInstInt1
parameter_list|(
name|op
parameter_list|,
name|i
parameter_list|,
name|envPtr
parameter_list|)
define|\
value|TclEnsureCodeSpace(2, (envPtr)); \     *(envPtr)->codeNext++ = (unsigned char) (op); \     *(envPtr)->codeNext++ = (unsigned char) ((unsigned int) (i))
end_define

begin_define
define|#
directive|define
name|TclEmitInstInt4
parameter_list|(
name|op
parameter_list|,
name|i
parameter_list|,
name|envPtr
parameter_list|)
define|\
value|TclEnsureCodeSpace(5, (envPtr)); \     *(envPtr)->codeNext++ = (unsigned char) (op); \     *(envPtr)->codeNext++ = \         (unsigned char) ((unsigned int) (i)>> 24); \     *(envPtr)->codeNext++ = \         (unsigned char) ((unsigned int) (i)>> 16); \     *(envPtr)->codeNext++ = \         (unsigned char) ((unsigned int) (i)>>  8); \     *(envPtr)->codeNext++ = \         (unsigned char) ((unsigned int) (i)      )
end_define

begin_define
define|#
directive|define
name|TclEmitInstUInt1
parameter_list|(
name|op
parameter_list|,
name|i
parameter_list|,
name|envPtr
parameter_list|)
define|\
value|TclEmitInstInt1((op), (i), (envPtr))
end_define

begin_define
define|#
directive|define
name|TclEmitInstUInt4
parameter_list|(
name|op
parameter_list|,
name|i
parameter_list|,
name|envPtr
parameter_list|)
define|\
value|TclEmitInstInt4((op), (i), (envPtr))
end_define

begin_comment
comment|/*  * Macro to push a Tcl object onto the Tcl evaluation stack. It emits the  * object's one or four byte array index into the CompileEnv's code  * array. These support, respectively, a maximum of 256 (2**8) and 2**32  * objects in a CompileEnv. The ANSI C "prototype" for this macro is:  *  * EXTERN void	TclEmitPush _ANSI_ARGS_((int objIndex, CompileEnv *envPtr));  */
end_comment

begin_define
define|#
directive|define
name|TclEmitPush
parameter_list|(
name|objIndex
parameter_list|,
name|envPtr
parameter_list|)
define|\
value|if ((objIndex)<= 255) { \ 	TclEmitInstUInt1(INST_PUSH1, (objIndex), (envPtr)); \     } else { \ 	TclEmitInstUInt4(INST_PUSH4, (objIndex), (envPtr)); \     }
end_define

begin_comment
comment|/*  * Macros to update a (signed or unsigned) integer starting at a pointer.  * The two variants depend on the number of bytes. The ANSI C "prototypes"  * for these macros are:  *  * EXTERN void	TclStoreInt1AtPtr _ANSI_ARGS_((int i, unsigned char *p));  * EXTERN void	TclStoreInt4AtPtr _ANSI_ARGS_((int i, unsigned char *p));  */
end_comment

begin_define
define|#
directive|define
name|TclStoreInt1AtPtr
parameter_list|(
name|i
parameter_list|,
name|p
parameter_list|)
define|\
value|*(p)   = (unsigned char) ((unsigned int) (i))
end_define

begin_define
define|#
directive|define
name|TclStoreInt4AtPtr
parameter_list|(
name|i
parameter_list|,
name|p
parameter_list|)
define|\
value|*(p)   = (unsigned char) ((unsigned int) (i)>> 24); \     *(p+1) = (unsigned char) ((unsigned int) (i)>> 16); \     *(p+2) = (unsigned char) ((unsigned int) (i)>>  8); \     *(p+3) = (unsigned char) ((unsigned int) (i)      )
end_define

begin_comment
comment|/*  * Macros to update instructions at a particular pc with a new op code  * and a (signed or unsigned) int operand. The ANSI C "prototypes" for  * these macros are:  *  * EXTERN void	TclUpdateInstInt1AtPc _ANSI_ARGS_((unsigned char op, int i,  *		    unsigned char *pc));  * EXTERN void	TclUpdateInstInt4AtPc _ANSI_ARGS_((unsigned char op, int i,  *		    unsigned char *pc));  */
end_comment

begin_define
define|#
directive|define
name|TclUpdateInstInt1AtPc
parameter_list|(
name|op
parameter_list|,
name|i
parameter_list|,
name|pc
parameter_list|)
define|\
value|*(pc) = (unsigned char) (op); \     TclStoreInt1AtPtr((i), ((pc)+1))
end_define

begin_define
define|#
directive|define
name|TclUpdateInstInt4AtPc
parameter_list|(
name|op
parameter_list|,
name|i
parameter_list|,
name|pc
parameter_list|)
define|\
value|*(pc) = (unsigned char) (op); \     TclStoreInt4AtPtr((i), ((pc)+1))
end_define

begin_comment
comment|/*  * Macros to get a signed integer (GET_INT{1,2}) or an unsigned int  * (GET_UINT{1,2}) from a pointer. There are two variants for each  * return type that depend on the number of bytes fetched.  * The ANSI C "prototypes" for these macros are:  *  * EXTERN int	        TclGetInt1AtPtr  _ANSI_ARGS_((unsigned char *p));  * EXTERN int	        TclGetInt4AtPtr  _ANSI_ARGS_((unsigned char *p));  * EXTERN unsigned int	TclGetUInt1AtPtr _ANSI_ARGS_((unsigned char *p));  * EXTERN unsigned int	TclGetUInt4AtPtr _ANSI_ARGS_((unsigned char *p));  */
end_comment

begin_comment
comment|/*  * The TclGetInt1AtPtr macro is tricky because we want to do sign  * extension on the 1-byte value. Unfortunately the "char" type isn't  * signed on all platforms so sign-extension doesn't always happen  * automatically. Sometimes we can explicitly declare the pointer to be  * signed, but other times we have to explicitly sign-extend the value  * in software.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CHAR_UNSIGNED__
end_ifndef

begin_define
define|#
directive|define
name|TclGetInt1AtPtr
parameter_list|(
name|p
parameter_list|)
value|((int) *((char *) p))
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SIGNED_CHAR
end_ifdef

begin_define
define|#
directive|define
name|TclGetInt1AtPtr
parameter_list|(
name|p
parameter_list|)
value|((int) *((signed char *) p))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TclGetInt1AtPtr
parameter_list|(
name|p
parameter_list|)
value|(((int) *((char *) p)) \ 		| ((*(p)& 0200) ? (-256) : 0))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TclGetInt4AtPtr
parameter_list|(
name|p
parameter_list|)
value|(((int) TclGetInt1AtPtr(p)<< 24) | \ 		                  	    (*((p)+1)<< 16) | \ 				  	    (*((p)+2)<<  8) | \ 				  	    (*((p)+3)))
end_define

begin_define
define|#
directive|define
name|TclGetUInt1AtPtr
parameter_list|(
name|p
parameter_list|)
value|((unsigned int) *(p))
end_define

begin_define
define|#
directive|define
name|TclGetUInt4AtPtr
parameter_list|(
name|p
parameter_list|)
value|((unsigned int) (*(p)<< 24) | \ 		                            (*((p)+1)<< 16) | \ 				            (*((p)+2)<<  8) | \ 				            (*((p)+3)))
end_define

begin_comment
comment|/*  * Macros used to compute the minimum and maximum of two integers.  * The ANSI C "prototypes" for these macros are:  *  * EXTERN int  TclMin _ANSI_ARGS_((int i, int j));  * EXTERN int  TclMax _ANSI_ARGS_((int i, int j));  */
end_comment

begin_define
define|#
directive|define
name|TclMin
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|)
value|((((int) i)< ((int) j))? (i) : (j))
end_define

begin_define
define|#
directive|define
name|TclMax
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|)
value|((((int) i)> ((int) j))? (i) : (j))
end_define

begin_comment
comment|/*  * Macro used to compute the offset of the current instruction in the  * bytecode instruction stream. The ANSI C "prototypes" for this macro is:  *  * EXTERN int  TclCurrCodeOffset _ANSI_ARGS_((void));  */
end_comment

begin_define
define|#
directive|define
name|TclCurrCodeOffset
parameter_list|()
value|((envPtr)->codeNext - (envPtr)->codeStart)
end_define

begin_comment
comment|/*  * Upper bound for legal jump distances. Checked during compilation if  * debugging.  */
end_comment

begin_define
define|#
directive|define
name|MAX_JUMP_DIST
value|5000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _TCLCOMPILATION */
end_comment

end_unit

