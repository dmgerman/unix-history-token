begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclIOUtil.c --  *  *	This file contains a collection of utility procedures that  *	are shared by the platform specific IO drivers.  *  *	Parts of this file are based on code contributed by Karl  *	Lehenbauer, Mark Diekhans and Peter da Silva.  *  * Copyright (c) 1991-1994 The Regents of the University of California.  * Copyright (c) 1994-1996 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclIOUtil.c 1.123 96/04/29 14:08:24  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * A linked list of the following structures is used to keep track  * of child processes that have been detached but haven't exited  * yet, so we can make sure that they're properly "reaped" (officially  * waited for) and don't lie around as zombies cluttering the  * system.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Detached
block|{
name|int
name|pid
decl_stmt|;
comment|/* Id of process that's been detached 					 * but isn't known to have exited. */
name|struct
name|Detached
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next in list of all detached 					 * processes. */
block|}
name|Detached
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|Detached
modifier|*
name|detList
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of all detached proceses. */
end_comment

begin_comment
comment|/*  * Declarations for local procedures defined in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|Tcl_File
name|FileForRedirect
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|spec
operator|,
name|int
name|atOk
operator|,
name|char
operator|*
name|arg
operator|,
name|int
name|flags
operator|,
name|char
operator|*
name|nextArg
operator|,
name|int
operator|*
name|skipPtr
operator|,
name|int
operator|*
name|closePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FileForRedirect --  *  *	This procedure does much of the work of parsing redirection  *	operators.  It handles "@" if specified and allowed, and a file  *	name, and opens the file if necessary.  *  * Results:  *	The return value is the descriptor number for the file.  If an  *	error occurs then NULL is returned and an error message is left  *	in interp->result.  Several arguments are side-effected; see  *	the argument list below for details.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Tcl_File
name|FileForRedirect
parameter_list|(
name|interp
parameter_list|,
name|spec
parameter_list|,
name|atOk
parameter_list|,
name|arg
parameter_list|,
name|flags
parameter_list|,
name|nextArg
parameter_list|,
name|skipPtr
parameter_list|,
name|closePtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Intepreter to use for error 					 * reporting. */
specifier|register
name|char
modifier|*
name|spec
decl_stmt|;
comment|/* Points to character just after 					 * redirection character. */
name|int
name|atOk
decl_stmt|;
comment|/* Non-zero means '@' notation is 					 * OK, zero means it isn't. */
name|char
modifier|*
name|arg
decl_stmt|;
comment|/* Pointer to entire argument 					 * containing spec:  used for error 					 * reporting. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to use for opening file. */
name|char
modifier|*
name|nextArg
decl_stmt|;
comment|/* Next argument in argc/argv 					 * array, if needed for file name. 					 * May be NULL. */
name|int
modifier|*
name|skipPtr
decl_stmt|;
comment|/* This value is incremented if 					 * nextArg is used for redirection 					 * spec. */
name|int
modifier|*
name|closePtr
decl_stmt|;
comment|/* This value is set to 1 if the file 					 * that's returned must be closed, 0 					 * if it was specified with "@" so 					 * it must be left open. */
block|{
name|int
name|writing
init|=
operator|(
name|flags
operator|&
name|O_WRONLY
operator|)
decl_stmt|;
name|Tcl_Channel
name|chan
decl_stmt|;
name|Tcl_File
name|file
decl_stmt|;
if|if
condition|(
name|atOk
operator|&&
operator|(
operator|*
name|spec
operator|==
literal|'@'
operator|)
condition|)
block|{
name|spec
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|spec
operator|==
literal|0
condition|)
block|{
name|spec
operator|=
name|nextArg
expr_stmt|;
if|if
condition|(
name|spec
operator|==
name|NULL
condition|)
block|{
goto|goto
name|badLastArg
goto|;
block|}
operator|*
name|skipPtr
operator|+=
literal|1
expr_stmt|;
block|}
name|chan
operator|=
name|Tcl_GetChannel
argument_list|(
name|interp
argument_list|,
name|spec
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
operator|*
name|closePtr
operator|=
literal|0
expr_stmt|;
name|file
operator|=
name|Tcl_GetChannelFile
argument_list|(
name|chan
argument_list|,
name|writing
condition|?
name|TCL_WRITABLE
else|:
name|TCL_READABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"channel \""
argument_list|,
name|Tcl_GetChannelName
argument_list|(
name|chan
argument_list|)
argument_list|,
literal|"\" wasn't opened for "
argument_list|,
name|writing
condition|?
literal|"writing"
else|:
literal|"reading"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|writing
condition|)
block|{
comment|/* 	     * Be sure to flush output to the file, so that anything 	     * written by the child appears after stuff we've already 	     * written. 	     */
name|Tcl_Flush
argument_list|(
name|chan
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Tcl_DString
name|buffer
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|*
name|spec
operator|==
literal|0
condition|)
block|{
name|spec
operator|=
name|nextArg
expr_stmt|;
if|if
condition|(
name|spec
operator|==
name|NULL
condition|)
block|{
goto|goto
name|badLastArg
goto|;
block|}
operator|*
name|skipPtr
operator|+=
literal|1
expr_stmt|;
block|}
name|name
operator|=
name|Tcl_TranslateFileName
argument_list|(
name|interp
argument_list|,
name|spec
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|file
operator|=
name|TclOpenFile
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|file
operator|=
name|NULL
expr_stmt|;
block|}
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't "
argument_list|,
operator|(
name|writing
operator|)
condition|?
literal|"write"
else|:
literal|"read"
argument_list|,
literal|" file \""
argument_list|,
name|spec
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|closePtr
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|file
return|;
name|badLastArg
label|:
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"can't specify \""
argument_list|,
name|arg
argument_list|,
literal|"\" as last word in command"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclGetOpenMode --  *  * Description:  *	Computes a POSIX mode mask for opening a file, from a given string,  *	and also sets a flag to indicate whether the caller should seek to  *	EOF after opening the file.  *  * Results:  *	On success, returns mode to pass to "open". If an error occurs, the  *	returns -1 and if interp is not NULL, sets interp->result to an  *	error message.  *  * Side effects:  *	Sets the integer referenced by seekFlagPtr to 1 to tell the caller  *	to seek to EOF after opening the file.  *  * Special note:  *	This code is based on a prototype implementation contributed  *	by Mark Diekhans.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclGetOpenMode
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|seekFlagPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for error 					 * reporting - may be NULL. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Mode string, e.g. "r+" or 					 * "RDONLY CREAT". */
name|int
modifier|*
name|seekFlagPtr
decl_stmt|;
comment|/* Set this to 1 if the caller                                          * should seek to EOF during the                                          * opening of the file. */
block|{
name|int
name|mode
decl_stmt|,
name|modeArgc
decl_stmt|,
name|c
decl_stmt|,
name|i
decl_stmt|,
name|gotRW
decl_stmt|;
name|char
modifier|*
modifier|*
name|modeArgv
decl_stmt|,
modifier|*
name|flag
decl_stmt|;
define|#
directive|define
name|RW_MODES
value|(O_RDONLY|O_WRONLY|O_RDWR)
comment|/*      * Check for the simpler fopen-like access modes (e.g. "r").  They      * are distinguished from the POSIX access modes by the presence      * of a lower-case first letter.      */
operator|*
name|seekFlagPtr
operator|=
literal|0
expr_stmt|;
name|mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|islower
argument_list|(
name|UCHAR
argument_list|(
name|string
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|string
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'r'
case|:
name|mode
operator|=
name|O_RDONLY
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|mode
operator|=
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|mode
operator|=
name|O_WRONLY
operator||
name|O_CREAT
expr_stmt|;
operator|*
name|seekFlagPtr
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|error
label|:
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"illegal access mode \""
argument_list|,
name|string
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|string
index|[
literal|1
index|]
operator|==
literal|'+'
condition|)
block|{
name|mode
operator|&=
operator|~
operator|(
name|O_RDONLY
operator||
name|O_WRONLY
operator|)
expr_stmt|;
name|mode
operator||=
name|O_RDWR
expr_stmt|;
if|if
condition|(
name|string
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|string
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
return|return
name|mode
return|;
block|}
comment|/*      * The access modes are specified using a list of POSIX modes      * such as O_CREAT.      *      * IMPORTANT NOTE: We rely on Tcl_SplitList working correctly when      * a NULL interpreter is passed in.      */
if|if
condition|(
name|Tcl_SplitList
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
operator|&
name|modeArgc
argument_list|,
operator|&
name|modeArgv
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
literal|"\n    while processing open access modes \""
argument_list|)
expr_stmt|;
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
name|gotRW
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modeArgc
condition|;
name|i
operator|++
control|)
block|{
name|flag
operator|=
name|modeArgv
index|[
name|i
index|]
expr_stmt|;
name|c
operator|=
name|flag
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'R'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|flag
argument_list|,
literal|"RDONLY"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mode
operator|=
operator|(
name|mode
operator|&
operator|~
name|RW_MODES
operator|)
operator||
name|O_RDONLY
expr_stmt|;
name|gotRW
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'W'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|flag
argument_list|,
literal|"WRONLY"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mode
operator|=
operator|(
name|mode
operator|&
operator|~
name|RW_MODES
operator|)
operator||
name|O_WRONLY
expr_stmt|;
name|gotRW
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'R'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|flag
argument_list|,
literal|"RDWR"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mode
operator|=
operator|(
name|mode
operator|&
operator|~
name|RW_MODES
operator|)
operator||
name|O_RDWR
expr_stmt|;
name|gotRW
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'A'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|flag
argument_list|,
literal|"APPEND"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mode
operator||=
name|O_APPEND
expr_stmt|;
operator|*
name|seekFlagPtr
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'C'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|flag
argument_list|,
literal|"CREAT"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mode
operator||=
name|O_CREAT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'E'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|flag
argument_list|,
literal|"EXCL"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mode
operator||=
name|O_EXCL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'N'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|flag
argument_list|,
literal|"NOCTTY"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|O_NOCTTY
name|mode
operator||=
name|O_NOCTTY
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"access mode \""
argument_list|,
name|flag
argument_list|,
literal|"\" not supported by this system"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|modeArgv
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'N'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|flag
argument_list|,
literal|"NONBLOCK"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|O_NDELAY
argument_list|)
operator|||
name|defined
argument_list|(
name|O_NONBLOCK
argument_list|)
ifdef|#
directive|ifdef
name|O_NONBLOCK
name|mode
operator||=
name|O_NONBLOCK
expr_stmt|;
else|#
directive|else
name|mode
operator||=
name|O_NDELAY
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"access mode \""
argument_list|,
name|flag
argument_list|,
literal|"\" not supported by this system"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|modeArgv
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'T'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|flag
argument_list|,
literal|"TRUNC"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mode
operator||=
name|O_TRUNC
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"invalid access mode \""
argument_list|,
name|flag
argument_list|,
literal|"\": must be RDONLY, WRONLY, RDWR, APPEND, CREAT"
argument_list|,
literal|" EXCL, NOCTTY, NONBLOCK, or TRUNC"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|modeArgv
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|modeArgv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gotRW
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"access mode must include either"
argument_list|,
literal|" RDONLY, WRONLY, or RDWR"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
return|return
name|mode
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_EvalFile --  *  *	Read in a file and process the entire file as one gigantic  *	Tcl command.  *  * Results:  *	A standard Tcl result, which is either the result of executing  *	the file or an error indicating why the file couldn't be read.  *  * Side effects:  *	Depends on the commands in the file.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_EvalFile
parameter_list|(
name|interp
parameter_list|,
name|fileName
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to process file. */
name|char
modifier|*
name|fileName
decl_stmt|;
comment|/* Name of file to process.  Tilde-substitution 				 * will be performed on this name. */
block|{
name|int
name|result
decl_stmt|;
name|struct
name|stat
name|statBuf
decl_stmt|;
name|char
modifier|*
name|cmdBuffer
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|char
modifier|*
name|oldScriptFile
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Tcl_DString
name|buffer
decl_stmt|;
name|char
modifier|*
name|nativeName
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|Tcl_Channel
name|chan
init|=
operator|(
name|Tcl_Channel
operator|)
name|NULL
decl_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|oldScriptFile
operator|=
name|iPtr
operator|->
name|scriptFile
expr_stmt|;
name|iPtr
operator|->
name|scriptFile
operator|=
name|fileName
expr_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|nativeName
operator|=
name|Tcl_TranslateFileName
argument_list|(
name|interp
argument_list|,
name|fileName
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|nativeName
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/*      * If Tcl_TranslateFileName didn't already copy the file name, do it      * here.  This way we don't depend on fileName staying constant      * throughout the execution of the script (e.g., what if it happens      * to point to a Tcl variable that the script could change?).      */
if|if
condition|(
name|nativeName
operator|!=
name|Tcl_DStringValue
argument_list|(
operator|&
name|buffer
argument_list|)
condition|)
block|{
name|Tcl_DStringSetLength
argument_list|(
operator|&
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|buffer
argument_list|,
name|nativeName
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|nativeName
operator|=
name|Tcl_DStringValue
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|nativeName
argument_list|,
operator|&
name|statBuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't read file \""
argument_list|,
name|fileName
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|chan
operator|=
name|Tcl_OpenFileChannel
argument_list|(
name|interp
argument_list|,
name|nativeName
argument_list|,
literal|"r"
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't read file \""
argument_list|,
name|fileName
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|cmdBuffer
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|statBuf
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_Read
argument_list|(
name|chan
argument_list|,
name|cmdBuffer
argument_list|,
name|statBuf
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
name|Tcl_Close
argument_list|(
name|interp
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't read file \""
argument_list|,
name|fileName
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|cmdBuffer
index|[
name|result
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Tcl_Close
argument_list|(
name|interp
argument_list|,
name|chan
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|result
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|cmdBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_RETURN
condition|)
block|{
name|result
operator|=
name|TclUpdateReturnInfo
argument_list|(
name|iPtr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|char
name|msg
index|[
literal|200
index|]
decl_stmt|;
comment|/* 	 * Record information telling where the error occurred. 	 */
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n    (file \"%.150s\" line %d)"
argument_list|,
name|fileName
argument_list|,
name|interp
operator|->
name|errorLine
argument_list|)
expr_stmt|;
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
name|iPtr
operator|->
name|scriptFile
operator|=
name|oldScriptFile
expr_stmt|;
name|ckfree
argument_list|(
name|cmdBuffer
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
return|return
name|result
return|;
name|error
label|:
if|if
condition|(
name|cmdBuffer
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|cmdBuffer
argument_list|)
expr_stmt|;
block|}
name|iPtr
operator|->
name|scriptFile
operator|=
name|oldScriptFile
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DetachPids --  *  *	This procedure is called to indicate that one or more child  *	processes have been placed in background and will never be  *	waited for;  they should eventually be reaped by  *	Tcl_ReapDetachedProcs.  *  * Results:  *	None.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DetachPids
parameter_list|(
name|numPids
parameter_list|,
name|pidPtr
parameter_list|)
name|int
name|numPids
decl_stmt|;
comment|/* Number of pids to detach:  gives size 				 * of array pointed to by pidPtr. */
name|int
modifier|*
name|pidPtr
decl_stmt|;
comment|/* Array of pids to detach. */
block|{
specifier|register
name|Detached
modifier|*
name|detPtr
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numPids
condition|;
name|i
operator|++
control|)
block|{
name|detPtr
operator|=
operator|(
name|Detached
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Detached
argument_list|)
argument_list|)
expr_stmt|;
name|detPtr
operator|->
name|pid
operator|=
name|pidPtr
index|[
name|i
index|]
expr_stmt|;
name|detPtr
operator|->
name|nextPtr
operator|=
name|detList
expr_stmt|;
name|detList
operator|=
name|detPtr
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ReapDetachedProcs --  *  *	This procedure checks to see if any detached processes have  *	exited and, if so, it "reaps" them by officially waiting on  *	them.  It should be called "occasionally" to make sure that  *	all detached processes are eventually reaped.  *  * Results:  *	None.  *  * Side effects:  *	Processes are waited on, so that they can be reaped by the  *	system.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_ReapDetachedProcs
parameter_list|()
block|{
specifier|register
name|Detached
modifier|*
name|detPtr
decl_stmt|;
name|Detached
modifier|*
name|nextPtr
decl_stmt|,
modifier|*
name|prevPtr
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|pid
decl_stmt|;
for|for
control|(
name|detPtr
operator|=
name|detList
operator|,
name|prevPtr
operator|=
name|NULL
init|;
name|detPtr
operator|!=
name|NULL
condition|;
control|)
block|{
name|pid
operator|=
operator|(
name|int
operator|)
name|Tcl_WaitPid
argument_list|(
name|detPtr
operator|->
name|pid
argument_list|,
operator|&
name|status
argument_list|,
name|WNOHANG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pid
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|pid
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|!=
name|ECHILD
operator|)
operator|)
condition|)
block|{
name|prevPtr
operator|=
name|detPtr
expr_stmt|;
name|detPtr
operator|=
name|detPtr
operator|->
name|nextPtr
expr_stmt|;
continue|continue;
block|}
name|nextPtr
operator|=
name|detPtr
operator|->
name|nextPtr
expr_stmt|;
if|if
condition|(
name|prevPtr
operator|==
name|NULL
condition|)
block|{
name|detList
operator|=
name|detPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
name|prevPtr
operator|->
name|nextPtr
operator|=
name|detPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|detPtr
argument_list|)
expr_stmt|;
name|detPtr
operator|=
name|nextPtr
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCleanupChildren --  *  *	This is a utility procedure used to wait for child processes  *	to exit, record information about abnormal exits, and then  *	collect any stderr output generated by them.  *  * Results:  *	The return value is a standard Tcl result.  If anything at  *	weird happened with the child processes, TCL_ERROR is returned  *	and a message is left in interp->result.  *  * Side effects:  *	If the last character of interp->result is a newline, then it  *	is removed unless keepNewline is non-zero.  File errorId gets  *	closed, and pidPtr is freed back to the storage allocator.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclCleanupChildren
parameter_list|(
name|interp
parameter_list|,
name|numPids
parameter_list|,
name|pidPtr
parameter_list|,
name|errorChan
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error messages. */
name|int
name|numPids
decl_stmt|;
comment|/* Number of entries in pidPtr array. */
name|int
modifier|*
name|pidPtr
decl_stmt|;
comment|/* Array of process ids of children. */
name|Tcl_Channel
name|errorChan
decl_stmt|;
comment|/* Channel for file containing stderr output 				 * from pipeline.  NULL means there isn't any 				 * stderr output. */
block|{
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
name|int
name|i
decl_stmt|,
name|pid
decl_stmt|,
name|abnormalExit
decl_stmt|,
name|anyErrorInfo
decl_stmt|;
name|WAIT_STATUS_TYPE
name|waitStatus
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|abnormalExit
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numPids
condition|;
name|i
operator|++
control|)
block|{
name|pid
operator|=
operator|(
name|int
operator|)
name|Tcl_WaitPid
argument_list|(
name|pidPtr
index|[
name|i
index|]
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|waitStatus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|msg
operator|=
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ECHILD
condition|)
block|{
comment|/*                      * This changeup in message suggested by Mark Diekhans                      * to remind people that ECHILD errors can occur on                      * some systems if SIGCHLD isn't in its default state.                      */
name|msg
operator|=
literal|"child process lost (is SIGCHLD ignored or trapped?)"
expr_stmt|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"error waiting for process to exit: "
argument_list|,
name|msg
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* 	 * Create error messages for unusual process exits.  An 	 * extra newline gets appended to each error message, but 	 * it gets removed below (in the same fashion that an 	 * extra newline in the command's output is removed). 	 */
if|if
condition|(
operator|!
name|WIFEXITED
argument_list|(
name|waitStatus
argument_list|)
operator|||
operator|(
name|WEXITSTATUS
argument_list|(
name|waitStatus
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|char
name|msg1
index|[
literal|20
index|]
decl_stmt|,
name|msg2
index|[
literal|20
index|]
decl_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
name|sprintf
argument_list|(
name|msg1
argument_list|,
literal|"%d"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|WIFEXITED
argument_list|(
name|waitStatus
argument_list|)
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|msg2
argument_list|,
literal|"%d"
argument_list|,
name|WEXITSTATUS
argument_list|(
name|waitStatus
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"CHILDSTATUS"
argument_list|,
name|msg1
argument_list|,
name|msg2
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|abnormalExit
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|waitStatus
argument_list|)
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|Tcl_SignalMsg
argument_list|(
call|(
name|int
call|)
argument_list|(
name|WTERMSIG
argument_list|(
name|waitStatus
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"CHILDKILLED"
argument_list|,
name|msg1
argument_list|,
name|Tcl_SignalId
argument_list|(
call|(
name|int
call|)
argument_list|(
name|WTERMSIG
argument_list|(
name|waitStatus
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"child killed: "
argument_list|,
name|p
argument_list|,
literal|"\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|waitStatus
argument_list|)
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|Tcl_SignalMsg
argument_list|(
call|(
name|int
call|)
argument_list|(
name|WSTOPSIG
argument_list|(
name|waitStatus
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"CHILDSUSP"
argument_list|,
name|msg1
argument_list|,
name|Tcl_SignalId
argument_list|(
call|(
name|int
call|)
argument_list|(
name|WSTOPSIG
argument_list|(
name|waitStatus
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"child suspended: "
argument_list|,
name|p
argument_list|,
literal|"\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"child wait status didn't make sense\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/*      * Read the standard error file.  If there's anything there,      * then return an error and add the file's contents to the result      * string.      */
name|anyErrorInfo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|errorChan
operator|!=
name|NULL
condition|)
block|{
comment|/* 	 * Make sure we start at the beginning of the file. 	 */
name|Tcl_Seek
argument_list|(
name|errorChan
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
define|#
directive|define
name|BUFFER_SIZE
value|1000
name|char
name|buffer
index|[
name|BUFFER_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
name|count
operator|=
name|Tcl_Read
argument_list|(
name|errorChan
argument_list|,
name|buffer
argument_list|,
name|BUFFER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"error reading stderr output file: "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
break|break;
comment|/* out of the "while (1)" loop. */
block|}
name|buffer
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|buffer
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|anyErrorInfo
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|Tcl_Close
argument_list|(
name|NULL
argument_list|,
name|errorChan
argument_list|)
expr_stmt|;
block|}
comment|/*      * If a child exited abnormally but didn't output any error information      * at all, generate an error message here.      */
if|if
condition|(
name|abnormalExit
operator|&&
operator|!
name|anyErrorInfo
operator|&&
operator|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"child process exited abnormally"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCreatePipeline --  *  *	Given an argc/argv array, instantiate a pipeline of processes  *	as described by the argv.  *  * Results:  *	The return value is a count of the number of new processes  *	created, or -1 if an error occurred while creating the pipeline.  *	*pidArrayPtr is filled in with the address of a dynamically  *	allocated array giving the ids of all of the processes.  It  *	is up to the caller to free this array when it isn't needed  *	anymore.  If inPipePtr is non-NULL, *inPipePtr is filled in  *	with the file id for the input pipe for the pipeline (if any):  *	the caller must eventually close this file.  If outPipePtr  *	isn't NULL, then *outPipePtr is filled in with the file id  *	for the output pipe from the pipeline:  the caller must close  *	this file.  If errFilePtr isn't NULL, then *errFilePtr is filled  *	with a file id that may be used to read error output after the  *	pipeline completes.  *  * Side effects:  *	Processes and pipes are created.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclCreatePipeline
parameter_list|(
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pidArrayPtr
parameter_list|,
name|inPipePtr
parameter_list|,
name|outPipePtr
parameter_list|,
name|errFilePtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for error reporting. */
name|int
name|argc
decl_stmt|;
comment|/* Number of entries in argv. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Array of strings describing commands in 				 * pipeline plus I/O redirection with<, 				 *<<,>, etc.  Argv[argc] must be NULL. */
name|int
modifier|*
modifier|*
name|pidArrayPtr
decl_stmt|;
comment|/* Word at *pidArrayPtr gets filled in with 				 * address of array of pids for processes 				 * in pipeline (first pid is first process 				 * in pipeline). */
name|Tcl_File
modifier|*
name|inPipePtr
decl_stmt|;
comment|/* If non-NULL, input to the pipeline comes 				 * from a pipe (unless overridden by 				 * redirection in the command).  The file 				 * id with which to write to this pipe is 				 * stored at *inPipePtr.  NULL means command 				 * specified its own input source. */
name|Tcl_File
modifier|*
name|outPipePtr
decl_stmt|;
comment|/* If non-NULL, output to the pipeline goes 				 * to a pipe, unless overriden by redirection 				 * in the command.  The file id with which to 				 * read frome this pipe is stored at 				 * *outPipePtr.  NULL means command specified 				 * its own output sink. */
name|Tcl_File
modifier|*
name|errFilePtr
decl_stmt|;
comment|/* If non-NULL, all stderr output from the 				 * pipeline will go to a temporary file 				 * created here, and a descriptor to read 				 * the file will be left at *errFilePtr. 				 * The file will be removed already, so 				 * closing this descriptor will be the end 				 * of the file.  If this is NULL, then 				 * all stderr output goes to our stderr. 				 * If the pipeline specifies redirection 				 * then the file will still be created 				 * but it will never get any data. */
block|{
if|#
directive|if
name|defined
argument_list|(
name|MAC_TCL
argument_list|)
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"command pipelines not supported on Macintosh OS"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
else|#
directive|else
comment|/* !MAC_TCL */
name|int
modifier|*
name|pidPtr
init|=
name|NULL
decl_stmt|;
comment|/* Points to malloc-ed array holding all 				 * the pids of child processes. */
name|int
name|numPids
init|=
literal|0
decl_stmt|;
comment|/* Actual number of processes that exist 				 * at *pidPtr right now. */
name|int
name|cmdCount
decl_stmt|;
comment|/* Count of number of distinct commands 				 * found in argc/argv. */
name|char
modifier|*
name|input
init|=
name|NULL
decl_stmt|;
comment|/* If non-null, then this points to a 				 * string containing input data (specified 				 * via<<) to be piped to the first process 				 * in the pipeline. */
name|Tcl_File
name|inputFile
init|=
name|NULL
decl_stmt|;
comment|/* If != NULL, gives file to use as input for 				 * first process in pipeline (specified via< 				 * or<@). */
name|int
name|closeInput
init|=
literal|0
decl_stmt|;
comment|/* If non-zero, then must close inputId 				 * when cleaning up (zero means the file needs 				 * to stay open for some other reason). */
name|Tcl_File
name|outputFile
init|=
name|NULL
decl_stmt|;
comment|/* Writable file for output from last command 				 * in pipeline (could be file or pipe).  NULL 				 * means use stdout. */
name|int
name|closeOutput
init|=
literal|0
decl_stmt|;
comment|/* Non-zero means must close outputId when 				 * cleaning up (similar to closeInput). */
name|Tcl_File
name|errorFile
init|=
name|NULL
decl_stmt|;
comment|/* Writable file for error output from all 				 * commands in pipeline.  NULL means use 				 * stderr. */
name|int
name|closeError
init|=
literal|0
decl_stmt|;
comment|/* Non-zero means must close errorId when 				 * cleaning up. */
name|int
name|skip
decl_stmt|;
comment|/* Number of arguments to skip (because they 				 * specify redirection). */
name|int
name|lastBar
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|hasPipes
init|=
name|TclHasPipes
argument_list|()
decl_stmt|;
name|char
name|finalOut
index|[
name|L_tmpnam
index|]
decl_stmt|;
name|char
name|intIn
index|[
name|L_tmpnam
index|]
decl_stmt|;
name|finalOut
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|intIn
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|inPipePtr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|inPipePtr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|outPipePtr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|outPipePtr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|errFilePtr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|errFilePtr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*      * First, scan through all the arguments to figure out the structure      * of the pipeline.  Process all of the input and output redirection      * arguments and remove them from the argument list in the pipeline.      * Count the number of distinct processes (it's the number of "|"      * arguments plus one) but don't remove the "|" arguments.      */
name|cmdCount
operator|=
literal|1
expr_stmt|;
name|lastBar
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'|'
operator|)
operator|&&
operator|(
operator|(
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'&'
operator|)
operator|&&
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|==
operator|(
name|lastBar
operator|+
literal|1
operator|)
operator|)
operator|||
operator|(
name|i
operator|==
operator|(
name|argc
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"illegal use of | or |& in command"
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|lastBar
operator|=
name|i
expr_stmt|;
name|cmdCount
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
operator|(
name|inputFile
operator|!=
name|NULL
operator|)
operator|&&
name|closeInput
condition|)
block|{
name|TclCloseFile
argument_list|(
name|inputFile
argument_list|)
expr_stmt|;
block|}
name|inputFile
operator|=
name|NULL
expr_stmt|;
name|skip
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'<'
condition|)
block|{
name|input
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|input
operator|==
literal|0
condition|)
block|{
name|input
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|input
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"can't specify \""
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
literal|"\" as last word in command"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|skip
operator|=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
name|input
operator|=
literal|0
expr_stmt|;
name|inputFile
operator|=
name|FileForRedirect
argument_list|(
name|interp
argument_list|,
name|argv
index|[
name|i
index|]
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|O_RDONLY
argument_list|,
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|&
name|skip
argument_list|,
operator|&
name|closeInput
argument_list|)
expr_stmt|;
if|if
condition|(
name|inputFile
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* When Win32s dies out, this code can be removed */
if|if
condition|(
operator|!
name|hasPipes
condition|)
block|{
if|if
condition|(
operator|!
name|closeInput
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"redirection with '@'"
argument_list|,
literal|" notation is not supported on this system"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|strcpy
argument_list|(
name|intIn
argument_list|,
name|skip
operator|==
literal|1
condition|?
name|argv
index|[
name|i
index|]
operator|+
literal|1
else|:
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'>'
condition|)
block|{
name|int
name|append
decl_stmt|,
name|useForStdErr
decl_stmt|,
name|useForStdOut
decl_stmt|,
name|mustClose
decl_stmt|,
name|atOk
decl_stmt|,
name|flags
decl_stmt|;
name|Tcl_File
name|file
decl_stmt|;
name|skip
operator|=
name|atOk
operator|=
literal|1
expr_stmt|;
name|append
operator|=
name|useForStdErr
operator|=
literal|0
expr_stmt|;
name|useForStdOut
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'>'
condition|)
block|{
name|p
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
name|append
operator|=
literal|1
expr_stmt|;
name|atOk
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
name|O_WRONLY
operator||
name|O_CREAT
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
name|flags
operator|=
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'&'
condition|)
block|{
name|useForStdErr
operator|=
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|file
operator|=
name|FileForRedirect
argument_list|(
name|interp
argument_list|,
name|p
argument_list|,
name|atOk
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|flags
argument_list|,
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|&
name|skip
argument_list|,
operator|&
name|mustClose
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* When Win32s dies out, this code can be removed */
if|if
condition|(
operator|!
name|hasPipes
condition|)
block|{
if|if
condition|(
operator|!
name|mustClose
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"redirection with '@'"
argument_list|,
literal|" notation is not supported on this system"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|strcpy
argument_list|(
name|finalOut
argument_list|,
name|skip
operator|==
literal|1
condition|?
name|p
else|:
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hasPipes
operator|&&
name|append
condition|)
block|{
name|TclSeekFile
argument_list|(
name|file
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * Got the file descriptor.  Now use it for standard output, 	     * standard error, or both, depending on the redirection. 	     */
if|if
condition|(
name|useForStdOut
condition|)
block|{
if|if
condition|(
operator|(
name|outputFile
operator|!=
name|NULL
operator|)
operator|&&
name|closeOutput
condition|)
block|{
name|TclCloseFile
argument_list|(
name|outputFile
argument_list|)
expr_stmt|;
block|}
name|outputFile
operator|=
name|file
expr_stmt|;
name|closeOutput
operator|=
name|mustClose
expr_stmt|;
block|}
if|if
condition|(
name|useForStdErr
condition|)
block|{
if|if
condition|(
operator|(
name|errorFile
operator|!=
name|NULL
operator|)
operator|&&
name|closeError
condition|)
block|{
name|TclCloseFile
argument_list|(
name|errorFile
argument_list|)
expr_stmt|;
block|}
name|errorFile
operator|=
name|file
expr_stmt|;
name|closeError
operator|=
operator|(
name|useForStdOut
operator|)
condition|?
literal|0
else|:
name|mustClose
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'2'
operator|)
operator|&&
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'>'
operator|)
condition|)
block|{
name|int
name|append
decl_stmt|,
name|atOk
decl_stmt|,
name|flags
decl_stmt|;
if|if
condition|(
operator|(
name|errorFile
operator|!=
name|NULL
operator|)
operator|&&
name|closeError
condition|)
block|{
name|TclCloseFile
argument_list|(
name|errorFile
argument_list|)
expr_stmt|;
block|}
name|skip
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'>'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|append
operator|=
literal|1
expr_stmt|;
name|atOk
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
name|O_WRONLY
operator||
name|O_CREAT
expr_stmt|;
block|}
else|else
block|{
name|append
operator|=
literal|0
expr_stmt|;
name|atOk
operator|=
literal|1
expr_stmt|;
name|flags
operator|=
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
expr_stmt|;
block|}
name|errorFile
operator|=
name|FileForRedirect
argument_list|(
name|interp
argument_list|,
name|p
argument_list|,
name|atOk
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|flags
argument_list|,
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|&
name|skip
argument_list|,
operator|&
name|closeError
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorFile
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|hasPipes
operator|&&
name|append
condition|)
block|{
name|TclSeekFile
argument_list|(
name|errorFile
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
continue|continue;
block|}
for|for
control|(
name|j
operator|=
name|i
operator|+
name|skip
init|;
name|j
operator|<
name|argc
condition|;
name|j
operator|++
control|)
block|{
name|argv
index|[
name|j
operator|-
name|skip
index|]
operator|=
name|argv
index|[
name|j
index|]
expr_stmt|;
block|}
name|argc
operator|-=
name|skip
expr_stmt|;
name|i
operator|-=
literal|1
expr_stmt|;
comment|/* Process next arg from same position. */
block|}
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|interp
operator|->
name|result
operator|=
literal|"didn't specify command to execute"
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|hasPipes
operator|&&
name|inputFile
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|!
name|hasPipes
operator|&&
name|intIn
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
name|input
operator|!=
name|NULL
condition|)
block|{
comment|/* 	     * The input for the first process is immediate data coming from 	     * Tcl.  Create a temporary file for it and put the data into the 	     * file. 	     */
name|inputFile
operator|=
name|TclCreateTempFile
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|closeInput
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|inputFile
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't create input file for command: "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|inPipePtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_File
name|inPipe
decl_stmt|,
name|outPipe
decl_stmt|;
comment|/* 	     * The input for the first process in the pipeline is to 	     * come from a pipe that can be written from this end. 	     */
if|if
condition|(
operator|!
name|hasPipes
operator|||
name|TclCreatePipe
argument_list|(
operator|&
name|inPipe
argument_list|,
operator|&
name|outPipe
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't create input pipe for command: "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|inputFile
operator|=
name|inPipe
expr_stmt|;
name|closeInput
operator|=
literal|1
expr_stmt|;
operator|*
name|inPipePtr
operator|=
name|outPipe
expr_stmt|;
block|}
block|}
comment|/*      * Set up a pipe to receive output from the pipeline, if no other      * output sink has been specified.      */
if|if
condition|(
operator|(
name|outputFile
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|outPipePtr
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|hasPipes
condition|)
block|{
name|tmpnam
argument_list|(
name|finalOut
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_File
name|inPipe
decl_stmt|,
name|outPipe
decl_stmt|;
if|if
condition|(
name|TclCreatePipe
argument_list|(
operator|&
name|inPipe
argument_list|,
operator|&
name|outPipe
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't create output pipe for command: "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|outputFile
operator|=
name|outPipe
expr_stmt|;
name|closeOutput
operator|=
literal|1
expr_stmt|;
operator|*
name|outPipePtr
operator|=
name|inPipe
expr_stmt|;
block|}
block|}
comment|/*      * Set up the standard error output sink for the pipeline, if      * requested.  Use a temporary file which is opened, then deleted.      * Could potentially just use pipe, but if it filled up it could      * cause the pipeline to deadlock:  we'd be waiting for processes      * to complete before reading stderr, and processes couldn't complete      * because stderr was backed up.      */
if|if
condition|(
name|errFilePtr
operator|&&
operator|!
name|errorFile
condition|)
block|{
operator|*
name|errFilePtr
operator|=
name|TclCreateTempFile
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|errFilePtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't create error file for command: "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|errorFile
operator|=
operator|*
name|errFilePtr
expr_stmt|;
name|closeError
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * Scan through the argc array, forking off a process for each      * group of arguments between "|" arguments.      */
name|pidPtr
operator|=
operator|(
name|int
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|cmdCount
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ReapDetachedProcs
argument_list|()
expr_stmt|;
if|if
condition|(
name|TclSpawnPipeline
argument_list|(
name|interp
argument_list|,
name|pidPtr
argument_list|,
operator|&
name|numPids
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|inputFile
argument_list|,
name|outputFile
argument_list|,
name|errorFile
argument_list|,
name|intIn
argument_list|,
name|finalOut
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
operator|*
name|pidArrayPtr
operator|=
name|pidPtr
expr_stmt|;
comment|/*      * All done.  Cleanup open files lying around and then return.      */
name|cleanup
label|:
if|if
condition|(
operator|(
name|inputFile
operator|!=
name|NULL
operator|)
operator|&&
name|closeInput
condition|)
block|{
name|TclCloseFile
argument_list|(
name|inputFile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|outputFile
operator|!=
name|NULL
operator|)
operator|&&
name|closeOutput
condition|)
block|{
name|TclCloseFile
argument_list|(
name|outputFile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|errorFile
operator|!=
name|NULL
operator|)
operator|&&
name|closeError
condition|)
block|{
name|TclCloseFile
argument_list|(
name|errorFile
argument_list|)
expr_stmt|;
block|}
return|return
name|numPids
return|;
comment|/*      * An error occurred.  There could have been extra files open, such      * as pipes between children.  Clean them all up.  Detach any child      * processes that have been created.      */
name|error
label|:
if|if
condition|(
operator|(
name|inPipePtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|inPipePtr
operator|!=
name|NULL
operator|)
condition|)
block|{
name|TclCloseFile
argument_list|(
operator|*
name|inPipePtr
argument_list|)
expr_stmt|;
operator|*
name|inPipePtr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|outPipePtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|outPipePtr
operator|!=
name|NULL
operator|)
condition|)
block|{
name|TclCloseFile
argument_list|(
operator|*
name|outPipePtr
argument_list|)
expr_stmt|;
operator|*
name|outPipePtr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|errFilePtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|errFilePtr
operator|!=
name|NULL
operator|)
condition|)
block|{
name|TclCloseFile
argument_list|(
operator|*
name|errFilePtr
argument_list|)
expr_stmt|;
operator|*
name|errFilePtr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pidPtr
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numPids
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pidPtr
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|Tcl_DetachPids
argument_list|(
literal|1
argument_list|,
operator|&
name|pidPtr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pidPtr
argument_list|)
expr_stmt|;
block|}
name|numPids
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|cleanup
goto|;
endif|#
directive|endif
comment|/* !MAC_TCL */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetErrno --  *  *	Gets the current value of the Tcl error code variable. This is  *	currently the global variable "errno" but could in the future  *	change to something else.  *  * Results:  *	The value of the Tcl error code variable.  *  * Side effects:  *	None. Note that the value of the Tcl error code variable is  *	UNDEFINED if a call to Tcl_SetErrno did not precede this call.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_GetErrno
parameter_list|()
block|{
return|return
name|errno
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetErrno --  *  *	Sets the Tcl error code variable to the supplied value.  *  * Results:  *	None.  *  * Side effects:  *	Modifies the value of the Tcl error code variable.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_SetErrno
parameter_list|(
name|err
parameter_list|)
name|int
name|err
decl_stmt|;
comment|/* The new value. */
block|{
name|errno
operator|=
name|err
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_PosixError --  *  *	This procedure is typically called after UNIX kernel calls  *	return errors.  It stores machine-readable information about  *	the error in $errorCode returns an information string for  *	the caller's use.  *  * Results:  *	The return value is a human-readable string describing the  *	error.  *  * Side effects:  *	The global variable $errorCode is reset.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_PosixError
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter whose $errorCode variable 				 * is to be changed. */
block|{
name|char
modifier|*
name|id
decl_stmt|,
modifier|*
name|msg
decl_stmt|;
name|msg
operator|=
name|Tcl_ErrnoMsg
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|id
operator|=
name|Tcl_ErrnoId
argument_list|()
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"POSIX"
argument_list|,
name|id
argument_list|,
name|msg
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|msg
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_OpenCommandChannel --  *  *	Opens an I/O channel to one or more subprocesses specified  *	by argc and argv.  The flags argument determines the  *	disposition of the stdio handles.  If the TCL_STDIN flag is  *	set then the standard input for the first subprocess will  *	be tied to the channel:  writing to the channel will provide  *	input to the subprocess.  If TCL_STDIN is not set, then  *	standard input for the first subprocess will be the same as  *	this application's standard input.  If TCL_STDOUT is set then  *	standard output from the last subprocess can be read from the  *	channel;  otherwise it goes to this application's standard  *	output.  If TCL_STDERR is set, standard error output for all  *	subprocesses is returned to the channel and results in an error  *	when the channel is closed;  otherwise it goes to this  *	application's standard error.  If TCL_ENFORCE_MODE is not set,  *	then argc and argv can redirect the stdio handles to override  *	TCL_STDIN, TCL_STDOUT, and TCL_STDERR;  if it is set, then it   *	is an error for argc and argv to override stdio channels for  *	which TCL_STDIN, TCL_STDOUT, and TCL_STDERR have been set.  *  * Results:  *	A new command channel, or NULL on failure with an error  *	message left in interp.  *  * Side effects:  *	Creates processes, opens pipes.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Channel
name|Tcl_OpenCommandChannel
parameter_list|(
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|flags
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter for error reporting. Can                                  * NOT be NULL. */
name|int
name|argc
decl_stmt|;
comment|/* How many arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Array of arguments for command pipe. */
name|int
name|flags
decl_stmt|;
comment|/* Or'ed combination of TCL_STDIN, TCL_STDOUT, 				 * TCL_STDERR, and TCL_ENFORCE_MODE. */
block|{
name|Tcl_File
modifier|*
name|inPipePtr
decl_stmt|,
modifier|*
name|outPipePtr
decl_stmt|,
modifier|*
name|errFilePtr
decl_stmt|;
name|Tcl_File
name|inPipe
decl_stmt|,
name|outPipe
decl_stmt|,
name|errFile
decl_stmt|;
name|int
name|numPids
decl_stmt|,
modifier|*
name|pidPtr
decl_stmt|;
name|Tcl_Channel
name|channel
decl_stmt|;
name|inPipe
operator|=
name|outPipe
operator|=
name|errFile
operator|=
name|NULL
expr_stmt|;
name|inPipePtr
operator|=
operator|(
name|flags
operator|&
name|TCL_STDIN
operator|)
condition|?
operator|&
name|inPipe
else|:
name|NULL
expr_stmt|;
name|outPipePtr
operator|=
operator|(
name|flags
operator|&
name|TCL_STDOUT
operator|)
condition|?
operator|&
name|outPipe
else|:
name|NULL
expr_stmt|;
name|errFilePtr
operator|=
operator|(
name|flags
operator|&
name|TCL_STDERR
operator|)
condition|?
operator|&
name|errFile
else|:
name|NULL
expr_stmt|;
name|numPids
operator|=
name|TclCreatePipeline
argument_list|(
name|interp
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|pidPtr
argument_list|,
name|inPipePtr
argument_list|,
name|outPipePtr
argument_list|,
name|errFilePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|numPids
operator|<
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/*      * Verify that the pipes that were created satisfy the      * readable/writable constraints.       */
if|if
condition|(
name|flags
operator|&
name|TCL_ENFORCE_MODE
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|TCL_STDOUT
operator|)
operator|&&
operator|(
name|outPipe
operator|==
name|NULL
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"can't read output from command:"
argument_list|,
literal|" standard output was redirected"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|TCL_STDIN
operator|)
operator|&&
operator|(
name|inPipe
operator|==
name|NULL
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"can't write input to command:"
argument_list|,
literal|" standard input was redirected"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
name|channel
operator|=
name|TclCreateCommandChannel
argument_list|(
name|outPipe
argument_list|,
name|inPipe
argument_list|,
name|errFile
argument_list|,
name|numPids
argument_list|,
name|pidPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"pipe for command could not be created"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
return|return
name|channel
return|;
name|error
label|:
if|if
condition|(
name|numPids
operator|>
literal|0
condition|)
block|{
name|Tcl_DetachPids
argument_list|(
name|numPids
argument_list|,
name|pidPtr
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pidPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inPipe
operator|!=
name|NULL
condition|)
block|{
name|TclClosePipeFile
argument_list|(
name|inPipe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outPipe
operator|!=
name|NULL
condition|)
block|{
name|TclClosePipeFile
argument_list|(
name|outPipe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errFile
operator|!=
name|NULL
condition|)
block|{
name|TclClosePipeFile
argument_list|(
name|errFile
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

end_unit

