begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclIOUtil.c --  *  *	This file contains a collection of utility procedures that  *	are shared by the platform specific IO drivers.  *  *	Parts of this file are based on code contributed by Karl  *	Lehenbauer, Mark Diekhans and Peter da Silva.  *  * Copyright (c) 1991-1994 The Regents of the University of California.  * Copyright (c) 1994-1996 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclIOUtil.c 1.132 97/04/23 16:21:42  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclGetOpenMode --  *  * Description:  *	Computes a POSIX mode mask for opening a file, from a given string,  *	and also sets a flag to indicate whether the caller should seek to  *	EOF after opening the file.  *  * Results:  *	On success, returns mode to pass to "open". If an error occurs, the  *	returns -1 and if interp is not NULL, sets interp->result to an  *	error message.  *  * Side effects:  *	Sets the integer referenced by seekFlagPtr to 1 to tell the caller  *	to seek to EOF after opening the file.  *  * Special note:  *	This code is based on a prototype implementation contributed  *	by Mark Diekhans.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclGetOpenMode
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|seekFlagPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for error 					 * reporting - may be NULL. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Mode string, e.g. "r+" or 					 * "RDONLY CREAT". */
name|int
modifier|*
name|seekFlagPtr
decl_stmt|;
comment|/* Set this to 1 if the caller                                          * should seek to EOF during the                                          * opening of the file. */
block|{
name|int
name|mode
decl_stmt|,
name|modeArgc
decl_stmt|,
name|c
decl_stmt|,
name|i
decl_stmt|,
name|gotRW
decl_stmt|;
name|char
modifier|*
modifier|*
name|modeArgv
decl_stmt|,
modifier|*
name|flag
decl_stmt|;
define|#
directive|define
name|RW_MODES
value|(O_RDONLY|O_WRONLY|O_RDWR)
comment|/*      * Check for the simpler fopen-like access modes (e.g. "r").  They      * are distinguished from the POSIX access modes by the presence      * of a lower-case first letter.      */
operator|*
name|seekFlagPtr
operator|=
literal|0
expr_stmt|;
name|mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|islower
argument_list|(
name|UCHAR
argument_list|(
name|string
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|string
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'r'
case|:
name|mode
operator|=
name|O_RDONLY
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|mode
operator|=
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|mode
operator|=
name|O_WRONLY
operator||
name|O_CREAT
expr_stmt|;
operator|*
name|seekFlagPtr
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|error
label|:
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"illegal access mode \""
argument_list|,
name|string
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|string
index|[
literal|1
index|]
operator|==
literal|'+'
condition|)
block|{
name|mode
operator|&=
operator|~
operator|(
name|O_RDONLY
operator||
name|O_WRONLY
operator|)
expr_stmt|;
name|mode
operator||=
name|O_RDWR
expr_stmt|;
if|if
condition|(
name|string
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|string
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
return|return
name|mode
return|;
block|}
comment|/*      * The access modes are specified using a list of POSIX modes      * such as O_CREAT.      *      * IMPORTANT NOTE: We rely on Tcl_SplitList working correctly when      * a NULL interpreter is passed in.      */
if|if
condition|(
name|Tcl_SplitList
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
operator|&
name|modeArgc
argument_list|,
operator|&
name|modeArgv
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
literal|"\n    while processing open access modes \""
argument_list|)
expr_stmt|;
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
name|gotRW
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modeArgc
condition|;
name|i
operator|++
control|)
block|{
name|flag
operator|=
name|modeArgv
index|[
name|i
index|]
expr_stmt|;
name|c
operator|=
name|flag
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'R'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|flag
argument_list|,
literal|"RDONLY"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mode
operator|=
operator|(
name|mode
operator|&
operator|~
name|RW_MODES
operator|)
operator||
name|O_RDONLY
expr_stmt|;
name|gotRW
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'W'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|flag
argument_list|,
literal|"WRONLY"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mode
operator|=
operator|(
name|mode
operator|&
operator|~
name|RW_MODES
operator|)
operator||
name|O_WRONLY
expr_stmt|;
name|gotRW
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'R'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|flag
argument_list|,
literal|"RDWR"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mode
operator|=
operator|(
name|mode
operator|&
operator|~
name|RW_MODES
operator|)
operator||
name|O_RDWR
expr_stmt|;
name|gotRW
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'A'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|flag
argument_list|,
literal|"APPEND"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mode
operator||=
name|O_APPEND
expr_stmt|;
operator|*
name|seekFlagPtr
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'C'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|flag
argument_list|,
literal|"CREAT"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mode
operator||=
name|O_CREAT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'E'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|flag
argument_list|,
literal|"EXCL"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mode
operator||=
name|O_EXCL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'N'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|flag
argument_list|,
literal|"NOCTTY"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|O_NOCTTY
name|mode
operator||=
name|O_NOCTTY
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"access mode \""
argument_list|,
name|flag
argument_list|,
literal|"\" not supported by this system"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|modeArgv
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'N'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|flag
argument_list|,
literal|"NONBLOCK"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|O_NDELAY
argument_list|)
operator|||
name|defined
argument_list|(
name|O_NONBLOCK
argument_list|)
ifdef|#
directive|ifdef
name|O_NONBLOCK
name|mode
operator||=
name|O_NONBLOCK
expr_stmt|;
else|#
directive|else
name|mode
operator||=
name|O_NDELAY
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"access mode \""
argument_list|,
name|flag
argument_list|,
literal|"\" not supported by this system"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|modeArgv
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'T'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|flag
argument_list|,
literal|"TRUNC"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mode
operator||=
name|O_TRUNC
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"invalid access mode \""
argument_list|,
name|flag
argument_list|,
literal|"\": must be RDONLY, WRONLY, RDWR, APPEND, CREAT"
argument_list|,
literal|" EXCL, NOCTTY, NONBLOCK, or TRUNC"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|modeArgv
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|modeArgv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gotRW
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"access mode must include either"
argument_list|,
literal|" RDONLY, WRONLY, or RDWR"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
return|return
name|mode
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_EvalFile --  *  *	Read in a file and process the entire file as one gigantic  *	Tcl command.  *  * Results:  *	A standard Tcl result, which is either the result of executing  *	the file or an error indicating why the file couldn't be read.  *  * Side effects:  *	Depends on the commands in the file.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_EvalFile
parameter_list|(
name|interp
parameter_list|,
name|fileName
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to process file. */
name|char
modifier|*
name|fileName
decl_stmt|;
comment|/* Name of file to process.  Tilde-substitution 				 * will be performed on this name. */
block|{
name|int
name|result
decl_stmt|;
name|struct
name|stat
name|statBuf
decl_stmt|;
name|char
modifier|*
name|cmdBuffer
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|char
modifier|*
name|oldScriptFile
decl_stmt|;
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Tcl_DString
name|buffer
decl_stmt|;
name|char
modifier|*
name|nativeName
decl_stmt|;
name|Tcl_Channel
name|chan
decl_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|oldScriptFile
operator|=
name|iPtr
operator|->
name|scriptFile
expr_stmt|;
name|iPtr
operator|->
name|scriptFile
operator|=
name|fileName
expr_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|nativeName
operator|=
name|Tcl_TranslateFileName
argument_list|(
name|interp
argument_list|,
name|fileName
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|nativeName
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/*      * If Tcl_TranslateFileName didn't already copy the file name, do it      * here.  This way we don't depend on fileName staying constant      * throughout the execution of the script (e.g., what if it happens      * to point to a Tcl variable that the script could change?).      */
if|if
condition|(
name|nativeName
operator|!=
name|Tcl_DStringValue
argument_list|(
operator|&
name|buffer
argument_list|)
condition|)
block|{
name|Tcl_DStringSetLength
argument_list|(
operator|&
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|buffer
argument_list|,
name|nativeName
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|nativeName
operator|=
name|Tcl_DStringValue
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|nativeName
argument_list|,
operator|&
name|statBuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't read file \""
argument_list|,
name|fileName
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|chan
operator|=
name|Tcl_OpenFileChannel
argument_list|(
name|interp
argument_list|,
name|nativeName
argument_list|,
literal|"r"
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't read file \""
argument_list|,
name|fileName
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|cmdBuffer
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|statBuf
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_Read
argument_list|(
name|chan
argument_list|,
name|cmdBuffer
argument_list|,
name|statBuf
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
name|Tcl_Close
argument_list|(
name|interp
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't read file \""
argument_list|,
name|fileName
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|cmdBuffer
index|[
name|result
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Tcl_Close
argument_list|(
name|interp
argument_list|,
name|chan
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|result
operator|=
name|Tcl_Eval
argument_list|(
name|interp
argument_list|,
name|cmdBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|TCL_RETURN
condition|)
block|{
name|result
operator|=
name|TclUpdateReturnInfo
argument_list|(
name|iPtr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|TCL_ERROR
condition|)
block|{
name|char
name|msg
index|[
literal|200
index|]
decl_stmt|;
comment|/* 	 * Record information telling where the error occurred. 	 */
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"\n    (file \"%.150s\" line %d)"
argument_list|,
name|fileName
argument_list|,
name|interp
operator|->
name|errorLine
argument_list|)
expr_stmt|;
name|Tcl_AddErrorInfo
argument_list|(
name|interp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
name|iPtr
operator|->
name|scriptFile
operator|=
name|oldScriptFile
expr_stmt|;
name|ckfree
argument_list|(
name|cmdBuffer
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
return|return
name|result
return|;
name|error
label|:
if|if
condition|(
name|cmdBuffer
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|cmdBuffer
argument_list|)
expr_stmt|;
block|}
name|iPtr
operator|->
name|scriptFile
operator|=
name|oldScriptFile
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetErrno --  *  *	Gets the current value of the Tcl error code variable. This is  *	currently the global variable "errno" but could in the future  *	change to something else.  *  * Results:  *	The value of the Tcl error code variable.  *  * Side effects:  *	None. Note that the value of the Tcl error code variable is  *	UNDEFINED if a call to Tcl_SetErrno did not precede this call.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_GetErrno
parameter_list|()
block|{
return|return
name|errno
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetErrno --  *  *	Sets the Tcl error code variable to the supplied value.  *  * Results:  *	None.  *  * Side effects:  *	Modifies the value of the Tcl error code variable.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_SetErrno
parameter_list|(
name|err
parameter_list|)
name|int
name|err
decl_stmt|;
comment|/* The new value. */
block|{
name|errno
operator|=
name|err
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_PosixError --  *  *	This procedure is typically called after UNIX kernel calls  *	return errors.  It stores machine-readable information about  *	the error in $errorCode returns an information string for  *	the caller's use.  *  * Results:  *	The return value is a human-readable string describing the  *	error.  *  * Side effects:  *	The global variable $errorCode is reset.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_PosixError
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter whose $errorCode variable 				 * is to be changed. */
block|{
name|char
modifier|*
name|id
decl_stmt|,
modifier|*
name|msg
decl_stmt|;
name|msg
operator|=
name|Tcl_ErrnoMsg
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|id
operator|=
name|Tcl_ErrnoId
argument_list|()
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"POSIX"
argument_list|,
name|id
argument_list|,
name|msg
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|msg
return|;
block|}
end_function

end_unit

