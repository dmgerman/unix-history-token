begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclDate.c --  *  *	This file is generated from a yacc grammar defined in  *	the file tclGetDate.y.  It should not be edited directly.  *  * Copyright (c) 1992-1995 Karl Lehenbauer and Mark Diekhans.  * Copyright (c) 1995-1997 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * @(#) tclDate.c 1.32 97/02/03 14:54:37  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MAC_TCL
end_ifdef

begin_define
define|#
directive|define
name|EPOCH
value|1904
end_define

begin_define
define|#
directive|define
name|START_OF_TIME
value|1904
end_define

begin_define
define|#
directive|define
name|END_OF_TIME
value|2039
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|EPOCH
value|1970
end_define

begin_define
define|#
directive|define
name|START_OF_TIME
value|1902
end_define

begin_define
define|#
directive|define
name|END_OF_TIME
value|2037
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The offset of tm_year of struct tm returned by localtime, gmtime, etc.  * I don't know how universal this is; K&R II, the NetBSD manpages, and  * ../compat/strftime.c all agree that tm_year is the year-1900.  However,  * some systems may have a different value.  This #define should be the  * same as in ../compat/strftime.c.  */
end_comment

begin_define
define|#
directive|define
name|TM_YEAR_BASE
value|1900
end_define

begin_define
define|#
directive|define
name|HOUR
parameter_list|(
name|x
parameter_list|)
value|((int) (60 * x))
end_define

begin_define
define|#
directive|define
name|SECSPERDAY
value|(24L * 60L * 60L)
end_define

begin_comment
comment|/*  *  An entry in the lexical lookup table.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_TABLE
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|type
decl_stmt|;
name|time_t
name|value
decl_stmt|;
block|}
name|TABLE
typedef|;
end_typedef

begin_comment
comment|/*  *  Daylight-savings mode:  on, off, or not yet known.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|_DSTMODE
block|{
name|DSTon
block|,
name|DSToff
block|,
name|DSTmaybe
block|}
name|DSTMODE
typedef|;
end_typedef

begin_comment
comment|/*  *  Meridian:  am, pm, or 24-hour style.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|_MERIDIAN
block|{
name|MERam
block|,
name|MERpm
block|,
name|MER24
block|}
name|MERIDIAN
typedef|;
end_typedef

begin_comment
comment|/*  *  Global variables.  We could get rid of most of these by using a good  *  union as the yacc stack.  (This routine was originally written before  *  yacc had the %union construct.)  Maybe someday; right now we only use  *  the %union very rarely.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|TclDateInput
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|DSTMODE
name|TclDateDSTmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|TclDateDayOrdinal
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|TclDateDayNumber
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TclDateHaveDate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TclDateHaveDay
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TclDateHaveRel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TclDateHaveTime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TclDateHaveZone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|TclDateTimezone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|TclDateDay
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|TclDateHour
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|TclDateMinutes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|TclDateMonth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|TclDateSeconds
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|TclDateYear
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|MERIDIAN
name|TclDateMeridian
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|TclDateRelMonth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|TclDateRelSeconds
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Prototypes of internal functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|TclDateerror
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|ToSeconds
name|_ANSI_ARGS_
argument_list|(
operator|(
name|time_t
name|Hours
operator|,
name|time_t
name|Minutes
operator|,
name|time_t
name|Seconds
operator|,
name|MERIDIAN
name|Meridian
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Convert
name|_ANSI_ARGS_
argument_list|(
operator|(
name|time_t
name|Month
operator|,
name|time_t
name|Day
operator|,
name|time_t
name|Year
operator|,
name|time_t
name|Hours
operator|,
name|time_t
name|Minutes
operator|,
name|time_t
name|Seconds
operator|,
name|MERIDIAN
name|Meridia
operator|,
name|DSTMODE
name|DSTmode
operator|,
name|time_t
operator|*
name|TimePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|DSTcorrect
name|_ANSI_ARGS_
argument_list|(
operator|(
name|time_t
name|Start
operator|,
name|time_t
name|Future
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|RelativeDate
name|_ANSI_ARGS_
argument_list|(
operator|(
name|time_t
name|Start
operator|,
name|time_t
name|DayOrdinal
operator|,
name|time_t
name|DayNumber
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|RelativeMonth
name|_ANSI_ARGS_
argument_list|(
operator|(
name|time_t
name|Start
operator|,
name|time_t
name|RelMonth
operator|,
name|time_t
operator|*
name|TimePtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|LookupWord
name|_ANSI_ARGS_
argument_list|(
operator|(
name|char
operator|*
name|buff
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TclDatelex
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|TclDateparse
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
union|union
ifdef|#
directive|ifdef
name|__cplusplus
name|YYSTYPE
endif|#
directive|endif
block|{
name|time_t
name|Number
decl_stmt|;
name|enum
name|_MERIDIAN
name|Meridian
decl_stmt|;
block|}
name|YYSTYPE
typedef|;
end_typedef

begin_define
define|#
directive|define
name|tAGO
value|257
end_define

begin_define
define|#
directive|define
name|tDAY
value|258
end_define

begin_define
define|#
directive|define
name|tDAYZONE
value|259
end_define

begin_define
define|#
directive|define
name|tID
value|260
end_define

begin_define
define|#
directive|define
name|tMERIDIAN
value|261
end_define

begin_define
define|#
directive|define
name|tMINUTE_UNIT
value|262
end_define

begin_define
define|#
directive|define
name|tMONTH
value|263
end_define

begin_define
define|#
directive|define
name|tMONTH_UNIT
value|264
end_define

begin_define
define|#
directive|define
name|tSEC_UNIT
value|265
end_define

begin_define
define|#
directive|define
name|tSNUMBER
value|266
end_define

begin_define
define|#
directive|define
name|tUNUMBER
value|267
end_define

begin_define
define|#
directive|define
name|tZONE
value|268
end_define

begin_define
define|#
directive|define
name|tEPOCH
value|269
end_define

begin_define
define|#
directive|define
name|tDST
value|270
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|TclDateerror
end_ifndef

begin_function_decl
name|void
name|TclDateerror
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TclDatelex
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__EXTERN_C__
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
name|int
name|TclDatelex
parameter_list|(
name|void
parameter_list|)
function_decl|;
block|}
end_extern

begin_else
else|#
directive|else
end_else

begin_function_decl
name|int
name|TclDatelex
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|int
name|TclDateparse
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TclDateclearin
value|TclDatechar = -1
end_define

begin_define
define|#
directive|define
name|TclDateerrok
value|TclDateerrflag = 0
end_define

begin_decl_stmt
specifier|extern
name|int
name|TclDatechar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|TclDateerrflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YYSTYPE
name|TclDatelval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YYSTYPE
name|TclDateval
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|int
name|TclDatetabelem
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|YYMAXDEPTH
end_ifndef

begin_define
define|#
directive|define
name|YYMAXDEPTH
value|150
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|YYMAXDEPTH
operator|>
literal|0
end_if

begin_decl_stmt
name|int
name|TclDate_TclDates
index|[
name|YYMAXDEPTH
index|]
decl_stmt|,
modifier|*
name|TclDates
init|=
name|TclDate_TclDates
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YYSTYPE
name|TclDate_TclDatev
index|[
name|YYMAXDEPTH
index|]
decl_stmt|,
modifier|*
name|TclDatev
init|=
name|TclDate_TclDatev
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* user does initial allocation */
end_comment

begin_decl_stmt
name|int
modifier|*
name|TclDates
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YYSTYPE
modifier|*
name|TclDatev
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|TclDatemaxdepth
init|=
name|YYMAXDEPTH
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|YYERRCODE
value|256
end_define

begin_comment
comment|/*  * Month and day table.  */
end_comment

begin_decl_stmt
specifier|static
name|TABLE
name|MonthDayTable
index|[]
init|=
block|{
block|{
literal|"january"
block|,
name|tMONTH
block|,
literal|1
block|}
block|,
block|{
literal|"february"
block|,
name|tMONTH
block|,
literal|2
block|}
block|,
block|{
literal|"march"
block|,
name|tMONTH
block|,
literal|3
block|}
block|,
block|{
literal|"april"
block|,
name|tMONTH
block|,
literal|4
block|}
block|,
block|{
literal|"may"
block|,
name|tMONTH
block|,
literal|5
block|}
block|,
block|{
literal|"june"
block|,
name|tMONTH
block|,
literal|6
block|}
block|,
block|{
literal|"july"
block|,
name|tMONTH
block|,
literal|7
block|}
block|,
block|{
literal|"august"
block|,
name|tMONTH
block|,
literal|8
block|}
block|,
block|{
literal|"september"
block|,
name|tMONTH
block|,
literal|9
block|}
block|,
block|{
literal|"sept"
block|,
name|tMONTH
block|,
literal|9
block|}
block|,
block|{
literal|"october"
block|,
name|tMONTH
block|,
literal|10
block|}
block|,
block|{
literal|"november"
block|,
name|tMONTH
block|,
literal|11
block|}
block|,
block|{
literal|"december"
block|,
name|tMONTH
block|,
literal|12
block|}
block|,
block|{
literal|"sunday"
block|,
name|tDAY
block|,
literal|0
block|}
block|,
block|{
literal|"monday"
block|,
name|tDAY
block|,
literal|1
block|}
block|,
block|{
literal|"tuesday"
block|,
name|tDAY
block|,
literal|2
block|}
block|,
block|{
literal|"tues"
block|,
name|tDAY
block|,
literal|2
block|}
block|,
block|{
literal|"wednesday"
block|,
name|tDAY
block|,
literal|3
block|}
block|,
block|{
literal|"wednes"
block|,
name|tDAY
block|,
literal|3
block|}
block|,
block|{
literal|"thursday"
block|,
name|tDAY
block|,
literal|4
block|}
block|,
block|{
literal|"thur"
block|,
name|tDAY
block|,
literal|4
block|}
block|,
block|{
literal|"thurs"
block|,
name|tDAY
block|,
literal|4
block|}
block|,
block|{
literal|"friday"
block|,
name|tDAY
block|,
literal|5
block|}
block|,
block|{
literal|"saturday"
block|,
name|tDAY
block|,
literal|6
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Time units table.  */
end_comment

begin_decl_stmt
specifier|static
name|TABLE
name|UnitsTable
index|[]
init|=
block|{
block|{
literal|"year"
block|,
name|tMONTH_UNIT
block|,
literal|12
block|}
block|,
block|{
literal|"month"
block|,
name|tMONTH_UNIT
block|,
literal|1
block|}
block|,
block|{
literal|"fortnight"
block|,
name|tMINUTE_UNIT
block|,
literal|14
operator|*
literal|24
operator|*
literal|60
block|}
block|,
block|{
literal|"week"
block|,
name|tMINUTE_UNIT
block|,
literal|7
operator|*
literal|24
operator|*
literal|60
block|}
block|,
block|{
literal|"day"
block|,
name|tMINUTE_UNIT
block|,
literal|1
operator|*
literal|24
operator|*
literal|60
block|}
block|,
block|{
literal|"hour"
block|,
name|tMINUTE_UNIT
block|,
literal|60
block|}
block|,
block|{
literal|"minute"
block|,
name|tMINUTE_UNIT
block|,
literal|1
block|}
block|,
block|{
literal|"min"
block|,
name|tMINUTE_UNIT
block|,
literal|1
block|}
block|,
block|{
literal|"second"
block|,
name|tSEC_UNIT
block|,
literal|1
block|}
block|,
block|{
literal|"sec"
block|,
name|tSEC_UNIT
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Assorted relative-time words.  */
end_comment

begin_decl_stmt
specifier|static
name|TABLE
name|OtherTable
index|[]
init|=
block|{
block|{
literal|"tomorrow"
block|,
name|tMINUTE_UNIT
block|,
literal|1
operator|*
literal|24
operator|*
literal|60
block|}
block|,
block|{
literal|"yesterday"
block|,
name|tMINUTE_UNIT
block|,
operator|-
literal|1
operator|*
literal|24
operator|*
literal|60
block|}
block|,
block|{
literal|"today"
block|,
name|tMINUTE_UNIT
block|,
literal|0
block|}
block|,
block|{
literal|"now"
block|,
name|tMINUTE_UNIT
block|,
literal|0
block|}
block|,
block|{
literal|"last"
block|,
name|tUNUMBER
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|"this"
block|,
name|tMINUTE_UNIT
block|,
literal|0
block|}
block|,
block|{
literal|"next"
block|,
name|tUNUMBER
block|,
literal|2
block|}
block|,
if|#
directive|if
literal|0
block|{ "first",          tUNUMBER,       1 },
comment|/*  { "second",         tUNUMBER,       2 }, */
block|{ "third",          tUNUMBER,       3 },     { "fourth",         tUNUMBER,       4 },     { "fifth",          tUNUMBER,       5 },     { "sixth",          tUNUMBER,       6 },     { "seventh",        tUNUMBER,       7 },     { "eighth",         tUNUMBER,       8 },     { "ninth",          tUNUMBER,       9 },     { "tenth",          tUNUMBER,       10 },     { "eleventh",       tUNUMBER,       11 },     { "twelfth",        tUNUMBER,       12 },
endif|#
directive|endif
block|{
literal|"ago"
block|,
name|tAGO
block|,
literal|1
block|}
block|,
block|{
literal|"epoch"
block|,
name|tEPOCH
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The timezone table.  (Note: This table was modified to not use any floating  * point constants to work around an SGI compiler bug).  */
end_comment

begin_decl_stmt
specifier|static
name|TABLE
name|TimezoneTable
index|[]
init|=
block|{
block|{
literal|"gmt"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|0
argument_list|)
block|}
block|,
comment|/* Greenwich Mean */
block|{
literal|"ut"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|0
argument_list|)
block|}
block|,
comment|/* Universal (Coordinated) */
block|{
literal|"utc"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|0
argument_list|)
block|}
block|,
block|{
literal|"wet"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|0
argument_list|)
block|}
block|,
comment|/* Western European */
block|{
literal|"bst"
block|,
name|tDAYZONE
block|,
name|HOUR
argument_list|(
literal|0
argument_list|)
block|}
block|,
comment|/* British Summer */
block|{
literal|"wat"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|1
argument_list|)
block|}
block|,
comment|/* West Africa */
block|{
literal|"at"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|2
argument_list|)
block|}
block|,
comment|/* Azores */
if|#
directive|if
literal|0
comment|/* For completeness.  BST is also British Summer, and GST is      * also Guam Standard. */
block|{ "bst",    tZONE,     HOUR( 3) },
comment|/* Brazil Standard */
block|{ "gst",    tZONE,     HOUR( 3) },
comment|/* Greenland Standard */
endif|#
directive|endif
block|{
literal|"nft"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|7
argument|/
literal|2
argument_list|)
block|}
block|,
comment|/* Newfoundland */
block|{
literal|"nst"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|7
argument|/
literal|2
argument_list|)
block|}
block|,
comment|/* Newfoundland Standard */
block|{
literal|"ndt"
block|,
name|tDAYZONE
block|,
name|HOUR
argument_list|(
literal|7
argument|/
literal|2
argument_list|)
block|}
block|,
comment|/* Newfoundland Daylight */
block|{
literal|"ast"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|4
argument_list|)
block|}
block|,
comment|/* Atlantic Standard */
block|{
literal|"adt"
block|,
name|tDAYZONE
block|,
name|HOUR
argument_list|(
literal|4
argument_list|)
block|}
block|,
comment|/* Atlantic Daylight */
block|{
literal|"est"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|5
argument_list|)
block|}
block|,
comment|/* Eastern Standard */
block|{
literal|"edt"
block|,
name|tDAYZONE
block|,
name|HOUR
argument_list|(
literal|5
argument_list|)
block|}
block|,
comment|/* Eastern Daylight */
block|{
literal|"cst"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|6
argument_list|)
block|}
block|,
comment|/* Central Standard */
block|{
literal|"cdt"
block|,
name|tDAYZONE
block|,
name|HOUR
argument_list|(
literal|6
argument_list|)
block|}
block|,
comment|/* Central Daylight */
block|{
literal|"mst"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|7
argument_list|)
block|}
block|,
comment|/* Mountain Standard */
block|{
literal|"mdt"
block|,
name|tDAYZONE
block|,
name|HOUR
argument_list|(
literal|7
argument_list|)
block|}
block|,
comment|/* Mountain Daylight */
block|{
literal|"pst"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|8
argument_list|)
block|}
block|,
comment|/* Pacific Standard */
block|{
literal|"pdt"
block|,
name|tDAYZONE
block|,
name|HOUR
argument_list|(
literal|8
argument_list|)
block|}
block|,
comment|/* Pacific Daylight */
block|{
literal|"yst"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|9
argument_list|)
block|}
block|,
comment|/* Yukon Standard */
block|{
literal|"ydt"
block|,
name|tDAYZONE
block|,
name|HOUR
argument_list|(
literal|9
argument_list|)
block|}
block|,
comment|/* Yukon Daylight */
block|{
literal|"hst"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|10
argument_list|)
block|}
block|,
comment|/* Hawaii Standard */
block|{
literal|"hdt"
block|,
name|tDAYZONE
block|,
name|HOUR
argument_list|(
literal|10
argument_list|)
block|}
block|,
comment|/* Hawaii Daylight */
block|{
literal|"cat"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|10
argument_list|)
block|}
block|,
comment|/* Central Alaska */
block|{
literal|"ahst"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|10
argument_list|)
block|}
block|,
comment|/* Alaska-Hawaii Standard */
block|{
literal|"nt"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|11
argument_list|)
block|}
block|,
comment|/* Nome */
block|{
literal|"idlw"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|12
argument_list|)
block|}
block|,
comment|/* International Date Line West */
block|{
literal|"cet"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|1
argument_list|)
block|}
block|,
comment|/* Central European */
block|{
literal|"met"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|1
argument_list|)
block|}
block|,
comment|/* Middle European */
block|{
literal|"mewt"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|1
argument_list|)
block|}
block|,
comment|/* Middle European Winter */
block|{
literal|"mest"
block|,
name|tDAYZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|1
argument_list|)
block|}
block|,
comment|/* Middle European Summer */
block|{
literal|"swt"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|1
argument_list|)
block|}
block|,
comment|/* Swedish Winter */
block|{
literal|"sst"
block|,
name|tDAYZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|1
argument_list|)
block|}
block|,
comment|/* Swedish Summer */
block|{
literal|"fwt"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|1
argument_list|)
block|}
block|,
comment|/* French Winter */
block|{
literal|"fst"
block|,
name|tDAYZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|1
argument_list|)
block|}
block|,
comment|/* French Summer */
block|{
literal|"eet"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|2
argument_list|)
block|}
block|,
comment|/* Eastern Europe, USSR Zone 1 */
block|{
literal|"bt"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|3
argument_list|)
block|}
block|,
comment|/* Baghdad, USSR Zone 2 */
block|{
literal|"it"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|7
argument|/
literal|2
argument_list|)
block|}
block|,
comment|/* Iran */
block|{
literal|"zp4"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|4
argument_list|)
block|}
block|,
comment|/* USSR Zone 3 */
block|{
literal|"zp5"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|5
argument_list|)
block|}
block|,
comment|/* USSR Zone 4 */
block|{
literal|"ist"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|11
argument|/
literal|2
argument_list|)
block|}
block|,
comment|/* Indian Standard */
block|{
literal|"zp6"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|6
argument_list|)
block|}
block|,
comment|/* USSR Zone 5 */
if|#
directive|if
literal|0
comment|/* For completeness.  NST is also Newfoundland Stanard, nad SST is      * also Swedish Summer. */
block|{ "nst",    tZONE,    -HOUR(13/2) },
comment|/* North Sumatra */
block|{ "sst",    tZONE,    -HOUR( 7) },
comment|/* South Sumatra, USSR Zone 6 */
endif|#
directive|endif
comment|/* 0 */
block|{
literal|"wast"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|7
argument_list|)
block|}
block|,
comment|/* West Australian Standard */
block|{
literal|"wadt"
block|,
name|tDAYZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|7
argument_list|)
block|}
block|,
comment|/* West Australian Daylight */
block|{
literal|"jt"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|15
argument|/
literal|2
argument_list|)
block|}
block|,
comment|/* Java (3pm in Cronusland!) */
block|{
literal|"cct"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|8
argument_list|)
block|}
block|,
comment|/* China Coast, USSR Zone 7 */
block|{
literal|"jst"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|9
argument_list|)
block|}
block|,
comment|/* Japan Standard, USSR Zone 8 */
block|{
literal|"cast"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|19
argument|/
literal|2
argument_list|)
block|}
block|,
comment|/* Central Australian Standard */
block|{
literal|"cadt"
block|,
name|tDAYZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|19
argument|/
literal|2
argument_list|)
block|}
block|,
comment|/* Central Australian Daylight */
block|{
literal|"east"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|10
argument_list|)
block|}
block|,
comment|/* Eastern Australian Standard */
block|{
literal|"eadt"
block|,
name|tDAYZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|10
argument_list|)
block|}
block|,
comment|/* Eastern Australian Daylight */
block|{
literal|"gst"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|10
argument_list|)
block|}
block|,
comment|/* Guam Standard, USSR Zone 9 */
block|{
literal|"nzt"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|12
argument_list|)
block|}
block|,
comment|/* New Zealand */
block|{
literal|"nzst"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|12
argument_list|)
block|}
block|,
comment|/* New Zealand Standard */
block|{
literal|"nzdt"
block|,
name|tDAYZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|12
argument_list|)
block|}
block|,
comment|/* New Zealand Daylight */
block|{
literal|"idle"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|12
argument_list|)
block|}
block|,
comment|/* International Date Line East */
comment|/* ADDED BY Marco Nijdam */
block|{
literal|"dst"
block|,
name|tDST
block|,
name|HOUR
argument_list|(
literal|0
argument_list|)
block|}
block|,
comment|/* DST on (hour is ignored) */
comment|/* End ADDED */
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Military timezone table.  */
end_comment

begin_decl_stmt
specifier|static
name|TABLE
name|MilitaryTable
index|[]
init|=
block|{
block|{
literal|"a"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|1
argument_list|)
block|}
block|,
block|{
literal|"b"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|2
argument_list|)
block|}
block|,
block|{
literal|"c"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|3
argument_list|)
block|}
block|,
block|{
literal|"d"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|4
argument_list|)
block|}
block|,
block|{
literal|"e"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|5
argument_list|)
block|}
block|,
block|{
literal|"f"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|6
argument_list|)
block|}
block|,
block|{
literal|"g"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|7
argument_list|)
block|}
block|,
block|{
literal|"h"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|8
argument_list|)
block|}
block|,
block|{
literal|"i"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|9
argument_list|)
block|}
block|,
block|{
literal|"k"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|10
argument_list|)
block|}
block|,
block|{
literal|"l"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|11
argument_list|)
block|}
block|,
block|{
literal|"m"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|12
argument_list|)
block|}
block|,
block|{
literal|"n"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
argument|-
literal|1
argument_list|)
block|}
block|,
block|{
literal|"o"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
argument|-
literal|2
argument_list|)
block|}
block|,
block|{
literal|"p"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
argument|-
literal|3
argument_list|)
block|}
block|,
block|{
literal|"q"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
argument|-
literal|4
argument_list|)
block|}
block|,
block|{
literal|"r"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
argument|-
literal|5
argument_list|)
block|}
block|,
block|{
literal|"s"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
argument|-
literal|6
argument_list|)
block|}
block|,
block|{
literal|"t"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
argument|-
literal|7
argument_list|)
block|}
block|,
block|{
literal|"u"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
argument|-
literal|8
argument_list|)
block|}
block|,
block|{
literal|"v"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
argument|-
literal|9
argument_list|)
block|}
block|,
block|{
literal|"w"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
argument|-
literal|10
argument_list|)
block|}
block|,
block|{
literal|"x"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
argument|-
literal|11
argument_list|)
block|}
block|,
block|{
literal|"y"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
argument|-
literal|12
argument_list|)
block|}
block|,
block|{
literal|"z"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|0
argument_list|)
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Dump error messages in the bit bucket.  */
end_comment

begin_function
specifier|static
name|void
name|TclDateerror
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{ }
end_function

begin_function
specifier|static
name|time_t
name|ToSeconds
parameter_list|(
name|Hours
parameter_list|,
name|Minutes
parameter_list|,
name|Seconds
parameter_list|,
name|Meridian
parameter_list|)
name|time_t
name|Hours
decl_stmt|;
name|time_t
name|Minutes
decl_stmt|;
name|time_t
name|Seconds
decl_stmt|;
name|MERIDIAN
name|Meridian
decl_stmt|;
block|{
if|if
condition|(
name|Minutes
operator|<
literal|0
operator|||
name|Minutes
operator|>
literal|59
operator|||
name|Seconds
operator|<
literal|0
operator|||
name|Seconds
operator|>
literal|59
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|Meridian
condition|)
block|{
case|case
name|MER24
case|:
if|if
condition|(
name|Hours
operator|<
literal|0
operator|||
name|Hours
operator|>
literal|23
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|Hours
operator|*
literal|60L
operator|+
name|Minutes
operator|)
operator|*
literal|60L
operator|+
name|Seconds
return|;
case|case
name|MERam
case|:
if|if
condition|(
name|Hours
operator|<
literal|1
operator|||
name|Hours
operator|>
literal|12
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
operator|(
name|Hours
operator|%
literal|12
operator|)
operator|*
literal|60L
operator|+
name|Minutes
operator|)
operator|*
literal|60L
operator|+
name|Seconds
return|;
case|case
name|MERpm
case|:
if|if
condition|(
name|Hours
operator|<
literal|1
operator|||
name|Hours
operator|>
literal|12
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
operator|(
operator|(
name|Hours
operator|%
literal|12
operator|)
operator|+
literal|12
operator|)
operator|*
literal|60L
operator|+
name|Minutes
operator|)
operator|*
literal|60L
operator|+
name|Seconds
return|;
block|}
return|return
operator|-
literal|1
return|;
comment|/* Should never be reached */
block|}
end_function

begin_function
specifier|static
name|int
name|Convert
parameter_list|(
name|Month
parameter_list|,
name|Day
parameter_list|,
name|Year
parameter_list|,
name|Hours
parameter_list|,
name|Minutes
parameter_list|,
name|Seconds
parameter_list|,
name|Meridian
parameter_list|,
name|DSTmode
parameter_list|,
name|TimePtr
parameter_list|)
name|time_t
name|Month
decl_stmt|;
name|time_t
name|Day
decl_stmt|;
name|time_t
name|Year
decl_stmt|;
name|time_t
name|Hours
decl_stmt|;
name|time_t
name|Minutes
decl_stmt|;
name|time_t
name|Seconds
decl_stmt|;
name|MERIDIAN
name|Meridian
decl_stmt|;
name|DSTMODE
name|DSTmode
decl_stmt|;
name|time_t
modifier|*
name|TimePtr
decl_stmt|;
block|{
specifier|static
name|int
name|DaysInMonth
index|[
literal|12
index|]
init|=
block|{
literal|31
block|,
literal|0
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
name|time_t
name|tod
decl_stmt|;
name|time_t
name|Julian
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DaysInMonth
index|[
literal|1
index|]
operator|=
name|Year
operator|%
literal|4
operator|==
literal|0
operator|&&
operator|(
name|Year
operator|%
literal|100
operator|!=
literal|0
operator|||
name|Year
operator|%
literal|400
operator|==
literal|0
operator|)
condition|?
literal|29
else|:
literal|28
expr_stmt|;
if|if
condition|(
name|Month
operator|<
literal|1
operator|||
name|Month
operator|>
literal|12
operator|||
name|Year
operator|<
name|START_OF_TIME
operator|||
name|Year
operator|>
name|END_OF_TIME
operator|||
name|Day
operator|<
literal|1
operator|||
name|Day
operator|>
name|DaysInMonth
index|[
operator|(
name|int
operator|)
operator|--
name|Month
index|]
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|Julian
operator|=
name|Day
operator|-
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Month
condition|;
name|i
operator|++
control|)
name|Julian
operator|+=
name|DaysInMonth
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|Year
operator|>=
name|EPOCH
condition|)
block|{
for|for
control|(
name|i
operator|=
name|EPOCH
init|;
name|i
operator|<
name|Year
condition|;
name|i
operator|++
control|)
name|Julian
operator|+=
literal|365
operator|+
operator|(
name|i
operator|%
literal|4
operator|==
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|Year
init|;
name|i
operator|<
name|EPOCH
condition|;
name|i
operator|++
control|)
name|Julian
operator|-=
literal|365
operator|+
operator|(
name|i
operator|%
literal|4
operator|==
literal|0
operator|)
expr_stmt|;
block|}
name|Julian
operator|*=
name|SECSPERDAY
expr_stmt|;
name|Julian
operator|+=
name|TclDateTimezone
operator|*
literal|60L
expr_stmt|;
if|if
condition|(
operator|(
name|tod
operator|=
name|ToSeconds
argument_list|(
name|Hours
argument_list|,
name|Minutes
argument_list|,
name|Seconds
argument_list|,
name|Meridian
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|Julian
operator|+=
name|tod
expr_stmt|;
if|if
condition|(
name|DSTmode
operator|==
name|DSTon
operator|||
operator|(
name|DSTmode
operator|==
name|DSTmaybe
operator|&&
name|TclpGetDate
argument_list|(
operator|&
name|Julian
argument_list|,
literal|0
argument_list|)
operator|->
name|tm_isdst
operator|)
condition|)
name|Julian
operator|-=
literal|60
operator|*
literal|60
expr_stmt|;
operator|*
name|TimePtr
operator|=
name|Julian
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|DSTcorrect
parameter_list|(
name|Start
parameter_list|,
name|Future
parameter_list|)
name|time_t
name|Start
decl_stmt|;
name|time_t
name|Future
decl_stmt|;
block|{
name|time_t
name|StartDay
decl_stmt|;
name|time_t
name|FutureDay
decl_stmt|;
name|StartDay
operator|=
operator|(
name|TclpGetDate
argument_list|(
operator|&
name|Start
argument_list|,
literal|0
argument_list|)
operator|->
name|tm_hour
operator|+
literal|1
operator|)
operator|%
literal|24
expr_stmt|;
name|FutureDay
operator|=
operator|(
name|TclpGetDate
argument_list|(
operator|&
name|Future
argument_list|,
literal|0
argument_list|)
operator|->
name|tm_hour
operator|+
literal|1
operator|)
operator|%
literal|24
expr_stmt|;
return|return
operator|(
name|Future
operator|-
name|Start
operator|)
operator|+
operator|(
name|StartDay
operator|-
name|FutureDay
operator|)
operator|*
literal|60L
operator|*
literal|60L
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|RelativeDate
parameter_list|(
name|Start
parameter_list|,
name|DayOrdinal
parameter_list|,
name|DayNumber
parameter_list|)
name|time_t
name|Start
decl_stmt|;
name|time_t
name|DayOrdinal
decl_stmt|;
name|time_t
name|DayNumber
decl_stmt|;
block|{
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|now
operator|=
name|Start
expr_stmt|;
name|tm
operator|=
name|TclpGetDate
argument_list|(
operator|&
name|now
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|now
operator|+=
name|SECSPERDAY
operator|*
operator|(
operator|(
name|DayNumber
operator|-
name|tm
operator|->
name|tm_wday
operator|+
literal|7
operator|)
operator|%
literal|7
operator|)
expr_stmt|;
name|now
operator|+=
literal|7
operator|*
name|SECSPERDAY
operator|*
operator|(
name|DayOrdinal
operator|<=
literal|0
condition|?
name|DayOrdinal
else|:
name|DayOrdinal
operator|-
literal|1
operator|)
expr_stmt|;
return|return
name|DSTcorrect
argument_list|(
name|Start
argument_list|,
name|now
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|RelativeMonth
parameter_list|(
name|Start
parameter_list|,
name|RelMonth
parameter_list|,
name|TimePtr
parameter_list|)
name|time_t
name|Start
decl_stmt|;
name|time_t
name|RelMonth
decl_stmt|;
name|time_t
modifier|*
name|TimePtr
decl_stmt|;
block|{
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|time_t
name|Month
decl_stmt|;
name|time_t
name|Year
decl_stmt|;
name|time_t
name|Julian
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|RelMonth
operator|==
literal|0
condition|)
block|{
operator|*
name|TimePtr
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|tm
operator|=
name|TclpGetDate
argument_list|(
operator|&
name|Start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Month
operator|=
literal|12
operator|*
operator|(
name|tm
operator|->
name|tm_year
operator|+
name|TM_YEAR_BASE
operator|)
operator|+
name|tm
operator|->
name|tm_mon
operator|+
name|RelMonth
expr_stmt|;
name|Year
operator|=
name|Month
operator|/
literal|12
expr_stmt|;
name|Month
operator|=
name|Month
operator|%
literal|12
operator|+
literal|1
expr_stmt|;
name|result
operator|=
name|Convert
argument_list|(
name|Month
argument_list|,
operator|(
name|time_t
operator|)
name|tm
operator|->
name|tm_mday
argument_list|,
name|Year
argument_list|,
operator|(
name|time_t
operator|)
name|tm
operator|->
name|tm_hour
argument_list|,
operator|(
name|time_t
operator|)
name|tm
operator|->
name|tm_min
argument_list|,
operator|(
name|time_t
operator|)
name|tm
operator|->
name|tm_sec
argument_list|,
name|MER24
argument_list|,
name|DSTmaybe
argument_list|,
operator|&
name|Julian
argument_list|)
expr_stmt|;
comment|/*      * The following iteration takes into account the case were we jump      * into a "short month".  Far example, "one month from Jan 31" will      * fail because there is no Feb 31.  The code below will reduce the      * day and try converting the date until we succed or the date equals      * 28 (which always works unless the date is bad in another way).      */
while|while
condition|(
operator|(
name|result
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|tm
operator|->
name|tm_mday
operator|>
literal|28
operator|)
condition|)
block|{
name|tm
operator|->
name|tm_mday
operator|--
expr_stmt|;
name|result
operator|=
name|Convert
argument_list|(
name|Month
argument_list|,
operator|(
name|time_t
operator|)
name|tm
operator|->
name|tm_mday
argument_list|,
name|Year
argument_list|,
operator|(
name|time_t
operator|)
name|tm
operator|->
name|tm_hour
argument_list|,
operator|(
name|time_t
operator|)
name|tm
operator|->
name|tm_min
argument_list|,
operator|(
name|time_t
operator|)
name|tm
operator|->
name|tm_sec
argument_list|,
name|MER24
argument_list|,
name|DSTmaybe
argument_list|,
operator|&
name|Julian
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|TimePtr
operator|=
name|DSTcorrect
argument_list|(
name|Start
argument_list|,
name|Julian
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|LookupWord
parameter_list|(
name|buff
parameter_list|)
name|char
modifier|*
name|buff
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|TABLE
modifier|*
name|tp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|abbrev
decl_stmt|;
comment|/*      * Make it lowercase.      */
for|for
control|(
name|p
operator|=
name|buff
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isupper
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|p
operator|=
operator|(
name|char
operator|)
name|tolower
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|buff
argument_list|,
literal|"am"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|buff
argument_list|,
literal|"a.m."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TclDatelval
operator|.
name|Meridian
operator|=
name|MERam
expr_stmt|;
return|return
name|tMERIDIAN
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|buff
argument_list|,
literal|"pm"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|buff
argument_list|,
literal|"p.m."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TclDatelval
operator|.
name|Meridian
operator|=
name|MERpm
expr_stmt|;
return|return
name|tMERIDIAN
return|;
block|}
comment|/*      * See if we have an abbreviation for a month.      */
if|if
condition|(
name|strlen
argument_list|(
name|buff
argument_list|)
operator|==
literal|3
condition|)
block|{
name|abbrev
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strlen
argument_list|(
name|buff
argument_list|)
operator|==
literal|4
operator|&&
name|buff
index|[
literal|3
index|]
operator|==
literal|'.'
condition|)
block|{
name|abbrev
operator|=
literal|1
expr_stmt|;
name|buff
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|abbrev
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|tp
operator|=
name|MonthDayTable
init|;
name|tp
operator|->
name|name
condition|;
name|tp
operator|++
control|)
block|{
if|if
condition|(
name|abbrev
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|buff
argument_list|,
name|tp
operator|->
name|name
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TclDatelval
operator|.
name|Number
operator|=
name|tp
operator|->
name|value
expr_stmt|;
return|return
name|tp
operator|->
name|type
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|buff
argument_list|,
name|tp
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TclDatelval
operator|.
name|Number
operator|=
name|tp
operator|->
name|value
expr_stmt|;
return|return
name|tp
operator|->
name|type
return|;
block|}
block|}
for|for
control|(
name|tp
operator|=
name|TimezoneTable
init|;
name|tp
operator|->
name|name
condition|;
name|tp
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|buff
argument_list|,
name|tp
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TclDatelval
operator|.
name|Number
operator|=
name|tp
operator|->
name|value
expr_stmt|;
return|return
name|tp
operator|->
name|type
return|;
block|}
block|}
for|for
control|(
name|tp
operator|=
name|UnitsTable
init|;
name|tp
operator|->
name|name
condition|;
name|tp
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|buff
argument_list|,
name|tp
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TclDatelval
operator|.
name|Number
operator|=
name|tp
operator|->
name|value
expr_stmt|;
return|return
name|tp
operator|->
name|type
return|;
block|}
block|}
comment|/*      * Strip off any plural and try the units table again.      */
name|i
operator|=
name|strlen
argument_list|(
name|buff
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|buff
index|[
name|i
index|]
operator|==
literal|'s'
condition|)
block|{
name|buff
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|UnitsTable
init|;
name|tp
operator|->
name|name
condition|;
name|tp
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|buff
argument_list|,
name|tp
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TclDatelval
operator|.
name|Number
operator|=
name|tp
operator|->
name|value
expr_stmt|;
return|return
name|tp
operator|->
name|type
return|;
block|}
block|}
block|}
for|for
control|(
name|tp
operator|=
name|OtherTable
init|;
name|tp
operator|->
name|name
condition|;
name|tp
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|buff
argument_list|,
name|tp
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TclDatelval
operator|.
name|Number
operator|=
name|tp
operator|->
name|value
expr_stmt|;
return|return
name|tp
operator|->
name|type
return|;
block|}
block|}
comment|/*      * Military timezones.      */
if|if
condition|(
name|buff
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|&&
name|isalpha
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|buff
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|tp
operator|=
name|MilitaryTable
init|;
name|tp
operator|->
name|name
condition|;
name|tp
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|buff
argument_list|,
name|tp
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TclDatelval
operator|.
name|Number
operator|=
name|tp
operator|->
name|value
expr_stmt|;
return|return
name|tp
operator|->
name|type
return|;
block|}
block|}
block|}
comment|/*      * Drop out any periods and try the timezone table again.      */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|q
operator|=
name|buff
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
if|if
condition|(
operator|*
name|q
operator|!=
literal|'.'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
operator|*
name|q
expr_stmt|;
block|}
else|else
block|{
name|i
operator|++
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
for|for
control|(
name|tp
operator|=
name|TimezoneTable
init|;
name|tp
operator|->
name|name
condition|;
name|tp
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|buff
argument_list|,
name|tp
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TclDatelval
operator|.
name|Number
operator|=
name|tp
operator|->
name|value
expr_stmt|;
return|return
name|tp
operator|->
name|type
return|;
block|}
block|}
block|}
return|return
name|tID
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|TclDatelex
parameter_list|()
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|buff
index|[
literal|20
index|]
decl_stmt|;
name|int
name|Count
decl_stmt|;
name|int
name|sign
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|isspace
argument_list|(
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|*
name|TclDateInput
argument_list|)
argument_list|)
condition|)
block|{
name|TclDateInput
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|isdigit
argument_list|(
name|c
operator|=
operator|*
name|TclDateInput
argument_list|)
operator|||
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'+'
condition|)
block|{
name|sign
operator|=
name|c
operator|==
literal|'-'
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
operator|++
name|TclDateInput
argument_list|)
condition|)
block|{
comment|/* 		     * skip the '-' sign 		     */
continue|continue;
block|}
block|}
else|else
block|{
name|sign
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|TclDatelval
operator|.
name|Number
operator|=
literal|0
init|;
name|isdigit
argument_list|(
name|c
operator|=
operator|*
name|TclDateInput
operator|++
argument_list|)
condition|;
control|)
block|{
name|TclDatelval
operator|.
name|Number
operator|=
literal|10
operator|*
name|TclDatelval
operator|.
name|Number
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
name|TclDateInput
operator|--
expr_stmt|;
if|if
condition|(
name|sign
operator|<
literal|0
condition|)
block|{
name|TclDatelval
operator|.
name|Number
operator|=
operator|-
name|TclDatelval
operator|.
name|Number
expr_stmt|;
block|}
return|return
name|sign
condition|?
name|tSNUMBER
else|:
name|tUNUMBER
return|;
block|}
if|if
condition|(
name|isalpha
argument_list|(
name|UCHAR
argument_list|(
name|c
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|p
operator|=
name|buff
init|;
name|isalpha
argument_list|(
name|c
operator|=
operator|*
name|TclDateInput
operator|++
argument_list|)
operator|||
name|c
operator|==
literal|'.'
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|<
operator|&
name|buff
index|[
sizeof|sizeof
name|buff
operator|-
literal|1
index|]
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|TclDateInput
operator|--
expr_stmt|;
return|return
name|LookupWord
argument_list|(
name|buff
argument_list|)
return|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'('
condition|)
block|{
return|return
operator|*
name|TclDateInput
operator|++
return|;
block|}
name|Count
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|c
operator|=
operator|*
name|TclDateInput
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
return|return
name|c
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
block|{
name|Count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
block|{
name|Count
operator|--
expr_stmt|;
block|}
block|}
do|while
condition|(
name|Count
operator|>
literal|0
condition|)
do|;
block|}
block|}
end_function

begin_comment
comment|/*  * Specify zone is of -50000 to force GMT.  (This allows BST to work).  */
end_comment

begin_function
name|int
name|TclGetDate
parameter_list|(
name|p
parameter_list|,
name|now
parameter_list|,
name|zone
parameter_list|,
name|timePtr
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|long
name|now
decl_stmt|;
name|long
name|zone
decl_stmt|;
name|unsigned
name|long
modifier|*
name|timePtr
decl_stmt|;
block|{
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|time_t
name|Start
decl_stmt|;
name|time_t
name|Time
decl_stmt|;
name|time_t
name|tod
decl_stmt|;
name|int
name|thisyear
decl_stmt|;
name|TclDateInput
operator|=
name|p
expr_stmt|;
name|tm
operator|=
name|TclpGetDate
argument_list|(
operator|(
name|time_t
operator|*
operator|)
operator|&
name|now
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|thisyear
operator|=
name|tm
operator|->
name|tm_year
operator|+
name|TM_YEAR_BASE
expr_stmt|;
name|TclDateYear
operator|=
name|thisyear
expr_stmt|;
name|TclDateMonth
operator|=
name|tm
operator|->
name|tm_mon
operator|+
literal|1
expr_stmt|;
name|TclDateDay
operator|=
name|tm
operator|->
name|tm_mday
expr_stmt|;
name|TclDateTimezone
operator|=
name|zone
expr_stmt|;
if|if
condition|(
name|zone
operator|==
operator|-
literal|50000
condition|)
block|{
name|TclDateDSTmode
operator|=
name|DSToff
expr_stmt|;
comment|/* assume GMT */
name|TclDateTimezone
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|TclDateDSTmode
operator|=
name|DSTmaybe
expr_stmt|;
block|}
name|TclDateHour
operator|=
literal|0
expr_stmt|;
name|TclDateMinutes
operator|=
literal|0
expr_stmt|;
name|TclDateSeconds
operator|=
literal|0
expr_stmt|;
name|TclDateMeridian
operator|=
name|MER24
expr_stmt|;
name|TclDateRelSeconds
operator|=
literal|0
expr_stmt|;
name|TclDateRelMonth
operator|=
literal|0
expr_stmt|;
name|TclDateHaveDate
operator|=
literal|0
expr_stmt|;
name|TclDateHaveDay
operator|=
literal|0
expr_stmt|;
name|TclDateHaveRel
operator|=
literal|0
expr_stmt|;
name|TclDateHaveTime
operator|=
literal|0
expr_stmt|;
name|TclDateHaveZone
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TclDateparse
argument_list|()
operator|||
name|TclDateHaveTime
operator|>
literal|1
operator|||
name|TclDateHaveZone
operator|>
literal|1
operator|||
name|TclDateHaveDate
operator|>
literal|1
operator|||
name|TclDateHaveDay
operator|>
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|TclDateHaveDate
operator|||
name|TclDateHaveTime
operator|||
name|TclDateHaveDay
condition|)
block|{
if|if
condition|(
name|TclDateYear
operator|<
literal|0
condition|)
block|{
name|TclDateYear
operator|=
operator|-
name|TclDateYear
expr_stmt|;
block|}
comment|/* 	 * The following line handles years that are specified using 	 * only two digits.  The line of code below implements a policy 	 * defined by the X/Open workgroup on the millinium rollover. 	 * Note: some of those dates may not actually be valid on some 	 * platforms.  The POSIX standard startes that the dates 70-99 	 * shall refer to 1970-1999 and 00-38 shall refer to 2000-2038. 	 * This later definition should work on all platforms. 	 */
if|if
condition|(
name|TclDateYear
operator|<
literal|100
condition|)
block|{
if|if
condition|(
name|TclDateYear
operator|>=
literal|69
condition|)
block|{
name|TclDateYear
operator|+=
literal|1900
expr_stmt|;
block|}
else|else
block|{
name|TclDateYear
operator|+=
literal|2000
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Convert
argument_list|(
name|TclDateMonth
argument_list|,
name|TclDateDay
argument_list|,
name|TclDateYear
argument_list|,
name|TclDateHour
argument_list|,
name|TclDateMinutes
argument_list|,
name|TclDateSeconds
argument_list|,
name|TclDateMeridian
argument_list|,
name|TclDateDSTmode
argument_list|,
operator|&
name|Start
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
name|Start
operator|=
name|now
expr_stmt|;
if|if
condition|(
operator|!
name|TclDateHaveRel
condition|)
block|{
name|Start
operator|-=
operator|(
operator|(
name|tm
operator|->
name|tm_hour
operator|*
literal|60L
operator|)
operator|+
name|tm
operator|->
name|tm_min
operator|*
literal|60L
operator|)
operator|+
name|tm
operator|->
name|tm_sec
expr_stmt|;
block|}
block|}
name|Start
operator|+=
name|TclDateRelSeconds
expr_stmt|;
if|if
condition|(
name|RelativeMonth
argument_list|(
name|Start
argument_list|,
name|TclDateRelMonth
argument_list|,
operator|&
name|Time
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|Start
operator|+=
name|Time
expr_stmt|;
if|if
condition|(
name|TclDateHaveDay
operator|&&
operator|!
name|TclDateHaveDate
condition|)
block|{
name|tod
operator|=
name|RelativeDate
argument_list|(
name|Start
argument_list|,
name|TclDateDayOrdinal
argument_list|,
name|TclDateDayNumber
argument_list|)
expr_stmt|;
name|Start
operator|+=
name|tod
expr_stmt|;
block|}
operator|*
name|timePtr
operator|=
name|Start
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|TclDatetabelem
name|TclDateexca
index|[]
init|=
block|{
operator|-
literal|1
block|,
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|2
block|,
literal|0
block|, 	}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|YYNPROD
value|41
end_define

begin_define
define|#
directive|define
name|YYLAST
value|227
end_define

begin_decl_stmt
name|TclDatetabelem
name|TclDateact
index|[]
init|=
block|{
literal|14
block|,
literal|11
block|,
literal|23
block|,
literal|28
block|,
literal|17
block|,
literal|12
block|,
literal|19
block|,
literal|18
block|,
literal|16
block|,
literal|9
block|,
literal|10
block|,
literal|13
block|,
literal|42
block|,
literal|21
block|,
literal|46
block|,
literal|45
block|,
literal|44
block|,
literal|48
block|,
literal|41
block|,
literal|37
block|,
literal|36
block|,
literal|35
block|,
literal|32
block|,
literal|29
block|,
literal|34
block|,
literal|33
block|,
literal|31
block|,
literal|43
block|,
literal|39
block|,
literal|38
block|,
literal|30
block|,
literal|15
block|,
literal|8
block|,
literal|7
block|,
literal|6
block|,
literal|5
block|,
literal|4
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|47
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|22
block|,
literal|0
block|,
literal|0
block|,
literal|20
block|,
literal|25
block|,
literal|24
block|,
literal|27
block|,
literal|26
block|,
literal|42
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|40
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TclDatetabelem
name|TclDatepact
index|[]
init|=
block|{
operator|-
literal|10000000
block|,
operator|-
literal|258
block|,
operator|-
literal|10000000
block|,
operator|-
literal|10000000
block|,
operator|-
literal|10000000
block|,
operator|-
literal|10000000
block|,
operator|-
literal|10000000
block|,
operator|-
literal|10000000
block|,
operator|-
literal|10000000
block|,
operator|-
literal|45
block|,
operator|-
literal|267
block|,
operator|-
literal|10000000
block|,
operator|-
literal|244
block|,
operator|-
literal|10000000
block|,
operator|-
literal|14
block|,
operator|-
literal|231
block|,
operator|-
literal|240
block|,
operator|-
literal|10000000
block|,
operator|-
literal|10000000
block|,
operator|-
literal|10000000
block|,
operator|-
literal|10000000
block|,
operator|-
literal|246
block|,
operator|-
literal|10000000
block|,
operator|-
literal|247
block|,
operator|-
literal|248
block|,
operator|-
literal|10000000
block|,
operator|-
literal|10000000
block|,
operator|-
literal|10000000
block|,
operator|-
literal|10000000
block|,
operator|-
literal|15
block|,
operator|-
literal|10000000
block|,
operator|-
literal|10000000
block|,
operator|-
literal|10000000
block|,
operator|-
literal|10000000
block|,
operator|-
literal|10000000
block|,
operator|-
literal|40
block|,
operator|-
literal|20
block|,
operator|-
literal|10000000
block|,
operator|-
literal|251
block|,
operator|-
literal|10000000
block|,
operator|-
literal|10000000
block|,
operator|-
literal|252
block|,
operator|-
literal|10000000
block|,
operator|-
literal|253
block|,
operator|-
literal|10000000
block|,
operator|-
literal|249
block|,
operator|-
literal|10000000
block|,
operator|-
literal|10000000
block|,
operator|-
literal|10000000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TclDatetabelem
name|TclDatepgo
index|[]
init|=
block|{
literal|0
block|,
literal|28
block|,
literal|39
block|,
literal|38
block|,
literal|37
block|,
literal|36
block|,
literal|35
block|,
literal|34
block|,
literal|33
block|,
literal|32
block|,
literal|31
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TclDatetabelem
name|TclDater1
index|[]
init|=
block|{
literal|0
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|8
block|,
literal|8
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|9
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TclDatetabelem
name|TclDater2
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|2
block|,
literal|5
block|,
literal|9
block|,
literal|9
block|,
literal|13
block|,
literal|13
block|,
literal|5
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|5
block|,
literal|5
block|,
literal|7
block|,
literal|11
block|,
literal|5
block|,
literal|9
block|,
literal|5
block|,
literal|3
block|,
literal|7
block|,
literal|5
block|,
literal|2
block|,
literal|5
block|,
literal|5
block|,
literal|3
block|,
literal|5
block|,
literal|5
block|,
literal|3
block|,
literal|5
block|,
literal|5
block|,
literal|3
block|,
literal|3
block|,
literal|1
block|,
literal|3
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TclDatetabelem
name|TclDatechk
index|[]
init|=
block|{
operator|-
literal|10000000
block|,
operator|-
literal|2
block|,
operator|-
literal|3
block|,
operator|-
literal|4
block|,
operator|-
literal|5
block|,
operator|-
literal|6
block|,
operator|-
literal|7
block|,
operator|-
literal|8
block|,
operator|-
literal|9
block|,
literal|267
block|,
literal|268
block|,
literal|259
block|,
literal|263
block|,
literal|269
block|,
literal|258
block|,
operator|-
literal|10
block|,
literal|266
block|,
literal|262
block|,
literal|265
block|,
literal|264
block|,
literal|261
block|,
literal|58
block|,
literal|258
block|,
literal|47
block|,
literal|263
block|,
literal|262
block|,
literal|265
block|,
literal|264
block|,
literal|270
block|,
literal|267
block|,
literal|44
block|,
literal|257
block|,
literal|262
block|,
literal|265
block|,
literal|264
block|,
literal|267
block|,
literal|267
block|,
literal|267
block|,
literal|44
block|,
operator|-
literal|1
block|,
literal|266
block|,
literal|58
block|,
literal|261
block|,
literal|47
block|,
literal|267
block|,
literal|267
block|,
literal|267
block|,
operator|-
literal|1
block|,
literal|266
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TclDatetabelem
name|TclDatedef
index|[]
init|=
block|{
literal|1
block|,
operator|-
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|38
block|,
literal|15
block|,
literal|16
block|,
literal|0
block|,
literal|25
block|,
literal|17
block|,
literal|28
block|,
literal|0
block|,
literal|31
block|,
literal|34
block|,
literal|37
block|,
literal|9
block|,
literal|0
block|,
literal|19
block|,
literal|0
block|,
literal|24
block|,
literal|29
block|,
literal|33
block|,
literal|36
block|,
literal|14
block|,
literal|22
block|,
literal|18
block|,
literal|27
block|,
literal|30
block|,
literal|32
block|,
literal|35
block|,
literal|39
block|,
literal|20
block|,
literal|26
block|,
literal|0
block|,
literal|10
block|,
literal|11
block|,
literal|0
block|,
literal|40
block|,
literal|0
block|,
literal|23
block|,
literal|39
block|,
literal|21
block|,
literal|12
block|,
literal|13
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
ifdef|#
directive|ifdef
name|__cplusplus
name|TclDatetoktype
endif|#
directive|endif
block|{
name|char
modifier|*
name|t_name
decl_stmt|;
name|int
name|t_val
decl_stmt|;
block|}
name|TclDatetoktype
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|YYDEBUG
end_ifndef

begin_define
define|#
directive|define
name|YYDEBUG
value|0
end_define

begin_comment
comment|/* don't allow debugging */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|YYDEBUG
end_if

begin_decl_stmt
name|TclDatetoktype
name|TclDatetoks
index|[]
init|=
block|{
literal|"tAGO"
block|,
literal|257
block|,
literal|"tDAY"
block|,
literal|258
block|,
literal|"tDAYZONE"
block|,
literal|259
block|,
literal|"tID"
block|,
literal|260
block|,
literal|"tMERIDIAN"
block|,
literal|261
block|,
literal|"tMINUTE_UNIT"
block|,
literal|262
block|,
literal|"tMONTH"
block|,
literal|263
block|,
literal|"tMONTH_UNIT"
block|,
literal|264
block|,
literal|"tSEC_UNIT"
block|,
literal|265
block|,
literal|"tSNUMBER"
block|,
literal|266
block|,
literal|"tUNUMBER"
block|,
literal|267
block|,
literal|"tZONE"
block|,
literal|268
block|,
literal|"tEPOCH"
block|,
literal|269
block|,
literal|"tDST"
block|,
literal|270
block|,
literal|"-unknown-"
block|,
operator|-
literal|1
comment|/* ends search */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|TclDatereds
index|[]
init|=
block|{
literal|"-no such reduction-"
block|,
literal|"spec : /* empty */"
block|,
literal|"spec : spec item"
block|,
literal|"item : time"
block|,
literal|"item : zone"
block|,
literal|"item : date"
block|,
literal|"item : day"
block|,
literal|"item : rel"
block|,
literal|"item : number"
block|,
literal|"time : tUNUMBER tMERIDIAN"
block|,
literal|"time : tUNUMBER ':' tUNUMBER o_merid"
block|,
literal|"time : tUNUMBER ':' tUNUMBER tSNUMBER"
block|,
literal|"time : tUNUMBER ':' tUNUMBER ':' tUNUMBER o_merid"
block|,
literal|"time : tUNUMBER ':' tUNUMBER ':' tUNUMBER tSNUMBER"
block|,
literal|"zone : tZONE tDST"
block|,
literal|"zone : tZONE"
block|,
literal|"zone : tDAYZONE"
block|,
literal|"day : tDAY"
block|,
literal|"day : tDAY ','"
block|,
literal|"day : tUNUMBER tDAY"
block|,
literal|"date : tUNUMBER '/' tUNUMBER"
block|,
literal|"date : tUNUMBER '/' tUNUMBER '/' tUNUMBER"
block|,
literal|"date : tMONTH tUNUMBER"
block|,
literal|"date : tMONTH tUNUMBER ',' tUNUMBER"
block|,
literal|"date : tUNUMBER tMONTH"
block|,
literal|"date : tEPOCH"
block|,
literal|"date : tUNUMBER tMONTH tUNUMBER"
block|,
literal|"rel : relunit tAGO"
block|,
literal|"rel : relunit"
block|,
literal|"relunit : tUNUMBER tMINUTE_UNIT"
block|,
literal|"relunit : tSNUMBER tMINUTE_UNIT"
block|,
literal|"relunit : tMINUTE_UNIT"
block|,
literal|"relunit : tSNUMBER tSEC_UNIT"
block|,
literal|"relunit : tUNUMBER tSEC_UNIT"
block|,
literal|"relunit : tSEC_UNIT"
block|,
literal|"relunit : tSNUMBER tMONTH_UNIT"
block|,
literal|"relunit : tUNUMBER tMONTH_UNIT"
block|,
literal|"relunit : tMONTH_UNIT"
block|,
literal|"number : tUNUMBER"
block|,
literal|"o_merid : /* empty */"
block|,
literal|"o_merid : tMERIDIAN"
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YYDEBUG */
end_comment

begin_comment
comment|/*  * Copyright (c) 1993 by Sun Microsystems, Inc.  */
end_comment

begin_comment
comment|/* ** Skeleton parser driver for yacc output */
end_comment

begin_comment
comment|/* ** yacc user known macros and defines */
end_comment

begin_define
define|#
directive|define
name|YYERROR
value|goto TclDateerrlab
end_define

begin_define
define|#
directive|define
name|YYACCEPT
value|return(0)
end_define

begin_define
define|#
directive|define
name|YYABORT
value|return(1)
end_define

begin_define
define|#
directive|define
name|YYBACKUP
parameter_list|(
name|newtoken
parameter_list|,
name|newvalue
parameter_list|)
define|\
value|{\ 	if ( TclDatechar>= 0 || ( TclDater2[ TclDatetmp ]>> 1 ) != 1 )\ 	{\ 		TclDateerror( "syntax error - cannot backup" );\ 		goto TclDateerrlab;\ 	}\ 	TclDatechar = newtoken;\ 	TclDatestate = *TclDateps;\ 	TclDatelval = newvalue;\ 	goto TclDatenewstate;\ }
end_define

begin_define
define|#
directive|define
name|YYRECOVERING
parameter_list|()
value|(!!TclDateerrflag)
end_define

begin_define
define|#
directive|define
name|YYNEW
parameter_list|(
name|type
parameter_list|)
value|malloc(sizeof(type) * TclDatenewmax)
end_define

begin_define
define|#
directive|define
name|YYCOPY
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|type
parameter_list|)
define|\
value|(type *) memcpy(to, (char *) from, TclDatenewmax * sizeof(type))
end_define

begin_define
define|#
directive|define
name|YYENLARGE
parameter_list|(
name|from
parameter_list|,
name|type
parameter_list|)
define|\
value|(type *) realloc((char *) from, TclDatenewmax * sizeof(type))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|YYDEBUG
end_ifndef

begin_define
define|#
directive|define
name|YYDEBUG
value|1
end_define

begin_comment
comment|/* make debugging available */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** user known globals */
end_comment

begin_decl_stmt
name|int
name|TclDatedebug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to 1 to get debugging */
end_comment

begin_comment
comment|/* ** driver internal defines */
end_comment

begin_define
define|#
directive|define
name|YYFLAG
value|(-10000000)
end_define

begin_comment
comment|/* ** global variables used by the parser */
end_comment

begin_decl_stmt
name|YYSTYPE
modifier|*
name|TclDatepv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* top of value stack */
end_comment

begin_decl_stmt
name|int
modifier|*
name|TclDateps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* top of state stack */
end_comment

begin_decl_stmt
name|int
name|TclDatestate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current state */
end_comment

begin_decl_stmt
name|int
name|TclDatetmp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* extra var (lasts between blocks) */
end_comment

begin_decl_stmt
name|int
name|TclDatenerrs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of errors */
end_comment

begin_decl_stmt
name|int
name|TclDateerrflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* error recovery flag */
end_comment

begin_decl_stmt
name|int
name|TclDatechar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current input token number */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|YYNMBCHARS
end_ifdef

begin_define
define|#
directive|define
name|YYLEX
parameter_list|()
value|TclDatecvtok(TclDatelex())
end_define

begin_comment
comment|/* ** TclDatecvtok - return a token if i is a wchar_t value that exceeds 255. **	If i<255, i itself is the token.  If i>255 but the neither  **	of the 30th or 31st bit is on, i is already a token. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_function
name|int
name|TclDatecvtok
parameter_list|(
name|int
name|i
parameter_list|)
else|#
directive|else
function|int TclDatecvtok
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|first
init|=
literal|0
decl_stmt|;
name|int
name|last
init|=
name|YYNMBCHARS
operator|-
literal|1
decl_stmt|;
name|int
name|mid
decl_stmt|;
name|wchar_t
name|j
decl_stmt|;
if|if
condition|(
name|i
operator|&
literal|0x60000000
condition|)
block|{
comment|/*Must convert to a token. */
if|if
condition|(
name|TclDatembchars
index|[
name|last
index|]
operator|.
name|character
operator|<
name|i
condition|)
block|{
return|return
name|i
return|;
comment|/*Giving up*/
block|}
while|while
condition|(
operator|(
name|last
operator|>=
name|first
operator|)
operator|&&
operator|(
name|first
operator|>=
literal|0
operator|)
condition|)
block|{
comment|/*Binary search loop*/
name|mid
operator|=
operator|(
name|first
operator|+
name|last
operator|)
operator|/
literal|2
expr_stmt|;
name|j
operator|=
name|TclDatembchars
index|[
name|mid
index|]
operator|.
name|character
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|i
condition|)
block|{
comment|/*Found*/
return|return
name|TclDatembchars
index|[
name|mid
index|]
operator|.
name|tvalue
return|;
block|}
elseif|else
if|if
condition|(
name|j
operator|<
name|i
condition|)
block|{
name|first
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|last
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/*No entry in the table.*/
return|return
name|i
return|;
comment|/* Giving up.*/
block|}
else|else
block|{
comment|/* i is already a token. */
return|return
name|i
return|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*!YYNMBCHARS*/
end_comment

begin_define
define|#
directive|define
name|YYLEX
parameter_list|()
value|TclDatelex()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*!YYNMBCHARS*/
end_comment

begin_comment
comment|/* ** TclDateparse - return 0 if worked, 1 if syntax error not recovered from */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_decl_stmt
name|int
name|TclDateparse
argument_list|(
name|void
argument_list|)
else|#
directive|else
name|int
name|TclDateparse
argument_list|()
endif|#
directive|endif
block|{
specifier|register
name|YYSTYPE
modifier|*
name|TclDatepvt
decl_stmt|;
comment|/* top of value stack for $vars */
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|||
name|defined
argument_list|(
name|lint
argument_list|)
comment|/* 	hacks to please C++ and lint - goto's inside switch should never be 	executed; TclDatepvt is set to 0 to avoid "used before set" warning. */
specifier|static
name|int
name|__yaccpar_lint_hack__
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|__yaccpar_lint_hack__
condition|)
block|{
case|case
literal|1
case|:
goto|goto
name|TclDateerrlab
goto|;
case|case
literal|2
case|:
goto|goto
name|TclDatenewstate
goto|;
block|}
name|TclDatepvt
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* 	** Initialize externals - TclDateparse may be called more than once 	*/
name|TclDatepv
operator|=
operator|&
name|TclDatev
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|TclDateps
operator|=
operator|&
name|TclDates
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|TclDatestate
operator|=
literal|0
expr_stmt|;
name|TclDatetmp
operator|=
literal|0
expr_stmt|;
name|TclDatenerrs
operator|=
literal|0
expr_stmt|;
name|TclDateerrflag
operator|=
literal|0
expr_stmt|;
name|TclDatechar
operator|=
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|YYMAXDEPTH
operator|<=
literal|0
if|if
condition|(
name|TclDatemaxdepth
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|TclDatemaxdepth
operator|=
name|YYEXPAND
argument_list|(
literal|0
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|TclDateerror
argument_list|(
literal|"yacc initialization error"
argument_list|)
expr_stmt|;
name|YYABORT
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|{
specifier|register
name|YYSTYPE
modifier|*
name|TclDate_pv
decl_stmt|;
comment|/* top of value stack */
specifier|register
name|int
modifier|*
name|TclDate_ps
decl_stmt|;
comment|/* top of state stack */
specifier|register
name|int
name|TclDate_state
decl_stmt|;
comment|/* current state */
specifier|register
name|int
name|TclDate_n
decl_stmt|;
comment|/* internal state number info */
goto|goto
name|TclDatestack
goto|;
comment|/* moved from 6 lines above to here to please C++ */
comment|/* 		** get globals into registers. 		** branch to here only if YYBACKUP was called. 		*/
name|TclDate_pv
operator|=
name|TclDatepv
expr_stmt|;
name|TclDate_ps
operator|=
name|TclDateps
expr_stmt|;
name|TclDate_state
operator|=
name|TclDatestate
expr_stmt|;
goto|goto
name|TclDate_newstate
goto|;
comment|/* 		** get globals into registers. 		** either we just started, or we just finished a reduction 		*/
name|TclDatestack
label|:
name|TclDate_pv
operator|=
name|TclDatepv
expr_stmt|;
name|TclDate_ps
operator|=
name|TclDateps
expr_stmt|;
name|TclDate_state
operator|=
name|TclDatestate
expr_stmt|;
comment|/* 		** top of for (;;) loop while no reductions done 		*/
name|TclDate_stack
label|:
comment|/* 		** put a state and value onto the stacks 		*/
if|#
directive|if
name|YYDEBUG
comment|/* 		** if debugging, look up token value in list of value vs. 		** name pairs.  0 and negative (-1) are special values. 		** Note: linear search is used since time is not a real 		** consideration while debugging. 		*/
if|if
condition|(
name|TclDatedebug
condition|)
block|{
specifier|register
name|int
name|TclDate_i
decl_stmt|;
name|printf
argument_list|(
literal|"State %d, token "
argument_list|,
name|TclDate_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|TclDatechar
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"end-of-file\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TclDatechar
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"-none-\n"
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|TclDate_i
operator|=
literal|0
init|;
name|TclDatetoks
index|[
name|TclDate_i
index|]
operator|.
name|t_val
operator|>=
literal|0
condition|;
name|TclDate_i
operator|++
control|)
block|{
if|if
condition|(
name|TclDatetoks
index|[
name|TclDate_i
index|]
operator|.
name|t_val
operator|==
name|TclDatechar
condition|)
break|break;
block|}
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|TclDatetoks
index|[
name|TclDate_i
index|]
operator|.
name|t_name
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* YYDEBUG */
if|if
condition|(
operator|++
name|TclDate_ps
operator|>=
operator|&
name|TclDates
index|[
name|TclDatemaxdepth
index|]
condition|)
comment|/* room on stack? */
block|{
comment|/* 			** reallocate and recover.  Note that pointers 			** have to be reset, or bad things will happen 			*/
name|int
name|TclDateps_index
init|=
operator|(
name|TclDate_ps
operator|-
name|TclDates
operator|)
decl_stmt|;
name|int
name|TclDatepv_index
init|=
operator|(
name|TclDate_pv
operator|-
name|TclDatev
operator|)
decl_stmt|;
name|int
name|TclDatepvt_index
init|=
operator|(
name|TclDatepvt
operator|-
name|TclDatev
operator|)
decl_stmt|;
name|int
name|TclDatenewmax
decl_stmt|;
ifdef|#
directive|ifdef
name|YYEXPAND
name|TclDatenewmax
operator|=
name|YYEXPAND
argument_list|(
name|TclDatemaxdepth
argument_list|)
expr_stmt|;
else|#
directive|else
name|TclDatenewmax
operator|=
literal|2
operator|*
name|TclDatemaxdepth
expr_stmt|;
comment|/* double table size */
if|if
condition|(
name|TclDatemaxdepth
operator|==
name|YYMAXDEPTH
condition|)
comment|/* first time growth */
block|{
name|char
modifier|*
name|newTclDates
init|=
operator|(
name|char
operator|*
operator|)
name|YYNEW
argument_list|(
name|int
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newTclDatev
init|=
operator|(
name|char
operator|*
operator|)
name|YYNEW
argument_list|(
name|YYSTYPE
argument_list|)
decl_stmt|;
if|if
condition|(
name|newTclDates
operator|!=
literal|0
operator|&&
name|newTclDatev
operator|!=
literal|0
condition|)
block|{
name|TclDates
operator|=
name|YYCOPY
argument_list|(
name|newTclDates
argument_list|,
name|TclDates
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|TclDatev
operator|=
name|YYCOPY
argument_list|(
name|newTclDatev
argument_list|,
name|TclDatev
argument_list|,
name|YYSTYPE
argument_list|)
expr_stmt|;
block|}
else|else
name|TclDatenewmax
operator|=
literal|0
expr_stmt|;
comment|/* failed */
block|}
else|else
comment|/* not first time */
block|{
name|TclDates
operator|=
name|YYENLARGE
argument_list|(
name|TclDates
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|TclDatev
operator|=
name|YYENLARGE
argument_list|(
name|TclDatev
argument_list|,
name|YYSTYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TclDates
operator|==
literal|0
operator|||
name|TclDatev
operator|==
literal|0
condition|)
name|TclDatenewmax
operator|=
literal|0
expr_stmt|;
comment|/* failed */
block|}
endif|#
directive|endif
if|if
condition|(
name|TclDatenewmax
operator|<=
name|TclDatemaxdepth
condition|)
comment|/* tables not expanded */
block|{
name|TclDateerror
argument_list|(
literal|"yacc stack overflow"
argument_list|)
expr_stmt|;
name|YYABORT
expr_stmt|;
block|}
name|TclDatemaxdepth
operator|=
name|TclDatenewmax
expr_stmt|;
name|TclDate_ps
operator|=
name|TclDates
operator|+
name|TclDateps_index
expr_stmt|;
name|TclDate_pv
operator|=
name|TclDatev
operator|+
name|TclDatepv_index
expr_stmt|;
name|TclDatepvt
operator|=
name|TclDatev
operator|+
name|TclDatepvt_index
expr_stmt|;
block|}
operator|*
name|TclDate_ps
operator|=
name|TclDate_state
expr_stmt|;
operator|*
operator|++
name|TclDate_pv
operator|=
name|TclDateval
expr_stmt|;
comment|/* 		** we have a new state - find out what to do 		*/
name|TclDate_newstate
label|:
if|if
condition|(
operator|(
name|TclDate_n
operator|=
name|TclDatepact
index|[
name|TclDate_state
index|]
operator|)
operator|<=
name|YYFLAG
condition|)
goto|goto
name|TclDatedefault
goto|;
comment|/* simple state */
if|#
directive|if
name|YYDEBUG
comment|/* 		** if debugging, need to mark whether new token grabbed 		*/
name|TclDatetmp
operator|=
name|TclDatechar
operator|<
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|TclDatechar
operator|<
literal|0
operator|)
operator|&&
operator|(
operator|(
name|TclDatechar
operator|=
name|YYLEX
argument_list|()
operator|)
operator|<
literal|0
operator|)
condition|)
name|TclDatechar
operator|=
literal|0
expr_stmt|;
comment|/* reached EOF */
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|TclDatedebug
operator|&&
name|TclDatetmp
condition|)
block|{
specifier|register
name|int
name|TclDate_i
decl_stmt|;
name|printf
argument_list|(
literal|"Received token "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TclDatechar
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"end-of-file\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TclDatechar
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"-none-\n"
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|TclDate_i
operator|=
literal|0
init|;
name|TclDatetoks
index|[
name|TclDate_i
index|]
operator|.
name|t_val
operator|>=
literal|0
condition|;
name|TclDate_i
operator|++
control|)
block|{
if|if
condition|(
name|TclDatetoks
index|[
name|TclDate_i
index|]
operator|.
name|t_val
operator|==
name|TclDatechar
condition|)
break|break;
block|}
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|TclDatetoks
index|[
name|TclDate_i
index|]
operator|.
name|t_name
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* YYDEBUG */
if|if
condition|(
operator|(
operator|(
name|TclDate_n
operator|+=
name|TclDatechar
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|TclDate_n
operator|>=
name|YYLAST
operator|)
condition|)
goto|goto
name|TclDatedefault
goto|;
if|if
condition|(
name|TclDatechk
index|[
name|TclDate_n
operator|=
name|TclDateact
index|[
name|TclDate_n
index|]
index|]
operator|==
name|TclDatechar
condition|)
comment|/*valid shift*/
block|{
name|TclDatechar
operator|=
operator|-
literal|1
expr_stmt|;
name|TclDateval
operator|=
name|TclDatelval
expr_stmt|;
name|TclDate_state
operator|=
name|TclDate_n
expr_stmt|;
if|if
condition|(
name|TclDateerrflag
operator|>
literal|0
condition|)
name|TclDateerrflag
operator|--
expr_stmt|;
goto|goto
name|TclDate_stack
goto|;
block|}
name|TclDatedefault
label|:
if|if
condition|(
operator|(
name|TclDate_n
operator|=
name|TclDatedef
index|[
name|TclDate_state
index|]
operator|)
operator|==
operator|-
literal|2
condition|)
block|{
if|#
directive|if
name|YYDEBUG
name|TclDatetmp
operator|=
name|TclDatechar
operator|<
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|TclDatechar
operator|<
literal|0
operator|)
operator|&&
operator|(
operator|(
name|TclDatechar
operator|=
name|YYLEX
argument_list|()
operator|)
operator|<
literal|0
operator|)
condition|)
name|TclDatechar
operator|=
literal|0
expr_stmt|;
comment|/* reached EOF */
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|TclDatedebug
operator|&&
name|TclDatetmp
condition|)
block|{
specifier|register
name|int
name|TclDate_i
decl_stmt|;
name|printf
argument_list|(
literal|"Received token "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TclDatechar
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"end-of-file\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TclDatechar
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"-none-\n"
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|TclDate_i
operator|=
literal|0
init|;
name|TclDatetoks
index|[
name|TclDate_i
index|]
operator|.
name|t_val
operator|>=
literal|0
condition|;
name|TclDate_i
operator|++
control|)
block|{
if|if
condition|(
name|TclDatetoks
index|[
name|TclDate_i
index|]
operator|.
name|t_val
operator|==
name|TclDatechar
condition|)
block|{
break|break;
block|}
block|}
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|TclDatetoks
index|[
name|TclDate_i
index|]
operator|.
name|t_name
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* YYDEBUG */
comment|/* 			** look through exception table 			*/
block|{
specifier|register
name|int
modifier|*
name|TclDatexi
init|=
name|TclDateexca
decl_stmt|;
while|while
condition|(
operator|(
operator|*
name|TclDatexi
operator|!=
operator|-
literal|1
operator|)
operator|||
operator|(
name|TclDatexi
index|[
literal|1
index|]
operator|!=
name|TclDate_state
operator|)
condition|)
block|{
name|TclDatexi
operator|+=
literal|2
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|*
operator|(
name|TclDatexi
operator|+=
literal|2
operator|)
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|*
name|TclDatexi
operator|!=
name|TclDatechar
operator|)
condition|)
empty_stmt|;
if|if
condition|(
operator|(
name|TclDate_n
operator|=
name|TclDatexi
index|[
literal|1
index|]
operator|)
operator|<
literal|0
condition|)
name|YYACCEPT
expr_stmt|;
block|}
block|}
comment|/* 		** check for syntax error 		*/
if|if
condition|(
name|TclDate_n
operator|==
literal|0
condition|)
comment|/* have an error */
block|{
comment|/* no worry about speed here! */
switch|switch
condition|(
name|TclDateerrflag
condition|)
block|{
case|case
literal|0
case|:
comment|/* new error */
name|TclDateerror
argument_list|(
literal|"syntax error"
argument_list|)
expr_stmt|;
goto|goto
name|skip_init
goto|;
comment|/* 				** get globals into registers. 				** we have a user generated syntax type error 				*/
name|TclDate_pv
operator|=
name|TclDatepv
expr_stmt|;
name|TclDate_ps
operator|=
name|TclDateps
expr_stmt|;
name|TclDate_state
operator|=
name|TclDatestate
expr_stmt|;
name|skip_init
label|:
name|TclDatenerrs
operator|++
expr_stmt|;
comment|/* FALLTHRU */
case|case
literal|1
case|:
case|case
literal|2
case|:
comment|/* incompletely recovered error */
comment|/* try again... */
name|TclDateerrflag
operator|=
literal|3
expr_stmt|;
comment|/* 				** find state where "error" is a legal 				** shift action 				*/
while|while
condition|(
name|TclDate_ps
operator|>=
name|TclDates
condition|)
block|{
name|TclDate_n
operator|=
name|TclDatepact
index|[
operator|*
name|TclDate_ps
index|]
operator|+
name|YYERRCODE
expr_stmt|;
if|if
condition|(
name|TclDate_n
operator|>=
literal|0
operator|&&
name|TclDate_n
operator|<
name|YYLAST
operator|&&
name|TclDatechk
index|[
name|TclDateact
index|[
name|TclDate_n
index|]
index|]
operator|==
name|YYERRCODE
condition|)
block|{
comment|/* 						** simulate shift of "error" 						*/
name|TclDate_state
operator|=
name|TclDateact
index|[
name|TclDate_n
index|]
expr_stmt|;
goto|goto
name|TclDate_stack
goto|;
block|}
comment|/* 					** current state has no shift on 					** "error", pop stack 					*/
if|#
directive|if
name|YYDEBUG
define|#
directive|define
name|_POP_
value|"Error recovery pops state %d, uncovers state %d\n"
if|if
condition|(
name|TclDatedebug
condition|)
name|printf
argument_list|(
name|_POP_
argument_list|,
operator|*
name|TclDate_ps
argument_list|,
name|TclDate_ps
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|_POP_
endif|#
directive|endif
name|TclDate_ps
operator|--
expr_stmt|;
name|TclDate_pv
operator|--
expr_stmt|;
block|}
comment|/* 				** there is no state on stack with "error" as 				** a valid shift.  give up. 				*/
name|YYABORT
expr_stmt|;
case|case
literal|3
case|:
comment|/* no shift yet; eat a token */
if|#
directive|if
name|YYDEBUG
comment|/* 				** if debugging, look up token in list of 				** pairs.  0 and negative shouldn't occur, 				** but since timing doesn't matter when 				** debugging, it doesn't hurt to leave the 				** tests here. 				*/
if|if
condition|(
name|TclDatedebug
condition|)
block|{
specifier|register
name|int
name|TclDate_i
decl_stmt|;
name|printf
argument_list|(
literal|"Error recovery discards "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TclDatechar
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"token end-of-file\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TclDatechar
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"token -none-\n"
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|TclDate_i
operator|=
literal|0
init|;
name|TclDatetoks
index|[
name|TclDate_i
index|]
operator|.
name|t_val
operator|>=
literal|0
condition|;
name|TclDate_i
operator|++
control|)
block|{
if|if
condition|(
name|TclDatetoks
index|[
name|TclDate_i
index|]
operator|.
name|t_val
operator|==
name|TclDatechar
condition|)
block|{
break|break;
block|}
block|}
name|printf
argument_list|(
literal|"token %s\n"
argument_list|,
name|TclDatetoks
index|[
name|TclDate_i
index|]
operator|.
name|t_name
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* YYDEBUG */
if|if
condition|(
name|TclDatechar
operator|==
literal|0
condition|)
comment|/* reached EOF. quit */
name|YYABORT
expr_stmt|;
name|TclDatechar
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|TclDate_newstate
goto|;
block|}
block|}
comment|/* end if ( TclDate_n == 0 ) */
comment|/* 		** reduction by production TclDate_n 		** put stack tops, etc. so things right after switch 		*/
if|#
directive|if
name|YYDEBUG
comment|/* 		** if debugging, print the string that is the user's 		** specification of the reduction which is just about 		** to be done. 		*/
if|if
condition|(
name|TclDatedebug
condition|)
name|printf
argument_list|(
literal|"Reduce by (%d) \"%s\"\n"
argument_list|,
name|TclDate_n
argument_list|,
name|TclDatereds
index|[
name|TclDate_n
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TclDatetmp
operator|=
name|TclDate_n
expr_stmt|;
comment|/* value to switch over */
name|TclDatepvt
operator|=
name|TclDate_pv
expr_stmt|;
comment|/* $vars top of value stack */
comment|/* 		** Look in goto table for next state 		** Sorry about using TclDate_state here as temporary 		** register variable, but why not, if it works... 		** If TclDater2[ TclDate_n ] doesn't have the low order bit 		** set, then there is no action to be done for 		** this reduction.  So, no saving& unsaving of 		** registers done.  The only difference between the 		** code just after the if and the body of the if is 		** the goto TclDate_stack in the body.  This way the test 		** can be made before the choice of what to do is needed. 		*/
block|{
comment|/* length of production doubled with extra bit */
specifier|register
name|int
name|TclDate_len
init|=
name|TclDater2
index|[
name|TclDate_n
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|TclDate_len
operator|&
literal|01
operator|)
condition|)
block|{
name|TclDate_len
operator|>>=
literal|1
expr_stmt|;
name|TclDateval
operator|=
operator|(
name|TclDate_pv
operator|-=
name|TclDate_len
operator|)
index|[
literal|1
index|]
expr_stmt|;
comment|/* $$ = $1 */
name|TclDate_state
operator|=
name|TclDatepgo
index|[
name|TclDate_n
operator|=
name|TclDater1
index|[
name|TclDate_n
index|]
index|]
operator|+
operator|*
operator|(
name|TclDate_ps
operator|-=
name|TclDate_len
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|TclDate_state
operator|>=
name|YYLAST
operator|||
name|TclDatechk
index|[
name|TclDate_state
operator|=
name|TclDateact
index|[
name|TclDate_state
index|]
index|]
operator|!=
operator|-
name|TclDate_n
condition|)
block|{
name|TclDate_state
operator|=
name|TclDateact
index|[
name|TclDatepgo
index|[
name|TclDate_n
index|]
index|]
expr_stmt|;
block|}
goto|goto
name|TclDate_stack
goto|;
block|}
name|TclDate_len
operator|>>=
literal|1
expr_stmt|;
name|TclDateval
operator|=
operator|(
name|TclDate_pv
operator|-=
name|TclDate_len
operator|)
index|[
literal|1
index|]
expr_stmt|;
comment|/* $$ = $1 */
name|TclDate_state
operator|=
name|TclDatepgo
index|[
name|TclDate_n
operator|=
name|TclDater1
index|[
name|TclDate_n
index|]
index|]
operator|+
operator|*
operator|(
name|TclDate_ps
operator|-=
name|TclDate_len
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|TclDate_state
operator|>=
name|YYLAST
operator|||
name|TclDatechk
index|[
name|TclDate_state
operator|=
name|TclDateact
index|[
name|TclDate_state
index|]
index|]
operator|!=
operator|-
name|TclDate_n
condition|)
block|{
name|TclDate_state
operator|=
name|TclDateact
index|[
name|TclDatepgo
index|[
name|TclDate_n
index|]
index|]
expr_stmt|;
block|}
block|}
comment|/* save until reenter driver code */
name|TclDatestate
operator|=
name|TclDate_state
expr_stmt|;
name|TclDateps
operator|=
name|TclDate_ps
expr_stmt|;
name|TclDatepv
operator|=
name|TclDate_pv
expr_stmt|;
block|}
comment|/* 	** code supplied by user is placed in this switch 	*/
switch|switch
condition|(
name|TclDatetmp
condition|)
block|{
case|case
literal|3
case|:
block|{
name|TclDateHaveTime
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|4
case|:
block|{
name|TclDateHaveZone
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|5
case|:
block|{
name|TclDateHaveDate
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|6
case|:
block|{
name|TclDateHaveDay
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|7
case|:
block|{
name|TclDateHaveRel
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|9
case|:
block|{
name|TclDateHour
operator|=
name|TclDatepvt
index|[
operator|-
literal|1
index|]
operator|.
name|Number
expr_stmt|;
name|TclDateMinutes
operator|=
literal|0
expr_stmt|;
name|TclDateSeconds
operator|=
literal|0
expr_stmt|;
name|TclDateMeridian
operator|=
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Meridian
expr_stmt|;
block|}
break|break;
case|case
literal|10
case|:
block|{
name|TclDateHour
operator|=
name|TclDatepvt
index|[
operator|-
literal|3
index|]
operator|.
name|Number
expr_stmt|;
name|TclDateMinutes
operator|=
name|TclDatepvt
index|[
operator|-
literal|1
index|]
operator|.
name|Number
expr_stmt|;
name|TclDateSeconds
operator|=
literal|0
expr_stmt|;
name|TclDateMeridian
operator|=
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Meridian
expr_stmt|;
block|}
break|break;
case|case
literal|11
case|:
block|{
name|TclDateHour
operator|=
name|TclDatepvt
index|[
operator|-
literal|3
index|]
operator|.
name|Number
expr_stmt|;
name|TclDateMinutes
operator|=
name|TclDatepvt
index|[
operator|-
literal|1
index|]
operator|.
name|Number
expr_stmt|;
name|TclDateMeridian
operator|=
name|MER24
expr_stmt|;
name|TclDateDSTmode
operator|=
name|DSToff
expr_stmt|;
name|TclDateTimezone
operator|=
operator|-
operator|(
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Number
operator|%
literal|100
operator|+
operator|(
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Number
operator|/
literal|100
operator|)
operator|*
literal|60
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|12
case|:
block|{
name|TclDateHour
operator|=
name|TclDatepvt
index|[
operator|-
literal|5
index|]
operator|.
name|Number
expr_stmt|;
name|TclDateMinutes
operator|=
name|TclDatepvt
index|[
operator|-
literal|3
index|]
operator|.
name|Number
expr_stmt|;
name|TclDateSeconds
operator|=
name|TclDatepvt
index|[
operator|-
literal|1
index|]
operator|.
name|Number
expr_stmt|;
name|TclDateMeridian
operator|=
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Meridian
expr_stmt|;
block|}
break|break;
case|case
literal|13
case|:
block|{
name|TclDateHour
operator|=
name|TclDatepvt
index|[
operator|-
literal|5
index|]
operator|.
name|Number
expr_stmt|;
name|TclDateMinutes
operator|=
name|TclDatepvt
index|[
operator|-
literal|3
index|]
operator|.
name|Number
expr_stmt|;
name|TclDateSeconds
operator|=
name|TclDatepvt
index|[
operator|-
literal|1
index|]
operator|.
name|Number
expr_stmt|;
name|TclDateMeridian
operator|=
name|MER24
expr_stmt|;
name|TclDateDSTmode
operator|=
name|DSToff
expr_stmt|;
name|TclDateTimezone
operator|=
operator|-
operator|(
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Number
operator|%
literal|100
operator|+
operator|(
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Number
operator|/
literal|100
operator|)
operator|*
literal|60
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|14
case|:
block|{
name|TclDateTimezone
operator|=
name|TclDatepvt
index|[
operator|-
literal|1
index|]
operator|.
name|Number
expr_stmt|;
name|TclDateDSTmode
operator|=
name|DSTon
expr_stmt|;
block|}
break|break;
case|case
literal|15
case|:
block|{
name|TclDateTimezone
operator|=
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Number
expr_stmt|;
name|TclDateDSTmode
operator|=
name|DSToff
expr_stmt|;
block|}
break|break;
case|case
literal|16
case|:
block|{
name|TclDateTimezone
operator|=
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Number
expr_stmt|;
name|TclDateDSTmode
operator|=
name|DSTon
expr_stmt|;
block|}
break|break;
case|case
literal|17
case|:
block|{
name|TclDateDayOrdinal
operator|=
literal|1
expr_stmt|;
name|TclDateDayNumber
operator|=
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Number
expr_stmt|;
block|}
break|break;
case|case
literal|18
case|:
block|{
name|TclDateDayOrdinal
operator|=
literal|1
expr_stmt|;
name|TclDateDayNumber
operator|=
name|TclDatepvt
index|[
operator|-
literal|1
index|]
operator|.
name|Number
expr_stmt|;
block|}
break|break;
case|case
literal|19
case|:
block|{
name|TclDateDayOrdinal
operator|=
name|TclDatepvt
index|[
operator|-
literal|1
index|]
operator|.
name|Number
expr_stmt|;
name|TclDateDayNumber
operator|=
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Number
expr_stmt|;
block|}
break|break;
case|case
literal|20
case|:
block|{
name|TclDateMonth
operator|=
name|TclDatepvt
index|[
operator|-
literal|2
index|]
operator|.
name|Number
expr_stmt|;
name|TclDateDay
operator|=
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Number
expr_stmt|;
block|}
break|break;
case|case
literal|21
case|:
block|{
name|TclDateMonth
operator|=
name|TclDatepvt
index|[
operator|-
literal|4
index|]
operator|.
name|Number
expr_stmt|;
name|TclDateDay
operator|=
name|TclDatepvt
index|[
operator|-
literal|2
index|]
operator|.
name|Number
expr_stmt|;
name|TclDateYear
operator|=
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Number
expr_stmt|;
block|}
break|break;
case|case
literal|22
case|:
block|{
name|TclDateMonth
operator|=
name|TclDatepvt
index|[
operator|-
literal|1
index|]
operator|.
name|Number
expr_stmt|;
name|TclDateDay
operator|=
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Number
expr_stmt|;
block|}
break|break;
case|case
literal|23
case|:
block|{
name|TclDateMonth
operator|=
name|TclDatepvt
index|[
operator|-
literal|3
index|]
operator|.
name|Number
expr_stmt|;
name|TclDateDay
operator|=
name|TclDatepvt
index|[
operator|-
literal|2
index|]
operator|.
name|Number
expr_stmt|;
name|TclDateYear
operator|=
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Number
expr_stmt|;
block|}
break|break;
case|case
literal|24
case|:
block|{
name|TclDateMonth
operator|=
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Number
expr_stmt|;
name|TclDateDay
operator|=
name|TclDatepvt
index|[
operator|-
literal|1
index|]
operator|.
name|Number
expr_stmt|;
block|}
break|break;
case|case
literal|25
case|:
block|{
name|TclDateMonth
operator|=
literal|1
expr_stmt|;
name|TclDateDay
operator|=
literal|1
expr_stmt|;
name|TclDateYear
operator|=
name|EPOCH
expr_stmt|;
block|}
break|break;
case|case
literal|26
case|:
block|{
name|TclDateMonth
operator|=
name|TclDatepvt
index|[
operator|-
literal|1
index|]
operator|.
name|Number
expr_stmt|;
name|TclDateDay
operator|=
name|TclDatepvt
index|[
operator|-
literal|2
index|]
operator|.
name|Number
expr_stmt|;
name|TclDateYear
operator|=
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Number
expr_stmt|;
block|}
break|break;
case|case
literal|27
case|:
block|{
name|TclDateRelSeconds
operator|=
operator|-
name|TclDateRelSeconds
expr_stmt|;
name|TclDateRelMonth
operator|=
operator|-
name|TclDateRelMonth
expr_stmt|;
block|}
break|break;
case|case
literal|29
case|:
block|{
name|TclDateRelSeconds
operator|+=
name|TclDatepvt
index|[
operator|-
literal|1
index|]
operator|.
name|Number
operator|*
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Number
operator|*
literal|60L
expr_stmt|;
block|}
break|break;
case|case
literal|30
case|:
block|{
name|TclDateRelSeconds
operator|+=
name|TclDatepvt
index|[
operator|-
literal|1
index|]
operator|.
name|Number
operator|*
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Number
operator|*
literal|60L
expr_stmt|;
block|}
break|break;
case|case
literal|31
case|:
block|{
name|TclDateRelSeconds
operator|+=
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Number
operator|*
literal|60L
expr_stmt|;
block|}
break|break;
case|case
literal|32
case|:
block|{
name|TclDateRelSeconds
operator|+=
name|TclDatepvt
index|[
operator|-
literal|1
index|]
operator|.
name|Number
expr_stmt|;
block|}
break|break;
case|case
literal|33
case|:
block|{
name|TclDateRelSeconds
operator|+=
name|TclDatepvt
index|[
operator|-
literal|1
index|]
operator|.
name|Number
expr_stmt|;
block|}
break|break;
case|case
literal|34
case|:
block|{
name|TclDateRelSeconds
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|35
case|:
block|{
name|TclDateRelMonth
operator|+=
name|TclDatepvt
index|[
operator|-
literal|1
index|]
operator|.
name|Number
operator|*
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Number
expr_stmt|;
block|}
break|break;
case|case
literal|36
case|:
block|{
name|TclDateRelMonth
operator|+=
name|TclDatepvt
index|[
operator|-
literal|1
index|]
operator|.
name|Number
operator|*
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Number
expr_stmt|;
block|}
break|break;
case|case
literal|37
case|:
block|{
name|TclDateRelMonth
operator|+=
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Number
expr_stmt|;
block|}
break|break;
case|case
literal|38
case|:
block|{
if|if
condition|(
name|TclDateHaveTime
operator|&&
name|TclDateHaveDate
operator|&&
operator|!
name|TclDateHaveRel
condition|)
block|{
name|TclDateYear
operator|=
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Number
expr_stmt|;
block|}
else|else
block|{
name|TclDateHaveTime
operator|++
expr_stmt|;
if|if
condition|(
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Number
operator|<
literal|100
condition|)
block|{
name|TclDateHour
operator|=
literal|0
expr_stmt|;
name|TclDateMinutes
operator|=
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Number
expr_stmt|;
block|}
else|else
block|{
name|TclDateHour
operator|=
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Number
operator|/
literal|100
expr_stmt|;
name|TclDateMinutes
operator|=
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Number
operator|%
literal|100
expr_stmt|;
block|}
name|TclDateSeconds
operator|=
literal|0
expr_stmt|;
name|TclDateMeridian
operator|=
name|MER24
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|39
case|:
block|{
name|TclDateval
operator|.
name|Meridian
operator|=
name|MER24
expr_stmt|;
block|}
break|break;
case|case
literal|40
case|:
block|{
name|TclDateval
operator|.
name|Meridian
operator|=
name|TclDatepvt
index|[
operator|-
literal|0
index|]
operator|.
name|Meridian
expr_stmt|;
block|}
break|break;
block|}
goto|goto
name|TclDatestack
goto|;
comment|/* reset registers in driver code */
block|}
end_decl_stmt

end_unit

