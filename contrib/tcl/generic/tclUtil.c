begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclUtil.c --  *  *	This file contains utility procedures that are used by many Tcl  *	commands.  *  * Copyright (c) 1987-1993 The Regents of the University of California.  * Copyright (c) 1994-1995 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclUtil.c 1.112 96/02/15 11:42:52  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * The following values are used in the flags returned by Tcl_ScanElement  * and used by Tcl_ConvertElement.  The value TCL_DONT_USE_BRACES is also  * defined in tcl.h;  make sure its value doesn't overlap with any of the  * values below.  *  * TCL_DONT_USE_BRACES -	1 means the string mustn't be enclosed in  *				braces (e.g. it contains unmatched braces,  *				or ends in a backslash character, or user  *				just doesn't want braces);  handle all  *				special characters by adding backslashes.  * USE_BRACES -			1 means the string contains a special  *				character that can be handled simply by  *				enclosing the entire argument in braces.  * BRACES_UNMATCHED -		1 means that braces aren't properly matched  *				in the argument.  */
end_comment

begin_define
define|#
directive|define
name|USE_BRACES
value|2
end_define

begin_define
define|#
directive|define
name|BRACES_UNMATCHED
value|4
end_define

begin_comment
comment|/*  * Function prototypes for local procedures in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|SetupAppendBuffer
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Interp
operator|*
name|iPtr
operator|,
name|int
name|newSpace
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclFindElement --  *  *	Given a pointer into a Tcl list, locate the first (or next)  *	element in the list.  *  * Results:  *	The return value is normally TCL_OK, which means that the  *	element was successfully located.  If TCL_ERROR is returned  *	it means that list didn't have proper list structure;  *	interp->result contains a more detailed error message.  *  *	If TCL_OK is returned, then *elementPtr will be set to point  *	to the first element of list, and *nextPtr will be set to point  *	to the character just after any white space following the last  *	character that's part of the element.  If this is the last argument  *	in the list, then *nextPtr will point to the NULL character at the  *	end of list.  If sizePtr is non-NULL, *sizePtr is filled in with  *	the number of characters in the element.  If the element is in  *	braces, then *elementPtr will point to the character after the  *	opening brace and *sizePtr will not include either of the braces.  *	If there isn't an element in the list, *sizePtr will be zero, and  *	both *elementPtr and *termPtr will refer to the null character at  *	the end of list.  Note:  this procedure does NOT collapse backslash  *	sequences.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclFindElement
parameter_list|(
name|interp
parameter_list|,
name|list
parameter_list|,
name|elementPtr
parameter_list|,
name|nextPtr
parameter_list|,
name|sizePtr
parameter_list|,
name|bracePtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for error reporting.  				 * If NULL, then no error message is left 				 * after errors. */
specifier|register
name|char
modifier|*
name|list
decl_stmt|;
comment|/* String containing Tcl list with zero 				 * or more elements (possibly in braces). */
name|char
modifier|*
modifier|*
name|elementPtr
decl_stmt|;
comment|/* Fill in with location of first significant 				 * character in first element of list. */
name|char
modifier|*
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Fill in with location of character just 				 * after all white space following end of 				 * argument (i.e. next argument or end of 				 * list). */
name|int
modifier|*
name|sizePtr
decl_stmt|;
comment|/* If non-zero, fill in with size of 				 * element. */
name|int
modifier|*
name|bracePtr
decl_stmt|;
comment|/* If non-zero fill in with non-zero/zero 				 * to indicate that arg was/wasn't 				 * in braces. */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|openBraces
init|=
literal|0
decl_stmt|;
name|int
name|inQuotes
init|=
literal|0
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/*      * Skim off leading white space and check for an opening brace or      * quote.   Note:  use of "isascii" below and elsewhere in this      * procedure is a temporary hack (7/27/90) because Mx uses characters      * with the high-order bit set for some things.  This should probably      * be changed back eventually, or all of Tcl should call isascii.      */
while|while
condition|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|list
argument_list|)
argument_list|)
condition|)
block|{
name|list
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|list
operator|==
literal|'{'
condition|)
block|{
name|openBraces
operator|=
literal|1
expr_stmt|;
name|list
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|list
operator|==
literal|'"'
condition|)
block|{
name|inQuotes
operator|=
literal|1
expr_stmt|;
name|list
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bracePtr
operator|!=
literal|0
condition|)
block|{
operator|*
name|bracePtr
operator|=
name|openBraces
expr_stmt|;
block|}
name|p
operator|=
name|list
expr_stmt|;
comment|/*      * Find the end of the element (either a space or a close brace or      * the end of the string).      */
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
comment|/* 	     * Open brace: don't treat specially unless the element is 	     * in braces.  In this case, keep a nesting count. 	     */
case|case
literal|'{'
case|:
if|if
condition|(
name|openBraces
operator|!=
literal|0
condition|)
block|{
name|openBraces
operator|++
expr_stmt|;
block|}
break|break;
comment|/* 	     * Close brace: if element is in braces, keep nesting 	     * count and quit when the last close brace is seen. 	     */
case|case
literal|'}'
case|:
if|if
condition|(
name|openBraces
operator|==
literal|1
condition|)
block|{
name|char
modifier|*
name|p2
decl_stmt|;
name|size
operator|=
name|p
operator|-
name|list
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|0
operator|)
condition|)
block|{
goto|goto
name|done
goto|;
block|}
for|for
control|(
name|p2
operator|=
name|p
init|;
operator|(
operator|*
name|p2
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|!
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p2
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|p2
operator|<
name|p
operator|+
literal|20
operator|)
condition|;
name|p2
operator|++
control|)
block|{
comment|/* null body */
block|}
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"list element in braces followed by \"%.*s\" instead of space"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p2
operator|-
name|p
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|openBraces
operator|!=
literal|0
condition|)
block|{
name|openBraces
operator|--
expr_stmt|;
block|}
break|break;
comment|/* 	     * Backslash:  skip over everything up to the end of the 	     * backslash sequence. 	     */
case|case
literal|'\\'
case|:
block|{
name|int
name|size
decl_stmt|;
operator|(
name|void
operator|)
name|Tcl_Backslash
argument_list|(
name|p
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|p
operator|+=
name|size
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 	     * Space: ignore if element is in braces or quotes;  otherwise 	     * terminate element. 	     */
case|case
literal|' '
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\v'
case|:
if|if
condition|(
operator|(
name|openBraces
operator|==
literal|0
operator|)
operator|&&
operator|!
name|inQuotes
condition|)
block|{
name|size
operator|=
name|p
operator|-
name|list
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
comment|/* 	     * Double-quote:  if element is in quotes then terminate it. 	     */
case|case
literal|'"'
case|:
if|if
condition|(
name|inQuotes
condition|)
block|{
name|char
modifier|*
name|p2
decl_stmt|;
name|size
operator|=
name|p
operator|-
name|list
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|0
operator|)
condition|)
block|{
goto|goto
name|done
goto|;
block|}
for|for
control|(
name|p2
operator|=
name|p
init|;
operator|(
operator|*
name|p2
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|!
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p2
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|p2
operator|<
name|p
operator|+
literal|20
operator|)
condition|;
name|p2
operator|++
control|)
block|{
comment|/* null body */
block|}
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|interp
operator|->
name|result
argument_list|,
literal|"list element in quotes followed by \"%.*s\" %s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p2
operator|-
name|p
argument_list|)
argument_list|,
name|p
argument_list|,
literal|"instead of space"
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
break|break;
comment|/* 	     * End of list:  terminate element. 	     */
case|case
literal|0
case|:
if|if
condition|(
name|openBraces
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"unmatched open brace in list"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|inQuotes
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"unmatched open quote in list"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
name|size
operator|=
name|p
operator|-
name|list
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|p
operator|++
expr_stmt|;
block|}
name|done
label|:
while|while
condition|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|elementPtr
operator|=
name|list
expr_stmt|;
operator|*
name|nextPtr
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|sizePtr
operator|!=
literal|0
condition|)
block|{
operator|*
name|sizePtr
operator|=
name|size
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCopyAndCollapse --  *  *	Copy a string and eliminate any backslashes that aren't in braces.  *  * Results:  *	There is no return value.  Count chars. get copied from src  *	to dst.  Along the way, if backslash sequences are found outside  *	braces, the backslashes are eliminated in the copy.  *	After scanning count chars. from source, a null character is  *	placed at the end of dst.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclCopyAndCollapse
parameter_list|(
name|count
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|int
name|count
decl_stmt|;
comment|/* Total number of characters to copy 				 * from src. */
specifier|register
name|char
modifier|*
name|src
decl_stmt|;
comment|/* Copy from here... */
specifier|register
name|char
modifier|*
name|dst
decl_stmt|;
comment|/* ... to here. */
block|{
specifier|register
name|char
name|c
decl_stmt|;
name|int
name|numRead
decl_stmt|;
for|for
control|(
name|c
operator|=
operator|*
name|src
init|;
name|count
operator|>
literal|0
condition|;
name|src
operator|++
operator|,
name|c
operator|=
operator|*
name|src
operator|,
name|count
operator|--
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|dst
operator|=
name|Tcl_Backslash
argument_list|(
name|src
argument_list|,
operator|&
name|numRead
argument_list|)
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|src
operator|+=
name|numRead
operator|-
literal|1
expr_stmt|;
name|count
operator|-=
name|numRead
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dst
operator|=
name|c
expr_stmt|;
name|dst
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|dst
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SplitList --  *  *	Splits a list up into its constituent fields.  *  * Results  *	The return value is normally TCL_OK, which means that  *	the list was successfully split up.  If TCL_ERROR is  *	returned, it means that "list" didn't have proper list  *	structure;  interp->result will contain a more detailed  *	error message.  *  *	*argvPtr will be filled in with the address of an array  *	whose elements point to the elements of list, in order.  *	*argcPtr will get filled in with the number of valid elements  *	in the array.  A single block of memory is dynamically allocated  *	to hold both the argv array and a copy of the list (with  *	backslashes and braces removed in the standard way).  *	The caller must eventually free this memory by calling free()  *	on *argvPtr.  Note:  *argvPtr and *argcPtr are only modified  *	if the procedure returns normally.  *  * Side effects:  *	Memory is allocated.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_SplitList
parameter_list|(
name|interp
parameter_list|,
name|list
parameter_list|,
name|argcPtr
parameter_list|,
name|argvPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for error reporting.  				 * If NULL, then no error message is left. */
name|char
modifier|*
name|list
decl_stmt|;
comment|/* Pointer to string with list structure. */
name|int
modifier|*
name|argcPtr
decl_stmt|;
comment|/* Pointer to location to fill in with 				 * the number of elements in the list. */
name|char
modifier|*
modifier|*
modifier|*
name|argvPtr
decl_stmt|;
comment|/* Pointer to place to store pointer to array 				 * of pointers to list elements. */
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|size
decl_stmt|,
name|i
decl_stmt|,
name|result
decl_stmt|,
name|elSize
decl_stmt|,
name|brace
decl_stmt|;
name|char
modifier|*
name|element
decl_stmt|;
comment|/*      * Figure out how much space to allocate.  There must be enough      * space for both the array of pointers and also for a copy of      * the list.  To estimate the number of pointers needed, count      * the number of space characters in the list.      */
for|for
control|(
name|size
operator|=
literal|1
operator|,
name|p
operator|=
name|list
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|size
operator|++
expr_stmt|;
block|}
block|}
name|size
operator|++
expr_stmt|;
comment|/* Leave space for final NULL pointer. */
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
operator|+
operator|(
name|p
operator|-
name|list
operator|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|argv
operator|)
operator|+
name|size
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
init|;
operator|*
name|list
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
name|TclFindElement
argument_list|(
name|interp
argument_list|,
name|list
argument_list|,
operator|&
name|element
argument_list|,
operator|&
name|list
argument_list|,
operator|&
name|elSize
argument_list|,
operator|&
name|brace
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
operator|*
name|element
operator|==
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|size
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"internal error in Tcl_SplitList"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
name|argv
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|brace
condition|)
block|{
name|strncpy
argument_list|(
name|p
argument_list|,
name|element
argument_list|,
operator|(
name|size_t
operator|)
name|elSize
argument_list|)
expr_stmt|;
name|p
operator|+=
name|elSize
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
name|TclCopyAndCollapse
argument_list|(
name|elSize
argument_list|,
name|element
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|elSize
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|argv
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|argvPtr
operator|=
name|argv
expr_stmt|;
operator|*
name|argcPtr
operator|=
name|i
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ScanElement --  *  *	This procedure is a companion procedure to Tcl_ConvertElement.  *	It scans a string to see what needs to be done to it (e.g.  *	add backslashes or enclosing braces) to make the string into  *	a valid Tcl list element.  *  * Results:  *	The return value is an overestimate of the number of characters  *	that will be needed by Tcl_ConvertElement to produce a valid  *	list element from string.  The word at *flagPtr is filled in  *	with a value needed by Tcl_ConvertElement when doing the actual  *	conversion.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_ScanElement
parameter_list|(
name|string
parameter_list|,
name|flagPtr
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String to convert to Tcl list element. */
name|int
modifier|*
name|flagPtr
decl_stmt|;
comment|/* Where to store information to guide 				 * Tcl_ConvertElement. */
block|{
name|int
name|flags
decl_stmt|,
name|nestingLevel
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/*      * This procedure and Tcl_ConvertElement together do two things:      *      * 1. They produce a proper list, one that will yield back the      * argument strings when evaluated or when disassembled with      * Tcl_SplitList.  This is the most important thing.      *       * 2. They try to produce legible output, which means minimizing the      * use of backslashes (using braces instead).  However, there are      * some situations where backslashes must be used (e.g. an element      * like "{abc": the leading brace will have to be backslashed.  For      * each element, one of three things must be done:      *      * (a) Use the element as-is (it doesn't contain anything special      * characters).  This is the most desirable option.      *      * (b) Enclose the element in braces, but leave the contents alone.      * This happens if the element contains embedded space, or if it      * contains characters with special interpretation ($, [, ;, or \),      * or if it starts with a brace or double-quote, or if there are      * no characters in the element.      *      * (c) Don't enclose the element in braces, but add backslashes to      * prevent special interpretation of special characters.  This is a      * last resort used when the argument would normally fall under case      * (b) but contains unmatched braces.  It also occurs if the last      * character of the argument is a backslash or if the element contains      * a backslash followed by newline.      *      * The procedure figures out how many bytes will be needed to store      * the result (actually, it overestimates).  It also collects information      * about the element in the form of a flags word.      */
name|nestingLevel
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
condition|)
block|{
name|string
operator|=
literal|""
expr_stmt|;
block|}
name|p
operator|=
name|string
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'{'
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'"'
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|0
operator|)
condition|)
block|{
name|flags
operator||=
name|USE_BRACES
expr_stmt|;
block|}
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'{'
case|:
name|nestingLevel
operator|++
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|nestingLevel
operator|--
expr_stmt|;
if|if
condition|(
name|nestingLevel
operator|<
literal|0
condition|)
block|{
name|flags
operator||=
name|TCL_DONT_USE_BRACES
operator||
name|BRACES_UNMATCHED
expr_stmt|;
block|}
break|break;
case|case
literal|'['
case|:
case|case
literal|'$'
case|:
case|case
literal|';'
case|:
case|case
literal|' '
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\v'
case|:
name|flags
operator||=
name|USE_BRACES
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|flags
operator|=
name|TCL_DONT_USE_BRACES
expr_stmt|;
block|}
else|else
block|{
name|int
name|size
decl_stmt|;
operator|(
name|void
operator|)
name|Tcl_Backslash
argument_list|(
name|p
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|p
operator|+=
name|size
operator|-
literal|1
expr_stmt|;
name|flags
operator||=
name|USE_BRACES
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|nestingLevel
operator|!=
literal|0
condition|)
block|{
name|flags
operator|=
name|TCL_DONT_USE_BRACES
operator||
name|BRACES_UNMATCHED
expr_stmt|;
block|}
operator|*
name|flagPtr
operator|=
name|flags
expr_stmt|;
comment|/*      * Allow enough space to backslash every character plus leave      * two spaces for braces.      */
return|return
literal|2
operator|*
operator|(
name|p
operator|-
name|string
operator|)
operator|+
literal|2
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ConvertElement --  *  *	This is a companion procedure to Tcl_ScanElement.  Given the  *	information produced by Tcl_ScanElement, this procedure converts  *	a string to a list element equal to that string.  *  * Results:  *	Information is copied to *dst in the form of a list element  *	identical to src (i.e. if Tcl_SplitList is applied to dst it  *	will produce a string identical to src).  The return value is  *	a count of the number of characters copied (not including the  *	terminating NULL character).  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_ConvertElement
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|flags
parameter_list|)
specifier|register
name|char
modifier|*
name|src
decl_stmt|;
comment|/* Source information for list element. */
name|char
modifier|*
name|dst
decl_stmt|;
comment|/* Place to put list-ified element. */
name|int
name|flags
decl_stmt|;
comment|/* Flags produced by Tcl_ScanElement. */
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|dst
decl_stmt|;
comment|/*      * See the comment block at the beginning of the Tcl_ScanElement      * code for details of how this works.      */
if|if
condition|(
operator|(
name|src
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|src
operator|==
literal|0
operator|)
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
literal|'{'
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|'}'
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|USE_BRACES
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|TCL_DONT_USE_BRACES
operator|)
condition|)
block|{
operator|*
name|p
operator|=
literal|'{'
expr_stmt|;
name|p
operator|++
expr_stmt|;
for|for
control|(
init|;
operator|*
name|src
operator|!=
literal|0
condition|;
name|src
operator|++
operator|,
name|p
operator|++
control|)
block|{
operator|*
name|p
operator|=
operator|*
name|src
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'}'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|src
operator|==
literal|'{'
condition|)
block|{
comment|/* 	     * Can't have a leading brace unless the whole element is 	     * enclosed in braces.  Add a backslash before the brace. 	     * Furthermore, this may destroy the balance between open 	     * and close braces, so set BRACES_UNMATCHED. 	     */
name|p
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|'{'
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|flags
operator||=
name|BRACES_UNMATCHED
expr_stmt|;
block|}
for|for
control|(
init|;
operator|*
name|src
operator|!=
literal|0
condition|;
name|src
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|src
condition|)
block|{
case|case
literal|']'
case|:
case|case
literal|'['
case|:
case|case
literal|'$'
case|:
case|case
literal|';'
case|:
case|case
literal|' '
case|:
case|case
literal|'\\'
case|:
case|case
literal|'"'
case|:
operator|*
name|p
operator|=
literal|'\\'
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
case|case
literal|'}'
case|:
comment|/* 		     * It may not seem necessary to backslash braces, but 		     * it is.  The reason for this is that the resulting 		     * list element may actually be an element of a sub-list 		     * enclosed in braces (e.g. if Tcl_DStringStartSublist 		     * has been invoked), so there may be a brace mismatch 		     * if the braces aren't backslashed. 		     */
if|if
condition|(
name|flags
operator|&
name|BRACES_UNMATCHED
condition|)
block|{
operator|*
name|p
operator|=
literal|'\\'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'\f'
case|:
operator|*
name|p
operator|=
literal|'\\'
expr_stmt|;
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'f'
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'\n'
case|:
operator|*
name|p
operator|=
literal|'\\'
expr_stmt|;
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'n'
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'\r'
case|:
operator|*
name|p
operator|=
literal|'\\'
expr_stmt|;
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'r'
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'\t'
case|:
operator|*
name|p
operator|=
literal|'\\'
expr_stmt|;
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'t'
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'\v'
case|:
operator|*
name|p
operator|=
literal|'\\'
expr_stmt|;
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'v'
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
operator|*
name|p
operator|=
operator|*
name|src
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|p
operator|-
name|dst
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_Merge --  *  *	Given a collection of strings, merge them together into a  *	single string that has proper Tcl list structured (i.e.  *	Tcl_SplitList may be used to retrieve strings equal to the  *	original elements, and Tcl_Eval will parse the string back  *	into its original elements).  *  * Results:  *	The return value is the address of a dynamically-allocated  *	string containing the merged list.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_Merge
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
comment|/* How many strings to merge. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Array of string values. */
block|{
define|#
directive|define
name|LOCAL_SIZE
value|20
name|int
name|localFlags
index|[
name|LOCAL_SIZE
index|]
decl_stmt|,
modifier|*
name|flagPtr
decl_stmt|;
name|int
name|numChars
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
specifier|register
name|char
modifier|*
name|dst
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*      * Pass 1: estimate space, gather flags.      */
if|if
condition|(
name|argc
operator|<=
name|LOCAL_SIZE
condition|)
block|{
name|flagPtr
operator|=
name|localFlags
expr_stmt|;
block|}
else|else
block|{
name|flagPtr
operator|=
operator|(
name|int
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|numChars
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|numChars
operator|+=
name|Tcl_ScanElement
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
operator|&
name|flagPtr
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
comment|/*      * Pass two: copy into the result area.      */
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|numChars
argument_list|)
expr_stmt|;
name|dst
operator|=
name|result
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|numChars
operator|=
name|Tcl_ConvertElement
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|dst
argument_list|,
name|flagPtr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|numChars
expr_stmt|;
operator|*
name|dst
operator|=
literal|' '
expr_stmt|;
name|dst
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dst
operator|==
name|result
condition|)
block|{
operator|*
name|dst
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|dst
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flagPtr
operator|!=
name|localFlags
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|flagPtr
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_Concat --  *  *	Concatenate a set of strings into a single large string.  *  * Results:  *	The return value is dynamically-allocated string containing  *	a concatenation of all the strings in argv, with spaces between  *	the original argv elements.  *  * Side effects:  *	Memory is allocated for the result;  the caller is responsible  *	for freeing the memory.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_Concat
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
comment|/* Number of strings to concatenate. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Array of strings to concatenate. */
block|{
name|int
name|totalSize
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
for|for
control|(
name|totalSize
operator|=
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|totalSize
operator|+=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|totalSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
operator|*
name|result
operator|=
literal|'\0'
expr_stmt|;
return|return
name|result
return|;
block|}
for|for
control|(
name|p
operator|=
name|result
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|element
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* 	 * Clip white space off the front and back of the string 	 * to generate a neater result, and ignore any empty 	 * elements. 	 */
name|element
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|element
argument_list|)
argument_list|)
condition|)
block|{
name|element
operator|++
expr_stmt|;
block|}
for|for
control|(
name|length
operator|=
name|strlen
argument_list|(
name|element
argument_list|)
init|;
operator|(
name|length
operator|>
literal|0
operator|)
operator|&&
operator|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
name|element
index|[
name|length
operator|-
literal|1
index|]
argument_list|)
argument_list|)
operator|)
condition|;
name|length
operator|--
control|)
block|{
comment|/* Null loop body. */
block|}
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|p
argument_list|,
name|element
argument_list|,
operator|(
name|size_t
operator|)
name|length
argument_list|)
expr_stmt|;
name|p
operator|+=
name|length
expr_stmt|;
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
name|result
condition|)
block|{
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_StringMatch --  *  *	See if a particular string matches a particular pattern.  *  * Results:  *	The return value is 1 if string matches pattern, and  *	0 otherwise.  The matching operation permits the following  *	special characters in the pattern: *?\[] (see the manual  *	entry for details on what these mean).  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_StringMatch
parameter_list|(
name|string
parameter_list|,
name|pattern
parameter_list|)
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String. */
specifier|register
name|char
modifier|*
name|pattern
decl_stmt|;
comment|/* Pattern, which may contain 				 * special characters. */
block|{
name|char
name|c2
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* See if we're at the end of both the pattern and the string. 	 * If so, we succeeded.  If we're at the end of the pattern 	 * but not at the end of the string, we failed. 	 */
if|if
condition|(
operator|*
name|pattern
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|string
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|(
operator|*
name|string
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|*
name|pattern
operator|!=
literal|'*'
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* Check for a "*" as the next pattern character.  It matches 	 * any substring.  We handle this by calling ourselves 	 * recursively for each postfix of string, until either we 	 * match or we reach the end of the string. 	 */
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'*'
condition|)
block|{
name|pattern
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|pattern
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|Tcl_StringMatch
argument_list|(
name|string
argument_list|,
name|pattern
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|string
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|string
operator|+=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Check for a "?" as the next pattern character.  It matches 	 * any single character. 	 */
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'?'
condition|)
block|{
goto|goto
name|thisCharOK
goto|;
block|}
comment|/* Check for a "[" as the next pattern character.  It is followed 	 * by a list of characters that are acceptable, or by a range 	 * (two characters separated by "-"). 	 */
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'['
condition|)
block|{
name|pattern
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|pattern
operator|==
literal|']'
operator|)
operator|||
operator|(
operator|*
name|pattern
operator|==
literal|0
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|*
name|pattern
operator|==
operator|*
name|string
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|pattern
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|c2
operator|=
name|pattern
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|c2
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|pattern
operator|<=
operator|*
name|string
operator|)
operator|&&
operator|(
name|c2
operator|>=
operator|*
name|string
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|(
operator|*
name|pattern
operator|>=
operator|*
name|string
operator|)
operator|&&
operator|(
name|c2
operator|<=
operator|*
name|string
operator|)
condition|)
block|{
break|break;
block|}
name|pattern
operator|+=
literal|2
expr_stmt|;
block|}
name|pattern
operator|+=
literal|1
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|pattern
operator|!=
literal|']'
condition|)
block|{
if|if
condition|(
operator|*
name|pattern
operator|==
literal|0
condition|)
block|{
name|pattern
operator|--
expr_stmt|;
break|break;
block|}
name|pattern
operator|+=
literal|1
expr_stmt|;
block|}
goto|goto
name|thisCharOK
goto|;
block|}
comment|/* If the next pattern character is '/', just strip off the '/' 	 * so we do exact matching on the character that follows. 	 */
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'\\'
condition|)
block|{
name|pattern
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|pattern
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
comment|/* There's no special character.  Just make sure that the next 	 * characters of each string match. 	 */
if|if
condition|(
operator|*
name|pattern
operator|!=
operator|*
name|string
condition|)
block|{
return|return
literal|0
return|;
block|}
name|thisCharOK
label|:
name|pattern
operator|+=
literal|1
expr_stmt|;
name|string
operator|+=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetResult --  *  *	Arrange for "string" to be the Tcl return value.  *  * Results:  *	None.  *  * Side effects:  *	interp->result is left pointing either to "string" (if "copy" is 0)  *	or to a copy of string.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_SetResult
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|freeProc
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter with which to associate the 				 * return value. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Value to be returned.  If NULL, 				 * the result is set to an empty string. */
name|Tcl_FreeProc
modifier|*
name|freeProc
decl_stmt|;
comment|/* Gives information about the string: 				 * TCL_STATIC, TCL_VOLATILE, or the address 				 * of a Tcl_FreeProc such as free. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|int
name|length
decl_stmt|;
name|Tcl_FreeProc
modifier|*
name|oldFreeProc
init|=
name|iPtr
operator|->
name|freeProc
decl_stmt|;
name|char
modifier|*
name|oldResult
init|=
name|iPtr
operator|->
name|result
decl_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
condition|)
block|{
name|iPtr
operator|->
name|resultSpace
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|iPtr
operator|->
name|result
operator|=
name|iPtr
operator|->
name|resultSpace
expr_stmt|;
name|iPtr
operator|->
name|freeProc
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|freeProc
operator|==
name|TCL_DYNAMIC
condition|)
block|{
name|iPtr
operator|->
name|result
operator|=
name|string
expr_stmt|;
name|iPtr
operator|->
name|freeProc
operator|=
name|TCL_DYNAMIC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|freeProc
operator|==
name|TCL_VOLATILE
condition|)
block|{
name|length
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
name|TCL_RESULT_SIZE
condition|)
block|{
name|iPtr
operator|->
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|freeProc
operator|=
name|TCL_DYNAMIC
expr_stmt|;
block|}
else|else
block|{
name|iPtr
operator|->
name|result
operator|=
name|iPtr
operator|->
name|resultSpace
expr_stmt|;
name|iPtr
operator|->
name|freeProc
operator|=
literal|0
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|iPtr
operator|->
name|result
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iPtr
operator|->
name|result
operator|=
name|string
expr_stmt|;
name|iPtr
operator|->
name|freeProc
operator|=
name|freeProc
expr_stmt|;
block|}
comment|/*      * If the old result was dynamically-allocated, free it up.  Do it      * here, rather than at the beginning, in case the new result value      * was part of the old result value.      */
if|if
condition|(
name|oldFreeProc
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|oldFreeProc
operator|==
name|TCL_DYNAMIC
operator|)
operator|||
operator|(
name|oldFreeProc
operator|==
operator|(
name|Tcl_FreeProc
operator|*
operator|)
name|free
operator|)
condition|)
block|{
name|ckfree
argument_list|(
name|oldResult
argument_list|)
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|oldFreeProc
call|)
argument_list|(
name|oldResult
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_AppendResult --  *  *	Append a variable number of strings onto the result already  *	present for an interpreter.  *  * Results:  *	None.  *  * Side effects:  *	The result in the interpreter given by the first argument  *	is extended by the strings given by the second and following  *	arguments (up to a terminating NULL argument).  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* VARARGS2 */
end_comment

begin_function
name|void
name|Tcl_AppendResult
name|TCL_VARARGS_DEF
parameter_list|(
name|Tcl_Interp
modifier|*
parameter_list|,
name|arg1
parameter_list|)
block|{
name|va_list
name|argList
decl_stmt|;
specifier|register
name|Interp
modifier|*
name|iPtr
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|newSpace
decl_stmt|;
comment|/*      * First, scan through all the arguments to see how much space is      * needed.      */
name|iPtr
operator|=
operator|(
name|Interp
operator|*
operator|)
name|TCL_VARARGS_START
argument_list|(
name|Tcl_Interp
operator|*
argument_list|,
name|arg1
argument_list|,
name|argList
argument_list|)
expr_stmt|;
name|newSpace
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|string
operator|=
name|va_arg
argument_list|(
name|argList
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|newSpace
operator|+=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|argList
argument_list|)
expr_stmt|;
comment|/*      * If the append buffer isn't already setup and large enough      * to hold the new data, set it up.      */
if|if
condition|(
operator|(
name|iPtr
operator|->
name|result
operator|!=
name|iPtr
operator|->
name|appendResult
operator|)
operator|||
operator|(
name|iPtr
operator|->
name|appendResult
index|[
name|iPtr
operator|->
name|appendUsed
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|newSpace
operator|+
name|iPtr
operator|->
name|appendUsed
operator|)
operator|>=
name|iPtr
operator|->
name|appendAvl
operator|)
condition|)
block|{
name|SetupAppendBuffer
argument_list|(
name|iPtr
argument_list|,
name|newSpace
argument_list|)
expr_stmt|;
block|}
comment|/*      * Final step:  go through all the argument strings again, copying      * them into the buffer.      */
name|TCL_VARARGS_START
argument_list|(
name|Tcl_Interp
operator|*
argument_list|,
name|arg1
argument_list|,
name|argList
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|string
operator|=
name|va_arg
argument_list|(
name|argList
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|strcpy
argument_list|(
name|iPtr
operator|->
name|appendResult
operator|+
name|iPtr
operator|->
name|appendUsed
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|appendUsed
operator|+=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|argList
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_AppendElement --  *  *	Convert a string to a valid Tcl list element and append it  *	to the current result (which is ostensibly a list).  *  * Results:  *	None.  *  * Side effects:  *	The result in the interpreter given by the first argument  *	is extended with a list element converted from string.  A  *	separator space is added before the converted list element  *	unless the current result is empty, contains the single  *	character "{", or ends in " {".  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_AppendElement
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter whose result is to be 				 * extended. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String to convert to list element and 				 * add to result. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|int
name|size
decl_stmt|,
name|flags
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
comment|/*      * See how much space is needed, and grow the append buffer if      * needed to accommodate the list element.      */
name|size
operator|=
name|Tcl_ScanElement
argument_list|(
name|string
argument_list|,
operator|&
name|flags
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|iPtr
operator|->
name|result
operator|!=
name|iPtr
operator|->
name|appendResult
operator|)
operator|||
operator|(
name|iPtr
operator|->
name|appendResult
index|[
name|iPtr
operator|->
name|appendUsed
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|size
operator|+
name|iPtr
operator|->
name|appendUsed
operator|)
operator|>=
name|iPtr
operator|->
name|appendAvl
operator|)
condition|)
block|{
name|SetupAppendBuffer
argument_list|(
name|iPtr
argument_list|,
name|size
operator|+
name|iPtr
operator|->
name|appendUsed
argument_list|)
expr_stmt|;
block|}
comment|/*      * Convert the string into a list element and copy it to the      * buffer that's forming, with a space separator if needed.      */
name|dst
operator|=
name|iPtr
operator|->
name|appendResult
operator|+
name|iPtr
operator|->
name|appendUsed
expr_stmt|;
if|if
condition|(
name|TclNeedSpace
argument_list|(
name|iPtr
operator|->
name|appendResult
argument_list|,
name|dst
argument_list|)
condition|)
block|{
name|iPtr
operator|->
name|appendUsed
operator|++
expr_stmt|;
operator|*
name|dst
operator|=
literal|' '
expr_stmt|;
name|dst
operator|++
expr_stmt|;
block|}
name|iPtr
operator|->
name|appendUsed
operator|+=
name|Tcl_ConvertElement
argument_list|(
name|string
argument_list|,
name|dst
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SetupAppendBuffer --  *  *	This procedure makes sure that there is an append buffer  *	properly initialized for interp, and that it has at least  *	enough room to accommodate newSpace new bytes of information.  *  * Results:  *	None.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|SetupAppendBuffer
parameter_list|(
name|iPtr
parameter_list|,
name|newSpace
parameter_list|)
specifier|register
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Interpreter whose result is being set up. */
name|int
name|newSpace
decl_stmt|;
comment|/* Make sure that at least this many bytes 				 * of new information may be added. */
block|{
name|int
name|totalSpace
decl_stmt|;
comment|/*      * Make the append buffer larger, if that's necessary, then      * copy the current result into the append buffer and make the      * append buffer the official Tcl result.      */
if|if
condition|(
name|iPtr
operator|->
name|result
operator|!=
name|iPtr
operator|->
name|appendResult
condition|)
block|{
comment|/* 	 * If an oversized buffer was used recently, then free it up 	 * so we go back to a smaller buffer.  This avoids tying up 	 * memory forever after a large operation. 	 */
if|if
condition|(
name|iPtr
operator|->
name|appendAvl
operator|>
literal|500
condition|)
block|{
name|ckfree
argument_list|(
name|iPtr
operator|->
name|appendResult
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|appendResult
operator|=
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|appendAvl
operator|=
literal|0
expr_stmt|;
block|}
name|iPtr
operator|->
name|appendUsed
operator|=
name|strlen
argument_list|(
name|iPtr
operator|->
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iPtr
operator|->
name|result
index|[
name|iPtr
operator|->
name|appendUsed
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* 	 * Most likely someone has modified a result created by 	 * Tcl_AppendResult et al. so that it has a different size. 	 * Just recompute the size. 	 */
name|iPtr
operator|->
name|appendUsed
operator|=
name|strlen
argument_list|(
name|iPtr
operator|->
name|result
argument_list|)
expr_stmt|;
block|}
name|totalSpace
operator|=
name|newSpace
operator|+
name|iPtr
operator|->
name|appendUsed
expr_stmt|;
if|if
condition|(
name|totalSpace
operator|>=
name|iPtr
operator|->
name|appendAvl
condition|)
block|{
name|char
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|totalSpace
operator|<
literal|100
condition|)
block|{
name|totalSpace
operator|=
literal|200
expr_stmt|;
block|}
else|else
block|{
name|totalSpace
operator|*=
literal|2
expr_stmt|;
block|}
name|new
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|totalSpace
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new
argument_list|,
name|iPtr
operator|->
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|appendResult
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|iPtr
operator|->
name|appendResult
argument_list|)
expr_stmt|;
block|}
name|iPtr
operator|->
name|appendResult
operator|=
name|new
expr_stmt|;
name|iPtr
operator|->
name|appendAvl
operator|=
name|totalSpace
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iPtr
operator|->
name|result
operator|!=
name|iPtr
operator|->
name|appendResult
condition|)
block|{
name|strcpy
argument_list|(
name|iPtr
operator|->
name|appendResult
argument_list|,
name|iPtr
operator|->
name|result
argument_list|)
expr_stmt|;
block|}
name|Tcl_FreeResult
argument_list|(
name|iPtr
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|result
operator|=
name|iPtr
operator|->
name|appendResult
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ResetResult --  *  *	This procedure restores the result area for an interpreter  *	to its default initialized state, freeing up any memory that  *	may have been allocated for the result and clearing any  *	error information for the interpreter.  *  * Results:  *	None.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_ResetResult
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter for which to clear result. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Tcl_FreeResult
argument_list|(
name|iPtr
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|result
operator|=
name|iPtr
operator|->
name|resultSpace
expr_stmt|;
name|iPtr
operator|->
name|resultSpace
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|iPtr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|ERR_ALREADY_LOGGED
operator||
name|ERR_IN_PROGRESS
operator||
name|ERROR_CODE_SET
operator|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetErrorCode --  *  *	This procedure is called to record machine-readable information  *	about an error that is about to be returned.  *  * Results:  *	None.  *  * Side effects:  *	The errorCode global variable is modified to hold all of the  *	arguments to this procedure, in a list form with each argument  *	becoming one element of the list.  A flag is set internally  *	to remember that errorCode has been set, so the variable doesn't  *	get set automatically when the error is returned.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* VARARGS2 */
end_comment

begin_function
name|void
name|Tcl_SetErrorCode
name|TCL_VARARGS_DEF
parameter_list|(
name|Tcl_Interp
modifier|*
parameter_list|,
name|arg1
parameter_list|)
block|{
name|va_list
name|argList
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/*      * Scan through the arguments one at a time, appending them to      * $errorCode as list elements.      */
name|iPtr
operator|=
operator|(
name|Interp
operator|*
operator|)
name|TCL_VARARGS_START
argument_list|(
name|Tcl_Interp
operator|*
argument_list|,
name|arg1
argument_list|,
name|argList
argument_list|)
expr_stmt|;
name|flags
operator|=
name|TCL_GLOBAL_ONLY
operator||
name|TCL_LIST_ELEMENT
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|string
operator|=
name|va_arg
argument_list|(
name|argList
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
operator|(
name|void
operator|)
name|Tcl_SetVar2
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|string
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|flags
operator||=
name|TCL_APPEND_VALUE
expr_stmt|;
block|}
name|va_end
argument_list|(
name|argList
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|flags
operator||=
name|ERROR_CODE_SET
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclGetListIndex --  *  *	Parse a list index, which may be either an integer or the  *	value "end".  *  * Results:  *	The return value is either TCL_OK or TCL_ERROR.  If it is  *	TCL_OK, then the index corresponding to string is left in  *	*indexPtr.  If the return value is TCL_ERROR, then string  *	was bogus;  an error message is returned in interp->result.  *	If a negative index is specified, it is rounded up to 0.  *	The index value may be larger than the size of the list  *	(this happens when "end" is specified).  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclGetListIndex
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|indexPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter for error reporting. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String containing list index. */
name|int
modifier|*
name|indexPtr
decl_stmt|;
comment|/* Where to store index. */
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|string
argument_list|)
argument_list|)
operator|||
operator|(
operator|*
name|string
operator|==
literal|'-'
operator|)
condition|)
block|{
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|string
argument_list|,
name|indexPtr
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|*
name|indexPtr
operator|<
literal|0
condition|)
block|{
operator|*
name|indexPtr
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|string
argument_list|,
literal|"end"
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|indexPtr
operator|=
name|INT_MAX
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad index \""
argument_list|,
name|string
argument_list|,
literal|"\": must be integer or \"end\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_RegExpCompile --  *  *	Compile a regular expression into a form suitable for fast  *	matching.  This procedure retains a small cache of pre-compiled  *	regular expressions in the interpreter, in order to avoid  *	compilation costs as much as possible.  *  * Results:  *	The return value is a pointer to the compiled form of string,  *	suitable for passing to Tcl_RegExpExec.  This compiled form  *	is only valid up until the next call to this procedure, so  *	don't keep these around for a long time!  If an error occurred  *	while compiling the pattern, then NULL is returned and an error  *	message is left in interp->result.  *  * Side effects:  *	The cache of compiled regexp's in interp will be modified to  *	hold information for string, if such information isn't already  *	present in the cache.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_RegExp
name|Tcl_RegExpCompile
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* For use in error reporting. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String for which to produce 					 * compiled regular expression. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|length
decl_stmt|;
name|regexp
modifier|*
name|result
decl_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGEXPS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|length
operator|==
name|iPtr
operator|->
name|patLengths
index|[
name|i
index|]
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|string
argument_list|,
name|iPtr
operator|->
name|patterns
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 	     * Move the matched pattern to the first slot in the 	     * cache and shift the other patterns down one position. 	     */
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|cachedString
decl_stmt|;
name|cachedString
operator|=
name|iPtr
operator|->
name|patterns
index|[
name|i
index|]
expr_stmt|;
name|result
operator|=
name|iPtr
operator|->
name|regexps
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|iPtr
operator|->
name|patterns
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|iPtr
operator|->
name|patterns
index|[
name|j
index|]
expr_stmt|;
name|iPtr
operator|->
name|patLengths
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|iPtr
operator|->
name|patLengths
index|[
name|j
index|]
expr_stmt|;
name|iPtr
operator|->
name|regexps
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|iPtr
operator|->
name|regexps
index|[
name|j
index|]
expr_stmt|;
block|}
name|iPtr
operator|->
name|patterns
index|[
literal|0
index|]
operator|=
name|cachedString
expr_stmt|;
name|iPtr
operator|->
name|patLengths
index|[
literal|0
index|]
operator|=
name|length
expr_stmt|;
name|iPtr
operator|->
name|regexps
index|[
literal|0
index|]
operator|=
name|result
expr_stmt|;
block|}
return|return
operator|(
name|Tcl_RegExp
operator|)
name|iPtr
operator|->
name|regexps
index|[
literal|0
index|]
return|;
block|}
block|}
comment|/*      * No match in the cache.  Compile the string and add it to the      * cache.      */
name|TclRegError
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TclRegComp
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|TclGetRegError
argument_list|()
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't compile regular expression pattern: "
argument_list|,
name|TclGetRegError
argument_list|()
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|iPtr
operator|->
name|patterns
index|[
name|NUM_REGEXPS
operator|-
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|iPtr
operator|->
name|patterns
index|[
name|NUM_REGEXPS
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iPtr
operator|->
name|regexps
index|[
name|NUM_REGEXPS
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|NUM_REGEXPS
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|iPtr
operator|->
name|patterns
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|iPtr
operator|->
name|patterns
index|[
name|i
index|]
expr_stmt|;
name|iPtr
operator|->
name|patLengths
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|iPtr
operator|->
name|patLengths
index|[
name|i
index|]
expr_stmt|;
name|iPtr
operator|->
name|regexps
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|iPtr
operator|->
name|regexps
index|[
name|i
index|]
expr_stmt|;
block|}
name|iPtr
operator|->
name|patterns
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|length
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|iPtr
operator|->
name|patterns
index|[
literal|0
index|]
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|patLengths
index|[
literal|0
index|]
operator|=
name|length
expr_stmt|;
name|iPtr
operator|->
name|regexps
index|[
literal|0
index|]
operator|=
name|result
expr_stmt|;
return|return
operator|(
name|Tcl_RegExp
operator|)
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_RegExpExec --  *  *	Execute the regular expression matcher using a compiled form  *	of a regular expression and save information about any match  *	that is found.  *  * Results:  *	If an error occurs during the matching operation then -1  *	is returned and interp->result contains an error message.  *	Otherwise the return value is 1 if a matching range is  *	found and 0 if there is no matching range.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_RegExpExec
parameter_list|(
name|interp
parameter_list|,
name|re
parameter_list|,
name|string
parameter_list|,
name|start
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for error reporting. */
name|Tcl_RegExp
name|re
decl_stmt|;
comment|/* Compiled regular expression;  must have 				 * been returned by previous call to 				 * Tcl_RegExpCompile. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String against which to match re. */
name|char
modifier|*
name|start
decl_stmt|;
comment|/* If string is part of a larger string, 				 * this identifies beginning of larger 				 * string, so that "^" won't match. */
block|{
name|int
name|match
decl_stmt|;
name|regexp
modifier|*
name|regexpPtr
init|=
operator|(
name|regexp
operator|*
operator|)
name|re
decl_stmt|;
name|TclRegError
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|match
operator|=
name|TclRegExec
argument_list|(
name|regexpPtr
argument_list|,
name|string
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|TclGetRegError
argument_list|()
operator|!=
name|NULL
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"error while matching regular expression: "
argument_list|,
name|TclGetRegError
argument_list|()
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|match
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_RegExpRange --  *  *	Returns pointers describing the range of a regular expression match,  *	or one of the subranges within the match.  *  * Results:  *	The variables at *startPtr and *endPtr are modified to hold the  *	addresses of the endpoints of the range given by index.  If the  *	specified range doesn't exist then NULLs are returned.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_RegExpRange
parameter_list|(
name|re
parameter_list|,
name|index
parameter_list|,
name|startPtr
parameter_list|,
name|endPtr
parameter_list|)
name|Tcl_RegExp
name|re
decl_stmt|;
comment|/* Compiled regular expression that has 				 * been passed to Tcl_RegExpExec. */
name|int
name|index
decl_stmt|;
comment|/* 0 means give the range of the entire 				 * match,> 0 means give the range of 				 * a matching subrange.  Must be no greater 				 * than NSUBEXP. */
name|char
modifier|*
modifier|*
name|startPtr
decl_stmt|;
comment|/* Store address of first character in 				 * (sub-) range here. */
name|char
modifier|*
modifier|*
name|endPtr
decl_stmt|;
comment|/* Store address of character just after last 				 * in (sub-) range here. */
block|{
name|regexp
modifier|*
name|regexpPtr
init|=
operator|(
name|regexp
operator|*
operator|)
name|re
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|NSUBEXP
condition|)
block|{
operator|*
name|startPtr
operator|=
operator|*
name|endPtr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
operator|*
name|startPtr
operator|=
name|regexpPtr
operator|->
name|startp
index|[
name|index
index|]
expr_stmt|;
operator|*
name|endPtr
operator|=
name|regexpPtr
operator|->
name|endp
index|[
name|index
index|]
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_RegExpMatch --  *  *	See if a string matches a regular expression.  *  * Results:  *	If an error occurs during the matching operation then -1  *	is returned and interp->result contains an error message.  *	Otherwise the return value is 1 if "string" matches "pattern"  *	and 0 otherwise.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_RegExpMatch
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|pattern
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String. */
name|char
modifier|*
name|pattern
decl_stmt|;
comment|/* Regular expression to match against 				 * string. */
block|{
name|Tcl_RegExp
name|re
decl_stmt|;
name|re
operator|=
name|Tcl_RegExpCompile
argument_list|(
name|interp
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|==
name|NULL
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
name|Tcl_RegExpExec
argument_list|(
name|interp
argument_list|,
name|re
argument_list|,
name|string
argument_list|,
name|string
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DStringInit --  *  *	Initializes a dynamic string, discarding any previous contents  *	of the string (Tcl_DStringFree should have been called already  *	if the dynamic string was previously in use).  *  * Results:  *	None.  *  * Side effects:  *	The dynamic string is initialized to be empty.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DStringInit
parameter_list|(
name|dsPtr
parameter_list|)
specifier|register
name|Tcl_DString
modifier|*
name|dsPtr
decl_stmt|;
comment|/* Pointer to structure for 					 * dynamic string. */
block|{
name|dsPtr
operator|->
name|string
operator|=
name|dsPtr
operator|->
name|staticSpace
expr_stmt|;
name|dsPtr
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|dsPtr
operator|->
name|spaceAvl
operator|=
name|TCL_DSTRING_STATIC_SIZE
expr_stmt|;
name|dsPtr
operator|->
name|staticSpace
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DStringAppend --  *  *	Append more characters to the current value of a dynamic string.  *  * Results:  *	The return value is a pointer to the dynamic string's new value.  *  * Side effects:  *	Length bytes from string (or all of string if length is less  *	than zero) are added to the current value of the string.  Memory  *	gets reallocated if needed to accomodate the string's new size.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_DStringAppend
parameter_list|(
name|dsPtr
parameter_list|,
name|string
parameter_list|,
name|length
parameter_list|)
specifier|register
name|Tcl_DString
modifier|*
name|dsPtr
decl_stmt|;
comment|/* Structure describing dynamic 					 * string. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String to append.  If length is 					 * -1 then this must be 					 * null-terminated. */
name|int
name|length
decl_stmt|;
comment|/* Number of characters from string 					 * to append.  If< 0, then append all 					 * of string, up to null at end. */
block|{
name|int
name|newSize
decl_stmt|;
name|char
modifier|*
name|newString
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
modifier|*
name|end
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
name|length
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
name|newSize
operator|=
name|length
operator|+
name|dsPtr
operator|->
name|length
expr_stmt|;
comment|/*      * Allocate a larger buffer for the string if the current one isn't      * large enough.  Allocate extra space in the new buffer so that there      * will be room to grow before we have to allocate again.      */
if|if
condition|(
name|newSize
operator|>=
name|dsPtr
operator|->
name|spaceAvl
condition|)
block|{
name|dsPtr
operator|->
name|spaceAvl
operator|=
name|newSize
operator|*
literal|2
expr_stmt|;
name|newString
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|dsPtr
operator|->
name|spaceAvl
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|newString
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|dsPtr
operator|->
name|string
argument_list|,
operator|(
name|size_t
operator|)
name|dsPtr
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsPtr
operator|->
name|string
operator|!=
name|dsPtr
operator|->
name|staticSpace
condition|)
block|{
name|ckfree
argument_list|(
name|dsPtr
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
name|dsPtr
operator|->
name|string
operator|=
name|newString
expr_stmt|;
block|}
comment|/*      * Copy the new string into the buffer at the end of the old      * one.      */
for|for
control|(
name|dst
operator|=
name|dsPtr
operator|->
name|string
operator|+
name|dsPtr
operator|->
name|length
operator|,
name|end
operator|=
name|string
operator|+
name|length
init|;
name|string
operator|<
name|end
condition|;
name|string
operator|++
operator|,
name|dst
operator|++
control|)
block|{
operator|*
name|dst
operator|=
operator|*
name|string
expr_stmt|;
block|}
operator|*
name|dst
operator|=
literal|0
expr_stmt|;
name|dsPtr
operator|->
name|length
operator|+=
name|length
expr_stmt|;
return|return
name|dsPtr
operator|->
name|string
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DStringAppendElement --  *  *	Append a list element to the current value of a dynamic string.  *  * Results:  *	The return value is a pointer to the dynamic string's new value.  *  * Side effects:  *	String is reformatted as a list element and added to the current  *	value of the string.  Memory gets reallocated if needed to  *	accomodate the string's new size.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_DStringAppendElement
parameter_list|(
name|dsPtr
parameter_list|,
name|string
parameter_list|)
specifier|register
name|Tcl_DString
modifier|*
name|dsPtr
decl_stmt|;
comment|/* Structure describing dynamic 					 * string. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String to append.  Must be 					 * null-terminated. */
block|{
name|int
name|newSize
decl_stmt|,
name|flags
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|,
modifier|*
name|newString
decl_stmt|;
name|newSize
operator|=
name|Tcl_ScanElement
argument_list|(
name|string
argument_list|,
operator|&
name|flags
argument_list|)
operator|+
name|dsPtr
operator|->
name|length
operator|+
literal|1
expr_stmt|;
comment|/*      * Allocate a larger buffer for the string if the current one isn't      * large enough.  Allocate extra space in the new buffer so that there      * will be room to grow before we have to allocate again.      * SPECIAL NOTE: must use memcpy, not strcpy, to copy the string      * to a larger buffer, since there may be embedded NULLs in the      * string in some cases.      */
if|if
condition|(
name|newSize
operator|>=
name|dsPtr
operator|->
name|spaceAvl
condition|)
block|{
name|dsPtr
operator|->
name|spaceAvl
operator|=
name|newSize
operator|*
literal|2
expr_stmt|;
name|newString
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|dsPtr
operator|->
name|spaceAvl
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|newString
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|dsPtr
operator|->
name|string
argument_list|,
operator|(
name|size_t
operator|)
name|dsPtr
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsPtr
operator|->
name|string
operator|!=
name|dsPtr
operator|->
name|staticSpace
condition|)
block|{
name|ckfree
argument_list|(
name|dsPtr
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
name|dsPtr
operator|->
name|string
operator|=
name|newString
expr_stmt|;
block|}
comment|/*      * Convert the new string to a list element and copy it into the      * buffer at the end, with a space, if needed.      */
name|dst
operator|=
name|dsPtr
operator|->
name|string
operator|+
name|dsPtr
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|TclNeedSpace
argument_list|(
name|dsPtr
operator|->
name|string
argument_list|,
name|dst
argument_list|)
condition|)
block|{
operator|*
name|dst
operator|=
literal|' '
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|dsPtr
operator|->
name|length
operator|++
expr_stmt|;
block|}
name|dsPtr
operator|->
name|length
operator|+=
name|Tcl_ConvertElement
argument_list|(
name|string
argument_list|,
name|dst
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|dsPtr
operator|->
name|string
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DStringSetLength --  *  *	Change the length of a dynamic string.  This can cause the  *	string to either grow or shrink, depending on the value of  *	length.  *  * Results:  *	None.  *  * Side effects:  *	The length of dsPtr is changed to length and a null byte is  *	stored at that position in the string.  If length is larger  *	than the space allocated for dsPtr, then a panic occurs.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DStringSetLength
parameter_list|(
name|dsPtr
parameter_list|,
name|length
parameter_list|)
specifier|register
name|Tcl_DString
modifier|*
name|dsPtr
decl_stmt|;
comment|/* Structure describing dynamic 					 * string. */
name|int
name|length
decl_stmt|;
comment|/* New length for dynamic string. */
block|{
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
name|length
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|>=
name|dsPtr
operator|->
name|spaceAvl
condition|)
block|{
name|char
modifier|*
name|newString
decl_stmt|;
name|dsPtr
operator|->
name|spaceAvl
operator|=
name|length
operator|+
literal|1
expr_stmt|;
name|newString
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|dsPtr
operator|->
name|spaceAvl
argument_list|)
expr_stmt|;
comment|/* 	 * SPECIAL NOTE: must use memcpy, not strcpy, to copy the string 	 * to a larger buffer, since there may be embedded NULLs in the 	 * string in some cases. 	 */
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|newString
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|dsPtr
operator|->
name|string
argument_list|,
operator|(
name|size_t
operator|)
name|dsPtr
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsPtr
operator|->
name|string
operator|!=
name|dsPtr
operator|->
name|staticSpace
condition|)
block|{
name|ckfree
argument_list|(
name|dsPtr
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
name|dsPtr
operator|->
name|string
operator|=
name|newString
expr_stmt|;
block|}
name|dsPtr
operator|->
name|length
operator|=
name|length
expr_stmt|;
name|dsPtr
operator|->
name|string
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DStringFree --  *  *	Frees up any memory allocated for the dynamic string and  *	reinitializes the string to an empty state.  *  * Results:  *	None.  *  * Side effects:  *	The previous contents of the dynamic string are lost, and  *	the new value is an empty string.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DStringFree
parameter_list|(
name|dsPtr
parameter_list|)
specifier|register
name|Tcl_DString
modifier|*
name|dsPtr
decl_stmt|;
comment|/* Structure describing dynamic 					 * string. */
block|{
if|if
condition|(
name|dsPtr
operator|->
name|string
operator|!=
name|dsPtr
operator|->
name|staticSpace
condition|)
block|{
name|ckfree
argument_list|(
name|dsPtr
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
name|dsPtr
operator|->
name|string
operator|=
name|dsPtr
operator|->
name|staticSpace
expr_stmt|;
name|dsPtr
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|dsPtr
operator|->
name|spaceAvl
operator|=
name|TCL_DSTRING_STATIC_SIZE
expr_stmt|;
name|dsPtr
operator|->
name|staticSpace
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DStringResult --  *  *	This procedure moves the value of a dynamic string into an  *	interpreter as its result.  The string itself is reinitialized  *	to an empty string.  *  * Results:  *	None.  *  * Side effects:  *	The string is "moved" to interp's result, and any existing  *	result for interp is freed up.  DsPtr is reinitialized to  *	an empty string.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DStringResult
parameter_list|(
name|interp
parameter_list|,
name|dsPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter whose result is to be 					 * reset. */
name|Tcl_DString
modifier|*
name|dsPtr
decl_stmt|;
comment|/* Dynamic string that is to become 					 * the result of interp. */
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsPtr
operator|->
name|string
operator|!=
name|dsPtr
operator|->
name|staticSpace
condition|)
block|{
name|interp
operator|->
name|result
operator|=
name|dsPtr
operator|->
name|string
expr_stmt|;
name|interp
operator|->
name|freeProc
operator|=
name|TCL_DYNAMIC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dsPtr
operator|->
name|length
operator|<
name|TCL_RESULT_SIZE
condition|)
block|{
name|interp
operator|->
name|result
operator|=
operator|(
operator|(
name|Interp
operator|*
operator|)
name|interp
operator|)
operator|->
name|resultSpace
expr_stmt|;
name|strcpy
argument_list|(
name|interp
operator|->
name|result
argument_list|,
name|dsPtr
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|dsPtr
operator|->
name|string
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
name|dsPtr
operator|->
name|string
operator|=
name|dsPtr
operator|->
name|staticSpace
expr_stmt|;
name|dsPtr
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|dsPtr
operator|->
name|spaceAvl
operator|=
name|TCL_DSTRING_STATIC_SIZE
expr_stmt|;
name|dsPtr
operator|->
name|staticSpace
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DStringGetResult --  *  *	This procedure moves the result of an interpreter into a  *	dynamic string.  *  * Results:  *	None.  *  * Side effects:  *	The interpreter's result is cleared, and the previous contents  *	of dsPtr are freed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DStringGetResult
parameter_list|(
name|interp
parameter_list|,
name|dsPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter whose result is to be 					 * reset. */
name|Tcl_DString
modifier|*
name|dsPtr
decl_stmt|;
comment|/* Dynamic string that is to become 					 * the result of interp. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
if|if
condition|(
name|dsPtr
operator|->
name|string
operator|!=
name|dsPtr
operator|->
name|staticSpace
condition|)
block|{
name|ckfree
argument_list|(
name|dsPtr
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
name|dsPtr
operator|->
name|length
operator|=
name|strlen
argument_list|(
name|iPtr
operator|->
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|freeProc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|iPtr
operator|->
name|freeProc
operator|==
name|TCL_DYNAMIC
operator|)
operator|||
operator|(
name|iPtr
operator|->
name|freeProc
operator|==
operator|(
name|Tcl_FreeProc
operator|*
operator|)
name|free
operator|)
condition|)
block|{
name|dsPtr
operator|->
name|string
operator|=
name|iPtr
operator|->
name|result
expr_stmt|;
name|dsPtr
operator|->
name|spaceAvl
operator|=
name|dsPtr
operator|->
name|length
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dsPtr
operator|->
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|dsPtr
operator|->
name|length
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dsPtr
operator|->
name|string
argument_list|,
name|iPtr
operator|->
name|result
argument_list|)
expr_stmt|;
call|(
modifier|*
name|iPtr
operator|->
name|freeProc
call|)
argument_list|(
name|iPtr
operator|->
name|result
argument_list|)
expr_stmt|;
block|}
name|dsPtr
operator|->
name|spaceAvl
operator|=
name|dsPtr
operator|->
name|length
operator|+
literal|1
expr_stmt|;
name|iPtr
operator|->
name|freeProc
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dsPtr
operator|->
name|length
operator|<
name|TCL_DSTRING_STATIC_SIZE
condition|)
block|{
name|dsPtr
operator|->
name|string
operator|=
name|dsPtr
operator|->
name|staticSpace
expr_stmt|;
name|dsPtr
operator|->
name|spaceAvl
operator|=
name|TCL_DSTRING_STATIC_SIZE
expr_stmt|;
block|}
else|else
block|{
name|dsPtr
operator|->
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|dsPtr
operator|->
name|length
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|dsPtr
operator|->
name|spaceAvl
operator|=
name|dsPtr
operator|->
name|length
operator|+
literal|1
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|dsPtr
operator|->
name|string
argument_list|,
name|iPtr
operator|->
name|result
argument_list|)
expr_stmt|;
block|}
name|iPtr
operator|->
name|result
operator|=
name|iPtr
operator|->
name|resultSpace
expr_stmt|;
name|iPtr
operator|->
name|resultSpace
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DStringStartSublist --  *  *	This procedure adds the necessary information to a dynamic  *	string (e.g. " {" to start a sublist.  Future element  *	appends will be in the sublist rather than the main list.  *  * Results:  *	None.  *  * Side effects:  *	Characters get added to the dynamic string.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DStringStartSublist
parameter_list|(
name|dsPtr
parameter_list|)
name|Tcl_DString
modifier|*
name|dsPtr
decl_stmt|;
comment|/* Dynamic string. */
block|{
if|if
condition|(
name|TclNeedSpace
argument_list|(
name|dsPtr
operator|->
name|string
argument_list|,
name|dsPtr
operator|->
name|string
operator|+
name|dsPtr
operator|->
name|length
argument_list|)
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|dsPtr
argument_list|,
literal|" {"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_DStringAppend
argument_list|(
name|dsPtr
argument_list|,
literal|"{"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DStringEndSublist --  *  *	This procedure adds the necessary characters to a dynamic  *	string to end a sublist (e.g. "}").  Future element appends  *	will be in the enclosing (sub)list rather than the current  *	sublist.  *  * Results:  *	None.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DStringEndSublist
parameter_list|(
name|dsPtr
parameter_list|)
name|Tcl_DString
modifier|*
name|dsPtr
decl_stmt|;
comment|/* Dynamic string. */
block|{
name|Tcl_DStringAppend
argument_list|(
name|dsPtr
argument_list|,
literal|"}"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_PrintDouble --  *  *	Given a floating-point value, this procedure converts it to  *	an ASCII string using.  *  * Results:  *	The ASCII equivalent of "value" is written at "dst".  It is  *	written using the current precision, and it is guaranteed to  *	contain a decimal point or exponent, so that it looks like  *	a floating-point value and not an integer.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_PrintDouble
parameter_list|(
name|interp
parameter_list|,
name|value
parameter_list|,
name|dst
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter whose tcl_precision 					 * variable controls printing. */
name|double
name|value
decl_stmt|;
comment|/* Value to print as string. */
name|char
modifier|*
name|dst
decl_stmt|;
comment|/* Where to store converted value; 					 * must have at least TCL_DOUBLE_SPACE 					 * characters. */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|sprintf
argument_list|(
name|dst
argument_list|,
operator|(
operator|(
name|Interp
operator|*
operator|)
name|interp
operator|)
operator|->
name|pdFormat
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/*      * If the ASCII result looks like an integer, add ".0" so that it      * doesn't look like an integer anymore.  This prevents floating-point      * values from being converted to integers unintentionally.      */
for|for
control|(
name|p
operator|=
name|dst
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'.'
operator|)
operator|||
operator|(
name|isalpha
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|)
condition|)
block|{
return|return;
block|}
block|}
name|p
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|'0'
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclPrecTraceProc --  *  *	This procedure is invoked whenever the variable "tcl_precision"  *	is written.  *  * Results:  *	Returns NULL if all went well, or an error message if the  *	new value for the variable doesn't make sense.  *  * Side effects:  *	If the new value doesn't make sense then this procedure  *	undoes the effect of the variable modification.  Otherwise  *	it modifies the format string that's used by Tcl_PrintDouble.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|char
modifier|*
name|TclPrecTraceProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|name1
parameter_list|,
name|name2
parameter_list|,
name|flags
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter containing variable. */
name|char
modifier|*
name|name1
decl_stmt|;
comment|/* Name of variable. */
name|char
modifier|*
name|name2
decl_stmt|;
comment|/* Second part of variable name. */
name|int
name|flags
decl_stmt|;
comment|/* Information about what happened. */
block|{
specifier|register
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|prec
decl_stmt|;
comment|/*      * If the variable is unset, then recreate the trace and restore      * the default value of the format string.      */
if|if
condition|(
name|flags
operator|&
name|TCL_TRACE_UNSETS
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|TCL_TRACE_DESTROYED
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|TCL_INTERP_DESTROYED
operator|)
condition|)
block|{
name|Tcl_TraceVar2
argument_list|(
name|interp
argument_list|,
name|name1
argument_list|,
name|name2
argument_list|,
name|TCL_GLOBAL_ONLY
operator||
name|TCL_TRACE_WRITES
operator||
name|TCL_TRACE_UNSETS
argument_list|,
name|TclPrecTraceProc
argument_list|,
name|clientData
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|iPtr
operator|->
name|pdFormat
argument_list|,
name|DEFAULT_PD_FORMAT
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|pdPrec
operator|=
name|DEFAULT_PD_PREC
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
block|}
name|value
operator|=
name|Tcl_GetVar2
argument_list|(
name|interp
argument_list|,
name|name1
argument_list|,
name|name2
argument_list|,
name|flags
operator|&
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
name|value
operator|=
literal|""
expr_stmt|;
block|}
name|prec
operator|=
name|strtoul
argument_list|(
name|value
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prec
operator|<=
literal|0
operator|)
operator|||
operator|(
name|prec
operator|>
name|TCL_MAX_PREC
operator|)
operator|||
operator|(
name|prec
operator|>
literal|100
operator|)
operator|||
operator|(
name|end
operator|==
name|value
operator|)
operator|||
operator|(
operator|*
name|end
operator|!=
literal|0
operator|)
condition|)
block|{
name|char
name|oldValue
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|oldValue
argument_list|,
literal|"%d"
argument_list|,
name|iPtr
operator|->
name|pdPrec
argument_list|)
expr_stmt|;
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
name|name1
argument_list|,
name|name2
argument_list|,
name|oldValue
argument_list|,
name|flags
operator|&
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
return|return
literal|"improper value for precision"
return|;
block|}
name|sprintf
argument_list|(
name|iPtr
operator|->
name|pdFormat
argument_list|,
literal|"%%.%dg"
argument_list|,
name|prec
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|pdPrec
operator|=
name|prec
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclNeedSpace --  *  *	This procedure checks to see whether it is appropriate to  *	add a space before appending a new list element to an  *	existing string.  *  * Results:  *	The return value is 1 if a space is appropriate, 0 otherwise.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclNeedSpace
parameter_list|(
name|start
parameter_list|,
name|end
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
comment|/* First character in string. */
name|char
modifier|*
name|end
decl_stmt|;
comment|/* End of string (place where space will 				 * be added, if appropriate). */
block|{
comment|/*      * A space is needed unless either      * (a) we're at the start of the string, or      * (b) the trailing characters of the string consist of one or more      *     open curly braces preceded by a space or extending back to      *     the beginning of the string.      * (c) the trailing characters of the string consist of a space      *	   preceded by a character other than backslash.      */
if|if
condition|(
name|end
operator|==
name|start
condition|)
block|{
return|return
literal|0
return|;
block|}
name|end
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|!=
literal|'{'
condition|)
block|{
if|if
condition|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|end
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|end
operator|==
name|start
operator|)
operator|||
operator|(
name|end
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\\'
operator|)
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
do|do
block|{
if|if
condition|(
name|end
operator|==
name|start
condition|)
block|{
return|return
literal|0
return|;
block|}
name|end
operator|--
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|end
operator|==
literal|'{'
condition|)
do|;
if|if
condition|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|end
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

end_unit

