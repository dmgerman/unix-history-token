begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclUtil.c --  *  *	This file contains utility procedures that are used by many Tcl  *	commands.  *  * Copyright (c) 1987-1993 The Regents of the University of California.  * Copyright (c) 1994-1997 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclUtil.c 1.161 97/08/12 17:07:18  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * The following values are used in the flags returned by Tcl_ScanElement  * and used by Tcl_ConvertElement.  The value TCL_DONT_USE_BRACES is also  * defined in tcl.h;  make sure its value doesn't overlap with any of the  * values below.  *  * TCL_DONT_USE_BRACES -	1 means the string mustn't be enclosed in  *				braces (e.g. it contains unmatched braces,  *				or ends in a backslash character, or user  *				just doesn't want braces);  handle all  *				special characters by adding backslashes.  * USE_BRACES -			1 means the string contains a special  *				character that can be handled simply by  *				enclosing the entire argument in braces.  * BRACES_UNMATCHED -		1 means that braces aren't properly matched  *				in the argument.  */
end_comment

begin_define
define|#
directive|define
name|USE_BRACES
value|2
end_define

begin_define
define|#
directive|define
name|BRACES_UNMATCHED
value|4
end_define

begin_comment
comment|/*  * The following values determine the precision used when converting  * floating-point values to strings.  This information is linked to all  * of the tcl_precision variables in all interpreters via the procedure  * TclPrecTraceProc.  *  * NOTE: these variables are not thread-safe.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|precisionString
index|[
literal|10
index|]
init|=
literal|"12"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The string value of all the tcl_precision 				 * variables. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|precisionFormat
index|[
literal|10
index|]
init|=
literal|"%.12g"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The format string actually used in calls 				 * to sprintf. */
end_comment

begin_comment
comment|/*  * Function prototypes for local procedures in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|SetupAppendBuffer
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Interp
operator|*
name|iPtr
operator|,
name|int
name|newSpace
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclFindElement --  *  *	Given a pointer into a Tcl list, locate the first (or next)  *	element in the list.  *  * Results:  *	The return value is normally TCL_OK, which means that the  *	element was successfully located.  If TCL_ERROR is returned  *	it means that list didn't have proper list structure;  *	interp->result contains a more detailed error message.  *  *	If TCL_OK is returned, then *elementPtr will be set to point to the  *	first element of list, and *nextPtr will be set to point to the  *	character just after any white space following the last character  *	that's part of the element. If this is the last argument in the  *	list, then *nextPtr will point just after the last character in the  *	list (i.e., at the character at list+listLength). If sizePtr is  *	non-NULL, *sizePtr is filled in with the number of characters in the  *	element.  If the element is in braces, then *elementPtr will point  *	to the character after the opening brace and *sizePtr will not  *	include either of the braces. If there isn't an element in the list,  *	*sizePtr will be zero, and both *elementPtr and *termPtr will point  *	just after the last character in the list. Note: this procedure does  *	NOT collapse backslash sequences.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclFindElement
parameter_list|(
name|interp
parameter_list|,
name|list
parameter_list|,
name|listLength
parameter_list|,
name|elementPtr
parameter_list|,
name|nextPtr
parameter_list|,
name|sizePtr
parameter_list|,
name|bracePtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for error reporting.  				 * If NULL, then no error message is left 				 * after errors. */
name|char
modifier|*
name|list
decl_stmt|;
comment|/* Points to the first byte of a string 				 * containing a Tcl list with zero or more 				 * elements (possibly in braces). */
name|int
name|listLength
decl_stmt|;
comment|/* Number of bytes in the list's string. */
name|char
modifier|*
modifier|*
name|elementPtr
decl_stmt|;
comment|/* Where to put address of first significant 				 * character in first element of list. */
name|char
modifier|*
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Fill in with location of character just 				 * after all white space following end of 				 * argument (next arg or end of list). */
name|int
modifier|*
name|sizePtr
decl_stmt|;
comment|/* If non-zero, fill in with size of 				 * element. */
name|int
modifier|*
name|bracePtr
decl_stmt|;
comment|/* If non-zero, fill in with non-zero/zero 				 * to indicate that arg was/wasn't 				 * in braces. */
block|{
name|char
modifier|*
name|p
init|=
name|list
decl_stmt|;
name|char
modifier|*
name|elemStart
decl_stmt|;
comment|/* Points to first byte of first element. */
name|char
modifier|*
name|limit
decl_stmt|;
comment|/* Points just after list's last byte. */
name|int
name|openBraces
init|=
literal|0
decl_stmt|;
comment|/* Brace nesting level during parse. */
name|int
name|inQuotes
init|=
literal|0
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
comment|/* Init. avoids compiler warning. */
name|int
name|numChars
decl_stmt|;
name|char
modifier|*
name|p2
decl_stmt|;
comment|/*      * Skim off leading white space and check for an opening brace or      * quote. We treat embedded NULLs in the list as bytes belonging to      * a list element. Note: use of "isascii" below and elsewhere in this      * procedure is a temporary hack (7/27/90) because Mx uses characters      * with the high-order bit set for some things. This should probably      * be changed back eventually, or all of Tcl should call isascii.      */
name|limit
operator|=
operator|(
name|list
operator|+
name|listLength
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|<
name|limit
operator|)
operator|&&
operator|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|limit
condition|)
block|{
comment|/* no element found */
name|elemStart
operator|=
name|limit
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'{'
condition|)
block|{
name|openBraces
operator|=
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
condition|)
block|{
name|inQuotes
operator|=
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|elemStart
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|bracePtr
operator|!=
literal|0
condition|)
block|{
operator|*
name|bracePtr
operator|=
name|openBraces
expr_stmt|;
block|}
comment|/*      * Find element's end (a space, close brace, or the end of the string).      */
while|while
condition|(
name|p
operator|<
name|limit
condition|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
comment|/* 	     * Open brace: don't treat specially unless the element is in 	     * braces. In this case, keep a nesting count. 	     */
case|case
literal|'{'
case|:
if|if
condition|(
name|openBraces
operator|!=
literal|0
condition|)
block|{
name|openBraces
operator|++
expr_stmt|;
block|}
break|break;
comment|/* 	     * Close brace: if element is in braces, keep nesting count and 	     * quit when the last close brace is seen. 	     */
case|case
literal|'}'
case|:
if|if
condition|(
name|openBraces
operator|>
literal|1
condition|)
block|{
name|openBraces
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|openBraces
operator|==
literal|1
condition|)
block|{
name|size
operator|=
operator|(
name|p
operator|-
name|elemStart
operator|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|>=
name|limit
operator|)
operator|||
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
goto|goto
name|done
goto|;
block|}
comment|/* 		     * Garbage after the closing brace; return an error. 		     */
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|p2
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|(
name|p2
operator|<
name|limit
operator|)
operator|&&
operator|(
operator|!
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p2
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|p2
operator|<
name|p
operator|+
literal|20
operator|)
condition|)
block|{
name|p2
operator|++
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"list element in braces followed by \"%.*s\" instead of space"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p2
operator|-
name|p
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
break|break;
comment|/* 	     * Backslash:  skip over everything up to the end of the 	     * backslash sequence. 	     */
case|case
literal|'\\'
case|:
block|{
operator|(
name|void
operator|)
name|Tcl_Backslash
argument_list|(
name|p
argument_list|,
operator|&
name|numChars
argument_list|)
expr_stmt|;
name|p
operator|+=
operator|(
name|numChars
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
block|}
comment|/* 	     * Space: ignore if element is in braces or quotes; otherwise 	     * terminate element. 	     */
case|case
literal|' '
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\v'
case|:
if|if
condition|(
operator|(
name|openBraces
operator|==
literal|0
operator|)
operator|&&
operator|!
name|inQuotes
condition|)
block|{
name|size
operator|=
operator|(
name|p
operator|-
name|elemStart
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
comment|/* 	     * Double-quote: if element is in quotes then terminate it. 	     */
case|case
literal|'"'
case|:
if|if
condition|(
name|inQuotes
condition|)
block|{
name|size
operator|=
operator|(
name|p
operator|-
name|elemStart
operator|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|>=
name|limit
operator|)
operator|||
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
goto|goto
name|done
goto|;
block|}
comment|/* 		     * Garbage after the closing quote; return an error. 		     */
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|p2
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|(
name|p2
operator|<
name|limit
operator|)
operator|&&
operator|(
operator|!
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p2
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|p2
operator|<
name|p
operator|+
literal|20
operator|)
condition|)
block|{
name|p2
operator|++
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"list element in quotes followed by \"%.*s\" %s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p2
operator|-
name|p
argument_list|)
argument_list|,
name|p
argument_list|,
literal|"instead of space"
argument_list|)
expr_stmt|;
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
break|break;
block|}
name|p
operator|++
expr_stmt|;
block|}
comment|/*      * End of list: terminate element.      */
if|if
condition|(
name|p
operator|==
name|limit
condition|)
block|{
if|if
condition|(
name|openBraces
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"unmatched open brace in list"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|inQuotes
condition|)
block|{
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"unmatched open quote in list"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
name|size
operator|=
operator|(
name|p
operator|-
name|elemStart
operator|)
expr_stmt|;
block|}
name|done
label|:
while|while
condition|(
operator|(
name|p
operator|<
name|limit
operator|)
operator|&&
operator|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|elementPtr
operator|=
name|elemStart
expr_stmt|;
operator|*
name|nextPtr
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|sizePtr
operator|!=
literal|0
condition|)
block|{
operator|*
name|sizePtr
operator|=
name|size
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCopyAndCollapse --  *  *	Copy a string and eliminate any backslashes that aren't in braces.  *  * Results:  *	There is no return value. Count characters get copied from src to  *	dst. Along the way, if backslash sequences are found outside braces,  *	the backslashes are eliminated in the copy. After scanning count  *	chars from source, a null character is placed at the end of dst.  *	Returns the number of characters that got copied.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclCopyAndCollapse
parameter_list|(
name|count
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|int
name|count
decl_stmt|;
comment|/* Number of characters to copy from src. */
name|char
modifier|*
name|src
decl_stmt|;
comment|/* Copy from here... */
name|char
modifier|*
name|dst
decl_stmt|;
comment|/* ... to here. */
block|{
name|char
name|c
decl_stmt|;
name|int
name|numRead
decl_stmt|;
name|int
name|newCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|c
operator|=
operator|*
name|src
init|;
name|count
operator|>
literal|0
condition|;
name|src
operator|++
operator|,
name|c
operator|=
operator|*
name|src
operator|,
name|count
operator|--
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|dst
operator|=
name|Tcl_Backslash
argument_list|(
name|src
argument_list|,
operator|&
name|numRead
argument_list|)
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|src
operator|+=
name|numRead
operator|-
literal|1
expr_stmt|;
name|count
operator|-=
name|numRead
operator|-
literal|1
expr_stmt|;
name|newCount
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dst
operator|=
name|c
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|newCount
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|dst
operator|=
literal|0
expr_stmt|;
return|return
name|newCount
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SplitList --  *  *	Splits a list up into its constituent fields.  *  * Results  *	The return value is normally TCL_OK, which means that  *	the list was successfully split up.  If TCL_ERROR is  *	returned, it means that "list" didn't have proper list  *	structure;  interp->result will contain a more detailed  *	error message.  *  *	*argvPtr will be filled in with the address of an array  *	whose elements point to the elements of list, in order.  *	*argcPtr will get filled in with the number of valid elements  *	in the array.  A single block of memory is dynamically allocated  *	to hold both the argv array and a copy of the list (with  *	backslashes and braces removed in the standard way).  *	The caller must eventually free this memory by calling free()  *	on *argvPtr.  Note:  *argvPtr and *argcPtr are only modified  *	if the procedure returns normally.  *  * Side effects:  *	Memory is allocated.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_SplitList
parameter_list|(
name|interp
parameter_list|,
name|list
parameter_list|,
name|argcPtr
parameter_list|,
name|argvPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for error reporting.  				 * If NULL, no error message is left. */
name|char
modifier|*
name|list
decl_stmt|;
comment|/* Pointer to string with list structure. */
name|int
modifier|*
name|argcPtr
decl_stmt|;
comment|/* Pointer to location to fill in with 				 * the number of elements in the list. */
name|char
modifier|*
modifier|*
modifier|*
name|argvPtr
decl_stmt|;
comment|/* Pointer to place to store pointer to 				 * array of pointers to list elements. */
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|length
decl_stmt|,
name|size
decl_stmt|,
name|i
decl_stmt|,
name|result
decl_stmt|,
name|elSize
decl_stmt|,
name|brace
decl_stmt|;
name|char
modifier|*
name|element
decl_stmt|;
comment|/*      * Figure out how much space to allocate.  There must be enough      * space for both the array of pointers and also for a copy of      * the list.  To estimate the number of pointers needed, count      * the number of space characters in the list.      */
for|for
control|(
name|size
operator|=
literal|1
operator|,
name|p
operator|=
name|list
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|size
operator|++
expr_stmt|;
block|}
block|}
name|size
operator|++
expr_stmt|;
comment|/* Leave space for final NULL pointer. */
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
operator|+
operator|(
name|p
operator|-
name|list
operator|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|list
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|argv
operator|)
operator|+
name|size
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
init|;
operator|*
name|list
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|prevList
init|=
name|list
decl_stmt|;
name|result
operator|=
name|TclFindElement
argument_list|(
name|interp
argument_list|,
name|list
argument_list|,
name|length
argument_list|,
operator|&
name|element
argument_list|,
operator|&
name|list
argument_list|,
operator|&
name|elSize
argument_list|,
operator|&
name|brace
argument_list|)
expr_stmt|;
name|length
operator|-=
operator|(
name|list
operator|-
name|prevList
operator|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
operator|*
name|element
operator|==
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|size
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
literal|"internal error in Tcl_SplitList"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
name|argv
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|brace
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|p
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|element
argument_list|,
operator|(
name|size_t
operator|)
name|elSize
argument_list|)
expr_stmt|;
name|p
operator|+=
name|elSize
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
name|TclCopyAndCollapse
argument_list|(
name|elSize
argument_list|,
name|element
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|elSize
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|argv
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|argvPtr
operator|=
name|argv
expr_stmt|;
operator|*
name|argcPtr
operator|=
name|i
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ScanElement --  *  *	This procedure is a companion procedure to Tcl_ConvertElement.  *	It scans a string to see what needs to be done to it (e.g. add  *	backslashes or enclosing braces) to make the string into a  *	valid Tcl list element.  *  * Results:  *	The return value is an overestimate of the number of characters  *	that will be needed by Tcl_ConvertElement to produce a valid  *	list element from string.  The word at *flagPtr is filled in  *	with a value needed by Tcl_ConvertElement when doing the actual  *	conversion.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_ScanElement
parameter_list|(
name|string
parameter_list|,
name|flagPtr
parameter_list|)
name|CONST
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String to convert to Tcl list element. */
name|int
modifier|*
name|flagPtr
decl_stmt|;
comment|/* Where to store information to guide 				 * Tcl_ConvertCountedElement. */
block|{
return|return
name|Tcl_ScanCountedElement
argument_list|(
name|string
argument_list|,
operator|-
literal|1
argument_list|,
name|flagPtr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ScanCountedElement --  *  *	This procedure is a companion procedure to  *	Tcl_ConvertCountedElement.  It scans a string to see what  *	needs to be done to it (e.g. add backslashes or enclosing  *	braces) to make the string into a valid Tcl list element.  *	If length is -1, then the string is scanned up to the first  *	null byte.  *  * Results:  *	The return value is an overestimate of the number of characters  *	that will be needed by Tcl_ConvertCountedElement to produce a  *	valid list element from string.  The word at *flagPtr is  *	filled in with a value needed by Tcl_ConvertCountedElement  *	when doing the actual conversion.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_ScanCountedElement
parameter_list|(
name|string
parameter_list|,
name|length
parameter_list|,
name|flagPtr
parameter_list|)
name|CONST
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String to convert to Tcl list element. */
name|int
name|length
decl_stmt|;
comment|/* Number of bytes in string, or -1. */
name|int
modifier|*
name|flagPtr
decl_stmt|;
comment|/* Where to store information to guide 				 * Tcl_ConvertElement. */
block|{
name|int
name|flags
decl_stmt|,
name|nestingLevel
decl_stmt|;
name|CONST
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|lastChar
decl_stmt|;
comment|/*      * This procedure and Tcl_ConvertElement together do two things:      *      * 1. They produce a proper list, one that will yield back the      * argument strings when evaluated or when disassembled with      * Tcl_SplitList.  This is the most important thing.      *       * 2. They try to produce legible output, which means minimizing the      * use of backslashes (using braces instead).  However, there are      * some situations where backslashes must be used (e.g. an element      * like "{abc": the leading brace will have to be backslashed.      * For each element, one of three things must be done:      *      * (a) Use the element as-is (it doesn't contain any special      * characters).  This is the most desirable option.      *      * (b) Enclose the element in braces, but leave the contents alone.      * This happens if the element contains embedded space, or if it      * contains characters with special interpretation ($, [, ;, or \),      * or if it starts with a brace or double-quote, or if there are      * no characters in the element.      *      * (c) Don't enclose the element in braces, but add backslashes to      * prevent special interpretation of special characters.  This is a      * last resort used when the argument would normally fall under case      * (b) but contains unmatched braces.  It also occurs if the last      * character of the argument is a backslash or if the element contains      * a backslash followed by newline.      *      * The procedure figures out how many bytes will be needed to store      * the result (actually, it overestimates). It also collects information      * about the element in the form of a flags word.      *      * Note: list elements produced by this procedure and      * Tcl_ConvertCountedElement must have the property that they can be      * enclosing in curly braces to make sub-lists.  This means, for      * example, that we must not leave unmatched curly braces in the      * resulting list element.  This property is necessary in order for      * procedures like Tcl_DStringStartSublist to work.      */
name|nestingLevel
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
condition|)
block|{
name|string
operator|=
literal|""
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|==
operator|-
literal|1
condition|)
block|{
name|length
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
name|lastChar
operator|=
name|string
operator|+
name|length
expr_stmt|;
name|p
operator|=
name|string
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|==
name|lastChar
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'{'
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'"'
operator|)
condition|)
block|{
name|flags
operator||=
name|USE_BRACES
expr_stmt|;
block|}
for|for
control|(
init|;
name|p
operator|!=
name|lastChar
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'{'
case|:
name|nestingLevel
operator|++
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|nestingLevel
operator|--
expr_stmt|;
if|if
condition|(
name|nestingLevel
operator|<
literal|0
condition|)
block|{
name|flags
operator||=
name|TCL_DONT_USE_BRACES
operator||
name|BRACES_UNMATCHED
expr_stmt|;
block|}
break|break;
case|case
literal|'['
case|:
case|case
literal|'$'
case|:
case|case
literal|';'
case|:
case|case
literal|' '
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\v'
case|:
name|flags
operator||=
name|USE_BRACES
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|(
name|p
operator|+
literal|1
operator|==
name|lastChar
operator|)
operator|||
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|flags
operator|=
name|TCL_DONT_USE_BRACES
operator||
name|BRACES_UNMATCHED
expr_stmt|;
block|}
else|else
block|{
name|int
name|size
decl_stmt|;
operator|(
name|void
operator|)
name|Tcl_Backslash
argument_list|(
name|p
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|p
operator|+=
name|size
operator|-
literal|1
expr_stmt|;
name|flags
operator||=
name|USE_BRACES
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|nestingLevel
operator|!=
literal|0
condition|)
block|{
name|flags
operator|=
name|TCL_DONT_USE_BRACES
operator||
name|BRACES_UNMATCHED
expr_stmt|;
block|}
operator|*
name|flagPtr
operator|=
name|flags
expr_stmt|;
comment|/*      * Allow enough space to backslash every character plus leave      * two spaces for braces.      */
return|return
literal|2
operator|*
operator|(
name|p
operator|-
name|string
operator|)
operator|+
literal|2
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ConvertElement --  *  *	This is a companion procedure to Tcl_ScanElement.  Given  *	the information produced by Tcl_ScanElement, this procedure  *	converts a string to a list element equal to that string.  *  * Results:  *	Information is copied to *dst in the form of a list element  *	identical to src (i.e. if Tcl_SplitList is applied to dst it  *	will produce a string identical to src).  The return value is  *	a count of the number of characters copied (not including the  *	terminating NULL character).  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_ConvertElement
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|flags
parameter_list|)
name|CONST
name|char
modifier|*
name|src
decl_stmt|;
comment|/* Source information for list element. */
name|char
modifier|*
name|dst
decl_stmt|;
comment|/* Place to put list-ified element. */
name|int
name|flags
decl_stmt|;
comment|/* Flags produced by Tcl_ScanElement. */
block|{
return|return
name|Tcl_ConvertCountedElement
argument_list|(
name|src
argument_list|,
operator|-
literal|1
argument_list|,
name|dst
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ConvertCountedElement --  *  *	This is a companion procedure to Tcl_ScanCountedElement.  Given  *	the information produced by Tcl_ScanCountedElement, this  *	procedure converts a string to a list element equal to that  *	string.  *  * Results:  *	Information is copied to *dst in the form of a list element  *	identical to src (i.e. if Tcl_SplitList is applied to dst it  *	will produce a string identical to src).  The return value is  *	a count of the number of characters copied (not including the  *	terminating NULL character).  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_ConvertCountedElement
parameter_list|(
name|src
parameter_list|,
name|length
parameter_list|,
name|dst
parameter_list|,
name|flags
parameter_list|)
name|CONST
name|char
modifier|*
name|src
decl_stmt|;
comment|/* Source information for list element. */
name|int
name|length
decl_stmt|;
comment|/* Number of bytes in src, or -1. */
name|char
modifier|*
name|dst
decl_stmt|;
comment|/* Place to put list-ified element. */
name|int
name|flags
decl_stmt|;
comment|/* Flags produced by Tcl_ScanElement. */
block|{
name|char
modifier|*
name|p
init|=
name|dst
decl_stmt|;
name|CONST
name|char
modifier|*
name|lastChar
decl_stmt|;
comment|/*      * See the comment block at the beginning of the Tcl_ScanElement      * code for details of how this works.      */
if|if
condition|(
name|src
operator|&&
name|length
operator|==
operator|-
literal|1
condition|)
block|{
name|length
operator|=
name|strlen
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|src
operator|==
name|NULL
operator|)
operator|||
operator|(
name|length
operator|==
literal|0
operator|)
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
literal|'{'
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|'}'
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|2
return|;
block|}
name|lastChar
operator|=
name|src
operator|+
name|length
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|USE_BRACES
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|TCL_DONT_USE_BRACES
operator|)
condition|)
block|{
operator|*
name|p
operator|=
literal|'{'
expr_stmt|;
name|p
operator|++
expr_stmt|;
for|for
control|(
init|;
name|src
operator|!=
name|lastChar
condition|;
name|src
operator|++
operator|,
name|p
operator|++
control|)
block|{
operator|*
name|p
operator|=
operator|*
name|src
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'}'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|src
operator|==
literal|'{'
condition|)
block|{
comment|/* 	     * Can't have a leading brace unless the whole element is 	     * enclosed in braces.  Add a backslash before the brace. 	     * Furthermore, this may destroy the balance between open 	     * and close braces, so set BRACES_UNMATCHED. 	     */
name|p
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|'{'
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|flags
operator||=
name|BRACES_UNMATCHED
expr_stmt|;
block|}
for|for
control|(
init|;
name|src
operator|!=
name|lastChar
condition|;
name|src
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|src
condition|)
block|{
case|case
literal|']'
case|:
case|case
literal|'['
case|:
case|case
literal|'$'
case|:
case|case
literal|';'
case|:
case|case
literal|' '
case|:
case|case
literal|'\\'
case|:
case|case
literal|'"'
case|:
operator|*
name|p
operator|=
literal|'\\'
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
case|case
literal|'}'
case|:
comment|/* 		     * It may not seem necessary to backslash braces, but 		     * it is.  The reason for this is that the resulting 		     * list element may actually be an element of a sub-list 		     * enclosed in braces (e.g. if Tcl_DStringStartSublist 		     * has been invoked), so there may be a brace mismatch 		     * if the braces aren't backslashed. 		     */
if|if
condition|(
name|flags
operator|&
name|BRACES_UNMATCHED
condition|)
block|{
operator|*
name|p
operator|=
literal|'\\'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'\f'
case|:
operator|*
name|p
operator|=
literal|'\\'
expr_stmt|;
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'f'
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'\n'
case|:
operator|*
name|p
operator|=
literal|'\\'
expr_stmt|;
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'n'
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'\r'
case|:
operator|*
name|p
operator|=
literal|'\\'
expr_stmt|;
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'r'
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'\t'
case|:
operator|*
name|p
operator|=
literal|'\\'
expr_stmt|;
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'t'
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'\v'
case|:
operator|*
name|p
operator|=
literal|'\\'
expr_stmt|;
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'v'
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
operator|*
name|p
operator|=
operator|*
name|src
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|p
operator|-
name|dst
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_Merge --  *  *	Given a collection of strings, merge them together into a  *	single string that has proper Tcl list structured (i.e.  *	Tcl_SplitList may be used to retrieve strings equal to the  *	original elements, and Tcl_Eval will parse the string back  *	into its original elements).  *  * Results:  *	The return value is the address of a dynamically-allocated  *	string containing the merged list.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_Merge
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
comment|/* How many strings to merge. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Array of string values. */
block|{
define|#
directive|define
name|LOCAL_SIZE
value|20
name|int
name|localFlags
index|[
name|LOCAL_SIZE
index|]
decl_stmt|,
modifier|*
name|flagPtr
decl_stmt|;
name|int
name|numChars
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*      * Pass 1: estimate space, gather flags.      */
if|if
condition|(
name|argc
operator|<=
name|LOCAL_SIZE
condition|)
block|{
name|flagPtr
operator|=
name|localFlags
expr_stmt|;
block|}
else|else
block|{
name|flagPtr
operator|=
operator|(
name|int
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|numChars
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|numChars
operator|+=
name|Tcl_ScanElement
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
operator|&
name|flagPtr
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
comment|/*      * Pass two: copy into the result area.      */
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|numChars
argument_list|)
expr_stmt|;
name|dst
operator|=
name|result
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|numChars
operator|=
name|Tcl_ConvertElement
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|dst
argument_list|,
name|flagPtr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|numChars
expr_stmt|;
operator|*
name|dst
operator|=
literal|' '
expr_stmt|;
name|dst
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dst
operator|==
name|result
condition|)
block|{
operator|*
name|dst
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|dst
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flagPtr
operator|!=
name|localFlags
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|flagPtr
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_Concat --  *  *	Concatenate a set of strings into a single large string.  *  * Results:  *	The return value is dynamically-allocated string containing  *	a concatenation of all the strings in argv, with spaces between  *	the original argv elements.  *  * Side effects:  *	Memory is allocated for the result;  the caller is responsible  *	for freeing the memory.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_Concat
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
comment|/* Number of strings to concatenate. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Array of strings to concatenate. */
block|{
name|int
name|totalSize
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
for|for
control|(
name|totalSize
operator|=
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|totalSize
operator|+=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|totalSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
operator|*
name|result
operator|=
literal|'\0'
expr_stmt|;
return|return
name|result
return|;
block|}
for|for
control|(
name|p
operator|=
name|result
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|element
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* 	 * Clip white space off the front and back of the string 	 * to generate a neater result, and ignore any empty 	 * elements. 	 */
name|element
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|element
argument_list|)
argument_list|)
condition|)
block|{
name|element
operator|++
expr_stmt|;
block|}
for|for
control|(
name|length
operator|=
name|strlen
argument_list|(
name|element
argument_list|)
init|;
operator|(
name|length
operator|>
literal|0
operator|)
operator|&&
operator|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
name|element
index|[
name|length
operator|-
literal|1
index|]
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|length
operator|<
literal|2
operator|)
operator|||
operator|(
name|element
index|[
name|length
operator|-
literal|2
index|]
operator|!=
literal|'\\'
operator|)
operator|)
condition|;
name|length
operator|--
control|)
block|{
comment|/* Null loop body. */
block|}
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|p
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|element
argument_list|,
operator|(
name|size_t
operator|)
name|length
argument_list|)
expr_stmt|;
name|p
operator|+=
name|length
expr_stmt|;
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
name|result
condition|)
block|{
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ConcatObj --  *  *	Concatenate the strings from a set of objects into a single string  *	object with spaces between the original strings.  *  * Results:  *	The return value is a new string object containing a concatenation  *	of the strings in objv. Its ref count is zero.  *  * Side effects:  *	A new object is created.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_ConcatObj
parameter_list|(
name|objc
parameter_list|,
name|objv
parameter_list|)
name|int
name|objc
decl_stmt|;
comment|/* Number of objects to concatenate. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* Array of objects to concatenate. */
block|{
name|int
name|allocSize
decl_stmt|,
name|finalSize
decl_stmt|,
name|length
decl_stmt|,
name|elemLength
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|element
decl_stmt|;
name|char
modifier|*
name|concatStr
decl_stmt|;
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|allocSize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|objPtr
operator|=
name|objv
index|[
name|i
index|]
expr_stmt|;
name|element
operator|=
name|TclGetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|element
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|length
operator|>
literal|0
operator|)
condition|)
block|{
name|allocSize
operator|+=
operator|(
name|length
operator|+
literal|1
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|allocSize
operator|==
literal|0
condition|)
block|{
name|allocSize
operator|=
literal|1
expr_stmt|;
comment|/* enough for the NULL byte at end */
block|}
comment|/*      * Allocate storage for the concatenated result. Note that allocSize      * is one more than the total number of characters, and so includes      * room for the terminating NULL byte.      */
name|concatStr
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|allocSize
argument_list|)
expr_stmt|;
comment|/*      * Now concatenate the elements. Clip white space off the front and back      * to generate a neater result, and ignore any empty elements. Also put      * a null byte at the end.      */
name|finalSize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|objc
operator|==
literal|0
condition|)
block|{
operator|*
name|concatStr
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|concatStr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|objPtr
operator|=
name|objv
index|[
name|i
index|]
expr_stmt|;
name|element
operator|=
name|TclGetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|&
name|elemLength
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|elemLength
operator|>
literal|0
operator|)
operator|&&
operator|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|element
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|element
operator|++
expr_stmt|;
name|elemLength
operator|--
expr_stmt|;
block|}
comment|/* 	     * Trim trailing white space.  But, be careful not to trim 	     * a space character if it is preceded by a backslash: in 	     * this case it could be significant. 	     */
while|while
condition|(
operator|(
name|elemLength
operator|>
literal|0
operator|)
operator|&&
name|isspace
argument_list|(
name|UCHAR
argument_list|(
name|element
index|[
name|elemLength
operator|-
literal|1
index|]
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|elemLength
operator|<
literal|2
operator|)
operator|||
operator|(
name|element
index|[
name|elemLength
operator|-
literal|2
index|]
operator|!=
literal|'\\'
operator|)
operator|)
condition|)
block|{
name|elemLength
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|elemLength
operator|==
literal|0
condition|)
block|{
continue|continue;
comment|/* nothing left of this element */
block|}
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|p
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|element
argument_list|,
operator|(
name|size_t
operator|)
name|elemLength
argument_list|)
expr_stmt|;
name|p
operator|+=
name|elemLength
expr_stmt|;
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|finalSize
operator|+=
operator|(
name|elemLength
operator|+
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
name|concatStr
condition|)
block|{
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|finalSize
operator|-=
literal|1
expr_stmt|;
comment|/* we overwrote the final ' ' */
block|}
else|else
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|TclNewObj
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|bytes
operator|=
name|concatStr
expr_stmt|;
name|objPtr
operator|->
name|length
operator|=
name|finalSize
expr_stmt|;
return|return
name|objPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_StringMatch --  *  *	See if a particular string matches a particular pattern.  *  * Results:  *	The return value is 1 if string matches pattern, and  *	0 otherwise.  The matching operation permits the following  *	special characters in the pattern: *?\[] (see the manual  *	entry for details on what these mean).  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_StringMatch
parameter_list|(
name|string
parameter_list|,
name|pattern
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String. */
name|char
modifier|*
name|pattern
decl_stmt|;
comment|/* Pattern, which may contain special 				 * characters. */
block|{
name|char
name|c2
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* See if we're at the end of both the pattern and the string. 	 * If so, we succeeded.  If we're at the end of the pattern 	 * but not at the end of the string, we failed. 	 */
if|if
condition|(
operator|*
name|pattern
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|string
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|(
operator|*
name|string
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|*
name|pattern
operator|!=
literal|'*'
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* Check for a "*" as the next pattern character.  It matches 	 * any substring.  We handle this by calling ourselves 	 * recursively for each postfix of string, until either we 	 * match or we reach the end of the string. 	 */
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'*'
condition|)
block|{
name|pattern
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|pattern
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|Tcl_StringMatch
argument_list|(
name|string
argument_list|,
name|pattern
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|string
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|string
operator|+=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Check for a "?" as the next pattern character.  It matches 	 * any single character. 	 */
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'?'
condition|)
block|{
goto|goto
name|thisCharOK
goto|;
block|}
comment|/* Check for a "[" as the next pattern character.  It is followed 	 * by a list of characters that are acceptable, or by a range 	 * (two characters separated by "-"). 	 */
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'['
condition|)
block|{
name|pattern
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|pattern
operator|==
literal|']'
operator|)
operator|||
operator|(
operator|*
name|pattern
operator|==
literal|0
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|*
name|pattern
operator|==
operator|*
name|string
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|pattern
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|c2
operator|=
name|pattern
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|c2
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|pattern
operator|<=
operator|*
name|string
operator|)
operator|&&
operator|(
name|c2
operator|>=
operator|*
name|string
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|(
operator|*
name|pattern
operator|>=
operator|*
name|string
operator|)
operator|&&
operator|(
name|c2
operator|<=
operator|*
name|string
operator|)
condition|)
block|{
break|break;
block|}
name|pattern
operator|+=
literal|2
expr_stmt|;
block|}
name|pattern
operator|+=
literal|1
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|pattern
operator|!=
literal|']'
condition|)
block|{
if|if
condition|(
operator|*
name|pattern
operator|==
literal|0
condition|)
block|{
name|pattern
operator|--
expr_stmt|;
break|break;
block|}
name|pattern
operator|+=
literal|1
expr_stmt|;
block|}
goto|goto
name|thisCharOK
goto|;
block|}
comment|/* If the next pattern character is '/', just strip off the '/' 	 * so we do exact matching on the character that follows. 	 */
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'\\'
condition|)
block|{
name|pattern
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|pattern
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
comment|/* There's no special character.  Just make sure that the next 	 * characters of each string match. 	 */
if|if
condition|(
operator|*
name|pattern
operator|!=
operator|*
name|string
condition|)
block|{
return|return
literal|0
return|;
block|}
name|thisCharOK
label|:
name|pattern
operator|+=
literal|1
expr_stmt|;
name|string
operator|+=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetResult --  *  *	Arrange for "string" to be the Tcl return value.  *  * Results:  *	None.  *  * Side effects:  *	interp->result is left pointing either to "string" (if "copy" is 0)  *	or to a copy of string. Also, the object result is reset.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_SetResult
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|freeProc
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter with which to associate the 				 * return value. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Value to be returned.  If NULL, the 				 * result is set to an empty string. */
name|Tcl_FreeProc
modifier|*
name|freeProc
decl_stmt|;
comment|/* Gives information about the string: 				 * TCL_STATIC, TCL_VOLATILE, or the address 				 * of a Tcl_FreeProc such as free. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|int
name|length
decl_stmt|;
name|Tcl_FreeProc
modifier|*
name|oldFreeProc
init|=
name|iPtr
operator|->
name|freeProc
decl_stmt|;
name|char
modifier|*
name|oldResult
init|=
name|iPtr
operator|->
name|result
decl_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
condition|)
block|{
name|iPtr
operator|->
name|resultSpace
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|iPtr
operator|->
name|result
operator|=
name|iPtr
operator|->
name|resultSpace
expr_stmt|;
name|iPtr
operator|->
name|freeProc
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|freeProc
operator|==
name|TCL_VOLATILE
condition|)
block|{
name|length
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
name|TCL_RESULT_SIZE
condition|)
block|{
name|iPtr
operator|->
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|freeProc
operator|=
name|TCL_DYNAMIC
expr_stmt|;
block|}
else|else
block|{
name|iPtr
operator|->
name|result
operator|=
name|iPtr
operator|->
name|resultSpace
expr_stmt|;
name|iPtr
operator|->
name|freeProc
operator|=
literal|0
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|iPtr
operator|->
name|result
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iPtr
operator|->
name|result
operator|=
name|string
expr_stmt|;
name|iPtr
operator|->
name|freeProc
operator|=
name|freeProc
expr_stmt|;
block|}
comment|/*      * If the old result was dynamically-allocated, free it up.  Do it      * here, rather than at the beginning, in case the new result value      * was part of the old result value.      */
if|if
condition|(
name|oldFreeProc
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|oldFreeProc
operator|==
name|TCL_DYNAMIC
operator|)
operator|||
operator|(
name|oldFreeProc
operator|==
operator|(
name|Tcl_FreeProc
operator|*
operator|)
name|free
operator|)
condition|)
block|{
name|ckfree
argument_list|(
name|oldResult
argument_list|)
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|oldFreeProc
call|)
argument_list|(
name|oldResult
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Reset the object result since we just set the string result.      */
name|TclResetObjResult
argument_list|(
name|iPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetStringResult --  *  *	Returns an interpreter's result value as a string.  *  * Results:  *	The interpreter's result as a string.  *  * Side effects:  *	If the string result is empty, the object result is moved to the  *	string result, then the object result is reset.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_GetStringResult
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter whose result to return. */
block|{
comment|/*      * If the string result is empty, move the object result to the      * string result, then reset the object result.      * FAILS IF OBJECT RESULT'S STRING REPRESENTATION CONTAINS NULLS.      */
if|if
condition|(
operator|*
operator|(
name|interp
operator|->
name|result
operator|)
operator|==
literal|0
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|TclGetStringFromObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
return|return
name|interp
operator|->
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetObjResult --  *  *	Arrange for objPtr to be an interpreter's result value.  *  * Results:  *	None.  *  * Side effects:  *	interp->objResultPtr is left pointing to the object referenced  *	by objPtr. The object's reference count is incremented since  *	there is now a new reference to it. The reference count for any  *	old objResultPtr value is decremented. Also, the string result  *	is reset.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_SetObjResult
parameter_list|(
name|interp
parameter_list|,
name|objPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter with which to associate the 				 * return object value. */
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Tcl object to be returned. If NULL, the 				 * obj result is made an empty string 				 * object. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Tcl_Obj
modifier|*
name|oldObjResult
init|=
name|iPtr
operator|->
name|objResultPtr
decl_stmt|;
name|iPtr
operator|->
name|objResultPtr
operator|=
name|objPtr
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
comment|/* since interp result is a reference */
comment|/*      * We wait until the end to release the old object result, in case      * we are setting the result to itself.      */
name|TclDecrRefCount
argument_list|(
name|oldObjResult
argument_list|)
expr_stmt|;
comment|/*      * Reset the string result since we just set the result object.      */
if|if
condition|(
name|iPtr
operator|->
name|freeProc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|iPtr
operator|->
name|freeProc
operator|==
name|TCL_DYNAMIC
operator|)
operator|||
operator|(
name|iPtr
operator|->
name|freeProc
operator|==
operator|(
name|Tcl_FreeProc
operator|*
operator|)
name|free
operator|)
condition|)
block|{
name|ckfree
argument_list|(
name|iPtr
operator|->
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|iPtr
operator|->
name|freeProc
call|)
argument_list|(
name|iPtr
operator|->
name|result
argument_list|)
expr_stmt|;
block|}
name|iPtr
operator|->
name|freeProc
operator|=
literal|0
expr_stmt|;
block|}
name|iPtr
operator|->
name|result
operator|=
name|iPtr
operator|->
name|resultSpace
expr_stmt|;
name|iPtr
operator|->
name|resultSpace
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetObjResult --  *  *	Returns an interpreter's result value as a Tcl object. The object's  *	reference count is not modified; the caller must do that if it  *	needs to hold on to a long-term reference to it.  *  * Results:  *	The interpreter's result as an object.  *  * Side effects:  *	If the interpreter has a non-empty string result, the result object  *	is either empty or stale because some procedure set interp->result  *	directly. If so, the string result is moved to the result object  *	then the string result is reset.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_GetObjResult
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter whose result to return. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Tcl_Obj
modifier|*
name|objResultPtr
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/*      * If the string result is non-empty, move the string result to the      * object result, then reset the string result.      */
if|if
condition|(
operator|*
operator|(
name|iPtr
operator|->
name|result
operator|)
operator|!=
literal|0
condition|)
block|{
name|TclResetObjResult
argument_list|(
name|iPtr
argument_list|)
expr_stmt|;
name|objResultPtr
operator|=
name|iPtr
operator|->
name|objResultPtr
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|iPtr
operator|->
name|result
argument_list|)
expr_stmt|;
name|TclInitStringRep
argument_list|(
name|objResultPtr
argument_list|,
name|iPtr
operator|->
name|result
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|freeProc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|iPtr
operator|->
name|freeProc
operator|==
name|TCL_DYNAMIC
operator|)
operator|||
operator|(
name|iPtr
operator|->
name|freeProc
operator|==
operator|(
name|Tcl_FreeProc
operator|*
operator|)
name|free
operator|)
condition|)
block|{
name|ckfree
argument_list|(
name|iPtr
operator|->
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|iPtr
operator|->
name|freeProc
call|)
argument_list|(
name|iPtr
operator|->
name|result
argument_list|)
expr_stmt|;
block|}
name|iPtr
operator|->
name|freeProc
operator|=
literal|0
expr_stmt|;
block|}
name|iPtr
operator|->
name|result
operator|=
name|iPtr
operator|->
name|resultSpace
expr_stmt|;
name|iPtr
operator|->
name|resultSpace
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|iPtr
operator|->
name|objResultPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_AppendResult --  *  *	Append a variable number of strings onto the interpreter's string  *	result.  *  * Results:  *	None.  *  * Side effects:  *	The result of the interpreter given by the first argument is  *	extended by the strings given by the second and following arguments  *	(up to a terminating NULL argument).  *  *	If the string result is empty, the object result is moved to the  *	string result, then the object result is reset.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_AppendResult
name|TCL_VARARGS_DEF
parameter_list|(
name|Tcl_Interp
modifier|*
parameter_list|,
name|arg1
parameter_list|)
block|{
name|va_list
name|argList
decl_stmt|;
name|Interp
modifier|*
name|iPtr
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|newSpace
decl_stmt|;
comment|/*      * If the string result is empty, move the object result to the      * string result, then reset the object result.      * FAILS IF OBJECT RESULT'S STRING REPRESENTATION CONTAINS NULLS.      */
name|iPtr
operator|=
operator|(
name|Interp
operator|*
operator|)
name|TCL_VARARGS_START
argument_list|(
name|Tcl_Interp
operator|*
argument_list|,
name|arg1
argument_list|,
name|argList
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|iPtr
operator|->
name|result
operator|)
operator|==
literal|0
condition|)
block|{
name|Tcl_SetResult
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
name|TclGetStringFromObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|)
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
comment|/*      * Scan through all the arguments to see how much space is needed.      */
name|newSpace
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|string
operator|=
name|va_arg
argument_list|(
name|argList
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|newSpace
operator|+=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|argList
argument_list|)
expr_stmt|;
comment|/*      * If the append buffer isn't already setup and large enough to hold      * the new data, set it up.      */
if|if
condition|(
operator|(
name|iPtr
operator|->
name|result
operator|!=
name|iPtr
operator|->
name|appendResult
operator|)
operator|||
operator|(
name|iPtr
operator|->
name|appendResult
index|[
name|iPtr
operator|->
name|appendUsed
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|newSpace
operator|+
name|iPtr
operator|->
name|appendUsed
operator|)
operator|>=
name|iPtr
operator|->
name|appendAvl
operator|)
condition|)
block|{
name|SetupAppendBuffer
argument_list|(
name|iPtr
argument_list|,
name|newSpace
argument_list|)
expr_stmt|;
block|}
comment|/*      * Now go through all the argument strings again, copying them into the      * buffer.      */
name|TCL_VARARGS_START
argument_list|(
name|Tcl_Interp
operator|*
argument_list|,
name|arg1
argument_list|,
name|argList
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|string
operator|=
name|va_arg
argument_list|(
name|argList
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|strcpy
argument_list|(
name|iPtr
operator|->
name|appendResult
operator|+
name|iPtr
operator|->
name|appendUsed
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|appendUsed
operator|+=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|argList
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_AppendElement --  *  *	Convert a string to a valid Tcl list element and append it to the  *	result (which is ostensibly a list).  *  * Results:  *	None.  *  * Side effects:  *	The result in the interpreter given by the first argument is  *	extended with a list element converted from string. A separator  *	space is added before the converted list element unless the current  *	result is empty, contains the single character "{", or ends in " {".  *  *	If the string result is empty, the object result is moved to the  *	string result, then the object result is reset.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_AppendElement
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter whose result is to be 				 * extended. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String to convert to list element and 				 * add to result. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/*      * If the string result is empty, move the object result to the      * string result, then reset the object result.      * FAILS IF OBJECT RESULT'S STRING REPRESENTATION CONTAINS NULLS.      */
if|if
condition|(
operator|*
operator|(
name|iPtr
operator|->
name|result
operator|)
operator|==
literal|0
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|TclGetStringFromObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
comment|/*      * See how much space is needed, and grow the append buffer if      * needed to accommodate the list element.      */
name|size
operator|=
name|Tcl_ScanElement
argument_list|(
name|string
argument_list|,
operator|&
name|flags
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|iPtr
operator|->
name|result
operator|!=
name|iPtr
operator|->
name|appendResult
operator|)
operator|||
operator|(
name|iPtr
operator|->
name|appendResult
index|[
name|iPtr
operator|->
name|appendUsed
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|size
operator|+
name|iPtr
operator|->
name|appendUsed
operator|)
operator|>=
name|iPtr
operator|->
name|appendAvl
operator|)
condition|)
block|{
name|SetupAppendBuffer
argument_list|(
name|iPtr
argument_list|,
name|size
operator|+
name|iPtr
operator|->
name|appendUsed
argument_list|)
expr_stmt|;
block|}
comment|/*      * Convert the string into a list element and copy it to the      * buffer that's forming, with a space separator if needed.      */
name|dst
operator|=
name|iPtr
operator|->
name|appendResult
operator|+
name|iPtr
operator|->
name|appendUsed
expr_stmt|;
if|if
condition|(
name|TclNeedSpace
argument_list|(
name|iPtr
operator|->
name|appendResult
argument_list|,
name|dst
argument_list|)
condition|)
block|{
name|iPtr
operator|->
name|appendUsed
operator|++
expr_stmt|;
operator|*
name|dst
operator|=
literal|' '
expr_stmt|;
name|dst
operator|++
expr_stmt|;
block|}
name|iPtr
operator|->
name|appendUsed
operator|+=
name|Tcl_ConvertElement
argument_list|(
name|string
argument_list|,
name|dst
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SetupAppendBuffer --  *  *	This procedure makes sure that there is an append buffer properly  *	initialized, if necessary, from the interpreter's result, and  *	that it has at least enough room to accommodate newSpace new  *	bytes of information.  *  * Results:  *	None.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|SetupAppendBuffer
parameter_list|(
name|iPtr
parameter_list|,
name|newSpace
parameter_list|)
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/* Interpreter whose result is being set up. */
name|int
name|newSpace
decl_stmt|;
comment|/* Make sure that at least this many bytes 				 * of new information may be added. */
block|{
name|int
name|totalSpace
decl_stmt|;
comment|/*      * Make the append buffer larger, if that's necessary, then copy the      * result into the append buffer and make the append buffer the official      * Tcl result.      */
if|if
condition|(
name|iPtr
operator|->
name|result
operator|!=
name|iPtr
operator|->
name|appendResult
condition|)
block|{
comment|/* 	 * If an oversized buffer was used recently, then free it up 	 * so we go back to a smaller buffer.  This avoids tying up 	 * memory forever after a large operation. 	 */
if|if
condition|(
name|iPtr
operator|->
name|appendAvl
operator|>
literal|500
condition|)
block|{
name|ckfree
argument_list|(
name|iPtr
operator|->
name|appendResult
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|appendResult
operator|=
name|NULL
expr_stmt|;
name|iPtr
operator|->
name|appendAvl
operator|=
literal|0
expr_stmt|;
block|}
name|iPtr
operator|->
name|appendUsed
operator|=
name|strlen
argument_list|(
name|iPtr
operator|->
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iPtr
operator|->
name|result
index|[
name|iPtr
operator|->
name|appendUsed
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* 	 * Most likely someone has modified a result created by 	 * Tcl_AppendResult et al. so that it has a different size. 	 * Just recompute the size. 	 */
name|iPtr
operator|->
name|appendUsed
operator|=
name|strlen
argument_list|(
name|iPtr
operator|->
name|result
argument_list|)
expr_stmt|;
block|}
name|totalSpace
operator|=
name|newSpace
operator|+
name|iPtr
operator|->
name|appendUsed
expr_stmt|;
if|if
condition|(
name|totalSpace
operator|>=
name|iPtr
operator|->
name|appendAvl
condition|)
block|{
name|char
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|totalSpace
operator|<
literal|100
condition|)
block|{
name|totalSpace
operator|=
literal|200
expr_stmt|;
block|}
else|else
block|{
name|totalSpace
operator|*=
literal|2
expr_stmt|;
block|}
name|new
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|totalSpace
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new
argument_list|,
name|iPtr
operator|->
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|appendResult
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|iPtr
operator|->
name|appendResult
argument_list|)
expr_stmt|;
block|}
name|iPtr
operator|->
name|appendResult
operator|=
name|new
expr_stmt|;
name|iPtr
operator|->
name|appendAvl
operator|=
name|totalSpace
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iPtr
operator|->
name|result
operator|!=
name|iPtr
operator|->
name|appendResult
condition|)
block|{
name|strcpy
argument_list|(
name|iPtr
operator|->
name|appendResult
argument_list|,
name|iPtr
operator|->
name|result
argument_list|)
expr_stmt|;
block|}
name|Tcl_FreeResult
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|result
operator|=
name|iPtr
operator|->
name|appendResult
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_FreeResult --  *  *	This procedure frees up the memory associated with an interpreter's  *	string result. It also resets the interpreter's result object.  *	Tcl_FreeResult is most commonly used when a procedure is about to  *	replace one result value with another.  *  * Results:  *	None.  *  * Side effects:  *	Frees the memory associated with interp's string result and sets  *	interp->freeProc to zero, but does not change interp->result or  *	clear error state. Resets interp's result object to an unshared  *	empty object.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_FreeResult
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter for which to free result. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|freeProc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|iPtr
operator|->
name|freeProc
operator|==
name|TCL_DYNAMIC
operator|)
operator|||
operator|(
name|iPtr
operator|->
name|freeProc
operator|==
operator|(
name|Tcl_FreeProc
operator|*
operator|)
name|free
operator|)
condition|)
block|{
name|ckfree
argument_list|(
name|iPtr
operator|->
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|iPtr
operator|->
name|freeProc
call|)
argument_list|(
name|iPtr
operator|->
name|result
argument_list|)
expr_stmt|;
block|}
name|iPtr
operator|->
name|freeProc
operator|=
literal|0
expr_stmt|;
block|}
name|TclResetObjResult
argument_list|(
name|iPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ResetResult --  *  *	This procedure resets both the interpreter's string and object  *	results.  *  * Results:  *	None.  *  * Side effects:  *	It resets the result object to an unshared empty object. It  *	then restores the interpreter's string result area to its default  *	initialized state, freeing up any memory that may have been  *	allocated. It also clears any error information for the interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_ResetResult
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter for which to clear result. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|TclResetObjResult
argument_list|(
name|iPtr
argument_list|)
expr_stmt|;
name|Tcl_FreeResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|result
operator|=
name|iPtr
operator|->
name|resultSpace
expr_stmt|;
name|iPtr
operator|->
name|resultSpace
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|iPtr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|ERR_ALREADY_LOGGED
operator||
name|ERR_IN_PROGRESS
operator||
name|ERROR_CODE_SET
operator|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetErrorCode --  *  *	This procedure is called to record machine-readable information  *	about an error that is about to be returned.  *  * Results:  *	None.  *  * Side effects:  *	The errorCode global variable is modified to hold all of the  *	arguments to this procedure, in a list form with each argument  *	becoming one element of the list.  A flag is set internally  *	to remember that errorCode has been set, so the variable doesn't  *	get set automatically when the error is returned.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* VARARGS2 */
end_comment

begin_function
name|void
name|Tcl_SetErrorCode
name|TCL_VARARGS_DEF
parameter_list|(
name|Tcl_Interp
modifier|*
parameter_list|,
name|arg1
parameter_list|)
block|{
name|va_list
name|argList
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|Interp
modifier|*
name|iPtr
decl_stmt|;
comment|/*      * Scan through the arguments one at a time, appending them to      * $errorCode as list elements.      */
name|iPtr
operator|=
operator|(
name|Interp
operator|*
operator|)
name|TCL_VARARGS_START
argument_list|(
name|Tcl_Interp
operator|*
argument_list|,
name|arg1
argument_list|,
name|argList
argument_list|)
expr_stmt|;
name|flags
operator|=
name|TCL_GLOBAL_ONLY
operator||
name|TCL_LIST_ELEMENT
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|string
operator|=
name|va_arg
argument_list|(
name|argList
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
operator|(
name|void
operator|)
name|Tcl_SetVar2
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|iPtr
argument_list|,
literal|"errorCode"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|string
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|flags
operator||=
name|TCL_APPEND_VALUE
expr_stmt|;
block|}
name|va_end
argument_list|(
name|argList
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|flags
operator||=
name|ERROR_CODE_SET
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetObjErrorCode --  *  *	This procedure is called to record machine-readable information  *	about an error that is about to be returned. The caller should  *	build a list object up and pass it to this routine.  *  * Results:  *	None.  *  * Side effects:  *	The errorCode global variable is modified to be the new value.  *	A flag is set internally to remember that errorCode has been  *	set, so the variable doesn't get set automatically when the  *	error is returned.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_SetObjErrorCode
parameter_list|(
name|interp
parameter_list|,
name|errorObjPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
name|Tcl_Obj
modifier|*
name|errorObjPtr
decl_stmt|;
block|{
name|Tcl_Obj
modifier|*
name|namePtr
decl_stmt|;
name|Interp
modifier|*
name|iPtr
decl_stmt|;
name|namePtr
operator|=
name|Tcl_NewStringObj
argument_list|(
literal|"errorCode"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|iPtr
operator|=
operator|(
name|Interp
operator|*
operator|)
name|interp
expr_stmt|;
name|Tcl_ObjSetVar2
argument_list|(
name|interp
argument_list|,
name|namePtr
argument_list|,
operator|(
name|Tcl_Obj
operator|*
operator|)
name|NULL
argument_list|,
name|errorObjPtr
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|flags
operator||=
name|ERROR_CODE_SET
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_RegExpCompile --  *  *	Compile a regular expression into a form suitable for fast  *	matching.  This procedure retains a small cache of pre-compiled  *	regular expressions in the interpreter, in order to avoid  *	compilation costs as much as possible.  *  * Results:  *	The return value is a pointer to the compiled form of string,  *	suitable for passing to Tcl_RegExpExec.  This compiled form  *	is only valid up until the next call to this procedure, so  *	don't keep these around for a long time!  If an error occurred  *	while compiling the pattern, then NULL is returned and an error  *	message is left in interp->result.  *  * Side effects:  *	The cache of compiled regexp's in interp will be modified to  *	hold information for string, if such information isn't already  *	present in the cache.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_RegExp
name|Tcl_RegExpCompile
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* For use in error reporting. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String for which to produce 					 * compiled regular expression. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|length
decl_stmt|;
name|regexp
modifier|*
name|result
decl_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGEXPS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|length
operator|==
name|iPtr
operator|->
name|patLengths
index|[
name|i
index|]
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|string
argument_list|,
name|iPtr
operator|->
name|patterns
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 	     * Move the matched pattern to the first slot in the 	     * cache and shift the other patterns down one position. 	     */
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|cachedString
decl_stmt|;
name|cachedString
operator|=
name|iPtr
operator|->
name|patterns
index|[
name|i
index|]
expr_stmt|;
name|result
operator|=
name|iPtr
operator|->
name|regexps
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|iPtr
operator|->
name|patterns
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|iPtr
operator|->
name|patterns
index|[
name|j
index|]
expr_stmt|;
name|iPtr
operator|->
name|patLengths
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|iPtr
operator|->
name|patLengths
index|[
name|j
index|]
expr_stmt|;
name|iPtr
operator|->
name|regexps
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|iPtr
operator|->
name|regexps
index|[
name|j
index|]
expr_stmt|;
block|}
name|iPtr
operator|->
name|patterns
index|[
literal|0
index|]
operator|=
name|cachedString
expr_stmt|;
name|iPtr
operator|->
name|patLengths
index|[
literal|0
index|]
operator|=
name|length
expr_stmt|;
name|iPtr
operator|->
name|regexps
index|[
literal|0
index|]
operator|=
name|result
expr_stmt|;
block|}
return|return
operator|(
name|Tcl_RegExp
operator|)
name|iPtr
operator|->
name|regexps
index|[
literal|0
index|]
return|;
block|}
block|}
comment|/*      * No match in the cache.  Compile the string and add it to the      * cache.      */
name|TclRegError
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TclRegComp
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|TclGetRegError
argument_list|()
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"couldn't compile regular expression pattern: "
argument_list|,
name|TclGetRegError
argument_list|()
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|iPtr
operator|->
name|patterns
index|[
name|NUM_REGEXPS
operator|-
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|iPtr
operator|->
name|patterns
index|[
name|NUM_REGEXPS
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iPtr
operator|->
name|regexps
index|[
name|NUM_REGEXPS
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|NUM_REGEXPS
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|iPtr
operator|->
name|patterns
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|iPtr
operator|->
name|patterns
index|[
name|i
index|]
expr_stmt|;
name|iPtr
operator|->
name|patLengths
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|iPtr
operator|->
name|patLengths
index|[
name|i
index|]
expr_stmt|;
name|iPtr
operator|->
name|regexps
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|iPtr
operator|->
name|regexps
index|[
name|i
index|]
expr_stmt|;
block|}
name|iPtr
operator|->
name|patterns
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|length
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|iPtr
operator|->
name|patterns
index|[
literal|0
index|]
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|iPtr
operator|->
name|patLengths
index|[
literal|0
index|]
operator|=
name|length
expr_stmt|;
name|iPtr
operator|->
name|regexps
index|[
literal|0
index|]
operator|=
name|result
expr_stmt|;
return|return
operator|(
name|Tcl_RegExp
operator|)
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_RegExpExec --  *  *	Execute the regular expression matcher using a compiled form  *	of a regular expression and save information about any match  *	that is found.  *  * Results:  *	If an error occurs during the matching operation then -1  *	is returned and interp->result contains an error message.  *	Otherwise the return value is 1 if a matching range is  *	found and 0 if there is no matching range.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_RegExpExec
parameter_list|(
name|interp
parameter_list|,
name|re
parameter_list|,
name|string
parameter_list|,
name|start
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for error reporting. */
name|Tcl_RegExp
name|re
decl_stmt|;
comment|/* Compiled regular expression;  must have 				 * been returned by previous call to 				 * Tcl_RegExpCompile. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String against which to match re. */
name|char
modifier|*
name|start
decl_stmt|;
comment|/* If string is part of a larger string, 				 * this identifies beginning of larger 				 * string, so that "^" won't match. */
block|{
name|int
name|match
decl_stmt|;
name|regexp
modifier|*
name|regexpPtr
init|=
operator|(
name|regexp
operator|*
operator|)
name|re
decl_stmt|;
name|TclRegError
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|match
operator|=
name|TclRegExec
argument_list|(
name|regexpPtr
argument_list|,
name|string
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|TclGetRegError
argument_list|()
operator|!=
name|NULL
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"error while matching regular expression: "
argument_list|,
name|TclGetRegError
argument_list|()
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|match
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_RegExpRange --  *  *	Returns pointers describing the range of a regular expression match,  *	or one of the subranges within the match.  *  * Results:  *	The variables at *startPtr and *endPtr are modified to hold the  *	addresses of the endpoints of the range given by index.  If the  *	specified range doesn't exist then NULLs are returned.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_RegExpRange
parameter_list|(
name|re
parameter_list|,
name|index
parameter_list|,
name|startPtr
parameter_list|,
name|endPtr
parameter_list|)
name|Tcl_RegExp
name|re
decl_stmt|;
comment|/* Compiled regular expression that has 				 * been passed to Tcl_RegExpExec. */
name|int
name|index
decl_stmt|;
comment|/* 0 means give the range of the entire 				 * match,> 0 means give the range of 				 * a matching subrange.  Must be no greater 				 * than NSUBEXP. */
name|char
modifier|*
modifier|*
name|startPtr
decl_stmt|;
comment|/* Store address of first character in 				 * (sub-) range here. */
name|char
modifier|*
modifier|*
name|endPtr
decl_stmt|;
comment|/* Store address of character just after last 				 * in (sub-) range here. */
block|{
name|regexp
modifier|*
name|regexpPtr
init|=
operator|(
name|regexp
operator|*
operator|)
name|re
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|NSUBEXP
condition|)
block|{
operator|*
name|startPtr
operator|=
operator|*
name|endPtr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
operator|*
name|startPtr
operator|=
name|regexpPtr
operator|->
name|startp
index|[
name|index
index|]
expr_stmt|;
operator|*
name|endPtr
operator|=
name|regexpPtr
operator|->
name|endp
index|[
name|index
index|]
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_RegExpMatch --  *  *	See if a string matches a regular expression.  *  * Results:  *	If an error occurs during the matching operation then -1  *	is returned and interp->result contains an error message.  *	Otherwise the return value is 1 if "string" matches "pattern"  *	and 0 otherwise.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_RegExpMatch
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|pattern
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String. */
name|char
modifier|*
name|pattern
decl_stmt|;
comment|/* Regular expression to match against 				 * string. */
block|{
name|Tcl_RegExp
name|re
decl_stmt|;
name|re
operator|=
name|Tcl_RegExpCompile
argument_list|(
name|interp
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|==
name|NULL
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
name|Tcl_RegExpExec
argument_list|(
name|interp
argument_list|,
name|re
argument_list|,
name|string
argument_list|,
name|string
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DStringInit --  *  *	Initializes a dynamic string, discarding any previous contents  *	of the string (Tcl_DStringFree should have been called already  *	if the dynamic string was previously in use).  *  * Results:  *	None.  *  * Side effects:  *	The dynamic string is initialized to be empty.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DStringInit
parameter_list|(
name|dsPtr
parameter_list|)
name|Tcl_DString
modifier|*
name|dsPtr
decl_stmt|;
comment|/* Pointer to structure for dynamic string. */
block|{
name|dsPtr
operator|->
name|string
operator|=
name|dsPtr
operator|->
name|staticSpace
expr_stmt|;
name|dsPtr
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|dsPtr
operator|->
name|spaceAvl
operator|=
name|TCL_DSTRING_STATIC_SIZE
expr_stmt|;
name|dsPtr
operator|->
name|staticSpace
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DStringAppend --  *  *	Append more characters to the current value of a dynamic string.  *  * Results:  *	The return value is a pointer to the dynamic string's new value.  *  * Side effects:  *	Length bytes from string (or all of string if length is less  *	than zero) are added to the current value of the string. Memory  *	gets reallocated if needed to accomodate the string's new size.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_DStringAppend
parameter_list|(
name|dsPtr
parameter_list|,
name|string
parameter_list|,
name|length
parameter_list|)
name|Tcl_DString
modifier|*
name|dsPtr
decl_stmt|;
comment|/* Structure describing dynamic string. */
name|CONST
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String to append.  If length is -1 then 				 * this must be null-terminated. */
name|int
name|length
decl_stmt|;
comment|/* Number of characters from string to 				 * append.  If< 0, then append all of string, 				 * up to null at end. */
block|{
name|int
name|newSize
decl_stmt|;
name|char
modifier|*
name|newString
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|CONST
name|char
modifier|*
name|end
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
name|length
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
name|newSize
operator|=
name|length
operator|+
name|dsPtr
operator|->
name|length
expr_stmt|;
comment|/*      * Allocate a larger buffer for the string if the current one isn't      * large enough. Allocate extra space in the new buffer so that there      * will be room to grow before we have to allocate again.      */
if|if
condition|(
name|newSize
operator|>=
name|dsPtr
operator|->
name|spaceAvl
condition|)
block|{
name|dsPtr
operator|->
name|spaceAvl
operator|=
name|newSize
operator|*
literal|2
expr_stmt|;
name|newString
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|dsPtr
operator|->
name|spaceAvl
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|newString
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|dsPtr
operator|->
name|string
argument_list|,
operator|(
name|size_t
operator|)
name|dsPtr
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsPtr
operator|->
name|string
operator|!=
name|dsPtr
operator|->
name|staticSpace
condition|)
block|{
name|ckfree
argument_list|(
name|dsPtr
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
name|dsPtr
operator|->
name|string
operator|=
name|newString
expr_stmt|;
block|}
comment|/*      * Copy the new string into the buffer at the end of the old      * one.      */
for|for
control|(
name|dst
operator|=
name|dsPtr
operator|->
name|string
operator|+
name|dsPtr
operator|->
name|length
operator|,
name|end
operator|=
name|string
operator|+
name|length
init|;
name|string
operator|<
name|end
condition|;
name|string
operator|++
operator|,
name|dst
operator|++
control|)
block|{
operator|*
name|dst
operator|=
operator|*
name|string
expr_stmt|;
block|}
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
name|dsPtr
operator|->
name|length
operator|+=
name|length
expr_stmt|;
return|return
name|dsPtr
operator|->
name|string
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DStringAppendElement --  *  *	Append a list element to the current value of a dynamic string.  *  * Results:  *	The return value is a pointer to the dynamic string's new value.  *  * Side effects:  *	String is reformatted as a list element and added to the current  *	value of the string.  Memory gets reallocated if needed to  *	accomodate the string's new size.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_DStringAppendElement
parameter_list|(
name|dsPtr
parameter_list|,
name|string
parameter_list|)
name|Tcl_DString
modifier|*
name|dsPtr
decl_stmt|;
comment|/* Structure describing dynamic string. */
name|CONST
name|char
modifier|*
name|string
decl_stmt|;
comment|/* String to append.  Must be 				 * null-terminated. */
block|{
name|int
name|newSize
decl_stmt|,
name|flags
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|,
modifier|*
name|newString
decl_stmt|;
name|newSize
operator|=
name|Tcl_ScanElement
argument_list|(
name|string
argument_list|,
operator|&
name|flags
argument_list|)
operator|+
name|dsPtr
operator|->
name|length
operator|+
literal|1
expr_stmt|;
comment|/*      * Allocate a larger buffer for the string if the current one isn't      * large enough.  Allocate extra space in the new buffer so that there      * will be room to grow before we have to allocate again.      * SPECIAL NOTE: must use memcpy, not strcpy, to copy the string      * to a larger buffer, since there may be embedded NULLs in the      * string in some cases.      */
if|if
condition|(
name|newSize
operator|>=
name|dsPtr
operator|->
name|spaceAvl
condition|)
block|{
name|dsPtr
operator|->
name|spaceAvl
operator|=
name|newSize
operator|*
literal|2
expr_stmt|;
name|newString
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|dsPtr
operator|->
name|spaceAvl
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|newString
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|dsPtr
operator|->
name|string
argument_list|,
operator|(
name|size_t
operator|)
name|dsPtr
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsPtr
operator|->
name|string
operator|!=
name|dsPtr
operator|->
name|staticSpace
condition|)
block|{
name|ckfree
argument_list|(
name|dsPtr
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
name|dsPtr
operator|->
name|string
operator|=
name|newString
expr_stmt|;
block|}
comment|/*      * Convert the new string to a list element and copy it into the      * buffer at the end, with a space, if needed.      */
name|dst
operator|=
name|dsPtr
operator|->
name|string
operator|+
name|dsPtr
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|TclNeedSpace
argument_list|(
name|dsPtr
operator|->
name|string
argument_list|,
name|dst
argument_list|)
condition|)
block|{
operator|*
name|dst
operator|=
literal|' '
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|dsPtr
operator|->
name|length
operator|++
expr_stmt|;
block|}
name|dsPtr
operator|->
name|length
operator|+=
name|Tcl_ConvertElement
argument_list|(
name|string
argument_list|,
name|dst
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|dsPtr
operator|->
name|string
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DStringSetLength --  *  *	Change the length of a dynamic string.  This can cause the  *	string to either grow or shrink, depending on the value of  *	length.  *  * Results:  *	None.  *  * Side effects:  *	The length of dsPtr is changed to length and a null byte is  *	stored at that position in the string.  If length is larger  *	than the space allocated for dsPtr, then a panic occurs.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DStringSetLength
parameter_list|(
name|dsPtr
parameter_list|,
name|length
parameter_list|)
name|Tcl_DString
modifier|*
name|dsPtr
decl_stmt|;
comment|/* Structure describing dynamic string. */
name|int
name|length
decl_stmt|;
comment|/* New length for dynamic string. */
block|{
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
name|length
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|>=
name|dsPtr
operator|->
name|spaceAvl
condition|)
block|{
name|char
modifier|*
name|newString
decl_stmt|;
name|dsPtr
operator|->
name|spaceAvl
operator|=
name|length
operator|+
literal|1
expr_stmt|;
name|newString
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|dsPtr
operator|->
name|spaceAvl
argument_list|)
expr_stmt|;
comment|/* 	 * SPECIAL NOTE: must use memcpy, not strcpy, to copy the string 	 * to a larger buffer, since there may be embedded NULLs in the 	 * string in some cases. 	 */
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|newString
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|dsPtr
operator|->
name|string
argument_list|,
operator|(
name|size_t
operator|)
name|dsPtr
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsPtr
operator|->
name|string
operator|!=
name|dsPtr
operator|->
name|staticSpace
condition|)
block|{
name|ckfree
argument_list|(
name|dsPtr
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
name|dsPtr
operator|->
name|string
operator|=
name|newString
expr_stmt|;
block|}
name|dsPtr
operator|->
name|length
operator|=
name|length
expr_stmt|;
name|dsPtr
operator|->
name|string
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DStringFree --  *  *	Frees up any memory allocated for the dynamic string and  *	reinitializes the string to an empty state.  *  * Results:  *	None.  *  * Side effects:  *	The previous contents of the dynamic string are lost, and  *	the new value is an empty string.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DStringFree
parameter_list|(
name|dsPtr
parameter_list|)
name|Tcl_DString
modifier|*
name|dsPtr
decl_stmt|;
comment|/* Structure describing dynamic string. */
block|{
if|if
condition|(
name|dsPtr
operator|->
name|string
operator|!=
name|dsPtr
operator|->
name|staticSpace
condition|)
block|{
name|ckfree
argument_list|(
name|dsPtr
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
name|dsPtr
operator|->
name|string
operator|=
name|dsPtr
operator|->
name|staticSpace
expr_stmt|;
name|dsPtr
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|dsPtr
operator|->
name|spaceAvl
operator|=
name|TCL_DSTRING_STATIC_SIZE
expr_stmt|;
name|dsPtr
operator|->
name|staticSpace
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DStringResult --  *  *	This procedure moves the value of a dynamic string into an  *	interpreter as its string result. Afterwards, the dynamic string  *	is reset to an empty string.  *  * Results:  *	None.  *  * Side effects:  *	The string is "moved" to interp's result, and any existing  *	string result for interp is freed. dsPtr is reinitialized to  *	an empty string.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DStringResult
parameter_list|(
name|interp
parameter_list|,
name|dsPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter whose result is to be reset. */
name|Tcl_DString
modifier|*
name|dsPtr
decl_stmt|;
comment|/* Dynamic string that is to become the 				 * result of interp. */
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsPtr
operator|->
name|string
operator|!=
name|dsPtr
operator|->
name|staticSpace
condition|)
block|{
name|interp
operator|->
name|result
operator|=
name|dsPtr
operator|->
name|string
expr_stmt|;
name|interp
operator|->
name|freeProc
operator|=
name|TCL_DYNAMIC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dsPtr
operator|->
name|length
operator|<
name|TCL_RESULT_SIZE
condition|)
block|{
name|interp
operator|->
name|result
operator|=
operator|(
operator|(
name|Interp
operator|*
operator|)
name|interp
operator|)
operator|->
name|resultSpace
expr_stmt|;
name|strcpy
argument_list|(
name|interp
operator|->
name|result
argument_list|,
name|dsPtr
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|dsPtr
operator|->
name|string
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
name|dsPtr
operator|->
name|string
operator|=
name|dsPtr
operator|->
name|staticSpace
expr_stmt|;
name|dsPtr
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|dsPtr
operator|->
name|spaceAvl
operator|=
name|TCL_DSTRING_STATIC_SIZE
expr_stmt|;
name|dsPtr
operator|->
name|staticSpace
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DStringGetResult --  *  *	This procedure moves an interpreter's result into a dynamic string.  *  * Results:  *	None.  *  * Side effects:  *	The interpreter's string result is cleared, and the previous  *	contents of dsPtr are freed.  *  *	If the string result is empty, the object result is moved to the  *	string result, then the object result is reset.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DStringGetResult
parameter_list|(
name|interp
parameter_list|,
name|dsPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter whose result is to be reset. */
name|Tcl_DString
modifier|*
name|dsPtr
decl_stmt|;
comment|/* Dynamic string that is to become the 				 * result of interp. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
if|if
condition|(
name|dsPtr
operator|->
name|string
operator|!=
name|dsPtr
operator|->
name|staticSpace
condition|)
block|{
name|ckfree
argument_list|(
name|dsPtr
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
comment|/*      * If the string result is empty, move the object result to the      * string result, then reset the object result.      * FAILS IF OBJECT RESULT'S STRING REPRESENTATION CONTAINS NULLS.      */
if|if
condition|(
operator|*
operator|(
name|iPtr
operator|->
name|result
operator|)
operator|==
literal|0
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|TclGetStringFromObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
name|dsPtr
operator|->
name|length
operator|=
name|strlen
argument_list|(
name|iPtr
operator|->
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|iPtr
operator|->
name|freeProc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|iPtr
operator|->
name|freeProc
operator|==
name|TCL_DYNAMIC
operator|)
operator|||
operator|(
name|iPtr
operator|->
name|freeProc
operator|==
operator|(
name|Tcl_FreeProc
operator|*
operator|)
name|free
operator|)
condition|)
block|{
name|dsPtr
operator|->
name|string
operator|=
name|iPtr
operator|->
name|result
expr_stmt|;
name|dsPtr
operator|->
name|spaceAvl
operator|=
name|dsPtr
operator|->
name|length
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dsPtr
operator|->
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|dsPtr
operator|->
name|length
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dsPtr
operator|->
name|string
argument_list|,
name|iPtr
operator|->
name|result
argument_list|)
expr_stmt|;
call|(
modifier|*
name|iPtr
operator|->
name|freeProc
call|)
argument_list|(
name|iPtr
operator|->
name|result
argument_list|)
expr_stmt|;
block|}
name|dsPtr
operator|->
name|spaceAvl
operator|=
name|dsPtr
operator|->
name|length
operator|+
literal|1
expr_stmt|;
name|iPtr
operator|->
name|freeProc
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dsPtr
operator|->
name|length
operator|<
name|TCL_DSTRING_STATIC_SIZE
condition|)
block|{
name|dsPtr
operator|->
name|string
operator|=
name|dsPtr
operator|->
name|staticSpace
expr_stmt|;
name|dsPtr
operator|->
name|spaceAvl
operator|=
name|TCL_DSTRING_STATIC_SIZE
expr_stmt|;
block|}
else|else
block|{
name|dsPtr
operator|->
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|dsPtr
operator|->
name|length
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|dsPtr
operator|->
name|spaceAvl
operator|=
name|dsPtr
operator|->
name|length
operator|+
literal|1
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|dsPtr
operator|->
name|string
argument_list|,
name|iPtr
operator|->
name|result
argument_list|)
expr_stmt|;
block|}
name|iPtr
operator|->
name|result
operator|=
name|iPtr
operator|->
name|resultSpace
expr_stmt|;
name|iPtr
operator|->
name|resultSpace
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DStringStartSublist --  *  *	This procedure adds the necessary information to a dynamic  *	string (e.g. " {" to start a sublist.  Future element  *	appends will be in the sublist rather than the main list.  *  * Results:  *	None.  *  * Side effects:  *	Characters get added to the dynamic string.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DStringStartSublist
parameter_list|(
name|dsPtr
parameter_list|)
name|Tcl_DString
modifier|*
name|dsPtr
decl_stmt|;
comment|/* Dynamic string. */
block|{
if|if
condition|(
name|TclNeedSpace
argument_list|(
name|dsPtr
operator|->
name|string
argument_list|,
name|dsPtr
operator|->
name|string
operator|+
name|dsPtr
operator|->
name|length
argument_list|)
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
name|dsPtr
argument_list|,
literal|" {"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_DStringAppend
argument_list|(
name|dsPtr
argument_list|,
literal|"{"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DStringEndSublist --  *  *	This procedure adds the necessary characters to a dynamic  *	string to end a sublist (e.g. "}").  Future element appends  *	will be in the enclosing (sub)list rather than the current  *	sublist.  *  * Results:  *	None.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DStringEndSublist
parameter_list|(
name|dsPtr
parameter_list|)
name|Tcl_DString
modifier|*
name|dsPtr
decl_stmt|;
comment|/* Dynamic string. */
block|{
name|Tcl_DStringAppend
argument_list|(
name|dsPtr
argument_list|,
literal|"}"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_PrintDouble --  *  *	Given a floating-point value, this procedure converts it to  *	an ASCII string using.  *  * Results:  *	The ASCII equivalent of "value" is written at "dst".  It is  *	written using the current precision, and it is guaranteed to  *	contain a decimal point or exponent, so that it looks like  *	a floating-point value and not an integer.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_PrintDouble
parameter_list|(
name|interp
parameter_list|,
name|value
parameter_list|,
name|dst
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter whose tcl_precision 					 * variable used to be used to control 					 * printing.  It's ignored now. */
name|double
name|value
decl_stmt|;
comment|/* Value to print as string. */
name|char
modifier|*
name|dst
decl_stmt|;
comment|/* Where to store converted value; 					 * must have at least TCL_DOUBLE_SPACE 					 * characters. */
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|sprintf
argument_list|(
name|dst
argument_list|,
name|precisionFormat
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/*      * If the ASCII result looks like an integer, add ".0" so that it      * doesn't look like an integer anymore.  This prevents floating-point      * values from being converted to integers unintentionally.      */
for|for
control|(
name|p
operator|=
name|dst
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'.'
operator|)
operator|||
operator|(
name|isalpha
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|)
condition|)
block|{
return|return;
block|}
block|}
name|p
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|'0'
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclPrecTraceProc --  *  *	This procedure is invoked whenever the variable "tcl_precision"  *	is written.  *  * Results:  *	Returns NULL if all went well, or an error message if the  *	new value for the variable doesn't make sense.  *  * Side effects:  *	If the new value doesn't make sense then this procedure  *	undoes the effect of the variable modification.  Otherwise  *	it modifies the format string that's used by Tcl_PrintDouble.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|char
modifier|*
name|TclPrecTraceProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|name1
parameter_list|,
name|name2
parameter_list|,
name|flags
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter containing variable. */
name|char
modifier|*
name|name1
decl_stmt|;
comment|/* Name of variable. */
name|char
modifier|*
name|name2
decl_stmt|;
comment|/* Second part of variable name. */
name|int
name|flags
decl_stmt|;
comment|/* Information about what happened. */
block|{
name|char
modifier|*
name|value
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|prec
decl_stmt|;
comment|/*      * If the variable is unset, then recreate the trace.      */
if|if
condition|(
name|flags
operator|&
name|TCL_TRACE_UNSETS
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|TCL_TRACE_DESTROYED
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|TCL_INTERP_DESTROYED
operator|)
condition|)
block|{
name|Tcl_TraceVar2
argument_list|(
name|interp
argument_list|,
name|name1
argument_list|,
name|name2
argument_list|,
name|TCL_GLOBAL_ONLY
operator||
name|TCL_TRACE_READS
operator||
name|TCL_TRACE_WRITES
operator||
name|TCL_TRACE_UNSETS
argument_list|,
name|TclPrecTraceProc
argument_list|,
name|clientData
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
block|}
comment|/*      * When the variable is read, reset its value from our shared      * value.  This is needed in case the variable was modified in      * some other interpreter so that this interpreter's value is      * out of date.      */
if|if
condition|(
name|flags
operator|&
name|TCL_TRACE_READS
condition|)
block|{
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
name|name1
argument_list|,
name|name2
argument_list|,
name|precisionString
argument_list|,
name|flags
operator|&
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
block|}
comment|/*      * The variable is being written.  Check the new value and disallow      * it if it isn't reasonable or if this is a safe interpreter (we      * don't want safe interpreters messing up the precision of other      * interpreters).      */
if|if
condition|(
name|Tcl_IsSafe
argument_list|(
name|interp
argument_list|)
condition|)
block|{
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
name|name1
argument_list|,
name|name2
argument_list|,
name|precisionString
argument_list|,
name|flags
operator|&
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
return|return
literal|"can't modify precision from a safe interpreter"
return|;
block|}
name|value
operator|=
name|Tcl_GetVar2
argument_list|(
name|interp
argument_list|,
name|name1
argument_list|,
name|name2
argument_list|,
name|flags
operator|&
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
name|value
operator|=
literal|""
expr_stmt|;
block|}
name|prec
operator|=
name|strtoul
argument_list|(
name|value
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prec
operator|<=
literal|0
operator|)
operator|||
operator|(
name|prec
operator|>
name|TCL_MAX_PREC
operator|)
operator|||
operator|(
name|prec
operator|>
literal|100
operator|)
operator|||
operator|(
name|end
operator|==
name|value
operator|)
operator|||
operator|(
operator|*
name|end
operator|!=
literal|0
operator|)
condition|)
block|{
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
name|name1
argument_list|,
name|name2
argument_list|,
name|precisionString
argument_list|,
name|flags
operator|&
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
return|return
literal|"improper value for precision"
return|;
block|}
name|TclFormatInt
argument_list|(
name|precisionString
argument_list|,
name|prec
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|precisionFormat
argument_list|,
literal|"%%.%dg"
argument_list|,
name|prec
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclNeedSpace --  *  *	This procedure checks to see whether it is appropriate to  *	add a space before appending a new list element to an  *	existing string.  *  * Results:  *	The return value is 1 if a space is appropriate, 0 otherwise.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclNeedSpace
parameter_list|(
name|start
parameter_list|,
name|end
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
comment|/* First character in string. */
name|char
modifier|*
name|end
decl_stmt|;
comment|/* End of string (place where space will 				 * be added, if appropriate). */
block|{
comment|/*      * A space is needed unless either      * (a) we're at the start of the string, or      * (b) the trailing characters of the string consist of one or more      *     open curly braces preceded by a space or extending back to      *     the beginning of the string.      * (c) the trailing characters of the string consist of a space      *	   preceded by a character other than backslash.      */
if|if
condition|(
name|end
operator|==
name|start
condition|)
block|{
return|return
literal|0
return|;
block|}
name|end
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|!=
literal|'{'
condition|)
block|{
if|if
condition|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|end
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|end
operator|==
name|start
operator|)
operator|||
operator|(
name|end
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\\'
operator|)
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
do|do
block|{
if|if
condition|(
name|end
operator|==
name|start
condition|)
block|{
return|return
literal|0
return|;
block|}
name|end
operator|--
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|end
operator|==
literal|'{'
condition|)
do|;
if|if
condition|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|end
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclFormatInt --  *  *	This procedure formats an integer into a sequence of decimal digit  *	characters in a buffer. If the integer is negative, a minus sign is  *	inserted at the start of the buffer. A null character is inserted at  *	the end of the formatted characters. It is the caller's  *	responsibility to ensure that enough storage is available. This  *	procedure has the effect of sprintf(buffer, "%d", n) but is faster.  *  * Results:  *	An integer representing the number of characters formatted, not  *	including the terminating \0.  *  * Side effects:  *	The formatted characters are written into the storage pointer to  *	by the "buffer" argument.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclFormatInt
parameter_list|(
name|buffer
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* Points to the storage into which the 				 * formatted characters are written. */
name|long
name|n
decl_stmt|;
comment|/* The integer to format. */
block|{
name|long
name|intVal
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|numFormatted
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|digits
init|=
literal|"0123456789"
decl_stmt|;
comment|/*      * Check first whether "n" is the maximum negative value. This is      * -2^(m-1) for an m-bit word, and has no positive equivalent;      * negating it produces the same value.      */
if|if
condition|(
name|n
operator|==
operator|-
name|n
condition|)
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%ld"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|strlen
argument_list|(
name|buffer
argument_list|)
return|;
block|}
comment|/*      * Generate the characters of the result backwards in the buffer.      */
name|intVal
operator|=
operator|(
name|n
operator|<
literal|0
condition|?
operator|-
name|n
else|:
name|n
operator|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
do|do
block|{
name|i
operator|++
expr_stmt|;
name|buffer
index|[
name|i
index|]
operator|=
name|digits
index|[
name|intVal
operator|%
literal|10
index|]
expr_stmt|;
name|intVal
operator|=
name|intVal
operator|/
literal|10
expr_stmt|;
block|}
do|while
condition|(
name|intVal
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|buffer
index|[
name|i
index|]
operator|=
literal|'-'
expr_stmt|;
block|}
name|numFormatted
operator|=
name|i
expr_stmt|;
comment|/*      * Now reverse the characters.      */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
operator|,
name|i
operator|--
control|)
block|{
name|char
name|tmp
init|=
name|buffer
index|[
name|i
index|]
decl_stmt|;
name|buffer
index|[
name|i
index|]
operator|=
name|buffer
index|[
name|j
index|]
expr_stmt|;
name|buffer
index|[
name|j
index|]
operator|=
name|tmp
expr_stmt|;
block|}
return|return
name|numFormatted
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclLooksLikeInt --  *  *	This procedure decides whether the leading characters of a  *	string look like an integer or something else (such as a  *	floating-point number or string).  *  * Results:  *	The return value is 1 if the leading characters of p look  *	like a valid Tcl integer.  If they look like a floating-point  *	number (e.g. "e01" or "2.4"), or if they don't look like a  *	number at all, then 0 is returned.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclLooksLikeInt
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Pointer to string. */
block|{
while|while
condition|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'+'
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'-'
operator|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|p
operator|!=
literal|'.'
operator|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|'e'
operator|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|'E'
operator|)
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclGetIntForIndex --  *  *	This procedure returns an integer corresponding to the list index  *	held in a Tcl object. The Tcl object's value is expected to be  *	either an integer or the string "end".   *  * Results:  *	The return value is normally TCL_OK, which means that the index was  *	successfully stored into the location referenced by "indexPtr".  If  *	the Tcl object referenced by "objPtr" has the value "end", the  *	value stored is "endValue". If "objPtr"s values is not "end" and  *	can not be converted to an integer, TCL_ERROR is returned and, if  *	"interp" is non-NULL, an error message is left in the interpreter's  *	result object.  *  * Side effects:  *	The object referenced by "objPtr" might be converted to an  *	integer object.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclGetIntForIndex
parameter_list|(
name|interp
parameter_list|,
name|objPtr
parameter_list|,
name|endValue
parameter_list|,
name|indexPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for error reporting.  				 * If NULL, then no error message is left 				 * after errors. */
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Points to an object containing either 				 * "end" or an integer. */
name|int
name|endValue
decl_stmt|;
comment|/* The value to be stored at "indexPtr" if 				 * "objPtr" holds "end". */
name|int
modifier|*
name|indexPtr
decl_stmt|;
comment|/* Location filled in with an integer 				 * representing an index. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|char
modifier|*
name|bytes
decl_stmt|;
name|int
name|index
decl_stmt|,
name|length
decl_stmt|,
name|result
decl_stmt|;
comment|/*      * THIS FAILS IF THE INDEX OBJECT'S STRING REP CONTAINS NULLS.      */
if|if
condition|(
name|objPtr
operator|->
name|typePtr
operator|==
operator|&
name|tclIntType
condition|)
block|{
operator|*
name|indexPtr
operator|=
operator|(
name|int
operator|)
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
name|bytes
operator|=
name|TclGetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|bytes
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|bytes
argument_list|,
literal|"end"
argument_list|,
operator|(
name|unsigned
operator|)
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|index
operator|=
name|endValue
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|Tcl_GetIntFromObj
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|objPtr
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|iPtr
operator|!=
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"bad index \""
argument_list|,
name|bytes
argument_list|,
literal|"\": must be integer or \"end\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
operator|*
name|indexPtr
operator|=
name|index
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

end_unit

