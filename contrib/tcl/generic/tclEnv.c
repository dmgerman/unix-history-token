begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclEnv.c --  *  *	Tcl support for environment variables, including a setenv  *	procedure.  *  * Copyright (c) 1991-1994 The Regents of the University of California.  * Copyright (c) 1994-1996 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclEnv.c 1.37 96/07/23 16:28:26  */
end_comment

begin_comment
comment|/*  * The putenv and setenv definitions below cause any system prototypes for  * those procedures to be ignored so that there won't be a clash when the  * versions in this file are compiled.  */
end_comment

begin_define
define|#
directive|define
name|putenv
value|ignore_putenv
end_define

begin_define
define|#
directive|define
name|setenv
value|ignore_setenv
end_define

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_undef
undef|#
directive|undef
name|putenv
end_undef

begin_undef
undef|#
directive|undef
name|setenv
end_undef

begin_comment
comment|/*  * The structure below is used to keep track of all of the interpereters  * for which we're managing the "env" array.  It's needed so that they  * can all be updated whenever an environment variable is changed  * anywhere.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|EnvInterp
block|{
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter for which we're managing 				 * the env array. */
name|struct
name|EnvInterp
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next in list of all such interpreters, 				 * or zero. */
block|}
name|EnvInterp
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|EnvInterp
modifier|*
name|firstInterpPtr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First in list of all managed interpreters, 				 * or NULL if none. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|environSize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that the all of the 				 * environ-related information is malloc-ed 				 * and the environ array itself has this 				 * many total entries allocated to it (not 				 * all may be in use at once).  Zero means 				 * that the environment array is in its 				 * original static state. */
end_comment

begin_comment
comment|/*  * Declarations for local procedures defined in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|EnvExitProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|EnvInit
name|_ANSI_ARGS_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|EnvTraceProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|,
name|char
operator|*
name|name1
operator|,
name|char
operator|*
name|name2
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|FindVariable
name|_ANSI_ARGS_
argument_list|(
operator|(
name|CONST
name|char
operator|*
name|name
operator|,
name|int
operator|*
name|lengthPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|TclSetEnv
name|_ANSI_ARGS_
argument_list|(
operator|(
name|CONST
name|char
operator|*
name|name
operator|,
name|CONST
name|char
operator|*
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|TclUnsetEnv
name|_ANSI_ARGS_
argument_list|(
operator|(
name|CONST
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclSetupEnv --  *  *	This procedure is invoked for an interpreter to make environment  *	variables accessible from that interpreter via the "env"  *	associative array.  *  * Results:  *	None.  *  * Side effects:  *	The interpreter is added to a list of interpreters managed  *	by us, so that its view of envariables can be kept consistent  *	with the view in other interpreters.  If this is the first  *	call to Tcl_SetupEnv, then additional initialization happens,  *	such as copying the environment to dynamically-allocated space  *	for ease of management.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclSetupEnv
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter whose "env" array is to be 				 * managed. */
block|{
name|EnvInterp
modifier|*
name|eiPtr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*      * First, initialize our environment-related information, if      * necessary.      */
if|if
condition|(
name|environSize
operator|==
literal|0
condition|)
block|{
name|EnvInit
argument_list|()
expr_stmt|;
block|}
comment|/*      * Next, add the interpreter to the list of those that we manage.      */
name|eiPtr
operator|=
operator|(
name|EnvInterp
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|EnvInterp
argument_list|)
argument_list|)
expr_stmt|;
name|eiPtr
operator|->
name|interp
operator|=
name|interp
expr_stmt|;
name|eiPtr
operator|->
name|nextPtr
operator|=
name|firstInterpPtr
expr_stmt|;
name|firstInterpPtr
operator|=
name|eiPtr
expr_stmt|;
comment|/*      * Store the environment variable values into the interpreter's      * "env" array, and arrange for us to be notified on future      * writes and unsets to that array.      */
operator|(
name|void
operator|)
name|Tcl_UnsetVar2
argument_list|(
name|interp
argument_list|,
literal|"env"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|p
operator|=
name|environ
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
for|for
control|(
name|p2
operator|=
name|p
init|;
operator|*
name|p2
operator|!=
literal|'='
condition|;
name|p2
operator|++
control|)
block|{
comment|/* Empty loop body. */
block|}
operator|*
name|p2
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|Tcl_SetVar2
argument_list|(
name|interp
argument_list|,
literal|"env"
argument_list|,
name|p
argument_list|,
name|p2
operator|+
literal|1
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
operator|*
name|p2
operator|=
literal|'='
expr_stmt|;
block|}
name|Tcl_TraceVar2
argument_list|(
name|interp
argument_list|,
literal|"env"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TCL_GLOBAL_ONLY
operator||
name|TCL_TRACE_WRITES
operator||
name|TCL_TRACE_UNSETS
argument_list|,
name|EnvTraceProc
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FindVariable --  *  *	Locate the entry in environ for a given name.  *  * Results:  *	The return value is the index in environ of an entry with the  *	name "name", or -1 if there is no such entry.   The integer at  *	*lengthPtr is filled in with the length of name (if a matching  *	entry is found) or the length of the environ array (if no matching  *	entry is found).  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|FindVariable
parameter_list|(
name|name
parameter_list|,
name|lengthPtr
parameter_list|)
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of desired environment variable. */
name|int
modifier|*
name|lengthPtr
decl_stmt|;
comment|/* Used to return length of name (for 				 * successful searches) or number of non-NULL 				 * entries in environ (for unsuccessful 				 * searches). */
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|CONST
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p1
operator|=
name|environ
index|[
name|i
index|]
init|;
name|p1
operator|!=
name|NULL
condition|;
name|i
operator|++
operator|,
name|p1
operator|=
name|environ
index|[
name|i
index|]
control|)
block|{
for|for
control|(
name|p2
operator|=
name|name
init|;
operator|*
name|p2
operator|==
operator|*
name|p1
condition|;
name|p1
operator|++
operator|,
name|p2
operator|++
control|)
block|{
comment|/* NULL loop body. */
block|}
if|if
condition|(
operator|(
operator|*
name|p1
operator|==
literal|'='
operator|)
operator|&&
operator|(
operator|*
name|p2
operator|==
literal|'\0'
operator|)
condition|)
block|{
operator|*
name|lengthPtr
operator|=
name|p2
operator|-
name|name
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
operator|*
name|lengthPtr
operator|=
name|i
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclGetEnv --  *  *	Get an environment variable or return NULL if the variable  *	doesn't exist.  This procedure is intended to be a  *	stand-in for the  UNIX "getenv" procedure so that applications  *	using that procedure will interface properly to Tcl.  To make  *	it a stand-in, the Makefile must define "TclGetEnv" to "getenv".  *  * Results:  *	ptr to value on success, NULL if error.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|TclGetEnv
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of desired environment variable. */
block|{
name|int
name|i
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|nameLen
decl_stmt|;
name|char
modifier|*
name|equal
decl_stmt|;
name|nameLen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|environ
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|equal
operator|=
name|strchr
argument_list|(
name|environ
index|[
name|i
index|]
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|equal
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
name|len
operator|=
call|(
name|size_t
call|)
argument_list|(
name|equal
operator|-
name|environ
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
name|nameLen
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|environ
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 	     * The caller of this function should regard this 	     * as static memory. 	     */
return|return
operator|&
name|environ
index|[
name|i
index|]
index|[
name|len
operator|+
literal|1
index|]
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclSetEnv --  *  *	Set an environment variable, replacing an existing value  *	or creating a new variable if there doesn't exist a variable  *	by the given name.  This procedure is intended to be a  *	stand-in for the  UNIX "setenv" procedure so that applications  *	using that procedure will interface properly to Tcl.  To make  *	it a stand-in, the Makefile must define "TclSetEnv" to "setenv".  *  * Results:  *	None.  *  * Side effects:  *	The environ array gets updated, as do all of the interpreters  *	that we manage.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclSetEnv
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|)
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of variable whose value is to be 				 * set. */
name|CONST
name|char
modifier|*
name|value
decl_stmt|;
comment|/* New value for variable. */
block|{
name|int
name|index
decl_stmt|,
name|length
decl_stmt|,
name|nameLength
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|EnvInterp
modifier|*
name|eiPtr
decl_stmt|;
if|if
condition|(
name|environSize
operator|==
literal|0
condition|)
block|{
name|EnvInit
argument_list|()
expr_stmt|;
block|}
comment|/*      * Figure out where the entry is going to go.  If the name doesn't      * already exist, enlarge the array if necessary to make room.  If      * the name exists, free its old entry.      */
name|index
operator|=
name|FindVariable
argument_list|(
name|name
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|length
operator|+
literal|2
operator|)
operator|>
name|environSize
condition|)
block|{
name|char
modifier|*
modifier|*
name|newEnviron
decl_stmt|;
name|newEnviron
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|length
operator|+
literal|5
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|newEnviron
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|environ
argument_list|,
name|length
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|environ
argument_list|)
expr_stmt|;
name|environ
operator|=
name|newEnviron
expr_stmt|;
name|environSize
operator|=
name|length
operator|+
literal|5
expr_stmt|;
block|}
name|index
operator|=
name|length
expr_stmt|;
name|environ
index|[
name|index
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|nameLength
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * Compare the new value to the existing value.  If they're 	 * the same then quit immediately (e.g. don't rewrite the 	 * value or propagate it to other interpreters).  Otherwise, 	 * when there are N interpreters there will be N! propagations 	 * of the same value among the interpreters. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
name|environ
index|[
name|index
index|]
operator|+
name|length
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|ckfree
argument_list|(
name|environ
index|[
name|index
index|]
argument_list|)
expr_stmt|;
name|nameLength
operator|=
name|length
expr_stmt|;
block|}
comment|/*      * Create a new entry and enter it into the table.      */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|nameLength
operator|+
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|environ
index|[
name|index
index|]
operator|=
name|p
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|p
operator|+=
name|nameLength
expr_stmt|;
operator|*
name|p
operator|=
literal|'='
expr_stmt|;
name|strcpy
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/*      * Update all of the interpreters.      */
for|for
control|(
name|eiPtr
operator|=
name|firstInterpPtr
init|;
name|eiPtr
operator|!=
name|NULL
condition|;
name|eiPtr
operator|=
name|eiPtr
operator|->
name|nextPtr
control|)
block|{
operator|(
name|void
operator|)
name|Tcl_SetVar2
argument_list|(
name|eiPtr
operator|->
name|interp
argument_list|,
literal|"env"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|name
argument_list|,
name|p
operator|+
literal|1
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
block|}
comment|/*      * Update the system environment.      */
name|TclSetSystemEnv
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_PutEnv --  *  *	Set an environment variable.  Similar to setenv except that  *	the information is passed in a single string of the form  *	NAME=value, rather than as separate name strings.  This procedure  *	is intended to be a stand-in for the  UNIX "putenv" procedure  *	so that applications using that procedure will interface  *	properly to Tcl.  To make it a stand-in, the Makefile will  *	define "Tcl_PutEnv" to "putenv".  *  * Results:  *	None.  *  * Side effects:  *	The environ array gets updated, as do all of the interpreters  *	that we manage.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_PutEnv
parameter_list|(
name|string
parameter_list|)
name|CONST
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Info about environment variable in the 				 * form NAME=value. */
block|{
name|int
name|nameLength
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|value
decl_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/*      * Separate the string into name and value parts, then call      * TclSetEnv to do all of the real work.      */
name|value
operator|=
name|strchr
argument_list|(
name|string
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
name|nameLength
operator|=
name|value
operator|-
name|string
expr_stmt|;
if|if
condition|(
name|nameLength
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|nameLength
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|string
argument_list|,
operator|(
name|size_t
operator|)
name|nameLength
argument_list|)
expr_stmt|;
name|name
index|[
name|nameLength
index|]
operator|=
literal|0
expr_stmt|;
name|TclSetEnv
argument_list|(
name|name
argument_list|,
name|value
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclUnsetEnv --  *  *	Remove an environment variable, updating the "env" arrays  *	in all interpreters managed by us.  This function is intended  *	to replace the UNIX "unsetenv" function (but to do this the  *	Makefile must be modified to redefine "TclUnsetEnv" to  *	"unsetenv".  *  * Results:  *	None.  *  * Side effects:  *	Interpreters are updated, as is environ.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|TclUnsetEnv
parameter_list|(
name|name
parameter_list|)
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of variable to remove. */
block|{
name|int
name|index
decl_stmt|,
name|dummy
decl_stmt|;
name|char
modifier|*
modifier|*
name|envPtr
decl_stmt|;
name|EnvInterp
modifier|*
name|eiPtr
decl_stmt|;
if|if
condition|(
name|environSize
operator|==
literal|0
condition|)
block|{
name|EnvInit
argument_list|()
expr_stmt|;
block|}
comment|/*      * Update the environ array.      */
name|index
operator|=
name|FindVariable
argument_list|(
name|name
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
return|return;
block|}
name|ckfree
argument_list|(
name|environ
index|[
name|index
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|envPtr
operator|=
name|environ
operator|+
name|index
operator|+
literal|1
init|;
condition|;
name|envPtr
operator|++
control|)
block|{
name|envPtr
index|[
operator|-
literal|1
index|]
operator|=
operator|*
name|envPtr
expr_stmt|;
if|if
condition|(
operator|*
name|envPtr
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
block|}
comment|/*      * Update all of the interpreters.      */
for|for
control|(
name|eiPtr
operator|=
name|firstInterpPtr
init|;
name|eiPtr
operator|!=
name|NULL
condition|;
name|eiPtr
operator|=
name|eiPtr
operator|->
name|nextPtr
control|)
block|{
operator|(
name|void
operator|)
name|Tcl_UnsetVar2
argument_list|(
name|eiPtr
operator|->
name|interp
argument_list|,
literal|"env"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|name
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
block|}
comment|/*      * Update the system environment.      */
name|TclSetSystemEnv
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * EnvTraceProc --  *  *	This procedure is invoked whenever an environment variable  *	is modified or deleted.  It propagates the change to the  *	"environ" array and to any other interpreters for whom  *	we're managing an "env" array.  *  * Results:  *	Always returns NULL to indicate success.  *  * Side effects:  *	Environment variable changes get propagated.  If the whole  *	"env" array is deleted, then we stop managing things for  *	this interpreter (usually this happens because the whole  *	interpreter is being deleted).  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|EnvTraceProc
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|name1
parameter_list|,
name|name2
parameter_list|,
name|flags
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter whose "env" variable is 				 * being modified. */
name|char
modifier|*
name|name1
decl_stmt|;
comment|/* Better be "env". */
name|char
modifier|*
name|name2
decl_stmt|;
comment|/* Name of variable being modified, or 				 * NULL if whole array is being deleted. */
name|int
name|flags
decl_stmt|;
comment|/* Indicates what's happening. */
block|{
comment|/*      * First see if the whole "env" variable is being deleted.  If      * so, just forget about this interpreter.      */
if|if
condition|(
name|name2
operator|==
name|NULL
condition|)
block|{
specifier|register
name|EnvInterp
modifier|*
name|eiPtr
decl_stmt|,
modifier|*
name|prevPtr
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|TCL_TRACE_UNSETS
operator||
name|TCL_TRACE_DESTROYED
operator|)
operator|)
operator|!=
operator|(
name|TCL_TRACE_UNSETS
operator||
name|TCL_TRACE_DESTROYED
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"EnvTraceProc called with confusing arguments"
argument_list|)
expr_stmt|;
block|}
name|eiPtr
operator|=
name|firstInterpPtr
expr_stmt|;
if|if
condition|(
name|eiPtr
operator|->
name|interp
operator|==
name|interp
condition|)
block|{
name|firstInterpPtr
operator|=
name|eiPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|prevPtr
operator|=
name|eiPtr
operator|,
name|eiPtr
operator|=
name|eiPtr
operator|->
name|nextPtr
init|;
condition|;
name|prevPtr
operator|=
name|eiPtr
operator|,
name|eiPtr
operator|=
name|eiPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
name|eiPtr
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"EnvTraceProc couldn't find interpreter"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eiPtr
operator|->
name|interp
operator|==
name|interp
condition|)
block|{
name|prevPtr
operator|->
name|nextPtr
operator|=
name|eiPtr
operator|->
name|nextPtr
expr_stmt|;
break|break;
block|}
block|}
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|eiPtr
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*      * If a value is being set, call TclSetEnv to do all of the work.      */
if|if
condition|(
name|flags
operator|&
name|TCL_TRACE_WRITES
condition|)
block|{
name|TclSetEnv
argument_list|(
name|name2
argument_list|,
name|Tcl_GetVar2
argument_list|(
name|interp
argument_list|,
literal|"env"
argument_list|,
name|name2
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|TCL_TRACE_UNSETS
condition|)
block|{
name|TclUnsetEnv
argument_list|(
name|name2
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * EnvInit --  *  *	This procedure is called to initialize our management  *	of the environ array.  *  * Results:  *	None.  *  * Side effects:  *	Environ gets copied to malloc-ed storage, so that in  *	the future we don't have to worry about which entries  *	are malloc-ed and which are static.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|EnvInit
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|MAC_TCL
name|environSize
operator|=
name|TclMacCreateEnv
argument_list|()
expr_stmt|;
else|#
directive|else
name|char
modifier|*
modifier|*
name|newEnviron
decl_stmt|;
name|int
name|i
decl_stmt|,
name|length
decl_stmt|;
if|if
condition|(
name|environSize
operator|!=
literal|0
condition|)
block|{
return|return;
block|}
for|for
control|(
name|length
operator|=
literal|0
init|;
name|environ
index|[
name|length
index|]
operator|!=
name|NULL
condition|;
name|length
operator|++
control|)
block|{
comment|/* Empty loop body. */
block|}
name|environSize
operator|=
name|length
operator|+
literal|5
expr_stmt|;
name|newEnviron
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|environSize
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|newEnviron
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|environ
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newEnviron
index|[
name|i
index|]
argument_list|,
name|environ
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|newEnviron
index|[
name|length
index|]
operator|=
name|NULL
expr_stmt|;
name|environ
operator|=
name|newEnviron
expr_stmt|;
name|Tcl_CreateExitHandler
argument_list|(
name|EnvExitProc
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * EnvExitProc --  *  *	This procedure is called just before the process exits.  It  *	frees the memory associated with environment variables.  *  * Results:  *	None.  *  * Side effects:  *	Memory is freed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|EnvExitProc
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not  used. */
block|{
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|environ
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
block|{
name|ckfree
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|environ
argument_list|)
expr_stmt|;
comment|/*      * Note that we need to reset the environ global so the Borland C run-time      * doesn't choke on exit.      */
name|environ
operator|=
name|NULL
expr_stmt|;
block|}
end_function

end_unit

