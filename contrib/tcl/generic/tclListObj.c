begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclListObj.c --  *  *	This file contains procedures that implement the Tcl list object  *	type.  *  * Copyright (c) 1995-1997 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclListObj.c 1.47 97/08/12 19:02:02  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_comment
comment|/*  * Prototypes for procedures defined later in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DupListInternalRep
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Obj
operator|*
name|srcPtr
operator|,
name|Tcl_Obj
operator|*
name|copyPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|FreeListInternalRep
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Obj
operator|*
name|listPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SetListFromAny
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Tcl_Obj
operator|*
name|objPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|UpdateStringOfList
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Obj
operator|*
name|listPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The structure below defines the list Tcl object type by means of  * procedures that can be invoked by generic object code.  */
end_comment

begin_decl_stmt
name|Tcl_ObjType
name|tclListType
init|=
block|{
literal|"list"
block|,
comment|/* name */
name|FreeListInternalRep
block|,
comment|/* freeIntRepProc */
name|DupListInternalRep
block|,
comment|/* dupIntRepProc */
name|UpdateStringOfList
block|,
comment|/* updateStringProc */
name|SetListFromAny
comment|/* setFromAnyProc */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_NewListObj --  *  *	This procedure is normally called when not debugging: i.e., when  *	TCL_MEM_DEBUG is not defined. It creates a new list object from an  *	(objc,objv) array: that is, each of the objc elements of the array  *	referenced by objv is inserted as an element into a new Tcl object.  *  *	When TCL_MEM_DEBUG is defined, this procedure just returns the  *	result of calling the debugging version Tcl_DbNewListObj.  *  * Results:  *	A new list object is returned that is initialized from the object  *	pointers in objv. If objc is less than or equal to zero, an empty  *	object is returned. The new object's string representation  *	is left NULL. The resulting new list object has ref count 0.  *  * Side effects:  *	The ref counts of the elements in objv are incremented since the  *	resulting list now refers to them.  *  *----------------------------------------------------------------------  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
end_ifdef

begin_undef
undef|#
directive|undef
name|Tcl_NewListObj
end_undef

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_NewListObj
parameter_list|(
name|objc
parameter_list|,
name|objv
parameter_list|)
name|int
name|objc
decl_stmt|;
comment|/* Count of objects referenced by objv. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* An array of pointers to Tcl objects. */
block|{
return|return
name|Tcl_DbNewListObj
argument_list|(
name|objc
argument_list|,
name|objv
argument_list|,
literal|"unknown"
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* if not TCL_MEM_DEBUG */
end_comment

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_NewListObj
parameter_list|(
name|objc
parameter_list|,
name|objv
parameter_list|)
name|int
name|objc
decl_stmt|;
comment|/* Count of objects referenced by objv. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* An array of pointers to Tcl objects. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|listPtr
decl_stmt|;
specifier|register
name|Tcl_Obj
modifier|*
modifier|*
name|elemPtrs
decl_stmt|;
specifier|register
name|List
modifier|*
name|listRepPtr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|TclNewObj
argument_list|(
name|listPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|objc
operator|>
literal|0
condition|)
block|{
name|Tcl_InvalidateStringRep
argument_list|(
name|listPtr
argument_list|)
expr_stmt|;
name|elemPtrs
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|objc
operator|*
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|elemPtrs
index|[
name|i
index|]
operator|=
name|objv
index|[
name|i
index|]
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|elemPtrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|listRepPtr
operator|=
operator|(
name|List
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|List
argument_list|)
argument_list|)
expr_stmt|;
name|listRepPtr
operator|->
name|maxElemCount
operator|=
name|objc
expr_stmt|;
name|listRepPtr
operator|->
name|elemCount
operator|=
name|objc
expr_stmt|;
name|listRepPtr
operator|->
name|elements
operator|=
name|elemPtrs
expr_stmt|;
name|listPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
operator|=
operator|(
name|VOID
operator|*
operator|)
name|listRepPtr
expr_stmt|;
name|listPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclListType
expr_stmt|;
block|}
return|return
name|listPtr
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* if TCL_MEM_DEBUG */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DbNewListObj --  *  *	This procedure is normally called when debugging: i.e., when  *	TCL_MEM_DEBUG is defined. It creates new list objects. It is the  *	same as the Tcl_NewListObj procedure above except that it calls  *	Tcl_DbCkalloc directly with the file name and line number from its  *	caller. This simplifies debugging since then the checkmem command  *	will report the correct file name and line number when reporting  *	objects that haven't been freed.  *  *	When TCL_MEM_DEBUG is not defined, this procedure just returns the  *	result of calling Tcl_NewListObj.  *  * Results:  *	A new list object is returned that is initialized from the object  *	pointers in objv. If objc is less than or equal to zero, an empty  *	object is returned. The new object's string representation  *	is left NULL. The new list object has ref count 0.  *  * Side effects:  *	The ref counts of the elements in objv are incremented since the  *	resulting list now refers to them.  *  *----------------------------------------------------------------------  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_MEM_DEBUG
end_ifdef

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_DbNewListObj
parameter_list|(
name|objc
parameter_list|,
name|objv
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|int
name|objc
decl_stmt|;
comment|/* Count of objects referenced by objv. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* An array of pointers to Tcl objects. */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* The name of the source file calling this 				 * procedure; used for debugging. */
name|int
name|line
decl_stmt|;
comment|/* Line number in the source file; used 				 * for debugging. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
name|listPtr
decl_stmt|;
specifier|register
name|Tcl_Obj
modifier|*
modifier|*
name|elemPtrs
decl_stmt|;
specifier|register
name|List
modifier|*
name|listRepPtr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|TclDbNewObj
argument_list|(
name|listPtr
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|objc
operator|>
literal|0
condition|)
block|{
name|Tcl_InvalidateStringRep
argument_list|(
name|listPtr
argument_list|)
expr_stmt|;
name|elemPtrs
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|objc
operator|*
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|elemPtrs
index|[
name|i
index|]
operator|=
name|objv
index|[
name|i
index|]
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|elemPtrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|listRepPtr
operator|=
operator|(
name|List
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|List
argument_list|)
argument_list|)
expr_stmt|;
name|listRepPtr
operator|->
name|maxElemCount
operator|=
name|objc
expr_stmt|;
name|listRepPtr
operator|->
name|elemCount
operator|=
name|objc
expr_stmt|;
name|listRepPtr
operator|->
name|elements
operator|=
name|elemPtrs
expr_stmt|;
name|listPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
operator|=
operator|(
name|VOID
operator|*
operator|)
name|listRepPtr
expr_stmt|;
name|listPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclListType
expr_stmt|;
block|}
return|return
name|listPtr
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* if not TCL_MEM_DEBUG */
end_comment

begin_function
name|Tcl_Obj
modifier|*
name|Tcl_DbNewListObj
parameter_list|(
name|objc
parameter_list|,
name|objv
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|int
name|objc
decl_stmt|;
comment|/* Count of objects referenced by objv. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* An array of pointers to Tcl objects. */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* The name of the source file calling this 				 * procedure; used for debugging. */
name|int
name|line
decl_stmt|;
comment|/* Line number in the source file; used 				 * for debugging. */
block|{
return|return
name|Tcl_NewListObj
argument_list|(
name|objc
argument_list|,
name|objv
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_MEM_DEBUG */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetListObj --  *  *	Modify an object to be a list containing each of the objc elements  *	of the object array referenced by objv.  *  * Results:  *	None.  *  * Side effects:  *	The object is made a list object and is initialized from the object  *	pointers in objv. If objc is less than or equal to zero, an empty  *	object is returned. The new object's string representation  *	is left NULL. The ref counts of the elements in objv are incremented  *	since the list now refers to them. The object's old string and  *	internal representations are freed and its type is set NULL.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_SetListObj
parameter_list|(
name|objPtr
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Object whose internal rep to init. */
name|int
name|objc
decl_stmt|;
comment|/* Count of objects referenced by objv. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* An array of pointers to Tcl objects. */
block|{
specifier|register
name|Tcl_Obj
modifier|*
modifier|*
name|elemPtrs
decl_stmt|;
specifier|register
name|List
modifier|*
name|listRepPtr
decl_stmt|;
name|Tcl_ObjType
modifier|*
name|oldTypePtr
init|=
name|objPtr
operator|->
name|typePtr
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|objPtr
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_SetListObj called with shared object"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Free any old string rep and any internal rep for the old type.      */
name|Tcl_InvalidateStringRep
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oldTypePtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|oldTypePtr
operator|->
name|freeIntRepProc
operator|!=
name|NULL
operator|)
condition|)
block|{
name|oldTypePtr
operator|->
name|freeIntRepProc
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*      * Set the object's type to "list" and initialize the internal rep.      */
if|if
condition|(
name|objc
operator|>
literal|0
condition|)
block|{
name|elemPtrs
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|objc
operator|*
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
name|elemPtrs
index|[
name|i
index|]
operator|=
name|objv
index|[
name|i
index|]
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|elemPtrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|listRepPtr
operator|=
operator|(
name|List
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|List
argument_list|)
argument_list|)
expr_stmt|;
name|listRepPtr
operator|->
name|maxElemCount
operator|=
name|objc
expr_stmt|;
name|listRepPtr
operator|->
name|elemCount
operator|=
name|objc
expr_stmt|;
name|listRepPtr
operator|->
name|elements
operator|=
name|elemPtrs
expr_stmt|;
name|objPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
operator|=
operator|(
name|VOID
operator|*
operator|)
name|listRepPtr
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclListType
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ListObjGetElements --  *  *	This procedure returns an (objc,objv) array of the elements in a  *	list object.  *  * Results:  *	The return value is normally TCL_OK; in this case *objcPtr is set to  *	the count of list elements and *objvPtr is set to a pointer to an  *	array of (*objcPtr) pointers to each list element. If listPtr does  *	not refer to a list object and the object can not be converted to  *	one, TCL_ERROR is returned and an error message will be left in  *	the interpreter's result if interp is not NULL.  *  *	The objects referenced by the returned array should be treated as  *	readonly and their ref counts are _not_ incremented; the caller must  *	do that if it holds on to a reference. Furthermore, the pointer  *	and length returned by this procedure may change as soon as any  *	procedure is called on the list object; be careful about retaining  *	the pointer in a local data structure.  *  * Side effects:  *	The possible conversion of the object referenced by listPtr  *	to a list object.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_ListObjGetElements
parameter_list|(
name|interp
parameter_list|,
name|listPtr
parameter_list|,
name|objcPtr
parameter_list|,
name|objvPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used to report errors if not NULL. */
specifier|register
name|Tcl_Obj
modifier|*
name|listPtr
decl_stmt|;
comment|/* List object for which an element array 				 * is to be returned. */
name|int
modifier|*
name|objcPtr
decl_stmt|;
comment|/* Where to store the count of objects 				 * referenced by objv. */
name|Tcl_Obj
modifier|*
modifier|*
modifier|*
name|objvPtr
decl_stmt|;
comment|/* Where to store the pointer to an array 				 * of pointers to the list's objects. */
block|{
specifier|register
name|List
modifier|*
name|listRepPtr
decl_stmt|;
if|if
condition|(
name|listPtr
operator|->
name|typePtr
operator|!=
operator|&
name|tclListType
condition|)
block|{
name|int
name|result
init|=
name|SetListFromAny
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
name|listRepPtr
operator|=
operator|(
name|List
operator|*
operator|)
name|listPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
expr_stmt|;
operator|*
name|objcPtr
operator|=
name|listRepPtr
operator|->
name|elemCount
expr_stmt|;
operator|*
name|objvPtr
operator|=
name|listRepPtr
operator|->
name|elements
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ListObjAppendList --  *  *	This procedure appends the objects in the list referenced by  *	elemListPtr to the list object referenced by listPtr. If listPtr is  *	not already a list object, an attempt will be made to convert it to  *	one.  *  * Results:  *	The return value is normally TCL_OK. If listPtr or elemListPtr do  *	not refer to list objects and they can not be converted to one,  *	TCL_ERROR is returned and an error message is left in  *	the interpreter's result if interp is not NULL.  *  * Side effects:  *	The reference counts of the elements in elemListPtr are incremented  *	since the list now refers to them. listPtr and elemListPtr are  *	converted, if necessary, to list objects. Also, appending the  *	new elements may cause listObj's array of element pointers to grow.  *	listPtr's old string representation, if any, is invalidated.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_ListObjAppendList
parameter_list|(
name|interp
parameter_list|,
name|listPtr
parameter_list|,
name|elemListPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used to report errors if not NULL. */
specifier|register
name|Tcl_Obj
modifier|*
name|listPtr
decl_stmt|;
comment|/* List object to append elements to. */
name|Tcl_Obj
modifier|*
name|elemListPtr
decl_stmt|;
comment|/* List obj with elements to append. */
block|{
specifier|register
name|List
modifier|*
name|listRepPtr
decl_stmt|;
name|int
name|listLen
decl_stmt|,
name|objc
decl_stmt|,
name|result
decl_stmt|;
name|Tcl_Obj
modifier|*
modifier|*
name|objv
decl_stmt|;
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|listPtr
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_ListObjAppendList called with shared object"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|listPtr
operator|->
name|typePtr
operator|!=
operator|&
name|tclListType
condition|)
block|{
name|result
operator|=
name|SetListFromAny
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
name|listRepPtr
operator|=
operator|(
name|List
operator|*
operator|)
name|listPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
expr_stmt|;
name|listLen
operator|=
name|listRepPtr
operator|->
name|elemCount
expr_stmt|;
name|result
operator|=
name|Tcl_ListObjGetElements
argument_list|(
name|interp
argument_list|,
name|elemListPtr
argument_list|,
operator|&
name|objc
argument_list|,
operator|&
name|objv
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
comment|/*      * Insert objc new elements starting after the lists's last element.      * Delete zero existing elements.      */
return|return
name|Tcl_ListObjReplace
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|,
name|listLen
argument_list|,
literal|0
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ListObjAppendElement --  *  *	This procedure is a special purpose version of  *	Tcl_ListObjAppendList: it appends a single object referenced by  *	objPtr to the list object referenced by listPtr. If listPtr is not  *	already a list object, an attempt will be made to convert it to one.  *  * Results:  *	The return value is normally TCL_OK; in this case objPtr is added  *	to the end of listPtr's list. If listPtr does not refer to a list  *	object and the object can not be converted to one, TCL_ERROR is  *	returned and an error message will be left in the interpreter's  *	result if interp is not NULL.  *  * Side effects:  *	The ref count of objPtr is incremented since the list now refers   *	to it. listPtr will be converted, if necessary, to a list object.  *	Also, appending the new element may cause listObj's array of element  *	pointers to grow. listPtr's old string representation, if any,  *	is invalidated.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_ListObjAppendElement
parameter_list|(
name|interp
parameter_list|,
name|listPtr
parameter_list|,
name|objPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used to report errors if not NULL. */
name|Tcl_Obj
modifier|*
name|listPtr
decl_stmt|;
comment|/* List object to append objPtr to. */
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* Object to append to listPtr's list. */
block|{
specifier|register
name|List
modifier|*
name|listRepPtr
decl_stmt|;
specifier|register
name|Tcl_Obj
modifier|*
modifier|*
name|elemPtrs
decl_stmt|;
name|int
name|numElems
decl_stmt|,
name|numRequired
decl_stmt|;
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|listPtr
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_ListObjAppendElement called with shared object"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|listPtr
operator|->
name|typePtr
operator|!=
operator|&
name|tclListType
condition|)
block|{
name|int
name|result
init|=
name|SetListFromAny
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
name|listRepPtr
operator|=
operator|(
name|List
operator|*
operator|)
name|listPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
expr_stmt|;
name|elemPtrs
operator|=
name|listRepPtr
operator|->
name|elements
expr_stmt|;
name|numElems
operator|=
name|listRepPtr
operator|->
name|elemCount
expr_stmt|;
name|numRequired
operator|=
name|numElems
operator|+
literal|1
expr_stmt|;
comment|/*      * If there is no room in the current array of element pointers,      * allocate a new, larger array and copy the pointers to it.      */
if|if
condition|(
name|numRequired
operator|>
name|listRepPtr
operator|->
name|maxElemCount
condition|)
block|{
name|int
name|newMax
init|=
operator|(
literal|2
operator|*
name|numRequired
operator|)
decl_stmt|;
name|Tcl_Obj
modifier|*
modifier|*
name|newElemPtrs
init|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|newMax
operator|*
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|newElemPtrs
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|elemPtrs
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|numElems
operator|*
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|listRepPtr
operator|->
name|maxElemCount
operator|=
name|newMax
expr_stmt|;
name|listRepPtr
operator|->
name|elements
operator|=
name|newElemPtrs
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|elemPtrs
argument_list|)
expr_stmt|;
name|elemPtrs
operator|=
name|newElemPtrs
expr_stmt|;
block|}
comment|/*      * Add objPtr to the end of listPtr's array of element      * pointers. Increment the ref count for the (now shared) objPtr.      */
name|elemPtrs
index|[
name|numElems
index|]
operator|=
name|objPtr
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|listRepPtr
operator|->
name|elemCount
operator|++
expr_stmt|;
comment|/*      * Invalidate any old string representation since the list's internal      * representation has changed.      */
name|Tcl_InvalidateStringRep
argument_list|(
name|listPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ListObjIndex --  *  *	This procedure returns a pointer to the index'th object from the  *	list referenced by listPtr. The first element has index 0. If index  *	is negative or greater than or equal to the number of elements in  *	the list, a NULL is returned. If listPtr is not a list object, an  *	attempt will be made to convert it to a list.  *  * Results:  *	The return value is normally TCL_OK; in this case objPtrPtr is set  *	to the Tcl_Obj pointer for the index'th list element or NULL if  *	index is out of range. This object should be treated as readonly and  *	its ref count is _not_ incremented; the caller must do that if it  *	holds on to the reference. If listPtr does not refer to a list and  *	can't be converted to one, TCL_ERROR is returned and an error  *	message is left in the interpreter's result if interp is not NULL.  *  * Side effects:  *	listPtr will be converted, if necessary, to a list object.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_ListObjIndex
parameter_list|(
name|interp
parameter_list|,
name|listPtr
parameter_list|,
name|index
parameter_list|,
name|objPtrPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used to report errors if not NULL. */
specifier|register
name|Tcl_Obj
modifier|*
name|listPtr
decl_stmt|;
comment|/* List object to index into. */
specifier|register
name|int
name|index
decl_stmt|;
comment|/* Index of element to return. */
name|Tcl_Obj
modifier|*
modifier|*
name|objPtrPtr
decl_stmt|;
comment|/* The resulting Tcl_Obj* is stored here. */
block|{
specifier|register
name|List
modifier|*
name|listRepPtr
decl_stmt|;
if|if
condition|(
name|listPtr
operator|->
name|typePtr
operator|!=
operator|&
name|tclListType
condition|)
block|{
name|int
name|result
init|=
name|SetListFromAny
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
name|listRepPtr
operator|=
operator|(
name|List
operator|*
operator|)
name|listPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
expr_stmt|;
if|if
condition|(
operator|(
name|index
operator|<
literal|0
operator|)
operator|||
operator|(
name|index
operator|>=
name|listRepPtr
operator|->
name|elemCount
operator|)
condition|)
block|{
operator|*
name|objPtrPtr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
operator|*
name|objPtrPtr
operator|=
name|listRepPtr
operator|->
name|elements
index|[
name|index
index|]
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ListObjLength --  *  *	This procedure returns the number of elements in a list object. If  *	the object is not already a list object, an attempt will be made to  *	convert it to one.  *  * Results:  *	The return value is normally TCL_OK; in this case *intPtr will be  *	set to the integer count of list elements. If listPtr does not refer  *	to a list object and the object can not be converted to one,  *	TCL_ERROR is returned and an error message will be left in  *	the interpreter's result if interp is not NULL.  *  * Side effects:  *	The possible conversion of the argument object to a list object.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_ListObjLength
parameter_list|(
name|interp
parameter_list|,
name|listPtr
parameter_list|,
name|intPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used to report errors if not NULL. */
specifier|register
name|Tcl_Obj
modifier|*
name|listPtr
decl_stmt|;
comment|/* List object whose #elements to return. */
specifier|register
name|int
modifier|*
name|intPtr
decl_stmt|;
comment|/* The resulting int is stored here. */
block|{
specifier|register
name|List
modifier|*
name|listRepPtr
decl_stmt|;
if|if
condition|(
name|listPtr
operator|->
name|typePtr
operator|!=
operator|&
name|tclListType
condition|)
block|{
name|int
name|result
init|=
name|SetListFromAny
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
name|listRepPtr
operator|=
operator|(
name|List
operator|*
operator|)
name|listPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
expr_stmt|;
operator|*
name|intPtr
operator|=
name|listRepPtr
operator|->
name|elemCount
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_ListObjReplace --  *   *	This procedure replaces zero or more elements of the list referenced  *	by listPtr with the objects from an (objc,objv) array.   *	The objc elements of the array referenced by objv replace the  *	count elements in listPtr starting at first.  *  *	If the argument first is zero or negative, it refers to the first  *	element. If first is greater than or equal to the number of elements  *	in the list, then no elements are deleted; the new elements are  *	appended to the list. Count gives the number of elements to  *	replace. If count is zero or negative then no elements are deleted;  *	the new elements are simply inserted before first.  *  *	The argument objv refers to an array of objc pointers to the new  *	elements to be added to listPtr in place of those that were  *	deleted. If objv is NULL, no new elements are added. If listPtr is  *	not a list object, an attempt will be made to convert it to one.  *  * Results:  *	The return value is normally TCL_OK. If listPtr does  *	not refer to a list object and can not be converted to one,  *	TCL_ERROR is returned and an error message will be left in  *	the interpreter's result if interp is not NULL.  *  * Side effects:  *	The ref counts of the objc elements in objv are incremented since  *	the resulting list now refers to them. Similarly, the ref counts for  *	replaced objects are decremented. listPtr is converted, if  *	necessary, to a list object. listPtr's old string representation, if  *	any, is freed.   *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_ListObjReplace
parameter_list|(
name|interp
parameter_list|,
name|listPtr
parameter_list|,
name|first
parameter_list|,
name|count
parameter_list|,
name|objc
parameter_list|,
name|objv
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting if not NULL. */
name|Tcl_Obj
modifier|*
name|listPtr
decl_stmt|;
comment|/* List object whose elements to replace. */
name|int
name|first
decl_stmt|;
comment|/* Index of first element to replace. */
name|int
name|count
decl_stmt|;
comment|/* Number of elements to replace. */
name|int
name|objc
decl_stmt|;
comment|/* Number of objects to insert. */
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
decl_stmt|;
comment|/* An array of objc pointers to Tcl objects 				 * to insert. */
block|{
name|List
modifier|*
name|listRepPtr
decl_stmt|;
specifier|register
name|Tcl_Obj
modifier|*
modifier|*
name|elemPtrs
decl_stmt|,
modifier|*
modifier|*
name|newPtrs
decl_stmt|;
name|Tcl_Obj
modifier|*
name|victimPtr
decl_stmt|;
name|int
name|numElems
decl_stmt|,
name|numRequired
decl_stmt|,
name|numAfterLast
decl_stmt|;
name|int
name|start
decl_stmt|,
name|shift
decl_stmt|,
name|newMax
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|Tcl_IsShared
argument_list|(
name|listPtr
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_ListObjReplace called with shared object"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|listPtr
operator|->
name|typePtr
operator|!=
operator|&
name|tclListType
condition|)
block|{
name|result
operator|=
name|SetListFromAny
argument_list|(
name|interp
argument_list|,
name|listPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
name|listRepPtr
operator|=
operator|(
name|List
operator|*
operator|)
name|listPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
expr_stmt|;
name|elemPtrs
operator|=
name|listRepPtr
operator|->
name|elements
expr_stmt|;
name|numElems
operator|=
name|listRepPtr
operator|->
name|elemCount
expr_stmt|;
if|if
condition|(
name|first
operator|<
literal|0
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|first
operator|>=
name|numElems
condition|)
block|{
name|first
operator|=
name|numElems
expr_stmt|;
comment|/* so we'll insert after last element */
block|}
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
block|}
name|numRequired
operator|=
operator|(
name|numElems
operator|-
name|count
operator|+
name|objc
operator|)
expr_stmt|;
if|if
condition|(
name|numRequired
operator|<=
name|listRepPtr
operator|->
name|maxElemCount
condition|)
block|{
comment|/* 	 * Enough room in the current array. First "delete" count 	 * elements starting at first. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|first
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|victimPtr
operator|=
name|elemPtrs
index|[
name|j
index|]
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|victimPtr
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Shift the elements after the last one removed to their 	 * new locations. 	 */
name|start
operator|=
operator|(
name|first
operator|+
name|count
operator|)
expr_stmt|;
name|numAfterLast
operator|=
operator|(
name|numElems
operator|-
name|start
operator|)
expr_stmt|;
name|shift
operator|=
operator|(
name|objc
operator|-
name|count
operator|)
expr_stmt|;
comment|/* numNewElems - numDeleted */
if|if
condition|(
operator|(
name|numAfterLast
operator|>
literal|0
operator|)
operator|&&
operator|(
name|shift
operator|!=
literal|0
operator|)
condition|)
block|{
name|Tcl_Obj
modifier|*
modifier|*
name|src
decl_stmt|,
modifier|*
modifier|*
name|dst
decl_stmt|;
if|if
condition|(
name|shift
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|src
operator|=
name|elemPtrs
operator|+
name|start
operator|,
name|dst
operator|=
name|src
operator|+
name|shift
init|;
name|numAfterLast
operator|>
literal|0
condition|;
name|numAfterLast
operator|--
operator|,
name|src
operator|++
operator|,
name|dst
operator|++
control|)
block|{
operator|*
name|dst
operator|=
operator|*
name|src
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|src
operator|=
name|elemPtrs
operator|+
name|numElems
operator|-
literal|1
operator|,
name|dst
operator|=
name|src
operator|+
name|shift
init|;
name|numAfterLast
operator|>
literal|0
condition|;
name|numAfterLast
operator|--
operator|,
name|src
operator|--
operator|,
name|dst
operator|--
control|)
block|{
operator|*
name|dst
operator|=
operator|*
name|src
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Insert the new elements into elemPtrs before "first". 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|first
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|elemPtrs
index|[
name|j
index|]
operator|=
name|objv
index|[
name|i
index|]
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Update the count of elements. 	 */
name|listRepPtr
operator|->
name|elemCount
operator|=
name|numRequired
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * Not enough room in the current array. Allocate a larger array and 	 * insert elements into it.  	 */
name|newMax
operator|=
operator|(
literal|2
operator|*
name|numRequired
operator|)
expr_stmt|;
name|newPtrs
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|newMax
operator|*
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Copy over the elements before "first". 	 */
if|if
condition|(
name|first
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|newPtrs
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|elemPtrs
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|first
operator|*
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * "Delete" count elements starting at first. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|first
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|victimPtr
operator|=
name|elemPtrs
index|[
name|j
index|]
expr_stmt|;
name|TclDecrRefCount
argument_list|(
name|victimPtr
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Copy the elements after the last one removed, shifted to 	 * their new locations. 	 */
name|start
operator|=
operator|(
name|first
operator|+
name|count
operator|)
expr_stmt|;
name|numAfterLast
operator|=
operator|(
name|numElems
operator|-
name|start
operator|)
expr_stmt|;
if|if
condition|(
name|numAfterLast
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
operator|&
operator|(
name|newPtrs
index|[
name|first
operator|+
name|objc
index|]
operator|)
argument_list|,
operator|(
name|VOID
operator|*
operator|)
operator|&
operator|(
name|elemPtrs
index|[
name|start
index|]
operator|)
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|numAfterLast
operator|*
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Insert the new elements before "first" and update the 	 * count of elements. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|first
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|newPtrs
index|[
name|j
index|]
operator|=
name|objv
index|[
name|i
index|]
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|listRepPtr
operator|->
name|elemCount
operator|=
name|numRequired
expr_stmt|;
name|listRepPtr
operator|->
name|maxElemCount
operator|=
name|newMax
expr_stmt|;
name|listRepPtr
operator|->
name|elements
operator|=
name|newPtrs
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|elemPtrs
argument_list|)
expr_stmt|;
block|}
comment|/*      * Invalidate and free any old string representation since it no longer      * reflects the list's internal representation.      */
name|Tcl_InvalidateStringRep
argument_list|(
name|listPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FreeListInternalRep --  *  *	Deallocate the storage associated with a list object's internal  *	representation.  *  * Results:  *	None.  *  * Side effects:  *	Frees listPtr's List* internal representation and sets listPtr's  *	internalRep.otherValuePtr to NULL. Decrements the ref counts  *	of all element objects, which may free them.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|FreeListInternalRep
parameter_list|(
name|listPtr
parameter_list|)
name|Tcl_Obj
modifier|*
name|listPtr
decl_stmt|;
comment|/* List object with internal rep to free. */
block|{
specifier|register
name|List
modifier|*
name|listRepPtr
init|=
operator|(
name|List
operator|*
operator|)
name|listPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
decl_stmt|;
specifier|register
name|Tcl_Obj
modifier|*
modifier|*
name|elemPtrs
init|=
name|listRepPtr
operator|->
name|elements
decl_stmt|;
specifier|register
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|int
name|numElems
init|=
name|listRepPtr
operator|->
name|elemCount
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numElems
condition|;
name|i
operator|++
control|)
block|{
name|objPtr
operator|=
name|elemPtrs
index|[
name|i
index|]
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|elemPtrs
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|listRepPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DupListInternalRep --  *  *	Initialize the internal representation of a list Tcl_Obj to a  *	copy of the internal representation of an existing list object.   *  * Results:  *	None.  *  * Side effects:  *	"srcPtr"s list internal rep pointer should not be NULL and we assume  *	it is not NULL. We set "copyPtr"s internal rep to a pointer to a  *	newly allocated List structure that, in turn, points to "srcPtr"s  *	element objects. Those element objects are not actually copied but  *	are shared between "srcPtr" and "copyPtr". The ref count of each  *	element object is incremented.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|DupListInternalRep
parameter_list|(
name|srcPtr
parameter_list|,
name|copyPtr
parameter_list|)
name|Tcl_Obj
modifier|*
name|srcPtr
decl_stmt|;
comment|/* Object with internal rep to copy. */
name|Tcl_Obj
modifier|*
name|copyPtr
decl_stmt|;
comment|/* Object with internal rep to set. */
block|{
name|List
modifier|*
name|srcListRepPtr
init|=
operator|(
name|List
operator|*
operator|)
name|srcPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
decl_stmt|;
name|int
name|numElems
init|=
name|srcListRepPtr
operator|->
name|elemCount
decl_stmt|;
name|int
name|maxElems
init|=
name|srcListRepPtr
operator|->
name|maxElemCount
decl_stmt|;
specifier|register
name|Tcl_Obj
modifier|*
modifier|*
name|srcElemPtrs
init|=
name|srcListRepPtr
operator|->
name|elements
decl_stmt|;
specifier|register
name|Tcl_Obj
modifier|*
modifier|*
name|copyElemPtrs
decl_stmt|;
specifier|register
name|List
modifier|*
name|copyListRepPtr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*      * Allocate a new List structure that points to "srcPtr"s element      * objects. Increment the ref counts for those (now shared) element      * objects.      */
name|copyElemPtrs
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|maxElems
operator|*
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numElems
condition|;
name|i
operator|++
control|)
block|{
name|copyElemPtrs
index|[
name|i
index|]
operator|=
name|srcElemPtrs
index|[
name|i
index|]
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|copyElemPtrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|copyListRepPtr
operator|=
operator|(
name|List
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|List
argument_list|)
argument_list|)
expr_stmt|;
name|copyListRepPtr
operator|->
name|maxElemCount
operator|=
name|maxElems
expr_stmt|;
name|copyListRepPtr
operator|->
name|elemCount
operator|=
name|numElems
expr_stmt|;
name|copyListRepPtr
operator|->
name|elements
operator|=
name|copyElemPtrs
expr_stmt|;
name|copyPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
operator|=
operator|(
name|VOID
operator|*
operator|)
name|copyListRepPtr
expr_stmt|;
name|copyPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclListType
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SetListFromAny --  *  *	Attempt to generate a list internal form for the Tcl object  *	"objPtr".  *  * Results:  *	The return value is TCL_OK or TCL_ERROR. If an error occurs during  *	conversion, an error message is left in the interpreter's result  *	unless "interp" is NULL.  *  * Side effects:  *	If no error occurs, a list is stored as "objPtr"s internal  *	representation.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SetListFromAny
parameter_list|(
name|interp
parameter_list|,
name|objPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting if not NULL. */
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* The object to convert. */
block|{
name|Tcl_ObjType
modifier|*
name|oldTypePtr
init|=
name|objPtr
operator|->
name|typePtr
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|,
modifier|*
name|elemStart
decl_stmt|,
modifier|*
name|nextElem
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|int
name|lenRemain
decl_stmt|,
name|length
decl_stmt|,
name|estCount
decl_stmt|,
name|elemSize
decl_stmt|,
name|hasBrace
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|result
decl_stmt|;
name|char
modifier|*
name|limit
decl_stmt|;
comment|/* Points just after string's last byte. */
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|Tcl_Obj
modifier|*
modifier|*
name|elemPtrs
decl_stmt|;
specifier|register
name|Tcl_Obj
modifier|*
name|elemPtr
decl_stmt|;
name|List
modifier|*
name|listRepPtr
decl_stmt|;
comment|/*      * Get the string representation. Make it up-to-date if necessary.      */
name|string
operator|=
name|TclGetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
comment|/*      * Parse the string into separate string objects, and create a List      * structure that points to the element string objects. We use a      * modified version of Tcl_SplitList's implementation to avoid one      * malloc and a string copy for each list element. First, estimate the      * number of elements by counting the number of space characters in the      * list.      */
name|limit
operator|=
operator|(
name|string
operator|+
name|length
operator|)
expr_stmt|;
name|estCount
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|string
init|;
name|p
operator|<
name|limit
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|estCount
operator|++
expr_stmt|;
block|}
block|}
comment|/*      * Allocate a new List structure with enough room for "estCount"      * elements. Each element is a pointer to a Tcl_Obj with the appropriate      * string rep. The initial "estCount" elements are set using the      * corresponding "argv" strings.      */
name|elemPtrs
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|estCount
operator|*
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|string
operator|,
name|lenRemain
operator|=
name|length
operator|,
name|i
operator|=
literal|0
init|;
name|lenRemain
operator|>
literal|0
condition|;
name|p
operator|=
name|nextElem
operator|,
name|lenRemain
operator|=
operator|(
name|limit
operator|-
name|nextElem
operator|)
operator|,
name|i
operator|++
control|)
block|{
name|result
operator|=
name|TclFindElement
argument_list|(
name|interp
argument_list|,
name|p
argument_list|,
name|lenRemain
argument_list|,
operator|&
name|elemStart
argument_list|,
operator|&
name|nextElem
argument_list|,
operator|&
name|elemSize
argument_list|,
operator|&
name|hasBrace
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|elemPtr
operator|=
name|elemPtrs
index|[
name|j
index|]
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|elemPtr
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|elemPtrs
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
name|elemStart
operator|>=
name|limit
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|i
operator|>
name|estCount
condition|)
block|{
name|panic
argument_list|(
literal|"SetListFromAny: bad size estimate for list"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Allocate a Tcl object for the element and initialize it from the 	 * "elemSize" bytes starting at "elemStart". 	 */
name|s
operator|=
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|elemSize
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasBrace
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|s
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|elemStart
argument_list|,
operator|(
name|size_t
operator|)
name|elemSize
argument_list|)
expr_stmt|;
name|s
index|[
name|elemSize
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|elemSize
operator|=
name|TclCopyAndCollapse
argument_list|(
name|elemSize
argument_list|,
name|elemStart
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|TclNewObj
argument_list|(
name|elemPtr
argument_list|)
expr_stmt|;
name|elemPtr
operator|->
name|bytes
operator|=
name|s
expr_stmt|;
name|elemPtr
operator|->
name|length
operator|=
name|elemSize
expr_stmt|;
name|elemPtrs
index|[
name|i
index|]
operator|=
name|elemPtr
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|elemPtr
argument_list|)
expr_stmt|;
comment|/* since list now holds ref to it */
block|}
name|listRepPtr
operator|=
operator|(
name|List
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|List
argument_list|)
argument_list|)
expr_stmt|;
name|listRepPtr
operator|->
name|maxElemCount
operator|=
name|estCount
expr_stmt|;
name|listRepPtr
operator|->
name|elemCount
operator|=
name|i
expr_stmt|;
name|listRepPtr
operator|->
name|elements
operator|=
name|elemPtrs
expr_stmt|;
comment|/*      * Free the old internalRep before setting the new one. We do this as      * late as possible to allow the conversion code, in particular      * Tcl_GetStringFromObj, to use that old internalRep.      */
if|if
condition|(
operator|(
name|oldTypePtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|oldTypePtr
operator|->
name|freeIntRepProc
operator|!=
name|NULL
operator|)
condition|)
block|{
name|oldTypePtr
operator|->
name|freeIntRepProc
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
block|}
name|objPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
operator|=
operator|(
name|VOID
operator|*
operator|)
name|listRepPtr
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclListType
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * UpdateStringOfList --  *  *	Update the string representation for a list object.  *	Note: This procedure does not invalidate an existing old string rep  *	so storage will be lost if this has not already been done.   *  * Results:  *	None.  *  * Side effects:  *	The object's string is set to a valid string that results from  *	the list-to-string conversion. This string will be empty if the  *	list has no elements. The list internal representation  *	should not be NULL and we assume it is not NULL.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|UpdateStringOfList
parameter_list|(
name|listPtr
parameter_list|)
name|Tcl_Obj
modifier|*
name|listPtr
decl_stmt|;
comment|/* List object with string rep to update. */
block|{
define|#
directive|define
name|LOCAL_SIZE
value|20
name|int
name|localFlags
index|[
name|LOCAL_SIZE
index|]
decl_stmt|,
modifier|*
name|flagPtr
decl_stmt|;
name|List
modifier|*
name|listRepPtr
init|=
operator|(
name|List
operator|*
operator|)
name|listPtr
operator|->
name|internalRep
operator|.
name|otherValuePtr
decl_stmt|;
name|int
name|numElems
init|=
name|listRepPtr
operator|->
name|elemCount
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|elem
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/*      * Convert each element of the list to string form and then convert it      * to proper list element form, adding it to the result buffer.      */
comment|/*      * Pass 1: estimate space, gather flags.      */
if|if
condition|(
name|numElems
operator|<=
name|LOCAL_SIZE
condition|)
block|{
name|flagPtr
operator|=
name|localFlags
expr_stmt|;
block|}
else|else
block|{
name|flagPtr
operator|=
operator|(
name|int
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|numElems
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|listPtr
operator|->
name|length
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numElems
condition|;
name|i
operator|++
control|)
block|{
name|elem
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|listRepPtr
operator|->
name|elements
index|[
name|i
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|listPtr
operator|->
name|length
operator|+=
name|Tcl_ScanCountedElement
argument_list|(
name|elem
argument_list|,
name|length
argument_list|,
operator|&
name|flagPtr
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
comment|/*      * Pass 2: copy into string rep buffer.      */
name|listPtr
operator|->
name|bytes
operator|=
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|listPtr
operator|->
name|length
argument_list|)
expr_stmt|;
name|dst
operator|=
name|listPtr
operator|->
name|bytes
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numElems
condition|;
name|i
operator|++
control|)
block|{
name|elem
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|listRepPtr
operator|->
name|elements
index|[
name|i
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|Tcl_ConvertCountedElement
argument_list|(
name|elem
argument_list|,
name|length
argument_list|,
name|dst
argument_list|,
name|flagPtr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|*
name|dst
operator|=
literal|' '
expr_stmt|;
name|dst
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|flagPtr
operator|!=
name|localFlags
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|flagPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dst
operator|==
name|listPtr
operator|->
name|bytes
condition|)
block|{
operator|*
name|dst
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|dst
operator|--
expr_stmt|;
operator|*
name|dst
operator|=
literal|0
expr_stmt|;
block|}
name|listPtr
operator|->
name|length
operator|=
name|dst
operator|-
name|listPtr
operator|->
name|bytes
expr_stmt|;
block|}
end_function

end_unit

