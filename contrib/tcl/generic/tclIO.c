begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclIO.c --  *  *	This file provides the generic portions (those that are the same on  *	all platforms and for all channel types) of Tcl's IO facilities.  *  * Copyright (c) 1995-1997 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclIO.c 1.268 97/07/28 14:20:36  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_comment
comment|/*  * Make sure that both EAGAIN and EWOULDBLOCK are defined. This does not  * compile on systems where neither is defined. We want both defined so  * that we can test safely for both. In the code we still have to test for  * both because there may be systems on which both are defined and have  * different values.  */
end_comment

begin_if
if|#
directive|if
operator|(
operator|(
operator|!
name|defined
argument_list|(
name|EWOULDBLOCK
argument_list|)
operator|)
operator|&&
operator|(
name|defined
argument_list|(
name|EAGAIN
argument_list|)
operator|)
operator|)
end_if

begin_define
define|#
directive|define
name|EWOULDBLOCK
value|EAGAIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
operator|(
operator|!
name|defined
argument_list|(
name|EAGAIN
argument_list|)
operator|)
operator|&&
operator|(
name|defined
argument_list|(
name|EWOULDBLOCK
argument_list|)
operator|)
operator|)
end_if

begin_define
define|#
directive|define
name|EAGAIN
value|EWOULDBLOCK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
operator|(
operator|!
name|defined
argument_list|(
name|EAGAIN
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|defined
argument_list|(
name|EWOULDBLOCK
argument_list|)
operator|)
operator|)
end_if

begin_expr_stmt
name|error
name|one
name|of
name|EWOULDBLOCK
name|or
name|EAGAIN
name|must
name|be
name|defined
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The following structure encapsulates the state for a background channel  * copy.  Note that the data buffer for the copy will be appended to this  * structure.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|CopyState
block|{
name|struct
name|Channel
modifier|*
name|readPtr
decl_stmt|;
comment|/* Pointer to input channel. */
name|struct
name|Channel
modifier|*
name|writePtr
decl_stmt|;
comment|/* Pointer to output channel. */
name|int
name|readFlags
decl_stmt|;
comment|/* Original read channel flags. */
name|int
name|writeFlags
decl_stmt|;
comment|/* Original write channel flags. */
name|int
name|toRead
decl_stmt|;
comment|/* Number of bytes to copy, or -1. */
name|int
name|total
decl_stmt|;
comment|/* Total bytes transferred (written). */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interp that started the copy. */
name|Tcl_Obj
modifier|*
name|cmdPtr
decl_stmt|;
comment|/* Command to be invoked at completion. */
name|int
name|bufSize
decl_stmt|;
comment|/* Size of appended buffer. */
name|char
name|buffer
index|[
literal|1
index|]
decl_stmt|;
comment|/* Copy buffer, this must be the last 				 * field. */
block|}
name|CopyState
typedef|;
end_typedef

begin_comment
comment|/*  * struct ChannelBuffer:  *  * Buffers data being sent to or from a channel.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ChannelBuffer
block|{
name|int
name|nextAdded
decl_stmt|;
comment|/* The next position into which a character                                  * will be put in the buffer. */
name|int
name|nextRemoved
decl_stmt|;
comment|/* Position of next byte to be removed                                  * from the buffer. */
name|int
name|bufSize
decl_stmt|;
comment|/* How big is the buffer? */
name|struct
name|ChannelBuffer
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next buffer in chain. */
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
comment|/* Placeholder for real buffer. The real                                  * buffer occuppies this space + bufSize-4                                  * bytes. This must be the last field in                                  * the structure. */
block|}
name|ChannelBuffer
typedef|;
end_typedef

begin_define
define|#
directive|define
name|CHANNELBUFFER_HEADER_SIZE
value|(sizeof(ChannelBuffer) - 4)
end_define

begin_comment
comment|/*  * The following defines the *default* buffer size for channels.  */
end_comment

begin_define
define|#
directive|define
name|CHANNELBUFFER_DEFAULT_SIZE
value|(1024 * 4)
end_define

begin_comment
comment|/*  * Structure to record a close callback. One such record exists for  * each close callback registered for a channel.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|CloseCallback
block|{
name|Tcl_CloseProc
modifier|*
name|proc
decl_stmt|;
comment|/* The procedure to call. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary one-word data to pass                                          * to the callback. */
name|struct
name|CloseCallback
modifier|*
name|nextPtr
decl_stmt|;
comment|/* For chaining close callbacks. */
block|}
name|CloseCallback
typedef|;
end_typedef

begin_comment
comment|/*  * The following structure describes the information saved from a call to  * "fileevent". This is used later when the event being waited for to  * invoke the saved script in the interpreter designed in this record.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|EventScriptRecord
block|{
name|struct
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The channel for which this script is                                  * registered. This is used only when an                                  * error occurs during evaluation of the                                  * script, to delete the handler. */
name|char
modifier|*
name|script
decl_stmt|;
comment|/* Script to invoke. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* In what interpreter to invoke script? */
name|int
name|mask
decl_stmt|;
comment|/* Events must overlap current mask for the                                  * stored script to be invoked. */
name|struct
name|EventScriptRecord
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next in chain of records. */
block|}
name|EventScriptRecord
typedef|;
end_typedef

begin_comment
comment|/*  * struct Channel:  *  * One of these structures is allocated for each open channel. It contains data  * specific to the channel but which belongs to the generic part of the Tcl  * channel mechanism, and it points at an instance specific (and type  * specific) * instance data, and at a channel type structure.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Channel
block|{
name|char
modifier|*
name|channelName
decl_stmt|;
comment|/* The name of the channel instance in Tcl                                  * commands. Storage is owned by the generic IO                                  * code,  is dynamically allocated. */
name|int
name|flags
decl_stmt|;
comment|/* ORed combination of the flags defined                                  * below. */
name|Tcl_EolTranslation
name|inputTranslation
decl_stmt|;
comment|/* What translation to apply for end of line                                  * sequences on input? */
name|Tcl_EolTranslation
name|outputTranslation
decl_stmt|;
comment|/* What translation to use for generating                                  * end of line sequences in output? */
name|int
name|inEofChar
decl_stmt|;
comment|/* If nonzero, use this as a signal of EOF                                  * on input. */
name|int
name|outEofChar
decl_stmt|;
comment|/* If nonzero, append this to the channel                                  * when it is closed if it is open for                                  * writing. */
name|int
name|unreportedError
decl_stmt|;
comment|/* Non-zero if an error report was deferred                                  * because it happened in the background. The                                  * value is the POSIX error code. */
name|ClientData
name|instanceData
decl_stmt|;
comment|/* Instance specific data. */
name|Tcl_ChannelType
modifier|*
name|typePtr
decl_stmt|;
comment|/* Pointer to channel type structure. */
name|int
name|refCount
decl_stmt|;
comment|/* How many interpreters hold references to                                  * this IO channel? */
name|CloseCallback
modifier|*
name|closeCbPtr
decl_stmt|;
comment|/* Callbacks registered to be called when the                                  * channel is closed. */
name|ChannelBuffer
modifier|*
name|curOutPtr
decl_stmt|;
comment|/* Current output buffer being filled. */
name|ChannelBuffer
modifier|*
name|outQueueHead
decl_stmt|;
comment|/* Points at first buffer in output queue. */
name|ChannelBuffer
modifier|*
name|outQueueTail
decl_stmt|;
comment|/* Points at last buffer in output queue. */
name|ChannelBuffer
modifier|*
name|saveInBufPtr
decl_stmt|;
comment|/* Buffer saved for input queue - eliminates                                  * need to allocate a new buffer for "gets"                                  * that crosses buffer boundaries. */
name|ChannelBuffer
modifier|*
name|inQueueHead
decl_stmt|;
comment|/* Points at first buffer in input queue. */
name|ChannelBuffer
modifier|*
name|inQueueTail
decl_stmt|;
comment|/* Points at last buffer in input queue. */
name|struct
name|ChannelHandler
modifier|*
name|chPtr
decl_stmt|;
comment|/* List of channel handlers registered                                   * for this channel. */
name|int
name|interestMask
decl_stmt|;
comment|/* Mask of all events this channel has                                  * handlers for. */
name|struct
name|Channel
modifier|*
name|nextChanPtr
decl_stmt|;
comment|/* Next in list of channels currently open. */
name|EventScriptRecord
modifier|*
name|scriptRecordPtr
decl_stmt|;
comment|/* Chain of all scripts registered for                                  * event handlers ("fileevent") on this                                  * channel. */
name|int
name|bufSize
decl_stmt|;
comment|/* What size buffers to allocate? */
name|Tcl_TimerToken
name|timer
decl_stmt|;
comment|/* Handle to wakeup timer for this channel. */
name|CopyState
modifier|*
name|csPtr
decl_stmt|;
comment|/* State of background copy, or NULL. */
block|}
name|Channel
typedef|;
end_typedef

begin_comment
comment|/*  * Values for the flags field in Channel. Any ORed combination of the  * following flags can be stored in the field. These flags record various  * options and state bits about the channel. In addition to the flags below,  * the channel can also have TCL_READABLE (1<<1) and TCL_WRITABLE (1<<2) set.  */
end_comment

begin_define
define|#
directive|define
name|CHANNEL_NONBLOCKING
value|(1<<3)
end_define

begin_comment
comment|/* Channel is currently in 					 * nonblocking mode. */
end_comment

begin_define
define|#
directive|define
name|CHANNEL_LINEBUFFERED
value|(1<<4)
end_define

begin_comment
comment|/* Output to the channel must be 					 * flushed after every newline. */
end_comment

begin_define
define|#
directive|define
name|CHANNEL_UNBUFFERED
value|(1<<5)
end_define

begin_comment
comment|/* Output to the channel must always 					 * be flushed immediately. */
end_comment

begin_define
define|#
directive|define
name|BUFFER_READY
value|(1<<6)
end_define

begin_comment
comment|/* Current output buffer (the 					 * curOutPtr field in the                                          * channel structure) should be                                          * output as soon as possible even                                          * though it may not be full. */
end_comment

begin_define
define|#
directive|define
name|BG_FLUSH_SCHEDULED
value|(1<<7)
end_define

begin_comment
comment|/* A background flush of the 					 * queued output buffers has been                                          * scheduled. */
end_comment

begin_define
define|#
directive|define
name|CHANNEL_CLOSED
value|(1<<8)
end_define

begin_comment
comment|/* Channel has been closed. No 					 * further Tcl-level IO on the                                          * channel is allowed. */
end_comment

begin_define
define|#
directive|define
name|CHANNEL_EOF
value|(1<<9)
end_define

begin_comment
comment|/* EOF occurred on this channel. 					 * This bit is cleared before every                                          * input operation. */
end_comment

begin_define
define|#
directive|define
name|CHANNEL_STICKY_EOF
value|(1<<10)
end_define

begin_comment
comment|/* EOF occurred on this channel because 					 * we saw the input eofChar. This bit                                          * prevents clearing of the EOF bit                                          * before every input operation. */
end_comment

begin_define
define|#
directive|define
name|CHANNEL_BLOCKED
value|(1<<11)
end_define

begin_comment
comment|/* EWOULDBLOCK or EAGAIN occurred 					 * on this channel. This bit is                                          * cleared before every input or                                          * output operation. */
end_comment

begin_define
define|#
directive|define
name|INPUT_SAW_CR
value|(1<<12)
end_define

begin_comment
comment|/* Channel is in CRLF eol input 					 * translation mode and the last                                          * byte seen was a "\r". */
end_comment

begin_define
define|#
directive|define
name|CHANNEL_DEAD
value|(1<<13)
end_define

begin_comment
comment|/* The channel has been closed by 					 * the exit handler (on exit) but                                          * not deallocated. When any IO                                          * operation sees this flag on a                                          * channel, it does not call driver                                          * level functions to avoid referring                                          * to deallocated data. */
end_comment

begin_define
define|#
directive|define
name|CHANNEL_GETS_BLOCKED
value|(1<<14)
end_define

begin_comment
comment|/* The last input operation was a gets 					 * that failed to get a comlete line. 					 * When set, file events will not be 					 * delivered for buffered data unless 					 * an EOL is present. */
end_comment

begin_comment
comment|/*  * For each channel handler registered in a call to Tcl_CreateChannelHandler,  * there is one record of the following type. All of records for a specific  * channel are chained together in a singly linked list which is stored in  * the channel structure.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ChannelHandler
block|{
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The channel structure for this channel. */
name|int
name|mask
decl_stmt|;
comment|/* Mask of desired events. */
name|Tcl_ChannelProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to call in the type of                                  * Tcl_CreateChannelHandler. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Argument to pass to procedure. */
name|struct
name|ChannelHandler
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Next one in list of registered handlers. */
block|}
name|ChannelHandler
typedef|;
end_typedef

begin_comment
comment|/*  * This structure keeps track of the current ChannelHandler being invoked in  * the current invocation of ChannelHandlerEventProc. There is a potential  * problem if a ChannelHandler is deleted while it is the current one, since  * ChannelHandlerEventProc needs to look at the nextPtr field. To handle this  * problem, structures of the type below indicate the next handler to be  * processed for any (recursively nested) dispatches in progress. The  * nextHandlerPtr field is updated if the handler being pointed to is deleted.  * The nextPtr field is used to chain together all recursive invocations, so  * that Tcl_DeleteChannelHandler can find all the recursively nested  * invocations of ChannelHandlerEventProc and compare the handler being  * deleted against the NEXT handler to be invoked in that invocation; when it  * finds such a situation, Tcl_DeleteChannelHandler updates the nextHandlerPtr  * field of the structure to the next handler.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|NextChannelHandler
block|{
name|ChannelHandler
modifier|*
name|nextHandlerPtr
decl_stmt|;
comment|/* The next handler to be invoked in                                          * this invocation. */
name|struct
name|NextChannelHandler
modifier|*
name|nestedHandlerPtr
decl_stmt|;
comment|/* Next nested invocation of                                          * ChannelHandlerEventProc. */
block|}
name|NextChannelHandler
typedef|;
end_typedef

begin_comment
comment|/*  * This variable holds the list of nested ChannelHandlerEventProc invocations.  */
end_comment

begin_decl_stmt
specifier|static
name|NextChannelHandler
modifier|*
name|nestedHandlerPtr
init|=
operator|(
name|NextChannelHandler
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * List of all channels currently open.  */
end_comment

begin_decl_stmt
specifier|static
name|Channel
modifier|*
name|firstChanPtr
init|=
operator|(
name|Channel
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Has a channel exit handler been created yet?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|channelExitHandlerCreated
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The following structure describes the event that is added to the Tcl  * event queue by the channel handler check procedure.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ChannelHandlerEvent
block|{
name|Tcl_Event
name|header
decl_stmt|;
comment|/* Standard header for all events. */
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The channel that is ready. */
name|int
name|readyMask
decl_stmt|;
comment|/* Events that have occurred. */
block|}
name|ChannelHandlerEvent
typedef|;
end_typedef

begin_comment
comment|/*  * Static variables to hold channels for stdin, stdout and stderr.  */
end_comment

begin_decl_stmt
specifier|static
name|Tcl_Channel
name|stdinChannel
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stdinInitialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Tcl_Channel
name|stdoutChannel
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stdoutInitialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Tcl_Channel
name|stderrChannel
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stderrInitialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Static functions in this file:  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ChannelEventScriptInvoker
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ChannelTimerProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|CheckForStdChannelsBeingClosed
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Channel
name|chan
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|CleanupChannelHandlers
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Channel
operator|*
name|chanPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CloseChannel
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Channel
operator|*
name|chanPtr
operator|,
name|int
name|errorCode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|CloseChannelsOnExit
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CopyAndTranslateBuffer
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Channel
operator|*
name|chanPtr
operator|,
name|char
operator|*
name|result
operator|,
name|int
name|space
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CopyData
name|_ANSI_ARGS_
argument_list|(
operator|(
name|CopyState
operator|*
name|csPtr
operator|,
name|int
name|mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|CopyEventProc
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|int
name|mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|CreateScriptRecord
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Channel
operator|*
name|chanPtr
operator|,
name|int
name|mask
operator|,
name|char
operator|*
name|script
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DeleteChannelTable
name|_ANSI_ARGS_
argument_list|(
operator|(
name|ClientData
name|clientData
operator|,
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DeleteScriptRecord
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Channel
operator|*
name|chanPtr
operator|,
name|int
name|mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DiscardInputQueued
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Channel
operator|*
name|chanPtr
operator|,
name|int
name|discardSavedBuffers
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DiscardOutputQueued
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Channel
operator|*
name|chanPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DoRead
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Channel
operator|*
name|chanPtr
operator|,
name|char
operator|*
name|srcPtr
operator|,
name|int
name|slen
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DoWrite
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Channel
operator|*
name|chanPtr
operator|,
name|char
operator|*
name|srcPtr
operator|,
name|int
name|slen
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|FlushChannel
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Channel
operator|*
name|chanPtr
operator|,
name|int
name|calledFromAsyncFlush
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Tcl_HashTable
modifier|*
name|GetChannelTable
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|GetEOL
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Channel
operator|*
name|chanPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|GetInput
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Channel
operator|*
name|chanPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|RecycleBuffer
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Channel
operator|*
name|chanPtr
operator|,
name|ChannelBuffer
operator|*
name|bufPtr
operator|,
name|int
name|mustDiscard
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ScanBufferForEOL
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Channel
operator|*
name|chanPtr
operator|,
name|ChannelBuffer
operator|*
name|bufPtr
operator|,
name|Tcl_EolTranslation
name|translation
operator|,
name|int
name|eofChar
operator|,
name|int
operator|*
name|bytesToEOLPtr
operator|,
name|int
operator|*
name|crSeenPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ScanInputForEOL
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Channel
operator|*
name|chanPtr
operator|,
name|int
operator|*
name|bytesQueuedPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SetBlockMode
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Channel
operator|*
name|chanPtr
operator|,
name|int
name|mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|StopCopy
name|_ANSI_ARGS_
argument_list|(
operator|(
name|CopyState
operator|*
name|csPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|UpdateInterest
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Channel
operator|*
name|chanPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CheckForDeadChannel
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|Channel
operator|*
name|chan
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * SetBlockMode --  *  *	This function sets the blocking mode for a channel and updates  *	the state flags.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Modifies the blocking mode of the channel and possibly generates  *	an error.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SetBlockMode
parameter_list|(
name|interp
parameter_list|,
name|chanPtr
parameter_list|,
name|mode
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interp for error reporting. */
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* Channel to modify. */
name|int
name|mode
decl_stmt|;
comment|/* One of TCL_MODE_BLOCKING or 				 * TCL_MODE_NONBLOCKING. */
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|chanPtr
operator|->
name|typePtr
operator|->
name|blockModeProc
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
call|(
name|chanPtr
operator|->
name|typePtr
operator|->
name|blockModeProc
call|)
argument_list|(
name|chanPtr
operator|->
name|instanceData
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"error setting blocking mode: "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|mode
operator|==
name|TCL_MODE_BLOCKING
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|CHANNEL_NONBLOCKING
operator||
name|BG_FLUSH_SCHEDULED
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|chanPtr
operator|->
name|flags
operator||=
name|CHANNEL_NONBLOCKING
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetStdChannel --  *  *	This function is used to change the channels that are used  *	for stdin/stdout/stderr in new interpreters.  *  * Results:  *	None  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_SetStdChannel
parameter_list|(
name|channel
parameter_list|,
name|type
parameter_list|)
name|Tcl_Channel
name|channel
decl_stmt|;
name|int
name|type
decl_stmt|;
comment|/* One of TCL_STDIN, TCL_STDOUT, TCL_STDERR. */
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TCL_STDIN
case|:
name|stdinInitialized
operator|=
literal|1
expr_stmt|;
name|stdinChannel
operator|=
name|channel
expr_stmt|;
break|break;
case|case
name|TCL_STDOUT
case|:
name|stdoutInitialized
operator|=
literal|1
expr_stmt|;
name|stdoutChannel
operator|=
name|channel
expr_stmt|;
break|break;
case|case
name|TCL_STDERR
case|:
name|stderrInitialized
operator|=
literal|1
expr_stmt|;
name|stderrChannel
operator|=
name|channel
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetStdChannel --  *  *	Returns the specified standard channel.  *  * Results:  *	Returns the specified standard channel, or NULL.  *  * Side effects:  *	May cause the creation of a standard channel and the underlying  *	file.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Channel
name|Tcl_GetStdChannel
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
comment|/* One of TCL_STDIN, TCL_STDOUT, TCL_STDERR. */
block|{
name|Tcl_Channel
name|channel
init|=
name|NULL
decl_stmt|;
comment|/*      * If the channels were not created yet, create them now and      * store them in the static variables.  Note that we need to set      * stdinInitialized before calling TclGetDefaultStdChannel in order      * to avoid recursive loops when TclGetDefaultStdChannel calls      * Tcl_CreateChannel.      */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TCL_STDIN
case|:
if|if
condition|(
operator|!
name|stdinInitialized
condition|)
block|{
name|stdinChannel
operator|=
name|TclGetDefaultStdChannel
argument_list|(
name|TCL_STDIN
argument_list|)
expr_stmt|;
name|stdinInitialized
operator|=
literal|1
expr_stmt|;
comment|/*                  * Artificially bump the refcount to ensure that the channel                  * is only closed on exit.                  *                  * NOTE: Must only do this if stdinChannel is not NULL. It                  * can be NULL in situations where Tcl is unable to connect                  * to the standard input.                  */
if|if
condition|(
name|stdinChannel
operator|!=
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|Tcl_RegisterChannel
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|stdinChannel
argument_list|)
expr_stmt|;
block|}
block|}
name|channel
operator|=
name|stdinChannel
expr_stmt|;
break|break;
case|case
name|TCL_STDOUT
case|:
if|if
condition|(
operator|!
name|stdoutInitialized
condition|)
block|{
name|stdoutChannel
operator|=
name|TclGetDefaultStdChannel
argument_list|(
name|TCL_STDOUT
argument_list|)
expr_stmt|;
name|stdoutInitialized
operator|=
literal|1
expr_stmt|;
comment|/*                  * Artificially bump the refcount to ensure that the channel                  * is only closed on exit.                  *                  * NOTE: Must only do this if stdoutChannel is not NULL. It                  * can be NULL in situations where Tcl is unable to connect                  * to the standard output.                  */
if|if
condition|(
name|stdoutChannel
operator|!=
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|Tcl_RegisterChannel
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|stdoutChannel
argument_list|)
expr_stmt|;
block|}
block|}
name|channel
operator|=
name|stdoutChannel
expr_stmt|;
break|break;
case|case
name|TCL_STDERR
case|:
if|if
condition|(
operator|!
name|stderrInitialized
condition|)
block|{
name|stderrChannel
operator|=
name|TclGetDefaultStdChannel
argument_list|(
name|TCL_STDERR
argument_list|)
expr_stmt|;
name|stderrInitialized
operator|=
literal|1
expr_stmt|;
comment|/*                  * Artificially bump the refcount to ensure that the channel                  * is only closed on exit.                  *                  * NOTE: Must only do this if stderrChannel is not NULL. It                  * can be NULL in situations where Tcl is unable to connect                  * to the standard error.                  */
if|if
condition|(
name|stderrChannel
operator|!=
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|Tcl_RegisterChannel
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
name|stderrChannel
argument_list|)
expr_stmt|;
block|}
block|}
name|channel
operator|=
name|stderrChannel
expr_stmt|;
break|break;
block|}
return|return
name|channel
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CreateCloseHandler  *  *	Creates a close callback which will be called when the channel is  *	closed.  *  * Results:  *	None.  *  * Side effects:  *	Causes the callback to be called in the future when the channel  *	will be closed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_CreateCloseHandler
parameter_list|(
name|chan
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel for which to create the                                  * close callback. */
name|Tcl_CloseProc
modifier|*
name|proc
decl_stmt|;
comment|/* The callback routine to call when the                                  * channel will be closed. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary data to pass to the                                  * close callback. */
block|{
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
name|CloseCallback
modifier|*
name|cbPtr
decl_stmt|;
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|chan
expr_stmt|;
name|cbPtr
operator|=
operator|(
name|CloseCallback
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|CloseCallback
argument_list|)
argument_list|)
expr_stmt|;
name|cbPtr
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|cbPtr
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
name|cbPtr
operator|->
name|nextPtr
operator|=
name|chanPtr
operator|->
name|closeCbPtr
expr_stmt|;
name|chanPtr
operator|->
name|closeCbPtr
operator|=
name|cbPtr
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DeleteCloseHandler --  *  *	Removes a callback that would have been called on closing  *	the channel. If there is no matching callback then this  *	function has no effect.  *  * Results:  *	None.  *  * Side effects:  *	The callback will not be called in the future when the channel  *	is eventually closed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DeleteCloseHandler
parameter_list|(
name|chan
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel for which to cancel the                                  * close callback. */
name|Tcl_CloseProc
modifier|*
name|proc
decl_stmt|;
comment|/* The procedure for the callback to                                  * remove. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* The callback data for the callback                                  * to remove. */
block|{
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
name|CloseCallback
modifier|*
name|cbPtr
decl_stmt|,
modifier|*
name|cbPrevPtr
decl_stmt|;
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|chan
expr_stmt|;
for|for
control|(
name|cbPtr
operator|=
name|chanPtr
operator|->
name|closeCbPtr
operator|,
name|cbPrevPtr
operator|=
operator|(
name|CloseCallback
operator|*
operator|)
name|NULL
init|;
name|cbPtr
operator|!=
operator|(
name|CloseCallback
operator|*
operator|)
name|NULL
condition|;
name|cbPtr
operator|=
name|cbPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
operator|(
name|cbPtr
operator|->
name|proc
operator|==
name|proc
operator|)
operator|&&
operator|(
name|cbPtr
operator|->
name|clientData
operator|==
name|clientData
operator|)
condition|)
block|{
if|if
condition|(
name|cbPrevPtr
operator|==
operator|(
name|CloseCallback
operator|*
operator|)
name|NULL
condition|)
block|{
name|chanPtr
operator|->
name|closeCbPtr
operator|=
name|cbPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cbPtr
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|cbPrevPtr
operator|=
name|cbPtr
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CloseChannelsOnExit --  *  *	Closes all the existing channels, on exit. This	routine is called  *	during exit processing.  *  * Results:  *	None.  *  * Side effects:  *	Closes all channels.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|CloseChannelsOnExit
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* NULL - unused. */
block|{
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* Iterates over open channels. */
name|Channel
modifier|*
name|nextChanPtr
decl_stmt|;
comment|/* Iterates over open channels. */
for|for
control|(
name|chanPtr
operator|=
name|firstChanPtr
init|;
name|chanPtr
operator|!=
operator|(
name|Channel
operator|*
operator|)
name|NULL
condition|;
name|chanPtr
operator|=
name|nextChanPtr
control|)
block|{
name|nextChanPtr
operator|=
name|chanPtr
operator|->
name|nextChanPtr
expr_stmt|;
comment|/*          * Set the channel back into blocking mode to ensure that we wait          * for all data to flush out.          */
operator|(
name|void
operator|)
name|Tcl_SetChannelOption
argument_list|(
name|NULL
argument_list|,
operator|(
name|Tcl_Channel
operator|)
name|chanPtr
argument_list|,
literal|"-blocking"
argument_list|,
literal|"on"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chanPtr
operator|==
operator|(
name|Channel
operator|*
operator|)
name|stdinChannel
operator|)
operator|||
operator|(
name|chanPtr
operator|==
operator|(
name|Channel
operator|*
operator|)
name|stdoutChannel
operator|)
operator|||
operator|(
name|chanPtr
operator|==
operator|(
name|Channel
operator|*
operator|)
name|stderrChannel
operator|)
condition|)
block|{
comment|/*              * Decrement the refcount which was earlier artificially bumped              * up to keep the channel from being closed.              */
name|chanPtr
operator|->
name|refCount
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|chanPtr
operator|->
name|refCount
operator|<=
literal|0
condition|)
block|{
comment|/*              * Close it only if the refcount indicates that the channel is not              * referenced from any interpreter. If it is, that interpreter will              * close the channel when it gets destroyed.              */
operator|(
name|void
operator|)
name|Tcl_Close
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|Tcl_Channel
operator|)
name|chanPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*              * The refcount is greater than zero, so flush the channel.              */
name|Tcl_Flush
argument_list|(
operator|(
name|Tcl_Channel
operator|)
name|chanPtr
argument_list|)
expr_stmt|;
comment|/*              * Call the device driver to actually close the underlying              * device for this channel.              */
call|(
name|chanPtr
operator|->
name|typePtr
operator|->
name|closeProc
call|)
argument_list|(
name|chanPtr
operator|->
name|instanceData
argument_list|,
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/*              * Finally, we clean up the fields in the channel data structure              * since all of them have been deleted already. We mark the              * channel with CHANNEL_DEAD to prevent any further IO operations              * on it.              */
name|chanPtr
operator|->
name|instanceData
operator|=
operator|(
name|ClientData
operator|)
name|NULL
expr_stmt|;
name|chanPtr
operator|->
name|flags
operator||=
name|CHANNEL_DEAD
expr_stmt|;
block|}
block|}
comment|/*      * Reinitialize all the variables to the initial state:      */
name|firstChanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|NULL
expr_stmt|;
name|nestedHandlerPtr
operator|=
operator|(
name|NextChannelHandler
operator|*
operator|)
name|NULL
expr_stmt|;
name|channelExitHandlerCreated
operator|=
literal|0
expr_stmt|;
name|stdinChannel
operator|=
name|NULL
expr_stmt|;
name|stdinInitialized
operator|=
literal|0
expr_stmt|;
name|stdoutChannel
operator|=
name|NULL
expr_stmt|;
name|stdoutInitialized
operator|=
literal|0
expr_stmt|;
name|stderrChannel
operator|=
name|NULL
expr_stmt|;
name|stderrInitialized
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * GetChannelTable --  *  *	Gets and potentially initializes the channel table for an  *	interpreter. If it is initializing the table it also inserts  *	channels for stdin, stdout and stderr if the interpreter is  *	trusted.  *  * Results:  *	A pointer to the hash table created, for use by the caller.  *  * Side effects:  *	Initializes the channel table for an interpreter. May create  *	channels for stdin, stdout and stderr.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Tcl_HashTable
modifier|*
name|GetChannelTable
parameter_list|(
name|interp
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
block|{
name|Tcl_HashTable
modifier|*
name|hTblPtr
decl_stmt|;
comment|/* Hash table of channels. */
name|Tcl_Channel
name|stdinChan
decl_stmt|,
name|stdoutChan
decl_stmt|,
name|stderrChan
decl_stmt|;
name|hTblPtr
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclIO"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hTblPtr
operator|==
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
condition|)
block|{
name|hTblPtr
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|Tcl_HashTable
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_InitHashTable
argument_list|(
name|hTblPtr
argument_list|,
name|TCL_STRING_KEYS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Tcl_SetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclIO"
argument_list|,
operator|(
name|Tcl_InterpDeleteProc
operator|*
operator|)
name|DeleteChannelTable
argument_list|,
operator|(
name|ClientData
operator|)
name|hTblPtr
argument_list|)
expr_stmt|;
comment|/*          * If the interpreter is trusted (not "safe"), insert channels          * for stdin, stdout and stderr (possibly creating them in the          * process).          */
if|if
condition|(
name|Tcl_IsSafe
argument_list|(
name|interp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|stdinChan
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdinChan
operator|!=
name|NULL
condition|)
block|{
name|Tcl_RegisterChannel
argument_list|(
name|interp
argument_list|,
name|stdinChan
argument_list|)
expr_stmt|;
block|}
name|stdoutChan
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdoutChan
operator|!=
name|NULL
condition|)
block|{
name|Tcl_RegisterChannel
argument_list|(
name|interp
argument_list|,
name|stdoutChan
argument_list|)
expr_stmt|;
block|}
name|stderrChan
operator|=
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|stderrChan
operator|!=
name|NULL
condition|)
block|{
name|Tcl_RegisterChannel
argument_list|(
name|interp
argument_list|,
name|stderrChan
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|hTblPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DeleteChannelTable --  *  *	Deletes the channel table for an interpreter, closing any open  *	channels whose refcount reaches zero. This procedure is invoked  *	when an interpreter is deleted, via the AssocData cleanup  *	mechanism.  *  * Results:  *	None.  *  * Side effects:  *	Deletes the hash table of channels. May close channels. May flush  *	output on closed channels. Removes any channeEvent handlers that were  *	registered in this interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|DeleteChannelTable
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* The per-interpreter data structure. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interpreter being deleted. */
block|{
name|Tcl_HashTable
modifier|*
name|hTblPtr
decl_stmt|;
comment|/* The hash table. */
name|Tcl_HashSearch
name|hSearch
decl_stmt|;
comment|/* Search variable. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Search variable. */
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* Channel being deleted. */
name|EventScriptRecord
modifier|*
name|sPtr
decl_stmt|,
modifier|*
name|prevPtr
decl_stmt|,
modifier|*
name|nextPtr
decl_stmt|;
comment|/* Variables to loop over all channel events                                  * registered, to delete the ones that refer                                  * to the interpreter being deleted. */
comment|/*      * Delete all the registered channels - this will close channels whose      * refcount reaches zero.      */
name|hTblPtr
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|clientData
expr_stmt|;
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|hTblPtr
argument_list|,
operator|&
name|hSearch
argument_list|)
init|;
name|hPtr
operator|!=
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|hTblPtr
argument_list|,
operator|&
name|hSearch
argument_list|)
control|)
block|{
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
comment|/*          * Remove any fileevents registered in this interpreter.          */
for|for
control|(
name|sPtr
operator|=
name|chanPtr
operator|->
name|scriptRecordPtr
operator|,
name|prevPtr
operator|=
operator|(
name|EventScriptRecord
operator|*
operator|)
name|NULL
init|;
name|sPtr
operator|!=
operator|(
name|EventScriptRecord
operator|*
operator|)
name|NULL
condition|;
name|sPtr
operator|=
name|nextPtr
control|)
block|{
name|nextPtr
operator|=
name|sPtr
operator|->
name|nextPtr
expr_stmt|;
if|if
condition|(
name|sPtr
operator|->
name|interp
operator|==
name|interp
condition|)
block|{
if|if
condition|(
name|prevPtr
operator|==
operator|(
name|EventScriptRecord
operator|*
operator|)
name|NULL
condition|)
block|{
name|chanPtr
operator|->
name|scriptRecordPtr
operator|=
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
name|prevPtr
operator|->
name|nextPtr
operator|=
name|nextPtr
expr_stmt|;
block|}
name|Tcl_DeleteChannelHandler
argument_list|(
operator|(
name|Tcl_Channel
operator|)
name|chanPtr
argument_list|,
name|ChannelEventScriptInvoker
argument_list|,
operator|(
name|ClientData
operator|)
name|sPtr
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|sPtr
operator|->
name|script
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prevPtr
operator|=
name|sPtr
expr_stmt|;
block|}
block|}
comment|/*          * Cannot call Tcl_UnregisterChannel because that procedure calls          * Tcl_GetAssocData to get the channel table, which might already          * be inaccessible from the interpreter structure. Instead, we          * emulate the behavior of Tcl_UnregisterChannel directly here.          */
name|Tcl_DeleteHashEntry
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
name|chanPtr
operator|->
name|refCount
operator|--
expr_stmt|;
if|if
condition|(
name|chanPtr
operator|->
name|refCount
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|BG_FLUSH_SCHEDULED
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|Tcl_Close
argument_list|(
name|interp
argument_list|,
operator|(
name|Tcl_Channel
operator|)
name|chanPtr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Tcl_DeleteHashTable
argument_list|(
name|hTblPtr
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hTblPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CheckForStdChannelsBeingClosed --  *  *	Perform special handling for standard channels being closed. When  *	given a standard channel, if the refcount is now 1, it means that  *	the last reference to the standard channel is being explicitly  *	closed. Now bump the refcount artificially down to 0, to ensure the  *	normal handling of channels being closed will occur. Also reset the  *	static pointer to the channel to NULL, to avoid dangling references.  *  * Results:  *	None.  *  * Side effects:  *	Manipulates the refcount on standard channels. May smash the global  *	static pointer to a standard channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|CheckForStdChannelsBeingClosed
parameter_list|(
name|chan
parameter_list|)
name|Tcl_Channel
name|chan
decl_stmt|;
block|{
name|Channel
modifier|*
name|chanPtr
init|=
operator|(
name|Channel
operator|*
operator|)
name|chan
decl_stmt|;
if|if
condition|(
operator|(
name|chan
operator|==
name|stdinChannel
operator|)
operator|&&
operator|(
name|stdinInitialized
operator|)
condition|)
block|{
if|if
condition|(
name|chanPtr
operator|->
name|refCount
operator|<
literal|2
condition|)
block|{
name|chanPtr
operator|->
name|refCount
operator|=
literal|0
expr_stmt|;
name|stdinChannel
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|chan
operator|==
name|stdoutChannel
operator|)
operator|&&
operator|(
name|stdoutInitialized
operator|)
condition|)
block|{
if|if
condition|(
name|chanPtr
operator|->
name|refCount
operator|<
literal|2
condition|)
block|{
name|chanPtr
operator|->
name|refCount
operator|=
literal|0
expr_stmt|;
name|stdoutChannel
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|chan
operator|==
name|stderrChannel
operator|)
operator|&&
operator|(
name|stderrInitialized
operator|)
condition|)
block|{
if|if
condition|(
name|chanPtr
operator|->
name|refCount
operator|<
literal|2
condition|)
block|{
name|chanPtr
operator|->
name|refCount
operator|=
literal|0
expr_stmt|;
name|stderrChannel
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_UnregisterChannel --  *  *	Deletes the hash entry for a channel associated with an interpreter.  *	If the interpreter given as argument is NULL, it only decrements the  *	reference count.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Deletes the hash entry for a channel associated with an interpreter.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_UnregisterChannel
parameter_list|(
name|interp
parameter_list|,
name|chan
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which channel is defined. */
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* Channel to delete. */
block|{
name|Tcl_HashTable
modifier|*
name|hTblPtr
decl_stmt|;
comment|/* Hash table of channels. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Search variable. */
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The real IO channel. */
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|chan
expr_stmt|;
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|hTblPtr
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclIO"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hTblPtr
operator|==
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
name|hTblPtr
argument_list|,
name|chanPtr
operator|->
name|channelName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
operator|(
name|Channel
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
operator|!=
name|chanPtr
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
name|Tcl_DeleteHashEntry
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
comment|/*          * Remove channel handlers that refer to this interpreter, so that they          * will not be present if the actual close is delayed and more events          * happen on the channel. This may occur if the channel is shared          * between several interpreters, or if the channel has async          * flushing active.          */
name|CleanupChannelHandlers
argument_list|(
name|interp
argument_list|,
name|chanPtr
argument_list|)
expr_stmt|;
block|}
name|chanPtr
operator|->
name|refCount
operator|--
expr_stmt|;
comment|/*      * Perform special handling for standard channels being closed. If the      * refCount is now 1 it means that the last reference to the standard      * channel is being explicitly closed, so bump the refCount down      * artificially to 0. This will ensure that the channel is actually      * closed, below. Also set the static pointer to NULL for the channel.      */
name|CheckForStdChannelsBeingClosed
argument_list|(
name|chan
argument_list|)
expr_stmt|;
comment|/*      * If the refCount reached zero, close the actual channel.      */
if|if
condition|(
name|chanPtr
operator|->
name|refCount
operator|<=
literal|0
condition|)
block|{
comment|/*          * Ensure that if there is another buffer, it gets flushed          * whether or not we are doing a background flush.          */
if|if
condition|(
operator|(
name|chanPtr
operator|->
name|curOutPtr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|chanPtr
operator|->
name|curOutPtr
operator|->
name|nextAdded
operator|>
name|chanPtr
operator|->
name|curOutPtr
operator|->
name|nextRemoved
operator|)
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator||=
name|BUFFER_READY
expr_stmt|;
block|}
name|chanPtr
operator|->
name|flags
operator||=
name|CHANNEL_CLOSED
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|BG_FLUSH_SCHEDULED
operator|)
condition|)
block|{
if|if
condition|(
name|Tcl_Close
argument_list|(
name|interp
argument_list|,
name|chan
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_RegisterChannel --  *  *	Adds an already-open channel to the channel table of an interpreter.  *	If the interpreter passed as argument is NULL, it only increments  *	the channel refCount.  *  * Results:  *	None.  *  * Side effects:  *	May increment the reference count of a channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_RegisterChannel
parameter_list|(
name|interp
parameter_list|,
name|chan
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to add the channel. */
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel to add to this interpreter                                  * channel table. */
block|{
name|Tcl_HashTable
modifier|*
name|hTblPtr
decl_stmt|;
comment|/* Hash table of channels. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Search variable. */
name|int
name|new
decl_stmt|;
comment|/* Is the hash entry new or does it exist? */
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The actual channel. */
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|chan
expr_stmt|;
if|if
condition|(
name|chanPtr
operator|->
name|channelName
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"Tcl_RegisterChannel: channel without name"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|interp
operator|!=
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
condition|)
block|{
name|hTblPtr
operator|=
name|GetChannelTable
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
name|hTblPtr
argument_list|,
name|chanPtr
operator|->
name|channelName
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
condition|)
block|{
return|return;
block|}
name|panic
argument_list|(
literal|"Tcl_RegisterChannel: duplicate channel names"
argument_list|)
expr_stmt|;
block|}
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
operator|(
name|ClientData
operator|)
name|chanPtr
argument_list|)
expr_stmt|;
block|}
name|chanPtr
operator|->
name|refCount
operator|++
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetChannel --  *  *	Finds an existing Tcl_Channel structure by name in a given  *	interpreter. This function is public because it is used by  *	channel-type-specific functions.  *  * Results:  *	A Tcl_Channel or NULL on failure. If failed, interp->result  *	contains an error message. It also returns, in modePtr, the  *	modes in which the channel is opened.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Channel
name|Tcl_GetChannel
parameter_list|(
name|interp
parameter_list|,
name|chanName
parameter_list|,
name|modePtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to find or create                                  * the channel. */
name|char
modifier|*
name|chanName
decl_stmt|;
comment|/* The name of the channel. */
name|int
modifier|*
name|modePtr
decl_stmt|;
comment|/* Where to store the mode in which the                                  * channel was opened? Will contain an ORed                                  * combination of TCL_READABLE and                                  * TCL_WRITABLE, if non-NULL. */
block|{
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The actual channel. */
name|Tcl_HashTable
modifier|*
name|hTblPtr
decl_stmt|;
comment|/* Hash table of channels. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Search variable. */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Translated name. */
comment|/*      * Substitute "stdin", etc.  Note that even though we immediately      * find the channel using Tcl_GetStdChannel, we still need to look      * it up in the specified interpreter to ensure that it is present      * in the channel table.  Otherwise, safe interpreters would always      * have access to the standard channels.      */
name|name
operator|=
name|chanName
expr_stmt|;
if|if
condition|(
operator|(
name|chanName
index|[
literal|0
index|]
operator|==
literal|'s'
operator|)
operator|&&
operator|(
name|chanName
index|[
literal|1
index|]
operator|==
literal|'t'
operator|)
condition|)
block|{
name|chanPtr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|chanName
argument_list|,
literal|"stdin"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDIN
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|chanName
argument_list|,
literal|"stdout"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDOUT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|chanName
argument_list|,
literal|"stderr"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|Tcl_GetStdChannel
argument_list|(
name|TCL_STDERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chanPtr
operator|!=
name|NULL
condition|)
block|{
name|name
operator|=
name|chanPtr
operator|->
name|channelName
expr_stmt|;
block|}
block|}
name|hTblPtr
operator|=
name|GetChannelTable
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
name|hTblPtr
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"can not find channel named \""
argument_list|,
name|chanName
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|modePtr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|modePtr
operator|=
operator|(
name|chanPtr
operator|->
name|flags
operator|&
operator|(
name|TCL_READABLE
operator||
name|TCL_WRITABLE
operator|)
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|Tcl_Channel
operator|)
name|chanPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CreateChannel --  *  *	Creates a new entry in the hash table for a Tcl_Channel  *	record.  *  * Results:  *	Returns the new Tcl_Channel.  *  * Side effects:  *	Creates a new Tcl_Channel instance and inserts it into the  *	hash table.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_Channel
name|Tcl_CreateChannel
parameter_list|(
name|typePtr
parameter_list|,
name|chanName
parameter_list|,
name|instanceData
parameter_list|,
name|mask
parameter_list|)
name|Tcl_ChannelType
modifier|*
name|typePtr
decl_stmt|;
comment|/* The channel type record. */
name|char
modifier|*
name|chanName
decl_stmt|;
comment|/* Name of channel to record. */
name|ClientData
name|instanceData
decl_stmt|;
comment|/* Instance specific data. */
name|int
name|mask
decl_stmt|;
comment|/* TCL_READABLE& TCL_WRITABLE to indicate                                  * if the channel is readable, writable. */
block|{
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The channel structure newly created. */
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|Channel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chanName
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|chanPtr
operator|->
name|channelName
operator|=
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|chanName
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|chanPtr
operator|->
name|channelName
argument_list|,
name|chanName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"Tcl_CreateChannel: NULL channel name"
argument_list|)
expr_stmt|;
block|}
name|chanPtr
operator|->
name|flags
operator|=
name|mask
expr_stmt|;
comment|/*      * Set the channel up initially in AUTO input translation mode to      * accept "\n", "\r" and "\r\n". Output translation mode is set to      * a platform specific default value. The eofChar is set to 0 for both      * input and output, so that Tcl does not look for an in-file EOF      * indicator (e.g. ^Z) and does not append an EOF indicator to files.      */
name|chanPtr
operator|->
name|inputTranslation
operator|=
name|TCL_TRANSLATE_AUTO
expr_stmt|;
name|chanPtr
operator|->
name|outputTranslation
operator|=
name|TCL_PLATFORM_TRANSLATION
expr_stmt|;
name|chanPtr
operator|->
name|inEofChar
operator|=
literal|0
expr_stmt|;
name|chanPtr
operator|->
name|outEofChar
operator|=
literal|0
expr_stmt|;
name|chanPtr
operator|->
name|unreportedError
operator|=
literal|0
expr_stmt|;
name|chanPtr
operator|->
name|instanceData
operator|=
name|instanceData
expr_stmt|;
name|chanPtr
operator|->
name|typePtr
operator|=
name|typePtr
expr_stmt|;
name|chanPtr
operator|->
name|refCount
operator|=
literal|0
expr_stmt|;
name|chanPtr
operator|->
name|closeCbPtr
operator|=
operator|(
name|CloseCallback
operator|*
operator|)
name|NULL
expr_stmt|;
name|chanPtr
operator|->
name|curOutPtr
operator|=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
expr_stmt|;
name|chanPtr
operator|->
name|outQueueHead
operator|=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
expr_stmt|;
name|chanPtr
operator|->
name|outQueueTail
operator|=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
expr_stmt|;
name|chanPtr
operator|->
name|saveInBufPtr
operator|=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
expr_stmt|;
name|chanPtr
operator|->
name|inQueueHead
operator|=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
expr_stmt|;
name|chanPtr
operator|->
name|inQueueTail
operator|=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
expr_stmt|;
name|chanPtr
operator|->
name|chPtr
operator|=
operator|(
name|ChannelHandler
operator|*
operator|)
name|NULL
expr_stmt|;
name|chanPtr
operator|->
name|interestMask
operator|=
literal|0
expr_stmt|;
name|chanPtr
operator|->
name|scriptRecordPtr
operator|=
operator|(
name|EventScriptRecord
operator|*
operator|)
name|NULL
expr_stmt|;
name|chanPtr
operator|->
name|bufSize
operator|=
name|CHANNELBUFFER_DEFAULT_SIZE
expr_stmt|;
name|chanPtr
operator|->
name|timer
operator|=
name|NULL
expr_stmt|;
name|chanPtr
operator|->
name|csPtr
operator|=
name|NULL
expr_stmt|;
comment|/*      * Link the channel into the list of all channels; create an on-exit      * handler if there is not one already, to close off all the channels      * in the list on exit.      */
name|chanPtr
operator|->
name|nextChanPtr
operator|=
name|firstChanPtr
expr_stmt|;
name|firstChanPtr
operator|=
name|chanPtr
expr_stmt|;
if|if
condition|(
operator|!
name|channelExitHandlerCreated
condition|)
block|{
name|channelExitHandlerCreated
operator|=
literal|1
expr_stmt|;
name|Tcl_CreateExitHandler
argument_list|(
name|CloseChannelsOnExit
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/*      * Install this channel in the first empty standard channel slot, if      * the channel was previously closed explicitly.      */
if|if
condition|(
operator|(
name|stdinChannel
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|stdinInitialized
operator|==
literal|1
operator|)
condition|)
block|{
name|Tcl_SetStdChannel
argument_list|(
operator|(
name|Tcl_Channel
operator|)
name|chanPtr
argument_list|,
name|TCL_STDIN
argument_list|)
expr_stmt|;
name|Tcl_RegisterChannel
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|Tcl_Channel
operator|)
name|chanPtr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|stdoutChannel
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|stdoutInitialized
operator|==
literal|1
operator|)
condition|)
block|{
name|Tcl_SetStdChannel
argument_list|(
operator|(
name|Tcl_Channel
operator|)
name|chanPtr
argument_list|,
name|TCL_STDOUT
argument_list|)
expr_stmt|;
name|Tcl_RegisterChannel
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|Tcl_Channel
operator|)
name|chanPtr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|stderrChannel
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|stderrInitialized
operator|==
literal|1
operator|)
condition|)
block|{
name|Tcl_SetStdChannel
argument_list|(
operator|(
name|Tcl_Channel
operator|)
name|chanPtr
argument_list|,
name|TCL_STDERR
argument_list|)
expr_stmt|;
name|Tcl_RegisterChannel
argument_list|(
operator|(
name|Tcl_Interp
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|Tcl_Channel
operator|)
name|chanPtr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|Tcl_Channel
operator|)
name|chanPtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetChannelMode --  *  *	Computes a mask indicating whether the channel is open for  *	reading and writing.  *  * Results:  *	An OR-ed combination of TCL_READABLE and TCL_WRITABLE.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_GetChannelMode
parameter_list|(
name|chan
parameter_list|)
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel for which the mode is                                  * being computed. */
block|{
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The actual channel. */
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|chan
expr_stmt|;
return|return
operator|(
name|chanPtr
operator|->
name|flags
operator|&
operator|(
name|TCL_READABLE
operator||
name|TCL_WRITABLE
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetChannelName --  *  *	Returns the string identifying the channel name.  *  * Results:  *	The string containing the channel name. This memory is  *	owned by the generic layer and should not be modified by  *	the caller.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Tcl_GetChannelName
parameter_list|(
name|chan
parameter_list|)
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel for which to return the name. */
block|{
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The actual channel. */
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|chan
expr_stmt|;
return|return
name|chanPtr
operator|->
name|channelName
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetChannelType --  *  *	Given a channel structure, returns the channel type structure.  *  * Results:  *	Returns a pointer to the channel type structure.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|Tcl_ChannelType
modifier|*
name|Tcl_GetChannelType
parameter_list|(
name|chan
parameter_list|)
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel to return type for. */
block|{
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The actual channel. */
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|chan
expr_stmt|;
return|return
name|chanPtr
operator|->
name|typePtr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetChannelHandle --  *  *	Returns an OS handle associated with a channel.  *  * Results:  *	Returns TCL_OK and places the handle in handlePtr, or returns  *	TCL_ERROR on failure.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_GetChannelHandle
parameter_list|(
name|chan
parameter_list|,
name|direction
parameter_list|,
name|handlePtr
parameter_list|)
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel to get file from. */
name|int
name|direction
decl_stmt|;
comment|/* TCL_WRITABLE or TCL_READABLE. */
name|ClientData
modifier|*
name|handlePtr
decl_stmt|;
comment|/* Where to store handle */
block|{
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The actual channel. */
name|ClientData
name|handle
decl_stmt|;
name|int
name|result
decl_stmt|;
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|chan
expr_stmt|;
name|result
operator|=
call|(
name|chanPtr
operator|->
name|typePtr
operator|->
name|getHandleProc
call|)
argument_list|(
name|chanPtr
operator|->
name|instanceData
argument_list|,
name|direction
argument_list|,
operator|&
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|handlePtr
condition|)
block|{
operator|*
name|handlePtr
operator|=
name|handle
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetChannelInstanceData --  *  *	Returns the client data associated with a channel.  *  * Results:  *	The client data.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|ClientData
name|Tcl_GetChannelInstanceData
parameter_list|(
name|chan
parameter_list|)
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* Channel for which to return client data. */
block|{
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The actual channel. */
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|chan
expr_stmt|;
return|return
name|chanPtr
operator|->
name|instanceData
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * RecycleBuffer --  *  *	Helper function to recycle input and output buffers. Ensures  *	that two input buffers are saved (one in the input queue and  *	another in the saveInBufPtr field) and that curOutPtr is set  *	to a buffer. Only if these conditions are met is the buffer  *	freed to the OS.  *  * Results:  *	None.  *  * Side effects:  *	May free a buffer to the OS.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|RecycleBuffer
parameter_list|(
name|chanPtr
parameter_list|,
name|bufPtr
parameter_list|,
name|mustDiscard
parameter_list|)
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* Channel for which to recycle buffers. */
name|ChannelBuffer
modifier|*
name|bufPtr
decl_stmt|;
comment|/* The buffer to recycle. */
name|int
name|mustDiscard
decl_stmt|;
comment|/* If nonzero, free the buffer to the                                  * OS, always. */
block|{
comment|/*      * Do we have to free the buffer to the OS?      */
if|if
condition|(
name|mustDiscard
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bufPtr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * Only save buffers for the input queue if the channel is readable.      */
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|TCL_READABLE
condition|)
block|{
if|if
condition|(
name|chanPtr
operator|->
name|inQueueHead
operator|==
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|)
block|{
name|chanPtr
operator|->
name|inQueueHead
operator|=
name|bufPtr
expr_stmt|;
name|chanPtr
operator|->
name|inQueueTail
operator|=
name|bufPtr
expr_stmt|;
goto|goto
name|keepit
goto|;
block|}
if|if
condition|(
name|chanPtr
operator|->
name|saveInBufPtr
operator|==
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|)
block|{
name|chanPtr
operator|->
name|saveInBufPtr
operator|=
name|bufPtr
expr_stmt|;
goto|goto
name|keepit
goto|;
block|}
block|}
comment|/*      * Only save buffers for the output queue if the channel is writable.      */
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|TCL_WRITABLE
condition|)
block|{
if|if
condition|(
name|chanPtr
operator|->
name|curOutPtr
operator|==
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|)
block|{
name|chanPtr
operator|->
name|curOutPtr
operator|=
name|bufPtr
expr_stmt|;
goto|goto
name|keepit
goto|;
block|}
block|}
comment|/*      * If we reached this code we return the buffer to the OS.      */
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bufPtr
argument_list|)
expr_stmt|;
return|return;
name|keepit
label|:
name|bufPtr
operator|->
name|nextRemoved
operator|=
literal|0
expr_stmt|;
name|bufPtr
operator|->
name|nextAdded
operator|=
literal|0
expr_stmt|;
name|bufPtr
operator|->
name|nextPtr
operator|=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DiscardOutputQueued --  *  *	Discards all output queued in the output queue of a channel.  *  * Results:  *	None.  *  * Side effects:  *	Recycles buffers.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|DiscardOutputQueued
parameter_list|(
name|chanPtr
parameter_list|)
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The channel for which to discard output. */
block|{
name|ChannelBuffer
modifier|*
name|bufPtr
decl_stmt|;
while|while
condition|(
name|chanPtr
operator|->
name|outQueueHead
operator|!=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|)
block|{
name|bufPtr
operator|=
name|chanPtr
operator|->
name|outQueueHead
expr_stmt|;
name|chanPtr
operator|->
name|outQueueHead
operator|=
name|bufPtr
operator|->
name|nextPtr
expr_stmt|;
name|RecycleBuffer
argument_list|(
name|chanPtr
argument_list|,
name|bufPtr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|chanPtr
operator|->
name|outQueueHead
operator|=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
expr_stmt|;
name|chanPtr
operator|->
name|outQueueTail
operator|=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CheckForDeadChannel --  *  *	This function checks is a given channel is Dead.  *      (A channel that has been closed but not yet deallocated.)  *  * Results:  *	True (1) if channel is Dead, False (0) if channel is Ok  *  * Side effects:  *      None  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CheckForDeadChannel
parameter_list|(
name|interp
parameter_list|,
name|chanPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* For error reporting (can be NULL) */
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The channel to check. */
block|{
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|CHANNEL_DEAD
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|interp
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"unable to access channel: invalid channel"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * FlushChannel --  *  *	This function flushes as much of the queued output as is possible  *	now. If calledFromAsyncFlush is nonzero, it is being called in an  *	event handler to flush channel output asynchronously.  *  * Results:  *	0 if successful, else the error code that was returned by the  *	channel type operation.  *  * Side effects:  *	May produce output on a channel. May block indefinitely if the  *	channel is synchronous. May schedule an async flush on the channel.  *	May recycle memory for buffers in the output queue.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|FlushChannel
parameter_list|(
name|interp
parameter_list|,
name|chanPtr
parameter_list|,
name|calledFromAsyncFlush
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* For error reporting during close. */
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The channel to flush on. */
name|int
name|calledFromAsyncFlush
decl_stmt|;
comment|/* If nonzero then we are being                                          * called from an asynchronous                                          * flush callback. */
block|{
name|ChannelBuffer
modifier|*
name|bufPtr
decl_stmt|;
comment|/* Iterates over buffered output                                          * queue. */
name|int
name|toWrite
decl_stmt|;
comment|/* Amount of output data in current                                          * buffer available to be written. */
name|int
name|written
decl_stmt|;
comment|/* Amount of output data actually                                          * written in current round. */
name|int
name|errorCode
decl_stmt|;
comment|/* Stores POSIX error codes from                                          * channel driver operations. */
name|errorCode
operator|=
literal|0
expr_stmt|;
comment|/*      * Prevent writing on a dead channel -- a channel that has been closed      * but not yet deallocated. This can occur if the exit handler for the      * channel deallocation runs before all channels are deregistered in      * all interpreters.      */
if|if
condition|(
name|CheckForDeadChannel
argument_list|(
name|interp
argument_list|,
name|chanPtr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/*      * Loop over the queued buffers and attempt to flush as      * much as possible of the queued output to the channel.      */
while|while
condition|(
literal|1
condition|)
block|{
comment|/*          * If the queue is empty and there is a ready current buffer, OR if          * the current buffer is full, then move the current buffer to the          * queue.          */
if|if
condition|(
operator|(
operator|(
name|chanPtr
operator|->
name|curOutPtr
operator|!=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|chanPtr
operator|->
name|curOutPtr
operator|->
name|nextAdded
operator|==
name|chanPtr
operator|->
name|curOutPtr
operator|->
name|bufSize
operator|)
operator|)
operator|||
operator|(
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|BUFFER_READY
operator|)
operator|&&
operator|(
name|chanPtr
operator|->
name|outQueueHead
operator|==
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
operator|)
operator|)
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|BUFFER_READY
operator|)
operator|)
expr_stmt|;
name|chanPtr
operator|->
name|curOutPtr
operator|->
name|nextPtr
operator|=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|chanPtr
operator|->
name|outQueueHead
operator|==
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|)
block|{
name|chanPtr
operator|->
name|outQueueHead
operator|=
name|chanPtr
operator|->
name|curOutPtr
expr_stmt|;
block|}
else|else
block|{
name|chanPtr
operator|->
name|outQueueTail
operator|->
name|nextPtr
operator|=
name|chanPtr
operator|->
name|curOutPtr
expr_stmt|;
block|}
name|chanPtr
operator|->
name|outQueueTail
operator|=
name|chanPtr
operator|->
name|curOutPtr
expr_stmt|;
name|chanPtr
operator|->
name|curOutPtr
operator|=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|bufPtr
operator|=
name|chanPtr
operator|->
name|outQueueHead
expr_stmt|;
comment|/*          * If we are not being called from an async flush and an async          * flush is active, we just return without producing any output.          */
if|if
condition|(
operator|(
operator|!
name|calledFromAsyncFlush
operator|)
operator|&&
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|BG_FLUSH_SCHEDULED
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/*          * If the output queue is still empty, break out of the while loop.          */
if|if
condition|(
name|bufPtr
operator|==
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|)
block|{
break|break;
comment|/* Out of the "while (1)". */
block|}
comment|/*          * Produce the output on the channel.          */
name|toWrite
operator|=
name|bufPtr
operator|->
name|nextAdded
operator|-
name|bufPtr
operator|->
name|nextRemoved
expr_stmt|;
name|written
operator|=
call|(
name|chanPtr
operator|->
name|typePtr
operator|->
name|outputProc
call|)
argument_list|(
name|chanPtr
operator|->
name|instanceData
argument_list|,
name|bufPtr
operator|->
name|buf
operator|+
name|bufPtr
operator|->
name|nextRemoved
argument_list|,
name|toWrite
argument_list|,
operator|&
name|errorCode
argument_list|)
expr_stmt|;
comment|/*          * If the write failed completely attempt to start the asynchronous          * flush mechanism and break out of this loop - do not attempt to          * write any more output at this time.          */
if|if
condition|(
name|written
operator|<
literal|0
condition|)
block|{
comment|/*              * If the last attempt to write was interrupted, simply retry.              */
if|if
condition|(
name|errorCode
operator|==
name|EINTR
condition|)
block|{
name|errorCode
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/*              * If the channel is non-blocking and we would have blocked,              * start a background flushing handler and break out of the loop.              */
if|if
condition|(
operator|(
name|errorCode
operator|==
name|EWOULDBLOCK
operator|)
operator|||
operator|(
name|errorCode
operator|==
name|EAGAIN
operator|)
condition|)
block|{
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|CHANNEL_NONBLOCKING
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|BG_FLUSH_SCHEDULED
operator|)
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator||=
name|BG_FLUSH_SCHEDULED
expr_stmt|;
name|UpdateInterest
argument_list|(
name|chanPtr
argument_list|)
expr_stmt|;
block|}
name|errorCode
operator|=
literal|0
expr_stmt|;
break|break;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"Blocking channel driver did not block on output"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*              * Decide whether to report the error upwards or defer it.              */
if|if
condition|(
name|calledFromAsyncFlush
condition|)
block|{
if|if
condition|(
name|chanPtr
operator|->
name|unreportedError
operator|==
literal|0
condition|)
block|{
name|chanPtr
operator|->
name|unreportedError
operator|=
name|errorCode
expr_stmt|;
block|}
block|}
else|else
block|{
name|Tcl_SetErrno
argument_list|(
name|errorCode
argument_list|)
expr_stmt|;
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*              * When we get an error we throw away all the output              * currently queued.              */
name|DiscardOutputQueued
argument_list|(
name|chanPtr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|bufPtr
operator|->
name|nextRemoved
operator|+=
name|written
expr_stmt|;
comment|/*          * If this buffer is now empty, recycle it.          */
if|if
condition|(
name|bufPtr
operator|->
name|nextRemoved
operator|==
name|bufPtr
operator|->
name|nextAdded
condition|)
block|{
name|chanPtr
operator|->
name|outQueueHead
operator|=
name|bufPtr
operator|->
name|nextPtr
expr_stmt|;
if|if
condition|(
name|chanPtr
operator|->
name|outQueueHead
operator|==
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|)
block|{
name|chanPtr
operator|->
name|outQueueTail
operator|=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|RecycleBuffer
argument_list|(
name|chanPtr
argument_list|,
name|bufPtr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Closes "while (1)". */
comment|/*      * If the queue became empty and we have the asynchronous flushing      * mechanism active, cancel the asynchronous flushing.      */
if|if
condition|(
operator|(
name|chanPtr
operator|->
name|outQueueHead
operator|==
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|BG_FLUSH_SCHEDULED
operator|)
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|BG_FLUSH_SCHEDULED
operator|)
operator|)
expr_stmt|;
call|(
name|chanPtr
operator|->
name|typePtr
operator|->
name|watchProc
call|)
argument_list|(
name|chanPtr
operator|->
name|instanceData
argument_list|,
name|chanPtr
operator|->
name|interestMask
argument_list|)
expr_stmt|;
block|}
comment|/*      * If the channel is flagged as closed, delete it when the refCount      * drops to zero, the output queue is empty and there is no output      * in the current output buffer.      */
if|if
condition|(
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|CHANNEL_CLOSED
operator|)
operator|&&
operator|(
name|chanPtr
operator|->
name|refCount
operator|<=
literal|0
operator|)
operator|&&
operator|(
name|chanPtr
operator|->
name|outQueueHead
operator|==
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|chanPtr
operator|->
name|curOutPtr
operator|==
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
operator|)
operator|||
operator|(
name|chanPtr
operator|->
name|curOutPtr
operator|->
name|nextAdded
operator|==
name|chanPtr
operator|->
name|curOutPtr
operator|->
name|nextRemoved
operator|)
operator|)
condition|)
block|{
return|return
name|CloseChannel
argument_list|(
name|interp
argument_list|,
name|chanPtr
argument_list|,
name|errorCode
argument_list|)
return|;
block|}
return|return
name|errorCode
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CloseChannel --  *  *	Utility procedure to close a channel and free its associated  *	resources.  *  * Results:  *	0 on success or a POSIX error code if the operation failed.  *  * Side effects:  *	May close the actual channel; may free memory.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CloseChannel
parameter_list|(
name|interp
parameter_list|,
name|chanPtr
parameter_list|,
name|errorCode
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* For error reporting. */
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The channel to close. */
name|int
name|errorCode
decl_stmt|;
comment|/* Status of operation so far. */
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
comment|/* Of calling driver close                                          * operation. */
name|Channel
modifier|*
name|prevChanPtr
decl_stmt|;
comment|/* Preceding channel in list of                                          * all channels - used to splice a                                          * channel out of the list on close. */
if|if
condition|(
name|chanPtr
operator|==
name|NULL
condition|)
block|{
return|return
name|result
return|;
block|}
comment|/*      * No more input can be consumed so discard any leftover input.      */
name|DiscardInputQueued
argument_list|(
name|chanPtr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*      * Discard a leftover buffer in the current output buffer field.      */
if|if
condition|(
name|chanPtr
operator|->
name|curOutPtr
operator|!=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|chanPtr
operator|->
name|curOutPtr
argument_list|)
expr_stmt|;
name|chanPtr
operator|->
name|curOutPtr
operator|=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/*      * The caller guarantees that there are no more buffers      * queued for output.      */
if|if
condition|(
name|chanPtr
operator|->
name|outQueueHead
operator|!=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"TclFlush, closed channel: queued output left"
argument_list|)
expr_stmt|;
block|}
comment|/*      * If the EOF character is set in the channel, append that to the      * output device.      */
if|if
condition|(
operator|(
name|chanPtr
operator|->
name|outEofChar
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|TCL_WRITABLE
operator|)
condition|)
block|{
name|int
name|dummy
decl_stmt|;
name|char
name|c
decl_stmt|;
name|c
operator|=
operator|(
name|char
operator|)
name|chanPtr
operator|->
name|outEofChar
expr_stmt|;
call|(
name|chanPtr
operator|->
name|typePtr
operator|->
name|outputProc
call|)
argument_list|(
name|chanPtr
operator|->
name|instanceData
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
block|}
comment|/*      * Remove TCL_READABLE and TCL_WRITABLE from chanPtr->flags, so      * that close callbacks can not do input or output (assuming they      * squirreled the channel away in their clientData). This also      * prevents infinite loops if the callback calls any C API that      * could call FlushChannel.      */
name|chanPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|TCL_READABLE
operator||
name|TCL_WRITABLE
operator|)
operator|)
expr_stmt|;
comment|/*      * Splice this channel out of the list of all channels.      */
if|if
condition|(
name|chanPtr
operator|==
name|firstChanPtr
condition|)
block|{
name|firstChanPtr
operator|=
name|chanPtr
operator|->
name|nextChanPtr
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|prevChanPtr
operator|=
name|firstChanPtr
init|;
operator|(
name|prevChanPtr
operator|!=
operator|(
name|Channel
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|prevChanPtr
operator|->
name|nextChanPtr
operator|!=
name|chanPtr
operator|)
condition|;
name|prevChanPtr
operator|=
name|prevChanPtr
operator|->
name|nextChanPtr
control|)
block|{
comment|/* Empty loop body. */
block|}
if|if
condition|(
name|prevChanPtr
operator|==
operator|(
name|Channel
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"FlushChannel: damaged channel list"
argument_list|)
expr_stmt|;
block|}
name|prevChanPtr
operator|->
name|nextChanPtr
operator|=
name|chanPtr
operator|->
name|nextChanPtr
expr_stmt|;
block|}
comment|/*      * OK, close the channel itself.      */
name|result
operator|=
call|(
name|chanPtr
operator|->
name|typePtr
operator|->
name|closeProc
call|)
argument_list|(
name|chanPtr
operator|->
name|instanceData
argument_list|,
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
name|chanPtr
operator|->
name|channelName
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
name|chanPtr
operator|->
name|channelName
argument_list|)
expr_stmt|;
block|}
comment|/*      * If we are being called synchronously, report either      * any latent error on the channel or the current error.      */
if|if
condition|(
name|chanPtr
operator|->
name|unreportedError
operator|!=
literal|0
condition|)
block|{
name|errorCode
operator|=
name|chanPtr
operator|->
name|unreportedError
expr_stmt|;
block|}
if|if
condition|(
name|errorCode
operator|==
literal|0
condition|)
block|{
name|errorCode
operator|=
name|result
expr_stmt|;
if|if
condition|(
name|errorCode
operator|!=
literal|0
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|errorCode
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Cancel any outstanding timer.      */
name|Tcl_DeleteTimerHandler
argument_list|(
name|chanPtr
operator|->
name|timer
argument_list|)
expr_stmt|;
comment|/*      * Mark the channel as deleted by clearing the type structure.      */
name|chanPtr
operator|->
name|typePtr
operator|=
name|NULL
expr_stmt|;
name|Tcl_EventuallyFree
argument_list|(
operator|(
name|ClientData
operator|)
name|chanPtr
argument_list|,
name|TCL_DYNAMIC
argument_list|)
expr_stmt|;
return|return
name|errorCode
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_Close --  *  *	Closes a channel.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Closes the channel if this is the last reference.  *  * NOTE:  *	Tcl_Close removes the channel as far as the user is concerned.  *	However, it may continue to exist for a while longer if it has  *	a background flush scheduled. The device itself is eventually  *	closed and the channel record removed, in CloseChannel, above.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_Close
parameter_list|(
name|interp
parameter_list|,
name|chan
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter for errors. */
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel being closed. Must                                          * not be referenced in any                                          * interpreter. */
block|{
name|ChannelHandler
modifier|*
name|chPtr
decl_stmt|,
modifier|*
name|chNext
decl_stmt|;
comment|/* Iterate over channel handlers. */
name|CloseCallback
modifier|*
name|cbPtr
decl_stmt|;
comment|/* Iterate over close callbacks                                          * for this channel. */
name|EventScriptRecord
modifier|*
name|ePtr
decl_stmt|,
modifier|*
name|eNextPtr
decl_stmt|;
comment|/* Iterate over eventscript records. */
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The real IO channel. */
name|int
name|result
decl_stmt|;
comment|/* Of calling FlushChannel. */
name|NextChannelHandler
modifier|*
name|nhPtr
decl_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
comment|/*      * Perform special handling for standard channels being closed. If the      * refCount is now 1 it means that the last reference to the standard      * channel is being explicitly closed, so bump the refCount down      * artificially to 0. This will ensure that the channel is actually      * closed, below. Also set the static pointer to NULL for the channel.      */
name|CheckForStdChannelsBeingClosed
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|chan
expr_stmt|;
if|if
condition|(
name|chanPtr
operator|->
name|refCount
operator|>
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"called Tcl_Close on channel with refCount> 0"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Remove any references to channel handlers for this channel that      * may be about to be invoked.      */
for|for
control|(
name|nhPtr
operator|=
name|nestedHandlerPtr
init|;
name|nhPtr
operator|!=
operator|(
name|NextChannelHandler
operator|*
operator|)
name|NULL
condition|;
name|nhPtr
operator|=
name|nhPtr
operator|->
name|nestedHandlerPtr
control|)
block|{
if|if
condition|(
name|nhPtr
operator|->
name|nextHandlerPtr
operator|&&
operator|(
name|nhPtr
operator|->
name|nextHandlerPtr
operator|->
name|chanPtr
operator|==
name|chanPtr
operator|)
condition|)
block|{
name|nhPtr
operator|->
name|nextHandlerPtr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/*      * Remove all the channel handler records attached to the channel      * itself.      */
for|for
control|(
name|chPtr
operator|=
name|chanPtr
operator|->
name|chPtr
init|;
name|chPtr
operator|!=
operator|(
name|ChannelHandler
operator|*
operator|)
name|NULL
condition|;
name|chPtr
operator|=
name|chNext
control|)
block|{
name|chNext
operator|=
name|chPtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|chPtr
argument_list|)
expr_stmt|;
block|}
name|chanPtr
operator|->
name|chPtr
operator|=
operator|(
name|ChannelHandler
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/*      * Cancel any pending copy operation.      */
name|StopCopy
argument_list|(
name|chanPtr
operator|->
name|csPtr
argument_list|)
expr_stmt|;
comment|/*      * Must set the interest mask now to 0, otherwise infinite loops      * will occur if Tcl_DoOneEvent is called before the channel is      * finally deleted in FlushChannel. This can happen if the channel      * has a background flush active.      */
name|chanPtr
operator|->
name|interestMask
operator|=
literal|0
expr_stmt|;
comment|/*      * Remove any EventScript records for this channel.      */
for|for
control|(
name|ePtr
operator|=
name|chanPtr
operator|->
name|scriptRecordPtr
init|;
name|ePtr
operator|!=
operator|(
name|EventScriptRecord
operator|*
operator|)
name|NULL
condition|;
name|ePtr
operator|=
name|eNextPtr
control|)
block|{
name|eNextPtr
operator|=
name|ePtr
operator|->
name|nextPtr
expr_stmt|;
name|ckfree
argument_list|(
name|ePtr
operator|->
name|script
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ePtr
argument_list|)
expr_stmt|;
block|}
name|chanPtr
operator|->
name|scriptRecordPtr
operator|=
operator|(
name|EventScriptRecord
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/*      * Invoke the registered close callbacks and delete their records.      */
while|while
condition|(
name|chanPtr
operator|->
name|closeCbPtr
operator|!=
operator|(
name|CloseCallback
operator|*
operator|)
name|NULL
condition|)
block|{
name|cbPtr
operator|=
name|chanPtr
operator|->
name|closeCbPtr
expr_stmt|;
name|chanPtr
operator|->
name|closeCbPtr
operator|=
name|cbPtr
operator|->
name|nextPtr
expr_stmt|;
call|(
name|cbPtr
operator|->
name|proc
call|)
argument_list|(
name|cbPtr
operator|->
name|clientData
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cbPtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * Ensure that the last output buffer will be flushed.      */
if|if
condition|(
operator|(
name|chanPtr
operator|->
name|curOutPtr
operator|!=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|chanPtr
operator|->
name|curOutPtr
operator|->
name|nextAdded
operator|>
name|chanPtr
operator|->
name|curOutPtr
operator|->
name|nextRemoved
operator|)
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator||=
name|BUFFER_READY
expr_stmt|;
block|}
comment|/*      * The call to FlushChannel will flush any queued output and invoke      * the close function of the channel driver, or it will set up the      * channel to be flushed and closed asynchronously.      */
name|chanPtr
operator|->
name|flags
operator||=
name|CHANNEL_CLOSED
expr_stmt|;
name|result
operator|=
name|FlushChannel
argument_list|(
name|interp
argument_list|,
name|chanPtr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_Write --  *  *	Puts a sequence of characters into an output buffer, may queue the  *	buffer for output if it gets full, and also remembers whether the  *	current buffer is ready e.g. if it contains a newline and we are in  *	line buffering mode.  *  * Results:  *	The number of bytes written or -1 in case of error. If -1,  *	Tcl_GetErrno will return the error code.  *  * Side effects:  *	May buffer up output and may cause output to be produced on the  *	channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_Write
parameter_list|(
name|chan
parameter_list|,
name|srcPtr
parameter_list|,
name|slen
parameter_list|)
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel to buffer output for. */
name|char
modifier|*
name|srcPtr
decl_stmt|;
comment|/* Output to buffer. */
name|int
name|slen
decl_stmt|;
comment|/* Its length. Negative means                                          * the output is null terminated                                          * and we must compute its length. */
block|{
name|Channel
modifier|*
name|chanPtr
init|=
operator|(
name|Channel
operator|*
operator|)
name|chan
decl_stmt|;
comment|/*      * Check for unreported error.      */
if|if
condition|(
name|chanPtr
operator|->
name|unreportedError
operator|!=
literal|0
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|chanPtr
operator|->
name|unreportedError
argument_list|)
expr_stmt|;
name|chanPtr
operator|->
name|unreportedError
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*      * If the channel is not open for writing punt.      */
if|if
condition|(
operator|!
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|TCL_WRITABLE
operator|)
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|EACCES
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*      * If the channel is in the middle of a background copy, fail.      */
if|if
condition|(
name|chanPtr
operator|->
name|csPtr
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|EBUSY
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*      * If length passed is negative, assume that the output is null terminated      * and compute its length.      */
if|if
condition|(
name|slen
operator|<
literal|0
condition|)
block|{
name|slen
operator|=
name|strlen
argument_list|(
name|srcPtr
argument_list|)
expr_stmt|;
block|}
return|return
name|DoWrite
argument_list|(
name|chanPtr
argument_list|,
name|srcPtr
argument_list|,
name|slen
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DoWrite --  *  *	Puts a sequence of characters into an output buffer, may queue the  *	buffer for output if it gets full, and also remembers whether the  *	current buffer is ready e.g. if it contains a newline and we are in  *	line buffering mode.  *  * Results:  *	The number of bytes written or -1 in case of error. If -1,  *	Tcl_GetErrno will return the error code.  *  * Side effects:  *	May buffer up output and may cause output to be produced on the  *	channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|DoWrite
parameter_list|(
name|chanPtr
parameter_list|,
name|srcPtr
parameter_list|,
name|slen
parameter_list|)
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The channel to buffer output for. */
name|char
modifier|*
name|srcPtr
decl_stmt|;
comment|/* Data to write. */
name|int
name|slen
decl_stmt|;
comment|/* Number of bytes to write. */
block|{
name|ChannelBuffer
modifier|*
name|outBufPtr
decl_stmt|;
comment|/* Current output buffer. */
name|int
name|foundNewline
decl_stmt|;
comment|/* Did we find a newline in output? */
name|char
modifier|*
name|dPtr
decl_stmt|,
modifier|*
name|sPtr
decl_stmt|;
comment|/* Search variables for newline. */
name|int
name|crsent
decl_stmt|;
comment|/* In CRLF eol translation mode,                                          * remember the fact that a CR was                                          * output to the channel without                                          * its following NL. */
name|int
name|i
decl_stmt|;
comment|/* Loop index for newline search. */
name|int
name|destCopied
decl_stmt|;
comment|/* How many bytes were used in this                                          * destination buffer to hold the                                          * output? */
name|int
name|totalDestCopied
decl_stmt|;
comment|/* How many bytes total were                                          * copied to the channel buffer? */
name|int
name|srcCopied
decl_stmt|;
comment|/* How many bytes were copied from                                          * the source string? */
name|char
modifier|*
name|destPtr
decl_stmt|;
comment|/* Where in line to copy to? */
comment|/*      * If we are in network (or windows) translation mode, record the fact      * that we have not yet sent a CR to the channel.      */
name|crsent
operator|=
literal|0
expr_stmt|;
comment|/*      * Loop filling buffers and flushing them until all output has been      * consumed.      */
name|srcCopied
operator|=
literal|0
expr_stmt|;
name|totalDestCopied
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|slen
operator|>
literal|0
condition|)
block|{
comment|/*          * Make sure there is a current output buffer to accept output.          */
if|if
condition|(
name|chanPtr
operator|->
name|curOutPtr
operator|==
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|)
block|{
name|chanPtr
operator|->
name|curOutPtr
operator|=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|CHANNELBUFFER_HEADER_SIZE
operator|+
name|chanPtr
operator|->
name|bufSize
argument_list|)
argument_list|)
expr_stmt|;
name|chanPtr
operator|->
name|curOutPtr
operator|->
name|nextAdded
operator|=
literal|0
expr_stmt|;
name|chanPtr
operator|->
name|curOutPtr
operator|->
name|nextRemoved
operator|=
literal|0
expr_stmt|;
name|chanPtr
operator|->
name|curOutPtr
operator|->
name|bufSize
operator|=
name|chanPtr
operator|->
name|bufSize
expr_stmt|;
name|chanPtr
operator|->
name|curOutPtr
operator|->
name|nextPtr
operator|=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|outBufPtr
operator|=
name|chanPtr
operator|->
name|curOutPtr
expr_stmt|;
name|destCopied
operator|=
name|outBufPtr
operator|->
name|bufSize
operator|-
name|outBufPtr
operator|->
name|nextAdded
expr_stmt|;
if|if
condition|(
name|destCopied
operator|>
name|slen
condition|)
block|{
name|destCopied
operator|=
name|slen
expr_stmt|;
block|}
name|destPtr
operator|=
name|outBufPtr
operator|->
name|buf
operator|+
name|outBufPtr
operator|->
name|nextAdded
expr_stmt|;
switch|switch
condition|(
name|chanPtr
operator|->
name|outputTranslation
condition|)
block|{
case|case
name|TCL_TRANSLATE_LF
case|:
name|srcCopied
operator|=
name|destCopied
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|destPtr
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|srcPtr
argument_list|,
operator|(
name|size_t
operator|)
name|destCopied
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCL_TRANSLATE_CR
case|:
name|srcCopied
operator|=
name|destCopied
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|destPtr
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|srcPtr
argument_list|,
operator|(
name|size_t
operator|)
name|destCopied
argument_list|)
expr_stmt|;
for|for
control|(
name|dPtr
operator|=
name|destPtr
init|;
name|dPtr
operator|<
name|destPtr
operator|+
name|destCopied
condition|;
name|dPtr
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|dPtr
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|dPtr
operator|=
literal|'\r'
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TCL_TRANSLATE_CRLF
case|:
for|for
control|(
name|srcCopied
operator|=
literal|0
operator|,
name|dPtr
operator|=
name|destPtr
operator|,
name|sPtr
operator|=
name|srcPtr
init|;
name|dPtr
operator|<
name|destPtr
operator|+
name|destCopied
condition|;
name|dPtr
operator|++
operator|,
name|sPtr
operator|++
operator|,
name|srcCopied
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|sPtr
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|crsent
condition|)
block|{
operator|*
name|dPtr
operator|=
literal|'\n'
expr_stmt|;
name|crsent
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dPtr
operator|=
literal|'\r'
expr_stmt|;
name|crsent
operator|=
literal|1
expr_stmt|;
name|sPtr
operator|--
operator|,
name|srcCopied
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|dPtr
operator|=
operator|*
name|sPtr
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TCL_TRANSLATE_AUTO
case|:
name|panic
argument_list|(
literal|"Tcl_Write: AUTO output translation mode not supported"
argument_list|)
expr_stmt|;
default|default:
name|panic
argument_list|(
literal|"Tcl_Write: unknown output translation mode"
argument_list|)
expr_stmt|;
block|}
comment|/*          * The current buffer is ready for output if it is full, or if it          * contains a newline and this channel is line-buffered, or if it          * contains any output and this channel is unbuffered.          */
name|outBufPtr
operator|->
name|nextAdded
operator|+=
name|destCopied
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|BUFFER_READY
operator|)
condition|)
block|{
if|if
condition|(
name|outBufPtr
operator|->
name|nextAdded
operator|==
name|outBufPtr
operator|->
name|bufSize
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator||=
name|BUFFER_READY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|CHANNEL_LINEBUFFERED
condition|)
block|{
for|for
control|(
name|sPtr
operator|=
name|srcPtr
operator|,
name|i
operator|=
literal|0
operator|,
name|foundNewline
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|srcCopied
operator|)
operator|&&
operator|(
operator|!
name|foundNewline
operator|)
condition|;
name|i
operator|++
operator|,
name|sPtr
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|sPtr
operator|==
literal|'\n'
condition|)
block|{
name|foundNewline
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|foundNewline
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator||=
name|BUFFER_READY
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|CHANNEL_UNBUFFERED
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator||=
name|BUFFER_READY
expr_stmt|;
block|}
block|}
name|totalDestCopied
operator|+=
name|srcCopied
expr_stmt|;
name|srcPtr
operator|+=
name|srcCopied
expr_stmt|;
name|slen
operator|-=
name|srcCopied
expr_stmt|;
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|BUFFER_READY
condition|)
block|{
if|if
condition|(
name|FlushChannel
argument_list|(
name|NULL
argument_list|,
name|chanPtr
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
comment|/* Closes "while" */
return|return
name|totalDestCopied
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_Flush --  *  *	Flushes output data on a channel.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	May flush output queued on this channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_Flush
parameter_list|(
name|chan
parameter_list|)
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The Channel to flush. */
block|{
name|int
name|result
decl_stmt|;
comment|/* Of calling FlushChannel. */
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The actual channel. */
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|chan
expr_stmt|;
comment|/*      * Check for unreported error.      */
if|if
condition|(
name|chanPtr
operator|->
name|unreportedError
operator|!=
literal|0
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|chanPtr
operator|->
name|unreportedError
argument_list|)
expr_stmt|;
name|chanPtr
operator|->
name|unreportedError
operator|=
literal|0
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * If the channel is not open for writing punt.      */
if|if
condition|(
operator|!
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|TCL_WRITABLE
operator|)
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|EACCES
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * If the channel is in the middle of a background copy, fail.      */
if|if
condition|(
name|chanPtr
operator|->
name|csPtr
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|EBUSY
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*      * Force current output buffer to be output also.      */
if|if
condition|(
operator|(
name|chanPtr
operator|->
name|curOutPtr
operator|!=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|chanPtr
operator|->
name|curOutPtr
operator|->
name|nextAdded
operator|>
literal|0
operator|)
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator||=
name|BUFFER_READY
expr_stmt|;
block|}
name|result
operator|=
name|FlushChannel
argument_list|(
name|NULL
argument_list|,
name|chanPtr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DiscardInputQueued --  *  *	Discards any input read from the channel but not yet consumed  *	by Tcl reading commands.  *  * Results:  *	None.  *  * Side effects:  *	May discard input from the channel. If discardLastBuffer is zero,  *	leaves one buffer in place for back-filling.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|DiscardInputQueued
parameter_list|(
name|chanPtr
parameter_list|,
name|discardSavedBuffers
parameter_list|)
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* Channel on which to discard                                  * the queued input. */
name|int
name|discardSavedBuffers
decl_stmt|;
comment|/* If non-zero, discard all buffers including                                  * last one. */
block|{
name|ChannelBuffer
modifier|*
name|bufPtr
decl_stmt|,
modifier|*
name|nxtPtr
decl_stmt|;
comment|/* Loop variables. */
name|bufPtr
operator|=
name|chanPtr
operator|->
name|inQueueHead
expr_stmt|;
name|chanPtr
operator|->
name|inQueueHead
operator|=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
expr_stmt|;
name|chanPtr
operator|->
name|inQueueTail
operator|=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
init|;
name|bufPtr
operator|!=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|;
name|bufPtr
operator|=
name|nxtPtr
control|)
block|{
name|nxtPtr
operator|=
name|bufPtr
operator|->
name|nextPtr
expr_stmt|;
name|RecycleBuffer
argument_list|(
name|chanPtr
argument_list|,
name|bufPtr
argument_list|,
name|discardSavedBuffers
argument_list|)
expr_stmt|;
block|}
comment|/*      * If discardSavedBuffers is nonzero, must also discard any previously      * saved buffer in the saveInBufPtr field.      */
if|if
condition|(
name|discardSavedBuffers
condition|)
block|{
if|if
condition|(
name|chanPtr
operator|->
name|saveInBufPtr
operator|!=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|chanPtr
operator|->
name|saveInBufPtr
argument_list|)
expr_stmt|;
name|chanPtr
operator|->
name|saveInBufPtr
operator|=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * GetInput --  *  *	Reads input data from a device or file into an input buffer.  *  * Results:  *	A Posix error code or 0.  *  * Side effects:  *	Reads from the underlying device.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|GetInput
parameter_list|(
name|chanPtr
parameter_list|)
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* Channel to read input from. */
block|{
name|int
name|toRead
decl_stmt|;
comment|/* How much to read? */
name|int
name|result
decl_stmt|;
comment|/* Of calling driver. */
name|int
name|nread
decl_stmt|;
comment|/* How much was read from channel? */
name|ChannelBuffer
modifier|*
name|bufPtr
decl_stmt|;
comment|/* New buffer to add to input queue. */
comment|/*      * Prevent reading from a dead channel -- a channel that has been closed      * but not yet deallocated, which can happen if the exit handler for      * channel cleanup has run but the channel is still registered in some      * interpreter.      */
if|if
condition|(
name|CheckForDeadChannel
argument_list|(
name|NULL
argument_list|,
name|chanPtr
argument_list|)
condition|)
return|return
name|EINVAL
return|;
comment|/*      * See if we can fill an existing buffer. If we can, read only      * as much as will fit in it. Otherwise allocate a new buffer,      * add it to the input queue and attempt to fill it to the max.      */
if|if
condition|(
operator|(
name|chanPtr
operator|->
name|inQueueTail
operator|!=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|chanPtr
operator|->
name|inQueueTail
operator|->
name|nextAdded
operator|<
name|chanPtr
operator|->
name|inQueueTail
operator|->
name|bufSize
operator|)
condition|)
block|{
name|bufPtr
operator|=
name|chanPtr
operator|->
name|inQueueTail
expr_stmt|;
name|toRead
operator|=
name|bufPtr
operator|->
name|bufSize
operator|-
name|bufPtr
operator|->
name|nextAdded
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|chanPtr
operator|->
name|saveInBufPtr
operator|!=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|)
block|{
name|bufPtr
operator|=
name|chanPtr
operator|->
name|saveInBufPtr
expr_stmt|;
name|chanPtr
operator|->
name|saveInBufPtr
operator|=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|bufPtr
operator|=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
operator|(
name|unsigned
operator|)
name|CHANNELBUFFER_HEADER_SIZE
operator|+
name|chanPtr
operator|->
name|bufSize
operator|)
argument_list|)
expr_stmt|;
name|bufPtr
operator|->
name|bufSize
operator|=
name|chanPtr
operator|->
name|bufSize
expr_stmt|;
block|}
name|bufPtr
operator|->
name|nextRemoved
operator|=
literal|0
expr_stmt|;
name|bufPtr
operator|->
name|nextAdded
operator|=
literal|0
expr_stmt|;
name|toRead
operator|=
name|bufPtr
operator|->
name|bufSize
expr_stmt|;
if|if
condition|(
name|chanPtr
operator|->
name|inQueueTail
operator|==
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|)
block|{
name|chanPtr
operator|->
name|inQueueHead
operator|=
name|bufPtr
expr_stmt|;
block|}
else|else
block|{
name|chanPtr
operator|->
name|inQueueTail
operator|->
name|nextPtr
operator|=
name|bufPtr
expr_stmt|;
block|}
name|chanPtr
operator|->
name|inQueueTail
operator|=
name|bufPtr
expr_stmt|;
name|bufPtr
operator|->
name|nextPtr
operator|=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/*      * If EOF is set, we should avoid calling the driver because on some      * platforms it is impossible to read from a device after EOF.      */
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|CHANNEL_EOF
condition|)
block|{
return|return
literal|0
return|;
block|}
name|nread
operator|=
call|(
name|chanPtr
operator|->
name|typePtr
operator|->
name|inputProc
call|)
argument_list|(
name|chanPtr
operator|->
name|instanceData
argument_list|,
name|bufPtr
operator|->
name|buf
operator|+
name|bufPtr
operator|->
name|nextAdded
argument_list|,
name|toRead
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator||=
name|CHANNEL_EOF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nread
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|result
operator|==
name|EWOULDBLOCK
operator|)
operator|||
operator|(
name|result
operator|==
name|EAGAIN
operator|)
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator||=
name|CHANNEL_BLOCKED
expr_stmt|;
name|result
operator|=
name|EAGAIN
expr_stmt|;
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|CHANNEL_NONBLOCKING
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"Blocking channel driver did not block on input"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Tcl_SetErrno
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
else|else
block|{
name|bufPtr
operator|->
name|nextAdded
operator|+=
name|nread
expr_stmt|;
comment|/* 	 * If we get a short read, signal up that we may be BLOCKED. We 	 * should avoid calling the driver because on some platforms we 	 * will block in the low level reading code even though the 	 * channel is set into nonblocking mode. 	 */
if|if
condition|(
name|nread
operator|<
name|toRead
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator||=
name|CHANNEL_BLOCKED
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CopyAndTranslateBuffer --  *  *	Copy at most one buffer of input to the result space, doing  *	eol translations according to mode in effect currently.  *  * Results:  *	Number of characters (as opposed to bytes) copied. May return  *	zero if no input is available to be translated.  *  * Side effects:  *	Consumes buffered input. May deallocate one buffer.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CopyAndTranslateBuffer
parameter_list|(
name|chanPtr
parameter_list|,
name|result
parameter_list|,
name|space
parameter_list|)
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The channel from which to read input. */
name|char
modifier|*
name|result
decl_stmt|;
comment|/* Where to store the copied input. */
name|int
name|space
decl_stmt|;
comment|/* How many bytes are available in result                                  * to store the copied input? */
block|{
name|int
name|bytesInBuffer
decl_stmt|;
comment|/* How many bytes are available to be                                  * copied in the current input buffer? */
name|int
name|copied
decl_stmt|;
comment|/* How many characters were already copied                                  * into the destination space? */
name|ChannelBuffer
modifier|*
name|bufPtr
decl_stmt|;
comment|/* The buffer from which to copy bytes. */
name|char
name|curByte
decl_stmt|;
comment|/* The byte we are currently translating. */
name|int
name|i
decl_stmt|;
comment|/* Iterates over the copied input looking                                  * for the input eofChar. */
comment|/*      * If there is no input at all, return zero. The invariant is that either      * there is no buffer in the queue, or if the first buffer is empty, it      * is also the last buffer (and thus there is no input in the queue).      * Note also that if the buffer is empty, we leave it in the queue.      */
if|if
condition|(
name|chanPtr
operator|->
name|inQueueHead
operator|==
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
name|bufPtr
operator|=
name|chanPtr
operator|->
name|inQueueHead
expr_stmt|;
name|bytesInBuffer
operator|=
name|bufPtr
operator|->
name|nextAdded
operator|-
name|bufPtr
operator|->
name|nextRemoved
expr_stmt|;
if|if
condition|(
name|bytesInBuffer
operator|<
name|space
condition|)
block|{
name|space
operator|=
name|bytesInBuffer
expr_stmt|;
block|}
name|copied
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|chanPtr
operator|->
name|inputTranslation
condition|)
block|{
case|case
name|TCL_TRANSLATE_LF
case|:
if|if
condition|(
name|space
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/*              * Copy the current chunk into the result buffer.              */
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|result
argument_list|,
operator|(
name|VOID
operator|*
operator|)
operator|(
name|bufPtr
operator|->
name|buf
operator|+
name|bufPtr
operator|->
name|nextRemoved
operator|)
argument_list|,
operator|(
name|size_t
operator|)
name|space
argument_list|)
expr_stmt|;
name|bufPtr
operator|->
name|nextRemoved
operator|+=
name|space
expr_stmt|;
name|copied
operator|=
name|space
expr_stmt|;
break|break;
case|case
name|TCL_TRANSLATE_CR
case|:
if|if
condition|(
name|space
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/*              * Copy the current chunk into the result buffer, then              * replace all \r with \n.              */
name|memcpy
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|result
argument_list|,
operator|(
name|VOID
operator|*
operator|)
operator|(
name|bufPtr
operator|->
name|buf
operator|+
name|bufPtr
operator|->
name|nextRemoved
operator|)
argument_list|,
operator|(
name|size_t
operator|)
name|space
argument_list|)
expr_stmt|;
name|bufPtr
operator|->
name|nextRemoved
operator|+=
name|space
expr_stmt|;
for|for
control|(
name|copied
operator|=
literal|0
init|;
name|copied
operator|<
name|space
condition|;
name|copied
operator|++
control|)
block|{
if|if
condition|(
name|result
index|[
name|copied
index|]
operator|==
literal|'\r'
condition|)
block|{
name|result
index|[
name|copied
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TCL_TRANSLATE_CRLF
case|:
comment|/*              * If there is a held-back "\r" at EOF, produce it now.              */
if|if
condition|(
name|space
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|chanPtr
operator|->
name|flags
operator|&
operator|(
name|INPUT_SAW_CR
operator||
name|CHANNEL_EOF
operator|)
operator|)
operator|==
operator|(
name|INPUT_SAW_CR
operator||
name|CHANNEL_EOF
operator|)
condition|)
block|{
name|result
index|[
literal|0
index|]
operator|=
literal|'\r'
expr_stmt|;
name|chanPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|INPUT_SAW_CR
operator|)
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/*              * Copy the current chunk and replace "\r\n" with "\n"              * (but not standalone "\r"!).              */
for|for
control|(
name|copied
operator|=
literal|0
init|;
operator|(
name|copied
operator|<
name|space
operator|)
operator|&&
operator|(
name|bufPtr
operator|->
name|nextRemoved
operator|<
name|bufPtr
operator|->
name|nextAdded
operator|)
condition|;
name|copied
operator|++
control|)
block|{
name|curByte
operator|=
name|bufPtr
operator|->
name|buf
index|[
name|bufPtr
operator|->
name|nextRemoved
index|]
expr_stmt|;
name|bufPtr
operator|->
name|nextRemoved
operator|++
expr_stmt|;
if|if
condition|(
name|curByte
operator|==
literal|'\r'
condition|)
block|{
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|INPUT_SAW_CR
condition|)
block|{
name|result
index|[
name|copied
index|]
operator|=
literal|'\r'
expr_stmt|;
block|}
else|else
block|{
name|chanPtr
operator|->
name|flags
operator||=
name|INPUT_SAW_CR
expr_stmt|;
name|copied
operator|--
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|curByte
operator|==
literal|'\n'
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|INPUT_SAW_CR
operator|)
operator|)
expr_stmt|;
name|result
index|[
name|copied
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|INPUT_SAW_CR
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|INPUT_SAW_CR
operator|)
operator|)
expr_stmt|;
name|result
index|[
name|copied
index|]
operator|=
literal|'\r'
expr_stmt|;
name|bufPtr
operator|->
name|nextRemoved
operator|--
expr_stmt|;
block|}
else|else
block|{
name|result
index|[
name|copied
index|]
operator|=
name|curByte
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|TCL_TRANSLATE_AUTO
case|:
if|if
condition|(
name|space
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/*              * Loop over the current buffer, converting "\r" and "\r\n"              * to "\n".              */
for|for
control|(
name|copied
operator|=
literal|0
init|;
operator|(
name|copied
operator|<
name|space
operator|)
operator|&&
operator|(
name|bufPtr
operator|->
name|nextRemoved
operator|<
name|bufPtr
operator|->
name|nextAdded
operator|)
condition|;
control|)
block|{
name|curByte
operator|=
name|bufPtr
operator|->
name|buf
index|[
name|bufPtr
operator|->
name|nextRemoved
index|]
expr_stmt|;
name|bufPtr
operator|->
name|nextRemoved
operator|++
expr_stmt|;
if|if
condition|(
name|curByte
operator|==
literal|'\r'
condition|)
block|{
name|result
index|[
name|copied
index|]
operator|=
literal|'\n'
expr_stmt|;
name|copied
operator|++
expr_stmt|;
if|if
condition|(
name|bufPtr
operator|->
name|nextRemoved
operator|<
name|bufPtr
operator|->
name|nextAdded
condition|)
block|{
if|if
condition|(
name|bufPtr
operator|->
name|buf
index|[
name|bufPtr
operator|->
name|nextRemoved
index|]
operator|==
literal|'\n'
condition|)
block|{
name|bufPtr
operator|->
name|nextRemoved
operator|++
expr_stmt|;
block|}
name|chanPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|INPUT_SAW_CR
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|chanPtr
operator|->
name|flags
operator||=
name|INPUT_SAW_CR
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|curByte
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|INPUT_SAW_CR
operator|)
condition|)
block|{
name|result
index|[
name|copied
index|]
operator|=
literal|'\n'
expr_stmt|;
name|copied
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|result
index|[
name|copied
index|]
operator|=
name|curByte
expr_stmt|;
name|copied
operator|++
expr_stmt|;
block|}
name|chanPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|INPUT_SAW_CR
operator|)
operator|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|panic
argument_list|(
literal|"unknown eol translation mode"
argument_list|)
expr_stmt|;
block|}
comment|/*      * If an in-stream EOF character is set for this channel,, check that      * the input we copied so far does not contain the EOF char. If it does,      * copy only up to and excluding that character.      */
if|if
condition|(
name|chanPtr
operator|->
name|inEofChar
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|copied
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|result
index|[
name|i
index|]
operator|==
operator|(
name|char
operator|)
name|chanPtr
operator|->
name|inEofChar
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|copied
condition|)
block|{
comment|/*              * Set sticky EOF so that no further input is presented              * to the caller.              */
name|chanPtr
operator|->
name|flags
operator||=
operator|(
name|CHANNEL_EOF
operator||
name|CHANNEL_STICKY_EOF
operator|)
expr_stmt|;
comment|/*              * Reset the start of valid data in the input buffer to the              * position of the eofChar, so that subsequent reads will              * encounter it immediately. First we set it to the position              * of the last byte consumed if all result bytes were the              * product of one input byte; since it is possible that "\r\n"              * contracted to "\n" in the result, we have to search back              * from that position until we find the eofChar, because it              * is possible that its actual position in the buffer is n              * bytes further back (n is the number of "\r\n" sequences              * that were contracted to "\n" in the result).              */
name|bufPtr
operator|->
name|nextRemoved
operator|-=
operator|(
name|copied
operator|-
name|i
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|bufPtr
operator|->
name|nextRemoved
operator|>
literal|0
operator|)
operator|&&
operator|(
name|bufPtr
operator|->
name|buf
index|[
name|bufPtr
operator|->
name|nextRemoved
index|]
operator|!=
operator|(
name|char
operator|)
name|chanPtr
operator|->
name|inEofChar
operator|)
condition|)
block|{
name|bufPtr
operator|->
name|nextRemoved
operator|--
expr_stmt|;
block|}
name|copied
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/*      * If the current buffer is empty recycle it.      */
if|if
condition|(
name|bufPtr
operator|->
name|nextRemoved
operator|==
name|bufPtr
operator|->
name|nextAdded
condition|)
block|{
name|chanPtr
operator|->
name|inQueueHead
operator|=
name|bufPtr
operator|->
name|nextPtr
expr_stmt|;
if|if
condition|(
name|chanPtr
operator|->
name|inQueueHead
operator|==
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|)
block|{
name|chanPtr
operator|->
name|inQueueTail
operator|=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|RecycleBuffer
argument_list|(
name|chanPtr
argument_list|,
name|bufPtr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*      * Return the number of characters copied into the result buffer.      * This may be different from the number of bytes consumed, because      * of EOL translations.      */
return|return
name|copied
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * ScanBufferForEOL --  *  *	Scans one buffer for EOL according to the specified EOL  *	translation mode. If it sees the input eofChar for the channel  *	it stops also.  *  * Results:  *	TRUE if EOL is found, FALSE otherwise. Also sets output parameter  *	bytesToEOLPtr to the number of bytes so far to EOL, and crSeenPtr  *	to whether a "\r" was seen.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ScanBufferForEOL
parameter_list|(
name|chanPtr
parameter_list|,
name|bufPtr
parameter_list|,
name|translation
parameter_list|,
name|eofChar
parameter_list|,
name|bytesToEOLPtr
parameter_list|,
name|crSeenPtr
parameter_list|)
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
name|ChannelBuffer
modifier|*
name|bufPtr
decl_stmt|;
comment|/* Buffer to scan for EOL. */
name|Tcl_EolTranslation
name|translation
decl_stmt|;
comment|/* Translation mode to use. */
name|int
name|eofChar
decl_stmt|;
comment|/* EOF char to look for. */
name|int
modifier|*
name|bytesToEOLPtr
decl_stmt|;
comment|/* Running counter. */
name|int
modifier|*
name|crSeenPtr
decl_stmt|;
comment|/* Has "\r" been seen? */
block|{
name|char
modifier|*
name|rPtr
decl_stmt|;
comment|/* Iterates over input string. */
name|char
modifier|*
name|sPtr
decl_stmt|;
comment|/* Where to stop search? */
name|int
name|EOLFound
decl_stmt|;
name|int
name|bytesToEOL
decl_stmt|;
for|for
control|(
name|EOLFound
operator|=
literal|0
operator|,
name|rPtr
operator|=
name|bufPtr
operator|->
name|buf
operator|+
name|bufPtr
operator|->
name|nextRemoved
operator|,
name|sPtr
operator|=
name|bufPtr
operator|->
name|buf
operator|+
name|bufPtr
operator|->
name|nextAdded
operator|,
name|bytesToEOL
operator|=
operator|*
name|bytesToEOLPtr
init|;
operator|(
operator|!
name|EOLFound
operator|)
operator|&&
operator|(
name|rPtr
operator|<
name|sPtr
operator|)
condition|;
name|rPtr
operator|++
control|)
block|{
switch|switch
condition|(
name|translation
condition|)
block|{
case|case
name|TCL_TRANSLATE_AUTO
case|:
if|if
condition|(
operator|(
operator|*
name|rPtr
operator|==
operator|(
name|char
operator|)
name|eofChar
operator|)
operator|&&
operator|(
name|eofChar
operator|!=
literal|0
operator|)
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator||=
operator|(
name|CHANNEL_EOF
operator||
name|CHANNEL_STICKY_EOF
operator|)
expr_stmt|;
name|EOLFound
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|rPtr
operator|==
literal|'\n'
condition|)
block|{
comment|/*                      * CopyAndTranslateBuffer wants to know the length                      * of the result, not the input. The input is one                      * larger because "\r\n" shrinks to "\n".                      */
if|if
condition|(
operator|!
operator|(
operator|*
name|crSeenPtr
operator|)
condition|)
block|{
name|bytesToEOL
operator|++
expr_stmt|;
name|EOLFound
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * This is a lf at the begining of a buffer 			 * where the previous buffer ended in a cr. 			 * Consume this lf because we've already emitted 			 * the newline for this crlf sequence. ALSO, if                          * bytesToEOL is 0 (which means that we are at the                          * first character of the scan), unset the                          * INPUT_SAW_CR flag in the channel, because we                          * already handled it; leaving it set would cause                          * CopyAndTranslateBuffer to potentially consume                          * another lf if one follows the current byte. 			 */
name|bufPtr
operator|->
name|nextRemoved
operator|++
expr_stmt|;
operator|*
name|crSeenPtr
operator|=
literal|0
expr_stmt|;
name|chanPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|INPUT_SAW_CR
operator|)
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|rPtr
operator|==
literal|'\r'
condition|)
block|{
name|bytesToEOL
operator|++
expr_stmt|;
name|EOLFound
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|crSeenPtr
operator|=
literal|0
expr_stmt|;
name|bytesToEOL
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|TCL_TRANSLATE_LF
case|:
if|if
condition|(
operator|(
operator|*
name|rPtr
operator|==
operator|(
name|char
operator|)
name|eofChar
operator|)
operator|&&
operator|(
name|eofChar
operator|!=
literal|0
operator|)
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator||=
operator|(
name|CHANNEL_EOF
operator||
name|CHANNEL_STICKY_EOF
operator|)
expr_stmt|;
name|EOLFound
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|rPtr
operator|==
literal|'\n'
condition|)
block|{
name|EOLFound
operator|=
literal|1
expr_stmt|;
block|}
name|bytesToEOL
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|TCL_TRANSLATE_CR
case|:
if|if
condition|(
operator|(
operator|*
name|rPtr
operator|==
operator|(
name|char
operator|)
name|eofChar
operator|)
operator|&&
operator|(
name|eofChar
operator|!=
literal|0
operator|)
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator||=
operator|(
name|CHANNEL_EOF
operator||
name|CHANNEL_STICKY_EOF
operator|)
expr_stmt|;
name|EOLFound
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|rPtr
operator|==
literal|'\r'
condition|)
block|{
name|EOLFound
operator|=
literal|1
expr_stmt|;
block|}
name|bytesToEOL
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|TCL_TRANSLATE_CRLF
case|:
if|if
condition|(
operator|(
operator|*
name|rPtr
operator|==
operator|(
name|char
operator|)
name|eofChar
operator|)
operator|&&
operator|(
name|eofChar
operator|!=
literal|0
operator|)
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator||=
operator|(
name|CHANNEL_EOF
operator||
name|CHANNEL_STICKY_EOF
operator|)
expr_stmt|;
name|EOLFound
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|rPtr
operator|==
literal|'\n'
condition|)
block|{
comment|/*                      * CopyAndTranslateBuffer wants to know the length                      * of the result, not the input. The input is one                      * larger because crlf shrinks to lf.                      */
if|if
condition|(
operator|*
name|crSeenPtr
condition|)
block|{
name|EOLFound
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|bytesToEOL
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|*
name|rPtr
operator|==
literal|'\r'
condition|)
block|{
operator|*
name|crSeenPtr
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|crSeenPtr
operator|=
literal|0
expr_stmt|;
block|}
name|bytesToEOL
operator|++
expr_stmt|;
block|}
break|break;
default|default:
name|panic
argument_list|(
literal|"unknown eol translation mode"
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|bytesToEOLPtr
operator|=
name|bytesToEOL
expr_stmt|;
return|return
name|EOLFound
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * ScanInputForEOL --  *  *	Scans queued input for chanPtr for an end of line (according to the  *	current EOL translation mode) and returns the number of bytes  *	upto and including the end of line, or -1 if none was found.  *  * Results:  *	Count of bytes upto and including the end of line if one is present  *	or -1 if none was found. Also returns in an output parameter the  *	number of bytes queued if no end of line was found.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ScanInputForEOL
parameter_list|(
name|chanPtr
parameter_list|,
name|bytesQueuedPtr
parameter_list|)
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* Channel for which to scan queued                                  * input for end of line. */
name|int
modifier|*
name|bytesQueuedPtr
decl_stmt|;
comment|/* Where to store the number of bytes                                  * currently queued if no end of line                                  * was found. */
block|{
name|ChannelBuffer
modifier|*
name|bufPtr
decl_stmt|;
comment|/* Iterates over queued buffers. */
name|int
name|bytesToEOL
decl_stmt|;
comment|/* How many bytes to end of line? */
name|int
name|EOLFound
decl_stmt|;
comment|/* Did we find an end of line? */
name|int
name|crSeen
decl_stmt|;
comment|/* Did we see a "\r" in CRLF mode? */
operator|*
name|bytesQueuedPtr
operator|=
literal|0
expr_stmt|;
name|bytesToEOL
operator|=
literal|0
expr_stmt|;
name|EOLFound
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bufPtr
operator|=
name|chanPtr
operator|->
name|inQueueHead
operator|,
name|crSeen
operator|=
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|INPUT_SAW_CR
operator|)
condition|?
literal|1
else|:
literal|0
init|;
operator|(
operator|!
name|EOLFound
operator|)
operator|&&
operator|(
name|bufPtr
operator|!=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
operator|)
condition|;
name|bufPtr
operator|=
name|bufPtr
operator|->
name|nextPtr
control|)
block|{
name|EOLFound
operator|=
name|ScanBufferForEOL
argument_list|(
name|chanPtr
argument_list|,
name|bufPtr
argument_list|,
name|chanPtr
operator|->
name|inputTranslation
argument_list|,
name|chanPtr
operator|->
name|inEofChar
argument_list|,
operator|&
name|bytesToEOL
argument_list|,
operator|&
name|crSeen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|EOLFound
operator|==
literal|0
condition|)
block|{
operator|*
name|bytesQueuedPtr
operator|=
name|bytesToEOL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|bytesToEOL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * GetEOL --  *  *	Accumulate input into the channel input buffer queue until an  *	end of line has been seen.  *  * Results:  *	Number of bytes buffered (at least 1) or -1 on failure.  *  * Side effects:  *	Consumes input from the channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|GetEOL
parameter_list|(
name|chanPtr
parameter_list|)
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* Channel to queue input on. */
block|{
name|int
name|bytesToEOL
decl_stmt|;
comment|/* How many bytes in buffer up to and                                  * including the end of line? */
name|int
name|bytesQueued
decl_stmt|;
comment|/* How many bytes are queued currently                                  * in the input chain of the channel? */
comment|/*      * Check for unreported error.      */
if|if
condition|(
name|chanPtr
operator|->
name|unreportedError
operator|!=
literal|0
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|chanPtr
operator|->
name|unreportedError
argument_list|)
expr_stmt|;
name|chanPtr
operator|->
name|unreportedError
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*      * Punt if the channel is not opened for reading.      */
if|if
condition|(
operator|!
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|TCL_READABLE
operator|)
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|EACCES
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*      * If the channel is in the middle of a background copy, fail.      */
if|if
condition|(
name|chanPtr
operator|->
name|csPtr
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|EBUSY
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*      * If we have not encountered a sticky EOF, clear the EOF bit      * (sticky EOF is set if we have seen the input eofChar, to prevent      * reading beyond the eofChar). Also, always clear the BLOCKED bit.      * We want to discover these conditions anew in each operation.      */
if|if
condition|(
operator|!
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|CHANNEL_STICKY_EOF
operator|)
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|CHANNEL_EOF
operator|)
operator|)
expr_stmt|;
block|}
name|chanPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|CHANNEL_BLOCKED
operator||
name|CHANNEL_GETS_BLOCKED
operator|)
operator|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|bytesToEOL
operator|=
name|ScanInputForEOL
argument_list|(
name|chanPtr
argument_list|,
operator|&
name|bytesQueued
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytesToEOL
operator|>
literal|0
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|CHANNEL_BLOCKED
operator|)
operator|)
expr_stmt|;
return|return
name|bytesToEOL
return|;
block|}
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|CHANNEL_EOF
condition|)
block|{
comment|/* 	     * Boundary case where cr was at the end of the previous buffer 	     * and this buffer just has a newline.  At EOF our caller wants 	     * to see -1 for the line length. 	     */
return|return
operator|(
name|bytesQueued
operator|==
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
name|bytesQueued
return|;
block|}
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|CHANNEL_BLOCKED
condition|)
block|{
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|CHANNEL_NONBLOCKING
condition|)
block|{
goto|goto
name|blocked
goto|;
block|}
name|chanPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|CHANNEL_BLOCKED
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|GetInput
argument_list|(
name|chanPtr
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|blocked
goto|;
block|}
block|}
name|blocked
label|:
comment|/*      * We didn't get a complete line so we need to indicate to UpdateInterest      * that the gets blocked.  It will wait for more data instead of firing      * a timer, avoiding a busy wait.  This is where we are assuming that the      * next operation is a gets.  No more file events will be delivered on       * this channel until new data arrives or some operation is performed      * on the channel (e.g. gets, read, fconfigure) that changes the blocking      * state.  Note that this means a file event will not be delivered even      * though a read would be able to consume the buffered data.      */
name|chanPtr
operator|->
name|flags
operator||=
name|CHANNEL_GETS_BLOCKED
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_Read --  *  *	Reads a given number of characters from a channel.  *  * Results:  *	The number of characters read, or -1 on error. Use Tcl_GetErrno()  *	to retrieve the error code for the error that occurred.  *  * Side effects:  *	May cause input to be buffered.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_Read
parameter_list|(
name|chan
parameter_list|,
name|bufPtr
parameter_list|,
name|toRead
parameter_list|)
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel from which to read. */
name|char
modifier|*
name|bufPtr
decl_stmt|;
comment|/* Where to store input read. */
name|int
name|toRead
decl_stmt|;
comment|/* Maximum number of characters to read. */
block|{
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The real IO channel. */
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|chan
expr_stmt|;
comment|/*      * Check for unreported error.      */
if|if
condition|(
name|chanPtr
operator|->
name|unreportedError
operator|!=
literal|0
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|chanPtr
operator|->
name|unreportedError
argument_list|)
expr_stmt|;
name|chanPtr
operator|->
name|unreportedError
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*      * Punt if the channel is not opened for reading.      */
if|if
condition|(
operator|!
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|TCL_READABLE
operator|)
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|EACCES
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*      * If the channel is in the middle of a background copy, fail.      */
if|if
condition|(
name|chanPtr
operator|->
name|csPtr
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|EBUSY
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|DoRead
argument_list|(
name|chanPtr
argument_list|,
name|bufPtr
argument_list|,
name|toRead
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DoRead --  *  *	Reads a given number of characters from a channel.  *  * Results:  *	The number of characters read, or -1 on error. Use Tcl_GetErrno()  *	to retrieve the error code for the error that occurred.  *  * Side effects:  *	May cause input to be buffered.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|DoRead
parameter_list|(
name|chanPtr
parameter_list|,
name|bufPtr
parameter_list|,
name|toRead
parameter_list|)
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The channel from which to read. */
name|char
modifier|*
name|bufPtr
decl_stmt|;
comment|/* Where to store input read. */
name|int
name|toRead
decl_stmt|;
comment|/* Maximum number of characters to read. */
block|{
name|int
name|copied
decl_stmt|;
comment|/* How many characters were copied into                                  * the result string? */
name|int
name|copiedNow
decl_stmt|;
comment|/* How many characters were copied from                                  * the current input buffer? */
name|int
name|result
decl_stmt|;
comment|/* Of calling GetInput. */
comment|/*      * If we have not encountered a sticky EOF, clear the EOF bit. Either      * way clear the BLOCKED bit. We want to discover these anew during      * each operation.      */
if|if
condition|(
operator|!
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|CHANNEL_STICKY_EOF
operator|)
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|CHANNEL_EOF
operator|)
operator|)
expr_stmt|;
block|}
name|chanPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|CHANNEL_BLOCKED
operator||
name|CHANNEL_GETS_BLOCKED
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|copied
operator|=
literal|0
init|;
name|copied
operator|<
name|toRead
condition|;
name|copied
operator|+=
name|copiedNow
control|)
block|{
name|copiedNow
operator|=
name|CopyAndTranslateBuffer
argument_list|(
name|chanPtr
argument_list|,
name|bufPtr
operator|+
name|copied
argument_list|,
name|toRead
operator|-
name|copied
argument_list|)
expr_stmt|;
if|if
condition|(
name|copiedNow
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|CHANNEL_EOF
condition|)
block|{
return|return
name|copied
return|;
block|}
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|CHANNEL_BLOCKED
condition|)
block|{
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|CHANNEL_NONBLOCKING
condition|)
block|{
return|return
name|copied
return|;
block|}
name|chanPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|CHANNEL_BLOCKED
operator|)
operator|)
expr_stmt|;
block|}
name|result
operator|=
name|GetInput
argument_list|(
name|chanPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|EAGAIN
condition|)
block|{
return|return
name|copied
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
name|chanPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|CHANNEL_BLOCKED
operator|)
operator|)
expr_stmt|;
return|return
name|copied
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_Gets --  *  *	Reads a complete line of input from the channel into a  *	Tcl_DString.  *  * Results:  *	Length of line read or -1 if error, EOF or blocked. If -1, use  *	Tcl_GetErrno() to retrieve the POSIX error code for the  *	error or condition that occurred.  *  * Side effects:  *	May flush output on the channel. May cause input to be  *	consumed from the channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_Gets
parameter_list|(
name|chan
parameter_list|,
name|lineRead
parameter_list|)
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* Channel from which to read. */
name|Tcl_DString
modifier|*
name|lineRead
decl_stmt|;
comment|/* The characters of the line read                                  * (excluding the terminating newline if                                  * present) will be appended to this                                  * DString. The caller must have initialized                                  * it and is responsible for managing the                                  * storage. */
block|{
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The channel to read from. */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Points into DString where data                                  * will be stored. */
name|int
name|offset
decl_stmt|;
comment|/* Offset from start of DString at                                  * which to append the line just read. */
name|int
name|copiedTotal
decl_stmt|;
comment|/* Accumulates total length of input copied. */
name|int
name|copiedNow
decl_stmt|;
comment|/* How many bytes were copied from the                                  * current input buffer? */
name|int
name|lineLen
decl_stmt|;
comment|/* Length of line read, including the                                  * translated newline. If this is zero                                  * and neither EOF nor BLOCKED is set,                                  * the current line is empty. */
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|chan
expr_stmt|;
name|lineLen
operator|=
name|GetEOL
argument_list|(
name|chanPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|lineLen
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|offset
operator|=
name|Tcl_DStringLength
argument_list|(
name|lineRead
argument_list|)
expr_stmt|;
name|Tcl_DStringSetLength
argument_list|(
name|lineRead
argument_list|,
name|lineLen
operator|+
name|offset
argument_list|)
expr_stmt|;
name|buf
operator|=
name|Tcl_DStringValue
argument_list|(
name|lineRead
argument_list|)
operator|+
name|offset
expr_stmt|;
for|for
control|(
name|copiedTotal
operator|=
literal|0
init|;
name|copiedTotal
operator|<
name|lineLen
condition|;
name|copiedTotal
operator|+=
name|copiedNow
control|)
block|{
name|copiedNow
operator|=
name|CopyAndTranslateBuffer
argument_list|(
name|chanPtr
argument_list|,
name|buf
operator|+
name|copiedTotal
argument_list|,
name|lineLen
operator|-
name|copiedTotal
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|copiedTotal
operator|>
literal|0
operator|)
operator|&&
operator|(
name|buf
index|[
name|copiedTotal
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|copiedTotal
operator|--
expr_stmt|;
block|}
name|Tcl_DStringSetLength
argument_list|(
name|lineRead
argument_list|,
name|copiedTotal
operator|+
name|offset
argument_list|)
expr_stmt|;
return|return
name|copiedTotal
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetsObj --  *  *	Reads a complete line of input from the channel into a  *	string object.  *  * Results:  *	Length of line read or -1 if error, EOF or blocked. If -1, use  *	Tcl_GetErrno() to retrieve the POSIX error code for the  *	error or condition that occurred.  *  * Side effects:  *	May flush output on the channel. May cause input to be  *	consumed from the channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_GetsObj
parameter_list|(
name|chan
parameter_list|,
name|objPtr
parameter_list|)
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* Channel from which to read. */
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/* The characters of the line read                                  * (excluding the terminating newline if                                  * present) will be appended to this                                  * object. The caller must have initialized                                  * it and is responsible for managing the                                  * storage. */
block|{
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The channel to read from. */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Points into DString where data                                  * will be stored. */
name|int
name|offset
decl_stmt|;
comment|/* Offset from start of DString at                                  * which to append the line just read. */
name|int
name|copiedTotal
decl_stmt|;
comment|/* Accumulates total length of input copied. */
name|int
name|copiedNow
decl_stmt|;
comment|/* How many bytes were copied from the                                  * current input buffer? */
name|int
name|lineLen
decl_stmt|;
comment|/* Length of line read, including the                                  * translated newline. If this is zero                                  * and neither EOF nor BLOCKED is set,                                  * the current line is empty. */
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|chan
expr_stmt|;
name|lineLen
operator|=
name|GetEOL
argument_list|(
name|chanPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|lineLen
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
operator|(
name|void
operator|)
name|Tcl_GetStringFromObj
argument_list|(
name|objPtr
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|Tcl_SetObjLength
argument_list|(
name|objPtr
argument_list|,
name|lineLen
operator|+
name|offset
argument_list|)
expr_stmt|;
name|buf
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objPtr
argument_list|,
name|NULL
argument_list|)
operator|+
name|offset
expr_stmt|;
for|for
control|(
name|copiedTotal
operator|=
literal|0
init|;
name|copiedTotal
operator|<
name|lineLen
condition|;
name|copiedTotal
operator|+=
name|copiedNow
control|)
block|{
name|copiedNow
operator|=
name|CopyAndTranslateBuffer
argument_list|(
name|chanPtr
argument_list|,
name|buf
operator|+
name|copiedTotal
argument_list|,
name|lineLen
operator|-
name|copiedTotal
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|copiedTotal
operator|>
literal|0
operator|)
operator|&&
operator|(
name|buf
index|[
name|copiedTotal
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|copiedTotal
operator|--
expr_stmt|;
block|}
name|Tcl_SetObjLength
argument_list|(
name|objPtr
argument_list|,
name|copiedTotal
operator|+
name|offset
argument_list|)
expr_stmt|;
return|return
name|copiedTotal
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_Ungets --  *  *	Causes the supplied string to be added to the input queue of  *	the channel, at either the head or tail of the queue.  *  * Results:  *	The number of bytes stored in the channel, or -1 on error.  *  * Side effects:  *	Adds input to the input queue of a channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_Ungets
parameter_list|(
name|chan
parameter_list|,
name|str
parameter_list|,
name|len
parameter_list|,
name|atEnd
parameter_list|)
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel for which to add the input. */
name|char
modifier|*
name|str
decl_stmt|;
comment|/* The input itself. */
name|int
name|len
decl_stmt|;
comment|/* The length of the input. */
name|int
name|atEnd
decl_stmt|;
comment|/* If non-zero, add at end of queue; otherwise                                  * add at head of queue. */
block|{
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The real IO channel. */
name|ChannelBuffer
modifier|*
name|bufPtr
decl_stmt|;
comment|/* Buffer to contain the data. */
name|int
name|i
decl_stmt|;
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|chan
expr_stmt|;
comment|/*      * Check for unreported error.      */
if|if
condition|(
name|chanPtr
operator|->
name|unreportedError
operator|!=
literal|0
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|chanPtr
operator|->
name|unreportedError
argument_list|)
expr_stmt|;
name|chanPtr
operator|->
name|unreportedError
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*      * Punt if the channel is not opened for reading.      */
if|if
condition|(
operator|!
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|TCL_READABLE
operator|)
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|EACCES
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*      * If the channel is in the middle of a background copy, fail.      */
if|if
condition|(
name|chanPtr
operator|->
name|csPtr
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|EBUSY
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*      * If we have encountered a sticky EOF, just punt without storing.      * (sticky EOF is set if we have seen the input eofChar, to prevent      * reading beyond the eofChar). Otherwise, clear the EOF flags, and      * clear the BLOCKED bit. We want to discover these conditions anew      * in each operation.      */
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|CHANNEL_STICKY_EOF
condition|)
block|{
return|return
name|len
return|;
block|}
name|chanPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|CHANNEL_BLOCKED
operator||
name|CHANNEL_EOF
operator|)
operator|)
expr_stmt|;
name|bufPtr
operator|=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|CHANNELBUFFER_HEADER_SIZE
operator|+
name|len
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|bufPtr
operator|->
name|buf
index|[
name|i
index|]
operator|=
name|str
index|[
name|i
index|]
expr_stmt|;
block|}
name|bufPtr
operator|->
name|bufSize
operator|=
name|len
expr_stmt|;
name|bufPtr
operator|->
name|nextAdded
operator|=
name|len
expr_stmt|;
name|bufPtr
operator|->
name|nextRemoved
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chanPtr
operator|->
name|inQueueHead
operator|==
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|)
block|{
name|bufPtr
operator|->
name|nextPtr
operator|=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
expr_stmt|;
name|chanPtr
operator|->
name|inQueueHead
operator|=
name|bufPtr
expr_stmt|;
name|chanPtr
operator|->
name|inQueueTail
operator|=
name|bufPtr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atEnd
condition|)
block|{
name|bufPtr
operator|->
name|nextPtr
operator|=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
expr_stmt|;
name|chanPtr
operator|->
name|inQueueTail
operator|->
name|nextPtr
operator|=
name|bufPtr
expr_stmt|;
name|chanPtr
operator|->
name|inQueueTail
operator|=
name|bufPtr
expr_stmt|;
block|}
else|else
block|{
name|bufPtr
operator|->
name|nextPtr
operator|=
name|chanPtr
operator|->
name|inQueueHead
expr_stmt|;
name|chanPtr
operator|->
name|inQueueHead
operator|=
name|bufPtr
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_Seek --  *  *	Implements seeking on Tcl Channels. This is a public function  *	so that other C facilities may be implemented on top of it.  *  * Results:  *	The new access point or -1 on error. If error, use Tcl_GetErrno()  *	to retrieve the POSIX error code for the error that occurred.  *  * Side effects:  *	May flush output on the channel. May discard queued input.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_Seek
parameter_list|(
name|chan
parameter_list|,
name|offset
parameter_list|,
name|mode
parameter_list|)
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel on which to seek. */
name|int
name|offset
decl_stmt|;
comment|/* Offset to seek to. */
name|int
name|mode
decl_stmt|;
comment|/* Relative to which location to seek? */
block|{
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The real IO channel. */
name|ChannelBuffer
modifier|*
name|bufPtr
decl_stmt|;
name|int
name|inputBuffered
decl_stmt|,
name|outputBuffered
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/* Of device driver operations. */
name|int
name|curPos
decl_stmt|;
comment|/* Position on the device. */
name|int
name|wasAsync
decl_stmt|;
comment|/* Was the channel nonblocking before the                                  * seek operation? If so, must restore to                                  * nonblocking mode after the seek. */
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|chan
expr_stmt|;
comment|/*      * Check for unreported error.      */
if|if
condition|(
name|chanPtr
operator|->
name|unreportedError
operator|!=
literal|0
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|chanPtr
operator|->
name|unreportedError
argument_list|)
expr_stmt|;
name|chanPtr
operator|->
name|unreportedError
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*      * Disallow seek on channels that are open for neither writing nor      * reading (e.g. socket server channels).      */
if|if
condition|(
operator|!
operator|(
name|chanPtr
operator|->
name|flags
operator|&
operator|(
name|TCL_WRITABLE
operator||
name|TCL_READABLE
operator|)
operator|)
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|EACCES
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*      * If the channel is in the middle of a background copy, fail.      */
if|if
condition|(
name|chanPtr
operator|->
name|csPtr
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|EBUSY
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*      * Disallow seek on dead channels -- channels that have been closed but      * not yet been deallocated. Such channels can be found if the exit      * handler for channel cleanup has run but the channel is still      * registered in an interpreter.      */
if|if
condition|(
name|CheckForDeadChannel
argument_list|(
name|NULL
argument_list|,
name|chanPtr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/*      * Disallow seek on channels whose type does not have a seek procedure      * defined. This means that the channel does not support seeking.      */
if|if
condition|(
name|chanPtr
operator|->
name|typePtr
operator|->
name|seekProc
operator|==
operator|(
name|Tcl_DriverSeekProc
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*      * Compute how much input and output is buffered. If both input and      * output is buffered, cannot compute the current position.      */
for|for
control|(
name|bufPtr
operator|=
name|chanPtr
operator|->
name|inQueueHead
operator|,
name|inputBuffered
operator|=
literal|0
init|;
name|bufPtr
operator|!=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|;
name|bufPtr
operator|=
name|bufPtr
operator|->
name|nextPtr
control|)
block|{
name|inputBuffered
operator|+=
operator|(
name|bufPtr
operator|->
name|nextAdded
operator|-
name|bufPtr
operator|->
name|nextRemoved
operator|)
expr_stmt|;
block|}
for|for
control|(
name|bufPtr
operator|=
name|chanPtr
operator|->
name|outQueueHead
operator|,
name|outputBuffered
operator|=
literal|0
init|;
name|bufPtr
operator|!=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|;
name|bufPtr
operator|=
name|bufPtr
operator|->
name|nextPtr
control|)
block|{
name|outputBuffered
operator|+=
operator|(
name|bufPtr
operator|->
name|nextAdded
operator|-
name|bufPtr
operator|->
name|nextRemoved
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|chanPtr
operator|->
name|curOutPtr
operator|!=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|chanPtr
operator|->
name|curOutPtr
operator|->
name|nextAdded
operator|>
name|chanPtr
operator|->
name|curOutPtr
operator|->
name|nextRemoved
operator|)
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator||=
name|BUFFER_READY
expr_stmt|;
name|outputBuffered
operator|+=
operator|(
name|chanPtr
operator|->
name|curOutPtr
operator|->
name|nextAdded
operator|-
name|chanPtr
operator|->
name|curOutPtr
operator|->
name|nextRemoved
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|inputBuffered
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|outputBuffered
operator|!=
literal|0
operator|)
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|EFAULT
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*      * If we are seeking relative to the current position, compute the      * corrected offset taking into account the amount of unread input.      */
if|if
condition|(
name|mode
operator|==
name|SEEK_CUR
condition|)
block|{
name|offset
operator|-=
name|inputBuffered
expr_stmt|;
block|}
comment|/*      * Discard any queued input - this input should not be read after      * the seek.      */
name|DiscardInputQueued
argument_list|(
name|chanPtr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * Reset EOF and BLOCKED flags. We invalidate them by moving the      * access point. Also clear CR related flags.      */
name|chanPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|CHANNEL_EOF
operator||
name|CHANNEL_STICKY_EOF
operator||
name|CHANNEL_BLOCKED
operator||
name|INPUT_SAW_CR
operator|)
operator|)
expr_stmt|;
comment|/*      * If the channel is in asynchronous output mode, switch it back      * to synchronous mode and cancel any async flush that may be      * scheduled. After the flush, the channel will be put back into      * asynchronous output mode.      */
name|wasAsync
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|CHANNEL_NONBLOCKING
condition|)
block|{
name|wasAsync
operator|=
literal|1
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chanPtr
operator|->
name|typePtr
operator|->
name|blockModeProc
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
call|(
name|chanPtr
operator|->
name|typePtr
operator|->
name|blockModeProc
call|)
argument_list|(
name|chanPtr
operator|->
name|instanceData
argument_list|,
name|TCL_MODE_BLOCKING
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|chanPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|CHANNEL_NONBLOCKING
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|BG_FLUSH_SCHEDULED
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|BG_FLUSH_SCHEDULED
operator|)
operator|)
expr_stmt|;
block|}
block|}
comment|/*      * If the flush fails we cannot recover the original position. In      * that case the seek is not attempted because we do not know where      * the access position is - instead we return the error. FlushChannel      * has already called Tcl_SetErrno() to report the error upwards.      * If the flush succeeds we do the seek also.      */
if|if
condition|(
name|FlushChannel
argument_list|(
name|NULL
argument_list|,
name|chanPtr
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|curPos
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/*          * Now seek to the new position in the channel as requested by the          * caller.          */
name|curPos
operator|=
call|(
name|chanPtr
operator|->
name|typePtr
operator|->
name|seekProc
call|)
argument_list|(
name|chanPtr
operator|->
name|instanceData
argument_list|,
operator|(
name|long
operator|)
name|offset
argument_list|,
name|mode
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|curPos
operator|==
operator|-
literal|1
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Restore to nonblocking mode if that was the previous behavior.      *      * NOTE: Even if there was an async flush active we do not restore      * it now because we already flushed all the queued output, above.      */
if|if
condition|(
name|wasAsync
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator||=
name|CHANNEL_NONBLOCKING
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chanPtr
operator|->
name|typePtr
operator|->
name|blockModeProc
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
call|(
name|chanPtr
operator|->
name|typePtr
operator|->
name|blockModeProc
call|)
argument_list|(
name|chanPtr
operator|->
name|instanceData
argument_list|,
name|TCL_MODE_NONBLOCKING
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
name|curPos
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_Tell --  *  *	Returns the position of the next character to be read/written on  *	this channel.  *  * Results:  *	A nonnegative integer on success, -1 on failure. If failed,  *	use Tcl_GetErrno() to retrieve the POSIX error code for the  *	error that occurred.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_Tell
parameter_list|(
name|chan
parameter_list|)
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel to return pos for. */
block|{
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The actual channel to tell on. */
name|ChannelBuffer
modifier|*
name|bufPtr
decl_stmt|;
name|int
name|inputBuffered
decl_stmt|,
name|outputBuffered
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/* Of calling device driver. */
name|int
name|curPos
decl_stmt|;
comment|/* Position on device. */
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|chan
expr_stmt|;
comment|/*      * Check for unreported error.      */
if|if
condition|(
name|chanPtr
operator|->
name|unreportedError
operator|!=
literal|0
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|chanPtr
operator|->
name|unreportedError
argument_list|)
expr_stmt|;
name|chanPtr
operator|->
name|unreportedError
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*      * Disallow tell on dead channels -- channels that have been closed but      * not yet been deallocated. Such channels can be found if the exit      * handler for channel cleanup has run but the channel is still      * registered in an interpreter.      */
if|if
condition|(
name|CheckForDeadChannel
argument_list|(
name|NULL
argument_list|,
name|chanPtr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/*      * Disallow tell on channels that are open for neither      * writing nor reading (e.g. socket server channels).      */
if|if
condition|(
operator|!
operator|(
name|chanPtr
operator|->
name|flags
operator|&
operator|(
name|TCL_WRITABLE
operator||
name|TCL_READABLE
operator|)
operator|)
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|EACCES
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*      * If the channel is in the middle of a background copy, fail.      */
if|if
condition|(
name|chanPtr
operator|->
name|csPtr
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|EBUSY
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*      * Disallow tell on channels whose type does not have a seek procedure      * defined. This means that the channel does not support seeking.      */
if|if
condition|(
name|chanPtr
operator|->
name|typePtr
operator|->
name|seekProc
operator|==
operator|(
name|Tcl_DriverSeekProc
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*      * Compute how much input and output is buffered. If both input and      * output is buffered, cannot compute the current position.      */
for|for
control|(
name|bufPtr
operator|=
name|chanPtr
operator|->
name|inQueueHead
operator|,
name|inputBuffered
operator|=
literal|0
init|;
name|bufPtr
operator|!=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|;
name|bufPtr
operator|=
name|bufPtr
operator|->
name|nextPtr
control|)
block|{
name|inputBuffered
operator|+=
operator|(
name|bufPtr
operator|->
name|nextAdded
operator|-
name|bufPtr
operator|->
name|nextRemoved
operator|)
expr_stmt|;
block|}
for|for
control|(
name|bufPtr
operator|=
name|chanPtr
operator|->
name|outQueueHead
operator|,
name|outputBuffered
operator|=
literal|0
init|;
name|bufPtr
operator|!=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|;
name|bufPtr
operator|=
name|bufPtr
operator|->
name|nextPtr
control|)
block|{
name|outputBuffered
operator|+=
operator|(
name|bufPtr
operator|->
name|nextAdded
operator|-
name|bufPtr
operator|->
name|nextRemoved
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|chanPtr
operator|->
name|curOutPtr
operator|!=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|chanPtr
operator|->
name|curOutPtr
operator|->
name|nextAdded
operator|>
name|chanPtr
operator|->
name|curOutPtr
operator|->
name|nextRemoved
operator|)
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator||=
name|BUFFER_READY
expr_stmt|;
name|outputBuffered
operator|+=
operator|(
name|chanPtr
operator|->
name|curOutPtr
operator|->
name|nextAdded
operator|-
name|chanPtr
operator|->
name|curOutPtr
operator|->
name|nextRemoved
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|inputBuffered
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|outputBuffered
operator|!=
literal|0
operator|)
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|EFAULT
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*      * Get the current position in the device and compute the position      * where the next character will be read or written.      */
name|curPos
operator|=
call|(
name|chanPtr
operator|->
name|typePtr
operator|->
name|seekProc
call|)
argument_list|(
name|chanPtr
operator|->
name|instanceData
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
name|SEEK_CUR
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|curPos
operator|==
operator|-
literal|1
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|inputBuffered
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|curPos
operator|-
name|inputBuffered
operator|)
return|;
block|}
return|return
operator|(
name|curPos
operator|+
name|outputBuffered
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_Eof --  *  *	Returns 1 if the channel is at EOF, 0 otherwise.  *  * Results:  *	1 or 0, always.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_Eof
parameter_list|(
name|chan
parameter_list|)
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* Does this channel have EOF? */
block|{
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The real channel structure. */
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|chan
expr_stmt|;
return|return
operator|(
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|CHANNEL_STICKY_EOF
operator|)
operator|||
operator|(
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|CHANNEL_EOF
operator|)
operator|&&
operator|(
name|Tcl_InputBuffered
argument_list|(
name|chan
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_InputBlocked --  *  *	Returns 1 if input is blocked on this channel, 0 otherwise.  *  * Results:  *	0 or 1, always.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_InputBlocked
parameter_list|(
name|chan
parameter_list|)
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* Is this channel blocked? */
block|{
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The real channel structure. */
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|chan
expr_stmt|;
return|return
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|CHANNEL_BLOCKED
operator|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_InputBuffered --  *  *	Returns the number of bytes of input currently buffered in the  *	internal buffer of a channel.  *  * Results:  *	The number of input bytes buffered, or zero if the channel is not  *	open for reading.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_InputBuffered
parameter_list|(
name|chan
parameter_list|)
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel to query. */
block|{
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
name|int
name|bytesBuffered
decl_stmt|;
name|ChannelBuffer
modifier|*
name|bufPtr
decl_stmt|;
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|chan
expr_stmt|;
for|for
control|(
name|bytesBuffered
operator|=
literal|0
operator|,
name|bufPtr
operator|=
name|chanPtr
operator|->
name|inQueueHead
init|;
name|bufPtr
operator|!=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|;
name|bufPtr
operator|=
name|bufPtr
operator|->
name|nextPtr
control|)
block|{
name|bytesBuffered
operator|+=
operator|(
name|bufPtr
operator|->
name|nextAdded
operator|-
name|bufPtr
operator|->
name|nextRemoved
operator|)
expr_stmt|;
block|}
return|return
name|bytesBuffered
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetChannelBufferSize --  *  *	Sets the size of buffers to allocate to store input or output  *	in the channel. The size must be between 10 bytes and 1 MByte.  *  * Results:  *	None.  *  * Side effects:  *	Sets the size of buffers subsequently allocated for this channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_SetChannelBufferSize
parameter_list|(
name|chan
parameter_list|,
name|sz
parameter_list|)
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel whose buffer size                                          * to set. */
name|int
name|sz
decl_stmt|;
comment|/* The size to set. */
block|{
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/*      * If the buffer size is smaller than 10 bytes or larger than one MByte,      * do not accept the requested size and leave the current buffer size.      */
if|if
condition|(
name|sz
operator|<
literal|10
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|sz
operator|>
operator|(
literal|1024
operator|*
literal|1024
operator|)
condition|)
block|{
return|return;
block|}
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|chan
expr_stmt|;
name|chanPtr
operator|->
name|bufSize
operator|=
name|sz
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetChannelBufferSize --  *  *	Retrieves the size of buffers to allocate for this channel.  *  * Results:  *	The size.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_GetChannelBufferSize
parameter_list|(
name|chan
parameter_list|)
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel for which to find the                                  * buffer size. */
block|{
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|chan
expr_stmt|;
return|return
name|chanPtr
operator|->
name|bufSize
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_BadChannelOption --  *  *	This procedure generates a "bad option" error message in an  *	(optional) interpreter.  It is used by channel drivers when   *      a invalid Set/Get option is requested. Its purpose is to concatenate  *      the generic options list to the specific ones and factorize  *      the generic options error message string.  *  * Results:  *	TCL_ERROR.  *  * Side effects:  *	An error message is generated in interp's result object to  *	indicate that a command was invoked with the a bad option  *	The message has the form  *		bad option "blah": should be one of   *<...generic options...>+<...specific options...>  *	"blah" is the optionName argument and "<specific options>"  *	is a space separated list of specific option words.  *      The function takes good care of inserting minus signs before  *      each option, commas after, and an "or" before the last option.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_BadChannelOption
parameter_list|(
name|interp
parameter_list|,
name|optionName
parameter_list|,
name|optionList
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. (can be NULL)*/
name|char
modifier|*
name|optionName
decl_stmt|;
comment|/* 'bad option' name */
name|char
modifier|*
name|optionList
decl_stmt|;
comment|/* Specific options list to append  					 * to the standard generic options. 					 * can be NULL for generic options  					 * only. 					 */
block|{
if|if
condition|(
name|interp
condition|)
block|{
name|CONST
name|char
modifier|*
name|genericopt
init|=
literal|"blocking buffering buffersize eofchar translation"
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|argc
decl_stmt|,
name|i
decl_stmt|;
name|Tcl_DString
name|ds
decl_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|ds
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|ds
argument_list|,
operator|(
name|char
operator|*
operator|)
name|genericopt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|optionList
operator|&&
operator|(
operator|*
name|optionList
operator|)
condition|)
block|{
name|Tcl_DStringAppend
argument_list|(
operator|&
name|ds
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|ds
argument_list|,
name|optionList
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Tcl_SplitList
argument_list|(
name|interp
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|ds
argument_list|)
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|panic
argument_list|(
literal|"malformed option list in channel driver"
argument_list|)
expr_stmt|;
block|}
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|optionName
argument_list|,
literal|"\": should be one of "
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"-"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
literal|", "
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"or -"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|ds
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
block|}
name|Tcl_SetErrno
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_GetChannelOption --  *  *	Gets a mode associated with an IO channel. If the optionName arg  *	is non NULL, retrieves the value of that option. If the optionName  *	arg is NULL, retrieves a list of alternating option names and  *	values for the given channel.  *  * Results:  *	A standard Tcl result. Also sets the supplied DString to the  *	string value of the option(s) returned.  *  * Side effects:  *      None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_GetChannelOption
parameter_list|(
name|interp
parameter_list|,
name|chan
parameter_list|,
name|optionName
parameter_list|,
name|dsPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* For error reporting - can be NULL. */
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* Channel on which to get option. */
name|char
modifier|*
name|optionName
decl_stmt|;
comment|/* Option to get. */
name|Tcl_DString
modifier|*
name|dsPtr
decl_stmt|;
comment|/* Where to store value(s). */
block|{
name|size_t
name|len
decl_stmt|;
comment|/* Length of optionName string. */
name|char
name|optionVal
index|[
literal|128
index|]
decl_stmt|;
comment|/* Buffer for sprintf. */
name|Channel
modifier|*
name|chanPtr
init|=
operator|(
name|Channel
operator|*
operator|)
name|chan
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/*      * If we are in the middle of a background copy, use the saved flags.      */
if|if
condition|(
name|chanPtr
operator|->
name|csPtr
condition|)
block|{
if|if
condition|(
name|chanPtr
operator|==
name|chanPtr
operator|->
name|csPtr
operator|->
name|readPtr
condition|)
block|{
name|flags
operator|=
name|chanPtr
operator|->
name|csPtr
operator|->
name|readFlags
expr_stmt|;
block|}
else|else
block|{
name|flags
operator|=
name|chanPtr
operator|->
name|csPtr
operator|->
name|writeFlags
expr_stmt|;
block|}
block|}
else|else
block|{
name|flags
operator|=
name|chanPtr
operator|->
name|flags
expr_stmt|;
block|}
comment|/*      * Disallow options on dead channels -- channels that have been closed but      * not yet been deallocated. Such channels can be found if the exit      * handler for channel cleanup has run but the channel is still      * registered in an interpreter.      */
if|if
condition|(
name|CheckForDeadChannel
argument_list|(
name|interp
argument_list|,
name|chanPtr
argument_list|)
condition|)
return|return
name|TCL_ERROR
return|;
comment|/*      * If the optionName is NULL it means that we want a list of all      * options and values.      */
if|if
condition|(
name|optionName
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|optionName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|len
operator|>
literal|2
operator|)
operator|&&
operator|(
name|optionName
index|[
literal|1
index|]
operator|==
literal|'b'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|optionName
argument_list|,
literal|"-blocking"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
literal|"-blocking"
argument_list|)
expr_stmt|;
block|}
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
operator|(
name|flags
operator|&
name|CHANNEL_NONBLOCKING
operator|)
condition|?
literal|"0"
else|:
literal|"1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
block|}
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|len
operator|>
literal|7
operator|)
operator|&&
operator|(
name|optionName
index|[
literal|1
index|]
operator|==
literal|'b'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|optionName
argument_list|,
literal|"-buffering"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
literal|"-buffering"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|CHANNEL_LINEBUFFERED
condition|)
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
literal|"line"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|CHANNEL_UNBUFFERED
condition|)
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
literal|"none"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
literal|"full"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
block|}
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|len
operator|>
literal|7
operator|)
operator|&&
operator|(
name|optionName
index|[
literal|1
index|]
operator|==
literal|'b'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|optionName
argument_list|,
literal|"-buffersize"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
literal|"-buffersize"
argument_list|)
expr_stmt|;
block|}
name|TclFormatInt
argument_list|(
name|optionVal
argument_list|,
name|chanPtr
operator|->
name|bufSize
argument_list|)
expr_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
name|optionVal
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
block|}
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|len
operator|>
literal|1
operator|)
operator|&&
operator|(
name|optionName
index|[
literal|1
index|]
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|optionName
argument_list|,
literal|"-eofchar"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
literal|"-eofchar"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
operator|(
name|TCL_READABLE
operator||
name|TCL_WRITABLE
operator|)
operator|)
operator|==
operator|(
name|TCL_READABLE
operator||
name|TCL_WRITABLE
operator|)
operator|)
operator|&&
operator|(
name|len
operator|==
literal|0
operator|)
condition|)
block|{
name|Tcl_DStringStartSublist
argument_list|(
name|dsPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|TCL_READABLE
condition|)
block|{
if|if
condition|(
name|chanPtr
operator|->
name|inEofChar
operator|==
literal|0
condition|)
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%c"
argument_list|,
name|chanPtr
operator|->
name|inEofChar
argument_list|)
expr_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|TCL_WRITABLE
condition|)
block|{
if|if
condition|(
name|chanPtr
operator|->
name|outEofChar
operator|==
literal|0
condition|)
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%c"
argument_list|,
name|chanPtr
operator|->
name|outEofChar
argument_list|)
expr_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
operator|(
name|TCL_READABLE
operator||
name|TCL_WRITABLE
operator|)
operator|)
operator|==
operator|(
name|TCL_READABLE
operator||
name|TCL_WRITABLE
operator|)
operator|)
operator|&&
operator|(
name|len
operator|==
literal|0
operator|)
condition|)
block|{
name|Tcl_DStringEndSublist
argument_list|(
name|dsPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
block|}
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|len
operator|>
literal|1
operator|)
operator|&&
operator|(
name|optionName
index|[
literal|1
index|]
operator|==
literal|'t'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|optionName
argument_list|,
literal|"-translation"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
literal|"-translation"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
operator|(
name|TCL_READABLE
operator||
name|TCL_WRITABLE
operator|)
operator|)
operator|==
operator|(
name|TCL_READABLE
operator||
name|TCL_WRITABLE
operator|)
operator|)
operator|&&
operator|(
name|len
operator|==
literal|0
operator|)
condition|)
block|{
name|Tcl_DStringStartSublist
argument_list|(
name|dsPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|TCL_READABLE
condition|)
block|{
if|if
condition|(
name|chanPtr
operator|->
name|inputTranslation
operator|==
name|TCL_TRANSLATE_AUTO
condition|)
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
literal|"auto"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chanPtr
operator|->
name|inputTranslation
operator|==
name|TCL_TRANSLATE_CR
condition|)
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
literal|"cr"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chanPtr
operator|->
name|inputTranslation
operator|==
name|TCL_TRANSLATE_CRLF
condition|)
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
literal|"crlf"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
literal|"lf"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|TCL_WRITABLE
condition|)
block|{
if|if
condition|(
name|chanPtr
operator|->
name|outputTranslation
operator|==
name|TCL_TRANSLATE_AUTO
condition|)
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
literal|"auto"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chanPtr
operator|->
name|outputTranslation
operator|==
name|TCL_TRANSLATE_CR
condition|)
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
literal|"cr"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chanPtr
operator|->
name|outputTranslation
operator|==
name|TCL_TRANSLATE_CRLF
condition|)
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
literal|"crlf"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_DStringAppendElement
argument_list|(
name|dsPtr
argument_list|,
literal|"lf"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
operator|(
name|TCL_READABLE
operator||
name|TCL_WRITABLE
operator|)
operator|)
operator|==
operator|(
name|TCL_READABLE
operator||
name|TCL_WRITABLE
operator|)
operator|)
operator|&&
operator|(
name|len
operator|==
literal|0
operator|)
condition|)
block|{
name|Tcl_DStringEndSublist
argument_list|(
name|dsPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
block|}
if|if
condition|(
name|chanPtr
operator|->
name|typePtr
operator|->
name|getOptionProc
operator|!=
operator|(
name|Tcl_DriverGetOptionProc
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* 	 * let the driver specific handle additional options 	 * and result code and message. 	 */
return|return
call|(
name|chanPtr
operator|->
name|typePtr
operator|->
name|getOptionProc
call|)
argument_list|(
name|chanPtr
operator|->
name|instanceData
argument_list|,
name|interp
argument_list|,
name|optionName
argument_list|,
name|dsPtr
argument_list|)
return|;
block|}
else|else
block|{
comment|/* 	 * no driver specific options case. 	 */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
return|return
name|Tcl_BadChannelOption
argument_list|(
name|interp
argument_list|,
name|optionName
argument_list|,
name|NULL
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_SetChannelOption --  *  *	Sets an option on a channel.  *  * Results:  *	A standard Tcl result. Also sets interp->result on error if  *	interp is not NULL.  *  * Side effects:  *	May modify an option on a device.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Tcl_SetChannelOption
parameter_list|(
name|interp
parameter_list|,
name|chan
parameter_list|,
name|optionName
parameter_list|,
name|newValue
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* For error reporting - can be NULL. */
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* Channel on which to set mode. */
name|char
modifier|*
name|optionName
decl_stmt|;
comment|/* Which option to set? */
name|char
modifier|*
name|newValue
decl_stmt|;
comment|/* New value for option. */
block|{
name|int
name|newMode
decl_stmt|;
comment|/* New (numeric) mode to sert. */
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The real IO channel. */
name|size_t
name|len
decl_stmt|;
comment|/* Length of optionName string. */
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|chan
expr_stmt|;
comment|/*      * If the channel is in the middle of a background copy, fail.      */
if|if
condition|(
name|chanPtr
operator|->
name|csPtr
condition|)
block|{
if|if
condition|(
name|interp
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"unable to set channel options: background copy in progress"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * Disallow options on dead channels -- channels that have been closed but      * not yet been deallocated. Such channels can be found if the exit      * handler for channel cleanup has run but the channel is still      * registered in an interpreter.      */
if|if
condition|(
name|CheckForDeadChannel
argument_list|(
name|NULL
argument_list|,
name|chanPtr
argument_list|)
condition|)
return|return
name|TCL_ERROR
return|;
name|len
operator|=
name|strlen
argument_list|(
name|optionName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|>
literal|2
operator|)
operator|&&
operator|(
name|optionName
index|[
literal|1
index|]
operator|==
literal|'b'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|optionName
argument_list|,
literal|"-blocking"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|Tcl_GetBoolean
argument_list|(
name|interp
argument_list|,
name|newValue
argument_list|,
operator|&
name|newMode
argument_list|)
operator|==
name|TCL_ERROR
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|newMode
condition|)
block|{
name|newMode
operator|=
name|TCL_MODE_BLOCKING
expr_stmt|;
block|}
else|else
block|{
name|newMode
operator|=
name|TCL_MODE_NONBLOCKING
expr_stmt|;
block|}
return|return
name|SetBlockMode
argument_list|(
name|interp
argument_list|,
name|chanPtr
argument_list|,
name|newMode
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|len
operator|>
literal|7
operator|)
operator|&&
operator|(
name|optionName
index|[
literal|1
index|]
operator|==
literal|'b'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|optionName
argument_list|,
literal|"-buffering"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|newValue
index|[
literal|0
index|]
operator|==
literal|'f'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|newValue
argument_list|,
literal|"full"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|CHANNEL_UNBUFFERED
operator||
name|CHANNEL_LINEBUFFERED
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|newValue
index|[
literal|0
index|]
operator|==
literal|'l'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|newValue
argument_list|,
literal|"line"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|CHANNEL_UNBUFFERED
operator|)
operator|)
expr_stmt|;
name|chanPtr
operator|->
name|flags
operator||=
name|CHANNEL_LINEBUFFERED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|newValue
index|[
literal|0
index|]
operator|==
literal|'n'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|newValue
argument_list|,
literal|"none"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|chanPtr
operator|->
name|flags
operator|&=
operator|(
operator|~
operator|(
name|CHANNEL_LINEBUFFERED
operator|)
operator|)
expr_stmt|;
name|chanPtr
operator|->
name|flags
operator||=
name|CHANNEL_UNBUFFERED
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|interp
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad value for -buffering: "
argument_list|,
literal|"must be one of full, line, or none"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
operator|(
name|len
operator|>
literal|7
operator|)
operator|&&
operator|(
name|optionName
index|[
literal|1
index|]
operator|==
literal|'b'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|optionName
argument_list|,
literal|"-buffersize"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|chanPtr
operator|->
name|bufSize
operator|=
name|atoi
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chanPtr
operator|->
name|bufSize
operator|<
literal|10
operator|)
operator|||
operator|(
name|chanPtr
operator|->
name|bufSize
operator|>
operator|(
literal|1024
operator|*
literal|1024
operator|)
operator|)
condition|)
block|{
name|chanPtr
operator|->
name|bufSize
operator|=
name|CHANNELBUFFER_DEFAULT_SIZE
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
operator|(
name|len
operator|>
literal|1
operator|)
operator|&&
operator|(
name|optionName
index|[
literal|1
index|]
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|optionName
argument_list|,
literal|"-eofchar"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|Tcl_SplitList
argument_list|(
name|interp
argument_list|,
name|newValue
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
operator|==
name|TCL_ERROR
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|chanPtr
operator|->
name|inEofChar
operator|=
literal|0
expr_stmt|;
name|chanPtr
operator|->
name|outEofChar
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|TCL_WRITABLE
condition|)
block|{
name|chanPtr
operator|->
name|outEofChar
operator|=
operator|(
name|int
operator|)
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|TCL_READABLE
condition|)
block|{
name|chanPtr
operator|->
name|inEofChar
operator|=
operator|(
name|int
operator|)
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
if|if
condition|(
name|interp
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad value for -eofchar: should be a list of one or"
argument_list|,
literal|" two elements"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
else|else
block|{
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|TCL_READABLE
condition|)
block|{
name|chanPtr
operator|->
name|inEofChar
operator|=
operator|(
name|int
operator|)
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|TCL_WRITABLE
condition|)
block|{
name|chanPtr
operator|->
name|outEofChar
operator|=
operator|(
name|int
operator|)
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|argv
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
operator|(
name|len
operator|>
literal|1
operator|)
operator|&&
operator|(
name|optionName
index|[
literal|1
index|]
operator|==
literal|'t'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|optionName
argument_list|,
literal|"-translation"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|char
modifier|*
name|readMode
decl_stmt|,
modifier|*
name|writeMode
decl_stmt|;
if|if
condition|(
name|Tcl_SplitList
argument_list|(
name|interp
argument_list|,
name|newValue
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
operator|==
name|TCL_ERROR
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|readMode
operator|=
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|TCL_READABLE
operator|)
condition|?
name|argv
index|[
literal|0
index|]
else|:
name|NULL
expr_stmt|;
name|writeMode
operator|=
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|TCL_WRITABLE
operator|)
condition|?
name|argv
index|[
literal|0
index|]
else|:
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
name|readMode
operator|=
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|TCL_READABLE
operator|)
condition|?
name|argv
index|[
literal|0
index|]
else|:
name|NULL
expr_stmt|;
name|writeMode
operator|=
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|TCL_WRITABLE
operator|)
condition|?
name|argv
index|[
literal|1
index|]
else|:
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|interp
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad value for -translation: must be a one or two"
argument_list|,
literal|" element list"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|readMode
condition|)
block|{
if|if
condition|(
operator|*
name|readMode
operator|==
literal|'\0'
condition|)
block|{
name|newMode
operator|=
name|chanPtr
operator|->
name|inputTranslation
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|readMode
argument_list|,
literal|"auto"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newMode
operator|=
name|TCL_TRANSLATE_AUTO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|readMode
argument_list|,
literal|"binary"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|chanPtr
operator|->
name|inEofChar
operator|=
literal|0
expr_stmt|;
name|newMode
operator|=
name|TCL_TRANSLATE_LF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|readMode
argument_list|,
literal|"lf"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newMode
operator|=
name|TCL_TRANSLATE_LF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|readMode
argument_list|,
literal|"cr"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newMode
operator|=
name|TCL_TRANSLATE_CR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|readMode
argument_list|,
literal|"crlf"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newMode
operator|=
name|TCL_TRANSLATE_CRLF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|readMode
argument_list|,
literal|"platform"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newMode
operator|=
name|TCL_PLATFORM_TRANSLATION
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|interp
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad value for -translation: "
argument_list|,
literal|"must be one of auto, binary, cr, lf, crlf,"
argument_list|,
literal|" or platform"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/* 	     * Reset the EOL flags since we need to look at any buffered 	     * data to see if the new translation mode allows us to 	     * complete the line. 	     */
if|if
condition|(
name|newMode
operator|!=
name|chanPtr
operator|->
name|inputTranslation
condition|)
block|{
name|chanPtr
operator|->
name|inputTranslation
operator|=
operator|(
name|Tcl_EolTranslation
operator|)
name|newMode
expr_stmt|;
name|chanPtr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|INPUT_SAW_CR
operator|)
expr_stmt|;
name|chanPtr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CHANNEL_GETS_BLOCKED
operator|)
expr_stmt|;
name|UpdateInterest
argument_list|(
name|chanPtr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|writeMode
condition|)
block|{
if|if
condition|(
operator|*
name|writeMode
operator|==
literal|'\0'
condition|)
block|{
comment|/* Do nothing. */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"auto"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * This is a hack to get TCP sockets to produce output 		 * in CRLF mode if they are being set into AUTO mode. 		 * A better solution for achieving this effect will be 		 * coded later. 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|chanPtr
operator|->
name|typePtr
operator|->
name|typeName
argument_list|,
literal|"tcp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|chanPtr
operator|->
name|outputTranslation
operator|=
name|TCL_TRANSLATE_CRLF
expr_stmt|;
block|}
else|else
block|{
name|chanPtr
operator|->
name|outputTranslation
operator|=
name|TCL_PLATFORM_TRANSLATION
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|writeMode
argument_list|,
literal|"binary"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|chanPtr
operator|->
name|outEofChar
operator|=
literal|0
expr_stmt|;
name|chanPtr
operator|->
name|outputTranslation
operator|=
name|TCL_TRANSLATE_LF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|writeMode
argument_list|,
literal|"lf"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|chanPtr
operator|->
name|outputTranslation
operator|=
name|TCL_TRANSLATE_LF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|writeMode
argument_list|,
literal|"cr"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|chanPtr
operator|->
name|outputTranslation
operator|=
name|TCL_TRANSLATE_CR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|writeMode
argument_list|,
literal|"crlf"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|chanPtr
operator|->
name|outputTranslation
operator|=
name|TCL_TRANSLATE_CRLF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|writeMode
argument_list|,
literal|"platform"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|chanPtr
operator|->
name|outputTranslation
operator|=
name|TCL_PLATFORM_TRANSLATION
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|interp
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad value for -translation: "
argument_list|,
literal|"must be one of auto, binary, cr, lf, crlf,"
argument_list|,
literal|" or platform"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|chanPtr
operator|->
name|typePtr
operator|->
name|setOptionProc
operator|!=
operator|(
name|Tcl_DriverSetOptionProc
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
call|(
name|chanPtr
operator|->
name|typePtr
operator|->
name|setOptionProc
call|)
argument_list|(
name|chanPtr
operator|->
name|instanceData
argument_list|,
name|interp
argument_list|,
name|optionName
argument_list|,
name|newValue
argument_list|)
return|;
block|}
return|return
name|Tcl_BadChannelOption
argument_list|(
name|interp
argument_list|,
name|optionName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CleanupChannelHandlers --  *  *	Removes channel handlers that refer to the supplied interpreter,  *	so that if the actual channel is not closed now, these handlers  *	will not run on subsequent events on the channel. This would be  *	erroneous, because the interpreter no longer has a reference to  *	this channel.  *  * Results:  *	None.  *  * Side effects:  *	Removes channel handlers.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|CleanupChannelHandlers
parameter_list|(
name|interp
parameter_list|,
name|chanPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
block|{
name|EventScriptRecord
modifier|*
name|sPtr
decl_stmt|,
modifier|*
name|prevPtr
decl_stmt|,
modifier|*
name|nextPtr
decl_stmt|;
comment|/*      * Remove fileevent records on this channel that refer to the      * given interpreter.      */
for|for
control|(
name|sPtr
operator|=
name|chanPtr
operator|->
name|scriptRecordPtr
operator|,
name|prevPtr
operator|=
operator|(
name|EventScriptRecord
operator|*
operator|)
name|NULL
init|;
name|sPtr
operator|!=
operator|(
name|EventScriptRecord
operator|*
operator|)
name|NULL
condition|;
name|sPtr
operator|=
name|nextPtr
control|)
block|{
name|nextPtr
operator|=
name|sPtr
operator|->
name|nextPtr
expr_stmt|;
if|if
condition|(
name|sPtr
operator|->
name|interp
operator|==
name|interp
condition|)
block|{
if|if
condition|(
name|prevPtr
operator|==
operator|(
name|EventScriptRecord
operator|*
operator|)
name|NULL
condition|)
block|{
name|chanPtr
operator|->
name|scriptRecordPtr
operator|=
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
name|prevPtr
operator|->
name|nextPtr
operator|=
name|nextPtr
expr_stmt|;
block|}
name|Tcl_DeleteChannelHandler
argument_list|(
operator|(
name|Tcl_Channel
operator|)
name|chanPtr
argument_list|,
name|ChannelEventScriptInvoker
argument_list|,
operator|(
name|ClientData
operator|)
name|sPtr
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|sPtr
operator|->
name|script
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prevPtr
operator|=
name|sPtr
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_NotifyChannel --  *  *	This procedure is called by a channel driver when a driver  *	detects an event on a channel.  This procedure is responsible  *	for actually handling the event by invoking any channel  *	handler callbacks.  *  * Results:  *	None.  *  * Side effects:  *	Whatever the channel handler callback procedure does.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_NotifyChannel
parameter_list|(
name|channel
parameter_list|,
name|mask
parameter_list|)
name|Tcl_Channel
name|channel
decl_stmt|;
comment|/* Channel that detected an event. */
name|int
name|mask
decl_stmt|;
comment|/* OR'ed combination of TCL_READABLE, 				 * TCL_WRITABLE, or TCL_EXCEPTION: indicates 				 * which events were detected. */
block|{
name|Channel
modifier|*
name|chanPtr
init|=
operator|(
name|Channel
operator|*
operator|)
name|channel
decl_stmt|;
name|ChannelHandler
modifier|*
name|chPtr
decl_stmt|;
name|NextChannelHandler
name|nh
decl_stmt|;
name|Tcl_Preserve
argument_list|(
operator|(
name|ClientData
operator|)
name|chanPtr
argument_list|)
expr_stmt|;
comment|/*      * If we are flushing in the background, be sure to call FlushChannel      * for writable events.  Note that we have to discard the writable      * event so we don't call any write handlers before the flush is      * complete.      */
if|if
condition|(
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|BG_FLUSH_SCHEDULED
operator|)
operator|&&
operator|(
name|mask
operator|&
name|TCL_WRITABLE
operator|)
condition|)
block|{
name|FlushChannel
argument_list|(
name|NULL
argument_list|,
name|chanPtr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mask
operator|&=
operator|~
name|TCL_WRITABLE
expr_stmt|;
block|}
comment|/*      * Add this invocation to the list of recursive invocations of      * ChannelHandlerEventProc.      */
name|nh
operator|.
name|nextHandlerPtr
operator|=
operator|(
name|ChannelHandler
operator|*
operator|)
name|NULL
expr_stmt|;
name|nh
operator|.
name|nestedHandlerPtr
operator|=
name|nestedHandlerPtr
expr_stmt|;
name|nestedHandlerPtr
operator|=
operator|&
name|nh
expr_stmt|;
for|for
control|(
name|chPtr
operator|=
name|chanPtr
operator|->
name|chPtr
init|;
name|chPtr
operator|!=
operator|(
name|ChannelHandler
operator|*
operator|)
name|NULL
condition|;
control|)
block|{
comment|/*          * If this channel handler is interested in any of the events that          * have occurred on the channel, invoke its procedure.          */
if|if
condition|(
operator|(
name|chPtr
operator|->
name|mask
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
block|{
name|nh
operator|.
name|nextHandlerPtr
operator|=
name|chPtr
operator|->
name|nextPtr
expr_stmt|;
operator|(
operator|*
operator|(
name|chPtr
operator|->
name|proc
operator|)
operator|)
operator|(
name|chPtr
operator|->
name|clientData
operator|,
name|mask
operator|)
expr_stmt|;
name|chPtr
operator|=
name|nh
operator|.
name|nextHandlerPtr
expr_stmt|;
block|}
else|else
block|{
name|chPtr
operator|=
name|chPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
block|}
comment|/*      * Update the notifier interest, since it may have changed after      * invoking event handlers.      */
if|if
condition|(
name|chanPtr
operator|->
name|typePtr
operator|!=
name|NULL
condition|)
block|{
name|UpdateInterest
argument_list|(
name|chanPtr
argument_list|)
expr_stmt|;
block|}
name|Tcl_Release
argument_list|(
operator|(
name|ClientData
operator|)
name|chanPtr
argument_list|)
expr_stmt|;
name|nestedHandlerPtr
operator|=
name|nh
operator|.
name|nestedHandlerPtr
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * UpdateInterest --  *  *	Arrange for the notifier to call us back at appropriate times  *	based on the current state of the channel.  *  * Results:  *	None.  *  * Side effects:  *	May schedule a timer or driver handler.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|UpdateInterest
parameter_list|(
name|chanPtr
parameter_list|)
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* Channel to update. */
block|{
name|int
name|mask
init|=
name|chanPtr
operator|->
name|interestMask
decl_stmt|;
comment|/*      * If there are flushed buffers waiting to be written, then      * we need to watch for the channel to become writable.      */
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|BG_FLUSH_SCHEDULED
condition|)
block|{
name|mask
operator||=
name|TCL_WRITABLE
expr_stmt|;
block|}
comment|/*      * If there is data in the input queue, and we aren't blocked waiting for      * an EOL, then we need to schedule a timer so we don't block in the      * notifier.  Also, cancel the read interest so we don't get duplicate      * events.      */
if|if
condition|(
name|mask
operator|&
name|TCL_READABLE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|CHANNEL_GETS_BLOCKED
operator|)
operator|&&
operator|(
name|chanPtr
operator|->
name|inQueueHead
operator|!=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|chanPtr
operator|->
name|inQueueHead
operator|->
name|nextRemoved
operator|<
name|chanPtr
operator|->
name|inQueueHead
operator|->
name|nextAdded
operator|)
condition|)
block|{
name|mask
operator|&=
operator|~
name|TCL_READABLE
expr_stmt|;
if|if
condition|(
operator|!
name|chanPtr
operator|->
name|timer
condition|)
block|{
name|chanPtr
operator|->
name|timer
operator|=
name|Tcl_CreateTimerHandler
argument_list|(
literal|0
argument_list|,
name|ChannelTimerProc
argument_list|,
operator|(
name|ClientData
operator|)
name|chanPtr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
call|(
name|chanPtr
operator|->
name|typePtr
operator|->
name|watchProc
call|)
argument_list|(
name|chanPtr
operator|->
name|instanceData
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * ChannelTimerProc --  *  *	Timer handler scheduled by UpdateInterest to monitor the  *	channel buffers until they are empty.  *  * Results:  *	None.  *  * Side effects:  *	May invoke channel handlers.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ChannelTimerProc
parameter_list|(
name|clientData
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
block|{
name|Channel
modifier|*
name|chanPtr
init|=
operator|(
name|Channel
operator|*
operator|)
name|clientData
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|CHANNEL_GETS_BLOCKED
operator|)
operator|&&
operator|(
name|chanPtr
operator|->
name|inQueueHead
operator|!=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|chanPtr
operator|->
name|inQueueHead
operator|->
name|nextRemoved
operator|<
name|chanPtr
operator|->
name|inQueueHead
operator|->
name|nextAdded
operator|)
condition|)
block|{
comment|/* 	 * Restart the timer in case a channel handler reenters the 	 * event loop before UpdateInterest gets called by Tcl_NotifyChannel. 	 */
name|chanPtr
operator|->
name|timer
operator|=
name|Tcl_CreateTimerHandler
argument_list|(
literal|0
argument_list|,
name|ChannelTimerProc
argument_list|,
operator|(
name|ClientData
operator|)
name|chanPtr
argument_list|)
expr_stmt|;
name|Tcl_NotifyChannel
argument_list|(
operator|(
name|Tcl_Channel
operator|)
name|chanPtr
argument_list|,
name|TCL_READABLE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chanPtr
operator|->
name|timer
operator|=
name|NULL
expr_stmt|;
name|UpdateInterest
argument_list|(
name|chanPtr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CreateChannelHandler --  *  *	Arrange for a given procedure to be invoked whenever the  *	channel indicated by the chanPtr arg becomes readable or  *	writable.  *  * Results:  *	None.  *  * Side effects:  *	From now on, whenever the I/O channel given by chanPtr becomes  *	ready in the way indicated by mask, proc will be invoked.  *	See the manual entry for details on the calling sequence  *	to proc.  If there is already an event handler for chan, proc  *	and clientData, then the mask will be updated.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_CreateChannelHandler
parameter_list|(
name|chan
parameter_list|,
name|mask
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel to create the handler for. */
name|int
name|mask
decl_stmt|;
comment|/* OR'ed combination of TCL_READABLE, 				 * TCL_WRITABLE, and TCL_EXCEPTION: 				 * indicates conditions under which 				 * proc should be called. Use 0 to                                  * disable a registered handler. */
name|Tcl_ChannelProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure to call for each 				 * selected event. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Arbitrary data to pass to proc. */
block|{
name|ChannelHandler
modifier|*
name|chPtr
decl_stmt|;
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|chan
expr_stmt|;
comment|/*      * Check whether this channel handler is not already registered. If      * it is not, create a new record, else reuse existing record (smash      * current values).      */
for|for
control|(
name|chPtr
operator|=
name|chanPtr
operator|->
name|chPtr
init|;
name|chPtr
operator|!=
operator|(
name|ChannelHandler
operator|*
operator|)
name|NULL
condition|;
name|chPtr
operator|=
name|chPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
operator|(
name|chPtr
operator|->
name|chanPtr
operator|==
name|chanPtr
operator|)
operator|&&
operator|(
name|chPtr
operator|->
name|proc
operator|==
name|proc
operator|)
operator|&&
operator|(
name|chPtr
operator|->
name|clientData
operator|==
name|clientData
operator|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|chPtr
operator|==
operator|(
name|ChannelHandler
operator|*
operator|)
name|NULL
condition|)
block|{
name|chPtr
operator|=
operator|(
name|ChannelHandler
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|ChannelHandler
argument_list|)
argument_list|)
expr_stmt|;
name|chPtr
operator|->
name|mask
operator|=
literal|0
expr_stmt|;
name|chPtr
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|chPtr
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
name|chPtr
operator|->
name|chanPtr
operator|=
name|chanPtr
expr_stmt|;
name|chPtr
operator|->
name|nextPtr
operator|=
name|chanPtr
operator|->
name|chPtr
expr_stmt|;
name|chanPtr
operator|->
name|chPtr
operator|=
name|chPtr
expr_stmt|;
block|}
comment|/*      * The remainder of the initialization below is done regardless of      * whether or not this is a new record or a modification of an old      * one.      */
name|chPtr
operator|->
name|mask
operator|=
name|mask
expr_stmt|;
comment|/*      * Recompute the interest mask for the channel - this call may actually      * be disabling an existing handler.      */
name|chanPtr
operator|->
name|interestMask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|chPtr
operator|=
name|chanPtr
operator|->
name|chPtr
init|;
name|chPtr
operator|!=
operator|(
name|ChannelHandler
operator|*
operator|)
name|NULL
condition|;
name|chPtr
operator|=
name|chPtr
operator|->
name|nextPtr
control|)
block|{
name|chanPtr
operator|->
name|interestMask
operator||=
name|chPtr
operator|->
name|mask
expr_stmt|;
block|}
name|UpdateInterest
argument_list|(
name|chanPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_DeleteChannelHandler --  *  *	Cancel a previously arranged callback arrangement for an IO  *	channel.  *  * Results:  *	None.  *  * Side effects:  *	If a callback was previously registered for this chan, proc and  *	 clientData , it is removed and the callback will no longer be called  *	when the channel becomes ready for IO.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_DeleteChannelHandler
parameter_list|(
name|chan
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The channel for which to remove the                                  * callback. */
name|Tcl_ChannelProc
modifier|*
name|proc
decl_stmt|;
comment|/* The procedure in the callback to delete. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* The client data in the callback                                  * to delete. */
block|{
name|ChannelHandler
modifier|*
name|chPtr
decl_stmt|,
modifier|*
name|prevChPtr
decl_stmt|;
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
name|NextChannelHandler
modifier|*
name|nhPtr
decl_stmt|;
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|chan
expr_stmt|;
comment|/*      * Find the entry and the previous one in the list.      */
for|for
control|(
name|prevChPtr
operator|=
operator|(
name|ChannelHandler
operator|*
operator|)
name|NULL
operator|,
name|chPtr
operator|=
name|chanPtr
operator|->
name|chPtr
init|;
name|chPtr
operator|!=
operator|(
name|ChannelHandler
operator|*
operator|)
name|NULL
condition|;
name|chPtr
operator|=
name|chPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
operator|(
name|chPtr
operator|->
name|chanPtr
operator|==
name|chanPtr
operator|)
operator|&&
operator|(
name|chPtr
operator|->
name|clientData
operator|==
name|clientData
operator|)
operator|&&
operator|(
name|chPtr
operator|->
name|proc
operator|==
name|proc
operator|)
condition|)
block|{
break|break;
block|}
name|prevChPtr
operator|=
name|chPtr
expr_stmt|;
block|}
comment|/*      * If not found, return without doing anything.      */
if|if
condition|(
name|chPtr
operator|==
operator|(
name|ChannelHandler
operator|*
operator|)
name|NULL
condition|)
block|{
return|return;
block|}
comment|/*      * If ChannelHandlerEventProc is about to process this handler, tell it to      * process the next one instead - we are going to delete *this* one.      */
for|for
control|(
name|nhPtr
operator|=
name|nestedHandlerPtr
init|;
name|nhPtr
operator|!=
operator|(
name|NextChannelHandler
operator|*
operator|)
name|NULL
condition|;
name|nhPtr
operator|=
name|nhPtr
operator|->
name|nestedHandlerPtr
control|)
block|{
if|if
condition|(
name|nhPtr
operator|->
name|nextHandlerPtr
operator|==
name|chPtr
condition|)
block|{
name|nhPtr
operator|->
name|nextHandlerPtr
operator|=
name|chPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
block|}
comment|/*      * Splice it out of the list of channel handlers.      */
if|if
condition|(
name|prevChPtr
operator|==
operator|(
name|ChannelHandler
operator|*
operator|)
name|NULL
condition|)
block|{
name|chanPtr
operator|->
name|chPtr
operator|=
name|chPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
name|prevChPtr
operator|->
name|nextPtr
operator|=
name|chPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|chPtr
argument_list|)
expr_stmt|;
comment|/*      * Recompute the interest list for the channel, so that infinite loops      * will not result if Tcl_DeleteChanelHandler is called inside an event.      */
name|chanPtr
operator|->
name|interestMask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|chPtr
operator|=
name|chanPtr
operator|->
name|chPtr
init|;
name|chPtr
operator|!=
operator|(
name|ChannelHandler
operator|*
operator|)
name|NULL
condition|;
name|chPtr
operator|=
name|chPtr
operator|->
name|nextPtr
control|)
block|{
name|chanPtr
operator|->
name|interestMask
operator||=
name|chPtr
operator|->
name|mask
expr_stmt|;
block|}
name|UpdateInterest
argument_list|(
name|chanPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * DeleteScriptRecord --  *  *	Delete a script record for this combination of channel, interp  *	and mask.  *  * Results:  *	None.  *  * Side effects:  *	Deletes a script record and cancels a channel event handler.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|DeleteScriptRecord
parameter_list|(
name|interp
parameter_list|,
name|chanPtr
parameter_list|,
name|mask
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which script was to be                                  * executed. */
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The channel for which to delete the                                  * script record (if any). */
name|int
name|mask
decl_stmt|;
comment|/* Events in mask must exactly match mask                                  * of script to delete. */
block|{
name|EventScriptRecord
modifier|*
name|esPtr
decl_stmt|,
modifier|*
name|prevEsPtr
decl_stmt|;
for|for
control|(
name|esPtr
operator|=
name|chanPtr
operator|->
name|scriptRecordPtr
operator|,
name|prevEsPtr
operator|=
operator|(
name|EventScriptRecord
operator|*
operator|)
name|NULL
init|;
name|esPtr
operator|!=
operator|(
name|EventScriptRecord
operator|*
operator|)
name|NULL
condition|;
name|prevEsPtr
operator|=
name|esPtr
operator|,
name|esPtr
operator|=
name|esPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
operator|(
name|esPtr
operator|->
name|interp
operator|==
name|interp
operator|)
operator|&&
operator|(
name|esPtr
operator|->
name|mask
operator|==
name|mask
operator|)
condition|)
block|{
if|if
condition|(
name|esPtr
operator|==
name|chanPtr
operator|->
name|scriptRecordPtr
condition|)
block|{
name|chanPtr
operator|->
name|scriptRecordPtr
operator|=
name|esPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
name|prevEsPtr
operator|->
name|nextPtr
operator|=
name|esPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
name|Tcl_DeleteChannelHandler
argument_list|(
operator|(
name|Tcl_Channel
operator|)
name|chanPtr
argument_list|,
name|ChannelEventScriptInvoker
argument_list|,
operator|(
name|ClientData
operator|)
name|esPtr
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|esPtr
operator|->
name|script
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|esPtr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CreateScriptRecord --  *  *	Creates a record to store a script to be executed when a specific  *	event fires on a specific channel.  *  * Results:  *	None.  *  * Side effects:  *	Causes the script to be stored for later execution.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|CreateScriptRecord
parameter_list|(
name|interp
parameter_list|,
name|chanPtr
parameter_list|,
name|mask
parameter_list|,
name|script
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to execute                                          * the stored script. */
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* Channel for which script is to                                          * be stored. */
name|int
name|mask
decl_stmt|;
comment|/* Set of events for which script                                          * will be invoked. */
name|char
modifier|*
name|script
decl_stmt|;
comment|/* A copy of this script is stored                                          * in the newly created record. */
block|{
name|EventScriptRecord
modifier|*
name|esPtr
decl_stmt|;
for|for
control|(
name|esPtr
operator|=
name|chanPtr
operator|->
name|scriptRecordPtr
init|;
name|esPtr
operator|!=
operator|(
name|EventScriptRecord
operator|*
operator|)
name|NULL
condition|;
name|esPtr
operator|=
name|esPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
operator|(
name|esPtr
operator|->
name|interp
operator|==
name|interp
operator|)
operator|&&
operator|(
name|esPtr
operator|->
name|mask
operator|==
name|mask
operator|)
condition|)
block|{
name|ckfree
argument_list|(
name|esPtr
operator|->
name|script
argument_list|)
expr_stmt|;
name|esPtr
operator|->
name|script
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|esPtr
operator|==
operator|(
name|EventScriptRecord
operator|*
operator|)
name|NULL
condition|)
block|{
name|esPtr
operator|=
operator|(
name|EventScriptRecord
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|EventScriptRecord
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_CreateChannelHandler
argument_list|(
operator|(
name|Tcl_Channel
operator|)
name|chanPtr
argument_list|,
name|mask
argument_list|,
name|ChannelEventScriptInvoker
argument_list|,
operator|(
name|ClientData
operator|)
name|esPtr
argument_list|)
expr_stmt|;
name|esPtr
operator|->
name|nextPtr
operator|=
name|chanPtr
operator|->
name|scriptRecordPtr
expr_stmt|;
name|chanPtr
operator|->
name|scriptRecordPtr
operator|=
name|esPtr
expr_stmt|;
block|}
name|esPtr
operator|->
name|chanPtr
operator|=
name|chanPtr
expr_stmt|;
name|esPtr
operator|->
name|interp
operator|=
name|interp
expr_stmt|;
name|esPtr
operator|->
name|mask
operator|=
name|mask
expr_stmt|;
name|esPtr
operator|->
name|script
operator|=
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|script
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|esPtr
operator|->
name|script
argument_list|,
name|script
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * ChannelEventScriptInvoker --  *  *	Invokes a script scheduled by "fileevent" for when the channel  *	becomes ready for IO. This function is invoked by the channel  *	handler which was created by the Tcl "fileevent" command.  *  * Results:  *	None.  *  * Side effects:  *	Whatever the script does.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ChannelEventScriptInvoker
parameter_list|(
name|clientData
parameter_list|,
name|mask
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* The script+interp record. */
name|int
name|mask
decl_stmt|;
comment|/* Not used. */
block|{
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which to eval the script. */
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The channel for which this handler is                                  * registered. */
name|char
modifier|*
name|script
decl_stmt|;
comment|/* Script to eval. */
name|EventScriptRecord
modifier|*
name|esPtr
decl_stmt|;
comment|/* The event script + interpreter to eval it                                  * in. */
name|int
name|result
decl_stmt|;
comment|/* Result of call to eval script. */
name|esPtr
operator|=
operator|(
name|EventScriptRecord
operator|*
operator|)
name|clientData
expr_stmt|;
name|chanPtr
operator|=
name|esPtr
operator|->
name|chanPtr
expr_stmt|;
name|mask
operator|=
name|esPtr
operator|->
name|mask
expr_stmt|;
name|interp
operator|=
name|esPtr
operator|->
name|interp
expr_stmt|;
name|script
operator|=
name|esPtr
operator|->
name|script
expr_stmt|;
comment|/*      * We must preserve the interpreter so we can report errors on it      * later.  Note that we do not need to preserve the channel because      * that is done by Tcl_NotifyChannel before calling channel handlers.      */
name|Tcl_Preserve
argument_list|(
operator|(
name|ClientData
operator|)
name|interp
argument_list|)
expr_stmt|;
name|result
operator|=
name|Tcl_GlobalEval
argument_list|(
name|interp
argument_list|,
name|script
argument_list|)
expr_stmt|;
comment|/*      * On error, cause a background error and remove the channel handler      * and the script record.      *      * NOTE: Must delete channel handler before causing the background error      * because the background error may want to reinstall the handler.      */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|chanPtr
operator|->
name|typePtr
operator|!=
name|NULL
condition|)
block|{
name|DeleteScriptRecord
argument_list|(
name|interp
argument_list|,
name|chanPtr
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
name|Tcl_BackgroundError
argument_list|(
name|interp
argument_list|)
expr_stmt|;
block|}
name|Tcl_Release
argument_list|(
operator|(
name|ClientData
operator|)
name|interp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_FileEventCmd --  *  *	This procedure implements the "fileevent" Tcl command. See the  *	user documentation for details on what it does. This command is  *	based on the Tk command "fileevent" which in turn is based on work  *	contributed by Mark Diekhans.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	May create a channel handler for the specified channel.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|Tcl_FileEventCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which the channel                                          * for which to create the handler                                          * is found. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The channel to create                                          * the handler for. */
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The opaque type for the channel. */
name|int
name|c
decl_stmt|;
comment|/* First char of mode argument. */
name|int
name|mask
decl_stmt|;
comment|/* Mask for events of interest. */
name|size_t
name|length
decl_stmt|;
comment|/* Length of mode argument. */
comment|/*      * Parse arguments.      */
if|if
condition|(
operator|(
name|argc
operator|!=
literal|3
operator|)
operator|&&
operator|(
name|argc
operator|!=
literal|4
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: must be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" channelId event ?script?"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|c
operator|=
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'r'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"readable"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mask
operator|=
name|TCL_READABLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'w'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"writable"
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mask
operator|=
name|TCL_WRITABLE
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad event name \""
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"\": must be readable or writable"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|chan
operator|=
name|Tcl_GetChannel
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|chan
expr_stmt|;
if|if
condition|(
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|mask
operator|)
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"channel is not "
argument_list|,
operator|(
name|mask
operator|==
name|TCL_READABLE
operator|)
condition|?
literal|"readable"
else|:
literal|"writable"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/*      * If we are supposed to return the script, do so.      */
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
block|{
name|EventScriptRecord
modifier|*
name|esPtr
decl_stmt|;
for|for
control|(
name|esPtr
operator|=
name|chanPtr
operator|->
name|scriptRecordPtr
init|;
name|esPtr
operator|!=
operator|(
name|EventScriptRecord
operator|*
operator|)
name|NULL
condition|;
name|esPtr
operator|=
name|esPtr
operator|->
name|nextPtr
control|)
block|{
if|if
condition|(
operator|(
name|esPtr
operator|->
name|interp
operator|==
name|interp
operator|)
operator|&&
operator|(
name|esPtr
operator|->
name|mask
operator|==
name|mask
operator|)
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|esPtr
operator|->
name|script
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
comment|/*      * If we are supposed to delete a stored script, do so.      */
if|if
condition|(
name|argv
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|DeleteScriptRecord
argument_list|(
name|interp
argument_list|,
name|chanPtr
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
comment|/*      * Make the script record that will link between the event and the      * script to invoke. This also creates a channel event handler which      * will evaluate the script in the supplied interpreter.      */
name|CreateScriptRecord
argument_list|(
name|interp
argument_list|,
name|chanPtr
argument_list|,
name|mask
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclTestChannelCmd --  *  *	Implements the Tcl "testchannel" debugging command and its  *	subcommands. This is part of the testing environment but must be  *	in this file instead of tclTest.c because it needs access to the  *	fields of struct Channel.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|TclTestChannelCmd
parameter_list|(
name|clientData
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter for result. */
name|int
name|argc
decl_stmt|;
comment|/* Count of additional args. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Additional arg strings. */
block|{
name|char
modifier|*
name|cmdName
decl_stmt|;
comment|/* Sub command. */
name|Tcl_HashTable
modifier|*
name|hTblPtr
decl_stmt|;
comment|/* Hash table of channels. */
name|Tcl_HashSearch
name|hSearch
decl_stmt|;
comment|/* Search variable. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
comment|/* Search variable. */
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
comment|/* The actual channel. */
name|Tcl_Channel
name|chan
decl_stmt|;
comment|/* The opaque type. */
name|size_t
name|len
decl_stmt|;
comment|/* Length of subcommand string. */
name|int
name|IOQueued
decl_stmt|;
comment|/* How much IO is queued inside channel? */
name|ChannelBuffer
modifier|*
name|bufPtr
decl_stmt|;
comment|/* For iterating over queued IO. */
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
comment|/* For sprintf. */
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" subcommand ?additional args..?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|cmdName
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|cmdName
argument_list|)
expr_stmt|;
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
name|chan
operator|=
name|Tcl_GetChannel
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
operator|(
name|Tcl_Channel
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|chan
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cmdName
index|[
literal|0
index|]
operator|==
literal|'i'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cmdName
argument_list|,
literal|"info"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" info channelName\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|chanPtr
operator|->
name|typePtr
operator|->
name|typeName
argument_list|)
expr_stmt|;
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|TCL_READABLE
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"read"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|TCL_WRITABLE
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"write"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|CHANNEL_NONBLOCKING
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"nonblocking"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"blocking"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|CHANNEL_LINEBUFFERED
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"line"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|CHANNEL_UNBUFFERED
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"none"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"full"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|BG_FLUSH_SCHEDULED
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"async_flush"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|CHANNEL_EOF
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"eof"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|CHANNEL_BLOCKED
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"blocked"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"unblocked"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chanPtr
operator|->
name|inputTranslation
operator|==
name|TCL_TRANSLATE_AUTO
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"auto"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|INPUT_SAW_CR
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"saw_cr"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|chanPtr
operator|->
name|inputTranslation
operator|==
name|TCL_TRANSLATE_LF
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"lf"
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chanPtr
operator|->
name|inputTranslation
operator|==
name|TCL_TRANSLATE_CR
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"cr"
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chanPtr
operator|->
name|inputTranslation
operator|==
name|TCL_TRANSLATE_CRLF
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"crlf"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|INPUT_SAW_CR
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"queued_cr"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|chanPtr
operator|->
name|outputTranslation
operator|==
name|TCL_TRANSLATE_AUTO
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"auto"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chanPtr
operator|->
name|outputTranslation
operator|==
name|TCL_TRANSLATE_LF
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"lf"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chanPtr
operator|->
name|outputTranslation
operator|==
name|TCL_TRANSLATE_CR
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"cr"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chanPtr
operator|->
name|outputTranslation
operator|==
name|TCL_TRANSLATE_CRLF
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"crlf"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|IOQueued
operator|=
literal|0
operator|,
name|bufPtr
operator|=
name|chanPtr
operator|->
name|inQueueHead
init|;
name|bufPtr
operator|!=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|;
name|bufPtr
operator|=
name|bufPtr
operator|->
name|nextPtr
control|)
block|{
name|IOQueued
operator|+=
name|bufPtr
operator|->
name|nextAdded
operator|-
name|bufPtr
operator|->
name|nextRemoved
expr_stmt|;
block|}
name|TclFormatInt
argument_list|(
name|buf
argument_list|,
name|IOQueued
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|IOQueued
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chanPtr
operator|->
name|curOutPtr
operator|!=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|)
block|{
name|IOQueued
operator|=
name|chanPtr
operator|->
name|curOutPtr
operator|->
name|nextAdded
operator|-
name|chanPtr
operator|->
name|curOutPtr
operator|->
name|nextRemoved
expr_stmt|;
block|}
for|for
control|(
name|bufPtr
operator|=
name|chanPtr
operator|->
name|outQueueHead
init|;
name|bufPtr
operator|!=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|;
name|bufPtr
operator|=
name|bufPtr
operator|->
name|nextPtr
control|)
block|{
name|IOQueued
operator|+=
operator|(
name|bufPtr
operator|->
name|nextAdded
operator|-
name|bufPtr
operator|->
name|nextRemoved
operator|)
expr_stmt|;
block|}
name|TclFormatInt
argument_list|(
name|buf
argument_list|,
name|IOQueued
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|TclFormatInt
argument_list|(
name|buf
argument_list|,
name|Tcl_Tell
argument_list|(
operator|(
name|Tcl_Channel
operator|)
name|chanPtr
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|TclFormatInt
argument_list|(
name|buf
argument_list|,
name|chanPtr
operator|->
name|refCount
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
operator|(
name|cmdName
index|[
literal|0
index|]
operator|==
literal|'i'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cmdName
argument_list|,
literal|"inputbuffered"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"channel name required"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
for|for
control|(
name|IOQueued
operator|=
literal|0
operator|,
name|bufPtr
operator|=
name|chanPtr
operator|->
name|inQueueHead
init|;
name|bufPtr
operator|!=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|;
name|bufPtr
operator|=
name|bufPtr
operator|->
name|nextPtr
control|)
block|{
name|IOQueued
operator|+=
name|bufPtr
operator|->
name|nextAdded
operator|-
name|bufPtr
operator|->
name|nextRemoved
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|IOQueued
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
operator|(
name|cmdName
index|[
literal|0
index|]
operator|==
literal|'m'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cmdName
argument_list|,
literal|"mode"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"channel name required"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|TCL_READABLE
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"read"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|TCL_WRITABLE
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|"write"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
operator|(
name|cmdName
index|[
literal|0
index|]
operator|==
literal|'n'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cmdName
argument_list|,
literal|"name"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"channel name required"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|chanPtr
operator|->
name|channelName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
operator|(
name|cmdName
index|[
literal|0
index|]
operator|==
literal|'o'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cmdName
argument_list|,
literal|"open"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|hTblPtr
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclIO"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hTblPtr
operator|==
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|hTblPtr
argument_list|,
operator|&
name|hSearch
argument_list|)
init|;
name|hPtr
operator|!=
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|hSearch
argument_list|)
control|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|Tcl_GetHashKey
argument_list|(
name|hTblPtr
argument_list|,
name|hPtr
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
operator|(
name|cmdName
index|[
literal|0
index|]
operator|==
literal|'o'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cmdName
argument_list|,
literal|"outputbuffered"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"channel name required"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|IOQueued
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chanPtr
operator|->
name|curOutPtr
operator|!=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|)
block|{
name|IOQueued
operator|=
name|chanPtr
operator|->
name|curOutPtr
operator|->
name|nextAdded
operator|-
name|chanPtr
operator|->
name|curOutPtr
operator|->
name|nextRemoved
expr_stmt|;
block|}
for|for
control|(
name|bufPtr
operator|=
name|chanPtr
operator|->
name|outQueueHead
init|;
name|bufPtr
operator|!=
operator|(
name|ChannelBuffer
operator|*
operator|)
name|NULL
condition|;
name|bufPtr
operator|=
name|bufPtr
operator|->
name|nextPtr
control|)
block|{
name|IOQueued
operator|+=
operator|(
name|bufPtr
operator|->
name|nextAdded
operator|-
name|bufPtr
operator|->
name|nextRemoved
operator|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|IOQueued
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
operator|(
name|cmdName
index|[
literal|0
index|]
operator|==
literal|'q'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cmdName
argument_list|,
literal|"queuedcr"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"channel name required"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
operator|(
name|chanPtr
operator|->
name|flags
operator|&
name|INPUT_SAW_CR
operator|)
condition|?
literal|"1"
else|:
literal|"0"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
operator|(
name|cmdName
index|[
literal|0
index|]
operator|==
literal|'r'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cmdName
argument_list|,
literal|"readable"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|hTblPtr
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclIO"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hTblPtr
operator|==
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|hTblPtr
argument_list|,
operator|&
name|hSearch
argument_list|)
init|;
name|hPtr
operator|!=
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|hSearch
argument_list|)
control|)
block|{
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|TCL_READABLE
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|Tcl_GetHashKey
argument_list|(
name|hTblPtr
argument_list|,
name|hPtr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
operator|(
name|cmdName
index|[
literal|0
index|]
operator|==
literal|'r'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cmdName
argument_list|,
literal|"refcount"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"channel name required"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|chanPtr
operator|->
name|refCount
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
operator|(
name|cmdName
index|[
literal|0
index|]
operator|==
literal|'t'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cmdName
argument_list|,
literal|"type"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"channel name required"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|chanPtr
operator|->
name|typePtr
operator|->
name|typeName
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
operator|(
name|cmdName
index|[
literal|0
index|]
operator|==
literal|'w'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cmdName
argument_list|,
literal|"writable"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|hTblPtr
operator|=
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|Tcl_GetAssocData
argument_list|(
name|interp
argument_list|,
literal|"tclIO"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hTblPtr
operator|==
operator|(
name|Tcl_HashTable
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
for|for
control|(
name|hPtr
operator|=
name|Tcl_FirstHashEntry
argument_list|(
name|hTblPtr
argument_list|,
operator|&
name|hSearch
argument_list|)
init|;
name|hPtr
operator|!=
operator|(
name|Tcl_HashEntry
operator|*
operator|)
name|NULL
condition|;
name|hPtr
operator|=
name|Tcl_NextHashEntry
argument_list|(
operator|&
name|hSearch
argument_list|)
control|)
block|{
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|chanPtr
operator|->
name|flags
operator|&
name|TCL_WRITABLE
condition|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|Tcl_GetHashKey
argument_list|(
name|hTblPtr
argument_list|,
name|hPtr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TCL_OK
return|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|cmdName
argument_list|,
literal|"\": should be "
argument_list|,
literal|"info, open, readable, or writable"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclTestChannelEventCmd --  *  *	This procedure implements the "testchannelevent" command. It is  *	used to test the Tcl channel event mechanism. It is present in  *	this file instead of tclTest.c because it needs access to the  *	internal structure of the channel.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	Creates, deletes and returns channel event handlers.  *  *----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|TclTestChannelEventCmd
parameter_list|(
name|dummy
parameter_list|,
name|interp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|ClientData
name|dummy
decl_stmt|;
comment|/* Not used. */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument strings. */
block|{
name|Channel
modifier|*
name|chanPtr
decl_stmt|;
name|EventScriptRecord
modifier|*
name|esPtr
decl_stmt|,
modifier|*
name|prevEsPtr
decl_stmt|,
modifier|*
name|nextEsPtr
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|int
name|index
decl_stmt|,
name|i
decl_stmt|,
name|mask
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|argc
operator|<
literal|3
operator|)
operator|||
operator|(
name|argc
operator|>
literal|5
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" channelName cmd ?arg1? ?arg2?\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|chanPtr
operator|=
operator|(
name|Channel
operator|*
operator|)
name|Tcl_GetChannel
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chanPtr
operator|==
operator|(
name|Channel
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|cmd
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
index|[
literal|0
index|]
operator|==
literal|'a'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cmd
argument_list|,
literal|"add"
argument_list|,
operator|(
name|unsigned
operator|)
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|5
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" channelName add eventSpec script\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|,
literal|"readable"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mask
operator|=
name|TCL_READABLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|,
literal|"writable"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mask
operator|=
name|TCL_WRITABLE
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad event name \""
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
literal|"\": must be readable or writable"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|esPtr
operator|=
operator|(
name|EventScriptRecord
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|EventScriptRecord
argument_list|)
argument_list|)
expr_stmt|;
name|esPtr
operator|->
name|nextPtr
operator|=
name|chanPtr
operator|->
name|scriptRecordPtr
expr_stmt|;
name|chanPtr
operator|->
name|scriptRecordPtr
operator|=
name|esPtr
expr_stmt|;
name|esPtr
operator|->
name|chanPtr
operator|=
name|chanPtr
expr_stmt|;
name|esPtr
operator|->
name|interp
operator|=
name|interp
expr_stmt|;
name|esPtr
operator|->
name|mask
operator|=
name|mask
expr_stmt|;
name|esPtr
operator|->
name|script
operator|=
name|ckalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|esPtr
operator|->
name|script
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|Tcl_CreateChannelHandler
argument_list|(
operator|(
name|Tcl_Channel
operator|)
name|chanPtr
argument_list|,
name|mask
argument_list|,
name|ChannelEventScriptInvoker
argument_list|,
operator|(
name|ClientData
operator|)
name|esPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
operator|(
name|cmd
index|[
literal|0
index|]
operator|==
literal|'d'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cmd
argument_list|,
literal|"delete"
argument_list|,
operator|(
name|unsigned
operator|)
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" channelName delete index\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetInt
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
operator|&
name|index
argument_list|)
operator|==
name|TCL_ERROR
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad event index: "
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
literal|": must be nonnegative"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|esPtr
operator|=
name|chanPtr
operator|->
name|scriptRecordPtr
init|;
operator|(
name|i
operator|<
name|index
operator|)
operator|&&
operator|(
name|esPtr
operator|!=
operator|(
name|EventScriptRecord
operator|*
operator|)
name|NULL
operator|)
condition|;
name|i
operator|++
operator|,
name|esPtr
operator|=
name|esPtr
operator|->
name|nextPtr
control|)
block|{
comment|/* Empty loop body. */
block|}
if|if
condition|(
name|esPtr
operator|==
operator|(
name|EventScriptRecord
operator|*
operator|)
name|NULL
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad event index "
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
literal|": out of range"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|esPtr
operator|==
name|chanPtr
operator|->
name|scriptRecordPtr
condition|)
block|{
name|chanPtr
operator|->
name|scriptRecordPtr
operator|=
name|esPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|prevEsPtr
operator|=
name|chanPtr
operator|->
name|scriptRecordPtr
init|;
operator|(
name|prevEsPtr
operator|!=
operator|(
name|EventScriptRecord
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|prevEsPtr
operator|->
name|nextPtr
operator|!=
name|esPtr
operator|)
condition|;
name|prevEsPtr
operator|=
name|prevEsPtr
operator|->
name|nextPtr
control|)
block|{
comment|/* Empty loop body. */
block|}
if|if
condition|(
name|prevEsPtr
operator|==
operator|(
name|EventScriptRecord
operator|*
operator|)
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"TclTestChannelEventCmd: damaged event script list"
argument_list|)
expr_stmt|;
block|}
name|prevEsPtr
operator|->
name|nextPtr
operator|=
name|esPtr
operator|->
name|nextPtr
expr_stmt|;
block|}
name|Tcl_DeleteChannelHandler
argument_list|(
operator|(
name|Tcl_Channel
operator|)
name|chanPtr
argument_list|,
name|ChannelEventScriptInvoker
argument_list|,
operator|(
name|ClientData
operator|)
name|esPtr
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|esPtr
operator|->
name|script
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|esPtr
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
operator|(
name|cmd
index|[
literal|0
index|]
operator|==
literal|'l'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cmd
argument_list|,
literal|"list"
argument_list|,
operator|(
name|unsigned
operator|)
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" channelName list\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
for|for
control|(
name|esPtr
operator|=
name|chanPtr
operator|->
name|scriptRecordPtr
init|;
name|esPtr
operator|!=
operator|(
name|EventScriptRecord
operator|*
operator|)
name|NULL
condition|;
name|esPtr
operator|=
name|esPtr
operator|->
name|nextPtr
control|)
block|{
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|esPtr
operator|->
name|mask
operator|==
name|TCL_READABLE
condition|?
literal|"readable"
else|:
literal|"writable"
argument_list|)
expr_stmt|;
name|Tcl_AppendElement
argument_list|(
name|interp
argument_list|,
name|esPtr
operator|->
name|script
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
operator|(
name|cmd
index|[
literal|0
index|]
operator|==
literal|'r'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cmd
argument_list|,
literal|"removeall"
argument_list|,
operator|(
name|unsigned
operator|)
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" channelName removeall\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
for|for
control|(
name|esPtr
operator|=
name|chanPtr
operator|->
name|scriptRecordPtr
init|;
name|esPtr
operator|!=
operator|(
name|EventScriptRecord
operator|*
operator|)
name|NULL
condition|;
name|esPtr
operator|=
name|nextEsPtr
control|)
block|{
name|nextEsPtr
operator|=
name|esPtr
operator|->
name|nextPtr
expr_stmt|;
name|Tcl_DeleteChannelHandler
argument_list|(
operator|(
name|Tcl_Channel
operator|)
name|chanPtr
argument_list|,
name|ChannelEventScriptInvoker
argument_list|,
operator|(
name|ClientData
operator|)
name|esPtr
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|esPtr
operator|->
name|script
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|esPtr
argument_list|)
expr_stmt|;
block|}
name|chanPtr
operator|->
name|scriptRecordPtr
operator|=
operator|(
name|EventScriptRecord
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad command "
argument_list|,
name|cmd
argument_list|,
literal|", must be one of "
argument_list|,
literal|"add, delete, list, or removeall"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCopyChannel --  *  *	This routine copies data from one channel to another, either  *	synchronously or asynchronously.  If a command script is  *	supplied, the operation runs in the background.  The script  *	is invoked when the copy completes.  Otherwise the function  *	waits until the copy is completed before returning.  *  * Results:  *	A standard Tcl result.  *  * Side effects:  *	May schedule a background copy operation that causes both  *	channels to be marked busy.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclCopyChannel
parameter_list|(
name|interp
parameter_list|,
name|inChan
parameter_list|,
name|outChan
parameter_list|,
name|toRead
parameter_list|,
name|cmdPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Current interpreter. */
name|Tcl_Channel
name|inChan
decl_stmt|;
comment|/* Channel to read from. */
name|Tcl_Channel
name|outChan
decl_stmt|;
comment|/* Channel to write to. */
name|int
name|toRead
decl_stmt|;
comment|/* Amount of data to copy, or -1 for all. */
name|Tcl_Obj
modifier|*
name|cmdPtr
decl_stmt|;
comment|/* Pointer to script to execute or NULL. */
block|{
name|Channel
modifier|*
name|inPtr
init|=
operator|(
name|Channel
operator|*
operator|)
name|inChan
decl_stmt|;
name|Channel
modifier|*
name|outPtr
init|=
operator|(
name|Channel
operator|*
operator|)
name|outChan
decl_stmt|;
name|int
name|readFlags
decl_stmt|,
name|writeFlags
decl_stmt|;
name|CopyState
modifier|*
name|csPtr
decl_stmt|;
name|int
name|nonBlocking
init|=
operator|(
name|cmdPtr
operator|)
condition|?
name|CHANNEL_NONBLOCKING
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|inPtr
operator|->
name|csPtr
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"channel \""
argument_list|,
name|Tcl_GetChannelName
argument_list|(
name|inChan
argument_list|)
argument_list|,
literal|"\" is busy"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|outPtr
operator|->
name|csPtr
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"channel \""
argument_list|,
name|Tcl_GetChannelName
argument_list|(
name|outChan
argument_list|)
argument_list|,
literal|"\" is busy"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|readFlags
operator|=
name|inPtr
operator|->
name|flags
expr_stmt|;
name|writeFlags
operator|=
name|outPtr
operator|->
name|flags
expr_stmt|;
comment|/*      * Set up the blocking mode appropriately.  Background copies need      * non-blocking channels.  Foreground copies need blocking channels.      * If there is an error, restore the old blocking mode.      */
if|if
condition|(
name|nonBlocking
operator|!=
operator|(
name|readFlags
operator|&
name|CHANNEL_NONBLOCKING
operator|)
condition|)
block|{
if|if
condition|(
name|SetBlockMode
argument_list|(
name|interp
argument_list|,
name|inPtr
argument_list|,
name|nonBlocking
condition|?
name|TCL_MODE_NONBLOCKING
else|:
name|TCL_MODE_BLOCKING
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
block|}
if|if
condition|(
name|inPtr
operator|!=
name|outPtr
condition|)
block|{
if|if
condition|(
name|nonBlocking
operator|!=
operator|(
name|writeFlags
operator|&
name|CHANNEL_NONBLOCKING
operator|)
condition|)
block|{
if|if
condition|(
name|SetBlockMode
argument_list|(
name|NULL
argument_list|,
name|outPtr
argument_list|,
name|nonBlocking
condition|?
name|TCL_MODE_BLOCKING
else|:
name|TCL_MODE_NONBLOCKING
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
if|if
condition|(
name|nonBlocking
operator|!=
operator|(
name|readFlags
operator|&
name|CHANNEL_NONBLOCKING
operator|)
condition|)
block|{
name|SetBlockMode
argument_list|(
name|NULL
argument_list|,
name|inPtr
argument_list|,
operator|(
name|readFlags
operator|&
name|CHANNEL_NONBLOCKING
operator|)
condition|?
name|TCL_MODE_NONBLOCKING
else|:
name|TCL_MODE_BLOCKING
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
block|}
block|}
comment|/*      * Make sure the output side is unbuffered.      */
name|outPtr
operator|->
name|flags
operator|=
operator|(
name|outPtr
operator|->
name|flags
operator|&
operator|~
operator|(
name|CHANNEL_LINEBUFFERED
operator|)
operator|)
operator||
name|CHANNEL_UNBUFFERED
expr_stmt|;
comment|/*      * Allocate a new CopyState to maintain info about the current copy in      * progress.  This structure will be deallocated when the copy is      * completed.      */
name|csPtr
operator|=
operator|(
name|CopyState
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CopyState
argument_list|)
operator|+
name|inPtr
operator|->
name|bufSize
argument_list|)
expr_stmt|;
name|csPtr
operator|->
name|bufSize
operator|=
name|inPtr
operator|->
name|bufSize
expr_stmt|;
name|csPtr
operator|->
name|readPtr
operator|=
name|inPtr
expr_stmt|;
name|csPtr
operator|->
name|writePtr
operator|=
name|outPtr
expr_stmt|;
name|csPtr
operator|->
name|readFlags
operator|=
name|readFlags
expr_stmt|;
name|csPtr
operator|->
name|writeFlags
operator|=
name|writeFlags
expr_stmt|;
name|csPtr
operator|->
name|toRead
operator|=
name|toRead
expr_stmt|;
name|csPtr
operator|->
name|total
operator|=
literal|0
expr_stmt|;
name|csPtr
operator|->
name|interp
operator|=
name|interp
expr_stmt|;
if|if
condition|(
name|cmdPtr
condition|)
block|{
name|Tcl_IncrRefCount
argument_list|(
name|cmdPtr
argument_list|)
expr_stmt|;
block|}
name|csPtr
operator|->
name|cmdPtr
operator|=
name|cmdPtr
expr_stmt|;
name|inPtr
operator|->
name|csPtr
operator|=
name|csPtr
expr_stmt|;
name|outPtr
operator|->
name|csPtr
operator|=
name|csPtr
expr_stmt|;
comment|/*      * Start copying data between the channels.      */
return|return
name|CopyData
argument_list|(
name|csPtr
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CopyData --  *  *	This function implements the lowest level of the copying  *	mechanism for TclCopyChannel.  *  * Results:  *	Returns TCL_OK on success, else TCL_ERROR.  *  * Side effects:  *	Moves data between channels, may create channel handlers.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CopyData
parameter_list|(
name|csPtr
parameter_list|,
name|mask
parameter_list|)
name|CopyState
modifier|*
name|csPtr
decl_stmt|;
comment|/* State of copy operation. */
name|int
name|mask
decl_stmt|;
comment|/* Current channel event flags. */
block|{
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
name|Tcl_Obj
modifier|*
name|cmdPtr
decl_stmt|,
modifier|*
name|errObj
init|=
name|NULL
decl_stmt|;
name|Tcl_Channel
name|inChan
decl_stmt|,
name|outChan
decl_stmt|;
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|total
decl_stmt|;
name|inChan
operator|=
operator|(
name|Tcl_Channel
operator|)
name|csPtr
operator|->
name|readPtr
expr_stmt|;
name|outChan
operator|=
operator|(
name|Tcl_Channel
operator|)
name|csPtr
operator|->
name|writePtr
expr_stmt|;
name|interp
operator|=
name|csPtr
operator|->
name|interp
expr_stmt|;
name|cmdPtr
operator|=
name|csPtr
operator|->
name|cmdPtr
expr_stmt|;
comment|/*      * Copy the data the slow way, using the translation mechanism.      */
while|while
condition|(
name|csPtr
operator|->
name|toRead
operator|!=
literal|0
condition|)
block|{
comment|/* 	 * Check for unreported background errors. 	 */
if|if
condition|(
name|csPtr
operator|->
name|readPtr
operator|->
name|unreportedError
operator|!=
literal|0
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|csPtr
operator|->
name|readPtr
operator|->
name|unreportedError
argument_list|)
expr_stmt|;
name|csPtr
operator|->
name|readPtr
operator|->
name|unreportedError
operator|=
literal|0
expr_stmt|;
goto|goto
name|readError
goto|;
block|}
if|if
condition|(
name|csPtr
operator|->
name|writePtr
operator|->
name|unreportedError
operator|!=
literal|0
condition|)
block|{
name|Tcl_SetErrno
argument_list|(
name|csPtr
operator|->
name|writePtr
operator|->
name|unreportedError
argument_list|)
expr_stmt|;
name|csPtr
operator|->
name|writePtr
operator|->
name|unreportedError
operator|=
literal|0
expr_stmt|;
goto|goto
name|writeError
goto|;
block|}
comment|/* 	 * Read up to bufSize bytes. 	 */
if|if
condition|(
operator|(
name|csPtr
operator|->
name|toRead
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|csPtr
operator|->
name|toRead
operator|>
name|csPtr
operator|->
name|bufSize
operator|)
condition|)
block|{
name|size
operator|=
name|csPtr
operator|->
name|bufSize
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
name|csPtr
operator|->
name|toRead
expr_stmt|;
block|}
name|size
operator|=
name|DoRead
argument_list|(
name|csPtr
operator|->
name|readPtr
argument_list|,
name|csPtr
operator|->
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|readError
label|:
name|errObj
operator|=
name|Tcl_NewObj
argument_list|()
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|errObj
argument_list|,
literal|"error reading \""
argument_list|,
name|Tcl_GetChannelName
argument_list|(
name|inChan
argument_list|)
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
comment|/* 	     * We had an underflow on the read side.  If we are at EOF, 	     * then the copying is done, otherwise set up a channel 	     * handler to detect when the channel becomes readable again. 	     */
if|if
condition|(
name|Tcl_Eof
argument_list|(
name|inChan
argument_list|)
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|mask
operator|&
name|TCL_READABLE
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|TCL_WRITABLE
condition|)
block|{
name|Tcl_DeleteChannelHandler
argument_list|(
name|outChan
argument_list|,
name|CopyEventProc
argument_list|,
operator|(
name|ClientData
operator|)
name|csPtr
argument_list|)
expr_stmt|;
block|}
name|Tcl_CreateChannelHandler
argument_list|(
name|inChan
argument_list|,
name|TCL_READABLE
argument_list|,
name|CopyEventProc
argument_list|,
operator|(
name|ClientData
operator|)
name|csPtr
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
comment|/* 	 * Now write the buffer out. 	 */
name|size
operator|=
name|DoWrite
argument_list|(
name|csPtr
operator|->
name|writePtr
argument_list|,
name|csPtr
operator|->
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|writeError
label|:
name|errObj
operator|=
name|Tcl_NewObj
argument_list|()
expr_stmt|;
name|Tcl_AppendStringsToObj
argument_list|(
name|errObj
argument_list|,
literal|"error writing \""
argument_list|,
name|Tcl_GetChannelName
argument_list|(
name|outChan
argument_list|)
argument_list|,
literal|"\": "
argument_list|,
name|Tcl_PosixError
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Check to see if the write is happening in the background.  If so, 	 * stop copying and wait for the channel to become writable again. 	 */
if|if
condition|(
name|csPtr
operator|->
name|writePtr
operator|->
name|flags
operator|&
name|BG_FLUSH_SCHEDULED
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|mask
operator|&
name|TCL_WRITABLE
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|TCL_READABLE
condition|)
block|{
name|Tcl_DeleteChannelHandler
argument_list|(
name|outChan
argument_list|,
name|CopyEventProc
argument_list|,
operator|(
name|ClientData
operator|)
name|csPtr
argument_list|)
expr_stmt|;
block|}
name|Tcl_CreateChannelHandler
argument_list|(
name|outChan
argument_list|,
name|TCL_WRITABLE
argument_list|,
name|CopyEventProc
argument_list|,
operator|(
name|ClientData
operator|)
name|csPtr
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
comment|/* 	 * Update the current byte count if we care. 	 */
if|if
condition|(
name|csPtr
operator|->
name|toRead
operator|!=
operator|-
literal|1
condition|)
block|{
name|csPtr
operator|->
name|toRead
operator|-=
name|size
expr_stmt|;
block|}
name|csPtr
operator|->
name|total
operator|+=
name|size
expr_stmt|;
comment|/* 	 * For background copies, we only do one buffer per invocation so 	 * we don't starve the rest of the system. 	 */
if|if
condition|(
name|cmdPtr
condition|)
block|{
comment|/* 	     * The first time we enter this code, there won't be a 	     * channel handler established yet, so do it here. 	     */
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
block|{
name|Tcl_CreateChannelHandler
argument_list|(
name|outChan
argument_list|,
name|TCL_WRITABLE
argument_list|,
name|CopyEventProc
argument_list|,
operator|(
name|ClientData
operator|)
name|csPtr
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
block|}
comment|/*      * Make the callback or return the number of bytes transferred.      * The local total is used because StopCopy frees csPtr.      */
name|total
operator|=
name|csPtr
operator|->
name|total
expr_stmt|;
if|if
condition|(
name|cmdPtr
condition|)
block|{
comment|/* 	 * Get a private copy of the command so we can mutate it 	 * by adding arguments.  Note that StopCopy frees our saved 	 * reference to the original command obj. 	 */
name|cmdPtr
operator|=
name|Tcl_DuplicateObj
argument_list|(
name|cmdPtr
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|cmdPtr
argument_list|)
expr_stmt|;
name|StopCopy
argument_list|(
name|csPtr
argument_list|)
expr_stmt|;
name|Tcl_Preserve
argument_list|(
operator|(
name|ClientData
operator|)
name|interp
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|cmdPtr
argument_list|,
name|Tcl_NewIntObj
argument_list|(
name|total
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errObj
condition|)
block|{
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|cmdPtr
argument_list|,
name|errObj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Tcl_EvalObj
argument_list|(
name|interp
argument_list|,
name|cmdPtr
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_BackgroundError
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
name|Tcl_DecrRefCount
argument_list|(
name|cmdPtr
argument_list|)
expr_stmt|;
name|Tcl_Release
argument_list|(
operator|(
name|ClientData
operator|)
name|interp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|StopCopy
argument_list|(
name|csPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|errObj
condition|)
block|{
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|errObj
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
else|else
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_SetIntObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|total
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CopyEventProc --  *  *	This routine is invoked as a channel event handler for  *	the background copy operation.  It is just a trivial wrapper  *	around the CopyData routine.  *  * Results:  *	None.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|CopyEventProc
parameter_list|(
name|clientData
parameter_list|,
name|mask
parameter_list|)
name|ClientData
name|clientData
decl_stmt|;
name|int
name|mask
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|CopyData
argument_list|(
operator|(
name|CopyState
operator|*
operator|)
name|clientData
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * StopCopy --  *  *	This routine halts a copy that is in progress.  *  * Results:  *	None.  *  * Side effects:  *	Removes any pending channel handlers and restores the blocking  *	and buffering modes of the channels.  The CopyState is freed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|StopCopy
parameter_list|(
name|csPtr
parameter_list|)
name|CopyState
modifier|*
name|csPtr
decl_stmt|;
comment|/* State for bg copy to stop . */
block|{
name|int
name|nonBlocking
decl_stmt|;
if|if
condition|(
operator|!
name|csPtr
condition|)
block|{
return|return;
block|}
comment|/*      * Restore the old blocking mode and output buffering mode.      */
name|nonBlocking
operator|=
operator|(
name|csPtr
operator|->
name|readFlags
operator|&
name|CHANNEL_NONBLOCKING
operator|)
expr_stmt|;
if|if
condition|(
name|nonBlocking
operator|!=
operator|(
name|csPtr
operator|->
name|readPtr
operator|->
name|flags
operator|&
name|CHANNEL_NONBLOCKING
operator|)
condition|)
block|{
name|SetBlockMode
argument_list|(
name|NULL
argument_list|,
name|csPtr
operator|->
name|readPtr
argument_list|,
name|nonBlocking
condition|?
name|TCL_MODE_NONBLOCKING
else|:
name|TCL_MODE_BLOCKING
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|csPtr
operator|->
name|writePtr
operator|!=
name|csPtr
operator|->
name|writePtr
condition|)
block|{
if|if
condition|(
name|nonBlocking
operator|!=
operator|(
name|csPtr
operator|->
name|writePtr
operator|->
name|flags
operator|&
name|CHANNEL_NONBLOCKING
operator|)
condition|)
block|{
name|SetBlockMode
argument_list|(
name|NULL
argument_list|,
name|csPtr
operator|->
name|writePtr
argument_list|,
name|nonBlocking
condition|?
name|TCL_MODE_NONBLOCKING
else|:
name|TCL_MODE_BLOCKING
argument_list|)
expr_stmt|;
block|}
block|}
name|csPtr
operator|->
name|writePtr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CHANNEL_LINEBUFFERED
operator||
name|CHANNEL_UNBUFFERED
operator|)
expr_stmt|;
name|csPtr
operator|->
name|writePtr
operator|->
name|flags
operator||=
name|csPtr
operator|->
name|writeFlags
operator|&
operator|(
name|CHANNEL_LINEBUFFERED
operator||
name|CHANNEL_UNBUFFERED
operator|)
expr_stmt|;
if|if
condition|(
name|csPtr
operator|->
name|cmdPtr
condition|)
block|{
name|Tcl_DeleteChannelHandler
argument_list|(
operator|(
name|Tcl_Channel
operator|)
name|csPtr
operator|->
name|readPtr
argument_list|,
name|CopyEventProc
argument_list|,
operator|(
name|ClientData
operator|)
name|csPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|csPtr
operator|->
name|readPtr
operator|!=
name|csPtr
operator|->
name|writePtr
condition|)
block|{
name|Tcl_DeleteChannelHandler
argument_list|(
operator|(
name|Tcl_Channel
operator|)
name|csPtr
operator|->
name|writePtr
argument_list|,
name|CopyEventProc
argument_list|,
operator|(
name|ClientData
operator|)
name|csPtr
argument_list|)
expr_stmt|;
block|}
name|Tcl_DecrRefCount
argument_list|(
name|csPtr
operator|->
name|cmdPtr
argument_list|)
expr_stmt|;
block|}
name|csPtr
operator|->
name|readPtr
operator|->
name|csPtr
operator|=
name|NULL
expr_stmt|;
name|csPtr
operator|->
name|writePtr
operator|->
name|csPtr
operator|=
name|NULL
expr_stmt|;
name|ckfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|csPtr
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

