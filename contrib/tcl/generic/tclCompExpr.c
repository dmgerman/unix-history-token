begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tclCompExpr.c --  *  *	This file contains the code to compile Tcl expressions.  *  * Copyright (c) 1996-1997 Sun Microsystems, Inc.  *  * See the file "license.terms" for information on usage and redistribution  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.  *  * SCCS: @(#) tclCompExpr.c 1.31 97/08/07 10:14:07  */
end_comment

begin_include
include|#
directive|include
file|"tclInt.h"
end_include

begin_include
include|#
directive|include
file|"tclCompile.h"
end_include

begin_comment
comment|/*  * The stuff below is a bit of a hack so that this file can be used in  * environments that include no UNIX, i.e. no errno: just arrange to use  * the errno from tclExecute.c here.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TCL_GENERIC_ONLY
end_ifndef

begin_include
include|#
directive|include
file|"tclPort.h"
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NO_ERRNO_H
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_ERRNO_H
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use errno from tclExecute.c. */
end_comment

begin_define
define|#
directive|define
name|ERANGE
value|34
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Boolean variable that controls whether expression compilation tracing  * is enabled.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|traceCompileExpr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_COMPILE_DEBUG */
end_comment

begin_comment
comment|/*  * The ExprInfo structure describes the state of compiling an expression.  * A pointer to an ExprInfo record is passed among the routines in  * this module.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ExprInfo
block|{
name|int
name|token
decl_stmt|;
comment|/* Type of the last token parsed in expr. 				 * See below for definitions. Corresponds 				 * to the characters just before next. */
name|int
name|objIndex
decl_stmt|;
comment|/* If token is a literal value, the index of 				 * an object holding the value in the code's 				 * object table; otherwise is NULL. */
name|char
modifier|*
name|funcName
decl_stmt|;
comment|/* If the token is FUNC_NAME, points to the 				 * first character of the math function's 				 * name; otherwise is NULL. */
name|char
modifier|*
name|next
decl_stmt|;
comment|/* Position of the next character to be 				 * scanned in the expression string. */
name|char
modifier|*
name|originalExpr
decl_stmt|;
comment|/* The entire expression that was originally 				 * passed to Tcl_ExprString et al. */
name|char
modifier|*
name|lastChar
decl_stmt|;
comment|/* Pointer to terminating null in 				 * originalExpr. */
name|int
name|hasOperators
decl_stmt|;
comment|/* Set 1 if the expr has operators; 0 if 				 * expr is only a primary. If 1 after 				 * compiling an expr, a tryCvtToNumeric 				 * instruction is emitted to convert the 				 * primary to a number if possible. */
name|int
name|exprIsJustVarRef
decl_stmt|;
comment|/* Set 1 if the expr consists of just a 				 * variable reference as in the expression 				 * of "if $b then...". Otherwise 0. If 1 the 				 * expr is compiled out-of-line in order to 				 * implement expr's 2 level substitution 				 * semantics properly. */
name|int
name|exprIsComparison
decl_stmt|;
comment|/* Set 1 if the top-level operator in the 				 * expr is a comparison. Otherwise 0. If 1, 				 * because the operands might be strings, 				 * the expr is compiled out-of-line in order 				 * to implement expr's 2 level substitution 				 * semantics properly. */
block|}
name|ExprInfo
typedef|;
end_typedef

begin_comment
comment|/*  * Definitions of the different tokens that appear in expressions. The order  * of these must match the corresponding entries in the operatorStrings  * array below.  */
end_comment

begin_define
define|#
directive|define
name|LITERAL
value|0
end_define

begin_define
define|#
directive|define
name|FUNC_NAME
value|(LITERAL + 1)
end_define

begin_define
define|#
directive|define
name|OPEN_BRACKET
value|(LITERAL + 2)
end_define

begin_define
define|#
directive|define
name|CLOSE_BRACKET
value|(LITERAL + 3)
end_define

begin_define
define|#
directive|define
name|OPEN_PAREN
value|(LITERAL + 4)
end_define

begin_define
define|#
directive|define
name|CLOSE_PAREN
value|(LITERAL + 5)
end_define

begin_define
define|#
directive|define
name|DOLLAR
value|(LITERAL + 6)
end_define

begin_define
define|#
directive|define
name|QUOTE
value|(LITERAL + 7)
end_define

begin_define
define|#
directive|define
name|COMMA
value|(LITERAL + 8)
end_define

begin_define
define|#
directive|define
name|END
value|(LITERAL + 9)
end_define

begin_define
define|#
directive|define
name|UNKNOWN
value|(LITERAL + 10)
end_define

begin_comment
comment|/*  * Binary operators:  */
end_comment

begin_define
define|#
directive|define
name|MULT
value|(UNKNOWN + 1)
end_define

begin_define
define|#
directive|define
name|DIVIDE
value|(MULT + 1)
end_define

begin_define
define|#
directive|define
name|MOD
value|(MULT + 2)
end_define

begin_define
define|#
directive|define
name|PLUS
value|(MULT + 3)
end_define

begin_define
define|#
directive|define
name|MINUS
value|(MULT + 4)
end_define

begin_define
define|#
directive|define
name|LEFT_SHIFT
value|(MULT + 5)
end_define

begin_define
define|#
directive|define
name|RIGHT_SHIFT
value|(MULT + 6)
end_define

begin_define
define|#
directive|define
name|LESS
value|(MULT + 7)
end_define

begin_define
define|#
directive|define
name|GREATER
value|(MULT + 8)
end_define

begin_define
define|#
directive|define
name|LEQ
value|(MULT + 9)
end_define

begin_define
define|#
directive|define
name|GEQ
value|(MULT + 10)
end_define

begin_define
define|#
directive|define
name|EQUAL
value|(MULT + 11)
end_define

begin_define
define|#
directive|define
name|NEQ
value|(MULT + 12)
end_define

begin_define
define|#
directive|define
name|BIT_AND
value|(MULT + 13)
end_define

begin_define
define|#
directive|define
name|BIT_XOR
value|(MULT + 14)
end_define

begin_define
define|#
directive|define
name|BIT_OR
value|(MULT + 15)
end_define

begin_define
define|#
directive|define
name|AND
value|(MULT + 16)
end_define

begin_define
define|#
directive|define
name|OR
value|(MULT + 17)
end_define

begin_define
define|#
directive|define
name|QUESTY
value|(MULT + 18)
end_define

begin_define
define|#
directive|define
name|COLON
value|(MULT + 19)
end_define

begin_comment
comment|/*  * Unary operators. Unary minus and plus are represented by the (binary)  * tokens MINUS and PLUS.  */
end_comment

begin_define
define|#
directive|define
name|NOT
value|(COLON + 1)
end_define

begin_define
define|#
directive|define
name|BIT_NOT
value|(NOT + 1)
end_define

begin_comment
comment|/*  * Mapping from tokens to strings; used for debugging messages. These  * entries must match the order and number of the token definitions above.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tokenStrings
index|[]
init|=
block|{
literal|"LITERAL"
block|,
literal|"FUNCNAME"
block|,
literal|"["
block|,
literal|"]"
block|,
literal|"("
block|,
literal|")"
block|,
literal|"$"
block|,
literal|"\""
block|,
literal|","
block|,
literal|"END"
block|,
literal|"UNKNOWN"
block|,
literal|"*"
block|,
literal|"/"
block|,
literal|"%"
block|,
literal|"+"
block|,
literal|"-"
block|,
literal|"<<"
block|,
literal|">>"
block|,
literal|"<"
block|,
literal|">"
block|,
literal|"<="
block|,
literal|">="
block|,
literal|"=="
block|,
literal|"!="
block|,
literal|"&"
block|,
literal|"^"
block|,
literal|"|"
block|,
literal|"&&"
block|,
literal|"||"
block|,
literal|"?"
block|,
literal|":"
block|,
literal|"!"
block|,
literal|"~"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_COMPILE_DEBUG */
end_comment

begin_comment
comment|/*  * Declarations for local procedures to this file:  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|CompileAddExpr
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExprInfo
operator|*
name|infoPtr
operator|,
name|int
name|flags
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CompileBitAndExpr
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExprInfo
operator|*
name|infoPtr
operator|,
name|int
name|flags
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CompileBitOrExpr
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExprInfo
operator|*
name|infoPtr
operator|,
name|int
name|flags
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CompileBitXorExpr
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExprInfo
operator|*
name|infoPtr
operator|,
name|int
name|flags
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CompileCondExpr
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExprInfo
operator|*
name|infoPtr
operator|,
name|int
name|flags
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CompileEqualityExpr
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExprInfo
operator|*
name|infoPtr
operator|,
name|int
name|flags
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CompileLandExpr
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExprInfo
operator|*
name|infoPtr
operator|,
name|int
name|flags
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CompileLorExpr
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExprInfo
operator|*
name|infoPtr
operator|,
name|int
name|flags
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CompileMathFuncCall
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExprInfo
operator|*
name|infoPtr
operator|,
name|int
name|flags
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CompileMultiplyExpr
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExprInfo
operator|*
name|infoPtr
operator|,
name|int
name|flags
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CompilePrimaryExpr
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExprInfo
operator|*
name|infoPtr
operator|,
name|int
name|flags
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CompileRelationalExpr
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExprInfo
operator|*
name|infoPtr
operator|,
name|int
name|flags
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CompileShiftExpr
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExprInfo
operator|*
name|infoPtr
operator|,
name|int
name|flags
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CompileUnaryExpr
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExprInfo
operator|*
name|infoPtr
operator|,
name|int
name|flags
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|GetToken
name|_ANSI_ARGS_
argument_list|(
operator|(
name|Tcl_Interp
operator|*
name|interp
operator|,
name|ExprInfo
operator|*
name|infoPtr
operator|,
name|CompileEnv
operator|*
name|envPtr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Macro used to debug the execution of the recursive descent parser used  * to compile expressions.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|HERE
parameter_list|(
name|production
parameter_list|,
name|level
parameter_list|)
define|\
value|if (traceCompileExpr) { \ 	fprintf(stderr, "%*s%s: token=%s, next=\"%.20s\"\n", \ 		(level), " ", (production), tokenStrings[infoPtr->token], \ 		infoPtr->next); \     }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|HERE
parameter_list|(
name|production
parameter_list|,
name|level
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCL_COMPILE_DEBUG */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * TclCompileExpr --  *  *	This procedure compiles a string containing a Tcl expression into  *	Tcl bytecodes. This procedure is the top-level interface to the  *	the expression compilation module, and is used by such public  *	procedures as Tcl_ExprString, Tcl_ExprStringObj, Tcl_ExprLong,  *	Tcl_ExprDouble, Tcl_ExprBoolean, and Tcl_ExprBooleanObj.  *  *	Note that the topmost recursive-descent parsing routine used by  *	TclCompileExpr to compile expressions is called "CompileCondExpr"  *	and not, e.g., "CompileExpr". This is done to avoid an extra  *	procedure call since such a procedure would only return the result  *	of calling CompileCondExpr. Other recursive-descent procedures  *	that need to parse expressions also call CompileCondExpr.  *  * Results:  *	The return value is TCL_OK on a successful compilation and TCL_ERROR  *	on failure. If TCL_ERROR is returned, then the interpreter's result  *	contains an error message.  *  *	envPtr->termOffset is filled in with the offset of the character in  *	"string" just after the last one successfully processed; this might  *	be the offset of the ']' (if flags& TCL_BRACKET_TERM), or the  *	offset of the '\0' at the end of the string.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the expression.  *  *	envPtr->exprIsJustVarRef is set 1 if the expression consisted of  *	a single variable reference as in the expression of "if $b then...".  *	Otherwise it is set 0. This is used to implement Tcl's two level  *	expression substitution semantics properly.  *  *	envPtr->exprIsComparison is set 1 if the top-level operator in the  *	expr is a comparison. Otherwise it is set 0. If 1, because the  *	operands might be strings, the expr is compiled out-of-line in order  *	to implement expr's 2 level substitution semantics properly.  *  * Side effects:  *	Adds instructions to envPtr to evaluate the expression at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|TclCompileExpr
parameter_list|(
name|interp
parameter_list|,
name|string
parameter_list|,
name|lastChar
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* The source string to compile. */
name|char
modifier|*
name|lastChar
decl_stmt|;
comment|/* Pointer to terminating character of 				 * string. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|ExprInfo
name|info
decl_stmt|;
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute the expression. */
name|int
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|TCL_COMPILE_DEBUG
if|if
condition|(
name|traceCompileExpr
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"expr: string=\"%.30s\"\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TCL_COMPILE_DEBUG */
comment|/*      * Register the builtin math functions the first time an expression is      * compiled.      */
if|if
condition|(
operator|!
operator|(
name|iPtr
operator|->
name|flags
operator|&
name|EXPR_INITIALIZED
operator|)
condition|)
block|{
name|BuiltinFunc
modifier|*
name|funcPtr
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|MathFunc
modifier|*
name|mathFuncPtr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|iPtr
operator|->
name|flags
operator||=
name|EXPR_INITIALIZED
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|funcPtr
operator|=
name|builtinFuncTable
init|;
name|funcPtr
operator|->
name|name
operator|!=
name|NULL
condition|;
name|funcPtr
operator|++
control|)
block|{
name|Tcl_CreateMathFunc
argument_list|(
name|interp
argument_list|,
name|funcPtr
operator|->
name|name
argument_list|,
name|funcPtr
operator|->
name|numArgs
argument_list|,
name|funcPtr
operator|->
name|argTypes
argument_list|,
operator|(
name|Tcl_MathProc
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|)
expr_stmt|;
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|mathFuncTable
argument_list|,
name|funcPtr
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"TclCompileExpr: Tcl_CreateMathFunc incorrectly registered '%s'"
argument_list|,
name|funcPtr
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|mathFuncPtr
operator|=
operator|(
name|MathFunc
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
name|mathFuncPtr
operator|->
name|builtinFuncIndex
operator|=
name|i
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
name|info
operator|.
name|token
operator|=
name|UNKNOWN
expr_stmt|;
name|info
operator|.
name|objIndex
operator|=
operator|-
literal|1
expr_stmt|;
name|info
operator|.
name|funcName
operator|=
name|NULL
expr_stmt|;
name|info
operator|.
name|next
operator|=
name|string
expr_stmt|;
name|info
operator|.
name|originalExpr
operator|=
name|string
expr_stmt|;
name|info
operator|.
name|lastChar
operator|=
name|lastChar
expr_stmt|;
name|info
operator|.
name|hasOperators
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|exprIsJustVarRef
operator|=
literal|1
expr_stmt|;
comment|/* will be set 0 if anything else is seen */
name|info
operator|.
name|exprIsComparison
operator|=
literal|0
expr_stmt|;
comment|/* set 1 if topmost operator is<,==,etc. */
comment|/*      * Get the first token then compile an expression.      */
name|result
operator|=
name|GetToken
argument_list|(
name|interp
argument_list|,
operator|&
name|info
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|result
operator|=
name|CompileCondExpr
argument_list|(
name|interp
argument_list|,
operator|&
name|info
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|info
operator|.
name|token
operator|!=
name|END
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"syntax error in expression \""
argument_list|,
name|string
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|!
name|info
operator|.
name|hasOperators
condition|)
block|{
comment|/* 	 * Attempt to convert the primary's object to an int or double. 	 * This is done in order to support Tcl's policy of interpreting 	 * operands if at all possible as first integers, else 	 * floating-point numbers. 	 */
name|TclEmitOpcode
argument_list|(
name|INST_TRY_CVT_TO_NUMERIC
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
name|done
label|:
name|envPtr
operator|->
name|termOffset
operator|=
operator|(
name|info
operator|.
name|next
operator|-
name|string
operator|)
expr_stmt|;
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
name|envPtr
operator|->
name|exprIsJustVarRef
operator|=
name|info
operator|.
name|exprIsJustVarRef
expr_stmt|;
name|envPtr
operator|->
name|exprIsComparison
operator|=
name|info
operator|.
name|exprIsComparison
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CompileCondExpr --  *  *	This procedure compiles a Tcl conditional expression:  *	condExpr ::= lorExpr ['?' condExpr ':' condExpr]  *  *	Note that this is the topmost recursive-descent parsing routine used  *	by TclCompileExpr to compile expressions. It does not call an  *	separate, higher-level "CompileExpr" procedure. This avoids an extra  *	procedure call since such a procedure would only return the result  *	of calling CompileCondExpr. Other recursive-descent procedures that  *	need to parse expressions also call CompileCondExpr.  *  * Results:  *	The return value is TCL_OK on a successful compilation and TCL_ERROR  *	on failure. If TCL_ERROR is returned, then the interpreter's result  *	contains an error message.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the expression.  *  * Side effects:  *	Adds instructions to envPtr to evaluate the expression at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CompileCondExpr
parameter_list|(
name|interp
parameter_list|,
name|infoPtr
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|ExprInfo
modifier|*
name|infoPtr
decl_stmt|;
comment|/* Describes the compilation state for the 				 * expression being compiled. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute the expression. */
name|JumpFixup
name|jumpAroundThenFixup
decl_stmt|,
name|jumpAroundElseFixup
decl_stmt|;
comment|/* Used to update or replace one-byte jumps 				 * around the then and else expressions when 				 * their target PCs are determined. */
name|int
name|elseCodeOffset
decl_stmt|,
name|currCodeOffset
decl_stmt|,
name|jumpDist
decl_stmt|,
name|result
decl_stmt|;
name|HERE
argument_list|(
literal|"condExpr"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|CompileLorExpr
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
if|if
condition|(
name|infoPtr
operator|->
name|token
operator|==
name|QUESTY
condition|)
block|{
name|result
operator|=
name|GetToken
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* skip over the '?' */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Emit the jump around the "then" clause to the "else" condExpr if 	 * the test was false. We emit a one byte (relative) jump here, and 	 * replace it later with a four byte jump if the jump target is more 	 * than 127 bytes away. 	 */
name|TclEmitForwardJump
argument_list|(
name|envPtr
argument_list|,
name|TCL_FALSE_JUMP
argument_list|,
operator|&
name|jumpAroundThenFixup
argument_list|)
expr_stmt|;
comment|/* 	 * Compile the "then" expression. Note that if a subexpression 	 * is only a primary, we need to try to convert it to numeric. 	 * This is done in order to support Tcl's policy of interpreting 	 * operands if at all possible as first integers, else 	 * floating-point numbers. 	 */
name|infoPtr
operator|->
name|hasOperators
operator|=
literal|0
expr_stmt|;
name|infoPtr
operator|->
name|exprIsJustVarRef
operator|=
literal|0
expr_stmt|;
name|infoPtr
operator|->
name|exprIsComparison
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|CompileCondExpr
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|TclMax
argument_list|(
name|envPtr
operator|->
name|maxStackDepth
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
if|if
condition|(
name|infoPtr
operator|->
name|token
operator|!=
name|COLON
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"syntax error in expression \""
argument_list|,
name|infoPtr
operator|->
name|originalExpr
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|!
name|infoPtr
operator|->
name|hasOperators
condition|)
block|{
name|TclEmitOpcode
argument_list|(
name|INST_TRY_CVT_TO_NUMERIC
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|GetToken
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* skip over the ':' */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Emit an unconditional jump around the "else" condExpr. 	 */
name|TclEmitForwardJump
argument_list|(
name|envPtr
argument_list|,
name|TCL_UNCONDITIONAL_JUMP
argument_list|,
operator|&
name|jumpAroundElseFixup
argument_list|)
expr_stmt|;
comment|/* 	 * Compile the "else" expression. 	 */
name|infoPtr
operator|->
name|hasOperators
operator|=
literal|0
expr_stmt|;
name|elseCodeOffset
operator|=
name|TclCurrCodeOffset
argument_list|()
expr_stmt|;
name|result
operator|=
name|CompileCondExpr
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|TclMax
argument_list|(
name|envPtr
operator|->
name|maxStackDepth
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|infoPtr
operator|->
name|hasOperators
condition|)
block|{
name|TclEmitOpcode
argument_list|(
name|INST_TRY_CVT_TO_NUMERIC
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fix up the second jump: the unconditional jump around the "else" 	 * expression. If the distance is too great (> 127 bytes), replace 	 * it with a four byte instruction and move the instructions after 	 * the jump down. 	 */
name|currCodeOffset
operator|=
name|TclCurrCodeOffset
argument_list|()
expr_stmt|;
name|jumpDist
operator|=
operator|(
name|currCodeOffset
operator|-
name|jumpAroundElseFixup
operator|.
name|codeOffset
operator|)
expr_stmt|;
if|if
condition|(
name|TclFixupForwardJump
argument_list|(
name|envPtr
argument_list|,
operator|&
name|jumpAroundElseFixup
argument_list|,
name|jumpDist
argument_list|,
literal|127
argument_list|)
condition|)
block|{
comment|/* 	     * Update the else expression's starting code offset since it 	     * moved down 3 bytes too. 	     */
name|elseCodeOffset
operator|+=
literal|3
expr_stmt|;
block|}
comment|/* 	 * Now fix up the first branch: the jumpFalse after the test. If the 	 * distance is too great, replace it with a four byte instruction 	 * and update the code offsets for the commands in both the "then" 	 * and "else" expressions. 	 */
name|jumpDist
operator|=
operator|(
name|elseCodeOffset
operator|-
name|jumpAroundThenFixup
operator|.
name|codeOffset
operator|)
expr_stmt|;
name|TclFixupForwardJump
argument_list|(
name|envPtr
argument_list|,
operator|&
name|jumpAroundThenFixup
argument_list|,
name|jumpDist
argument_list|,
literal|127
argument_list|)
expr_stmt|;
name|infoPtr
operator|->
name|hasOperators
operator|=
literal|1
expr_stmt|;
comment|/* 	 * A comparison is not the top-level operator in this expression. 	 */
name|infoPtr
operator|->
name|exprIsComparison
operator|=
literal|0
expr_stmt|;
block|}
name|done
label|:
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CompileLorExpr --  *  *	This procedure compiles a Tcl logical or expression:  *	lorExpr ::= landExpr {'||' landExpr}  *  * Results:  *	The return value is TCL_OK on a successful compilation and TCL_ERROR  *	on failure. If TCL_ERROR is returned, then the interpreter's result  *	contains an error message.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the expression.  *  * Side effects:  *	Adds instructions to envPtr to evaluate the expression at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CompileLorExpr
parameter_list|(
name|interp
parameter_list|,
name|infoPtr
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|ExprInfo
modifier|*
name|infoPtr
decl_stmt|;
comment|/* Describes the compilation state for the 				 * expression being compiled. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
name|int
name|maxDepth
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute the expression. */
name|JumpFixupArray
name|jumpFixupArray
decl_stmt|;
comment|/* Used to fix up the forward "short 				 * circuit" jump after each or-ed 				 * subexpression to just after the last 				 * subexpression. */
name|JumpFixup
name|jumpTrueFixup
decl_stmt|,
name|jumpFixup
decl_stmt|;
comment|/* Used to emit the jumps in the code to 				 * convert the first operand to a 0 or 1. */
name|int
name|fixupIndex
decl_stmt|,
name|jumpDist
decl_stmt|,
name|currCodeOffset
decl_stmt|,
name|objIndex
decl_stmt|,
name|j
decl_stmt|,
name|result
decl_stmt|;
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|HERE
argument_list|(
literal|"lorExpr"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|result
operator|=
name|CompileLandExpr
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|!=
name|TCL_OK
operator|)
operator|||
operator|(
name|infoPtr
operator|->
name|token
operator|!=
name|OR
operator|)
condition|)
block|{
return|return
name|result
return|;
comment|/* envPtr->maxStackDepth is already set */
block|}
name|infoPtr
operator|->
name|hasOperators
operator|=
literal|1
expr_stmt|;
name|infoPtr
operator|->
name|exprIsJustVarRef
operator|=
literal|0
expr_stmt|;
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
name|TclInitJumpFixupArray
argument_list|(
operator|&
name|jumpFixupArray
argument_list|)
expr_stmt|;
while|while
condition|(
name|infoPtr
operator|->
name|token
operator|==
name|OR
condition|)
block|{
name|result
operator|=
name|GetToken
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* skip over the '||' */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|jumpFixupArray
operator|.
name|next
operator|==
literal|0
condition|)
block|{
comment|/* 	     * Just the first "lor" operand is on the stack. The following 	     * is slightly ugly: we need to convert that first "lor" operand 	     * to a "0" or "1" to get the correct result if it is nonzero. 	     * Eventually we'll use a new instruction for this. 	     */
name|TclEmitForwardJump
argument_list|(
name|envPtr
argument_list|,
name|TCL_TRUE_JUMP
argument_list|,
operator|&
name|jumpTrueFixup
argument_list|)
expr_stmt|;
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
literal|"0"
argument_list|,
literal|1
argument_list|,
comment|/*allocStrRep*/
literal|0
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|objPtr
operator|=
name|envPtr
operator|->
name|objArrayPtr
index|[
name|objIndex
index|]
expr_stmt|;
name|Tcl_InvalidateStringRep
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|=
literal|0
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclIntType
expr_stmt|;
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|TclEmitForwardJump
argument_list|(
name|envPtr
argument_list|,
name|TCL_UNCONDITIONAL_JUMP
argument_list|,
operator|&
name|jumpFixup
argument_list|)
expr_stmt|;
name|jumpDist
operator|=
operator|(
name|TclCurrCodeOffset
argument_list|()
operator|-
name|jumpTrueFixup
operator|.
name|codeOffset
operator|)
expr_stmt|;
if|if
condition|(
name|TclFixupForwardJump
argument_list|(
name|envPtr
argument_list|,
operator|&
name|jumpTrueFixup
argument_list|,
name|jumpDist
argument_list|,
literal|127
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"CompileLorExpr: bad jump distance %d\n"
argument_list|,
name|jumpDist
argument_list|)
expr_stmt|;
block|}
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
literal|"1"
argument_list|,
literal|1
argument_list|,
comment|/*allocStrRep*/
literal|0
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|objPtr
operator|=
name|envPtr
operator|->
name|objArrayPtr
index|[
name|objIndex
index|]
expr_stmt|;
name|Tcl_InvalidateStringRep
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|=
literal|1
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclIntType
expr_stmt|;
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|jumpDist
operator|=
operator|(
name|TclCurrCodeOffset
argument_list|()
operator|-
name|jumpFixup
operator|.
name|codeOffset
operator|)
expr_stmt|;
if|if
condition|(
name|TclFixupForwardJump
argument_list|(
name|envPtr
argument_list|,
operator|&
name|jumpFixup
argument_list|,
name|jumpDist
argument_list|,
literal|127
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"CompileLorExpr: bad jump distance %d\n"
argument_list|,
name|jumpDist
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Duplicate the value on top of the stack to prevent the jump from 	 * consuming it. 	 */
name|TclEmitOpcode
argument_list|(
name|INST_DUP
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* 	 * Emit the "short circuit" jump around the rest of the lorExp if 	 * the previous expression was true. We emit a one byte (relative) 	 * jump here, and replace it later with a four byte jump if the jump 	 * target is more than 127 bytes away. 	 */
if|if
condition|(
name|jumpFixupArray
operator|.
name|next
operator|==
name|jumpFixupArray
operator|.
name|end
condition|)
block|{
name|TclExpandJumpFixupArray
argument_list|(
operator|&
name|jumpFixupArray
argument_list|)
expr_stmt|;
block|}
name|fixupIndex
operator|=
name|jumpFixupArray
operator|.
name|next
expr_stmt|;
name|jumpFixupArray
operator|.
name|next
operator|++
expr_stmt|;
name|TclEmitForwardJump
argument_list|(
name|envPtr
argument_list|,
name|TCL_TRUE_JUMP
argument_list|,
operator|&
operator|(
name|jumpFixupArray
operator|.
name|fixup
index|[
name|fixupIndex
index|]
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Compile the subexpression. 	 */
name|result
operator|=
name|CompileLandExpr
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|TclMax
argument_list|(
operator|(
name|envPtr
operator|->
name|maxStackDepth
operator|+
literal|1
operator|)
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
comment|/* 	 * Emit a "logical or" instruction. This does not try to "short- 	 * circuit" the evaluation of both operands of a Tcl "||" operator, 	 * but instead ensures that we either have a "1" or a "0" result. 	 */
name|TclEmitOpcode
argument_list|(
name|INST_LOR
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * Now that we know the target of the forward jumps, update the jumps      * with the correct distance. Also, if the distance is too great (> 127      * bytes), replace the jump with a four byte instruction and move the      * instructions after the jump down.      */
for|for
control|(
name|j
operator|=
name|jumpFixupArray
operator|.
name|next
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|fixupIndex
operator|=
operator|(
name|j
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* process closest jump first */
name|currCodeOffset
operator|=
name|TclCurrCodeOffset
argument_list|()
expr_stmt|;
name|jumpDist
operator|=
operator|(
name|currCodeOffset
operator|-
name|jumpFixupArray
operator|.
name|fixup
index|[
name|fixupIndex
index|]
operator|.
name|codeOffset
operator|)
expr_stmt|;
name|TclFixupForwardJump
argument_list|(
name|envPtr
argument_list|,
operator|&
operator|(
name|jumpFixupArray
operator|.
name|fixup
index|[
name|fixupIndex
index|]
operator|)
argument_list|,
name|jumpDist
argument_list|,
literal|127
argument_list|)
expr_stmt|;
block|}
comment|/*      * We get here only if one or more ||'s appear as top-level operators.      */
name|done
label|:
name|infoPtr
operator|->
name|exprIsComparison
operator|=
literal|0
expr_stmt|;
name|TclFreeJumpFixupArray
argument_list|(
operator|&
name|jumpFixupArray
argument_list|)
expr_stmt|;
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CompileLandExpr --  *  *	This procedure compiles a Tcl logical and expression:  *	landExpr ::= bitOrExpr {'&&' bitOrExpr}  *  * Results:  *	The return value is TCL_OK on a successful compilation and TCL_ERROR  *	on failure. If TCL_ERROR is returned, then the interpreter's result  *	contains an error message.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the expression.  *  * Side effects:  *	Adds instructions to envPtr to evaluate the expression at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CompileLandExpr
parameter_list|(
name|interp
parameter_list|,
name|infoPtr
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|ExprInfo
modifier|*
name|infoPtr
decl_stmt|;
comment|/* Describes the compilation state for the 				 * expression being compiled. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
name|int
name|maxDepth
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute the expression. */
name|JumpFixupArray
name|jumpFixupArray
decl_stmt|;
comment|/* Used to fix up the forward "short 				 * circuit" jump after each and-ed 				 * subexpression to just after the last 				 * subexpression. */
name|JumpFixup
name|jumpTrueFixup
decl_stmt|,
name|jumpFixup
decl_stmt|;
comment|/* Used to emit the jumps in the code to 				 * convert the first operand to a 0 or 1. */
name|int
name|fixupIndex
decl_stmt|,
name|jumpDist
decl_stmt|,
name|currCodeOffset
decl_stmt|,
name|objIndex
decl_stmt|,
name|j
decl_stmt|,
name|result
decl_stmt|;
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
name|HERE
argument_list|(
literal|"landExpr"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|result
operator|=
name|CompileBitOrExpr
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|!=
name|TCL_OK
operator|)
operator|||
operator|(
name|infoPtr
operator|->
name|token
operator|!=
name|AND
operator|)
condition|)
block|{
return|return
name|result
return|;
comment|/* envPtr->maxStackDepth is already set */
block|}
name|infoPtr
operator|->
name|hasOperators
operator|=
literal|1
expr_stmt|;
name|infoPtr
operator|->
name|exprIsJustVarRef
operator|=
literal|0
expr_stmt|;
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
name|TclInitJumpFixupArray
argument_list|(
operator|&
name|jumpFixupArray
argument_list|)
expr_stmt|;
while|while
condition|(
name|infoPtr
operator|->
name|token
operator|==
name|AND
condition|)
block|{
name|result
operator|=
name|GetToken
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* skip over the '&&' */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|jumpFixupArray
operator|.
name|next
operator|==
literal|0
condition|)
block|{
comment|/* 	     * Just the first "land" operand is on the stack. The following 	     * is slightly ugly: we need to convert the first "land" operand 	     * to a "0" or "1" to get the correct result if it is 	     * nonzero. Eventually we'll use a new instruction. 	     */
name|TclEmitForwardJump
argument_list|(
name|envPtr
argument_list|,
name|TCL_TRUE_JUMP
argument_list|,
operator|&
name|jumpTrueFixup
argument_list|)
expr_stmt|;
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
literal|"0"
argument_list|,
literal|1
argument_list|,
comment|/*allocStrRep*/
literal|0
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|objPtr
operator|=
name|envPtr
operator|->
name|objArrayPtr
index|[
name|objIndex
index|]
expr_stmt|;
name|Tcl_InvalidateStringRep
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|=
literal|0
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclIntType
expr_stmt|;
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|TclEmitForwardJump
argument_list|(
name|envPtr
argument_list|,
name|TCL_UNCONDITIONAL_JUMP
argument_list|,
operator|&
name|jumpFixup
argument_list|)
expr_stmt|;
name|jumpDist
operator|=
operator|(
name|TclCurrCodeOffset
argument_list|()
operator|-
name|jumpTrueFixup
operator|.
name|codeOffset
operator|)
expr_stmt|;
if|if
condition|(
name|TclFixupForwardJump
argument_list|(
name|envPtr
argument_list|,
operator|&
name|jumpTrueFixup
argument_list|,
name|jumpDist
argument_list|,
literal|127
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"CompileLandExpr: bad jump distance %d\n"
argument_list|,
name|jumpDist
argument_list|)
expr_stmt|;
block|}
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
literal|"1"
argument_list|,
literal|1
argument_list|,
comment|/*allocStrRep*/
literal|0
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|objPtr
operator|=
name|envPtr
operator|->
name|objArrayPtr
index|[
name|objIndex
index|]
expr_stmt|;
name|Tcl_InvalidateStringRep
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|=
literal|1
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclIntType
expr_stmt|;
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|jumpDist
operator|=
operator|(
name|TclCurrCodeOffset
argument_list|()
operator|-
name|jumpFixup
operator|.
name|codeOffset
operator|)
expr_stmt|;
if|if
condition|(
name|TclFixupForwardJump
argument_list|(
name|envPtr
argument_list|,
operator|&
name|jumpFixup
argument_list|,
name|jumpDist
argument_list|,
literal|127
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"CompileLandExpr: bad jump distance %d\n"
argument_list|,
name|jumpDist
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Duplicate the value on top of the stack to prevent the jump from 	 * consuming it. 	 */
name|TclEmitOpcode
argument_list|(
name|INST_DUP
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* 	 * Emit the "short circuit" jump around the rest of the landExp if 	 * the previous expression was false. We emit a one byte (relative) 	 * jump here, and replace it later with a four byte jump if the jump 	 * target is more than 127 bytes away. 	 */
if|if
condition|(
name|jumpFixupArray
operator|.
name|next
operator|==
name|jumpFixupArray
operator|.
name|end
condition|)
block|{
name|TclExpandJumpFixupArray
argument_list|(
operator|&
name|jumpFixupArray
argument_list|)
expr_stmt|;
block|}
name|fixupIndex
operator|=
name|jumpFixupArray
operator|.
name|next
expr_stmt|;
name|jumpFixupArray
operator|.
name|next
operator|++
expr_stmt|;
name|TclEmitForwardJump
argument_list|(
name|envPtr
argument_list|,
name|TCL_FALSE_JUMP
argument_list|,
operator|&
operator|(
name|jumpFixupArray
operator|.
name|fixup
index|[
name|fixupIndex
index|]
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Compile the subexpression. 	 */
name|result
operator|=
name|CompileBitOrExpr
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|TclMax
argument_list|(
operator|(
name|envPtr
operator|->
name|maxStackDepth
operator|+
literal|1
operator|)
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
comment|/* 	 * Emit a "logical and" instruction. This does not try to "short- 	 * circuit" the evaluation of both operands of a Tcl "&&" operator, 	 * but instead ensures that we either have a "1" or a "0" result. 	 */
name|TclEmitOpcode
argument_list|(
name|INST_LAND
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * Now that we know the target of the forward jumps, update the jumps      * with the correct distance. Also, if the distance is too great (> 127      * bytes), replace the jump with a four byte instruction and move the      * instructions after the jump down.      */
for|for
control|(
name|j
operator|=
name|jumpFixupArray
operator|.
name|next
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|fixupIndex
operator|=
operator|(
name|j
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* process closest jump first */
name|currCodeOffset
operator|=
name|TclCurrCodeOffset
argument_list|()
expr_stmt|;
name|jumpDist
operator|=
operator|(
name|currCodeOffset
operator|-
name|jumpFixupArray
operator|.
name|fixup
index|[
name|fixupIndex
index|]
operator|.
name|codeOffset
operator|)
expr_stmt|;
name|TclFixupForwardJump
argument_list|(
name|envPtr
argument_list|,
operator|&
operator|(
name|jumpFixupArray
operator|.
name|fixup
index|[
name|fixupIndex
index|]
operator|)
argument_list|,
name|jumpDist
argument_list|,
literal|127
argument_list|)
expr_stmt|;
block|}
comment|/*      * We get here only if one or more&&'s appear as top-level operators.      */
name|done
label|:
name|infoPtr
operator|->
name|exprIsComparison
operator|=
literal|0
expr_stmt|;
name|TclFreeJumpFixupArray
argument_list|(
operator|&
name|jumpFixupArray
argument_list|)
expr_stmt|;
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CompileBitOrExpr --  *  *	This procedure compiles a Tcl bitwise or expression:  *	bitOrExpr ::= bitXorExpr {'|' bitXorExpr}  *  * Results:  *	The return value is TCL_OK on a successful compilation and TCL_ERROR  *	on failure. If TCL_ERROR is returned, then the interpreter's result  *	contains an error message.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the expression.  *  * Side effects:  *	Adds instructions to envPtr to evaluate the expression at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CompileBitOrExpr
parameter_list|(
name|interp
parameter_list|,
name|infoPtr
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|ExprInfo
modifier|*
name|infoPtr
decl_stmt|;
comment|/* Describes the compilation state for the 				 * expression being compiled. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute the expression. */
name|int
name|result
decl_stmt|;
name|HERE
argument_list|(
literal|"bitOrExpr"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|result
operator|=
name|CompileBitXorExpr
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
while|while
condition|(
name|infoPtr
operator|->
name|token
operator|==
name|BIT_OR
condition|)
block|{
name|infoPtr
operator|->
name|hasOperators
operator|=
literal|1
expr_stmt|;
name|infoPtr
operator|->
name|exprIsJustVarRef
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|GetToken
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* skip over the '|' */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|result
operator|=
name|CompileBitXorExpr
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|TclMax
argument_list|(
operator|(
name|envPtr
operator|->
name|maxStackDepth
operator|+
literal|1
operator|)
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
name|TclEmitOpcode
argument_list|(
name|INST_BITOR
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* 	 * A comparison is not the top-level operator in this expression. 	 */
name|infoPtr
operator|->
name|exprIsComparison
operator|=
literal|0
expr_stmt|;
block|}
name|done
label|:
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CompileBitXorExpr --  *  *	This procedure compiles a Tcl bitwise exclusive or expression:  *	bitXorExpr ::= bitAndExpr {'^' bitAndExpr}  *  * Results:  *	The return value is TCL_OK on a successful compilation and TCL_ERROR  *	on failure. If TCL_ERROR is returned, then the interpreter's result  *	contains an error message.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the expression.  *  * Side effects:  *	Adds instructions to envPtr to evaluate the expression at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CompileBitXorExpr
parameter_list|(
name|interp
parameter_list|,
name|infoPtr
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|ExprInfo
modifier|*
name|infoPtr
decl_stmt|;
comment|/* Describes the compilation state for the 				 * expression being compiled. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute the expression. */
name|int
name|result
decl_stmt|;
name|HERE
argument_list|(
literal|"bitXorExpr"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|result
operator|=
name|CompileBitAndExpr
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
while|while
condition|(
name|infoPtr
operator|->
name|token
operator|==
name|BIT_XOR
condition|)
block|{
name|infoPtr
operator|->
name|hasOperators
operator|=
literal|1
expr_stmt|;
name|infoPtr
operator|->
name|exprIsJustVarRef
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|GetToken
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* skip over the '^' */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|result
operator|=
name|CompileBitAndExpr
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|TclMax
argument_list|(
operator|(
name|envPtr
operator|->
name|maxStackDepth
operator|+
literal|1
operator|)
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
name|TclEmitOpcode
argument_list|(
name|INST_BITXOR
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* 	 * A comparison is not the top-level operator in this expression. 	 */
name|infoPtr
operator|->
name|exprIsComparison
operator|=
literal|0
expr_stmt|;
block|}
name|done
label|:
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CompileBitAndExpr --  *  *	This procedure compiles a Tcl bitwise and expression:  *	bitAndExpr ::= equalityExpr {'&' equalityExpr}  *  * Results:  *	The return value is TCL_OK on a successful compilation and TCL_ERROR  *	on failure. If TCL_ERROR is returned, then the interpreter's result  *	contains an error message.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the expression.  *  * Side effects:  *	Adds instructions to envPtr to evaluate the expression at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CompileBitAndExpr
parameter_list|(
name|interp
parameter_list|,
name|infoPtr
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|ExprInfo
modifier|*
name|infoPtr
decl_stmt|;
comment|/* Describes the compilation state for the 				 * expression being compiled. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute the expression. */
name|int
name|result
decl_stmt|;
name|HERE
argument_list|(
literal|"bitAndExpr"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|result
operator|=
name|CompileEqualityExpr
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
while|while
condition|(
name|infoPtr
operator|->
name|token
operator|==
name|BIT_AND
condition|)
block|{
name|infoPtr
operator|->
name|hasOperators
operator|=
literal|1
expr_stmt|;
name|infoPtr
operator|->
name|exprIsJustVarRef
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|GetToken
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* skip over the '&' */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|result
operator|=
name|CompileEqualityExpr
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|TclMax
argument_list|(
operator|(
name|envPtr
operator|->
name|maxStackDepth
operator|+
literal|1
operator|)
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
name|TclEmitOpcode
argument_list|(
name|INST_BITAND
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* 	 * A comparison is not the top-level operator in this expression. 	 */
name|infoPtr
operator|->
name|exprIsComparison
operator|=
literal|0
expr_stmt|;
block|}
name|done
label|:
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CompileEqualityExpr --  *  *	This procedure compiles a Tcl equality (inequality) expression:  *	equalityExpr ::= relationalExpr {('==' | '!=') relationalExpr}  *  * Results:  *	The return value is TCL_OK on a successful compilation and TCL_ERROR  *	on failure. If TCL_ERROR is returned, then the interpreter's result  *	contains an error message.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the expression.  *  * Side effects:  *	Adds instructions to envPtr to evaluate the expression at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CompileEqualityExpr
parameter_list|(
name|interp
parameter_list|,
name|infoPtr
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|ExprInfo
modifier|*
name|infoPtr
decl_stmt|;
comment|/* Describes the compilation state for the 				 * expression being compiled. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute the expression. */
name|int
name|op
decl_stmt|,
name|result
decl_stmt|;
name|HERE
argument_list|(
literal|"equalityExpr"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|result
operator|=
name|CompileRelationalExpr
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
name|op
operator|=
name|infoPtr
operator|->
name|token
expr_stmt|;
while|while
condition|(
operator|(
name|op
operator|==
name|EQUAL
operator|)
operator|||
operator|(
name|op
operator|==
name|NEQ
operator|)
condition|)
block|{
name|infoPtr
operator|->
name|hasOperators
operator|=
literal|1
expr_stmt|;
name|infoPtr
operator|->
name|exprIsJustVarRef
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|GetToken
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* skip over == or != */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|result
operator|=
name|CompileRelationalExpr
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|TclMax
argument_list|(
operator|(
name|envPtr
operator|->
name|maxStackDepth
operator|+
literal|1
operator|)
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|EQUAL
condition|)
block|{
name|TclEmitOpcode
argument_list|(
name|INST_EQ
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TclEmitOpcode
argument_list|(
name|INST_NEQ
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
name|op
operator|=
name|infoPtr
operator|->
name|token
expr_stmt|;
comment|/* 	 * A comparison _is_ the top-level operator in this expression. 	 */
name|infoPtr
operator|->
name|exprIsComparison
operator|=
literal|1
expr_stmt|;
block|}
name|done
label|:
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CompileRelationalExpr --  *  *	This procedure compiles a Tcl relational expression:  *	relationalExpr ::= shiftExpr {('<' | '>' | '<=' | '>=') shiftExpr}  *  * Results:  *	The return value is TCL_OK on a successful compilation and TCL_ERROR  *	on failure. If TCL_ERROR is returned, then the interpreter's result  *	contains an error message.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the expression.  *  * Side effects:  *	Adds instructions to envPtr to evaluate the expression at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CompileRelationalExpr
parameter_list|(
name|interp
parameter_list|,
name|infoPtr
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|ExprInfo
modifier|*
name|infoPtr
decl_stmt|;
comment|/* Describes the compilation state for the 				 * expression being compiled. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute the expression. */
name|int
name|op
decl_stmt|,
name|result
decl_stmt|;
name|HERE
argument_list|(
literal|"relationalExpr"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|result
operator|=
name|CompileShiftExpr
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
name|op
operator|=
name|infoPtr
operator|->
name|token
expr_stmt|;
while|while
condition|(
operator|(
name|op
operator|==
name|LESS
operator|)
operator|||
operator|(
name|op
operator|==
name|GREATER
operator|)
operator|||
operator|(
name|op
operator|==
name|LEQ
operator|)
operator|||
operator|(
name|op
operator|==
name|GEQ
operator|)
condition|)
block|{
name|infoPtr
operator|->
name|hasOperators
operator|=
literal|1
expr_stmt|;
name|infoPtr
operator|->
name|exprIsJustVarRef
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|GetToken
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* skip over the op */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|result
operator|=
name|CompileShiftExpr
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|TclMax
argument_list|(
operator|(
name|envPtr
operator|->
name|maxStackDepth
operator|+
literal|1
operator|)
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|LESS
case|:
name|TclEmitOpcode
argument_list|(
name|INST_LT
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREATER
case|:
name|TclEmitOpcode
argument_list|(
name|INST_GT
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEQ
case|:
name|TclEmitOpcode
argument_list|(
name|INST_LE
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEQ
case|:
name|TclEmitOpcode
argument_list|(
name|INST_GE
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
break|break;
block|}
name|op
operator|=
name|infoPtr
operator|->
name|token
expr_stmt|;
comment|/* 	 * A comparison _is_ the top-level operator in this expression. 	 */
name|infoPtr
operator|->
name|exprIsComparison
operator|=
literal|1
expr_stmt|;
block|}
name|done
label|:
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CompileShiftExpr --  *  *	This procedure compiles a Tcl shift expression:  *	shiftExpr ::= addExpr {('<<' | '>>') addExpr}  *  * Results:  *	The return value is TCL_OK on a successful compilation and TCL_ERROR  *	on failure. If TCL_ERROR is returned, then the interpreter's result  *	contains an error message.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the expression.  *  * Side effects:  *	Adds instructions to envPtr to evaluate the expression at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CompileShiftExpr
parameter_list|(
name|interp
parameter_list|,
name|infoPtr
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|ExprInfo
modifier|*
name|infoPtr
decl_stmt|;
comment|/* Describes the compilation state for the 				 * expression being compiled. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute the expression. */
name|int
name|op
decl_stmt|,
name|result
decl_stmt|;
name|HERE
argument_list|(
literal|"shiftExpr"
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|result
operator|=
name|CompileAddExpr
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
name|op
operator|=
name|infoPtr
operator|->
name|token
expr_stmt|;
while|while
condition|(
operator|(
name|op
operator|==
name|LEFT_SHIFT
operator|)
operator|||
operator|(
name|op
operator|==
name|RIGHT_SHIFT
operator|)
condition|)
block|{
name|infoPtr
operator|->
name|hasOperators
operator|=
literal|1
expr_stmt|;
name|infoPtr
operator|->
name|exprIsJustVarRef
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|GetToken
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* skip over<< or>> */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|result
operator|=
name|CompileAddExpr
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|TclMax
argument_list|(
operator|(
name|envPtr
operator|->
name|maxStackDepth
operator|+
literal|1
operator|)
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|LEFT_SHIFT
condition|)
block|{
name|TclEmitOpcode
argument_list|(
name|INST_LSHIFT
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TclEmitOpcode
argument_list|(
name|INST_RSHIFT
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
name|op
operator|=
name|infoPtr
operator|->
name|token
expr_stmt|;
comment|/* 	 * A comparison is not the top-level operator in this expression. 	 */
name|infoPtr
operator|->
name|exprIsComparison
operator|=
literal|0
expr_stmt|;
block|}
name|done
label|:
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CompileAddExpr --  *  *	This procedure compiles a Tcl addition expression:  *	addExpr ::= multiplyExpr {('+' | '-') multiplyExpr}  *  * Results:  *	The return value is TCL_OK on a successful compilation and TCL_ERROR  *	on failure. If TCL_ERROR is returned, then the interpreter's result  *	contains an error message.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the expression.  *  * Side effects:  *	Adds instructions to envPtr to evaluate the expression at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CompileAddExpr
parameter_list|(
name|interp
parameter_list|,
name|infoPtr
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|ExprInfo
modifier|*
name|infoPtr
decl_stmt|;
comment|/* Describes the compilation state for the 				 * expression being compiled. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute the expression. */
name|int
name|op
decl_stmt|,
name|result
decl_stmt|;
name|HERE
argument_list|(
literal|"addExpr"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|result
operator|=
name|CompileMultiplyExpr
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
name|op
operator|=
name|infoPtr
operator|->
name|token
expr_stmt|;
while|while
condition|(
operator|(
name|op
operator|==
name|PLUS
operator|)
operator|||
operator|(
name|op
operator|==
name|MINUS
operator|)
condition|)
block|{
name|infoPtr
operator|->
name|hasOperators
operator|=
literal|1
expr_stmt|;
name|infoPtr
operator|->
name|exprIsJustVarRef
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|GetToken
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* skip over + or - */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|result
operator|=
name|CompileMultiplyExpr
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|TclMax
argument_list|(
operator|(
name|envPtr
operator|->
name|maxStackDepth
operator|+
literal|1
operator|)
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|PLUS
condition|)
block|{
name|TclEmitOpcode
argument_list|(
name|INST_ADD
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TclEmitOpcode
argument_list|(
name|INST_SUB
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
name|op
operator|=
name|infoPtr
operator|->
name|token
expr_stmt|;
comment|/* 	 * A comparison is not the top-level operator in this expression. 	 */
name|infoPtr
operator|->
name|exprIsComparison
operator|=
literal|0
expr_stmt|;
block|}
name|done
label|:
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CompileMultiplyExpr --  *  *	This procedure compiles a Tcl multiply expression:  *	multiplyExpr ::= unaryExpr {('*' | '/' | '%') unaryExpr}  *  * Results:  *	The return value is TCL_OK on a successful compilation and TCL_ERROR  *	on failure. If TCL_ERROR is returned, then the interpreter's result  *	contains an error message.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the expression.  *  * Side effects:  *	Adds instructions to envPtr to evaluate the expression at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CompileMultiplyExpr
parameter_list|(
name|interp
parameter_list|,
name|infoPtr
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|ExprInfo
modifier|*
name|infoPtr
decl_stmt|;
comment|/* Describes the compilation state for the 				 * expression being compiled. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute the expression. */
name|int
name|op
decl_stmt|,
name|result
decl_stmt|;
name|HERE
argument_list|(
literal|"multiplyExpr"
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|result
operator|=
name|CompileUnaryExpr
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
name|op
operator|=
name|infoPtr
operator|->
name|token
expr_stmt|;
while|while
condition|(
operator|(
name|op
operator|==
name|MULT
operator|)
operator|||
operator|(
name|op
operator|==
name|DIVIDE
operator|)
operator|||
operator|(
name|op
operator|==
name|MOD
operator|)
condition|)
block|{
name|infoPtr
operator|->
name|hasOperators
operator|=
literal|1
expr_stmt|;
name|infoPtr
operator|->
name|exprIsJustVarRef
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|GetToken
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* skip over * or / */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|result
operator|=
name|CompileUnaryExpr
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|TclMax
argument_list|(
operator|(
name|envPtr
operator|->
name|maxStackDepth
operator|+
literal|1
operator|)
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|MULT
condition|)
block|{
name|TclEmitOpcode
argument_list|(
name|INST_MULT
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|DIVIDE
condition|)
block|{
name|TclEmitOpcode
argument_list|(
name|INST_DIV
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TclEmitOpcode
argument_list|(
name|INST_MOD
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
name|op
operator|=
name|infoPtr
operator|->
name|token
expr_stmt|;
comment|/* 	 * A comparison is not the top-level operator in this expression. 	 */
name|infoPtr
operator|->
name|exprIsComparison
operator|=
literal|0
expr_stmt|;
block|}
name|done
label|:
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CompileUnaryExpr --  *  *	This procedure compiles a Tcl unary expression:  *	unaryExpr ::= ('+' | '-' | '~' | '!') unaryExpr | primaryExpr  *  * Results:  *	The return value is TCL_OK on a successful compilation and TCL_ERROR  *	on failure. If TCL_ERROR is returned, then the interpreter's result  *	contains an error message.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the expression.  *  * Side effects:  *	Adds instructions to envPtr to evaluate the expression at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CompileUnaryExpr
parameter_list|(
name|interp
parameter_list|,
name|infoPtr
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|ExprInfo
modifier|*
name|infoPtr
decl_stmt|;
comment|/* Describes the compilation state for the 				 * expression being compiled. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute the expression. */
name|int
name|op
decl_stmt|,
name|result
decl_stmt|;
name|HERE
argument_list|(
literal|"unaryExpr"
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|op
operator|=
name|infoPtr
operator|->
name|token
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|==
name|PLUS
operator|)
operator|||
operator|(
name|op
operator|==
name|MINUS
operator|)
operator|||
operator|(
name|op
operator|==
name|BIT_NOT
operator|)
operator|||
operator|(
name|op
operator|==
name|NOT
operator|)
condition|)
block|{
name|infoPtr
operator|->
name|hasOperators
operator|=
literal|1
expr_stmt|;
name|infoPtr
operator|->
name|exprIsJustVarRef
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|GetToken
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* skip over the op */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|result
operator|=
name|CompileUnaryExpr
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|PLUS
case|:
name|TclEmitOpcode
argument_list|(
name|INST_UPLUS
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|TclEmitOpcode
argument_list|(
name|INST_UMINUS
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_NOT
case|:
name|TclEmitOpcode
argument_list|(
name|INST_BITNOT
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOT
case|:
name|TclEmitOpcode
argument_list|(
name|INST_LNOT
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * A comparison is not the top-level operator in this expression. 	 */
name|infoPtr
operator|->
name|exprIsComparison
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* must be a primaryExpr */
name|result
operator|=
name|CompilePrimaryExpr
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
block|}
name|done
label|:
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CompilePrimaryExpr --  *  *	This procedure compiles a Tcl primary expression:  *	primaryExpr ::= literal | varReference | quotedString |  *			'[' command ']' | mathFuncCall | '(' condExpr ')'  *  * Results:  *	The return value is TCL_OK on a successful compilation and TCL_ERROR  *	on failure. If TCL_ERROR is returned, then the interpreter's result  *	contains an error message.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the expression.  *  * Side effects:  *	Adds instructions to envPtr to evaluate the expression at runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CompilePrimaryExpr
parameter_list|(
name|interp
parameter_list|,
name|infoPtr
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|ExprInfo
modifier|*
name|infoPtr
decl_stmt|;
comment|/* Describes the compilation state for the 				 * expression being compiled. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute the expression. */
name|int
name|theToken
decl_stmt|;
name|char
modifier|*
name|dollarPtr
decl_stmt|,
modifier|*
name|quotePtr
decl_stmt|,
modifier|*
name|cmdPtr
decl_stmt|,
modifier|*
name|termPtr
decl_stmt|;
name|int
name|result
init|=
name|TCL_OK
decl_stmt|;
comment|/*      * We emit tryCvtToNumeric instructions after most of these primary      * expressions in order to support Tcl's policy of interpreting operands      * as first integers if possible, otherwise floating-point numbers if      * possible.      */
name|HERE
argument_list|(
literal|"primaryExpr"
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|theToken
operator|=
name|infoPtr
operator|->
name|token
expr_stmt|;
if|if
condition|(
name|theToken
operator|!=
name|DOLLAR
condition|)
block|{
name|infoPtr
operator|->
name|exprIsJustVarRef
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|theToken
condition|)
block|{
case|case
name|LITERAL
case|:
comment|/* int, double, or string in braces */
name|TclEmitPush
argument_list|(
name|infoPtr
operator|->
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|maxDepth
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DOLLAR
case|:
comment|/* $var variable reference */
name|dollarPtr
operator|=
operator|(
name|infoPtr
operator|->
name|next
operator|-
literal|1
operator|)
expr_stmt|;
name|envPtr
operator|->
name|pushSimpleWords
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|TclCompileDollarVar
argument_list|(
name|interp
argument_list|,
name|dollarPtr
argument_list|,
name|infoPtr
operator|->
name|lastChar
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
name|infoPtr
operator|->
name|next
operator|=
operator|(
name|dollarPtr
operator|+
name|envPtr
operator|->
name|termOffset
operator|)
expr_stmt|;
break|break;
case|case
name|QUOTE
case|:
comment|/* quotedString */
name|quotePtr
operator|=
name|infoPtr
operator|->
name|next
expr_stmt|;
name|envPtr
operator|->
name|pushSimpleWords
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|TclCompileQuotes
argument_list|(
name|interp
argument_list|,
name|quotePtr
argument_list|,
name|infoPtr
operator|->
name|lastChar
argument_list|,
literal|'"'
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
name|infoPtr
operator|->
name|next
operator|=
operator|(
name|quotePtr
operator|+
name|envPtr
operator|->
name|termOffset
operator|)
expr_stmt|;
break|break;
case|case
name|OPEN_BRACKET
case|:
comment|/* '[' command ']' */
name|cmdPtr
operator|=
name|infoPtr
operator|->
name|next
expr_stmt|;
name|envPtr
operator|->
name|pushSimpleWords
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|TclCompileString
argument_list|(
name|interp
argument_list|,
name|cmdPtr
argument_list|,
name|infoPtr
operator|->
name|lastChar
argument_list|,
operator|(
name|flags
operator||
name|TCL_BRACKET_TERM
operator|)
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|termPtr
operator|=
operator|(
name|cmdPtr
operator|+
name|envPtr
operator|->
name|termOffset
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|termPtr
operator|==
literal|']'
condition|)
block|{
name|infoPtr
operator|->
name|next
operator|=
operator|(
name|termPtr
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* advance over the ']'. */
block|}
elseif|else
if|if
condition|(
name|termPtr
operator|==
name|infoPtr
operator|->
name|lastChar
condition|)
block|{
comment|/* 	     * Missing ] at end of nested command. 	     */
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"missing close-bracket"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"CompilePrimaryExpr: unexpected termination char '%c' for nested command\n"
argument_list|,
operator|*
name|termPtr
argument_list|)
expr_stmt|;
block|}
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
break|break;
case|case
name|FUNC_NAME
case|:
name|result
operator|=
name|CompileMathFuncCall
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
break|break;
case|case
name|OPEN_PAREN
case|:
name|result
operator|=
name|GetToken
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* skip over the '(' */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|infoPtr
operator|->
name|exprIsComparison
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|CompileCondExpr
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|=
name|envPtr
operator|->
name|maxStackDepth
expr_stmt|;
if|if
condition|(
name|infoPtr
operator|->
name|token
operator|!=
name|CLOSE_PAREN
condition|)
block|{
goto|goto
name|syntaxError
goto|;
block|}
break|break;
default|default:
goto|goto
name|syntaxError
goto|;
block|}
if|if
condition|(
name|theToken
operator|!=
name|FUNC_NAME
condition|)
block|{
comment|/* 	 * Advance to the next token before returning. 	 */
name|result
operator|=
name|GetToken
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
return|return
name|result
return|;
name|syntaxError
label|:
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"syntax error in expression \""
argument_list|,
name|infoPtr
operator|->
name|originalExpr
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * CompileMathFuncCall --  *  *	This procedure compiles a call on a math function in an expression:  *	mathFuncCall ::= funcName '(' [condExpr {',' condExpr}] ')'  *  * Results:  *	The return value is TCL_OK on a successful compilation and TCL_ERROR  *	on failure. If TCL_ERROR is returned, then the interpreter's result  *	contains an error message.  *  *	envPtr->maxStackDepth is updated with the maximum number of stack  *	elements needed to execute the function.  *  * Side effects:  *	Adds instructions to envPtr to evaluate the math function at  *	runtime.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CompileMathFuncCall
parameter_list|(
name|interp
parameter_list|,
name|infoPtr
parameter_list|,
name|flags
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Used for error reporting. */
name|ExprInfo
modifier|*
name|infoPtr
decl_stmt|;
comment|/* Describes the compilation state for the 				 * expression being compiled. */
name|int
name|flags
decl_stmt|;
comment|/* Flags to control compilation (same as 				 * passed to Tcl_Eval). */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds resulting instructions. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|int
name|maxDepth
init|=
literal|0
decl_stmt|;
comment|/* Maximum number of stack elements needed 				 * to execute the expression. */
name|MathFunc
modifier|*
name|mathFuncPtr
decl_stmt|;
comment|/* Info about math function. */
name|int
name|objIndex
decl_stmt|;
comment|/* The object array index for an object 				 * holding the function name if it is not 				 * builtin. */
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|funcName
decl_stmt|;
name|char
name|savedChar
decl_stmt|;
name|int
name|result
decl_stmt|,
name|i
decl_stmt|;
comment|/*      * infoPtr->funcName points to the first character of the math      * function's name. Look for the end of its name and look up the      * MathFunc record for the function.      */
name|funcName
operator|=
name|p
operator|=
name|infoPtr
operator|->
name|funcName
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'_'
operator|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
name|infoPtr
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|result
operator|=
name|GetToken
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* skip over func name */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|infoPtr
operator|->
name|token
operator|!=
name|OPEN_PAREN
condition|)
block|{
goto|goto
name|syntaxError
goto|;
block|}
name|result
operator|=
name|GetToken
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* skip over '(' */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|savedChar
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|hPtr
operator|=
name|Tcl_FindHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|mathFuncTable
argument_list|,
name|funcName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hPtr
operator|==
name|NULL
condition|)
block|{
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"unknown math function \""
argument_list|,
name|funcName
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
operator|*
name|p
operator|=
name|savedChar
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|mathFuncPtr
operator|=
operator|(
name|MathFunc
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
comment|/*      * If not a builtin function, push an object with the function's name.      */
if|if
condition|(
name|mathFuncPtr
operator|->
name|builtinFuncIndex
operator|<
literal|0
condition|)
block|{
comment|/* not builtin */
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
name|funcName
argument_list|,
operator|-
literal|1
argument_list|,
comment|/*allocStrRep*/
literal|1
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|TclEmitPush
argument_list|(
name|objIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
name|maxDepth
operator|=
literal|1
expr_stmt|;
block|}
comment|/*      * Restore the saved character after the function name.      */
operator|*
name|p
operator|=
name|savedChar
expr_stmt|;
comment|/*      * Compile the arguments for the function, if there are any.      */
if|if
condition|(
name|mathFuncPtr
operator|->
name|numArgs
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|infoPtr
operator|->
name|exprIsComparison
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|CompileCondExpr
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|flags
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
comment|/* 	     * Check for a ',' between arguments or a ')' ending the 	     * argument list. 	     */
if|if
condition|(
name|i
operator|==
operator|(
name|mathFuncPtr
operator|->
name|numArgs
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|infoPtr
operator|->
name|token
operator|==
name|CLOSE_PAREN
condition|)
block|{
break|break;
comment|/* exit the argument parsing loop */
block|}
elseif|else
if|if
condition|(
name|infoPtr
operator|->
name|token
operator|==
name|COMMA
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"too many arguments for math function"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
block|{
goto|goto
name|syntaxError
goto|;
block|}
block|}
if|if
condition|(
name|infoPtr
operator|->
name|token
operator|!=
name|COMMA
condition|)
block|{
if|if
condition|(
name|infoPtr
operator|->
name|token
operator|==
name|CLOSE_PAREN
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"too few arguments for math function"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TCL_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
block|{
goto|goto
name|syntaxError
goto|;
block|}
block|}
name|result
operator|=
name|GetToken
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* skip over , */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|maxDepth
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|infoPtr
operator|->
name|token
operator|!=
name|CLOSE_PAREN
condition|)
block|{
goto|goto
name|syntaxError
goto|;
block|}
name|result
operator|=
name|GetToken
argument_list|(
name|interp
argument_list|,
name|infoPtr
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
comment|/* skip over ')' */
if|if
condition|(
name|result
operator|!=
name|TCL_OK
condition|)
block|{
goto|goto
name|done
goto|;
block|}
comment|/*      * Compile the call on the math function. Note that the "objc" argument      * count for non-builtin functions is incremented by 1 to include the      * the function name itself.      */
if|if
condition|(
name|mathFuncPtr
operator|->
name|builtinFuncIndex
operator|>=
literal|0
condition|)
block|{
comment|/* a builtin function */
name|TclEmitInstUInt1
argument_list|(
name|INST_CALL_BUILTIN_FUNC1
argument_list|,
name|mathFuncPtr
operator|->
name|builtinFuncIndex
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TclEmitInstUInt1
argument_list|(
name|INST_CALL_FUNC1
argument_list|,
operator|(
name|mathFuncPtr
operator|->
name|numArgs
operator|+
literal|1
operator|)
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
comment|/*      * A comparison is not the top-level operator in this expression.      */
name|done
label|:
name|infoPtr
operator|->
name|exprIsComparison
operator|=
literal|0
expr_stmt|;
name|envPtr
operator|->
name|maxStackDepth
operator|=
name|maxDepth
expr_stmt|;
return|return
name|result
return|;
name|syntaxError
label|:
name|Tcl_AppendStringsToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"syntax error in expression \""
argument_list|,
name|infoPtr
operator|->
name|originalExpr
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * GetToken --  *  *	Lexical scanner used to compile expressions: parses a single   *	operator or other syntactic element from an expression string.  *  * Results:  *	TCL_OK is returned unless an error occurred. In that case a standard  *	Tcl error is returned, using the interpreter's result to hold an  *	error message. TCL_ERROR is returned if an integer overflow, or a  *	floating-point overflow or underflow occurred while reading in a  *	number. If the lexical analysis is successful, infoPtr->token refers  *	to the next symbol in the expression string, and infoPtr->next is  *	advanced past the token. Also, if the token is a integer, double, or  *	string literal, then infoPtr->objIndex the index of an object  *	holding the value in the code's object table; otherwise is NULL.  *  * Side effects:  *	Object are added to envPtr to hold the values of scanned literal  *	integers, doubles, or strings.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|GetToken
parameter_list|(
name|interp
parameter_list|,
name|infoPtr
parameter_list|,
name|envPtr
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter to use for error 					 * reporting. */
specifier|register
name|ExprInfo
modifier|*
name|infoPtr
decl_stmt|;
comment|/* Describes the state of the 					 * compiling the expression, 					 * including the resulting token. */
name|CompileEnv
modifier|*
name|envPtr
decl_stmt|;
comment|/* Holds objects that store literal 					 * values that are scanned. */
block|{
specifier|register
name|char
modifier|*
name|src
decl_stmt|;
comment|/* Points to current source char. */
specifier|register
name|char
name|c
decl_stmt|;
comment|/* The current char. */
specifier|register
name|int
name|type
decl_stmt|;
comment|/* Current char's CHAR_TYPE type. */
name|char
modifier|*
name|termPtr
decl_stmt|;
comment|/* Points to char terminating a literal. */
name|char
name|savedChar
decl_stmt|;
comment|/* Holds the character termporarily replaced 				 * by a null character during processing of 				 * literal tokens. */
name|int
name|objIndex
decl_stmt|;
comment|/* The object array index for an object 				 * holding a scanned literal. */
name|long
name|longValue
decl_stmt|;
comment|/* Value of a scanned integer literal. */
name|double
name|doubleValue
decl_stmt|;
comment|/* Value of a scanned double literal. */
name|Tcl_Obj
modifier|*
name|objPtr
decl_stmt|;
comment|/*      * First initialize the scanner's "result" fields to default values.      */
name|infoPtr
operator|->
name|token
operator|=
name|UNKNOWN
expr_stmt|;
name|infoPtr
operator|->
name|objIndex
operator|=
operator|-
literal|1
expr_stmt|;
name|infoPtr
operator|->
name|funcName
operator|=
name|NULL
expr_stmt|;
comment|/*      * Scan over leading white space at the start of a token. Note that a      * backslash-newline is treated as a space.      */
name|src
operator|=
name|infoPtr
operator|->
name|next
expr_stmt|;
name|c
operator|=
operator|*
name|src
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|infoPtr
operator|->
name|lastChar
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|type
operator|&
operator|(
name|TCL_SPACE
operator||
name|TCL_BACKSLASH
operator|)
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|TCL_BACKSLASH
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|src
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
break|break;
comment|/* no longer white space */
block|}
block|}
else|else
block|{
name|src
operator|++
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|src
expr_stmt|;
name|type
operator|=
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|infoPtr
operator|->
name|lastChar
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|src
operator|==
name|infoPtr
operator|->
name|lastChar
condition|)
block|{
name|infoPtr
operator|->
name|token
operator|=
name|END
expr_stmt|;
name|infoPtr
operator|->
name|next
operator|=
name|src
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
comment|/*      * Try to parse the token first as an integer or floating-point      * number. Don't check for a number if the first character is "+" or      * "-". If we did, we might treat a binary operator as unary by mistake,      * which would eventually cause a syntax error.      */
if|if
condition|(
operator|(
operator|*
name|src
operator|!=
literal|'+'
operator|)
operator|&&
operator|(
operator|*
name|src
operator|!=
literal|'-'
operator|)
condition|)
block|{
name|int
name|startsWithDigit
init|=
name|isdigit
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|startsWithDigit
operator|&&
name|TclLooksLikeInt
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|longValue
operator|=
name|strtoul
argument_list|(
name|src
argument_list|,
operator|&
name|termPtr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ERANGE
condition|)
block|{
name|char
modifier|*
name|s
init|=
literal|"integer value too large to represent"
decl_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
name|s
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_SetErrorCode
argument_list|(
name|interp
argument_list|,
literal|"ARITH"
argument_list|,
literal|"IOVERFLOW"
argument_list|,
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/* 	     * Find/create an object in envPtr's object array that contains 	     * the integer. 	     */
name|savedChar
operator|=
operator|*
name|termPtr
expr_stmt|;
operator|*
name|termPtr
operator|=
literal|'\0'
expr_stmt|;
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
name|src
argument_list|,
name|termPtr
operator|-
name|src
argument_list|,
comment|/*allocStrRep*/
literal|0
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
operator|*
name|termPtr
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
name|objPtr
operator|=
name|envPtr
operator|->
name|objArrayPtr
index|[
name|objIndex
index|]
expr_stmt|;
name|Tcl_InvalidateStringRep
argument_list|(
name|objPtr
argument_list|)
expr_stmt|;
name|objPtr
operator|->
name|internalRep
operator|.
name|longValue
operator|=
name|longValue
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclIntType
expr_stmt|;
name|infoPtr
operator|->
name|token
operator|=
name|LITERAL
expr_stmt|;
name|infoPtr
operator|->
name|objIndex
operator|=
name|objIndex
expr_stmt|;
name|infoPtr
operator|->
name|next
operator|=
name|termPtr
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
elseif|else
if|if
condition|(
name|startsWithDigit
operator|||
operator|(
operator|*
name|src
operator|==
literal|'.'
operator|)
operator|||
operator|(
operator|*
name|src
operator|==
literal|'n'
operator|)
operator|||
operator|(
operator|*
name|src
operator|==
literal|'N'
operator|)
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|doubleValue
operator|=
name|strtod
argument_list|(
name|src
argument_list|,
operator|&
name|termPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|termPtr
operator|!=
name|src
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|TclExprFloatError
argument_list|(
name|interp
argument_list|,
name|doubleValue
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
comment|/* 		 * Find/create an object in the object array containing the 		 * double. 		 */
name|savedChar
operator|=
operator|*
name|termPtr
expr_stmt|;
operator|*
name|termPtr
operator|=
literal|'\0'
expr_stmt|;
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
name|src
argument_list|,
name|termPtr
operator|-
name|src
argument_list|,
comment|/*allocStrRep*/
literal|1
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
operator|*
name|termPtr
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
name|objPtr
operator|=
name|envPtr
operator|->
name|objArrayPtr
index|[
name|objIndex
index|]
expr_stmt|;
name|objPtr
operator|->
name|internalRep
operator|.
name|doubleValue
operator|=
name|doubleValue
expr_stmt|;
name|objPtr
operator|->
name|typePtr
operator|=
operator|&
name|tclDoubleType
expr_stmt|;
name|infoPtr
operator|->
name|token
operator|=
name|LITERAL
expr_stmt|;
name|infoPtr
operator|->
name|objIndex
operator|=
name|objIndex
expr_stmt|;
name|infoPtr
operator|->
name|next
operator|=
name|termPtr
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
block|}
block|}
comment|/*      * Not an integer or double literal. Check next for a string literal      * in braces.      */
if|if
condition|(
operator|*
name|src
operator|==
literal|'{'
condition|)
block|{
name|int
name|level
init|=
literal|0
decl_stmt|;
comment|/* The {} nesting level. */
name|int
name|hasBackslashNL
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if '\newline' was found. */
name|char
modifier|*
name|string
init|=
name|src
operator|+
literal|1
decl_stmt|;
comment|/* Points just after the starting '{'. */
name|char
modifier|*
name|last
decl_stmt|;
comment|/* Points just before terminating '}'. */
name|int
name|numChars
decl_stmt|;
comment|/* Number of chars in braced string. */
name|char
name|savedChar
decl_stmt|;
comment|/* Holds the character from string 				  * termporarily replaced by a null char 				  * during braced string processing. */
name|int
name|numRead
decl_stmt|;
comment|/* 	 * Check first for any backslash-newlines, since we must treat 	 * backslash-newlines specially (they must be replaced by spaces). 	 */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|src
operator|==
name|infoPtr
operator|->
name|lastChar
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_AppendToObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
literal|"missing close-brace"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|CHAR_TYPE
argument_list|(
name|src
argument_list|,
name|infoPtr
operator|->
name|lastChar
argument_list|)
operator|==
name|TCL_NORMAL
condition|)
block|{
name|src
operator|++
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
operator|*
name|src
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
block|{
name|level
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
block|{
operator|--
name|level
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
name|last
operator|=
operator|(
name|src
operator|-
literal|2
operator|)
expr_stmt|;
comment|/* i.e. just before terminating } */
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|*
name|src
operator|==
literal|'\n'
condition|)
block|{
name|hasBackslashNL
operator|=
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|Tcl_Backslash
argument_list|(
name|src
operator|-
literal|1
argument_list|,
operator|&
name|numRead
argument_list|)
expr_stmt|;
name|src
operator|+=
name|numRead
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * Create a string object for the braced string. This starts at 	 * "string" and ends just after "last" (which points to the final 	 * character before the terminating '}'). If backslash-newlines were 	 * found, we copy characters one at a time into a heap-allocated 	 * buffer and do backslash-newline substitutions. 	 */
name|numChars
operator|=
operator|(
name|last
operator|-
name|string
operator|+
literal|1
operator|)
expr_stmt|;
name|savedChar
operator|=
name|string
index|[
name|numChars
index|]
expr_stmt|;
name|string
index|[
name|numChars
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|hasBackslashNL
operator|&&
operator|(
name|numChars
operator|>
literal|0
operator|)
condition|)
block|{
name|char
modifier|*
name|buffer
init|=
name|ckalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|numChars
operator|+
literal|1
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|dst
init|=
name|buffer
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|string
decl_stmt|;
while|while
condition|(
name|p
operator|<=
name|last
condition|)
block|{
name|c
operator|=
operator|*
name|dst
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
name|dst
index|[
operator|-
literal|1
index|]
operator|=
name|Tcl_Backslash
argument_list|(
name|p
operator|-
literal|1
argument_list|,
operator|&
name|numRead
argument_list|)
expr_stmt|;
name|p
operator|+=
name|numRead
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|Tcl_Backslash
argument_list|(
name|p
operator|-
literal|1
argument_list|,
operator|&
name|numRead
argument_list|)
expr_stmt|;
while|while
condition|(
name|numRead
operator|>
literal|1
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|numRead
operator|--
expr_stmt|;
block|}
block|}
block|}
block|}
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
name|buffer
argument_list|,
name|dst
operator|-
name|buffer
argument_list|,
comment|/*allocStrRep*/
literal|1
argument_list|,
comment|/*inHeap*/
literal|1
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|objIndex
operator|=
name|TclObjIndexForString
argument_list|(
name|string
argument_list|,
name|numChars
argument_list|,
comment|/*allocStrRep*/
literal|1
argument_list|,
comment|/*inHeap*/
literal|0
argument_list|,
name|envPtr
argument_list|)
expr_stmt|;
block|}
name|string
index|[
name|numChars
index|]
operator|=
name|savedChar
expr_stmt|;
comment|/* restore the saved char */
name|infoPtr
operator|->
name|token
operator|=
name|LITERAL
expr_stmt|;
name|infoPtr
operator|->
name|objIndex
operator|=
name|objIndex
expr_stmt|;
name|infoPtr
operator|->
name|next
operator|=
name|src
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
comment|/*      * Not an literal value.      */
name|infoPtr
operator|->
name|next
operator|=
name|src
operator|+
literal|1
expr_stmt|;
comment|/* assume a 1 char token and advance over it */
switch|switch
condition|(
operator|*
name|src
condition|)
block|{
case|case
literal|'['
case|:
name|infoPtr
operator|->
name|token
operator|=
name|OPEN_BRACKET
expr_stmt|;
return|return
name|TCL_OK
return|;
case|case
literal|']'
case|:
name|infoPtr
operator|->
name|token
operator|=
name|CLOSE_BRACKET
expr_stmt|;
return|return
name|TCL_OK
return|;
case|case
literal|'('
case|:
name|infoPtr
operator|->
name|token
operator|=
name|OPEN_PAREN
expr_stmt|;
return|return
name|TCL_OK
return|;
case|case
literal|')'
case|:
name|infoPtr
operator|->
name|token
operator|=
name|CLOSE_PAREN
expr_stmt|;
return|return
name|TCL_OK
return|;
case|case
literal|'$'
case|:
name|infoPtr
operator|->
name|token
operator|=
name|DOLLAR
expr_stmt|;
return|return
name|TCL_OK
return|;
case|case
literal|'"'
case|:
name|infoPtr
operator|->
name|token
operator|=
name|QUOTE
expr_stmt|;
return|return
name|TCL_OK
return|;
case|case
literal|','
case|:
name|infoPtr
operator|->
name|token
operator|=
name|COMMA
expr_stmt|;
return|return
name|TCL_OK
return|;
case|case
literal|'*'
case|:
name|infoPtr
operator|->
name|token
operator|=
name|MULT
expr_stmt|;
return|return
name|TCL_OK
return|;
case|case
literal|'/'
case|:
name|infoPtr
operator|->
name|token
operator|=
name|DIVIDE
expr_stmt|;
return|return
name|TCL_OK
return|;
case|case
literal|'%'
case|:
name|infoPtr
operator|->
name|token
operator|=
name|MOD
expr_stmt|;
return|return
name|TCL_OK
return|;
case|case
literal|'+'
case|:
name|infoPtr
operator|->
name|token
operator|=
name|PLUS
expr_stmt|;
return|return
name|TCL_OK
return|;
case|case
literal|'-'
case|:
name|infoPtr
operator|->
name|token
operator|=
name|MINUS
expr_stmt|;
return|return
name|TCL_OK
return|;
case|case
literal|'?'
case|:
name|infoPtr
operator|->
name|token
operator|=
name|QUESTY
expr_stmt|;
return|return
name|TCL_OK
return|;
case|case
literal|':'
case|:
name|infoPtr
operator|->
name|token
operator|=
name|COLON
expr_stmt|;
return|return
name|TCL_OK
return|;
case|case
literal|'<'
case|:
switch|switch
condition|(
name|src
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'<'
case|:
name|infoPtr
operator|->
name|next
operator|=
name|src
operator|+
literal|2
expr_stmt|;
name|infoPtr
operator|->
name|token
operator|=
name|LEFT_SHIFT
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|infoPtr
operator|->
name|next
operator|=
name|src
operator|+
literal|2
expr_stmt|;
name|infoPtr
operator|->
name|token
operator|=
name|LEQ
expr_stmt|;
break|break;
default|default:
name|infoPtr
operator|->
name|token
operator|=
name|LESS
expr_stmt|;
break|break;
block|}
return|return
name|TCL_OK
return|;
case|case
literal|'>'
case|:
switch|switch
condition|(
name|src
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'>'
case|:
name|infoPtr
operator|->
name|next
operator|=
name|src
operator|+
literal|2
expr_stmt|;
name|infoPtr
operator|->
name|token
operator|=
name|RIGHT_SHIFT
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|infoPtr
operator|->
name|next
operator|=
name|src
operator|+
literal|2
expr_stmt|;
name|infoPtr
operator|->
name|token
operator|=
name|GEQ
expr_stmt|;
break|break;
default|default:
name|infoPtr
operator|->
name|token
operator|=
name|GREATER
expr_stmt|;
break|break;
block|}
return|return
name|TCL_OK
return|;
case|case
literal|'='
case|:
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
name|infoPtr
operator|->
name|next
operator|=
name|src
operator|+
literal|2
expr_stmt|;
name|infoPtr
operator|->
name|token
operator|=
name|EQUAL
expr_stmt|;
block|}
else|else
block|{
name|infoPtr
operator|->
name|token
operator|=
name|UNKNOWN
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
case|case
literal|'!'
case|:
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
name|infoPtr
operator|->
name|next
operator|=
name|src
operator|+
literal|2
expr_stmt|;
name|infoPtr
operator|->
name|token
operator|=
name|NEQ
expr_stmt|;
block|}
else|else
block|{
name|infoPtr
operator|->
name|token
operator|=
name|NOT
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
case|case
literal|'&'
case|:
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'&'
condition|)
block|{
name|infoPtr
operator|->
name|next
operator|=
name|src
operator|+
literal|2
expr_stmt|;
name|infoPtr
operator|->
name|token
operator|=
name|AND
expr_stmt|;
block|}
else|else
block|{
name|infoPtr
operator|->
name|token
operator|=
name|BIT_AND
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
case|case
literal|'^'
case|:
name|infoPtr
operator|->
name|token
operator|=
name|BIT_XOR
expr_stmt|;
return|return
name|TCL_OK
return|;
case|case
literal|'|'
case|:
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'|'
condition|)
block|{
name|infoPtr
operator|->
name|next
operator|=
name|src
operator|+
literal|2
expr_stmt|;
name|infoPtr
operator|->
name|token
operator|=
name|OR
expr_stmt|;
block|}
else|else
block|{
name|infoPtr
operator|->
name|token
operator|=
name|BIT_OR
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
case|case
literal|'~'
case|:
name|infoPtr
operator|->
name|token
operator|=
name|BIT_NOT
expr_stmt|;
return|return
name|TCL_OK
return|;
default|default:
if|if
condition|(
name|isalpha
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
condition|)
block|{
name|infoPtr
operator|->
name|token
operator|=
name|FUNC_NAME
expr_stmt|;
name|infoPtr
operator|->
name|funcName
operator|=
name|src
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
operator|||
operator|(
operator|*
name|src
operator|==
literal|'_'
operator|)
condition|)
block|{
name|src
operator|++
expr_stmt|;
block|}
name|infoPtr
operator|->
name|next
operator|=
name|src
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
name|infoPtr
operator|->
name|next
operator|=
name|src
operator|+
literal|1
expr_stmt|;
name|infoPtr
operator|->
name|token
operator|=
name|UNKNOWN
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * Tcl_CreateMathFunc --  *  *	Creates a new math function for expressions in a given  *	interpreter.  *  * Results:  *	None.  *  * Side effects:  *	The function defined by "name" is created or redefined. If the  *	function already exists then its definition is replaced; this  *	includes the builtin functions. Redefining a builtin function forces  *	all existing code to be invalidated since that code may be compiled  *	using an instruction specific to the replaced function. In addition,  *	redefioning a non-builtin function will force existing code to be  *	invalidated if the number of arguments has changed.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Tcl_CreateMathFunc
parameter_list|(
name|interp
parameter_list|,
name|name
parameter_list|,
name|numArgs
parameter_list|,
name|argTypes
parameter_list|,
name|proc
parameter_list|,
name|clientData
parameter_list|)
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* Interpreter in which function is 					 * to be available. */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of function (e.g. "sin"). */
name|int
name|numArgs
decl_stmt|;
comment|/* Nnumber of arguments required by 					 * function. */
name|Tcl_ValueType
modifier|*
name|argTypes
decl_stmt|;
comment|/* Array of types acceptable for 					 * each argument. */
name|Tcl_MathProc
modifier|*
name|proc
decl_stmt|;
comment|/* Procedure that implements the 					 * math function. */
name|ClientData
name|clientData
decl_stmt|;
comment|/* Additional value to pass to the 					 * function. */
block|{
name|Interp
modifier|*
name|iPtr
init|=
operator|(
name|Interp
operator|*
operator|)
name|interp
decl_stmt|;
name|Tcl_HashEntry
modifier|*
name|hPtr
decl_stmt|;
name|MathFunc
modifier|*
name|mathFuncPtr
decl_stmt|;
name|int
name|new
decl_stmt|,
name|i
decl_stmt|;
name|hPtr
operator|=
name|Tcl_CreateHashEntry
argument_list|(
operator|&
name|iPtr
operator|->
name|mathFuncTable
argument_list|,
name|name
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
name|Tcl_SetHashValue
argument_list|(
name|hPtr
argument_list|,
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|MathFunc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mathFuncPtr
operator|=
operator|(
name|MathFunc
operator|*
operator|)
name|Tcl_GetHashValue
argument_list|(
name|hPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
block|{
if|if
condition|(
name|mathFuncPtr
operator|->
name|builtinFuncIndex
operator|>=
literal|0
condition|)
block|{
comment|/* 	     * We are redefining a builtin math function. Invalidate the              * interpreter's existing code by incrementing its              * compileEpoch member. This field is checked in Tcl_EvalObj              * and ObjInterpProc, and code whose compilation epoch doesn't              * match is recompiled. Newly compiled code will no longer              * treat the function as builtin. 	     */
name|iPtr
operator|->
name|compileEpoch
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * A non-builtin function is being redefined. We must invalidate              * existing code if the number of arguments has changed. This 	     * is because existing code was compiled assuming that number. 	     */
if|if
condition|(
name|numArgs
operator|!=
name|mathFuncPtr
operator|->
name|numArgs
condition|)
block|{
name|iPtr
operator|->
name|compileEpoch
operator|++
expr_stmt|;
block|}
block|}
block|}
name|mathFuncPtr
operator|->
name|builtinFuncIndex
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* can't be a builtin function */
if|if
condition|(
name|numArgs
operator|>
name|MAX_MATH_ARGS
condition|)
block|{
name|numArgs
operator|=
name|MAX_MATH_ARGS
expr_stmt|;
block|}
name|mathFuncPtr
operator|->
name|numArgs
operator|=
name|numArgs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numArgs
condition|;
name|i
operator|++
control|)
block|{
name|mathFuncPtr
operator|->
name|argTypes
index|[
name|i
index|]
operator|=
name|argTypes
index|[
name|i
index|]
expr_stmt|;
block|}
name|mathFuncPtr
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|mathFuncPtr
operator|->
name|clientData
operator|=
name|clientData
expr_stmt|;
block|}
end_function

end_unit

