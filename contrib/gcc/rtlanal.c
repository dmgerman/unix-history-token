begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Analyze RTL for C-Compiler    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_comment
comment|/* Forward declarations */
end_comment

begin_decl_stmt
specifier|static
name|void
name|set_of_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insn_dependent_p_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|computed_jump_p_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parms_set
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bit flags that specify the machine subtype we are compiling for.    Bits are tested using macros TARGET_... defined in the tm.h file    and set by `-m...' switches.  Must be defined in rtlanal.c.  */
end_comment

begin_decl_stmt
name|int
name|target_flags
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return 1 if the value of X is unstable    (would be different at a different point in the program).    The frame pointer, arg pointer, etc. are considered stable    (within one function) and so is anything marked `unchanging'.  */
end_comment

begin_function
name|int
name|rtx_unstable_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MEM
case|:
return|return
operator|!
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|||
name|rtx_unstable_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|QUEUED
case|:
return|return
literal|1
return|;
case|case
name|ADDRESSOF
case|:
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|0
return|;
case|case
name|REG
case|:
comment|/* As in rtx_varies_p, we have to use the actual rtx, not reg number.  */
if|if
condition|(
name|x
operator|==
name|frame_pointer_rtx
operator|||
name|x
operator|==
name|hard_frame_pointer_rtx
comment|/* The arg pointer varies if it is not a fixed register.  */
operator|||
operator|(
name|x
operator|==
name|arg_pointer_rtx
operator|&&
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
operator|)
operator|||
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
ifndef|#
directive|ifndef
name|PIC_OFFSET_TABLE_REG_CALL_CLOBBERED
comment|/* ??? When call-clobbered, the value is stable modulo the restore 	 that must happen after a call.  This currently screws up local-alloc 	 into believing that the restore is not needed.  */
if|if
condition|(
name|x
operator|==
name|pic_offset_table_rtx
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
return|return
literal|1
return|;
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* FALLTHROUGH */
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|rtx_unstable_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|rtx_unstable_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X has a value that can vary even between two    executions of the program.  0 means X can be compared reliably    against certain constants or near-constants.    FOR_ALIAS is nonzero if we are called from alias analysis; if it is    zero, we are slightly more conservative.    The frame pointer and the arg pointer are considered constant.  */
end_comment

begin_function
name|int
name|rtx_varies_p
parameter_list|(
name|x
parameter_list|,
name|for_alias
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|for_alias
decl_stmt|;
block|{
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MEM
case|:
return|return
operator|!
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|||
name|rtx_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|for_alias
argument_list|)
return|;
case|case
name|QUEUED
case|:
return|return
literal|1
return|;
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|0
return|;
case|case
name|REG
case|:
comment|/* Note that we have to test for the actual rtx used for the frame 	 and arg pointers and not just the register number in case we have 	 eliminated the frame and/or arg pointer and are using it 	 for pseudos.  */
if|if
condition|(
name|x
operator|==
name|frame_pointer_rtx
operator|||
name|x
operator|==
name|hard_frame_pointer_rtx
comment|/* The arg pointer varies if it is not a fixed register.  */
operator|||
operator|(
name|x
operator|==
name|arg_pointer_rtx
operator|&&
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|x
operator|==
name|pic_offset_table_rtx
ifdef|#
directive|ifdef
name|PIC_OFFSET_TABLE_REG_CALL_CLOBBERED
comment|/* ??? When call-clobbered, the value is stable modulo the restore 	     that must happen after a call.  This currently screws up 	     local-alloc into believing that the restore is not needed, so we 	     must return 0 only if we are called from alias analysis.  */
operator|&&
name|for_alias
endif|#
directive|endif
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|LO_SUM
case|:
comment|/* The operand 0 of a LO_SUM is considered constant 	 (in fact it is related specifically to operand 1) 	 during alias analysis.  */
return|return
operator|(
operator|!
name|for_alias
operator|&&
name|rtx_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|for_alias
argument_list|)
operator|)
operator|||
name|rtx_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|for_alias
argument_list|)
return|;
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* FALLTHROUGH */
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|rtx_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|for_alias
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|rtx_varies_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|for_alias
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 0 if the use of X as an address in a MEM can cause a trap.  */
end_comment

begin_function
name|int
name|rtx_addr_can_trap_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
return|return
name|SYMBOL_REF_WEAK
argument_list|(
name|x
argument_list|)
return|;
case|case
name|LABEL_REF
case|:
return|return
literal|0
return|;
case|case
name|REG
case|:
comment|/* As in rtx_varies_p, we have to use the actual rtx, not reg number.  */
if|if
condition|(
name|x
operator|==
name|frame_pointer_rtx
operator|||
name|x
operator|==
name|hard_frame_pointer_rtx
operator|||
name|x
operator|==
name|stack_pointer_rtx
comment|/* The arg pointer varies if it is not a fixed register.  */
operator|||
operator|(
name|x
operator|==
name|arg_pointer_rtx
operator|&&
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
operator|)
condition|)
return|return
literal|0
return|;
comment|/* All of the virtual frame registers are stack references.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_VIRTUAL_REGISTER
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|CONST
case|:
return|return
name|rtx_addr_can_trap_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|PLUS
case|:
comment|/* An address is assumed not to trap if it is an address that can't 	 trap plus a constant integer or it is the pic register plus a 	 constant.  */
return|return
operator|!
operator|(
operator|(
operator|!
name|rtx_addr_can_trap_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|||
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|pic_offset_table_rtx
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
return|;
case|case
name|LO_SUM
case|:
case|case
name|PRE_MODIFY
case|:
return|return
name|rtx_addr_can_trap_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|PRE_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|POST_MODIFY
case|:
return|return
name|rtx_addr_can_trap_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
comment|/* If it isn't one of the case above, it can cause a trap.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X refers to a memory location whose address     cannot be compared reliably with constant addresses,    or if X refers to a BLKmode memory object.     FOR_ALIAS is nonzero if we are called from alias analysis; if it is    zero, we are slightly more conservative.  */
end_comment

begin_function
name|int
name|rtx_addr_varies_p
parameter_list|(
name|x
parameter_list|,
name|for_alias
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|for_alias
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
return|return
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
operator|||
name|rtx_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|for_alias
argument_list|)
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|rtx_addr_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|for_alias
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|rtx_addr_varies_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|for_alias
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the value of the integer term in X, if one is apparent;    otherwise return 0.    Only obvious integer terms are detected.    This is used in cse.c with the `related_value' field.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|get_integer_term
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If X is a constant, return the value sans apparent integer term;    otherwise return 0.    Only obvious integer terms are detected.  */
end_comment

begin_function
name|rtx
name|get_related_value
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a tablejump insn INSN, return the RTL expression for the offset    into the jump table.  If the offset cannot be determined, then return    NULL_RTX.     If EARLIEST is non-zero, it is a pointer to a place where the earliest    insn used in locating the offset was found.  */
end_comment

begin_function
name|rtx
name|get_jump_table_offset
parameter_list|(
name|insn
parameter_list|,
name|earliest
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|earliest
decl_stmt|;
block|{
name|rtx
name|label
decl_stmt|;
name|rtx
name|table
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|rtx
name|old_insn
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
name|old_x
decl_stmt|;
name|rtx
name|y
decl_stmt|;
name|rtx
name|old_y
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|!
operator|(
name|label
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|table
operator|=
name|NEXT_INSN
argument_list|(
name|label
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|table
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|table
argument_list|)
argument_list|)
operator|!=
name|ADDR_VEC
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|table
argument_list|)
argument_list|)
operator|!=
name|ADDR_DIFF_VEC
operator|)
operator|||
operator|!
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
return|return
name|NULL_RTX
return|;
name|x
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
comment|/* Some targets (eg, ARM) emit a tablejump that also      contains the out-of-range target.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Search backwards and locate the expression stored in X.  */
for|for
control|(
name|old_x
operator|=
name|NULL_RTX
init|;
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|x
operator|!=
name|old_x
condition|;
name|old_x
operator|=
name|x
operator|,
name|x
operator|=
name|find_last_value
argument_list|(
name|x
argument_list|,
operator|&
name|insn
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
comment|/* If X is an expression using a relative address then strip      off the addition / subtraction of PC, PIC_OFFSET_TABLE_REGNUM,      or the jump table label.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|table
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|old_insn
operator|=
name|insn
expr_stmt|;
name|y
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
name|pc_rtx
operator|||
name|y
operator|==
name|pic_offset_table_rtx
condition|)
break|break;
for|for
control|(
name|old_y
operator|=
name|NULL_RTX
init|;
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|REG
operator|&&
name|y
operator|!=
name|old_y
condition|;
name|old_y
operator|=
name|y
operator|,
name|y
operator|=
name|find_last_value
argument_list|(
name|y
argument_list|,
operator|&
name|old_insn
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
operator|==
name|label
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
literal|2
condition|)
return|return
name|NULL_RTX
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
operator|-
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|old_x
operator|=
name|NULL_RTX
init|;
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|x
operator|!=
name|old_x
condition|;
name|old_x
operator|=
name|x
operator|,
name|x
operator|=
name|find_last_value
argument_list|(
name|x
argument_list|,
operator|&
name|insn
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
block|}
comment|/* Strip off any sign or zero extension.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTEND
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|old_x
operator|=
name|NULL_RTX
init|;
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|x
operator|!=
name|old_x
condition|;
name|old_x
operator|=
name|x
operator|,
name|x
operator|=
name|find_last_value
argument_list|(
name|x
argument_list|,
operator|&
name|insn
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
block|}
comment|/* If X isn't a MEM then this isn't a tablejump we understand.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Strip off the MEM.  */
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|old_x
operator|=
name|NULL_RTX
init|;
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|x
operator|!=
name|old_x
condition|;
name|old_x
operator|=
name|x
operator|,
name|x
operator|=
name|find_last_value
argument_list|(
name|x
argument_list|,
operator|&
name|insn
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
comment|/* If X isn't a PLUS than this isn't a tablejump we understand.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
name|NULL_RTX
return|;
comment|/* At this point we should have an expression representing the jump table      plus an offset.  Examine each operand in order to determine which one      represents the jump table.  Knowing that tells us that the other operand      must represent the offset.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|old_insn
operator|=
name|insn
expr_stmt|;
name|y
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|old_y
operator|=
name|NULL_RTX
init|;
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|REG
operator|&&
name|y
operator|!=
name|old_y
condition|;
name|old_y
operator|=
name|y
operator|,
name|y
operator|=
name|find_last_value
argument_list|(
name|y
argument_list|,
operator|&
name|old_insn
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|label
argument_list|,
name|y
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
literal|2
condition|)
return|return
name|NULL_RTX
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
operator|-
name|i
argument_list|)
expr_stmt|;
comment|/* Strip off the addition / subtraction of PIC_OFFSET_TABLE_REGNUM.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|==
name|pic_offset_table_rtx
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
operator|-
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|earliest
condition|)
operator|*
name|earliest
operator|=
name|insn
expr_stmt|;
comment|/* Return the RTL expression representing the offset.  */
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the number of places FIND appears within X.  If COUNT_DEST is    zero, we do not count occurrences inside the destination of a SET.  */
end_comment

begin_function
name|int
name|count_occurrences
parameter_list|(
name|x
parameter_list|,
name|find
parameter_list|,
name|count_dest
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|find
decl_stmt|;
name|int
name|count_dest
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|find
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
literal|0
return|;
case|case
name|MEM
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|find
argument_list|)
operator|==
name|MEM
operator|&&
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|find
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|SET
case|:
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|find
operator|&&
operator|!
name|count_dest
condition|)
return|return
name|count_occurrences
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|find
argument_list|,
name|count_dest
argument_list|)
return|;
break|break;
default|default:
break|break;
block|}
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|count
operator|+=
name|count_occurrences
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|find
argument_list|,
name|count_dest
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|count
operator|+=
name|count_occurrences
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|find
argument_list|,
name|count_dest
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|count
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if register REG appears somewhere within IN.    Also works if REG is not a register; in this case it checks    for a subexpression of IN that is Lisp "equal" to REG.  */
end_comment

begin_function
name|int
name|reg_mentioned_p
parameter_list|(
name|reg
parameter_list|,
name|in
parameter_list|)
name|rtx
name|reg
decl_stmt|,
name|in
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|in
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|reg
operator|==
name|in
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
name|reg
operator|==
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|in
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Compare registers by number.  */
case|case
name|REG
case|:
return|return
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|in
argument_list|)
operator|==
name|REGNO
argument_list|(
name|reg
argument_list|)
return|;
comment|/* These codes have no constituent expressions 	 and are unique.  */
case|case
name|SCRATCH
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
return|return
literal|0
return|;
case|case
name|CONST_INT
case|:
return|return
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|in
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|reg
argument_list|)
return|;
case|case
name|CONST_DOUBLE
case|:
comment|/* These are kept unique for a given value.  */
return|return
literal|0
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|code
operator|&&
name|rtx_equal_p
argument_list|(
name|reg
argument_list|,
name|in
argument_list|)
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|in
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|XVECEXP
argument_list|(
name|in
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|XEXP
argument_list|(
name|in
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if in between BEG and END, exclusive of BEG and END, there is    no CODE_LABEL insn.  */
end_comment

begin_function
name|int
name|no_labels_between_p
parameter_list|(
name|beg
parameter_list|,
name|end
parameter_list|)
name|rtx
name|beg
decl_stmt|,
name|end
decl_stmt|;
block|{
name|rtx
name|p
decl_stmt|;
if|if
condition|(
name|beg
operator|==
name|end
condition|)
return|return
literal|0
return|;
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|beg
argument_list|)
init|;
name|p
operator|!=
name|end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if in between BEG and END, exclusive of BEG and END, there is    no JUMP_INSN insn.  */
end_comment

begin_function
name|int
name|no_jumps_between_p
parameter_list|(
name|beg
parameter_list|,
name|end
parameter_list|)
name|rtx
name|beg
decl_stmt|,
name|end
decl_stmt|;
block|{
name|rtx
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|beg
argument_list|)
init|;
name|p
operator|!=
name|end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if register REG is used in an insn between    FROM_INSN and TO_INSN (exclusive of those two).  */
end_comment

begin_function
name|int
name|reg_used_between_p
parameter_list|(
name|reg
parameter_list|,
name|from_insn
parameter_list|,
name|to_insn
parameter_list|)
name|rtx
name|reg
decl_stmt|,
name|from_insn
decl_stmt|,
name|to_insn
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|from_insn
operator|==
name|to_insn
condition|)
return|return
literal|0
return|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|from_insn
argument_list|)
init|;
name|insn
operator|!=
name|to_insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
operator|(
name|find_reg_fusage
argument_list|(
name|insn
argument_list|,
name|USE
argument_list|,
name|reg
argument_list|)
operator|||
name|find_reg_fusage
argument_list|(
name|insn
argument_list|,
name|CLOBBER
argument_list|,
name|reg
argument_list|)
operator|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if the old value of X, a register, is referenced in BODY.  If X    is entirely replaced by a new value and the only use is as a SET_DEST,    we do not consider it a reference.  */
end_comment

begin_function
name|int
name|reg_referenced_p
parameter_list|(
name|x
parameter_list|,
name|body
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|body
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
condition|)
block|{
case|case
name|SET
case|:
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If the destination is anything other than CC0, PC, a REG or a SUBREG 	 of a REG that occupies all of the REG, the insn references X if 	 it is mentioned in the destination.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|!=
name|CC0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|!=
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|==
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
operator|)
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|ASM_OPERANDS
case|:
for|for
control|(
name|i
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|body
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|ASM_OPERANDS_INPUT
argument_list|(
name|body
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|CALL
case|:
case|case
name|USE
case|:
case|case
name|IF_THEN_ELSE
case|:
return|return
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|body
argument_list|)
return|;
case|case
name|TRAP_IF
case|:
return|return
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|TRAP_CONDITION
argument_list|(
name|body
argument_list|)
argument_list|)
return|;
case|case
name|PREFETCH
case|:
return|return
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|UNSPEC
case|:
case|case
name|UNSPEC_VOLATILE
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|PARALLEL
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|reg_referenced_p
argument_list|(
name|x
argument_list|,
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|CLOBBER
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|COND_EXEC
case|:
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|COND_EXEC_TEST
argument_list|(
name|body
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|reg_referenced_p
argument_list|(
name|x
argument_list|,
name|COND_EXEC_CODE
argument_list|(
name|body
argument_list|)
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Nonzero if register REG is referenced in an insn between    FROM_INSN and TO_INSN (exclusive of those two).  Sets of REG do    not count.  */
end_comment

begin_function
name|int
name|reg_referenced_between_p
parameter_list|(
name|reg
parameter_list|,
name|from_insn
parameter_list|,
name|to_insn
parameter_list|)
name|rtx
name|reg
decl_stmt|,
name|from_insn
decl_stmt|,
name|to_insn
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|from_insn
operator|==
name|to_insn
condition|)
return|return
literal|0
return|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|from_insn
argument_list|)
init|;
name|insn
operator|!=
name|to_insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|reg_referenced_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|find_reg_fusage
argument_list|(
name|insn
argument_list|,
name|USE
argument_list|,
name|reg
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if register REG is set or clobbered in an insn between    FROM_INSN and TO_INSN (exclusive of those two).  */
end_comment

begin_function
name|int
name|reg_set_between_p
parameter_list|(
name|reg
parameter_list|,
name|from_insn
parameter_list|,
name|to_insn
parameter_list|)
name|rtx
name|reg
decl_stmt|,
name|from_insn
decl_stmt|,
name|to_insn
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|from_insn
operator|==
name|to_insn
condition|)
return|return
literal|0
return|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|from_insn
argument_list|)
init|;
name|insn
operator|!=
name|to_insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|reg_set_p
argument_list|(
name|reg
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Internals of reg_set_between_p.  */
end_comment

begin_function
name|int
name|reg_set_p
parameter_list|(
name|reg
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|reg
decl_stmt|,
name|insn
decl_stmt|;
block|{
name|rtx
name|body
init|=
name|insn
decl_stmt|;
comment|/* We can be passed an insn or part of one.  If we are passed an insn,      check if a side-effect of the insn clobbers REG.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|FIND_REG_INC_NOTE
argument_list|(
name|insn
argument_list|,
name|reg
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
comment|/* We'd like to test call_used_regs here, but rtlanal.c can't 		 reference that variable due to its use in genattrtab.  So 		 we'll just be more conservative.  		 ??? Unless we could ensure that the CALL_INSN_FUNCTION_USAGE 		 information holds all clobbered registers.  */
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|MEM
operator|||
name|find_reg_fusage
argument_list|(
name|insn
argument_list|,
name|CLOBBER
argument_list|,
name|reg
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
return|return
name|set_of
argument_list|(
name|reg
argument_list|,
name|insn
argument_list|)
operator|!=
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Similar to reg_set_between_p, but check all registers in X.  Return 0    only if none of them are modified between START and END.  Do not    consider non-registers one way or the other.  */
end_comment

begin_function
name|int
name|regs_set_between_p
parameter_list|(
name|x
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
literal|0
return|;
case|case
name|REG
case|:
return|return
name|reg_set_between_p
argument_list|(
name|x
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
return|;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|regs_set_between_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|regs_set_between_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Similar to reg_set_between_p, but check all registers in X.  Return 0    only if none of them are modified between START and END.  Return 1 if    X contains a MEM; this routine does not perform any memory aliasing.  */
end_comment

begin_function
name|int
name|modified_between_p
parameter_list|(
name|x
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|0
return|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
comment|/* If the memory is not constant, assume it is modified.  If it is 	 constant, we still have to check the address.  */
if|if
condition|(
operator|!
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|REG
case|:
return|return
name|reg_set_between_p
argument_list|(
name|x
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
return|;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|modified_between_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|modified_between_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Similar to reg_set_p, but check all registers in X.  Return 0 only if none    of them are modified in INSN.  Return 1 if X contains a MEM; this routine    does not perform any memory aliasing.  */
end_comment

begin_function
name|int
name|modified_in_p
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|0
return|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
comment|/* If the memory is not constant, assume it is modified.  If it is 	 constant, we still have to check the address.  */
if|if
condition|(
operator|!
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|REG
case|:
return|return
name|reg_set_p
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
return|;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|modified_in_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|modified_in_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if anything in insn X is (anti,output,true) dependent on    anything in insn Y.  */
end_comment

begin_function
name|int
name|insn_dependent_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|rtx
name|tmp
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|x
argument_list|)
operator|||
operator|!
name|INSN_P
argument_list|(
name|y
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|PATTERN
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn_dependent_p_1
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL_RTX
condition|)
return|return
literal|1
return|;
name|tmp
operator|=
name|PATTERN
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|y
argument_list|)
argument_list|,
name|insn_dependent_p_1
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL_RTX
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A helper routine for insn_dependent_p called through note_stores.  */
end_comment

begin_function
specifier|static
name|void
name|insn_dependent_p_1
parameter_list|(
name|x
parameter_list|,
name|pat
parameter_list|,
name|data
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|pat
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|rtx
modifier|*
name|pinsn
init|=
operator|(
name|rtx
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|*
name|pinsn
operator|&&
name|reg_mentioned_p
argument_list|(
name|x
argument_list|,
operator|*
name|pinsn
argument_list|)
condition|)
operator|*
name|pinsn
operator|=
name|NULL_RTX
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper function for set_of.  */
end_comment

begin_struct
struct|struct
name|set_of_data
block|{
name|rtx
name|found
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|set_of_1
parameter_list|(
name|x
parameter_list|,
name|pat
parameter_list|,
name|data1
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|void
modifier|*
name|data1
decl_stmt|;
block|{
name|struct
name|set_of_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|set_of_data
operator|*
operator|)
operator|(
name|data1
operator|)
decl_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|data
operator|->
name|pat
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|data
operator|->
name|pat
argument_list|,
name|x
argument_list|)
operator|)
condition|)
name|data
operator|->
name|found
operator|=
name|pat
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Give an INSN, return a SET or CLOBBER expression that does modify PAT    (either directly or via STRICT_LOW_PART and similar modifiers).  */
end_comment

begin_function
name|rtx
name|set_of
parameter_list|(
name|pat
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|pat
decl_stmt|,
name|insn
decl_stmt|;
block|{
name|struct
name|set_of_data
name|data
decl_stmt|;
name|data
operator|.
name|found
operator|=
name|NULL_RTX
expr_stmt|;
name|data
operator|.
name|pat
operator|=
name|pat
expr_stmt|;
name|note_stores
argument_list|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|?
name|PATTERN
argument_list|(
name|insn
argument_list|)
else|:
name|insn
argument_list|,
name|set_of_1
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
return|return
name|data
operator|.
name|found
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an INSN, return a SET expression if this insn has only a single SET.    It may also have CLOBBERs, USEs, or SET whose output    will not be used, which we ignore.  */
end_comment

begin_function
name|rtx
name|single_set_2
parameter_list|(
name|insn
parameter_list|,
name|pat
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|pat
decl_stmt|;
block|{
name|rtx
name|set
init|=
name|NULL
decl_stmt|;
name|int
name|set_verified
init|=
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|sub
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|sub
argument_list|)
condition|)
block|{
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
break|break;
case|case
name|SET
case|:
comment|/* We can consider insns having multiple sets, where all 		 but one are dead as single set insns.  In common case 		 only single set is present in the pattern so we want 		 to avoid checking for REG_UNUSED notes unless necessary.  		 When we reach set first time, we just expect this is 		 the single set we are looking for and only when more 		 sets are found in the insn, we check them.  */
if|if
condition|(
operator|!
name|set_verified
condition|)
block|{
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|set
argument_list|)
condition|)
name|set
operator|=
name|NULL
expr_stmt|;
else|else
name|set_verified
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|set
condition|)
name|set
operator|=
name|sub
operator|,
name|set_verified
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|SET_DEST
argument_list|(
name|sub
argument_list|)
argument_list|)
operator|||
name|side_effects_p
argument_list|(
name|sub
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
break|break;
default|default:
return|return
name|NULL_RTX
return|;
block|}
block|}
block|}
return|return
name|set
return|;
block|}
end_function

begin_comment
comment|/* Given an INSN, return nonzero if it has more than one SET, else return    zero.  */
end_comment

begin_function
name|int
name|multiple_sets
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|found
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* INSN must be an insn.  */
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Only a PARALLEL can have multiple SETs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|found
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
comment|/* If we have already found a SET, then return now.  */
if|if
condition|(
name|found
condition|)
return|return
literal|1
return|;
else|else
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Either zero or one SET.  */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if the destination of SET equals the source    and there are no side effects.  */
end_comment

begin_function
name|int
name|set_noop_p
parameter_list|(
name|set
parameter_list|)
name|rtx
name|set
decl_stmt|;
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|dst
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
if|if
condition|(
name|side_effects_p
argument_list|(
name|src
argument_list|)
operator|||
name|side_effects_p
argument_list|(
name|dst
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|rtx_equal_p
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
return|;
if|if
condition|(
name|dst
operator|==
name|pc_rtx
operator|&&
name|src
operator|==
name|pc_rtx
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
return|return
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|src
argument_list|)
operator|&&
operator|!
name|BYTES_BIG_ENDIAN
operator|&&
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|2
argument_list|)
operator|==
name|const0_rtx
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dst
operator|=
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|SUBREG_BYTE
argument_list|(
name|src
argument_list|)
operator|!=
name|SUBREG_BYTE
argument_list|(
name|dst
argument_list|)
condition|)
return|return
literal|0
return|;
name|src
operator|=
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|dst
operator|=
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|==
name|REGNO
argument_list|(
name|dst
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if an insn consists only of SETs, each of which only sets a    value to itself.  */
end_comment

begin_function
name|int
name|noop_move_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOOP_MOVE_INSN_CODE
condition|)
return|return
literal|1
return|;
comment|/* Insns carrying these notes are useful later on.  */
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* For now treat an insn with a REG_RETVAL note as a      a special insn which should not be considered a no-op.  */
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|set_noop_p
argument_list|(
name|pat
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* If nothing but SETs of registers to themselves, 	 this insn can also be deleted.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|tem
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CLOBBER
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|SET
operator|||
operator|!
name|set_noop_p
argument_list|(
name|tem
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the last thing that X was assigned from before *PINSN.  If VALID_TO    is not NULL_RTX then verify that the object is not modified up to VALID_TO.    If the object was modified, if we hit a partial assignment to X, or hit a    CODE_LABEL first, return X.  If we found an assignment, update *PINSN to    point to it.  ALLOW_HWREG is set to 1 if hardware registers are allowed to    be the src.  */
end_comment

begin_function
name|rtx
name|find_last_value
parameter_list|(
name|x
parameter_list|,
name|pinsn
parameter_list|,
name|valid_to
parameter_list|,
name|allow_hwreg
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
modifier|*
name|pinsn
decl_stmt|;
name|rtx
name|valid_to
decl_stmt|;
name|int
name|allow_hwreg
decl_stmt|;
block|{
name|rtx
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|PREV_INSN
argument_list|(
operator|*
name|pinsn
argument_list|)
init|;
name|p
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|CODE_LABEL
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|EXPR_LIST
condition|)
name|src
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|valid_to
operator|==
name|NULL_RTX
operator|||
operator|!
name|modified_between_p
argument_list|(
name|src
argument_list|,
name|PREV_INSN
argument_list|(
name|p
argument_list|)
argument_list|,
name|valid_to
argument_list|)
operator|)
comment|/* Reject hard registers because we don't usually want 		   to use them; we'd rather use a pseudo.  */
operator|&&
operator|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
name|allow_hwreg
operator|)
condition|)
block|{
operator|*
name|pinsn
operator|=
name|p
expr_stmt|;
return|return
name|src
return|;
block|}
block|}
comment|/* If set in non-simple way, we don't have a value.  */
if|if
condition|(
name|reg_set_p
argument_list|(
name|x
argument_list|,
name|p
argument_list|)
condition|)
break|break;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if register in range [REGNO, ENDREGNO)    appears either explicitly or implicitly in X    other than being stored into.     References contained within the substructure at LOC do not count.    LOC may be zero, meaning don't ignore anything.  */
end_comment

begin_function
name|int
name|refers_to_regno_p
parameter_list|(
name|regno
parameter_list|,
name|endregno
parameter_list|,
name|x
parameter_list|,
name|loc
parameter_list|)
name|unsigned
name|int
name|regno
decl_stmt|,
name|endregno
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|x_regno
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|repeat
label|:
comment|/* The contents of a REG_NONNEG note is always zero, so we must come here      upon repeat in case the last REG_NOTE is a REG_NONNEG note.  */
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
name|x_regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If we modifying the stack, frame, or argument pointer, it will 	 clobber a virtual register.  In fact, we could be more precise, 	 but it isn't worth it.  */
if|if
condition|(
operator|(
name|x_regno
operator|==
name|STACK_POINTER_REGNUM
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|||
name|x_regno
operator|==
name|ARG_POINTER_REGNUM
endif|#
directive|endif
operator|||
name|x_regno
operator|==
name|FRAME_POINTER_REGNUM
operator|)
operator|&&
name|regno
operator|>=
name|FIRST_VIRTUAL_REGISTER
operator|&&
name|regno
operator|<=
name|LAST_VIRTUAL_REGISTER
condition|)
return|return
literal|1
return|;
return|return
operator|(
name|endregno
operator|>
name|x_regno
operator|&&
name|regno
operator|<
name|x_regno
operator|+
operator|(
name|x_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|HARD_REGNO_NREGS
argument_list|(
name|x_regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
literal|1
operator|)
operator|)
return|;
case|case
name|SUBREG
case|:
comment|/* If this is a SUBREG of a hard reg, we can see exactly which 	 registers are being modified.  Otherwise, handle normally.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|unsigned
name|int
name|inner_regno
init|=
name|subreg_regno
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|inner_endregno
init|=
name|inner_regno
operator|+
operator|(
name|inner_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
literal|1
operator|)
decl_stmt|;
return|return
name|endregno
operator|>
name|inner_regno
operator|&&
name|regno
operator|<
name|inner_endregno
return|;
block|}
break|break;
case|case
name|CLOBBER
case|:
case|case
name|SET
case|:
if|if
condition|(
operator|&
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|!=
name|loc
comment|/* Note setting a SUBREG counts as referring to the REG it is in for 	     a pseudo but not for hard registers since we can 	     treat each word individually.  */
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|loc
operator|!=
operator|&
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|loc
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|loc
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|code
operator|==
name|CLOBBER
operator|||
name|loc
operator|==
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
default|default:
break|break;
block|}
comment|/* X does not match, so try its subexpressions.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|loc
operator|!=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
elseif|else
if|if
condition|(
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|loc
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|loc
operator|!=
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|&&
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|loc
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if modifying X will affect IN.  If X is a register or a SUBREG,    we check if any register number in X conflicts with the relevant register    numbers.  If X is a constant, return 0.  If X is a MEM, return 1 iff IN    contains a MEM (we don't bother checking for memory addresses that can't    conflict because we expect this to be a rare case.  */
end_comment

begin_function
name|int
name|reg_overlap_mentioned_p
parameter_list|(
name|x
parameter_list|,
name|in
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|in
decl_stmt|;
block|{
name|unsigned
name|int
name|regno
decl_stmt|,
name|endregno
decl_stmt|;
comment|/* Overly conservative.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If either argument is a constant, then modifying X can not affect IN.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|||
name|CONSTANT_P
argument_list|(
name|in
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|SUBREG
case|:
name|regno
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|regno
operator|=
name|subreg_regno
argument_list|(
name|x
argument_list|)
expr_stmt|;
goto|goto
name|do_reg
goto|;
case|case
name|REG
case|:
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|do_reg
label|:
name|endregno
operator|=
name|regno
operator|+
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
literal|1
operator|)
expr_stmt|;
return|return
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|in
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|)
return|;
case|case
name|MEM
case|:
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|XEXP
argument_list|(
name|in
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
case|case
name|SCRATCH
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
name|reg_mentioned_p
argument_list|(
name|x
argument_list|,
name|in
argument_list|)
return|;
case|case
name|PARALLEL
case|:
block|{
name|int
name|i
decl_stmt|;
comment|/* If any register in here refers to it we return true.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|in
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
default|default:
break|break;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the last value to which REG was set prior to INSN.  If we can't    find it easily, return 0.     We only return a REG, SUBREG, or constant because it is too hard to    check if a MEM remains unchanged.  */
end_comment

begin_function
name|rtx
name|reg_set_last
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|orig_insn
init|=
name|insn
decl_stmt|;
comment|/* Scan backwards until reg_set_last_1 changed one of the above flags.      Stop when we reach a label or X is a hard reg and we reach a      CALL_INSN (if reg_set_last_last_regno is a hard reg).       If we find a set of X, ensure that its SET_SRC remains unchanged.  */
comment|/* We compare with<= here, because reg_set_last_last_regno      is actually the number of the first reg *not* in X.  */
for|for
control|(
init|;
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|set
init|=
name|set_of
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
decl_stmt|;
comment|/* OK, this function modify our register.  See if we understand it.  */
if|if
condition|(
name|set
condition|)
block|{
name|rtx
name|last_value
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|!=
name|SET
operator|||
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|!=
name|x
condition|)
return|return
literal|0
return|;
name|last_value
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|last_value
argument_list|)
operator|||
operator|(
operator|(
name|GET_CODE
argument_list|(
name|last_value
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|last_value
argument_list|)
operator|==
name|SUBREG
operator|)
operator|&&
operator|!
name|reg_set_between_p
argument_list|(
name|last_value
argument_list|,
name|insn
argument_list|,
name|orig_insn
argument_list|)
operator|)
condition|)
return|return
name|last_value
return|;
else|else
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call FUN on each register or MEM that is stored into or clobbered by X.    (X would be the pattern of an insn).    FUN receives two arguments:      the REG, MEM, CC0 or PC being stored in or clobbered,      the SET or CLOBBER rtx that does the store.    If the item being stored in or clobbered is a SUBREG of a hard register,   the SUBREG will be passed.  */
end_comment

begin_function_decl
name|void
name|note_stores
parameter_list|(
name|x
parameter_list|,
name|fun
parameter_list|,
name|data
parameter_list|)
name|rtx
name|x
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*fun
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|x
operator|=
name|COND_EXEC_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we have a PARALLEL, SET_DEST is a list of EXPR_LIST expressions, 	 each of whose first operand is a register.  We can't know what 	 precisely is being set in these cases, so make up a CLOBBER to pass 	 to the function.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
call|(
modifier|*
name|fun
call|)
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
call|(
modifier|*
name|fun
call|)
argument_list|(
name|dest
argument_list|,
name|x
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|note_stores
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|fun
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Like notes_stores, but call FUN for each expression that is being    referenced in PBODY, a pointer to the PATTERN of an insn.  We only call    FUN for each expression, not any interior subexpressions.  FUN receives a    pointer to the expression and the DATA passed to this function.     Note that this is not quite the same test as that done in reg_referenced_p    since that considers something as being referenced if it is being    partially set, while we do not.  */
end_comment

begin_function_decl
name|void
name|note_uses
parameter_list|(
name|pbody
parameter_list|,
name|fun
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|pbody
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*fun
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rtx
name|body
init|=
operator|*
name|pbody
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
condition|)
block|{
case|case
name|COND_EXEC
case|:
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|COND_EXEC_TEST
argument_list|(
name|body
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|note_uses
argument_list|(
operator|&
name|COND_EXEC_CODE
argument_list|(
name|body
argument_list|)
argument_list|,
name|fun
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
case|case
name|PARALLEL
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|note_uses
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|fun
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
case|case
name|USE
case|:
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
case|case
name|ASM_OPERANDS
case|:
for|for
control|(
name|i
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|body
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|ASM_OPERANDS_INPUT
argument_list|(
name|body
argument_list|,
name|i
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
case|case
name|TRAP_IF
case|:
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|TRAP_CONDITION
argument_list|(
name|body
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
case|case
name|PREFETCH
case|:
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNSPEC
case|:
case|case
name|UNSPEC_VOLATILE
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
case|case
name|CLOBBER
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
case|case
name|SET
case|:
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
decl_stmt|;
comment|/* For sets we replace everything in source plus registers in memory 	   expression in store and operands of a ZERO_EXTRACT.  */
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
block|{
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|1
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|2
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
comment|/* All the other possibilities never store.  */
call|(
modifier|*
name|fun
call|)
argument_list|(
name|pbody
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if X's old contents don't survive after INSN.    This will be true if X is (cc0) or if X is a register and    X dies in INSN or because INSN entirely sets X.     "Entirely set" means set directly and not through a SUBREG,    ZERO_EXTRACT or SIGN_EXTRACT, so no trace of the old contents remains.    Likewise, REG_INC does not count.     REG may be a hard or pseudo reg.  Renumbering is not taken into account,    but for this use that makes no difference, since regs don't overlap    during their lifetimes.  Therefore, this function may be used    at any time after deaths have been computed (in flow.c).     If REG is a hard reg that occupies multiple machine registers, this    function will only return 1 if each of those registers will be replaced    by INSN.  */
end_comment

begin_function
name|int
name|dead_or_set_p
parameter_list|(
name|insn
parameter_list|,
name|x
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|unsigned
name|int
name|regno
decl_stmt|,
name|last_regno
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Can't use cc0_rtx below since this file is used by genattrtab.c.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CC0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|last_regno
operator|=
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
name|regno
else|:
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<=
name|last_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|dead_or_set_regno_p
argument_list|(
name|insn
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Utility function for dead_or_set_p to check an individual register.  Also    called from flow.c.  */
end_comment

begin_function
name|int
name|dead_or_set_regno_p
parameter_list|(
name|insn
parameter_list|,
name|test_regno
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|unsigned
name|int
name|test_regno
decl_stmt|;
block|{
name|unsigned
name|int
name|regno
decl_stmt|,
name|endregno
decl_stmt|;
name|rtx
name|pattern
decl_stmt|;
comment|/* See if there is a death note for something that includes TEST_REGNO.  */
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|test_regno
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|find_regno_fusage
argument_list|(
name|insn
argument_list|,
name|CLOBBER
argument_list|,
name|test_regno
argument_list|)
condition|)
return|return
literal|1
return|;
name|pattern
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|pattern
operator|=
name|COND_EXEC_CODE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
comment|/* A value is totally replaced if it is the destination or the 	 destination is a SUBREG of REGNO that does not change the number of 	 words in it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|==
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|endregno
operator|=
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
name|regno
operator|+
literal|1
else|:
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|test_regno
operator|>=
name|regno
operator|&&
name|test_regno
operator|<
name|endregno
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|body
init|=
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|body
operator|=
name|COND_EXEC_CODE
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|==
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
condition|)
continue|continue;
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|endregno
operator|=
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
name|regno
operator|+
literal|1
else|:
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|test_regno
operator|>=
name|regno
operator|&&
name|test_regno
operator|<
name|endregno
condition|)
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the reg-note of kind KIND in insn INSN, if there is one.    If DATUM is nonzero, look for one whose datum is DATUM.  */
end_comment

begin_function
name|rtx
name|find_reg_note
parameter_list|(
name|insn
parameter_list|,
name|kind
parameter_list|,
name|datum
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|enum
name|reg_note
name|kind
decl_stmt|;
name|rtx
name|datum
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|;
comment|/* Ignore anything that is not an INSN, JUMP_INSN or CALL_INSN.  */
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|kind
operator|&&
operator|(
name|datum
operator|==
literal|0
operator|||
name|datum
operator|==
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|link
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the reg-note of kind KIND in insn INSN which applies to register    number REGNO, if any.  Return 0 if there is no such reg-note.  Note that    the REGNO of this NOTE need not be REGNO if REGNO is a hard register;    it might be the case that the note overlaps REGNO.  */
end_comment

begin_function
name|rtx
name|find_regno_note
parameter_list|(
name|insn
parameter_list|,
name|kind
parameter_list|,
name|regno
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|enum
name|reg_note
name|kind
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|;
comment|/* Ignore anything that is not an INSN, JUMP_INSN or CALL_INSN.  */
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|kind
comment|/* Verify that it is a register, so that scratch and MEM won't cause a 	   problem here.  */
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
name|regno
operator|&&
operator|(
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|+
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|>
name|regno
operator|)
condition|)
return|return
name|link
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return a REG_EQUIV or REG_EQUAL note if insn has only a single set and    has such a note.  */
end_comment

begin_function
name|rtx
name|find_reg_equal_equiv_note
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|single_set
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|note
return|;
else|else
return|return
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if DATUM, or any overlap of DATUM, of kind CODE is found    in the CALL_INSN_FUNCTION_USAGE information of INSN.  */
end_comment

begin_function
name|int
name|find_reg_fusage
parameter_list|(
name|insn
parameter_list|,
name|code
parameter_list|,
name|datum
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|datum
decl_stmt|;
block|{
comment|/* If it's not a CALL_INSN, it can't possibly have a      CALL_INSN_FUNCTION_USAGE field, so don't bother checking.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CALL_INSN
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|datum
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|datum
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|code
operator|&&
name|rtx_equal_p
argument_list|(
name|datum
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|datum
argument_list|)
decl_stmt|;
comment|/* CALL_INSN_FUNCTION_USAGE information cannot contain references 	 to pseudo registers, so don't bother checking.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|unsigned
name|int
name|end_regno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|datum
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|end_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|find_regno_fusage
argument_list|(
name|insn
argument_list|,
name|code
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if REGNO, or any overlap of REGNO, of kind CODE is found    in the CALL_INSN_FUNCTION_USAGE information of INSN.  */
end_comment

begin_function
name|int
name|find_regno_fusage
parameter_list|(
name|insn
parameter_list|,
name|code
parameter_list|,
name|regno
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|;
comment|/* CALL_INSN_FUNCTION_USAGE information cannot contain references      to pseudo registers, so don't bother checking.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CALL_INSN
condition|)
return|return
literal|0
return|;
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|unsigned
name|int
name|regnote
decl_stmt|;
name|rtx
name|op
decl_stmt|,
name|reg
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|code
operator|&&
name|GET_CODE
argument_list|(
name|reg
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|regnote
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|)
operator|<=
name|regno
operator|&&
name|regnote
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regnote
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|>
name|regno
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remove register note NOTE from the REG_NOTES of INSN.  */
end_comment

begin_function
name|void
name|remove_note
parameter_list|(
name|insn
parameter_list|,
name|note
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|note
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|;
if|if
condition|(
name|note
operator|==
name|NULL_RTX
condition|)
return|return;
if|if
condition|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|==
name|note
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|==
name|note
condition|)
block|{
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Search LISTP (an EXPR_LIST) for an entry whose first operand is NODE and    return 1 if it is found.  A simple equality test is used to determine if    NODE matches.  */
end_comment

begin_function
name|int
name|in_expr_list_p
parameter_list|(
name|listp
parameter_list|,
name|node
parameter_list|)
name|rtx
name|listp
decl_stmt|;
name|rtx
name|node
decl_stmt|;
block|{
name|rtx
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|listp
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|node
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Search LISTP (an EXPR_LIST) for an entry whose first operand is NODE and    remove that entry from the list if it is found.     A simple equality test is used to determine if NODE matches.  */
end_comment

begin_function
name|void
name|remove_node_from_expr_list
parameter_list|(
name|node
parameter_list|,
name|listp
parameter_list|)
name|rtx
name|node
decl_stmt|;
name|rtx
modifier|*
name|listp
decl_stmt|;
block|{
name|rtx
name|temp
init|=
operator|*
name|listp
decl_stmt|;
name|rtx
name|prev
init|=
name|NULL_RTX
decl_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|node
operator|==
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Splice the node out of the list.  */
if|if
condition|(
name|prev
condition|)
name|XEXP
argument_list|(
name|prev
argument_list|,
literal|1
argument_list|)
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
operator|*
name|listp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|prev
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if X contains any volatile instructions.  These are instructions    which may cause unpredictable machine state instructions, and thus no    instructions should be moved or combined across them.  This includes    only volatile asms and UNSPEC_VOLATILE instructions.  */
end_comment

begin_function
name|int
name|volatile_insn_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|RTX_CODE
name|code
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|REG
case|:
case|case
name|SCRATCH
case|:
case|case
name|CLOBBER
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
case|case
name|CALL
case|:
case|case
name|MEM
case|:
return|return
literal|0
return|;
case|case
name|UNSPEC_VOLATILE
case|:
comment|/* case TRAP_IF: This isn't clear yet.  */
return|return
literal|1
return|;
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
default|default:
break|break;
block|}
comment|/* Recursively scan the operands of this expression.  */
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|volatile_insn_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|volatile_insn_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if X contains any volatile memory references    UNSPEC_VOLATILE operations or volatile ASM_OPERANDS expressions.  */
end_comment

begin_function
name|int
name|volatile_refs_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|RTX_CODE
name|code
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|REG
case|:
case|case
name|SCRATCH
case|:
case|case
name|CLOBBER
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return
literal|0
return|;
case|case
name|CALL
case|:
case|case
name|UNSPEC_VOLATILE
case|:
comment|/* case TRAP_IF: This isn't clear yet.  */
return|return
literal|1
return|;
case|case
name|MEM
case|:
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
default|default:
break|break;
block|}
comment|/* Recursively scan the operands of this expression.  */
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|volatile_refs_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|volatile_refs_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Similar to above, except that it also rejects register pre- and post-    incrementing.  */
end_comment

begin_function
name|int
name|side_effects_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|RTX_CODE
name|code
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|REG
case|:
case|case
name|SCRATCH
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return
literal|0
return|;
case|case
name|CLOBBER
case|:
comment|/* Reject CLOBBER with a non-VOID mode.  These are made by combine.c 	 when some combination can't be done.  If we see one, don't think 	 that we can simplify the expression.  */
return|return
operator|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
operator|)
return|;
case|case
name|PRE_INC
case|:
case|case
name|PRE_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_MODIFY
case|:
case|case
name|POST_MODIFY
case|:
case|case
name|CALL
case|:
case|case
name|UNSPEC_VOLATILE
case|:
comment|/* case TRAP_IF: This isn't clear yet.  */
return|return
literal|1
return|;
case|case
name|MEM
case|:
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
default|default:
break|break;
block|}
comment|/* Recursively scan the operands of this expression.  */
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|side_effects_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|side_effects_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if evaluating rtx X might cause a trap.  */
end_comment

begin_function
name|int
name|may_trap_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Handle these cases quickly.  */
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|REG
case|:
case|case
name|SCRATCH
case|:
return|return
literal|0
return|;
case|case
name|ASM_INPUT
case|:
case|case
name|UNSPEC_VOLATILE
case|:
case|case
name|TRAP_IF
case|:
return|return
literal|1
return|;
case|case
name|ASM_OPERANDS
case|:
return|return
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
return|;
comment|/* Memory ref can trap unless it's a static var or a stack slot.  */
case|case
name|MEM
case|:
return|return
name|rtx_addr_can_trap_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Division by a non-constant might trap.  */
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
literal|1
return|;
comment|/* This was const0_rtx, but by not using that, 	 we can link this file into other programs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|EXPR_LIST
case|:
comment|/* An EXPR_LIST is used to represent a function call.  This 	 certainly may trap.  */
return|return
literal|1
return|;
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|COMPARE
case|:
comment|/* Some floating point comparisons may trap.  */
comment|/* ??? There is no machine independent way to check for tests that trap 	 when COMPARE is used, though many targets do make this distinction. 	 For instance, sparc uses CCFPE for compares which generate exceptions 	 and CCFP for compares which do not generate exceptions.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
literal|1
return|;
comment|/* But often the compare has some CC mode, so check operand 	 modes as well.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|NEG
case|:
case|case
name|ABS
case|:
comment|/* These operations don't trap even with floating point.  */
break|break;
default|default:
comment|/* Any floating arithmetic may trap.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
literal|1
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|may_trap_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|may_trap_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if X contains a comparison that is not either EQ or NE,    i.e., an inequality.  */
end_comment

begin_function
name|int
name|inequality_comparisons_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|SCRATCH
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
return|return
literal|0
return|;
case|case
name|LT
case|:
case|case
name|LTU
case|:
case|case
name|GT
case|:
case|case
name|GTU
case|:
case|case
name|LE
case|:
case|case
name|LEU
case|:
case|case
name|GE
case|:
case|case
name|GEU
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|inequality_comparisons_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|inequality_comparisons_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Replace any occurrence of FROM in X with TO.  The function does    not enter into CONST_DOUBLE for the replace.     Note that copying is not done so X must not be shared unless all copies    are to be modified.  */
end_comment

begin_function
name|rtx
name|replace_rtx
parameter_list|(
name|x
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* The following prevents loops occurrence when we change MEM in      CONST_DOUBLE onto the same CONST_DOUBLE.  */
if|if
condition|(
name|x
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
name|x
return|;
if|if
condition|(
name|x
operator|==
name|from
condition|)
return|return
name|to
return|;
comment|/* Allow this function to make replacements in EXPR_LISTs.  */
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|replace_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Throughout the rtx X, replace many registers according to REG_MAP.    Return the replacement for X (which may be X with altered contents).    REG_MAP[R] is the replacement for register R, or 0 for don't replace.    NREGS is the length of REG_MAP; regs>= NREGS are not mapped.       We only support REG_MAP entries of REG or SUBREG.  Also, hard registers    should not be mapped to pseudos or vice versa since validate_change    is not called.     If REPLACE_DEST is 1, replacements are also done in destinations;    otherwise, only sources are replaced.  */
end_comment

begin_function
name|rtx
name|replace_regs
parameter_list|(
name|x
parameter_list|,
name|reg_map
parameter_list|,
name|nregs
parameter_list|,
name|replace_dest
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
modifier|*
name|reg_map
decl_stmt|;
name|unsigned
name|int
name|nregs
decl_stmt|;
name|int
name|replace_dest
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|x
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SCRATCH
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
name|x
return|;
case|case
name|REG
case|:
comment|/* Verify that the register has an entry before trying to access it.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|nregs
operator|&&
name|reg_map
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* SUBREGs can't be shared.  Always return a copy to ensure that if 	     this replacement occurs more than once then each instance will 	     get distinct rtx.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg_map
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
return|return
name|copy_rtx
argument_list|(
name|reg_map
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
return|;
return|return
name|reg_map
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
return|;
block|}
return|return
name|x
return|;
case|case
name|SUBREG
case|:
comment|/* Prevent making nested SUBREGs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|nregs
operator|&&
name|reg_map
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reg_map
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|rtx
name|map_val
init|=
name|reg_map
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
decl_stmt|;
return|return
name|simplify_gen_subreg
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|map_val
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|SET
case|:
if|if
condition|(
name|replace_dest
condition|)
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|=
name|replace_regs
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|nregs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
comment|/* Even if we are not to replace destinations, replace register if it 	   is CONTAINED in destination (destination is memory or 	   STRICT_LOW_PART).  */
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|replace_regs
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|nregs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
comment|/* Similarly, for ZERO_EXTRACT we replace all operands.  */
break|break;
name|SET_SRC
argument_list|(
name|x
argument_list|)
operator|=
name|replace_regs
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|nregs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|x
return|;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|replace_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|nregs
argument_list|,
name|replace_dest
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|replace_regs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|nregs
argument_list|,
name|replace_dest
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of computed_jump_p, return 1 if X contains a REG or MEM or    constant that is not in the constant pool and not in the condition    of an IF_THEN_ELSE.  */
end_comment

begin_function
specifier|static
name|int
name|computed_jump_p_1
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|PC
case|:
return|return
literal|0
return|;
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|REG
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
return|return
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|IF_THEN_ELSE
case|:
return|return
operator|(
name|computed_jump_p_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|computed_jump_p_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|)
return|;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|computed_jump_p_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|computed_jump_p_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if INSN is an indirect jump (aka computed jump).     Tablejumps and casesi insns are not considered indirect jumps;    we can recognize them by a (use (label_ref)).  */
end_comment

begin_function
name|int
name|computed_jump_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LABEL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|has_use_labelref
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
condition|)
name|has_use_labelref
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|has_use_labelref
condition|)
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|computed_jump_p_1
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|computed_jump_p_1
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Traverse X via depth-first search, calling F for each    sub-expression (including X itself).  F is also passed the DATA.    If F returns -1, do not traverse sub-expressions, but continue    traversing the rest of the tree.  If F ever returns any other    non-zero value, stop the traversal, and return the value returned    by F.  Otherwise, return 0.  This function does not traverse inside    tree structure that contains RTX_EXPRs, or into sub-expressions    whose format code is `0' since it is not known whether or not those    codes are actually RTL.     This routine is very general, and could (should?) be used to    implement many of the other routines in this file.  */
end_comment

begin_function
name|int
name|for_each_rtx
parameter_list|(
name|x
parameter_list|,
name|f
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|x
decl_stmt|;
name|rtx_function
name|f
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|int
name|length
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Call F on X.  */
name|result
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
name|x
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
comment|/* Do not traverse sub-expressions.  */
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
comment|/* Stop the traversal.  */
return|return
name|result
return|;
if|if
condition|(
operator|*
name|x
operator|==
name|NULL_RTX
condition|)
comment|/* There are no sub-expressions.  */
return|return
literal|0
return|;
name|length
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|format
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|format
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
name|result
operator|=
name|for_each_rtx
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|f
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
return|return
name|result
return|;
break|break;
case|case
literal|'V'
case|:
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|)
condition|;
operator|++
name|j
control|)
block|{
name|result
operator|=
name|for_each_rtx
argument_list|(
operator|&
name|XVECEXP
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|f
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
return|return
name|result
return|;
block|}
block|}
break|break;
default|default:
comment|/* Nothing to do.  */
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Searches X for any reference to REGNO, returning the rtx of the    reference found if any.  Otherwise, returns NULL_RTX.  */
end_comment

begin_function
name|rtx
name|regno_use_in
parameter_list|(
name|regno
parameter_list|,
name|x
parameter_list|)
name|unsigned
name|int
name|regno
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|regno
condition|)
return|return
name|x
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
operator|(
name|tem
operator|=
name|regno_use_in
argument_list|(
name|regno
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|tem
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
operator|(
name|tem
operator|=
name|regno_use_in
argument_list|(
name|regno
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|tem
return|;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Return a value indicating whether OP, an operand of a commutative    operation, is preferred as the first or second operand.  The higher    the value, the stronger the preference for being the first operand.    We use negative values to indicate a preference for the first operand    and positive values for the second operand.  */
end_comment

begin_function
name|int
name|commutative_operand_precedence
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
comment|/* Constants always come the second operand.  Prefer "nice" constants.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|-
literal|5
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
operator|-
literal|4
return|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
operator|-
literal|3
return|;
comment|/* SUBREGs of objects should come second.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'o'
condition|)
return|return
operator|-
literal|2
return|;
comment|/* If only one operand is a `neg', `not',     `mult', `plus', or `minus' expression, it will be the first     operand.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NEG
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NOT
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MULT
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MINUS
condition|)
return|return
literal|2
return|;
comment|/* Complex expressions should be the first, so decrease priority      of objects.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
literal|'o'
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 iff it is necessary to swap operands of commutative operation    in order to canonicalize expression.  */
end_comment

begin_function
name|int
name|swap_commutative_operands_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
return|return
operator|(
name|commutative_operand_precedence
argument_list|(
name|x
argument_list|)
operator|<
name|commutative_operand_precedence
argument_list|(
name|y
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X is an autoincrement side effect and the register is    not the stack pointer.  */
end_comment

begin_function
name|int
name|auto_inc_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|PRE_INC
case|:
case|case
name|POST_INC
case|:
case|case
name|PRE_DEC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_MODIFY
case|:
case|case
name|POST_MODIFY
case|:
comment|/* There are no REG_INC notes for SP.  */
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
name|stack_pointer_rtx
condition|)
return|return
literal|1
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the sequence of instructions beginning with FROM and up    to and including TO is safe to move.  If NEW_TO is non-NULL, and    the sequence is not already safe to move, but can be easily    extended to a sequence which is safe, then NEW_TO will point to the    end of the extended sequence.        For now, this function only checks that the region contains whole    exception regions, but it could be extended to check additional    conditions as well.  */
end_comment

begin_function
name|int
name|insns_safe_to_move_p
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|new_to
parameter_list|)
name|rtx
name|from
decl_stmt|;
name|rtx
name|to
decl_stmt|;
name|rtx
modifier|*
name|new_to
decl_stmt|;
block|{
name|int
name|eh_region_count
init|=
literal|0
decl_stmt|;
name|int
name|past_to_p
init|=
literal|0
decl_stmt|;
name|rtx
name|r
init|=
name|from
decl_stmt|;
comment|/* By default, assume the end of the region will be what was      suggested.  */
if|if
condition|(
name|new_to
condition|)
operator|*
name|new_to
operator|=
name|to
expr_stmt|;
while|while
condition|(
name|r
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|NOTE
condition|)
block|{
switch|switch
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|r
argument_list|)
condition|)
block|{
case|case
name|NOTE_INSN_EH_REGION_BEG
case|:
operator|++
name|eh_region_count
expr_stmt|;
break|break;
case|case
name|NOTE_INSN_EH_REGION_END
case|:
if|if
condition|(
name|eh_region_count
operator|==
literal|0
condition|)
comment|/* This sequence of instructions contains the end of 		   an exception region, but not he beginning.  Moving 		   it will cause chaos.  */
return|return
literal|0
return|;
operator|--
name|eh_region_count
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|past_to_p
condition|)
comment|/* If we've passed TO, and we see a non-note instruction, we 	   can't extend the sequence to a movable sequence.  */
return|return
literal|0
return|;
if|if
condition|(
name|r
operator|==
name|to
condition|)
block|{
if|if
condition|(
operator|!
name|new_to
condition|)
comment|/* It's OK to move the sequence if there were matched sets of 	       exception region notes.  */
return|return
name|eh_region_count
operator|==
literal|0
return|;
name|past_to_p
operator|=
literal|1
expr_stmt|;
block|}
comment|/* It's OK to move the sequence if there were matched sets of 	 exception region notes.  */
if|if
condition|(
name|past_to_p
operator|&&
name|eh_region_count
operator|==
literal|0
condition|)
block|{
operator|*
name|new_to
operator|=
name|r
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Go to the next instruction.  */
name|r
operator|=
name|NEXT_INSN
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if IN contains a piece of rtl that has the address LOC */
end_comment

begin_function
name|int
name|loc_mentioned_in_p
parameter_list|(
name|loc
parameter_list|,
name|in
parameter_list|)
name|rtx
modifier|*
name|loc
decl_stmt|,
name|in
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|in
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|loc
operator|==
operator|&
name|in
operator|->
name|fld
index|[
name|i
index|]
operator|.
name|rtx
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|loc_mentioned_in_p
argument_list|(
name|loc
argument_list|,
name|XEXP
argument_list|(
name|in
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|in
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|loc_mentioned_in_p
argument_list|(
name|loc
argument_list|,
name|XVECEXP
argument_list|(
name|in
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a subreg X, return the bit offset where the subreg begins    (counting from the least significant bit of the reg).  */
end_comment

begin_function
name|unsigned
name|int
name|subreg_lsb
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|bitpos
decl_stmt|;
name|unsigned
name|int
name|byte
decl_stmt|;
name|unsigned
name|int
name|word
decl_stmt|;
comment|/* A paradoxical subreg begins at bit position 0.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
operator|!=
name|BYTES_BIG_ENDIAN
condition|)
comment|/* If the subreg crosses a word boundary ensure that        it also begins and ends on a word boundary.  */
if|if
condition|(
operator|(
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
operator|%
name|UNITS_PER_WORD
operator|+
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
operator|>
name|UNITS_PER_WORD
operator|&&
operator|(
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
operator|%
name|UNITS_PER_WORD
operator|||
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|%
name|UNITS_PER_WORD
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|word
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|inner_mode
argument_list|)
operator|-
operator|(
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
operator|+
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
else|else
name|word
operator|=
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
name|bitpos
operator|=
name|word
operator|*
name|BITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|byte
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|inner_mode
argument_list|)
operator|-
operator|(
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
operator|+
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
operator|)
operator|%
name|UNITS_PER_WORD
expr_stmt|;
else|else
name|byte
operator|=
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
operator|%
name|UNITS_PER_WORD
expr_stmt|;
name|bitpos
operator|+=
name|byte
operator|*
name|BITS_PER_UNIT
expr_stmt|;
return|return
name|bitpos
return|;
block|}
end_function

begin_comment
comment|/* This function returns the regno offset of a subreg expression.    xregno - A regno of an inner hard subreg_reg (or what will become one).    xmode  - The mode of xregno.    offset - The byte offset.    ymode  - The mode of a top level SUBREG (or what may become one).    RETURN - The regno offset which would be used.  */
end_comment

begin_function
name|unsigned
name|int
name|subreg_regno_offset
parameter_list|(
name|xregno
parameter_list|,
name|xmode
parameter_list|,
name|offset
parameter_list|,
name|ymode
parameter_list|)
name|unsigned
name|int
name|xregno
decl_stmt|;
name|enum
name|machine_mode
name|xmode
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|enum
name|machine_mode
name|ymode
decl_stmt|;
block|{
name|int
name|nregs_xmode
decl_stmt|,
name|nregs_ymode
decl_stmt|;
name|int
name|mode_multiple
decl_stmt|,
name|nregs_multiple
decl_stmt|;
name|int
name|y_offset
decl_stmt|;
if|if
condition|(
name|xregno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|nregs_xmode
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|xregno
argument_list|,
name|xmode
argument_list|)
expr_stmt|;
name|nregs_ymode
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|xregno
argument_list|,
name|ymode
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
operator|||
name|nregs_xmode
operator|==
name|nregs_ymode
condition|)
return|return
literal|0
return|;
comment|/* size of ymode must not be greater than the size of xmode.  */
name|mode_multiple
operator|=
name|GET_MODE_SIZE
argument_list|(
name|xmode
argument_list|)
operator|/
name|GET_MODE_SIZE
argument_list|(
name|ymode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_multiple
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|y_offset
operator|=
name|offset
operator|/
name|GET_MODE_SIZE
argument_list|(
name|ymode
argument_list|)
expr_stmt|;
name|nregs_multiple
operator|=
name|nregs_xmode
operator|/
name|nregs_ymode
expr_stmt|;
return|return
operator|(
name|y_offset
operator|/
operator|(
name|mode_multiple
operator|/
name|nregs_multiple
operator|)
operator|)
operator|*
name|nregs_ymode
return|;
block|}
end_function

begin_comment
comment|/* Return the final regno that a subreg expression refers to.  */
end_comment

begin_function
name|unsigned
name|int
name|subreg_regno
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|unsigned
name|int
name|ret
decl_stmt|;
name|rtx
name|subreg
init|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|subreg
argument_list|)
decl_stmt|;
name|ret
operator|=
name|regno
operator|+
name|subreg_regno_offset
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|subreg
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_struct
struct|struct
name|parms_set_data
block|{
name|int
name|nregs
decl_stmt|;
name|HARD_REG_SET
name|regs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Helper function for noticing stores to parameter registers.  */
end_comment

begin_function
specifier|static
name|void
name|parms_set
parameter_list|(
name|x
parameter_list|,
name|pat
parameter_list|,
name|data
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|pat
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|parms_set_data
modifier|*
name|d
init|=
name|data
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|d
operator|->
name|regs
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
name|d
operator|->
name|regs
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|nregs
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Look backward for first parameter to be loaded.      Do not skip BOUNDARY.  */
end_comment

begin_function
name|rtx
name|find_first_parameter_load
parameter_list|(
name|call_insn
parameter_list|,
name|boundary
parameter_list|)
name|rtx
name|call_insn
decl_stmt|,
name|boundary
decl_stmt|;
block|{
name|struct
name|parms_set_data
name|parm
decl_stmt|;
name|rtx
name|p
decl_stmt|,
name|before
decl_stmt|;
comment|/* Since different machines initialize their parameter registers      in different orders, assume nothing.  Collect the set of all      parameter registers.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|parm
operator|.
name|regs
argument_list|)
expr_stmt|;
name|parm
operator|.
name|nregs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call_insn
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|XEXP
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* We only care about registers which can hold function 	   arguments.  */
if|if
condition|(
operator|!
name|FUNCTION_ARG_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
continue|continue;
name|SET_HARD_REG_BIT
argument_list|(
name|parm
operator|.
name|regs
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|parm
operator|.
name|nregs
operator|++
expr_stmt|;
block|}
name|before
operator|=
name|call_insn
expr_stmt|;
comment|/* Search backward for the first set of a register in this set.  */
while|while
condition|(
name|parm
operator|.
name|nregs
operator|&&
name|before
operator|!=
name|boundary
condition|)
block|{
name|before
operator|=
name|PREV_INSN
argument_list|(
name|before
argument_list|)
expr_stmt|;
comment|/* It is possible that some loads got CSEed from one call to          another.  Stop in that case.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|before
argument_list|)
operator|==
name|CALL_INSN
condition|)
break|break;
comment|/* Our caller needs either ensure that we will find all sets          (in case code has not been optimized yet), or take care          for possible labels in a way by setting boundary to preceding          CODE_LABEL.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|before
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
if|if
condition|(
name|before
operator|!=
name|boundary
condition|)
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|INSN_P
argument_list|(
name|before
argument_list|)
condition|)
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|before
argument_list|)
argument_list|,
name|parms_set
argument_list|,
operator|&
name|parm
argument_list|)
expr_stmt|;
block|}
return|return
name|before
return|;
block|}
end_function

end_unit

