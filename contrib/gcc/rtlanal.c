begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Analyze RTL for GNU compiler.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software    Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_comment
comment|/* Forward declarations */
end_comment

begin_function_decl
specifier|static
name|void
name|set_of_1
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|covers_regno_p
parameter_list|(
name|rtx
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|covers_regno_no_parallel_p
parameter_list|(
name|rtx
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rtx_referenced_p_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|computed_jump_p_1
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parms_set
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|cached_nonzero_bits
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|nonzero_bits1
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|cached_num_sign_bit_copies
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|num_sign_bit_copies1
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Offset of the first 'e', 'E' or 'V' operand for each rtx code, or    -1 if a code has no such operand.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|non_rtx_starting_operands
index|[
name|NUM_RTX_CODE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bit flags that specify the machine subtype we are compiling for.    Bits are tested using macros TARGET_... defined in the tm.h file    and set by `-m...' switches.  Must be defined in rtlanal.c.  */
end_comment

begin_decl_stmt
name|int
name|target_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Truncation narrows the mode from SOURCE mode to DESTINATION mode.    If TARGET_MODE_REP_EXTENDED (DESTINATION, DESTINATION_REP) is    SIGN_EXTEND then while narrowing we also have to enforce the    representation and sign-extend the value to mode DESTINATION_REP.     If the value is already sign-extended to DESTINATION_REP mode we    can just switch to DESTINATION mode on it.  For each pair of    integral modes SOURCE and DESTINATION, when truncating from SOURCE    to DESTINATION, NUM_SIGN_BIT_COPIES_IN_REP[SOURCE][DESTINATION]    contains the number of high-order bits in SOURCE that have to be    copies of the sign-bit so that we can do this mode-switch to    DESTINATION.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|num_sign_bit_copies_in_rep
index|[
name|MAX_MODE_INT
operator|+
literal|1
index|]
index|[
name|MAX_MODE_INT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return 1 if the value of X is unstable    (would be different at a different point in the program).    The frame pointer, arg pointer, etc. are considered stable    (within one function) and so is anything marked `unchanging'.  */
end_comment

begin_function
name|int
name|rtx_unstable_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MEM
case|:
return|return
operator|!
name|MEM_READONLY_P
argument_list|(
name|x
argument_list|)
operator|||
name|rtx_unstable_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|0
return|;
case|case
name|REG
case|:
comment|/* As in rtx_varies_p, we have to use the actual rtx, not reg number.  */
if|if
condition|(
name|x
operator|==
name|frame_pointer_rtx
operator|||
name|x
operator|==
name|hard_frame_pointer_rtx
comment|/* The arg pointer varies if it is not a fixed register.  */
operator|||
operator|(
name|x
operator|==
name|arg_pointer_rtx
operator|&&
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
operator|)
condition|)
return|return
literal|0
return|;
ifndef|#
directive|ifndef
name|PIC_OFFSET_TABLE_REG_CALL_CLOBBERED
comment|/* ??? When call-clobbered, the value is stable modulo the restore 	 that must happen after a call.  This currently screws up local-alloc 	 into believing that the restore is not needed.  */
if|if
condition|(
name|x
operator|==
name|pic_offset_table_rtx
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
return|return
literal|1
return|;
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Fall through.  */
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|rtx_unstable_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|rtx_unstable_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X has a value that can vary even between two    executions of the program.  0 means X can be compared reliably    against certain constants or near-constants.    FOR_ALIAS is nonzero if we are called from alias analysis; if it is    zero, we are slightly more conservative.    The frame pointer and the arg pointer are considered constant.  */
end_comment

begin_function
name|int
name|rtx_varies_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|for_alias
parameter_list|)
block|{
name|RTX_CODE
name|code
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MEM
case|:
return|return
operator|!
name|MEM_READONLY_P
argument_list|(
name|x
argument_list|)
operator|||
name|rtx_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|for_alias
argument_list|)
return|;
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|0
return|;
case|case
name|REG
case|:
comment|/* Note that we have to test for the actual rtx used for the frame 	 and arg pointers and not just the register number in case we have 	 eliminated the frame and/or arg pointer and are using it 	 for pseudos.  */
if|if
condition|(
name|x
operator|==
name|frame_pointer_rtx
operator|||
name|x
operator|==
name|hard_frame_pointer_rtx
comment|/* The arg pointer varies if it is not a fixed register.  */
operator|||
operator|(
name|x
operator|==
name|arg_pointer_rtx
operator|&&
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|x
operator|==
name|pic_offset_table_rtx
ifdef|#
directive|ifdef
name|PIC_OFFSET_TABLE_REG_CALL_CLOBBERED
comment|/* ??? When call-clobbered, the value is stable modulo the restore 	     that must happen after a call.  This currently screws up 	     local-alloc into believing that the restore is not needed, so we 	     must return 0 only if we are called from alias analysis.  */
operator|&&
name|for_alias
endif|#
directive|endif
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|LO_SUM
case|:
comment|/* The operand 0 of a LO_SUM is considered constant 	 (in fact it is related specifically to operand 1) 	 during alias analysis.  */
return|return
operator|(
operator|!
name|for_alias
operator|&&
name|rtx_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|for_alias
argument_list|)
operator|)
operator|||
name|rtx_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|for_alias
argument_list|)
return|;
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Fall through.  */
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|rtx_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|for_alias
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|rtx_varies_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|for_alias
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the use of X as an address in a MEM can cause a trap.    MODE is the mode of the MEM (not that of X) and UNALIGNED_MEMS controls    whether nonzero is returned for unaligned memory accesses on strict    alignment machines.  */
end_comment

begin_function
specifier|static
name|int
name|rtx_addr_can_trap_p_1
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|bool
name|unaligned_mems
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
return|return
name|SYMBOL_REF_WEAK
argument_list|(
name|x
argument_list|)
return|;
case|case
name|LABEL_REF
case|:
return|return
literal|0
return|;
case|case
name|REG
case|:
comment|/* As in rtx_varies_p, we have to use the actual rtx, not reg number.  */
if|if
condition|(
name|x
operator|==
name|frame_pointer_rtx
operator|||
name|x
operator|==
name|hard_frame_pointer_rtx
operator|||
name|x
operator|==
name|stack_pointer_rtx
comment|/* The arg pointer varies if it is not a fixed register.  */
operator|||
operator|(
name|x
operator|==
name|arg_pointer_rtx
operator|&&
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
operator|)
condition|)
return|return
literal|0
return|;
comment|/* All of the virtual frame registers are stack references.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_VIRTUAL_REGISTER
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|CONST
case|:
return|return
name|rtx_addr_can_trap_p_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|unaligned_mems
argument_list|)
return|;
case|case
name|PLUS
case|:
comment|/* An address is assumed not to trap if: 	 - it is an address that can't trap plus a constant integer, 	   with the proper remainder modulo the mode size if we are 	   considering unaligned memory references.  */
if|if
condition|(
operator|!
name|rtx_addr_can_trap_p_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|unaligned_mems
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
if|if
condition|(
operator|!
name|STRICT_ALIGNMENT
operator|||
operator|!
name|unaligned_mems
operator|||
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SPARC_STACK_BOUNDARY_HACK
comment|/* ??? The SPARC port may claim a STACK_BOUNDARY higher than 	     the real alignment of %sp.  However, when it does this, the 	     alignment of %sp+STACK_POINTER_OFFSET is STACK_BOUNDARY.  */
if|if
condition|(
name|SPARC_STACK_BOUNDARY_HACK
operator|&&
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
operator|||
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|hard_frame_pointer_rtx
operator|)
condition|)
name|offset
operator|-=
name|STACK_POINTER_OFFSET
expr_stmt|;
endif|#
directive|endif
return|return
name|offset
operator|%
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|!=
literal|0
return|;
block|}
comment|/* - or it is the pic register plus a constant.  */
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|pic_offset_table_rtx
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|LO_SUM
case|:
case|case
name|PRE_MODIFY
case|:
return|return
name|rtx_addr_can_trap_p_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|,
name|unaligned_mems
argument_list|)
return|;
case|case
name|PRE_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|POST_MODIFY
case|:
return|return
name|rtx_addr_can_trap_p_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|unaligned_mems
argument_list|)
return|;
default|default:
break|break;
block|}
comment|/* If it isn't one of the case above, it can cause a trap.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the use of X as an address in a MEM can cause a trap.  */
end_comment

begin_function
name|int
name|rtx_addr_can_trap_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
return|return
name|rtx_addr_can_trap_p_1
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if X is an address that is known to not be zero.  */
end_comment

begin_function
name|bool
name|nonzero_address_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
return|return
operator|!
name|SYMBOL_REF_WEAK
argument_list|(
name|x
argument_list|)
return|;
case|case
name|LABEL_REF
case|:
return|return
name|true
return|;
case|case
name|REG
case|:
comment|/* As in rtx_varies_p, we have to use the actual rtx, not reg number.  */
if|if
condition|(
name|x
operator|==
name|frame_pointer_rtx
operator|||
name|x
operator|==
name|hard_frame_pointer_rtx
operator|||
name|x
operator|==
name|stack_pointer_rtx
operator|||
operator|(
name|x
operator|==
name|arg_pointer_rtx
operator|&&
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
operator|)
condition|)
return|return
name|true
return|;
comment|/* All of the virtual frame registers are stack references.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_VIRTUAL_REGISTER
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
case|case
name|CONST
case|:
return|return
name|nonzero_address_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|PLUS
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|nonzero_address_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Handle PIC references.  */
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|pic_offset_table_rtx
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
case|case
name|PRE_MODIFY
case|:
comment|/* Similar to the above; allow positive offsets.  Further, since 	 auto-inc is only allowed in memories, the register must be a 	 pointer.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
return|return
name|true
return|;
return|return
name|nonzero_address_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|PRE_INC
case|:
comment|/* Similarly.  Further, the offset is always positive.  */
return|return
name|true
return|;
case|case
name|PRE_DEC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|POST_MODIFY
case|:
return|return
name|nonzero_address_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|LO_SUM
case|:
return|return
name|nonzero_address_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
comment|/* If it isn't one of the case above, might be zero.  */
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X refers to a memory location whose address    cannot be compared reliably with constant addresses,    or if X refers to a BLKmode memory object.    FOR_ALIAS is nonzero if we are called from alias analysis; if it is    zero, we are slightly more conservative.  */
end_comment

begin_function
name|int
name|rtx_addr_varies_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|for_alias
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
return|return
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
operator|||
name|rtx_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|for_alias
argument_list|)
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|rtx_addr_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|for_alias
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|rtx_addr_varies_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|for_alias
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the value of the integer term in X, if one is apparent;    otherwise return 0.    Only obvious integer terms are detected.    This is used in cse.c with the `related_value' field.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|get_integer_term
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If X is a constant, return the value sans apparent integer term;    otherwise return 0.    Only obvious integer terms are detected.  */
end_comment

begin_function
name|rtx
name|get_related_value
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the number of places FIND appears within X.  If COUNT_DEST is    zero, we do not count occurrences inside the destination of a SET.  */
end_comment

begin_function
name|int
name|count_occurrences
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|find
parameter_list|,
name|int
name|count_dest
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|find
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
literal|0
return|;
case|case
name|MEM
case|:
if|if
condition|(
name|MEM_P
argument_list|(
name|find
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|find
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|SET
case|:
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|find
operator|&&
operator|!
name|count_dest
condition|)
return|return
name|count_occurrences
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|find
argument_list|,
name|count_dest
argument_list|)
return|;
break|break;
default|default:
break|break;
block|}
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|count
operator|+=
name|count_occurrences
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|find
argument_list|,
name|count_dest
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|count
operator|+=
name|count_occurrences
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|find
argument_list|,
name|count_dest
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|count
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if register REG appears somewhere within IN.    Also works if REG is not a register; in this case it checks    for a subexpression of IN that is Lisp "equal" to REG.  */
end_comment

begin_function
name|int
name|reg_mentioned_p
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|in
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|in
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|reg
operator|==
name|in
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
name|reg
operator|==
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|in
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Compare registers by number.  */
case|case
name|REG
case|:
return|return
name|REG_P
argument_list|(
name|reg
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|in
argument_list|)
operator|==
name|REGNO
argument_list|(
name|reg
argument_list|)
return|;
comment|/* These codes have no constituent expressions 	 and are unique.  */
case|case
name|SCRATCH
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
return|return
literal|0
return|;
case|case
name|CONST_INT
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|CONST_DOUBLE
case|:
comment|/* These are kept unique for a given value.  */
return|return
literal|0
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|code
operator|&&
name|rtx_equal_p
argument_list|(
name|reg
argument_list|,
name|in
argument_list|)
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|in
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|XVECEXP
argument_list|(
name|in
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|XEXP
argument_list|(
name|in
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if in between BEG and END, exclusive of BEG and END, there is    no CODE_LABEL insn.  */
end_comment

begin_function
name|int
name|no_labels_between_p
parameter_list|(
name|rtx
name|beg
parameter_list|,
name|rtx
name|end
parameter_list|)
block|{
name|rtx
name|p
decl_stmt|;
if|if
condition|(
name|beg
operator|==
name|end
condition|)
return|return
literal|0
return|;
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|beg
argument_list|)
init|;
name|p
operator|!=
name|end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|LABEL_P
argument_list|(
name|p
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if register REG is used in an insn between    FROM_INSN and TO_INSN (exclusive of those two).  */
end_comment

begin_function
name|int
name|reg_used_between_p
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|from_insn
parameter_list|,
name|rtx
name|to_insn
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|from_insn
operator|==
name|to_insn
condition|)
return|return
literal|0
return|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|from_insn
argument_list|)
init|;
name|insn
operator|!=
name|to_insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|||
operator|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|find_reg_fusage
argument_list|(
name|insn
argument_list|,
name|USE
argument_list|,
name|reg
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if the old value of X, a register, is referenced in BODY.  If X    is entirely replaced by a new value and the only use is as a SET_DEST,    we do not consider it a reference.  */
end_comment

begin_function
name|int
name|reg_referenced_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|body
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
condition|)
block|{
case|case
name|SET
case|:
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If the destination is anything other than CC0, PC, a REG or a SUBREG 	 of a REG that occupies all of the REG, the insn references X if 	 it is mentioned in the destination.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|!=
name|CC0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|!=
name|PC
operator|&&
operator|!
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|==
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
operator|)
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|ASM_OPERANDS
case|:
for|for
control|(
name|i
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|body
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|ASM_OPERANDS_INPUT
argument_list|(
name|body
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|CALL
case|:
case|case
name|USE
case|:
case|case
name|IF_THEN_ELSE
case|:
return|return
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|body
argument_list|)
return|;
case|case
name|TRAP_IF
case|:
return|return
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|TRAP_CONDITION
argument_list|(
name|body
argument_list|)
argument_list|)
return|;
case|case
name|PREFETCH
case|:
return|return
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|UNSPEC
case|:
case|case
name|UNSPEC_VOLATILE
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|PARALLEL
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|reg_referenced_p
argument_list|(
name|x
argument_list|,
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|CLOBBER
case|:
if|if
condition|(
name|MEM_P
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|COND_EXEC
case|:
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|COND_EXEC_TEST
argument_list|(
name|body
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|reg_referenced_p
argument_list|(
name|x
argument_list|,
name|COND_EXEC_CODE
argument_list|(
name|body
argument_list|)
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if register REG is set or clobbered in an insn between    FROM_INSN and TO_INSN (exclusive of those two).  */
end_comment

begin_function
name|int
name|reg_set_between_p
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|from_insn
parameter_list|,
name|rtx
name|to_insn
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|from_insn
operator|==
name|to_insn
condition|)
return|return
literal|0
return|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|from_insn
argument_list|)
init|;
name|insn
operator|!=
name|to_insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|reg_set_p
argument_list|(
name|reg
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Internals of reg_set_between_p.  */
end_comment

begin_function
name|int
name|reg_set_p
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
comment|/* We can be passed an insn or part of one.  If we are passed an insn,      check if a side-effect of the insn clobbers REG.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|FIND_REG_INC_NOTE
argument_list|(
name|insn
argument_list|,
name|reg
argument_list|)
operator|||
operator|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
operator|(
name|REG_P
argument_list|(
name|reg
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|overlaps_hard_reg_set_p
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|)
operator|||
name|MEM_P
argument_list|(
name|reg
argument_list|)
operator|||
name|find_reg_fusage
argument_list|(
name|insn
argument_list|,
name|CLOBBER
argument_list|,
name|reg
argument_list|)
operator|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
name|set_of
argument_list|(
name|reg
argument_list|,
name|insn
argument_list|)
operator|!=
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Similar to reg_set_between_p, but check all registers in X.  Return 0    only if none of them are modified between START and END.  Return 1 if    X contains a MEM; this routine does usememory aliasing.  */
end_comment

begin_function
name|int
name|modified_between_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|start
parameter_list|,
name|rtx
name|end
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|start
operator|==
name|end
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|0
return|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
if|if
condition|(
name|modified_between_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|MEM_READONLY_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|start
argument_list|)
init|;
name|insn
operator|!=
name|end
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|memory_modified_in_insn_p
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
break|break;
case|case
name|REG
case|:
return|return
name|reg_set_between_p
argument_list|(
name|x
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
return|;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|modified_between_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|modified_between_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Similar to reg_set_p, but check all registers in X.  Return 0 only if none    of them are modified in INSN.  Return 1 if X contains a MEM; this routine    does use memory aliasing.  */
end_comment

begin_function
name|int
name|modified_in_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|0
return|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
if|if
condition|(
name|modified_in_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|MEM_READONLY_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|memory_modified_in_insn_p
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
break|break;
case|case
name|REG
case|:
return|return
name|reg_set_p
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
return|;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|modified_in_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|modified_in_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper function for set_of.  */
end_comment

begin_struct
struct|struct
name|set_of_data
block|{
name|rtx
name|found
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|set_of_1
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|pat
parameter_list|,
name|void
modifier|*
name|data1
parameter_list|)
block|{
name|struct
name|set_of_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|set_of_data
operator|*
operator|)
operator|(
name|data1
operator|)
decl_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|data
operator|->
name|pat
argument_list|)
operator|||
operator|(
operator|!
name|MEM_P
argument_list|(
name|x
argument_list|)
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|data
operator|->
name|pat
argument_list|,
name|x
argument_list|)
operator|)
condition|)
name|data
operator|->
name|found
operator|=
name|pat
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Give an INSN, return a SET or CLOBBER expression that does modify PAT    (either directly or via STRICT_LOW_PART and similar modifiers).  */
end_comment

begin_function
name|rtx
name|set_of
parameter_list|(
name|rtx
name|pat
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|struct
name|set_of_data
name|data
decl_stmt|;
name|data
operator|.
name|found
operator|=
name|NULL_RTX
expr_stmt|;
name|data
operator|.
name|pat
operator|=
name|pat
expr_stmt|;
name|note_stores
argument_list|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|?
name|PATTERN
argument_list|(
name|insn
argument_list|)
else|:
name|insn
argument_list|,
name|set_of_1
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
return|return
name|data
operator|.
name|found
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an INSN, return a SET expression if this insn has only a single SET.    It may also have CLOBBERs, USEs, or SET whose output    will not be used, which we ignore.  */
end_comment

begin_function
name|rtx
name|single_set_2
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|pat
parameter_list|)
block|{
name|rtx
name|set
init|=
name|NULL
decl_stmt|;
name|int
name|set_verified
init|=
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|sub
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|sub
argument_list|)
condition|)
block|{
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
break|break;
case|case
name|SET
case|:
comment|/* We can consider insns having multiple sets, where all 		 but one are dead as single set insns.  In common case 		 only single set is present in the pattern so we want 		 to avoid checking for REG_UNUSED notes unless necessary.  		 When we reach set first time, we just expect this is 		 the single set we are looking for and only when more 		 sets are found in the insn, we check them.  */
if|if
condition|(
operator|!
name|set_verified
condition|)
block|{
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|set
argument_list|)
condition|)
name|set
operator|=
name|NULL
expr_stmt|;
else|else
name|set_verified
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|set
condition|)
name|set
operator|=
name|sub
operator|,
name|set_verified
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|SET_DEST
argument_list|(
name|sub
argument_list|)
argument_list|)
operator|||
name|side_effects_p
argument_list|(
name|sub
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
break|break;
default|default:
return|return
name|NULL_RTX
return|;
block|}
block|}
block|}
return|return
name|set
return|;
block|}
end_function

begin_comment
comment|/* Given an INSN, return nonzero if it has more than one SET, else return    zero.  */
end_comment

begin_function
name|int
name|multiple_sets
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|found
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* INSN must be an insn.  */
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Only a PARALLEL can have multiple SETs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|found
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
comment|/* If we have already found a SET, then return now.  */
if|if
condition|(
name|found
condition|)
return|return
literal|1
return|;
else|else
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Either zero or one SET.  */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if the destination of SET equals the source    and there are no side effects.  */
end_comment

begin_function
name|int
name|set_noop_p
parameter_list|(
name|rtx
name|set
parameter_list|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|dst
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
if|if
condition|(
name|dst
operator|==
name|pc_rtx
operator|&&
name|src
operator|==
name|pc_rtx
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|MEM_P
argument_list|(
name|dst
argument_list|)
operator|&&
name|MEM_P
argument_list|(
name|src
argument_list|)
condition|)
return|return
name|rtx_equal_p
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|dst
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
return|return
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|src
argument_list|)
operator|&&
operator|!
name|BYTES_BIG_ENDIAN
operator|&&
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|2
argument_list|)
operator|==
name|const0_rtx
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|src
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dst
operator|=
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|SUBREG_BYTE
argument_list|(
name|src
argument_list|)
operator|!=
name|SUBREG_BYTE
argument_list|(
name|dst
argument_list|)
condition|)
return|return
literal|0
return|;
name|src
operator|=
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|dst
operator|=
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|REG_P
argument_list|(
name|src
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|dst
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|==
name|REGNO
argument_list|(
name|dst
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if an insn consists only of SETs, each of which only sets a    value to itself.  */
end_comment

begin_function
name|int
name|noop_move_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOOP_MOVE_INSN_CODE
condition|)
return|return
literal|1
return|;
comment|/* Insns carrying these notes are useful later on.  */
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* For now treat an insn with a REG_RETVAL note as a      a special insn which should not be considered a no-op.  */
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|set_noop_p
argument_list|(
name|pat
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* If nothing but SETs of registers to themselves, 	 this insn can also be deleted.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|tem
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CLOBBER
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|SET
operator|||
operator|!
name|set_noop_p
argument_list|(
name|tem
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the last thing that X was assigned from before *PINSN.  If VALID_TO    is not NULL_RTX then verify that the object is not modified up to VALID_TO.    If the object was modified, if we hit a partial assignment to X, or hit a    CODE_LABEL first, return X.  If we found an assignment, update *PINSN to    point to it.  ALLOW_HWREG is set to 1 if hardware registers are allowed to    be the src.  */
end_comment

begin_function
name|rtx
name|find_last_value
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
modifier|*
name|pinsn
parameter_list|,
name|rtx
name|valid_to
parameter_list|,
name|int
name|allow_hwreg
parameter_list|)
block|{
name|rtx
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|PREV_INSN
argument_list|(
operator|*
name|pinsn
argument_list|)
init|;
name|p
operator|&&
operator|!
name|LABEL_P
argument_list|(
name|p
argument_list|)
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|EXPR_LIST
condition|)
name|src
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|valid_to
operator|==
name|NULL_RTX
operator|||
operator|!
name|modified_between_p
argument_list|(
name|src
argument_list|,
name|PREV_INSN
argument_list|(
name|p
argument_list|)
argument_list|,
name|valid_to
argument_list|)
operator|)
comment|/* Reject hard registers because we don't usually want 		   to use them; we'd rather use a pseudo.  */
operator|&&
operator|(
operator|!
operator|(
name|REG_P
argument_list|(
name|src
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
name|allow_hwreg
operator|)
condition|)
block|{
operator|*
name|pinsn
operator|=
name|p
expr_stmt|;
return|return
name|src
return|;
block|}
block|}
comment|/* If set in non-simple way, we don't have a value.  */
if|if
condition|(
name|reg_set_p
argument_list|(
name|x
argument_list|,
name|p
argument_list|)
condition|)
break|break;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if register in range [REGNO, ENDREGNO)    appears either explicitly or implicitly in X    other than being stored into.     References contained within the substructure at LOC do not count.    LOC may be zero, meaning don't ignore anything.  */
end_comment

begin_function
name|int
name|refers_to_regno_p
parameter_list|(
name|unsigned
name|int
name|regno
parameter_list|,
name|unsigned
name|int
name|endregno
parameter_list|,
name|rtx
name|x
parameter_list|,
name|rtx
modifier|*
name|loc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|x_regno
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|repeat
label|:
comment|/* The contents of a REG_NONNEG note is always zero, so we must come here      upon repeat in case the last REG_NOTE is a REG_NONNEG note.  */
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
name|x_regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If we modifying the stack, frame, or argument pointer, it will 	 clobber a virtual register.  In fact, we could be more precise, 	 but it isn't worth it.  */
if|if
condition|(
operator|(
name|x_regno
operator|==
name|STACK_POINTER_REGNUM
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|||
name|x_regno
operator|==
name|ARG_POINTER_REGNUM
endif|#
directive|endif
operator|||
name|x_regno
operator|==
name|FRAME_POINTER_REGNUM
operator|)
operator|&&
name|regno
operator|>=
name|FIRST_VIRTUAL_REGISTER
operator|&&
name|regno
operator|<=
name|LAST_VIRTUAL_REGISTER
condition|)
return|return
literal|1
return|;
return|return
operator|(
name|endregno
operator|>
name|x_regno
operator|&&
name|regno
operator|<
name|x_regno
operator|+
operator|(
name|x_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|hard_regno_nregs
index|[
name|x_regno
index|]
index|[
name|GET_MODE
argument_list|(
name|x
argument_list|)
index|]
else|:
literal|1
operator|)
operator|)
return|;
case|case
name|SUBREG
case|:
comment|/* If this is a SUBREG of a hard reg, we can see exactly which 	 registers are being modified.  Otherwise, handle normally.  */
if|if
condition|(
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|unsigned
name|int
name|inner_regno
init|=
name|subreg_regno
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|inner_endregno
init|=
name|inner_regno
operator|+
operator|(
name|inner_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|hard_regno_nregs
index|[
name|inner_regno
index|]
index|[
name|GET_MODE
argument_list|(
name|x
argument_list|)
index|]
else|:
literal|1
operator|)
decl_stmt|;
return|return
name|endregno
operator|>
name|inner_regno
operator|&&
name|regno
operator|<
name|inner_endregno
return|;
block|}
break|break;
case|case
name|CLOBBER
case|:
case|case
name|SET
case|:
if|if
condition|(
operator|&
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|!=
name|loc
comment|/* Note setting a SUBREG counts as referring to the REG it is in for 	     a pseudo but not for hard registers since we can 	     treat each word individually.  */
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|loc
operator|!=
operator|&
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|loc
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|loc
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|code
operator|==
name|CLOBBER
operator|||
name|loc
operator|==
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
default|default:
break|break;
block|}
comment|/* X does not match, so try its subexpressions.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|loc
operator|!=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
elseif|else
if|if
condition|(
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|loc
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|loc
operator|!=
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|&&
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|loc
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if modifying X will affect IN.  If X is a register or a SUBREG,    we check if any register number in X conflicts with the relevant register    numbers.  If X is a constant, return 0.  If X is a MEM, return 1 iff IN    contains a MEM (we don't bother checking for memory addresses that can't    conflict because we expect this to be a rare case.  */
end_comment

begin_function
name|int
name|reg_overlap_mentioned_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|in
parameter_list|)
block|{
name|unsigned
name|int
name|regno
decl_stmt|,
name|endregno
decl_stmt|;
comment|/* If either argument is a constant, then modifying X can not      affect IN.  Here we look at IN, we can profitably combine      CONSTANT_P (x) with the switch statement below.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|in
argument_list|)
condition|)
return|return
literal|0
return|;
name|recurse
label|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|STRICT_LOW_PART
case|:
case|case
name|ZERO_EXTRACT
case|:
case|case
name|SIGN_EXTRACT
case|:
comment|/* Overly conservative.  */
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|recurse
goto|;
case|case
name|SUBREG
case|:
name|regno
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|regno
operator|=
name|subreg_regno
argument_list|(
name|x
argument_list|)
expr_stmt|;
goto|goto
name|do_reg
goto|;
case|case
name|REG
case|:
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|do_reg
label|:
name|endregno
operator|=
name|regno
operator|+
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|GET_MODE
argument_list|(
name|x
argument_list|)
index|]
else|:
literal|1
operator|)
expr_stmt|;
return|return
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|in
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|)
return|;
case|case
name|MEM
case|:
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|MEM_P
argument_list|(
name|in
argument_list|)
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|XEXP
argument_list|(
name|in
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|in
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|XVECEXP
argument_list|(
name|in
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
case|case
name|SCRATCH
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
name|reg_mentioned_p
argument_list|(
name|x
argument_list|,
name|in
argument_list|)
return|;
case|case
name|PARALLEL
case|:
block|{
name|int
name|i
decl_stmt|;
comment|/* If any register in here refers to it we return true.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|in
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
default|default:
name|gcc_assert
argument_list|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call FUN on each register or MEM that is stored into or clobbered by X.    (X would be the pattern of an insn).    FUN receives two arguments:      the REG, MEM, CC0 or PC being stored in or clobbered,      the SET or CLOBBER rtx that does the store.    If the item being stored in or clobbered is a SUBREG of a hard register,   the SUBREG will be passed.  */
end_comment

begin_function
name|void
name|note_stores
parameter_list|(
name|rtx
name|x
parameter_list|,
name|void
function_decl|(
modifier|*
name|fun
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|x
operator|=
name|COND_EXEC_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
operator|!
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|||
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we have a PARALLEL, SET_DEST is a list of EXPR_LIST expressions, 	 each of whose first operand is a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
call|(
modifier|*
name|fun
call|)
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
call|(
modifier|*
name|fun
call|)
argument_list|(
name|dest
argument_list|,
name|x
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|note_stores
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|fun
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like notes_stores, but call FUN for each expression that is being    referenced in PBODY, a pointer to the PATTERN of an insn.  We only call    FUN for each expression, not any interior subexpressions.  FUN receives a    pointer to the expression and the DATA passed to this function.     Note that this is not quite the same test as that done in reg_referenced_p    since that considers something as being referenced if it is being    partially set, while we do not.  */
end_comment

begin_function
name|void
name|note_uses
parameter_list|(
name|rtx
modifier|*
name|pbody
parameter_list|,
name|void
function_decl|(
modifier|*
name|fun
function_decl|)
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|rtx
name|body
init|=
operator|*
name|pbody
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
condition|)
block|{
case|case
name|COND_EXEC
case|:
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|COND_EXEC_TEST
argument_list|(
name|body
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|note_uses
argument_list|(
operator|&
name|COND_EXEC_CODE
argument_list|(
name|body
argument_list|)
argument_list|,
name|fun
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
case|case
name|PARALLEL
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|note_uses
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|fun
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
case|case
name|USE
case|:
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
case|case
name|ASM_OPERANDS
case|:
for|for
control|(
name|i
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|body
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|ASM_OPERANDS_INPUT
argument_list|(
name|body
argument_list|,
name|i
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
case|case
name|TRAP_IF
case|:
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|TRAP_CONDITION
argument_list|(
name|body
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
case|case
name|PREFETCH
case|:
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNSPEC
case|:
case|case
name|UNSPEC_VOLATILE
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
case|case
name|CLOBBER
case|:
if|if
condition|(
name|MEM_P
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
case|case
name|SET
case|:
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
decl_stmt|;
comment|/* For sets we replace everything in source plus registers in memory 	   expression in store and operands of a ZERO_EXTRACT.  */
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
block|{
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|1
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|2
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|MEM_P
argument_list|(
name|dest
argument_list|)
condition|)
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
comment|/* All the other possibilities never store.  */
call|(
modifier|*
name|fun
call|)
argument_list|(
name|pbody
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if X's old contents don't survive after INSN.    This will be true if X is (cc0) or if X is a register and    X dies in INSN or because INSN entirely sets X.     "Entirely set" means set directly and not through a SUBREG, or    ZERO_EXTRACT, so no trace of the old contents remains.    Likewise, REG_INC does not count.     REG may be a hard or pseudo reg.  Renumbering is not taken into account,    but for this use that makes no difference, since regs don't overlap    during their lifetimes.  Therefore, this function may be used    at any time after deaths have been computed (in flow.c).     If REG is a hard reg that occupies multiple machine registers, this    function will only return 1 if each of those registers will be replaced    by INSN.  */
end_comment

begin_function
name|int
name|dead_or_set_p
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|unsigned
name|int
name|regno
decl_stmt|,
name|last_regno
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Can't use cc0_rtx below since this file is used by genattrtab.c.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CC0
condition|)
return|return
literal|1
return|;
name|gcc_assert
argument_list|(
name|REG_P
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|last_regno
operator|=
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
name|regno
else|:
name|regno
operator|+
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|GET_MODE
argument_list|(
name|x
argument_list|)
index|]
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<=
name|last_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|dead_or_set_regno_p
argument_list|(
name|insn
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE iff DEST is a register or subreg of a register and    doesn't change the number of words of the inner register, and any    part of the register is TEST_REGNO.  */
end_comment

begin_function
specifier|static
name|bool
name|covers_regno_no_parallel_p
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|unsigned
name|int
name|test_regno
parameter_list|)
block|{
name|unsigned
name|int
name|regno
decl_stmt|,
name|endregno
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|==
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|dest
argument_list|)
condition|)
return|return
name|false
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|endregno
operator|=
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
name|regno
operator|+
literal|1
else|:
name|regno
operator|+
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|GET_MODE
argument_list|(
name|dest
argument_list|)
index|]
operator|)
expr_stmt|;
return|return
operator|(
name|test_regno
operator|>=
name|regno
operator|&&
name|test_regno
operator|<
name|endregno
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like covers_regno_no_parallel_p, but also handles PARALLELs where    any member matches the covers_regno_no_parallel_p criteria.  */
end_comment

begin_function
specifier|static
name|bool
name|covers_regno_p
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|unsigned
name|int
name|test_regno
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
comment|/* Some targets place small structures in registers for return 	 values of functions, and those registers are wrapped in 	 PARALLELs that we may see as the destination of a SET.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|inner
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|inner
operator|!=
name|NULL_RTX
operator|&&
name|covers_regno_no_parallel_p
argument_list|(
name|inner
argument_list|,
name|test_regno
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
else|else
return|return
name|covers_regno_no_parallel_p
argument_list|(
name|dest
argument_list|,
name|test_regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Utility function for dead_or_set_p to check an individual register.  Also    called from flow.c.  */
end_comment

begin_function
name|int
name|dead_or_set_regno_p
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|unsigned
name|int
name|test_regno
parameter_list|)
block|{
name|rtx
name|pattern
decl_stmt|;
comment|/* See if there is a death note for something that includes TEST_REGNO.  */
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|test_regno
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|find_regno_fusage
argument_list|(
name|insn
argument_list|,
name|CLOBBER
argument_list|,
name|test_regno
argument_list|)
condition|)
return|return
literal|1
return|;
name|pattern
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|pattern
operator|=
name|COND_EXEC_CODE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SET
condition|)
return|return
name|covers_regno_p
argument_list|(
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
argument_list|,
name|test_regno
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|body
init|=
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|body
operator|=
name|COND_EXEC_CODE
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|CLOBBER
operator|)
operator|&&
name|covers_regno_p
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|,
name|test_regno
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the reg-note of kind KIND in insn INSN, if there is one.    If DATUM is nonzero, look for one whose datum is DATUM.  */
end_comment

begin_function
name|rtx
name|find_reg_note
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|enum
name|reg_note
name|kind
parameter_list|,
name|rtx
name|datum
parameter_list|)
block|{
name|rtx
name|link
decl_stmt|;
name|gcc_assert
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Ignore anything that is not an INSN, JUMP_INSN or CALL_INSN.  */
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|datum
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|kind
condition|)
return|return
name|link
return|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|kind
operator|&&
name|datum
operator|==
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|link
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the reg-note of kind KIND in insn INSN which applies to register    number REGNO, if any.  Return 0 if there is no such reg-note.  Note that    the REGNO of this NOTE need not be REGNO if REGNO is a hard register;    it might be the case that the note overlaps REGNO.  */
end_comment

begin_function
name|rtx
name|find_regno_note
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|enum
name|reg_note
name|kind
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|)
block|{
name|rtx
name|link
decl_stmt|;
comment|/* Ignore anything that is not an INSN, JUMP_INSN or CALL_INSN.  */
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|kind
comment|/* Verify that it is a register, so that scratch and MEM won't cause a 	   problem here.  */
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
name|regno
operator|&&
operator|(
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|+
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|hard_regno_nregs
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
index|[
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|)
operator|)
operator|>
name|regno
operator|)
condition|)
return|return
name|link
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return a REG_EQUIV or REG_EQUAL note if insn has only a single set and    has such a note.  */
end_comment

begin_function
name|rtx
name|find_reg_equal_equiv_note
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|link
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_EQUAL
operator|||
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_EQUIV
condition|)
block|{
if|if
condition|(
name|single_set
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|link
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return true if DATUM, or any overlap of DATUM, of kind CODE is found    in the CALL_INSN_FUNCTION_USAGE information of INSN.  */
end_comment

begin_function
name|int
name|find_reg_fusage
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|datum
parameter_list|)
block|{
comment|/* If it's not a CALL_INSN, it can't possibly have a      CALL_INSN_FUNCTION_USAGE field, so don't bother checking.  */
if|if
condition|(
operator|!
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
name|gcc_assert
argument_list|(
name|datum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|datum
argument_list|)
condition|)
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|code
operator|&&
name|rtx_equal_p
argument_list|(
name|datum
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|datum
argument_list|)
decl_stmt|;
comment|/* CALL_INSN_FUNCTION_USAGE information cannot contain references 	 to pseudo registers, so don't bother checking.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|unsigned
name|int
name|end_regno
init|=
name|regno
operator|+
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|GET_MODE
argument_list|(
name|datum
argument_list|)
index|]
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|end_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|find_regno_fusage
argument_list|(
name|insn
argument_list|,
name|code
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if REGNO, or any overlap of REGNO, of kind CODE is found    in the CALL_INSN_FUNCTION_USAGE information of INSN.  */
end_comment

begin_function
name|int
name|find_regno_fusage
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|)
block|{
name|rtx
name|link
decl_stmt|;
comment|/* CALL_INSN_FUNCTION_USAGE information cannot contain references      to pseudo registers, so don't bother checking.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|unsigned
name|int
name|regnote
decl_stmt|;
name|rtx
name|op
decl_stmt|,
name|reg
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|code
operator|&&
name|REG_P
argument_list|(
name|reg
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
name|regnote
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|)
operator|<=
name|regno
operator|&&
name|regnote
operator|+
name|hard_regno_nregs
index|[
name|regnote
index|]
index|[
name|GET_MODE
argument_list|(
name|reg
argument_list|)
index|]
operator|>
name|regno
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if INSN is a call to a pure function.  */
end_comment

begin_function
name|int
name|pure_call_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|link
decl_stmt|;
if|if
condition|(
operator|!
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|!
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Look for the note that differentiates const and pure functions.  */
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|u
decl_stmt|,
name|m
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|u
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|MEM_P
argument_list|(
name|m
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|m
argument_list|)
operator|==
name|BLKmode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SCRATCH
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remove register note NOTE from the REG_NOTES of INSN.  */
end_comment

begin_function
name|void
name|remove_note
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|note
parameter_list|)
block|{
name|rtx
name|link
decl_stmt|;
if|if
condition|(
name|note
operator|==
name|NULL_RTX
condition|)
return|return;
if|if
condition|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|==
name|note
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|==
name|note
condition|)
block|{
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Search LISTP (an EXPR_LIST) for an entry whose first operand is NODE and    return 1 if it is found.  A simple equality test is used to determine if    NODE matches.  */
end_comment

begin_function
name|int
name|in_expr_list_p
parameter_list|(
name|rtx
name|listp
parameter_list|,
name|rtx
name|node
parameter_list|)
block|{
name|rtx
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|listp
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|node
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Search LISTP (an EXPR_LIST) for an entry whose first operand is NODE and    remove that entry from the list if it is found.     A simple equality test is used to determine if NODE matches.  */
end_comment

begin_function
name|void
name|remove_node_from_expr_list
parameter_list|(
name|rtx
name|node
parameter_list|,
name|rtx
modifier|*
name|listp
parameter_list|)
block|{
name|rtx
name|temp
init|=
operator|*
name|listp
decl_stmt|;
name|rtx
name|prev
init|=
name|NULL_RTX
decl_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|node
operator|==
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Splice the node out of the list.  */
if|if
condition|(
name|prev
condition|)
name|XEXP
argument_list|(
name|prev
argument_list|,
literal|1
argument_list|)
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
operator|*
name|listp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|prev
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if X contains any volatile instructions.  These are instructions    which may cause unpredictable machine state instructions, and thus no    instructions should be moved or combined across them.  This includes    only volatile asms and UNSPEC_VOLATILE instructions.  */
end_comment

begin_function
name|int
name|volatile_insn_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|RTX_CODE
name|code
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|REG
case|:
case|case
name|SCRATCH
case|:
case|case
name|CLOBBER
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
case|case
name|CALL
case|:
case|case
name|MEM
case|:
return|return
literal|0
return|;
case|case
name|UNSPEC_VOLATILE
case|:
comment|/* case TRAP_IF: This isn't clear yet.  */
return|return
literal|1
return|;
case|case
name|ASM_INPUT
case|:
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
default|default:
break|break;
block|}
comment|/* Recursively scan the operands of this expression.  */
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|volatile_insn_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|volatile_insn_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if X contains any volatile memory references    UNSPEC_VOLATILE operations or volatile ASM_OPERANDS expressions.  */
end_comment

begin_function
name|int
name|volatile_refs_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|RTX_CODE
name|code
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|REG
case|:
case|case
name|SCRATCH
case|:
case|case
name|CLOBBER
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return
literal|0
return|;
case|case
name|UNSPEC_VOLATILE
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
default|default:
break|break;
block|}
comment|/* Recursively scan the operands of this expression.  */
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|volatile_refs_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|volatile_refs_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Similar to above, except that it also rejects register pre- and post-    incrementing.  */
end_comment

begin_function
name|int
name|side_effects_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|RTX_CODE
name|code
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|REG
case|:
case|case
name|SCRATCH
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return
literal|0
return|;
case|case
name|CLOBBER
case|:
comment|/* Reject CLOBBER with a non-VOID mode.  These are made by combine.c 	 when some combination can't be done.  If we see one, don't think 	 that we can simplify the expression.  */
return|return
operator|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
operator|)
return|;
case|case
name|PRE_INC
case|:
case|case
name|PRE_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_MODIFY
case|:
case|case
name|POST_MODIFY
case|:
case|case
name|CALL
case|:
case|case
name|UNSPEC_VOLATILE
case|:
comment|/* case TRAP_IF: This isn't clear yet.  */
return|return
literal|1
return|;
case|case
name|MEM
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
default|default:
break|break;
block|}
comment|/* Recursively scan the operands of this expression.  */
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|side_effects_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|side_effects_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_enum
enum|enum
name|may_trap_p_flags
block|{
name|MTP_UNALIGNED_MEMS
init|=
literal|1
block|,
name|MTP_AFTER_MOVE
init|=
literal|2
block|}
enum|;
end_enum

begin_comment
comment|/* Return nonzero if evaluating rtx X might cause a trap.    (FLAGS& MTP_UNALIGNED_MEMS) controls whether nonzero is returned for    unaligned memory accesses on strict alignment machines.  If    (FLAGS& AFTER_MOVE) is true, returns nonzero even in case the expression    cannot trap at its current location, but it might become trapping if moved    elsewhere.  */
end_comment

begin_function
specifier|static
name|int
name|may_trap_p_1
parameter_list|(
name|rtx
name|x
parameter_list|,
name|unsigned
name|flags
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|bool
name|unaligned_mems
init|=
operator|(
name|flags
operator|&
name|MTP_UNALIGNED_MEMS
operator|)
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Handle these cases quickly.  */
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|REG
case|:
case|case
name|SCRATCH
case|:
return|return
literal|0
return|;
case|case
name|ASM_INPUT
case|:
case|case
name|UNSPEC_VOLATILE
case|:
case|case
name|TRAP_IF
case|:
return|return
literal|1
return|;
case|case
name|ASM_OPERANDS
case|:
return|return
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
return|;
comment|/* Memory ref can trap unless it's a static var or a stack slot.  */
case|case
name|MEM
case|:
if|if
condition|(
comment|/* MEM_NOTRAP_P only relates to the actual position of the memory 	     reference; moving it out of condition might cause its address 	     become invalid.  */
operator|!
operator|(
name|flags
operator|&
name|MTP_AFTER_MOVE
operator|)
operator|&&
name|MEM_NOTRAP_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|(
operator|!
name|STRICT_ALIGNMENT
operator|||
operator|!
name|unaligned_mems
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|rtx_addr_can_trap_p_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|unaligned_mems
argument_list|)
return|;
comment|/* Division by a non-constant might trap.  */
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
if|if
condition|(
name|HONOR_SNANS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|flag_trapping_math
return|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|EXPR_LIST
case|:
comment|/* An EXPR_LIST is used to represent a function call.  This 	 certainly may trap.  */
return|return
literal|1
return|;
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|LTGT
case|:
case|case
name|COMPARE
case|:
comment|/* Some floating point comparisons may trap.  */
if|if
condition|(
operator|!
name|flag_trapping_math
condition|)
break|break;
comment|/* ??? There is no machine independent way to check for tests that trap 	 when COMPARE is used, though many targets do make this distinction. 	 For instance, sparc uses CCFPE for compares which generate exceptions 	 and CCFP for compares which do not generate exceptions.  */
if|if
condition|(
name|HONOR_NANS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* But often the compare has some CC mode, so check operand 	 modes as well.  */
if|if
condition|(
name|HONOR_NANS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|||
name|HONOR_NANS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|EQ
case|:
case|case
name|NE
case|:
if|if
condition|(
name|HONOR_SNANS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Often comparison is CC mode, so check operand modes.  */
if|if
condition|(
name|HONOR_SNANS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|||
name|HONOR_SNANS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|FIX
case|:
comment|/* Conversion of floating point might trap.  */
if|if
condition|(
name|flag_trapping_math
operator|&&
name|HONOR_NANS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|NEG
case|:
case|case
name|ABS
case|:
case|case
name|SUBREG
case|:
comment|/* These operations don't trap even with floating point.  */
break|break;
default|default:
comment|/* Any floating arithmetic may trap.  */
if|if
condition|(
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|flag_trapping_math
condition|)
return|return
literal|1
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|may_trap_p_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|flags
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|may_trap_p_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|flags
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if evaluating rtx X might cause a trap.  */
end_comment

begin_function
name|int
name|may_trap_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
return|return
name|may_trap_p_1
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if evaluating rtx X might cause a trap, when the expression    is moved from its current location by some optimization.  */
end_comment

begin_function
name|int
name|may_trap_after_code_motion_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
return|return
name|may_trap_p_1
argument_list|(
name|x
argument_list|,
name|MTP_AFTER_MOVE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Same as above, but additionally return nonzero if evaluating rtx X might    cause a fault.  We define a fault for the purpose of this function as a    erroneous execution condition that cannot be encountered during the normal    execution of a valid program; the typical example is an unaligned memory    access on a strict alignment machine.  The compiler guarantees that it    doesn't generate code that will fault from a valid program, but this    guarantee doesn't mean anything for individual instructions.  Consider    the following example:        struct S { int d; union { char *cp; int *ip; }; };        int foo(struct S *s)       { 	if (s->d == 1) 	  return *s->ip; 	else 	  return *s->cp;       }     on a strict alignment machine.  In a valid program, foo will never be    invoked on a structure for which d is equal to 1 and the underlying    unique field of the union not aligned on a 4-byte boundary, but the    expression *s->ip might cause a fault if considered individually.     At the RTL level, potentially problematic expressions will almost always    verify may_trap_p; for example, the above dereference can be emitted as    (mem:SI (reg:P)) and this expression is may_trap_p for a generic register.    However, suppose that foo is inlined in a caller that causes s->cp to    point to a local character variable and guarantees that s->d is not set    to 1; foo may have been effectively translated into pseudo-RTL as:        if ((reg:SI) == 1) 	(set (reg:SI) (mem:SI (%fp - 7)))       else 	(set (reg:QI) (mem:QI (%fp - 7)))     Now (mem:SI (%fp - 7)) is considered as not may_trap_p since it is a    memory reference to a stack slot, but it will certainly cause a fault    on a strict alignment machine.  */
end_comment

begin_function
name|int
name|may_trap_or_fault_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
return|return
name|may_trap_p_1
argument_list|(
name|x
argument_list|,
name|MTP_UNALIGNED_MEMS
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if X contains a comparison that is not either EQ or NE,    i.e., an inequality.  */
end_comment

begin_function
name|int
name|inequality_comparisons_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|SCRATCH
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
return|return
literal|0
return|;
case|case
name|LT
case|:
case|case
name|LTU
case|:
case|case
name|GT
case|:
case|case
name|GTU
case|:
case|case
name|LE
case|:
case|case
name|LEU
case|:
case|case
name|GE
case|:
case|case
name|GEU
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|inequality_comparisons_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|inequality_comparisons_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Replace any occurrence of FROM in X with TO.  The function does    not enter into CONST_DOUBLE for the replace.     Note that copying is not done so X must not be shared unless all copies    are to be modified.  */
end_comment

begin_function
name|rtx
name|replace_rtx
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|from
parameter_list|,
name|rtx
name|to
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* The following prevents loops occurrence when we change MEM in      CONST_DOUBLE onto the same CONST_DOUBLE.  */
if|if
condition|(
name|x
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
name|x
return|;
if|if
condition|(
name|x
operator|==
name|from
condition|)
return|return
name|to
return|;
comment|/* Allow this function to make replacements in EXPR_LISTs.  */
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|rtx
name|new
init|=
name|replace_rtx
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|x
operator|=
name|simplify_subreg
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
else|else
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
operator|=
name|new
expr_stmt|;
return|return
name|x
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTEND
condition|)
block|{
name|rtx
name|new
init|=
name|replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|x
operator|=
name|simplify_unary_operation
argument_list|(
name|ZERO_EXTEND
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
else|else
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|new
expr_stmt|;
return|return
name|x
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|replace_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Replace occurrences of the old label in *X with the new one.    DATA is a REPLACE_LABEL_DATA containing the old and new labels.  */
end_comment

begin_function
name|int
name|replace_label
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|rtx
name|l
init|=
operator|*
name|x
decl_stmt|;
name|rtx
name|old_label
init|=
operator|(
operator|(
name|replace_label_data
operator|*
operator|)
name|data
operator|)
operator|->
name|r1
decl_stmt|;
name|rtx
name|new_label
init|=
operator|(
operator|(
name|replace_label_data
operator|*
operator|)
name|data
operator|)
operator|->
name|r2
decl_stmt|;
name|bool
name|update_label_nuses
init|=
operator|(
operator|(
name|replace_label_data
operator|*
operator|)
name|data
operator|)
operator|->
name|update_label_nuses
decl_stmt|;
if|if
condition|(
name|l
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|l
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|l
argument_list|)
condition|)
block|{
name|rtx
name|c
init|=
name|get_pool_constant
argument_list|(
name|l
argument_list|)
decl_stmt|;
if|if
condition|(
name|rtx_referenced_p
argument_list|(
name|old_label
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|rtx
name|new_c
decl_stmt|,
name|new_l
decl_stmt|;
name|replace_label_data
modifier|*
name|d
init|=
operator|(
name|replace_label_data
operator|*
operator|)
name|data
decl_stmt|;
comment|/* Create a copy of constant C; replace the label inside 	     but do not update LABEL_NUSES because uses in constant pool 	     are not counted.  */
name|new_c
operator|=
name|copy_rtx
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|d
operator|->
name|update_label_nuses
operator|=
name|false
expr_stmt|;
name|for_each_rtx
argument_list|(
operator|&
name|new_c
argument_list|,
name|replace_label
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|d
operator|->
name|update_label_nuses
operator|=
name|update_label_nuses
expr_stmt|;
comment|/* Add the new constant NEW_C to constant pool and replace 	     the old reference to constant by new reference.  */
name|new_l
operator|=
name|XEXP
argument_list|(
name|force_const_mem
argument_list|(
name|get_pool_mode
argument_list|(
name|l
argument_list|)
argument_list|,
name|new_c
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|x
operator|=
name|replace_rtx
argument_list|(
name|l
argument_list|,
name|l
argument_list|,
name|new_l
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* If this is a JUMP_INSN, then we also need to fix the JUMP_LABEL      field.  This is not handled by for_each_rtx because it doesn't      handle unprinted ('0') fields.  */
if|if
condition|(
name|JUMP_P
argument_list|(
name|l
argument_list|)
operator|&&
name|JUMP_LABEL
argument_list|(
name|l
argument_list|)
operator|==
name|old_label
condition|)
name|JUMP_LABEL
argument_list|(
name|l
argument_list|)
operator|=
name|new_label
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|l
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|l
argument_list|)
operator|==
name|INSN_LIST
operator|)
operator|&&
name|XEXP
argument_list|(
name|l
argument_list|,
literal|0
argument_list|)
operator|==
name|old_label
condition|)
block|{
name|XEXP
argument_list|(
name|l
argument_list|,
literal|0
argument_list|)
operator|=
name|new_label
expr_stmt|;
if|if
condition|(
name|update_label_nuses
condition|)
block|{
operator|++
name|LABEL_NUSES
argument_list|(
name|new_label
argument_list|)
expr_stmt|;
operator|--
name|LABEL_NUSES
argument_list|(
name|old_label
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* When *BODY is equal to X or X is directly referenced by *BODY    return nonzero, thus FOR_EACH_RTX stops traversing and returns nonzero    too, otherwise FOR_EACH_RTX continues traversing *BODY.  */
end_comment

begin_function
specifier|static
name|int
name|rtx_referenced_p_1
parameter_list|(
name|rtx
modifier|*
name|body
parameter_list|,
name|void
modifier|*
name|x
parameter_list|)
block|{
name|rtx
name|y
init|=
operator|(
name|rtx
operator|)
name|x
decl_stmt|;
if|if
condition|(
operator|*
name|body
operator|==
name|NULL_RTX
condition|)
return|return
name|y
operator|==
name|NULL_RTX
return|;
comment|/* Return true if a label_ref *BODY refers to label Y.  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|body
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|LABEL_P
argument_list|(
name|y
argument_list|)
condition|)
return|return
name|XEXP
argument_list|(
operator|*
name|body
argument_list|,
literal|0
argument_list|)
operator|==
name|y
return|;
comment|/* If *BODY is a reference to pool constant traverse the constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|body
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
operator|*
name|body
argument_list|)
condition|)
return|return
name|rtx_referenced_p
argument_list|(
name|y
argument_list|,
name|get_pool_constant
argument_list|(
operator|*
name|body
argument_list|)
argument_list|)
return|;
comment|/* By default, compare the RTL expressions.  */
return|return
name|rtx_equal_p
argument_list|(
operator|*
name|body
argument_list|,
name|y
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if X is referenced in BODY.  */
end_comment

begin_function
name|int
name|rtx_referenced_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|body
parameter_list|)
block|{
return|return
name|for_each_rtx
argument_list|(
operator|&
name|body
argument_list|,
name|rtx_referenced_p_1
argument_list|,
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If INSN is a tablejump return true and store the label (before jump table) to    *LABELP and the jump table to *TABLEP.  LABELP and TABLEP may be NULL.  */
end_comment

begin_function
name|bool
name|tablejump_p
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
modifier|*
name|labelp
parameter_list|,
name|rtx
modifier|*
name|tablep
parameter_list|)
block|{
name|rtx
name|label
decl_stmt|,
name|table
decl_stmt|;
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|label
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
operator|(
name|table
operator|=
name|next_active_insn
argument_list|(
name|label
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
name|JUMP_P
argument_list|(
name|table
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|table
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|table
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
block|{
if|if
condition|(
name|labelp
condition|)
operator|*
name|labelp
operator|=
name|label
expr_stmt|;
if|if
condition|(
name|tablep
condition|)
operator|*
name|tablep
operator|=
name|table
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of computed_jump_p, return 1 if X contains a REG or MEM or    constant that is not in the constant pool and not in the condition    of an IF_THEN_ELSE.  */
end_comment

begin_function
specifier|static
name|int
name|computed_jump_p_1
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|PC
case|:
return|return
literal|0
return|;
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|REG
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
return|return
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|IF_THEN_ELSE
case|:
return|return
operator|(
name|computed_jump_p_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|computed_jump_p_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|)
return|;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|computed_jump_p_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|computed_jump_p_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if INSN is an indirect jump (aka computed jump).     Tablejumps and casesi insns are not considered indirect jumps;    we can recognize them by a (use (label_ref)).  */
end_comment

begin_function
name|int
name|computed_jump_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LABEL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|has_use_labelref
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
condition|)
name|has_use_labelref
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|has_use_labelref
condition|)
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|computed_jump_p_1
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|computed_jump_p_1
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Optimized loop of for_each_rtx, trying to avoid useless recursive    calls.  Processes the subexpressions of EXP and passes them to F.  */
end_comment

begin_function
specifier|static
name|int
name|for_each_rtx_1
parameter_list|(
name|rtx
name|exp
parameter_list|,
name|int
name|n
parameter_list|,
name|rtx_function
name|f
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|result
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
init|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|x
decl_stmt|;
for|for
control|(
init|;
name|format
index|[
name|n
index|]
operator|!=
literal|'\0'
condition|;
name|n
operator|++
control|)
block|{
switch|switch
condition|(
name|format
index|[
name|n
index|]
condition|)
block|{
case|case
literal|'e'
case|:
comment|/* Call F on X.  */
name|x
operator|=
operator|&
name|XEXP
argument_list|(
name|exp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|result
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
name|x
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
comment|/* Do not traverse sub-expressions.  */
continue|continue;
elseif|else
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
comment|/* Stop the traversal.  */
return|return
name|result
return|;
if|if
condition|(
operator|*
name|x
operator|==
name|NULL_RTX
condition|)
comment|/* There are no sub-expressions.  */
continue|continue;
name|i
operator|=
name|non_rtx_starting_operands
index|[
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|result
operator|=
name|for_each_rtx_1
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
return|return
name|result
return|;
block|}
break|break;
case|case
literal|'V'
case|:
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|exp
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|exp
argument_list|,
name|n
argument_list|)
condition|;
operator|++
name|j
control|)
block|{
comment|/* Call F on X.  */
name|x
operator|=
operator|&
name|XVECEXP
argument_list|(
name|exp
argument_list|,
name|n
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|result
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
name|x
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
comment|/* Do not traverse sub-expressions.  */
continue|continue;
elseif|else
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
comment|/* Stop the traversal.  */
return|return
name|result
return|;
if|if
condition|(
operator|*
name|x
operator|==
name|NULL_RTX
condition|)
comment|/* There are no sub-expressions.  */
continue|continue;
name|i
operator|=
name|non_rtx_starting_operands
index|[
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|result
operator|=
name|for_each_rtx_1
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
return|return
name|result
return|;
block|}
block|}
break|break;
default|default:
comment|/* Nothing to do.  */
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Traverse X via depth-first search, calling F for each    sub-expression (including X itself).  F is also passed the DATA.    If F returns -1, do not traverse sub-expressions, but continue    traversing the rest of the tree.  If F ever returns any other    nonzero value, stop the traversal, and return the value returned    by F.  Otherwise, return 0.  This function does not traverse inside    tree structure that contains RTX_EXPRs, or into sub-expressions    whose format code is `0' since it is not known whether or not those    codes are actually RTL.     This routine is very general, and could (should?) be used to    implement many of the other routines in this file.  */
end_comment

begin_function
name|int
name|for_each_rtx
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|rtx_function
name|f
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Call F on X.  */
name|result
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
name|x
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
comment|/* Do not traverse sub-expressions.  */
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
comment|/* Stop the traversal.  */
return|return
name|result
return|;
if|if
condition|(
operator|*
name|x
operator|==
name|NULL_RTX
condition|)
comment|/* There are no sub-expressions.  */
return|return
literal|0
return|;
name|i
operator|=
name|non_rtx_starting_operands
index|[
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|for_each_rtx_1
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Searches X for any reference to REGNO, returning the rtx of the    reference found if any.  Otherwise, returns NULL_RTX.  */
end_comment

begin_function
name|rtx
name|regno_use_in
parameter_list|(
name|unsigned
name|int
name|regno
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|regno
condition|)
return|return
name|x
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
operator|(
name|tem
operator|=
name|regno_use_in
argument_list|(
name|regno
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|tem
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
operator|(
name|tem
operator|=
name|regno_use_in
argument_list|(
name|regno
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|tem
return|;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Return a value indicating whether OP, an operand of a commutative    operation, is preferred as the first or second operand.  The higher    the value, the stronger the preference for being the first operand.    We use negative values to indicate a preference for the first operand    and positive values for the second operand.  */
end_comment

begin_function
name|int
name|commutative_operand_precedence
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
comment|/* Constants always come the second operand.  Prefer "nice" constants.  */
if|if
condition|(
name|code
operator|==
name|CONST_INT
condition|)
return|return
operator|-
literal|7
return|;
if|if
condition|(
name|code
operator|==
name|CONST_DOUBLE
condition|)
return|return
operator|-
literal|6
return|;
name|op
operator|=
name|avoid_constant_pool_reference
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|RTX_CONST_OBJ
case|:
if|if
condition|(
name|code
operator|==
name|CONST_INT
condition|)
return|return
operator|-
literal|5
return|;
if|if
condition|(
name|code
operator|==
name|CONST_DOUBLE
condition|)
return|return
operator|-
literal|4
return|;
return|return
operator|-
literal|3
return|;
case|case
name|RTX_EXTRA
case|:
comment|/* SUBREGs of objects should come second.  */
if|if
condition|(
name|code
operator|==
name|SUBREG
operator|&&
name|OBJECT_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|2
return|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
comment|/* As for RTX_CONST_OBJ.  */
return|return
operator|-
literal|3
return|;
case|case
name|RTX_OBJ
case|:
comment|/* Complex expressions should be the first, so decrease priority          of objects.  */
return|return
operator|-
literal|1
return|;
case|case
name|RTX_COMM_ARITH
case|:
comment|/* Prefer operands that are themselves commutative to be first.          This helps to make things linear.  In particular,          (and (and (reg) (reg)) (not (reg))) is canonical.  */
return|return
literal|4
return|;
case|case
name|RTX_BIN_ARITH
case|:
comment|/* If only one operand is a binary expression, it will be the first          operand.  In particular,  (plus (minus (reg) (reg)) (neg (reg)))          is canonical, although it will usually be further simplified.  */
return|return
literal|2
return|;
case|case
name|RTX_UNARY
case|:
comment|/* Then prefer NEG and NOT.  */
if|if
condition|(
name|code
operator|==
name|NEG
operator|||
name|code
operator|==
name|NOT
condition|)
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 iff it is necessary to swap operands of commutative operation    in order to canonicalize expression.  */
end_comment

begin_function
name|int
name|swap_commutative_operands_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
return|return
operator|(
name|commutative_operand_precedence
argument_list|(
name|x
argument_list|)
operator|<
name|commutative_operand_precedence
argument_list|(
name|y
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X is an autoincrement side effect and the register is    not the stack pointer.  */
end_comment

begin_function
name|int
name|auto_inc_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|PRE_INC
case|:
case|case
name|POST_INC
case|:
case|case
name|PRE_DEC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_MODIFY
case|:
case|case
name|POST_MODIFY
case|:
comment|/* There are no REG_INC notes for SP.  */
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
name|stack_pointer_rtx
condition|)
return|return
literal|1
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if IN contains a piece of rtl that has the address LOC.  */
end_comment

begin_function
name|int
name|loc_mentioned_in_p
parameter_list|(
name|rtx
modifier|*
name|loc
parameter_list|,
name|rtx
name|in
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|in
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|loc
operator|==
operator|&
name|in
operator|->
name|u
operator|.
name|fld
index|[
name|i
index|]
operator|.
name|rt_rtx
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|loc_mentioned_in_p
argument_list|(
name|loc
argument_list|,
name|XEXP
argument_list|(
name|in
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|in
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|loc_mentioned_in_p
argument_list|(
name|loc
argument_list|,
name|XVECEXP
argument_list|(
name|in
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Helper function for subreg_lsb.  Given a subreg's OUTER_MODE, INNER_MODE,    and SUBREG_BYTE, return the bit offset where the subreg begins    (counting from the least significant bit of the operand).  */
end_comment

begin_function
name|unsigned
name|int
name|subreg_lsb_1
parameter_list|(
name|enum
name|machine_mode
name|outer_mode
parameter_list|,
name|enum
name|machine_mode
name|inner_mode
parameter_list|,
name|unsigned
name|int
name|subreg_byte
parameter_list|)
block|{
name|unsigned
name|int
name|bitpos
decl_stmt|;
name|unsigned
name|int
name|byte
decl_stmt|;
name|unsigned
name|int
name|word
decl_stmt|;
comment|/* A paradoxical subreg begins at bit position 0.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|outer_mode
argument_list|)
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
operator|!=
name|BYTES_BIG_ENDIAN
condition|)
comment|/* If the subreg crosses a word boundary ensure that        it also begins and ends on a word boundary.  */
name|gcc_assert
argument_list|(
operator|!
operator|(
operator|(
name|subreg_byte
operator|%
name|UNITS_PER_WORD
operator|+
name|GET_MODE_SIZE
argument_list|(
name|outer_mode
argument_list|)
operator|)
operator|>
name|UNITS_PER_WORD
operator|&&
operator|(
name|subreg_byte
operator|%
name|UNITS_PER_WORD
operator|||
name|GET_MODE_SIZE
argument_list|(
name|outer_mode
argument_list|)
operator|%
name|UNITS_PER_WORD
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|word
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|inner_mode
argument_list|)
operator|-
operator|(
name|subreg_byte
operator|+
name|GET_MODE_SIZE
argument_list|(
name|outer_mode
argument_list|)
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
else|else
name|word
operator|=
name|subreg_byte
operator|/
name|UNITS_PER_WORD
expr_stmt|;
name|bitpos
operator|=
name|word
operator|*
name|BITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|byte
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|inner_mode
argument_list|)
operator|-
operator|(
name|subreg_byte
operator|+
name|GET_MODE_SIZE
argument_list|(
name|outer_mode
argument_list|)
operator|)
operator|)
operator|%
name|UNITS_PER_WORD
expr_stmt|;
else|else
name|byte
operator|=
name|subreg_byte
operator|%
name|UNITS_PER_WORD
expr_stmt|;
name|bitpos
operator|+=
name|byte
operator|*
name|BITS_PER_UNIT
expr_stmt|;
return|return
name|bitpos
return|;
block|}
end_function

begin_comment
comment|/* Given a subreg X, return the bit offset where the subreg begins    (counting from the least significant bit of the reg).  */
end_comment

begin_function
name|unsigned
name|int
name|subreg_lsb
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
return|return
name|subreg_lsb_1
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This function returns the regno offset of a subreg expression.    xregno - A regno of an inner hard subreg_reg (or what will become one).    xmode  - The mode of xregno.    offset - The byte offset.    ymode  - The mode of a top level SUBREG (or what may become one).    RETURN - The regno offset which would be used.  */
end_comment

begin_function
name|unsigned
name|int
name|subreg_regno_offset
parameter_list|(
name|unsigned
name|int
name|xregno
parameter_list|,
name|enum
name|machine_mode
name|xmode
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|,
name|enum
name|machine_mode
name|ymode
parameter_list|)
block|{
name|int
name|nregs_xmode
decl_stmt|,
name|nregs_ymode
decl_stmt|;
name|int
name|mode_multiple
decl_stmt|,
name|nregs_multiple
decl_stmt|;
name|int
name|y_offset
decl_stmt|;
name|gcc_assert
argument_list|(
name|xregno
operator|<
name|FIRST_PSEUDO_REGISTER
argument_list|)
expr_stmt|;
comment|/* Adjust nregs_xmode to allow for 'holes'.  */
if|if
condition|(
name|HARD_REGNO_NREGS_HAS_PADDING
argument_list|(
name|xregno
argument_list|,
name|xmode
argument_list|)
condition|)
name|nregs_xmode
operator|=
name|HARD_REGNO_NREGS_WITH_PADDING
argument_list|(
name|xregno
argument_list|,
name|xmode
argument_list|)
expr_stmt|;
else|else
name|nregs_xmode
operator|=
name|hard_regno_nregs
index|[
name|xregno
index|]
index|[
name|xmode
index|]
expr_stmt|;
name|nregs_ymode
operator|=
name|hard_regno_nregs
index|[
name|xregno
index|]
index|[
name|ymode
index|]
expr_stmt|;
comment|/* If this is a big endian paradoxical subreg, which uses more actual      hard registers than the original register, we must return a negative      offset so that we find the proper highpart of the register.  */
if|if
condition|(
name|offset
operator|==
literal|0
operator|&&
name|nregs_ymode
operator|>
name|nregs_xmode
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|ymode
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|?
name|WORDS_BIG_ENDIAN
else|:
name|BYTES_BIG_ENDIAN
operator|)
condition|)
return|return
name|nregs_xmode
operator|-
name|nregs_ymode
return|;
if|if
condition|(
name|offset
operator|==
literal|0
operator|||
name|nregs_xmode
operator|==
name|nregs_ymode
condition|)
return|return
literal|0
return|;
comment|/* Size of ymode must not be greater than the size of xmode.  */
name|mode_multiple
operator|=
name|GET_MODE_SIZE
argument_list|(
name|xmode
argument_list|)
operator|/
name|GET_MODE_SIZE
argument_list|(
name|ymode
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|mode_multiple
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|y_offset
operator|=
name|offset
operator|/
name|GET_MODE_SIZE
argument_list|(
name|ymode
argument_list|)
expr_stmt|;
name|nregs_multiple
operator|=
name|nregs_xmode
operator|/
name|nregs_ymode
expr_stmt|;
return|return
operator|(
name|y_offset
operator|/
operator|(
name|mode_multiple
operator|/
name|nregs_multiple
operator|)
operator|)
operator|*
name|nregs_ymode
return|;
block|}
end_function

begin_comment
comment|/* This function returns true when the offset is representable via    subreg_offset in the given regno.    xregno - A regno of an inner hard subreg_reg (or what will become one).    xmode  - The mode of xregno.    offset - The byte offset.    ymode  - The mode of a top level SUBREG (or what may become one).    RETURN - Whether the offset is representable.  */
end_comment

begin_function
name|bool
name|subreg_offset_representable_p
parameter_list|(
name|unsigned
name|int
name|xregno
parameter_list|,
name|enum
name|machine_mode
name|xmode
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|,
name|enum
name|machine_mode
name|ymode
parameter_list|)
block|{
name|int
name|nregs_xmode
decl_stmt|,
name|nregs_ymode
decl_stmt|;
name|int
name|mode_multiple
decl_stmt|,
name|nregs_multiple
decl_stmt|;
name|int
name|y_offset
decl_stmt|;
name|int
name|regsize_xmode
decl_stmt|,
name|regsize_ymode
decl_stmt|;
name|gcc_assert
argument_list|(
name|xregno
operator|<
name|FIRST_PSEUDO_REGISTER
argument_list|)
expr_stmt|;
comment|/* If there are holes in a non-scalar mode in registers, we expect      that it is made up of its units concatenated together.  */
if|if
condition|(
name|HARD_REGNO_NREGS_HAS_PADDING
argument_list|(
name|xregno
argument_list|,
name|xmode
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|xmode_unit
decl_stmt|;
name|nregs_xmode
operator|=
name|HARD_REGNO_NREGS_WITH_PADDING
argument_list|(
name|xregno
argument_list|,
name|xmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_INNER
argument_list|(
name|xmode
argument_list|)
operator|==
name|VOIDmode
condition|)
name|xmode_unit
operator|=
name|xmode
expr_stmt|;
else|else
name|xmode_unit
operator|=
name|GET_MODE_INNER
argument_list|(
name|xmode
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|HARD_REGNO_NREGS_HAS_PADDING
argument_list|(
name|xregno
argument_list|,
name|xmode_unit
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|nregs_xmode
operator|==
operator|(
name|GET_MODE_NUNITS
argument_list|(
name|xmode
argument_list|)
operator|*
name|HARD_REGNO_NREGS_WITH_PADDING
argument_list|(
name|xregno
argument_list|,
name|xmode_unit
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|hard_regno_nregs
index|[
name|xregno
index|]
index|[
name|xmode
index|]
operator|==
operator|(
name|hard_regno_nregs
index|[
name|xregno
index|]
index|[
name|xmode_unit
index|]
operator|*
name|GET_MODE_NUNITS
argument_list|(
name|xmode
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* You can only ask for a SUBREG of a value with holes in the middle 	 if you don't cross the holes.  (Such a SUBREG should be done by 	 picking a different register class, or doing it in memory if 	 necessary.)  An example of a value with holes is XCmode on 32-bit 	 x86 with -m128bit-long-double; it's represented in 6 32-bit registers, 	 3 for each part, but in memory it's two 128-bit parts.   	 Padding is assumed to be at the end (not necessarily the 'high part') 	 of each unit.  */
if|if
condition|(
operator|(
name|offset
operator|/
name|GET_MODE_SIZE
argument_list|(
name|xmode_unit
argument_list|)
operator|+
literal|1
operator|<
name|GET_MODE_NUNITS
argument_list|(
name|xmode
argument_list|)
operator|)
operator|&&
operator|(
name|offset
operator|/
name|GET_MODE_SIZE
argument_list|(
name|xmode_unit
argument_list|)
operator|!=
operator|(
operator|(
name|offset
operator|+
name|GET_MODE_SIZE
argument_list|(
name|ymode
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|GET_MODE_SIZE
argument_list|(
name|xmode_unit
argument_list|)
operator|)
operator|)
condition|)
return|return
name|false
return|;
block|}
else|else
name|nregs_xmode
operator|=
name|hard_regno_nregs
index|[
name|xregno
index|]
index|[
name|xmode
index|]
expr_stmt|;
name|nregs_ymode
operator|=
name|hard_regno_nregs
index|[
name|xregno
index|]
index|[
name|ymode
index|]
expr_stmt|;
comment|/* Paradoxical subregs are otherwise valid.  */
if|if
condition|(
name|offset
operator|==
literal|0
operator|&&
name|nregs_ymode
operator|>
name|nregs_xmode
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|ymode
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|?
name|WORDS_BIG_ENDIAN
else|:
name|BYTES_BIG_ENDIAN
operator|)
condition|)
return|return
name|true
return|;
comment|/* If registers store different numbers of bits in the different      modes, we cannot generally form this subreg.  */
name|regsize_xmode
operator|=
name|GET_MODE_SIZE
argument_list|(
name|xmode
argument_list|)
operator|/
name|nregs_xmode
expr_stmt|;
name|regsize_ymode
operator|=
name|GET_MODE_SIZE
argument_list|(
name|ymode
argument_list|)
operator|/
name|nregs_ymode
expr_stmt|;
if|if
condition|(
name|regsize_xmode
operator|>
name|regsize_ymode
operator|&&
name|nregs_ymode
operator|>
literal|1
condition|)
return|return
name|false
return|;
if|if
condition|(
name|regsize_ymode
operator|>
name|regsize_xmode
operator|&&
name|nregs_xmode
operator|>
literal|1
condition|)
return|return
name|false
return|;
comment|/* Lowpart subregs are otherwise valid.  */
if|if
condition|(
name|offset
operator|==
name|subreg_lowpart_offset
argument_list|(
name|ymode
argument_list|,
name|xmode
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* This should always pass, otherwise we don't know how to verify      the constraint.  These conditions may be relaxed but      subreg_regno_offset would need to be redesigned.  */
name|gcc_assert
argument_list|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|xmode
argument_list|)
operator|%
name|GET_MODE_SIZE
argument_list|(
name|ymode
argument_list|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|nregs_xmode
operator|%
name|nregs_ymode
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* The XMODE value can be seen as a vector of NREGS_XMODE      values.  The subreg must represent a lowpart of given field.      Compute what field it is.  */
name|offset
operator|-=
name|subreg_lowpart_offset
argument_list|(
name|ymode
argument_list|,
name|mode_for_size
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|xmode
argument_list|)
operator|/
name|nregs_xmode
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Size of ymode must not be greater than the size of xmode.  */
name|mode_multiple
operator|=
name|GET_MODE_SIZE
argument_list|(
name|xmode
argument_list|)
operator|/
name|GET_MODE_SIZE
argument_list|(
name|ymode
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|mode_multiple
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|y_offset
operator|=
name|offset
operator|/
name|GET_MODE_SIZE
argument_list|(
name|ymode
argument_list|)
expr_stmt|;
name|nregs_multiple
operator|=
name|nregs_xmode
operator|/
name|nregs_ymode
expr_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|offset
operator|%
name|GET_MODE_SIZE
argument_list|(
name|ymode
argument_list|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|mode_multiple
operator|%
name|nregs_multiple
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
operator|(
name|y_offset
operator|%
operator|(
name|mode_multiple
operator|/
name|nregs_multiple
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the final regno that a subreg expression refers to.  */
end_comment

begin_function
name|unsigned
name|int
name|subreg_regno
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|unsigned
name|int
name|ret
decl_stmt|;
name|rtx
name|subreg
init|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|subreg
argument_list|)
decl_stmt|;
name|ret
operator|=
name|regno
operator|+
name|subreg_regno_offset
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|subreg
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_struct
struct|struct
name|parms_set_data
block|{
name|int
name|nregs
decl_stmt|;
name|HARD_REG_SET
name|regs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Helper function for noticing stores to parameter registers.  */
end_comment

begin_function
specifier|static
name|void
name|parms_set
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|pat
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|parms_set_data
modifier|*
name|d
init|=
name|data
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|d
operator|->
name|regs
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
name|d
operator|->
name|regs
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|nregs
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Look backward for first parameter to be loaded.    Note that loads of all parameters will not necessarily be    found if CSE has eliminated some of them (e.g., an argument    to the outer function is passed down as a parameter).    Do not skip BOUNDARY.  */
end_comment

begin_function
name|rtx
name|find_first_parameter_load
parameter_list|(
name|rtx
name|call_insn
parameter_list|,
name|rtx
name|boundary
parameter_list|)
block|{
name|struct
name|parms_set_data
name|parm
decl_stmt|;
name|rtx
name|p
decl_stmt|,
name|before
decl_stmt|,
name|first_set
decl_stmt|;
comment|/* Since different machines initialize their parameter registers      in different orders, assume nothing.  Collect the set of all      parameter registers.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|parm
operator|.
name|regs
argument_list|)
expr_stmt|;
name|parm
operator|.
name|nregs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call_insn
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|XEXP
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
argument_list|)
expr_stmt|;
comment|/* We only care about registers which can hold function 	   arguments.  */
if|if
condition|(
operator|!
name|FUNCTION_ARG_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
continue|continue;
name|SET_HARD_REG_BIT
argument_list|(
name|parm
operator|.
name|regs
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|parm
operator|.
name|nregs
operator|++
expr_stmt|;
block|}
name|before
operator|=
name|call_insn
expr_stmt|;
name|first_set
operator|=
name|call_insn
expr_stmt|;
comment|/* Search backward for the first set of a register in this set.  */
while|while
condition|(
name|parm
operator|.
name|nregs
operator|&&
name|before
operator|!=
name|boundary
condition|)
block|{
name|before
operator|=
name|PREV_INSN
argument_list|(
name|before
argument_list|)
expr_stmt|;
comment|/* It is possible that some loads got CSEed from one call to          another.  Stop in that case.  */
if|if
condition|(
name|CALL_P
argument_list|(
name|before
argument_list|)
condition|)
break|break;
comment|/* Our caller needs either ensure that we will find all sets          (in case code has not been optimized yet), or take care          for possible labels in a way by setting boundary to preceding          CODE_LABEL.  */
if|if
condition|(
name|LABEL_P
argument_list|(
name|before
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|before
operator|==
name|boundary
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|INSN_P
argument_list|(
name|before
argument_list|)
condition|)
block|{
name|int
name|nregs_old
init|=
name|parm
operator|.
name|nregs
decl_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|before
argument_list|)
argument_list|,
name|parms_set
argument_list|,
operator|&
name|parm
argument_list|)
expr_stmt|;
comment|/* If we found something that did not set a parameter reg, 	     we're done.  Do not keep going, as that might result 	     in hoisting an insn before the setting of a pseudo 	     that is used by the hoisted insn. */
if|if
condition|(
name|nregs_old
operator|!=
name|parm
operator|.
name|nregs
condition|)
name|first_set
operator|=
name|before
expr_stmt|;
else|else
break|break;
block|}
block|}
return|return
name|first_set
return|;
block|}
end_function

begin_comment
comment|/* Return true if we should avoid inserting code between INSN and preceding    call instruction.  */
end_comment

begin_function
name|bool
name|keep_with_call_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|set
decl_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|fixed_regs
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|&&
name|general_operand
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|REG_P
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|FUNCTION_VALUE_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|true
return|;
comment|/* There may be a stack pop just after the call and before the store 	 of the return register.  Search for the actual store when deciding 	 if we can break or not.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|stack_pointer_rtx
condition|)
block|{
name|rtx
name|i2
init|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|i2
operator|&&
name|keep_with_call_p
argument_list|(
name|i2
argument_list|)
condition|)
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if LABEL is a target of JUMP_INSN.  This applies only    to non-complex jumps.  That is, direct unconditional, conditional,    and tablejumps, but not computed jumps or returns.  It also does    not apply to the fallthru case of a conditional jump.  */
end_comment

begin_function
name|bool
name|label_is_jump_target_p
parameter_list|(
name|rtx
name|label
parameter_list|,
name|rtx
name|jump_insn
parameter_list|)
block|{
name|rtx
name|tmp
init|=
name|JUMP_LABEL
argument_list|(
name|jump_insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|label
operator|==
name|tmp
condition|)
return|return
name|true
return|;
if|if
condition|(
name|tablejump_p
argument_list|(
name|jump_insn
argument_list|,
name|NULL
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
block|{
name|rtvec
name|vec
init|=
name|XVEC
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|veclen
init|=
name|GET_NUM_ELEM
argument_list|(
name|vec
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|veclen
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|label
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an estimate of the cost of computing rtx X.    One use is in cse, to decide which expression to keep in the hash table.    Another is in rtl generation, to pick the cheapest way to multiply.    Other uses like the latter are expected in the future.  */
end_comment

begin_function
name|int
name|rtx_cost
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|rtx_code
name|outer_code
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|total
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Compute the default costs of certain things.      Note that targetm.rtx_costs can override the defaults.  */
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MULT
case|:
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
case|case
name|UDIV
case|:
case|case
name|MOD
case|:
case|case
name|UMOD
case|:
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|7
argument_list|)
expr_stmt|;
break|break;
case|case
name|USE
case|:
comment|/* Used in combine.c as a marker.  */
name|total
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
return|return
literal|0
return|;
case|case
name|SUBREG
case|:
name|total
operator|=
literal|0
expr_stmt|;
comment|/* If we can't tie these modes, make this expensive.  The larger 	 the mode, the more expensive it is.  */
if|if
condition|(
operator|!
name|MODES_TIEABLE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|COSTS_N_INSNS
argument_list|(
literal|2
operator|+
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|/
name|UNITS_PER_WORD
argument_list|)
return|;
break|break;
default|default:
if|if
condition|(
name|targetm
operator|.
name|rtx_costs
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|outer_code
argument_list|,
operator|&
name|total
argument_list|)
condition|)
return|return
name|total
return|;
break|break;
block|}
comment|/* Sum the costs of the sub-rtx's, plus cost of this operation,      which is already in total.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|total
operator|+=
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|total
operator|+=
name|rtx_cost
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
name|total
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return cost of address expression X.    Expect that X is properly formed address reference.  */
end_comment

begin_function
name|int
name|address_cost
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
comment|/* We may be asked for cost of various unusual addresses, such as operands      of push instruction.  It is not worthwhile to complicate writing      of the target hook by such cases.  */
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
condition|)
return|return
literal|1000
return|;
return|return
name|targetm
operator|.
name|address_cost
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If the target doesn't override, compute the cost as with arithmetic.  */
end_comment

begin_function
name|int
name|default_address_cost
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
return|return
name|rtx_cost
argument_list|(
name|x
argument_list|,
name|MEM
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|unsigned
name|HOST_WIDE_INT
name|nonzero_bits
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|cached_nonzero_bits
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|num_sign_bit_copies
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|cached_num_sign_bit_copies
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The function cached_nonzero_bits is a wrapper around nonzero_bits1.    It avoids exponential behavior in nonzero_bits1 when X has    identical subexpressions on the first or the second level.  */
end_comment

begin_function
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|cached_nonzero_bits
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|known_x
parameter_list|,
name|enum
name|machine_mode
name|known_mode
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|known_ret
parameter_list|)
block|{
if|if
condition|(
name|x
operator|==
name|known_x
operator|&&
name|mode
operator|==
name|known_mode
condition|)
return|return
name|known_ret
return|;
comment|/* Try to find identical subexpressions.  If found call      nonzero_bits1 on X with the subexpressions as KNOWN_X and the      precomputed value for the subexpression as KNOWN_RET.  */
if|if
condition|(
name|ARITHMETIC_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|rtx
name|x0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|x1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Check the first level.  */
if|if
condition|(
name|x0
operator|==
name|x1
condition|)
return|return
name|nonzero_bits1
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|x0
argument_list|,
name|mode
argument_list|,
name|cached_nonzero_bits
argument_list|(
name|x0
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
argument_list|)
return|;
comment|/* Check the second level.  */
if|if
condition|(
name|ARITHMETIC_P
argument_list|(
name|x0
argument_list|)
operator|&&
operator|(
name|x1
operator|==
name|XEXP
argument_list|(
name|x0
argument_list|,
literal|0
argument_list|)
operator|||
name|x1
operator|==
name|XEXP
argument_list|(
name|x0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
name|nonzero_bits1
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|x1
argument_list|,
name|mode
argument_list|,
name|cached_nonzero_bits
argument_list|(
name|x1
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|ARITHMETIC_P
argument_list|(
name|x1
argument_list|)
operator|&&
operator|(
name|x0
operator|==
name|XEXP
argument_list|(
name|x1
argument_list|,
literal|0
argument_list|)
operator|||
name|x0
operator|==
name|XEXP
argument_list|(
name|x1
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
name|nonzero_bits1
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|x0
argument_list|,
name|mode
argument_list|,
name|cached_nonzero_bits
argument_list|(
name|x0
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
argument_list|)
return|;
block|}
return|return
name|nonzero_bits1
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* We let num_sign_bit_copies recur into nonzero_bits as that is useful.    We don't let nonzero_bits recur into num_sign_bit_copies, because that    is less useful.  We can't allow both, because that results in exponential    run time recursion.  There is a nullstone testcase that triggered    this.  This macro avoids accidental uses of num_sign_bit_copies.  */
end_comment

begin_define
define|#
directive|define
name|cached_num_sign_bit_copies
value|sorry_i_am_preventing_exponential_behavior
end_define

begin_comment
comment|/* Given an expression, X, compute which bits in X can be nonzero.    We don't care about bits outside of those defined in MODE.     For most X this is simply GET_MODE_MASK (GET_MODE (MODE)), but if X is    an arithmetic operation, we can do better.  */
end_comment

begin_function
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|nonzero_bits1
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|known_x
parameter_list|,
name|enum
name|machine_mode
name|known_mode
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|known_ret
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|nonzero
init|=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|inner_nz
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|unsigned
name|int
name|mode_width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
comment|/* For floating-point values, assume all bits are needed.  */
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|||
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|nonzero
return|;
comment|/* If X is wider than MODE, use its mode instead.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|mode_width
condition|)
block|{
name|mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|nonzero
operator|=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|mode_width
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode_width
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
comment|/* Our only callers in this case look for single bit values.  So        just return the mode mask.  Those tests will then be false.  */
return|return
name|nonzero
return|;
ifndef|#
directive|ifndef
name|WORD_REGISTER_OPERATIONS
comment|/* If MODE is wider than X, but both are a single word for both the host      and target machines, we can compute this from which bits of the      object might be nonzero in its own mode, taking into account the fact      that on many CISC machines, accessing an object in a wider mode      causes the high-order bits to become undefined.  So they are      not known to be zero.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|mode
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<=
name|BITS_PER_WORD
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|nonzero
operator|&=
name|cached_nonzero_bits
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
name|nonzero
operator||=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|nonzero
return|;
block|}
endif|#
directive|endif
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
if|#
directive|if
name|defined
argument_list|(
name|POINTERS_EXTEND_UNSIGNED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_ptr_extend
argument_list|)
comment|/* If pointers extend unsigned and this is a pointer in Pmode, say that 	 all the bits above ptr_mode are known to be zero.  */
if|if
condition|(
name|POINTERS_EXTEND_UNSIGNED
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|Pmode
operator|&&
name|REG_POINTER
argument_list|(
name|x
argument_list|)
condition|)
name|nonzero
operator|&=
name|GET_MODE_MASK
argument_list|(
name|ptr_mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Include declared information about alignment of pointers.  */
comment|/* ??? We don't properly preserve REG_POINTER changes across 	 pointer-to-integer casts, so we can't trust it except for 	 things that we know must be pointers.  See execute/960116-1.c.  */
if|if
condition|(
operator|(
name|x
operator|==
name|stack_pointer_rtx
operator|||
name|x
operator|==
name|frame_pointer_rtx
operator|||
name|x
operator|==
name|arg_pointer_rtx
operator|)
operator|&&
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|alignment
init|=
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
comment|/* If PUSH_ROUNDING is defined, it is possible for the 	     stack to be momentarily aligned only to that amount, 	     so we pick the least alignment.  */
if|if
condition|(
name|x
operator|==
name|stack_pointer_rtx
operator|&&
name|PUSH_ARGS
condition|)
name|alignment
operator|=
name|MIN
argument_list|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|PUSH_ROUNDING
argument_list|(
literal|1
argument_list|)
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nonzero
operator|&=
operator|~
operator|(
name|alignment
operator|-
literal|1
operator|)
expr_stmt|;
block|}
block|{
name|unsigned
name|HOST_WIDE_INT
name|nonzero_for_hook
init|=
name|nonzero
decl_stmt|;
name|rtx
name|new
init|=
name|rtl_hooks
operator|.
name|reg_nonzero_bits
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|,
operator|&
name|nonzero_for_hook
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
condition|)
name|nonzero_for_hook
operator|&=
name|cached_nonzero_bits
argument_list|(
name|new
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
return|return
name|nonzero_for_hook
return|;
block|}
case|case
name|CONST_INT
case|:
ifdef|#
directive|ifdef
name|SHORT_IMMEDIATES_SIGN_EXTEND
comment|/* If X is negative in MODE, sign-extend the value.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>
literal|0
operator|&&
name|mode_width
operator|<
name|BITS_PER_WORD
operator|&&
literal|0
operator|!=
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|mode_width
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
return|return
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator||
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|mode_width
operator|)
operator|)
return|;
endif|#
directive|endif
return|return
name|INTVAL
argument_list|(
name|x
argument_list|)
return|;
case|case
name|MEM
case|:
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
comment|/* In many, if not most, RISC machines, reading a byte from memory 	 zeros the rest of the register.  Noticing that fact saves a lot 	 of extra zero-extends.  */
if|if
condition|(
name|LOAD_EXTEND_OP
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTEND
condition|)
name|nonzero
operator|&=
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|UNEQ
case|:
case|case
name|LTGT
case|:
case|case
name|GT
case|:
case|case
name|GTU
case|:
case|case
name|UNGT
case|:
case|case
name|LT
case|:
case|case
name|LTU
case|:
case|case
name|UNLT
case|:
case|case
name|GE
case|:
case|case
name|GEU
case|:
case|case
name|UNGE
case|:
case|case
name|LE
case|:
case|case
name|LEU
case|:
case|case
name|UNLE
case|:
case|case
name|UNORDERED
case|:
case|case
name|ORDERED
case|:
comment|/* If this produces an integer result, we know which bits are set. 	 Code here used to clear bits outside the mode of X, but that is 	 now done above.  */
comment|/* Mind that MODE is the mode the caller wants to look at this  	 operation in, and not the actual operation mode.  We can wind  	 up with (subreg:DI (gt:V4HI x y)), and we don't have anything 	 that describes the results of a vector compare.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|mode_width
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
name|nonzero
operator|=
name|STORE_FLAG_VALUE
expr_stmt|;
break|break;
case|case
name|NEG
case|:
if|#
directive|if
literal|0
comment|/* Disabled to avoid exponential mutual recursion between nonzero_bits 	 and num_sign_bit_copies.  */
block|if (num_sign_bit_copies (XEXP (x, 0), GET_MODE (x)) 	  == GET_MODE_BITSIZE (GET_MODE (x))) 	nonzero = 1;
endif|#
directive|endif
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|mode_width
condition|)
name|nonzero
operator||=
operator|(
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|ABS
case|:
if|#
directive|if
literal|0
comment|/* Disabled to avoid exponential mutual recursion between nonzero_bits 	 and num_sign_bit_copies.  */
block|if (num_sign_bit_copies (XEXP (x, 0), GET_MODE (x)) 	  == GET_MODE_BITSIZE (GET_MODE (x))) 	nonzero = 1;
endif|#
directive|endif
break|break;
case|case
name|TRUNCATE
case|:
name|nonzero
operator|&=
operator|(
name|cached_nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|ZERO_EXTEND
case|:
name|nonzero
operator|&=
name|cached_nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|nonzero
operator|&=
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGN_EXTEND
case|:
comment|/* If the sign bit is known clear, this is the same as ZERO_EXTEND. 	 Otherwise, show all the bits in the outer mode but not the inner 	 may be nonzero.  */
name|inner_nz
operator|=
name|cached_nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
name|inner_nz
operator|&=
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner_nz
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|inner_nz
operator||=
operator|(
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
name|nonzero
operator|&=
name|inner_nz
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|nonzero
operator|&=
name|cached_nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
operator|&
name|cached_nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
break|break;
case|case
name|XOR
case|:
case|case
name|IOR
case|:
case|case
name|UMIN
case|:
case|case
name|UMAX
case|:
case|case
name|SMIN
case|:
case|case
name|SMAX
case|:
block|{
name|unsigned
name|HOST_WIDE_INT
name|nonzero0
init|=
name|cached_nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
decl_stmt|;
comment|/* Don't call nonzero_bits for the second time if it cannot change 	   anything.  */
if|if
condition|(
operator|(
name|nonzero
operator|&
name|nonzero0
operator|)
operator|!=
name|nonzero
condition|)
name|nonzero
operator|&=
name|nonzero0
operator||
name|cached_nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|MULT
case|:
case|case
name|DIV
case|:
case|case
name|UDIV
case|:
case|case
name|MOD
case|:
case|case
name|UMOD
case|:
comment|/* We can apply the rules of arithmetic to compute the number of 	 high- and low-order zero bits of these operations.  We start by 	 computing the width (position of the highest-order nonzero bit) 	 and the number of low-order zero bits for each value.  */
block|{
name|unsigned
name|HOST_WIDE_INT
name|nz0
init|=
name|cached_nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|nz1
init|=
name|cached_nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
decl_stmt|;
name|int
name|sign_index
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
decl_stmt|;
name|int
name|width0
init|=
name|floor_log2
argument_list|(
name|nz0
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|width1
init|=
name|floor_log2
argument_list|(
name|nz1
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|low0
init|=
name|floor_log2
argument_list|(
name|nz0
operator|&
operator|-
name|nz0
argument_list|)
decl_stmt|;
name|int
name|low1
init|=
name|floor_log2
argument_list|(
name|nz1
operator|&
operator|-
name|nz1
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|op0_maybe_minusp
init|=
operator|(
name|nz0
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|sign_index
operator|)
operator|)
decl_stmt|;
name|HOST_WIDE_INT
name|op1_maybe_minusp
init|=
operator|(
name|nz1
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|sign_index
operator|)
operator|)
decl_stmt|;
name|unsigned
name|int
name|result_width
init|=
name|mode_width
decl_stmt|;
name|int
name|result_low
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
name|result_width
operator|=
name|MAX
argument_list|(
name|width0
argument_list|,
name|width1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|result_low
operator|=
name|MIN
argument_list|(
name|low0
argument_list|,
name|low1
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|result_low
operator|=
name|MIN
argument_list|(
name|low0
argument_list|,
name|low1
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|result_width
operator|=
name|width0
operator|+
name|width1
expr_stmt|;
name|result_low
operator|=
name|low0
operator|+
name|low1
expr_stmt|;
break|break;
case|case
name|DIV
case|:
if|if
condition|(
name|width1
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|op0_maybe_minusp
operator|&&
operator|!
name|op1_maybe_minusp
condition|)
name|result_width
operator|=
name|width0
expr_stmt|;
break|break;
case|case
name|UDIV
case|:
if|if
condition|(
name|width1
operator|==
literal|0
condition|)
break|break;
name|result_width
operator|=
name|width0
expr_stmt|;
break|break;
case|case
name|MOD
case|:
if|if
condition|(
name|width1
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|op0_maybe_minusp
operator|&&
operator|!
name|op1_maybe_minusp
condition|)
name|result_width
operator|=
name|MIN
argument_list|(
name|width0
argument_list|,
name|width1
argument_list|)
expr_stmt|;
name|result_low
operator|=
name|MIN
argument_list|(
name|low0
argument_list|,
name|low1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMOD
case|:
if|if
condition|(
name|width1
operator|==
literal|0
condition|)
break|break;
name|result_width
operator|=
name|MIN
argument_list|(
name|width0
argument_list|,
name|width1
argument_list|)
expr_stmt|;
name|result_low
operator|=
name|MIN
argument_list|(
name|low0
argument_list|,
name|low1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|result_width
operator|<
name|mode_width
condition|)
name|nonzero
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|result_width
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|result_low
operator|>
literal|0
condition|)
name|nonzero
operator|&=
operator|~
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|result_low
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
comment|/* If pointers extend unsigned and this is an addition or subtraction 	   to a pointer in Pmode, all the bits above ptr_mode are known to be 	   zero.  */
if|if
condition|(
name|POINTERS_EXTEND_UNSIGNED
operator|>
literal|0
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|Pmode
operator|&&
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
operator|)
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|REG_POINTER
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|nonzero
operator|&=
name|GET_MODE_MASK
argument_list|(
name|ptr_mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
case|case
name|ZERO_EXTRACT
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|nonzero
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|SUBREG
case|:
comment|/* If this is a SUBREG formed for a promoted variable that has 	 been zero-extended, we know that at least the high-order bits 	 are zero, though others might be too.  */
if|if
condition|(
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|x
argument_list|)
operator|&&
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|x
argument_list|)
operator|>
literal|0
condition|)
name|nonzero
operator|=
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&
name|cached_nonzero_bits
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
comment|/* If the inner mode is a single word for both the host and target 	 machines, we can compute this from which bits of the inner 	 object might be nonzero.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|BITS_PER_WORD
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
condition|)
block|{
name|nonzero
operator|&=
name|cached_nonzero_bits
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|WORD_REGISTER_OPERATIONS
argument_list|)
operator|&&
name|defined
argument_list|(
name|LOAD_EXTEND_OP
argument_list|)
comment|/* If this is a typical RISC machine, we only have to worry 	     about the way loads are extended.  */
if|if
condition|(
operator|(
name|LOAD_EXTEND_OP
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
condition|?
operator|(
operator|(
operator|(
name|nonzero
operator|&
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|)
operator|!=
literal|0
operator|)
operator|)
else|:
name|LOAD_EXTEND_OP
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|ZERO_EXTEND
operator|)
operator|||
operator|!
name|MEM_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
endif|#
directive|endif
block|{
comment|/* On many CISC machines, accessing an object in a wider mode 		 causes the high-order bits to become undefined.  So they are 		 not known to be zero.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
condition|)
name|nonzero
operator||=
operator|(
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFT
case|:
case|case
name|ROTATE
case|:
comment|/* The nonzero bits are in two classes: any bits within MODE 	 that aren't in GET_MODE (x) are always significant.  The rest of the 	 nonzero bits are those that are significant in the operand of 	 the shift when shifted the appropriate number of bits.  This 	 shows that high-order bits are cleared by the right shift and 	 low-order bits by left shifts.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
decl_stmt|;
name|int
name|count
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|mode_mask
init|=
name|GET_MODE_MASK
argument_list|(
name|inner_mode
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|op_nonzero
init|=
name|cached_nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|inner
init|=
name|op_nonzero
operator|&
name|mode_mask
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|outer
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mode_width
operator|>
name|width
condition|)
name|outer
operator|=
operator|(
name|op_nonzero
operator|&
name|nonzero
operator|&
operator|~
name|mode_mask
operator|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|LSHIFTRT
condition|)
name|inner
operator|>>=
name|count
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|ASHIFTRT
condition|)
block|{
name|inner
operator|>>=
name|count
expr_stmt|;
comment|/* If the sign bit may have been nonzero before the shift, we 		 need to mark all the places it could have been copied to 		 by the shift as possibly nonzero.  */
if|if
condition|(
name|inner
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|-
name|count
operator|)
operator|)
condition|)
name|inner
operator||=
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|count
operator|)
operator|-
literal|1
operator|)
operator|<<
operator|(
name|width
operator|-
name|count
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|ASHIFT
condition|)
name|inner
operator|<<=
name|count
expr_stmt|;
else|else
name|inner
operator|=
operator|(
operator|(
name|inner
operator|<<
operator|(
name|count
operator|%
name|width
operator|)
operator||
operator|(
name|inner
operator|>>
operator|(
name|width
operator|-
operator|(
name|count
operator|%
name|width
operator|)
operator|)
operator|)
operator|)
operator|&
name|mode_mask
operator|)
expr_stmt|;
name|nonzero
operator|&=
operator|(
name|outer
operator||
name|inner
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|FFS
case|:
case|case
name|POPCOUNT
case|:
comment|/* This is at most the number of bits in the mode.  */
name|nonzero
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|2
operator|<<
operator|(
name|floor_log2
argument_list|(
name|mode_width
argument_list|)
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|CLZ
case|:
comment|/* If CLZ has a known value at zero, then the nonzero bits are 	 that value, plus the number of bits in the mode minus one.  */
if|if
condition|(
name|CLZ_DEFINED_VALUE_AT_ZERO
argument_list|(
name|mode
argument_list|,
name|nonzero
argument_list|)
condition|)
name|nonzero
operator||=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|floor_log2
argument_list|(
name|mode_width
argument_list|)
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
else|else
name|nonzero
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|CTZ
case|:
comment|/* If CTZ has a known value at zero, then the nonzero bits are 	 that value, plus the number of bits in the mode minus one.  */
if|if
condition|(
name|CTZ_DEFINED_VALUE_AT_ZERO
argument_list|(
name|mode
argument_list|,
name|nonzero
argument_list|)
condition|)
name|nonzero
operator||=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|floor_log2
argument_list|(
name|mode_width
argument_list|)
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
else|else
name|nonzero
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|PARITY
case|:
name|nonzero
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IF_THEN_ELSE
case|:
block|{
name|unsigned
name|HOST_WIDE_INT
name|nonzero_true
init|=
name|cached_nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
decl_stmt|;
comment|/* Don't call nonzero_bits for the second time if it cannot change 	   anything.  */
if|if
condition|(
operator|(
name|nonzero
operator|&
name|nonzero_true
operator|)
operator|!=
name|nonzero
condition|)
name|nonzero
operator|&=
name|nonzero_true
operator||
name|cached_nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|nonzero
return|;
block|}
end_function

begin_comment
comment|/* See the macro definition above.  */
end_comment

begin_undef
undef|#
directive|undef
name|cached_num_sign_bit_copies
end_undef

begin_escape
end_escape

begin_comment
comment|/* The function cached_num_sign_bit_copies is a wrapper around    num_sign_bit_copies1.  It avoids exponential behavior in    num_sign_bit_copies1 when X has identical subexpressions on the    first or the second level.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|cached_num_sign_bit_copies
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|known_x
parameter_list|,
name|enum
name|machine_mode
name|known_mode
parameter_list|,
name|unsigned
name|int
name|known_ret
parameter_list|)
block|{
if|if
condition|(
name|x
operator|==
name|known_x
operator|&&
name|mode
operator|==
name|known_mode
condition|)
return|return
name|known_ret
return|;
comment|/* Try to find identical subexpressions.  If found call      num_sign_bit_copies1 on X with the subexpressions as KNOWN_X and      the precomputed value for the subexpression as KNOWN_RET.  */
if|if
condition|(
name|ARITHMETIC_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|rtx
name|x0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|x1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Check the first level.  */
if|if
condition|(
name|x0
operator|==
name|x1
condition|)
return|return
name|num_sign_bit_copies1
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|x0
argument_list|,
name|mode
argument_list|,
name|cached_num_sign_bit_copies
argument_list|(
name|x0
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
argument_list|)
return|;
comment|/* Check the second level.  */
if|if
condition|(
name|ARITHMETIC_P
argument_list|(
name|x0
argument_list|)
operator|&&
operator|(
name|x1
operator|==
name|XEXP
argument_list|(
name|x0
argument_list|,
literal|0
argument_list|)
operator|||
name|x1
operator|==
name|XEXP
argument_list|(
name|x0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
name|num_sign_bit_copies1
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|x1
argument_list|,
name|mode
argument_list|,
name|cached_num_sign_bit_copies
argument_list|(
name|x1
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|ARITHMETIC_P
argument_list|(
name|x1
argument_list|)
operator|&&
operator|(
name|x0
operator|==
name|XEXP
argument_list|(
name|x1
argument_list|,
literal|0
argument_list|)
operator|||
name|x0
operator|==
name|XEXP
argument_list|(
name|x1
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
name|num_sign_bit_copies1
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|x0
argument_list|,
name|mode
argument_list|,
name|cached_num_sign_bit_copies
argument_list|(
name|x0
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
argument_list|)
return|;
block|}
return|return
name|num_sign_bit_copies1
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the number of bits at the high-order end of X that are known to    be equal to the sign bit.  X will be used in mode MODE; if MODE is    VOIDmode, X will be used in its own mode.  The returned value  will always    be between 1 and the number of bits in MODE.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|num_sign_bit_copies1
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|known_x
parameter_list|,
name|enum
name|machine_mode
name|known_mode
parameter_list|,
name|unsigned
name|int
name|known_ret
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|bitwidth
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|num0
decl_stmt|,
name|num1
decl_stmt|,
name|result
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|nonzero
decl_stmt|;
comment|/* If we weren't given a mode, use the mode of X.  If the mode is still      VOIDmode, we don't know anything.  Likewise if one of the modes is      floating-point.  */
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
operator|||
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* For a smaller object, just ignore the high bits.  */
if|if
condition|(
name|bitwidth
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|num0
operator|=
name|cached_num_sign_bit_copies
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
return|return
name|MAX
argument_list|(
literal|1
argument_list|,
name|num0
operator|-
call|(
name|int
call|)
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
name|bitwidth
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|bitwidth
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|WORD_REGISTER_OPERATIONS
comment|/* If this machine does not do all register operations on the entire      register and MODE is wider than the mode of X, we can say nothing      at all about the high-order bits.  */
return|return
literal|1
return|;
else|#
directive|else
comment|/* Likewise on machines that do, if the mode of the object is smaller 	 than a word and loads of that size don't sign extend, we can say 	 nothing about the high order bits.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|BITS_PER_WORD
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
operator|&&
name|LOAD_EXTEND_OP
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|SIGN_EXTEND
endif|#
directive|endif
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
if|#
directive|if
name|defined
argument_list|(
name|POINTERS_EXTEND_UNSIGNED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_ptr_extend
argument_list|)
comment|/* If pointers extend signed and this is a pointer in Pmode, say that 	 all the bits above ptr_mode are known to be sign bit copies.  */
if|if
condition|(
operator|!
name|POINTERS_EXTEND_UNSIGNED
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|Pmode
operator|&&
name|mode
operator|==
name|Pmode
operator|&&
name|REG_POINTER
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|GET_MODE_BITSIZE
argument_list|(
name|Pmode
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|ptr_mode
argument_list|)
operator|+
literal|1
return|;
endif|#
directive|endif
block|{
name|unsigned
name|int
name|copies_for_hook
init|=
literal|1
decl_stmt|,
name|copies
init|=
literal|1
decl_stmt|;
name|rtx
name|new
init|=
name|rtl_hooks
operator|.
name|reg_num_sign_bit_copies
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|,
operator|&
name|copies_for_hook
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
condition|)
name|copies
operator|=
name|cached_num_sign_bit_copies
argument_list|(
name|new
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|copies
operator|>
literal|1
operator|||
name|copies_for_hook
operator|>
literal|1
condition|)
return|return
name|MAX
argument_list|(
name|copies
argument_list|,
name|copies_for_hook
argument_list|)
return|;
comment|/* Else, use nonzero_bits to guess num_sign_bit_copies (see below).  */
block|}
break|break;
case|case
name|MEM
case|:
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
comment|/* Some RISC machines sign-extend all loads of smaller than a word.  */
if|if
condition|(
name|LOAD_EXTEND_OP
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
condition|)
return|return
name|MAX
argument_list|(
literal|1
argument_list|,
operator|(
operator|(
name|int
operator|)
name|bitwidth
operator|-
operator|(
name|int
operator|)
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|+
literal|1
operator|)
argument_list|)
return|;
endif|#
directive|endif
break|break;
case|case
name|CONST_INT
case|:
comment|/* If the constant is negative, take its 1's complement and remask. 	 Then see how many zero bits we have.  */
name|nonzero
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitwidth
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|nonzero
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bitwidth
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
name|nonzero
operator|=
operator|(
operator|~
name|nonzero
operator|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|nonzero
operator|==
literal|0
condition|?
name|bitwidth
else|:
name|bitwidth
operator|-
name|floor_log2
argument_list|(
name|nonzero
argument_list|)
operator|-
literal|1
operator|)
return|;
case|case
name|SUBREG
case|:
comment|/* If this is a SUBREG for a promoted object that is sign-extended 	 and we are looking at it in a wider mode, we know that at least the 	 high-order bits are known to be sign bit copies.  */
if|if
condition|(
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|num0
operator|=
name|cached_num_sign_bit_copies
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
return|return
name|MAX
argument_list|(
operator|(
name|int
operator|)
name|bitwidth
operator|-
operator|(
name|int
operator|)
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|,
name|num0
argument_list|)
return|;
block|}
comment|/* For a smaller object, just ignore the high bits.  */
if|if
condition|(
name|bitwidth
operator|<=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|num0
operator|=
name|cached_num_sign_bit_copies
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
return|return
name|MAX
argument_list|(
literal|1
argument_list|,
operator|(
name|num0
operator|-
call|(
name|int
call|)
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|-
name|bitwidth
argument_list|)
operator|)
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|WORD_REGISTER_OPERATIONS
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
comment|/* For paradoxical SUBREGs on machines where all register operations 	 affect the entire register, just look inside.  Note that we are 	 passing MODE to the recursive call, so the number of sign bit copies 	 will remain relative to that mode, not the inner mode.  */
comment|/* This works only if loads sign extend.  Otherwise, if we get a 	 reload for the inner part, it may be loaded from the stack, and 	 then we lose all sign bit copies that existed before the store 	 to the stack.  */
if|if
condition|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|LOAD_EXTEND_OP
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
operator|&&
name|MEM_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|cached_num_sign_bit_copies
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
return|;
endif|#
directive|endif
endif|#
directive|endif
break|break;
case|case
name|SIGN_EXTRACT
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|MAX
argument_list|(
literal|1
argument_list|,
operator|(
name|int
operator|)
name|bitwidth
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|SIGN_EXTEND
case|:
return|return
operator|(
name|bitwidth
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|+
name|cached_num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
operator|)
return|;
case|case
name|TRUNCATE
case|:
comment|/* For a smaller object, just ignore the high bits.  */
name|num0
operator|=
name|cached_num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
return|return
name|MAX
argument_list|(
literal|1
argument_list|,
operator|(
name|num0
operator|-
call|(
name|int
call|)
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|-
name|bitwidth
argument_list|)
operator|)
argument_list|)
return|;
case|case
name|NOT
case|:
return|return
name|cached_num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
return|;
case|case
name|ROTATE
case|:
case|case
name|ROTATERT
case|:
comment|/* If we are rotating left by a number of bits less than the number 	 of sign bit copies, we can just subtract that amount from the 	 number.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
operator|(
name|int
operator|)
name|bitwidth
condition|)
block|{
name|num0
operator|=
name|cached_num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
return|return
name|MAX
argument_list|(
literal|1
argument_list|,
name|num0
operator|-
operator|(
name|code
operator|==
name|ROTATE
condition|?
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
else|:
operator|(
name|int
operator|)
name|bitwidth
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
argument_list|)
return|;
block|}
break|break;
case|case
name|NEG
case|:
comment|/* In general, this subtracts one sign bit copy.  But if the value 	 is known to be positive, the number of sign bit copies is the 	 same as that of the input.  Finally, if the input has just one bit 	 that might be nonzero, all the bits are copies of the sign bit.  */
name|num0
operator|=
name|cached_num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitwidth
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
name|num0
operator|>
literal|1
condition|?
name|num0
operator|-
literal|1
else|:
literal|1
return|;
name|nonzero
operator|=
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonzero
operator|==
literal|1
condition|)
return|return
name|bitwidth
return|;
if|if
condition|(
name|num0
operator|>
literal|1
operator|&&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bitwidth
operator|-
literal|1
operator|)
operator|)
operator|&
name|nonzero
operator|)
condition|)
name|num0
operator|--
expr_stmt|;
return|return
name|num0
return|;
case|case
name|IOR
case|:
case|case
name|AND
case|:
case|case
name|XOR
case|:
case|case
name|SMIN
case|:
case|case
name|SMAX
case|:
case|case
name|UMIN
case|:
case|case
name|UMAX
case|:
comment|/* Logical operations will preserve the number of sign-bit copies. 	 MIN and MAX operations always return one of the operands.  */
name|num0
operator|=
name|cached_num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
name|num1
operator|=
name|cached_num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
return|return
name|MIN
argument_list|(
name|num0
argument_list|,
name|num1
argument_list|)
return|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
comment|/* For addition and subtraction, we can have a 1-bit carry.  However, 	 if we are subtracting 1 from a positive number, there will not 	 be such a carry.  Furthermore, if the positive number is known to 	 be 0 or 1, we know the result is either -1 or 0.  */
if|if
condition|(
name|code
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|constm1_rtx
operator|&&
name|bitwidth
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|nonzero
operator|=
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bitwidth
operator|-
literal|1
operator|)
operator|)
operator|&
name|nonzero
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|nonzero
operator|==
literal|1
operator|||
name|nonzero
operator|==
literal|0
condition|?
name|bitwidth
else|:
name|bitwidth
operator|-
name|floor_log2
argument_list|(
name|nonzero
argument_list|)
operator|-
literal|1
operator|)
return|;
block|}
name|num0
operator|=
name|cached_num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
name|num1
operator|=
name|cached_num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
name|result
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|MIN
argument_list|(
name|num0
argument_list|,
name|num1
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
comment|/* If pointers extend signed and this is an addition or subtraction 	 to a pointer in Pmode, all the bits above ptr_mode are known to be 	 sign bit copies.  */
if|if
condition|(
operator|!
name|POINTERS_EXTEND_UNSIGNED
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|Pmode
operator|&&
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
operator|)
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|REG_POINTER
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|result
operator|=
name|MAX
argument_list|(
call|(
name|int
call|)
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|Pmode
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|ptr_mode
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
case|case
name|MULT
case|:
comment|/* The number of bits of the product is the sum of the number of 	 bits of both terms.  However, unless one of the terms if known 	 to be positive, we must allow for an additional bit since negating 	 a negative number can remove one sign bit copy.  */
name|num0
operator|=
name|cached_num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
name|num1
operator|=
name|cached_num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
name|result
operator|=
name|bitwidth
operator|-
operator|(
name|bitwidth
operator|-
name|num0
operator|)
operator|-
operator|(
name|bitwidth
operator|-
name|num1
operator|)
expr_stmt|;
if|if
condition|(
name|result
operator|>
literal|0
operator|&&
operator|(
name|bitwidth
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|||
operator|(
operator|(
operator|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bitwidth
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bitwidth
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
operator|)
operator|)
operator|)
condition|)
name|result
operator|--
expr_stmt|;
return|return
name|MAX
argument_list|(
literal|1
argument_list|,
name|result
argument_list|)
return|;
case|case
name|UDIV
case|:
comment|/* The result must be<= the first operand.  If the first operand 	 has the high bit set, we know nothing about the number of sign 	 bit copies.  */
if|if
condition|(
name|bitwidth
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bitwidth
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
else|else
return|return
name|cached_num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
return|;
case|case
name|UMOD
case|:
comment|/* The result must be<= the second operand.  */
return|return
name|cached_num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
return|;
case|case
name|DIV
case|:
comment|/* Similar to unsigned division, except that we have to worry about 	 the case where the divisor is negative, in which case we have 	 to add 1.  */
name|result
operator|=
name|cached_num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|>
literal|1
operator|&&
operator|(
name|bitwidth
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|||
operator|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bitwidth
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
name|result
operator|--
expr_stmt|;
return|return
name|result
return|;
case|case
name|MOD
case|:
name|result
operator|=
name|cached_num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|>
literal|1
operator|&&
operator|(
name|bitwidth
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|||
operator|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bitwidth
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
name|result
operator|--
expr_stmt|;
return|return
name|result
return|;
case|case
name|ASHIFTRT
case|:
comment|/* Shifts by a constant add to the number of bits equal to the 	 sign bit.  */
name|num0
operator|=
name|cached_num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
name|num0
operator|=
name|MIN
argument_list|(
operator|(
name|int
operator|)
name|bitwidth
argument_list|,
name|num0
operator|+
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|num0
return|;
case|case
name|ASHIFT
case|:
comment|/* Left shifts destroy copies.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
literal|0
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
operator|(
name|int
operator|)
name|bitwidth
condition|)
return|return
literal|1
return|;
name|num0
operator|=
name|cached_num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
return|return
name|MAX
argument_list|(
literal|1
argument_list|,
name|num0
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|IF_THEN_ELSE
case|:
name|num0
operator|=
name|cached_num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
name|num1
operator|=
name|cached_num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
expr_stmt|;
return|return
name|MIN
argument_list|(
name|num0
argument_list|,
name|num1
argument_list|)
return|;
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|UNEQ
case|:
case|case
name|LTGT
case|:
case|case
name|UNGE
case|:
case|case
name|UNGT
case|:
case|case
name|UNLE
case|:
case|case
name|UNLT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
case|case
name|UNORDERED
case|:
case|case
name|ORDERED
case|:
comment|/* If the constant is negative, take its 1's complement and remask. 	 Then see how many zero bits we have.  */
name|nonzero
operator|=
name|STORE_FLAG_VALUE
expr_stmt|;
if|if
condition|(
name|bitwidth
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|nonzero
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bitwidth
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
name|nonzero
operator|=
operator|(
operator|~
name|nonzero
operator|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|nonzero
operator|==
literal|0
condition|?
name|bitwidth
else|:
name|bitwidth
operator|-
name|floor_log2
argument_list|(
name|nonzero
argument_list|)
operator|-
literal|1
operator|)
return|;
default|default:
break|break;
block|}
comment|/* If we haven't been able to figure it out by one of the above rules,      see if some of the high-order bits are known to be zero.  If so,      count those bits and return one less than that amount.  If we can't      safely compute the mask for this mode, always return BITWIDTH.  */
name|bitwidth
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitwidth
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
literal|1
return|;
name|nonzero
operator|=
name|nonzero_bits
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|nonzero
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bitwidth
operator|-
literal|1
operator|)
operator|)
condition|?
literal|1
else|:
name|bitwidth
operator|-
name|floor_log2
argument_list|(
name|nonzero
argument_list|)
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Calculate the rtx_cost of a single instruction.  A return value of    zero indicates an instruction pattern without a known cost.  */
end_comment

begin_function
name|int
name|insn_rtx_cost
parameter_list|(
name|rtx
name|pat
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|cost
decl_stmt|;
name|rtx
name|set
decl_stmt|;
comment|/* Extract the single set rtx from the instruction pattern.      We can't use single_set since we only have the pattern.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
name|set
operator|=
name|pat
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|set
operator|=
name|NULL_RTX
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|set
condition|)
return|return
literal|0
return|;
name|set
operator|=
name|x
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|set
condition|)
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
name|cost
operator|=
name|rtx_cost
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET
argument_list|)
expr_stmt|;
return|return
name|cost
operator|>
literal|0
condition|?
name|cost
else|:
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given an insn INSN and condition COND, return the condition in a    canonical form to simplify testing by callers.  Specifically:     (1) The code will always be a comparison operation (EQ, NE, GT, etc.).    (2) Both operands will be machine operands; (cc0) will have been replaced.    (3) If an operand is a constant, it will be the second operand.    (4) (LE x const) will be replaced with (LT x<const+1>) and similarly        for GE, GEU, and LEU.     If the condition cannot be understood, or is an inequality floating-point    comparison which needs to be reversed, 0 will be returned.     If REVERSE is nonzero, then reverse the condition prior to canonizing it.     If EARLIEST is nonzero, it is a pointer to a place where the earliest    insn used in locating the condition was found.  If a replacement test    of the condition is desired, it should be placed in front of that    insn and we will be sure that the inputs are still valid.     If WANT_REG is nonzero, we wish the condition to be relative to that    register, if possible.  Therefore, do not canonicalize the condition    further.  If ALLOW_CC_MODE is nonzero, allow the condition returned     to be a compare to a CC mode register.     If VALID_AT_INSN_P, the condition must be valid at both *EARLIEST    and at INSN.  */
end_comment

begin_function
name|rtx
name|canonicalize_condition
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|cond
parameter_list|,
name|int
name|reverse
parameter_list|,
name|rtx
modifier|*
name|earliest
parameter_list|,
name|rtx
name|want_reg
parameter_list|,
name|int
name|allow_cc_mode
parameter_list|,
name|int
name|valid_at_insn_p
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|prev
init|=
name|insn
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|int
name|reverse_code
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|basic_block
name|bb
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|op0
operator|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|reverse
condition|)
name|code
operator|=
name|reversed_comparison_code
argument_list|(
name|cond
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|UNKNOWN
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|earliest
condition|)
operator|*
name|earliest
operator|=
name|insn
expr_stmt|;
comment|/* If we are comparing a register with zero, see if the register is set      in the previous insn to a COMPARE or a comparison operation.  Perform      the same tests as a function of STORE_FLAG_VALUE as find_comparison_args      in cse.c  */
while|while
condition|(
operator|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|RTX_COMPARE
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|RTX_COMM_COMPARE
operator|)
operator|&&
name|op1
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|&&
name|op0
operator|!=
name|want_reg
condition|)
block|{
comment|/* Set nonzero when we find something of interest.  */
name|rtx
name|x
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If comparison with cc0, import actual comparison from compare 	 insn.  */
if|if
condition|(
name|op0
operator|==
name|cc0_rtx
condition|)
block|{
if|if
condition|(
operator|(
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|prev
argument_list|)
operator|)
operator|==
literal|0
operator|||
operator|!
name|NONJUMP_INSN_P
argument_list|(
name|prev
argument_list|)
operator|||
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|prev
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|!=
name|cc0_rtx
condition|)
return|return
literal|0
return|;
name|op0
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|op1
operator|=
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|earliest
condition|)
operator|*
name|earliest
operator|=
name|prev
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If this is a COMPARE, pick up the two things being compared.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|COMPARE
condition|)
block|{
name|op1
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|op0
argument_list|)
condition|)
break|break;
comment|/* Go back to the previous insn.  Stop if it is not an INSN.  We also 	 stop if it isn't a single set or if it has a REG_INC note because 	 we don't want to bother dealing with it.  */
if|if
condition|(
operator|(
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|prev
argument_list|)
operator|)
operator|==
literal|0
operator|||
operator|!
name|NONJUMP_INSN_P
argument_list|(
name|prev
argument_list|)
operator|||
name|FIND_REG_INC_NOTE
argument_list|(
name|prev
argument_list|,
name|NULL_RTX
argument_list|)
comment|/* In cfglayout mode, there do not have to be labels at the 	     beginning of a block, or jumps at the end, so the previous 	     conditions would not stop us when we reach bb boundary.  */
operator|||
name|BLOCK_FOR_INSN
argument_list|(
name|prev
argument_list|)
operator|!=
name|bb
condition|)
break|break;
name|set
operator|=
name|set_of
argument_list|(
name|op0
argument_list|,
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|!=
name|SET
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|op0
argument_list|)
operator|)
condition|)
break|break;
comment|/* If this is setting OP0, get what it sets it to if it looks 	 relevant.  */
if|if
condition|(
name|set
condition|)
block|{
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
name|REAL_VALUE_TYPE
name|fsfv
decl_stmt|;
endif|#
directive|endif
comment|/* ??? We may not combine comparisons done in a CCmode with 	     comparisons not done in a CCmode.  This is to aid targets 	     like Alpha that have an IEEE compliant EQ instruction, and 	     a non-IEEE compliant BEQ instruction.  The use of CCmode is 	     actually artificial, simply to prevent the combination, but 	     should not affect other platforms.  	     However, we must allow VOIDmode comparisons to match either 	     CCmode or non-CCmode comparison, because some ports have 	     modeless comparisons inside branch patterns.  	     ??? This mode check should perhaps look more like the mode check 	     in simplify_comparison in combine.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|COMPARE
operator|||
operator|(
operator|(
operator|(
name|code
operator|==
name|NE
operator|||
operator|(
name|code
operator|==
name|LT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
operator|(
name|STORE_FLAG_VALUE
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|)
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
operator|||
operator|(
name|code
operator|==
name|LT
operator|&&
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|inner_mode
argument_list|)
operator|&&
operator|(
name|fsfv
operator|=
name|FLOAT_STORE_FLAG_VALUE
argument_list|(
name|inner_mode
argument_list|)
operator|,
name|REAL_VALUE_NEGATIVE
argument_list|(
name|fsfv
argument_list|)
operator|)
operator|)
endif|#
directive|endif
operator|)
operator|)
operator|&&
name|COMPARISON_P
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
operator|)
operator|==
operator|(
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_CC
operator|)
operator|)
operator|||
name|mode
operator|==
name|VOIDmode
operator|||
name|inner_mode
operator|==
name|VOIDmode
operator|)
condition|)
name|x
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|code
operator|==
name|EQ
operator|||
operator|(
name|code
operator|==
name|GE
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|STORE_FLAG_VALUE
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|)
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
operator|||
operator|(
name|code
operator|==
name|GE
operator|&&
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|inner_mode
argument_list|)
operator|&&
operator|(
name|fsfv
operator|=
name|FLOAT_STORE_FLAG_VALUE
argument_list|(
name|inner_mode
argument_list|)
operator|,
name|REAL_VALUE_NEGATIVE
argument_list|(
name|fsfv
argument_list|)
operator|)
operator|)
endif|#
directive|endif
operator|)
operator|)
operator|&&
name|COMPARISON_P
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
operator|)
operator|==
operator|(
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_CC
operator|)
operator|)
operator|||
name|mode
operator|==
name|VOIDmode
operator|||
name|inner_mode
operator|==
name|VOIDmode
operator|)
condition|)
block|{
name|reverse_code
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
elseif|else
if|if
condition|(
name|reg_set_p
argument_list|(
name|op0
argument_list|,
name|prev
argument_list|)
condition|)
comment|/* If this sets OP0, but not directly, we have to give up.  */
break|break;
if|if
condition|(
name|x
condition|)
block|{
comment|/* If the caller is expecting the condition to be valid at INSN, 	     make sure X doesn't change before INSN.  */
if|if
condition|(
name|valid_at_insn_p
condition|)
if|if
condition|(
name|modified_in_p
argument_list|(
name|x
argument_list|,
name|prev
argument_list|)
operator|||
name|modified_between_p
argument_list|(
name|x
argument_list|,
name|prev
argument_list|,
name|insn
argument_list|)
condition|)
break|break;
if|if
condition|(
name|COMPARISON_P
argument_list|(
name|x
argument_list|)
condition|)
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|reverse_code
condition|)
block|{
name|code
operator|=
name|reversed_comparison_code
argument_list|(
name|x
argument_list|,
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|UNKNOWN
condition|)
return|return
literal|0
return|;
name|reverse_code
operator|=
literal|0
expr_stmt|;
block|}
name|op0
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|,
name|op1
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|earliest
condition|)
operator|*
name|earliest
operator|=
name|prev
expr_stmt|;
block|}
block|}
comment|/* If constant is first, put it last.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
operator|,
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
comment|/* If OP0 is the result of a comparison, we weren't able to find what      was really being compared, so fail.  */
if|if
condition|(
operator|!
name|allow_cc_mode
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_CC
condition|)
return|return
literal|0
return|;
comment|/* Canonicalize any ordered comparison with integers involving equality      if we can do computations in the relevant mode and we do not      overflow.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|!=
name|MODE_CC
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|HOST_WIDE_INT
name|const_val
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|uconst_val
init|=
name|const_val
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|max_val
init|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LE
case|:
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|const_val
operator|!=
name|max_val
operator|>>
literal|1
condition|)
name|code
operator|=
name|LT
operator|,
name|op1
operator|=
name|gen_int_mode
argument_list|(
name|const_val
operator|+
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* When cross-compiling, const_val might be sign-extended from 	   BITS_PER_WORD to HOST_BITS_PER_WIDE_INT */
case|case
name|GE
case|:
if|if
condition|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
name|const_val
operator|&
name|max_val
argument_list|)
operator|!=
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|code
operator|=
name|GT
operator|,
name|op1
operator|=
name|gen_int_mode
argument_list|(
name|const_val
operator|-
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEU
case|:
if|if
condition|(
name|uconst_val
operator|<
name|max_val
condition|)
name|code
operator|=
name|LTU
operator|,
name|op1
operator|=
name|gen_int_mode
argument_list|(
name|uconst_val
operator|+
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEU
case|:
if|if
condition|(
name|uconst_val
operator|!=
literal|0
condition|)
name|code
operator|=
name|GTU
operator|,
name|op1
operator|=
name|gen_int_mode
argument_list|(
name|uconst_val
operator|-
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* Never return CC0; return zero instead.  */
if|if
condition|(
name|CC0_P
argument_list|(
name|op0
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a jump insn JUMP, return the condition that will cause it to branch    to its JUMP_LABEL.  If the condition cannot be understood, or is an    inequality floating-point comparison which needs to be reversed, 0 will    be returned.     If EARLIEST is nonzero, it is a pointer to a place where the earliest    insn used in locating the condition was found.  If a replacement test    of the condition is desired, it should be placed in front of that    insn and we will be sure that the inputs are still valid.  If EARLIEST    is null, the returned condition will be valid at INSN.     If ALLOW_CC_MODE is nonzero, allow the condition returned to be a    compare CC mode register.     VALID_AT_INSN_P is the same as for canonicalize_condition.  */
end_comment

begin_function
name|rtx
name|get_condition
parameter_list|(
name|rtx
name|jump
parameter_list|,
name|rtx
modifier|*
name|earliest
parameter_list|,
name|int
name|allow_cc_mode
parameter_list|,
name|int
name|valid_at_insn_p
parameter_list|)
block|{
name|rtx
name|cond
decl_stmt|;
name|int
name|reverse
decl_stmt|;
name|rtx
name|set
decl_stmt|;
comment|/* If this is not a standard conditional jump, we can't parse it.  */
if|if
condition|(
operator|!
name|JUMP_P
argument_list|(
name|jump
argument_list|)
operator|||
operator|!
name|any_condjump_p
argument_list|(
name|jump
argument_list|)
condition|)
return|return
literal|0
return|;
name|set
operator|=
name|pc_set
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|cond
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this branches to JUMP_LABEL when the condition is false, reverse      the condition.  */
name|reverse
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
expr_stmt|;
return|return
name|canonicalize_condition
argument_list|(
name|jump
argument_list|,
name|cond
argument_list|,
name|reverse
argument_list|,
name|earliest
argument_list|,
name|NULL_RTX
argument_list|,
name|allow_cc_mode
argument_list|,
name|valid_at_insn_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize the table NUM_SIGN_BIT_COPIES_IN_REP based on    TARGET_MODE_REP_EXTENDED.     Note that we assume that the property of    TARGET_MODE_REP_EXTENDED(B, C) is sticky to the integral modes    narrower than mode B.  I.e., if A is a mode narrower than B then in    order to be able to operate on it in mode B, mode A needs to    satisfy the requirements set by the representation of mode B.  */
end_comment

begin_function
specifier|static
name|void
name|init_num_sign_bit_copies_in_rep
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|in_mode
decl_stmt|;
for|for
control|(
name|in_mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|in_mode
operator|!=
name|VOIDmode
condition|;
name|in_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|in_mode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
name|enum
name|machine_mode
name|i
decl_stmt|;
comment|/* Currently, it is assumed that TARGET_MODE_REP_EXTENDED 	   extends to the next widest mode.  */
name|gcc_assert
argument_list|(
name|targetm
operator|.
name|mode_rep_extended
argument_list|(
name|mode
argument_list|,
name|in_mode
argument_list|)
operator|==
name|UNKNOWN
operator|||
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
operator|==
name|in_mode
argument_list|)
expr_stmt|;
comment|/* We are in in_mode.  Count how many bits outside of mode 	   have to be copies of the sign-bit.  */
for|for
control|(
name|i
operator|=
name|mode
init|;
name|i
operator|!=
name|in_mode
condition|;
name|i
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|i
argument_list|)
control|)
block|{
name|enum
name|machine_mode
name|wider
init|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetm
operator|.
name|mode_rep_extended
argument_list|(
name|i
argument_list|,
name|wider
argument_list|)
operator|==
name|SIGN_EXTEND
comment|/* We can only check sign-bit copies starting from the 		   top-bit.  In order to be able to check the bits we 		   have already seen we pretend that subsequent bits 		   have to be sign-bit copies too.  */
operator|||
name|num_sign_bit_copies_in_rep
index|[
name|in_mode
index|]
index|[
name|mode
index|]
condition|)
name|num_sign_bit_copies_in_rep
index|[
name|in_mode
index|]
index|[
name|mode
index|]
operator|+=
name|GET_MODE_BITSIZE
argument_list|(
name|wider
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Suppose that truncation from the machine mode of X to MODE is not a    no-op.  See if there is anything special about X so that we can    assume it already contains a truncated value of MODE.  */
end_comment

begin_function
name|bool
name|truncated_to_mode
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
comment|/* This register has already been used in MODE without explicit      truncation.  */
if|if
condition|(
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
name|rtl_hooks
operator|.
name|reg_truncated_to_mode
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* See if we already satisfy the requirements of MODE.  If yes we      can just switch to MODE.  */
if|if
condition|(
name|num_sign_bit_copies_in_rep
index|[
name|GET_MODE
argument_list|(
name|x
argument_list|)
index|]
index|[
name|mode
index|]
operator|&&
operator|(
name|num_sign_bit_copies
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>=
name|num_sign_bit_copies_in_rep
index|[
name|GET_MODE
argument_list|(
name|x
argument_list|)
index|]
index|[
name|mode
index|]
operator|+
literal|1
operator|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize non_rtx_starting_operands, which is used to speed up    for_each_rtx.  */
end_comment

begin_function
name|void
name|init_rtlanal
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_RTX_CODE
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|format
init|=
name|GET_RTX_FORMAT
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|first
init|=
name|strpbrk
argument_list|(
name|format
argument_list|,
literal|"eEV"
argument_list|)
decl_stmt|;
name|non_rtx_starting_operands
index|[
name|i
index|]
operator|=
name|first
condition|?
name|first
operator|-
name|format
else|:
operator|-
literal|1
expr_stmt|;
block|}
name|init_num_sign_bit_copies_in_rep
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check whether this is a constant pool constant.  */
end_comment

begin_function
name|bool
name|constant_pool_constant_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|x
operator|=
name|avoid_constant_pool_reference
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
return|;
block|}
end_function

end_unit

