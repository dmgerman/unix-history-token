begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Analyze RTL for C-Compiler    Copyright (C) 1987, 88, 92-97, 1998 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|rtx_addr_can_trap_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reg_set_p_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reg_set_last_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations */
end_comment

begin_decl_stmt
specifier|static
name|int
name|jmp_uses_reg_or_mem
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bit flags that specify the machine subtype we are compiling for.    Bits are tested using macros TARGET_... defined in the tm.h file    and set by `-m...' switches.  Must be defined in rtlanal.c.  */
end_comment

begin_decl_stmt
name|int
name|target_flags
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return 1 if the value of X is unstable    (would be different at a different point in the program).    The frame pointer, arg pointer, etc. are considered stable    (within one function) and so is anything marked `unchanging'.  */
end_comment

begin_function
name|int
name|rtx_unstable_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
return|return
operator|!
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|QUEUED
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|code
operator|==
name|CONST
operator|||
name|code
operator|==
name|CONST_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|code
operator|==
name|REG
condition|)
return|return
operator|!
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|ARG_POINTER_REGNUM
operator|||
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|)
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
if|if
condition|(
name|rtx_unstable_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X has a value that can vary even between two    executions of the program.  0 means X can be compared reliably    against certain constants or near-constants.    The frame pointer and the arg pointer are considered constant.  */
end_comment

begin_function
name|int
name|rtx_varies_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MEM
case|:
case|case
name|QUEUED
case|:
return|return
literal|1
return|;
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|0
return|;
case|case
name|REG
case|:
comment|/* Note that we have to test for the actual rtx used for the frame 	 and arg pointers and not just the register number in case we have 	 eliminated the frame and/or arg pointer and are using it 	 for pseudos.  */
return|return
operator|!
operator|(
name|x
operator|==
name|frame_pointer_rtx
operator|||
name|x
operator|==
name|hard_frame_pointer_rtx
operator|||
name|x
operator|==
name|arg_pointer_rtx
operator|||
name|x
operator|==
name|pic_offset_table_rtx
operator|)
return|;
case|case
name|LO_SUM
case|:
comment|/* The operand 0 of a LO_SUM is considered constant 	 (in fact is it related specifically to operand 1).  */
return|return
name|rtx_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
if|if
condition|(
name|rtx_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 0 if the use of X as an address in a MEM can cause a trap.  */
end_comment

begin_function
specifier|static
name|int
name|rtx_addr_can_trap_p
parameter_list|(
name|x
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
comment|/* SYMBOL_REF is problematic due to the possible presence of 	 a #pragma weak, but to say that loads from symbols can trap is 	 *very* costly.  It's not at all clear what's best here.  For 	 now, we ignore the impact of #pragma weak.  */
return|return
literal|0
return|;
case|case
name|REG
case|:
comment|/* As in rtx_varies_p, we have to use the actual rtx, not reg number.  */
return|return
operator|!
operator|(
name|x
operator|==
name|frame_pointer_rtx
operator|||
name|x
operator|==
name|hard_frame_pointer_rtx
operator|||
name|x
operator|==
name|stack_pointer_rtx
operator|||
name|x
operator|==
name|arg_pointer_rtx
operator|)
return|;
case|case
name|CONST
case|:
return|return
name|rtx_addr_can_trap_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|PLUS
case|:
comment|/* An address is assumed not to trap if it is an address that can't 	 trap plus a constant integer.  */
return|return
operator|(
name|rtx_addr_can_trap_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|)
return|;
case|case
name|LO_SUM
case|:
return|return
name|rtx_addr_can_trap_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
comment|/* If it isn't one of the case above, it can cause a trap.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X refers to a memory location whose address     cannot be compared reliably with constant addresses,    or if X refers to a BLKmode memory object.  */
end_comment

begin_function
name|int
name|rtx_addr_varies_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
return|return
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
operator|||
name|rtx_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|rtx_addr_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|rtx_addr_varies_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the value of the integer term in X, if one is apparent;    otherwise return 0.    Only obvious integer terms are detected.    This is used in cse.c with the `related_value' field.*/
end_comment

begin_function
name|HOST_WIDE_INT
name|get_integer_term
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If X is a constant, return the value sans apparent integer term;    otherwise return 0.    Only obvious integer terms are detected.  */
end_comment

begin_function
name|rtx
name|get_related_value
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if register REG appears somewhere within IN.    Also works if REG is not a register; in this case it checks    for a subexpression of IN that is Lisp "equal" to REG.  */
end_comment

begin_function
name|int
name|reg_mentioned_p
parameter_list|(
name|reg
parameter_list|,
name|in
parameter_list|)
specifier|register
name|rtx
name|reg
decl_stmt|,
name|in
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|in
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|reg
operator|==
name|in
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
name|reg
operator|==
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|in
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Compare registers by number.  */
case|case
name|REG
case|:
return|return
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|in
argument_list|)
operator|==
name|REGNO
argument_list|(
name|reg
argument_list|)
return|;
comment|/* These codes have no constituent expressions 	 and are unique.  */
case|case
name|SCRATCH
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
return|return
literal|0
return|;
case|case
name|CONST_INT
case|:
return|return
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|in
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|reg
argument_list|)
return|;
case|case
name|CONST_DOUBLE
case|:
comment|/* These are kept unique for a given value.  */
return|return
literal|0
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|code
operator|&&
name|rtx_equal_p
argument_list|(
name|reg
argument_list|,
name|in
argument_list|)
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|in
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|XVECEXP
argument_list|(
name|in
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|XEXP
argument_list|(
name|in
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if in between BEG and END, exclusive of BEG and END, there is    no CODE_LABEL insn.  */
end_comment

begin_function
name|int
name|no_labels_between_p
parameter_list|(
name|beg
parameter_list|,
name|end
parameter_list|)
name|rtx
name|beg
decl_stmt|,
name|end
decl_stmt|;
block|{
specifier|register
name|rtx
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|beg
argument_list|)
init|;
name|p
operator|!=
name|end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if register REG is used in an insn between    FROM_INSN and TO_INSN (exclusive of those two).  */
end_comment

begin_function
name|int
name|reg_used_between_p
parameter_list|(
name|reg
parameter_list|,
name|from_insn
parameter_list|,
name|to_insn
parameter_list|)
name|rtx
name|reg
decl_stmt|,
name|from_insn
decl_stmt|,
name|to_insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|from_insn
operator|==
name|to_insn
condition|)
return|return
literal|0
return|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|from_insn
argument_list|)
init|;
name|insn
operator|!=
name|to_insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
operator|(
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
operator|(
name|find_reg_fusage
argument_list|(
name|insn
argument_list|,
name|USE
argument_list|,
name|reg
argument_list|)
operator|||
name|find_reg_fusage
argument_list|(
name|insn
argument_list|,
name|CLOBBER
argument_list|,
name|reg
argument_list|)
operator|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if the old value of X, a register, is referenced in BODY.  If X    is entirely replaced by a new value and the only use is as a SET_DEST,    we do not consider it a reference.  */
end_comment

begin_function
name|int
name|reg_referenced_p
parameter_list|(
name|x
parameter_list|,
name|body
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|body
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
condition|)
block|{
case|case
name|SET
case|:
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If the destination is anything other than CC0, PC, a REG or a SUBREG 	 of a REG that occupies all of the REG, the insn references X if 	 it is mentioned in the destination.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|!=
name|CC0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|!=
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|==
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
operator|)
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|ASM_OPERANDS
case|:
for|for
control|(
name|i
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|body
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|ASM_OPERANDS_INPUT
argument_list|(
name|body
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|CALL
case|:
case|case
name|USE
case|:
return|return
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|body
argument_list|)
return|;
case|case
name|TRAP_IF
case|:
return|return
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|TRAP_CONDITION
argument_list|(
name|body
argument_list|)
argument_list|)
return|;
case|case
name|UNSPEC
case|:
case|case
name|UNSPEC_VOLATILE
case|:
case|case
name|PARALLEL
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|reg_referenced_p
argument_list|(
name|x
argument_list|,
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Nonzero if register REG is referenced in an insn between    FROM_INSN and TO_INSN (exclusive of those two).  Sets of REG do    not count.  */
end_comment

begin_function
name|int
name|reg_referenced_between_p
parameter_list|(
name|reg
parameter_list|,
name|from_insn
parameter_list|,
name|to_insn
parameter_list|)
name|rtx
name|reg
decl_stmt|,
name|from_insn
decl_stmt|,
name|to_insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|from_insn
operator|==
name|to_insn
condition|)
return|return
literal|0
return|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|from_insn
argument_list|)
init|;
name|insn
operator|!=
name|to_insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
operator|(
name|reg_referenced_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|find_reg_fusage
argument_list|(
name|insn
argument_list|,
name|USE
argument_list|,
name|reg
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if register REG is set or clobbered in an insn between    FROM_INSN and TO_INSN (exclusive of those two).  */
end_comment

begin_function
name|int
name|reg_set_between_p
parameter_list|(
name|reg
parameter_list|,
name|from_insn
parameter_list|,
name|to_insn
parameter_list|)
name|rtx
name|reg
decl_stmt|,
name|from_insn
decl_stmt|,
name|to_insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|from_insn
operator|==
name|to_insn
condition|)
return|return
literal|0
return|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|from_insn
argument_list|)
init|;
name|insn
operator|!=
name|to_insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|reg_set_p
argument_list|(
name|reg
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Internals of reg_set_between_p.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|reg_set_reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_set_flag
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|reg_set_p_1
parameter_list|(
name|x
parameter_list|,
name|pat
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|pat
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* We don't want to return 1 if X is a MEM that contains a register      within REG_SET_REG.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
operator|)
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|reg_set_reg
argument_list|,
name|x
argument_list|)
condition|)
name|reg_set_flag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|reg_set_p
parameter_list|(
name|reg
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|reg
decl_stmt|,
name|insn
decl_stmt|;
block|{
name|rtx
name|body
init|=
name|insn
decl_stmt|;
comment|/* We can be passed an insn or part of one.  If we are passed an insn,      check if a side-effect of the insn clobbers REG.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
if|if
condition|(
name|FIND_REG_INC_NOTE
argument_list|(
name|insn
argument_list|,
name|reg
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
comment|/* We'd like to test call_used_regs here, but rtlanal.c can't 		 reference that variable due to its use in genattrtab.  So 		 we'll just be more conservative.  		 ??? Unless we could ensure that the CALL_INSN_FUNCTION_USAGE 		 information holds all clobbered registers.  */
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|MEM
operator|||
name|find_reg_fusage
argument_list|(
name|insn
argument_list|,
name|CLOBBER
argument_list|,
name|reg
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
name|reg_set_reg
operator|=
name|reg
expr_stmt|;
name|reg_set_flag
operator|=
literal|0
expr_stmt|;
name|note_stores
argument_list|(
name|body
argument_list|,
name|reg_set_p_1
argument_list|)
expr_stmt|;
return|return
name|reg_set_flag
return|;
block|}
end_function

begin_comment
comment|/* Similar to reg_set_between_p, but check all registers in X.  Return 0    only if none of them are modified between START and END.  Return 1 if    X contains a MEM; this routine does not perform any memory aliasing.  */
end_comment

begin_function
name|int
name|modified_between_p
parameter_list|(
name|x
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|0
return|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
comment|/* If the memory is not constant, assume it is modified.  If it is 	 constant, we still have to check the address.  */
if|if
condition|(
operator|!
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|REG
case|:
return|return
name|reg_set_between_p
argument_list|(
name|x
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
return|;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|modified_between_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|modified_between_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Similar to reg_set_p, but check all registers in X.  Return 0 only if none    of them are modified in INSN.  Return 1 if X contains a MEM; this routine    does not perform any memory aliasing.  */
end_comment

begin_function
name|int
name|modified_in_p
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|0
return|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
comment|/* If the memory is not constant, assume it is modified.  If it is 	 constant, we still have to check the address.  */
if|if
condition|(
operator|!
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|REG
case|:
return|return
name|reg_set_p
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
return|;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|modified_in_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|modified_in_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an INSN, return a SET expression if this insn has only a single SET.    It may also have CLOBBERs, USEs, or SET whose output    will not be used, which we ignore.  */
end_comment

begin_function
name|rtx
name|single_set
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|set
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
return|return
name|PATTERN
argument_list|(
name|insn
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|set
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
operator|(
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
operator|||
name|side_effects_p
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|set
condition|)
return|return
literal|0
return|;
else|else
name|set
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|set
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the last thing that X was assigned from before *PINSN.  Verify that    the object is not modified up to VALID_TO.  If it was, if we hit    a partial assignment to X, or hit a CODE_LABEL first, return X.  If we    found an assignment, update *PINSN to point to it.  */
end_comment

begin_function
name|rtx
name|find_last_value
parameter_list|(
name|x
parameter_list|,
name|pinsn
parameter_list|,
name|valid_to
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
modifier|*
name|pinsn
decl_stmt|;
name|rtx
name|valid_to
decl_stmt|;
block|{
name|rtx
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|PREV_INSN
argument_list|(
operator|*
name|pinsn
argument_list|)
init|;
name|p
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|CODE_LABEL
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|EXPR_LIST
condition|)
name|src
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|modified_between_p
argument_list|(
name|src
argument_list|,
name|PREV_INSN
argument_list|(
name|p
argument_list|)
argument_list|,
name|valid_to
argument_list|)
comment|/* Reject hard registers because we don't usually want 		   to use them; we'd rather use a pseudo.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
block|{
operator|*
name|pinsn
operator|=
name|p
expr_stmt|;
return|return
name|src
return|;
block|}
block|}
comment|/* If set in non-simple way, we don't have a value.  */
if|if
condition|(
name|reg_set_p
argument_list|(
name|x
argument_list|,
name|p
argument_list|)
condition|)
break|break;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if register in range [REGNO, ENDREGNO)    appears either explicitly or implicitly in X    other than being stored into.     References contained within the substructure at LOC do not count.    LOC may be zero, meaning don't ignore anything.  */
end_comment

begin_function
name|int
name|refers_to_regno_p
parameter_list|(
name|regno
parameter_list|,
name|endregno
parameter_list|,
name|x
parameter_list|,
name|loc
parameter_list|)
name|int
name|regno
decl_stmt|,
name|endregno
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|repeat
label|:
comment|/* The contents of a REG_NONNEG note is always zero, so we must come here      upon repeat in case the last REG_NOTE is a REG_NONNEG note.  */
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
name|i
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If we modifying the stack, frame, or argument pointer, it will 	 clobber a virtual register.  In fact, we could be more precise, 	 but it isn't worth it.  */
if|if
condition|(
operator|(
name|i
operator|==
name|STACK_POINTER_REGNUM
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|||
name|i
operator|==
name|ARG_POINTER_REGNUM
endif|#
directive|endif
operator|||
name|i
operator|==
name|FRAME_POINTER_REGNUM
operator|)
operator|&&
name|regno
operator|>=
name|FIRST_VIRTUAL_REGISTER
operator|&&
name|regno
operator|<=
name|LAST_VIRTUAL_REGISTER
condition|)
return|return
literal|1
return|;
return|return
operator|(
name|endregno
operator|>
name|i
operator|&&
name|regno
operator|<
name|i
operator|+
operator|(
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
literal|1
operator|)
operator|)
return|;
case|case
name|SUBREG
case|:
comment|/* If this is a SUBREG of a hard reg, we can see exactly which 	 registers are being modified.  Otherwise, handle normally.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|inner_regno
init|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|+
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|inner_endregno
init|=
name|inner_regno
operator|+
operator|(
name|inner_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
literal|1
operator|)
decl_stmt|;
return|return
name|endregno
operator|>
name|inner_regno
operator|&&
name|regno
operator|<
name|inner_endregno
return|;
block|}
break|break;
case|case
name|CLOBBER
case|:
case|case
name|SET
case|:
if|if
condition|(
operator|&
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|!=
name|loc
comment|/* Note setting a SUBREG counts as referring to the REG it is in for 	     a pseudo but not for hard registers since we can 	     treat each word individually.  */
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|loc
operator|!=
operator|&
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|loc
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|loc
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|code
operator|==
name|CLOBBER
operator|||
name|loc
operator|==
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
default|default:
break|break;
block|}
comment|/* X does not match, so try its subexpressions.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|loc
operator|!=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
elseif|else
if|if
condition|(
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|loc
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|loc
operator|!=
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|&&
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|loc
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if modifying X will affect IN.  If X is a register or a SUBREG,    we check if any register number in X conflicts with the relevant register    numbers.  If X is a constant, return 0.  If X is a MEM, return 1 iff IN    contains a MEM (we don't bother checking for memory addresses that can't    conflict because we expect this to be a rare case.  */
end_comment

begin_function
name|int
name|reg_overlap_mentioned_p
parameter_list|(
name|x
parameter_list|,
name|in
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|in
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|,
name|endregno
decl_stmt|;
comment|/* Overly conservative.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If either argument is a constant, then modifying X can not affect IN.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|||
name|CONSTANT_P
argument_list|(
name|in
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|regno
operator|+=
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|XEXP
argument_list|(
name|in
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SCRATCH
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PC
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CC0
condition|)
return|return
name|reg_mentioned_p
argument_list|(
name|x
argument_list|,
name|in
argument_list|)
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|endregno
operator|=
name|regno
operator|+
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
literal|1
operator|)
expr_stmt|;
return|return
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|in
argument_list|,
name|NULL_PTR
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Used for communications between the next few functions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_set_last_unknown
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|reg_set_last_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_set_last_first_regno
decl_stmt|,
name|reg_set_last_last_regno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called via note_stores from reg_set_last.  */
end_comment

begin_function
specifier|static
name|void
name|reg_set_last_1
parameter_list|(
name|x
parameter_list|,
name|pat
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
block|{
name|int
name|first
decl_stmt|,
name|last
decl_stmt|;
comment|/* If X is not a register, or is not one in the range we care      about, ignore.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|first
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|last
operator|=
name|first
operator|+
operator|(
name|first
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|HARD_REGNO_NREGS
argument_list|(
name|first
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|first
operator|>=
name|reg_set_last_last_regno
operator|||
name|last
operator|<=
name|reg_set_last_first_regno
condition|)
return|return;
comment|/* If this is a CLOBBER or is some complex LHS, or doesn't modify      exactly the registers we care about, show we don't know the value.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
operator|||
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|!=
name|x
operator|||
name|first
operator|!=
name|reg_set_last_first_regno
operator|||
name|last
operator|!=
name|reg_set_last_last_regno
condition|)
name|reg_set_last_unknown
operator|=
literal|1
expr_stmt|;
else|else
name|reg_set_last_value
operator|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the last value to which REG was set prior to INSN.  If we can't    find it easily, return 0.     We only return a REG, SUBREG, or constant because it is too hard to    check if a MEM remains unchanged.  */
end_comment

begin_function
name|rtx
name|reg_set_last
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|orig_insn
init|=
name|insn
decl_stmt|;
name|reg_set_last_first_regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|reg_set_last_last_regno
operator|=
name|reg_set_last_first_regno
operator|+
operator|(
name|reg_set_last_first_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|HARD_REGNO_NREGS
argument_list|(
name|reg_set_last_first_regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
literal|1
operator|)
expr_stmt|;
name|reg_set_last_unknown
operator|=
literal|0
expr_stmt|;
name|reg_set_last_value
operator|=
literal|0
expr_stmt|;
comment|/* Scan backwards until reg_set_last_1 changed one of the above flags.      Stop when we reach a label or X is a hard reg and we reach a      CALL_INSN (if reg_set_last_last_regno is a hard reg).       If we find a set of X, ensure that its SET_SRC remains unchanged.  */
comment|/* We compare with<= here, because reg_set_last_last_regno      is actually the number of the first reg *not* in X.  */
for|for
control|(
init|;
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|reg_set_last_last_regno
operator|<=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reg_set_last_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_set_last_unknown
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|reg_set_last_value
condition|)
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|reg_set_last_value
argument_list|)
operator|||
operator|(
operator|(
name|GET_CODE
argument_list|(
name|reg_set_last_value
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|reg_set_last_value
argument_list|)
operator|==
name|SUBREG
operator|)
operator|&&
operator|!
name|reg_set_between_p
argument_list|(
name|reg_set_last_value
argument_list|,
name|insn
argument_list|,
name|orig_insn
argument_list|)
operator|)
condition|)
return|return
name|reg_set_last_value
return|;
else|else
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is 1 until after the rtl generation pass.  */
end_comment

begin_decl_stmt
name|int
name|rtx_equal_function_value_matters
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return 1 if X and Y are identical-looking rtx's.    This is the Lisp function EQUAL for rtx arguments.  */
end_comment

begin_function
name|int
name|rtx_equal_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|y
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Rtx's of different codes cannot be equal.  */
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.      (REG:SI x) and (REG:HI x) are NOT equivalent.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* REG, LABEL_REF, and SYMBOL_REF can be compared nonrecursively.  */
if|if
condition|(
name|code
operator|==
name|REG
condition|)
comment|/* Until rtl generation is complete, don't consider a reference to the        return register of the current function the same as the return from a        called function.  This eases the job of function integration.  Once the        distinction is no longer needed, they can be considered equivalent.  */
return|return
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|REGNO
argument_list|(
name|y
argument_list|)
operator|&&
operator|(
operator|!
name|rtx_equal_function_value_matters
operator|||
name|REG_FUNCTION_VALUE_P
argument_list|(
name|x
argument_list|)
operator|==
name|REG_FUNCTION_VALUE_P
argument_list|(
name|y
argument_list|)
operator|)
operator|)
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|LABEL_REF
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|SYMBOL_REF
condition|)
return|return
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|SCRATCH
operator|||
name|code
operator|==
name|CONST_DOUBLE
condition|)
return|return
literal|0
return|;
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole things.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'w'
case|:
if|if
condition|(
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XWINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'n'
case|:
case|case
literal|'i'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'V'
case|:
case|case
literal|'E'
case|:
comment|/* Two vectors must have the same length.  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* And the corresponding elements must match.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'u'
case|:
comment|/* These are just backpointers, so they don't matter.  */
break|break;
case|case
literal|'0'
case|:
break|break;
comment|/* It is believed that rtx's at this level will never 	     contain anything but integers and other rtx's, 	     except for within LABEL_REFs and SYMBOL_REFs.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call FUN on each register or MEM that is stored into or clobbered by X.    (X would be the pattern of an insn).    FUN receives two arguments:      the REG, MEM, CC0 or PC being stored in or clobbered,      the SET or CLOBBER rtx that does the store.    If the item being stored in or clobbered is a SUBREG of a hard register,   the SUBREG will be passed.  */
end_comment

begin_decl_stmt
name|void
name|note_stores
argument_list|(
name|x
argument_list|,
name|fun
argument_list|)
decl|register
name|rtx
name|x
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|fun
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
operator|)
condition|)
block|{
specifier|register
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|fun
call|)
argument_list|(
name|dest
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
specifier|register
name|rtx
name|y
init|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
specifier|register
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|y
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|fun
call|)
argument_list|(
name|dest
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if X's old contents don't survive after INSN.    This will be true if X is (cc0) or if X is a register and    X dies in INSN or because INSN entirely sets X.     "Entirely set" means set directly and not through a SUBREG,    ZERO_EXTRACT or SIGN_EXTRACT, so no trace of the old contents remains.    Likewise, REG_INC does not count.     REG may be a hard or pseudo reg.  Renumbering is not taken into account,    but for this use that makes no difference, since regs don't overlap    during their lifetimes.  Therefore, this function may be used    at any time after deaths have been computed (in flow.c).     If REG is a hard reg that occupies multiple machine registers, this    function will only return 1 if each of those registers will be replaced    by INSN.  */
end_comment

begin_function
name|int
name|dead_or_set_p
parameter_list|(
name|insn
parameter_list|,
name|x
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|,
name|last_regno
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Can't use cc0_rtx below since this file is used by genattrtab.c.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CC0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|last_regno
operator|=
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
name|regno
else|:
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<=
name|last_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|dead_or_set_regno_p
argument_list|(
name|insn
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Utility function for dead_or_set_p to check an individual register.  Also    called from flow.c.  */
end_comment

begin_function
name|int
name|dead_or_set_regno_p
parameter_list|(
name|insn
parameter_list|,
name|test_regno
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|test_regno
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|,
name|endregno
decl_stmt|;
name|rtx
name|link
decl_stmt|;
comment|/* REG_READ notes are not normally maintained after reload, so we      ignore them if the are invalid.  */
if|if
condition|(
operator|!
name|reload_completed
ifdef|#
directive|ifdef
name|PRESERVE_DEATH_INFO_REGNO_P
operator|||
name|PRESERVE_DEATH_INFO_REGNO_P
argument_list|(
name|test_regno
argument_list|)
endif|#
directive|endif
condition|)
block|{
comment|/* See if there is a death note for something that includes          TEST_REGNO.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
name|REG_DEAD
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
continue|continue;
name|regno
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|endregno
operator|=
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
name|regno
operator|+
literal|1
else|:
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|test_regno
operator|>=
name|regno
operator|&&
name|test_regno
operator|<
name|endregno
condition|)
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|find_regno_fusage
argument_list|(
name|insn
argument_list|,
name|CLOBBER
argument_list|,
name|test_regno
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
comment|/* A value is totally replaced if it is the destination or the 	 destination is a SUBREG of REGNO that does not change the number of 	 words in it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|==
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|endregno
operator|=
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
name|regno
operator|+
literal|1
else|:
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|test_regno
operator|>=
name|regno
operator|&&
name|test_regno
operator|<
name|endregno
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|body
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|==
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
condition|)
continue|continue;
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|endregno
operator|=
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
name|regno
operator|+
literal|1
else|:
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|test_regno
operator|>=
name|regno
operator|&&
name|test_regno
operator|<
name|endregno
condition|)
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the reg-note of kind KIND in insn INSN, if there is one.    If DATUM is nonzero, look for one whose datum is DATUM.  */
end_comment

begin_function
name|rtx
name|find_reg_note
parameter_list|(
name|insn
parameter_list|,
name|kind
parameter_list|,
name|datum
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|enum
name|reg_note
name|kind
decl_stmt|;
name|rtx
name|datum
decl_stmt|;
block|{
specifier|register
name|rtx
name|link
decl_stmt|;
comment|/* Ignore anything that is not an INSN, JUMP_INSN or CALL_INSN.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
return|return
literal|0
return|;
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|kind
operator|&&
operator|(
name|datum
operator|==
literal|0
operator|||
name|datum
operator|==
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|link
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the reg-note of kind KIND in insn INSN which applies to register    number REGNO, if any.  Return 0 if there is no such reg-note.  Note that    the REGNO of this NOTE need not be REGNO if REGNO is a hard register;    it might be the case that the note overlaps REGNO.  */
end_comment

begin_function
name|rtx
name|find_regno_note
parameter_list|(
name|insn
parameter_list|,
name|kind
parameter_list|,
name|regno
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|enum
name|reg_note
name|kind
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
specifier|register
name|rtx
name|link
decl_stmt|;
comment|/* Ignore anything that is not an INSN, JUMP_INSN or CALL_INSN.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
return|return
literal|0
return|;
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|kind
comment|/* Verify that it is a register, so that scratch and MEM won't cause a 	   problem here.  */
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
name|regno
operator|&&
operator|(
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|+
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|>
name|regno
operator|)
condition|)
return|return
name|link
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if DATUM, or any overlap of DATUM, of kind CODE is found    in the CALL_INSN_FUNCTION_USAGE information of INSN.  */
end_comment

begin_function
name|int
name|find_reg_fusage
parameter_list|(
name|insn
parameter_list|,
name|code
parameter_list|,
name|datum
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|datum
decl_stmt|;
block|{
comment|/* If it's not a CALL_INSN, it can't possibly have a      CALL_INSN_FUNCTION_USAGE field, so don't bother checking.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CALL_INSN
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|datum
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|datum
argument_list|)
operator|!=
name|REG
condition|)
block|{
specifier|register
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|code
operator|&&
name|rtx_equal_p
argument_list|(
name|datum
argument_list|,
name|SET_DEST
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|datum
argument_list|)
decl_stmt|;
comment|/* CALL_INSN_FUNCTION_USAGE information cannot contain references 	 to pseudo registers, so don't bother checking.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|end_regno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|datum
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|end_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|find_regno_fusage
argument_list|(
name|insn
argument_list|,
name|code
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if REGNO, or any overlap of REGNO, of kind CODE is found    in the CALL_INSN_FUNCTION_USAGE information of INSN.  */
end_comment

begin_function
name|int
name|find_regno_fusage
parameter_list|(
name|insn
parameter_list|,
name|code
parameter_list|,
name|regno
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
specifier|register
name|rtx
name|link
decl_stmt|;
comment|/* CALL_INSN_FUNCTION_USAGE information cannot contain references      to pseudo registers, so don't bother checking.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CALL_INSN
condition|)
return|return
literal|0
return|;
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
specifier|register
name|int
name|regnote
decl_stmt|;
specifier|register
name|rtx
name|op
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|code
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|regnote
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|<=
name|regno
operator|&&
name|regnote
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regnote
argument_list|,
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|)
operator|>
name|regno
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remove register note NOTE from the REG_NOTES of INSN.  */
end_comment

begin_function
name|void
name|remove_note
parameter_list|(
name|insn
parameter_list|,
name|note
parameter_list|)
specifier|register
name|rtx
name|note
decl_stmt|;
specifier|register
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|link
decl_stmt|;
if|if
condition|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|==
name|note
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|==
name|note
condition|)
block|{
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if X contains any volatile instructions.  These are instructions    which may cause unpredictable machine state instructions, and thus no    instructions should be moved or combined across them.  This includes    only volatile asms and UNSPEC_VOLATILE instructions.  */
end_comment

begin_function
name|int
name|volatile_insn_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|REG
case|:
case|case
name|SCRATCH
case|:
case|case
name|CLOBBER
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
case|case
name|CALL
case|:
case|case
name|MEM
case|:
return|return
literal|0
return|;
case|case
name|UNSPEC_VOLATILE
case|:
comment|/* case TRAP_IF: This isn't clear yet.  */
return|return
literal|1
return|;
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
default|default:
break|break;
block|}
comment|/* Recursively scan the operands of this expression.  */
block|{
specifier|register
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|volatile_insn_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|volatile_insn_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if X contains any volatile memory references    UNSPEC_VOLATILE operations or volatile ASM_OPERANDS expressions.  */
end_comment

begin_function
name|int
name|volatile_refs_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|REG
case|:
case|case
name|SCRATCH
case|:
case|case
name|CLOBBER
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return
literal|0
return|;
case|case
name|CALL
case|:
case|case
name|UNSPEC_VOLATILE
case|:
comment|/* case TRAP_IF: This isn't clear yet.  */
return|return
literal|1
return|;
case|case
name|MEM
case|:
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
default|default:
break|break;
block|}
comment|/* Recursively scan the operands of this expression.  */
block|{
specifier|register
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|volatile_refs_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|volatile_refs_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Similar to above, except that it also rejects register pre- and post-    incrementing.  */
end_comment

begin_function
name|int
name|side_effects_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|REG
case|:
case|case
name|SCRATCH
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return
literal|0
return|;
case|case
name|CLOBBER
case|:
comment|/* Reject CLOBBER with a non-VOID mode.  These are made by combine.c 	 when some combination can't be done.  If we see one, don't think 	 that we can simplify the expression.  */
return|return
operator|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
operator|)
return|;
case|case
name|PRE_INC
case|:
case|case
name|PRE_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|CALL
case|:
case|case
name|UNSPEC_VOLATILE
case|:
comment|/* case TRAP_IF: This isn't clear yet.  */
return|return
literal|1
return|;
case|case
name|MEM
case|:
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
default|default:
break|break;
block|}
comment|/* Recursively scan the operands of this expression.  */
block|{
specifier|register
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|side_effects_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|side_effects_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if evaluating rtx X might cause a trap.  */
end_comment

begin_function
name|int
name|may_trap_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Handle these cases quickly.  */
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|REG
case|:
case|case
name|SCRATCH
case|:
return|return
literal|0
return|;
comment|/* Conditional trap can trap!  */
case|case
name|UNSPEC_VOLATILE
case|:
case|case
name|TRAP_IF
case|:
return|return
literal|1
return|;
comment|/* Memory ref can trap unless it's a static var or a stack slot.  */
case|case
name|MEM
case|:
return|return
name|rtx_addr_can_trap_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Division by a non-constant might trap.  */
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
literal|1
return|;
comment|/* This was const0_rtx, but by not using that, 	 we can link this file into other programs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|EXPR_LIST
case|:
comment|/* An EXPR_LIST is used to represent a function call.  This 	 certainly may trap.  */
return|return
literal|1
return|;
default|default:
comment|/* Any floating arithmetic may trap.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
literal|1
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|may_trap_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|may_trap_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if X contains a comparison that is not either EQ or NE,    i.e., an inequality.  */
end_comment

begin_function
name|int
name|inequality_comparisons_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|SCRATCH
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
return|return
literal|0
return|;
case|case
name|LT
case|:
case|case
name|LTU
case|:
case|case
name|GT
case|:
case|case
name|GTU
case|:
case|case
name|LE
case|:
case|case
name|LEU
case|:
case|case
name|GE
case|:
case|case
name|GEU
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|inequality_comparisons_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|inequality_comparisons_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Replace any occurrence of FROM in X with TO.  The function does    not enter into CONST_DOUBLE for the replace.     Note that copying is not done so X must not be shared unless all copies    are to be modified.  */
end_comment

begin_function
name|rtx
name|replace_rtx
parameter_list|(
name|x
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* The following prevents loops occurrence when we change MEM in      CONST_DOUBLE onto the same CONST_DOUBLE. */
if|if
condition|(
name|x
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
name|x
return|;
if|if
condition|(
name|x
operator|==
name|from
condition|)
return|return
name|to
return|;
comment|/* Allow this function to make replacements in EXPR_LISTs.  */
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|replace_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Throughout the rtx X, replace many registers according to REG_MAP.    Return the replacement for X (which may be X with altered contents).    REG_MAP[R] is the replacement for register R, or 0 for don't replace.    NREGS is the length of REG_MAP; regs>= NREGS are not mapped.       We only support REG_MAP entries of REG or SUBREG.  Also, hard registers    should not be mapped to pseudos or vice versa since validate_change    is not called.     If REPLACE_DEST is 1, replacements are also done in destinations;    otherwise, only sources are replaced.  */
end_comment

begin_function
name|rtx
name|replace_regs
parameter_list|(
name|x
parameter_list|,
name|reg_map
parameter_list|,
name|nregs
parameter_list|,
name|replace_dest
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
modifier|*
name|reg_map
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|int
name|replace_dest
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|x
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SCRATCH
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
name|x
return|;
case|case
name|REG
case|:
comment|/* Verify that the register has an entry before trying to access it.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|nregs
operator|&&
name|reg_map
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* SUBREGs can't be shared.  Always return a copy to ensure that if 	     this replacement occurs more than once then each instance will 	     get distinct rtx.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg_map
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
return|return
name|copy_rtx
argument_list|(
name|reg_map
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
return|;
return|return
name|reg_map
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
return|;
block|}
return|return
name|x
return|;
case|case
name|SUBREG
case|:
comment|/* Prevent making nested SUBREGs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|nregs
operator|&&
name|reg_map
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reg_map
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|rtx
name|map_val
init|=
name|reg_map
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
decl_stmt|;
name|rtx
name|map_inner
init|=
name|SUBREG_REG
argument_list|(
name|map_val
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|map_inner
argument_list|)
condition|)
return|return
name|map_inner
return|;
else|else
block|{
comment|/* We cannot call gen_rtx here since we may be linked with 		 genattrtab.c.  */
comment|/* Let's try clobbering the incoming SUBREG and see 		 if this is really safe.  */
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
operator|=
name|map_inner
expr_stmt|;
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|+=
name|SUBREG_WORD
argument_list|(
name|map_val
argument_list|)
expr_stmt|;
return|return
name|x
return|;
if|#
directive|if
literal|0
block|rtx new = rtx_alloc (SUBREG); 	      PUT_MODE (new, GET_MODE (x)); 	      SUBREG_REG (new) = map_inner; 	      SUBREG_WORD (new) = SUBREG_WORD (x) + SUBREG_WORD (map_val);
endif|#
directive|endif
block|}
block|}
break|break;
case|case
name|SET
case|:
if|if
condition|(
name|replace_dest
condition|)
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|=
name|replace_regs
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|nregs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
comment|/* Even if we are not to replace destinations, replace register if it 	   is CONTAINED in destination (destination is memory or 	   STRICT_LOW_PART).  */
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|replace_regs
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|nregs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
comment|/* Similarly, for ZERO_EXTRACT we replace all operands.  */
break|break;
name|SET_SRC
argument_list|(
name|x
argument_list|)
operator|=
name|replace_regs
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|nregs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|x
return|;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|replace_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|nregs
argument_list|,
name|replace_dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|replace_regs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|nregs
argument_list|,
name|replace_dest
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X, the SRC_SRC of  SET of (pc) contain a REG or MEM that is    not in the constant pool and not in the condition of an IF_THEN_ELSE.  */
end_comment

begin_function
specifier|static
name|int
name|jmp_uses_reg_or_mem
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
case|case
name|PC
case|:
return|return
literal|0
return|;
case|case
name|REG
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
return|return
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|IF_THEN_ELSE
case|:
return|return
operator|(
name|jmp_uses_reg_or_mem
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|jmp_uses_reg_or_mem
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|MULT
case|:
return|return
operator|(
name|jmp_uses_reg_or_mem
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|jmp_uses_reg_or_mem
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|jmp_uses_reg_or_mem
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|jmp_uses_reg_or_mem
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if INSN is an indirect jump (aka computed jump).     Tablejumps and casesi insns are not considered indirect jumps;    we can recognize them by a (use (lael_ref)).  */
end_comment

begin_function
name|int
name|computed_jump_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|has_use_labelref
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
condition|)
name|has_use_labelref
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|has_use_labelref
condition|)
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|jmp_uses_reg_or_mem
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|jmp_uses_reg_or_mem
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

