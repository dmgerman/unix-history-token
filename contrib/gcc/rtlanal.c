begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Analyze RTL for C-Compiler    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_comment
comment|/* Forward declarations */
end_comment

begin_function_decl
specifier|static
name|int
name|global_reg_mentioned_p_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_of_1
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|insn_dependent_p_1
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rtx_referenced_p_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|computed_jump_p_1
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parms_set
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|hoist_test_store
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|regset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hoist_update_store
parameter_list|(
name|rtx
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Bit flags that specify the machine subtype we are compiling for.    Bits are tested using macros TARGET_... defined in the tm.h file    and set by `-m...' switches.  Must be defined in rtlanal.c.  */
end_comment

begin_decl_stmt
name|int
name|target_flags
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return 1 if the value of X is unstable    (would be different at a different point in the program).    The frame pointer, arg pointer, etc. are considered stable    (within one function) and so is anything marked `unchanging'.  */
end_comment

begin_function
name|int
name|rtx_unstable_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MEM
case|:
return|return
operator|!
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|||
name|rtx_unstable_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|QUEUED
case|:
return|return
literal|1
return|;
case|case
name|ADDRESSOF
case|:
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|0
return|;
case|case
name|REG
case|:
comment|/* As in rtx_varies_p, we have to use the actual rtx, not reg number.  */
if|if
condition|(
name|x
operator|==
name|frame_pointer_rtx
operator|||
name|x
operator|==
name|hard_frame_pointer_rtx
comment|/* The arg pointer varies if it is not a fixed register.  */
operator|||
operator|(
name|x
operator|==
name|arg_pointer_rtx
operator|&&
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
operator|)
operator|||
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
ifndef|#
directive|ifndef
name|PIC_OFFSET_TABLE_REG_CALL_CLOBBERED
comment|/* ??? When call-clobbered, the value is stable modulo the restore 	 that must happen after a call.  This currently screws up local-alloc 	 into believing that the restore is not needed.  */
if|if
condition|(
name|x
operator|==
name|pic_offset_table_rtx
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
return|return
literal|1
return|;
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Fall through.  */
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|rtx_unstable_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|rtx_unstable_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X has a value that can vary even between two    executions of the program.  0 means X can be compared reliably    against certain constants or near-constants.    FOR_ALIAS is nonzero if we are called from alias analysis; if it is    zero, we are slightly more conservative.    The frame pointer and the arg pointer are considered constant.  */
end_comment

begin_function
name|int
name|rtx_varies_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|for_alias
parameter_list|)
block|{
name|RTX_CODE
name|code
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MEM
case|:
return|return
operator|!
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|||
name|rtx_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|for_alias
argument_list|)
return|;
case|case
name|QUEUED
case|:
return|return
literal|1
return|;
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|0
return|;
case|case
name|ADDRESSOF
case|:
comment|/* This will resolve to some offset from the frame pointer.  */
return|return
literal|0
return|;
case|case
name|REG
case|:
comment|/* Note that we have to test for the actual rtx used for the frame 	 and arg pointers and not just the register number in case we have 	 eliminated the frame and/or arg pointer and are using it 	 for pseudos.  */
if|if
condition|(
name|x
operator|==
name|frame_pointer_rtx
operator|||
name|x
operator|==
name|hard_frame_pointer_rtx
comment|/* The arg pointer varies if it is not a fixed register.  */
operator|||
operator|(
name|x
operator|==
name|arg_pointer_rtx
operator|&&
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|x
operator|==
name|pic_offset_table_rtx
ifdef|#
directive|ifdef
name|PIC_OFFSET_TABLE_REG_CALL_CLOBBERED
comment|/* ??? When call-clobbered, the value is stable modulo the restore 	     that must happen after a call.  This currently screws up 	     local-alloc into believing that the restore is not needed, so we 	     must return 0 only if we are called from alias analysis.  */
operator|&&
name|for_alias
endif|#
directive|endif
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|LO_SUM
case|:
comment|/* The operand 0 of a LO_SUM is considered constant 	 (in fact it is related specifically to operand 1) 	 during alias analysis.  */
return|return
operator|(
operator|!
name|for_alias
operator|&&
name|rtx_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|for_alias
argument_list|)
operator|)
operator|||
name|rtx_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|for_alias
argument_list|)
return|;
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Fall through.  */
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|rtx_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|for_alias
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|rtx_varies_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|for_alias
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 0 if the use of X as an address in a MEM can cause a trap.  */
end_comment

begin_function
name|int
name|rtx_addr_can_trap_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
return|return
name|SYMBOL_REF_WEAK
argument_list|(
name|x
argument_list|)
return|;
case|case
name|LABEL_REF
case|:
return|return
literal|0
return|;
case|case
name|ADDRESSOF
case|:
comment|/* This will resolve to some offset from the frame pointer.  */
return|return
literal|0
return|;
case|case
name|REG
case|:
comment|/* As in rtx_varies_p, we have to use the actual rtx, not reg number.  */
if|if
condition|(
name|x
operator|==
name|frame_pointer_rtx
operator|||
name|x
operator|==
name|hard_frame_pointer_rtx
operator|||
name|x
operator|==
name|stack_pointer_rtx
comment|/* The arg pointer varies if it is not a fixed register.  */
operator|||
operator|(
name|x
operator|==
name|arg_pointer_rtx
operator|&&
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
operator|)
condition|)
return|return
literal|0
return|;
comment|/* All of the virtual frame registers are stack references.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_VIRTUAL_REGISTER
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|CONST
case|:
return|return
name|rtx_addr_can_trap_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|PLUS
case|:
comment|/* An address is assumed not to trap if it is an address that can't 	 trap plus a constant integer or it is the pic register plus a 	 constant.  */
return|return
operator|!
operator|(
operator|(
operator|!
name|rtx_addr_can_trap_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|||
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|pic_offset_table_rtx
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
return|;
case|case
name|LO_SUM
case|:
case|case
name|PRE_MODIFY
case|:
return|return
name|rtx_addr_can_trap_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|PRE_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|POST_MODIFY
case|:
return|return
name|rtx_addr_can_trap_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
comment|/* If it isn't one of the case above, it can cause a trap.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return true if X is an address that is known to not be zero.  */
end_comment

begin_function
name|bool
name|nonzero_address_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
return|return
operator|!
name|SYMBOL_REF_WEAK
argument_list|(
name|x
argument_list|)
return|;
case|case
name|LABEL_REF
case|:
return|return
name|true
return|;
case|case
name|ADDRESSOF
case|:
comment|/* This will resolve to some offset from the frame pointer.  */
return|return
name|true
return|;
case|case
name|REG
case|:
comment|/* As in rtx_varies_p, we have to use the actual rtx, not reg number.  */
if|if
condition|(
name|x
operator|==
name|frame_pointer_rtx
operator|||
name|x
operator|==
name|hard_frame_pointer_rtx
operator|||
name|x
operator|==
name|stack_pointer_rtx
operator|||
operator|(
name|x
operator|==
name|arg_pointer_rtx
operator|&&
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
operator|)
condition|)
return|return
name|true
return|;
comment|/* All of the virtual frame registers are stack references.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_VIRTUAL_REGISTER
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
case|case
name|CONST
case|:
return|return
name|nonzero_address_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|PLUS
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
comment|/* Pointers aren't allowed to wrap.  If we've got a register 	     that is known to be a pointer, and a positive offset, then 	     the composite can't be zero.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|REG_POINTER
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|nonzero_address_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* Handle PIC references.  */
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|pic_offset_table_rtx
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
case|case
name|PRE_MODIFY
case|:
comment|/* Similar to the above; allow positive offsets.  Further, since 	 auto-inc is only allowed in memories, the register must be a 	 pointer.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
return|return
name|true
return|;
return|return
name|nonzero_address_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|PRE_INC
case|:
comment|/* Similarly.  Further, the offset is always positive.  */
return|return
name|true
return|;
case|case
name|PRE_DEC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|POST_MODIFY
case|:
return|return
name|nonzero_address_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|LO_SUM
case|:
return|return
name|nonzero_address_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
comment|/* If it isn't one of the case above, might be zero.  */
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X refers to a memory location whose address    cannot be compared reliably with constant addresses,    or if X refers to a BLKmode memory object.    FOR_ALIAS is nonzero if we are called from alias analysis; if it is    zero, we are slightly more conservative.  */
end_comment

begin_function
name|int
name|rtx_addr_varies_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|for_alias
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
return|return
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
operator|||
name|rtx_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|for_alias
argument_list|)
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|rtx_addr_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|for_alias
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|rtx_addr_varies_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|for_alias
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the value of the integer term in X, if one is apparent;    otherwise return 0.    Only obvious integer terms are detected.    This is used in cse.c with the `related_value' field.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|get_integer_term
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If X is a constant, return the value sans apparent integer term;    otherwise return 0.    Only obvious integer terms are detected.  */
end_comment

begin_function
name|rtx
name|get_related_value
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a tablejump insn INSN, return the RTL expression for the offset    into the jump table.  If the offset cannot be determined, then return    NULL_RTX.     If EARLIEST is nonzero, it is a pointer to a place where the earliest    insn used in locating the offset was found.  */
end_comment

begin_function
name|rtx
name|get_jump_table_offset
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
modifier|*
name|earliest
parameter_list|)
block|{
name|rtx
name|label
decl_stmt|;
name|rtx
name|table
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|rtx
name|old_insn
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
name|old_x
decl_stmt|;
name|rtx
name|y
decl_stmt|;
name|rtx
name|old_y
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|tablejump_p
argument_list|(
name|insn
argument_list|,
operator|&
name|label
argument_list|,
operator|&
name|table
argument_list|)
operator|||
operator|!
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
return|return
name|NULL_RTX
return|;
name|x
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
comment|/* Some targets (eg, ARM) emit a tablejump that also      contains the out-of-range target.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Search backwards and locate the expression stored in X.  */
for|for
control|(
name|old_x
operator|=
name|NULL_RTX
init|;
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|x
operator|!=
name|old_x
condition|;
name|old_x
operator|=
name|x
operator|,
name|x
operator|=
name|find_last_value
argument_list|(
name|x
argument_list|,
operator|&
name|insn
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
comment|/* If X is an expression using a relative address then strip      off the addition / subtraction of PC, PIC_OFFSET_TABLE_REGNUM,      or the jump table label.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|table
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|old_insn
operator|=
name|insn
expr_stmt|;
name|y
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
name|pc_rtx
operator|||
name|y
operator|==
name|pic_offset_table_rtx
condition|)
break|break;
for|for
control|(
name|old_y
operator|=
name|NULL_RTX
init|;
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|REG
operator|&&
name|y
operator|!=
name|old_y
condition|;
name|old_y
operator|=
name|y
operator|,
name|y
operator|=
name|find_last_value
argument_list|(
name|y
argument_list|,
operator|&
name|old_insn
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
operator|==
name|label
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
literal|2
condition|)
return|return
name|NULL_RTX
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
operator|-
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|old_x
operator|=
name|NULL_RTX
init|;
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|x
operator|!=
name|old_x
condition|;
name|old_x
operator|=
name|x
operator|,
name|x
operator|=
name|find_last_value
argument_list|(
name|x
argument_list|,
operator|&
name|insn
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
block|}
comment|/* Strip off any sign or zero extension.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTEND
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|old_x
operator|=
name|NULL_RTX
init|;
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|x
operator|!=
name|old_x
condition|;
name|old_x
operator|=
name|x
operator|,
name|x
operator|=
name|find_last_value
argument_list|(
name|x
argument_list|,
operator|&
name|insn
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
block|}
comment|/* If X isn't a MEM then this isn't a tablejump we understand.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Strip off the MEM.  */
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|old_x
operator|=
name|NULL_RTX
init|;
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|x
operator|!=
name|old_x
condition|;
name|old_x
operator|=
name|x
operator|,
name|x
operator|=
name|find_last_value
argument_list|(
name|x
argument_list|,
operator|&
name|insn
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
comment|/* If X isn't a PLUS than this isn't a tablejump we understand.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
name|NULL_RTX
return|;
comment|/* At this point we should have an expression representing the jump table      plus an offset.  Examine each operand in order to determine which one      represents the jump table.  Knowing that tells us that the other operand      must represent the offset.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|old_insn
operator|=
name|insn
expr_stmt|;
name|y
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|old_y
operator|=
name|NULL_RTX
init|;
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|REG
operator|&&
name|y
operator|!=
name|old_y
condition|;
name|old_y
operator|=
name|y
operator|,
name|y
operator|=
name|find_last_value
argument_list|(
name|y
argument_list|,
operator|&
name|old_insn
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|label
argument_list|,
name|y
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
literal|2
condition|)
return|return
name|NULL_RTX
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
operator|-
name|i
argument_list|)
expr_stmt|;
comment|/* Strip off the addition / subtraction of PIC_OFFSET_TABLE_REGNUM.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|==
name|pic_offset_table_rtx
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
operator|-
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|earliest
condition|)
operator|*
name|earliest
operator|=
name|insn
expr_stmt|;
comment|/* Return the RTL expression representing the offset.  */
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A subroutine of global_reg_mentioned_p, returns 1 if *LOC mentions    a global register.  */
end_comment

begin_function
specifier|static
name|int
name|global_reg_mentioned_p_1
parameter_list|(
name|rtx
modifier|*
name|loc
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|SUBREG
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|global_regs
index|[
name|subreg_regno
argument_list|(
name|x
argument_list|)
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|REG
case|:
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|global_regs
index|[
name|regno
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|SCRATCH
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|0
return|;
case|case
name|CALL
case|:
comment|/* A non-constant call might use a global register.  */
return|return
literal|1
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if X mentions a global register.  */
end_comment

begin_function
name|int
name|global_reg_mentioned_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
operator|!
name|CONST_OR_PURE_CALL_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
name|x
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
name|x
operator|=
name|PATTERN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
return|return
name|for_each_rtx
argument_list|(
operator|&
name|x
argument_list|,
name|global_reg_mentioned_p_1
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the number of places FIND appears within X.  If COUNT_DEST is    zero, we do not count occurrences inside the destination of a SET.  */
end_comment

begin_function
name|int
name|count_occurrences
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|find
parameter_list|,
name|int
name|count_dest
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|find
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
literal|0
return|;
case|case
name|MEM
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|find
argument_list|)
operator|==
name|MEM
operator|&&
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|find
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|SET
case|:
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|find
operator|&&
operator|!
name|count_dest
condition|)
return|return
name|count_occurrences
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|find
argument_list|,
name|count_dest
argument_list|)
return|;
break|break;
default|default:
break|break;
block|}
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|count
operator|+=
name|count_occurrences
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|find
argument_list|,
name|count_dest
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|count
operator|+=
name|count_occurrences
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|find
argument_list|,
name|count_dest
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|count
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if register REG appears somewhere within IN.    Also works if REG is not a register; in this case it checks    for a subexpression of IN that is Lisp "equal" to REG.  */
end_comment

begin_function
name|int
name|reg_mentioned_p
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|in
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|in
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|reg
operator|==
name|in
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
name|reg
operator|==
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|in
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Compare registers by number.  */
case|case
name|REG
case|:
return|return
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|in
argument_list|)
operator|==
name|REGNO
argument_list|(
name|reg
argument_list|)
return|;
comment|/* These codes have no constituent expressions 	 and are unique.  */
case|case
name|SCRATCH
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
return|return
literal|0
return|;
case|case
name|CONST_INT
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|CONST_DOUBLE
case|:
comment|/* These are kept unique for a given value.  */
return|return
literal|0
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|code
operator|&&
name|rtx_equal_p
argument_list|(
name|reg
argument_list|,
name|in
argument_list|)
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|in
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|XVECEXP
argument_list|(
name|in
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|XEXP
argument_list|(
name|in
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if in between BEG and END, exclusive of BEG and END, there is    no CODE_LABEL insn.  */
end_comment

begin_function
name|int
name|no_labels_between_p
parameter_list|(
name|rtx
name|beg
parameter_list|,
name|rtx
name|end
parameter_list|)
block|{
name|rtx
name|p
decl_stmt|;
if|if
condition|(
name|beg
operator|==
name|end
condition|)
return|return
literal|0
return|;
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|beg
argument_list|)
init|;
name|p
operator|!=
name|end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if in between BEG and END, exclusive of BEG and END, there is    no JUMP_INSN insn.  */
end_comment

begin_function
name|int
name|no_jumps_between_p
parameter_list|(
name|rtx
name|beg
parameter_list|,
name|rtx
name|end
parameter_list|)
block|{
name|rtx
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|beg
argument_list|)
init|;
name|p
operator|!=
name|end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if register REG is used in an insn between    FROM_INSN and TO_INSN (exclusive of those two).  */
end_comment

begin_function
name|int
name|reg_used_between_p
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|from_insn
parameter_list|,
name|rtx
name|to_insn
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|from_insn
operator|==
name|to_insn
condition|)
return|return
literal|0
return|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|from_insn
argument_list|)
init|;
name|insn
operator|!=
name|to_insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
operator|(
name|find_reg_fusage
argument_list|(
name|insn
argument_list|,
name|USE
argument_list|,
name|reg
argument_list|)
operator|||
name|find_reg_fusage
argument_list|(
name|insn
argument_list|,
name|CLOBBER
argument_list|,
name|reg
argument_list|)
operator|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if the old value of X, a register, is referenced in BODY.  If X    is entirely replaced by a new value and the only use is as a SET_DEST,    we do not consider it a reference.  */
end_comment

begin_function
name|int
name|reg_referenced_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|body
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
condition|)
block|{
case|case
name|SET
case|:
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If the destination is anything other than CC0, PC, a REG or a SUBREG 	 of a REG that occupies all of the REG, the insn references X if 	 it is mentioned in the destination.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|!=
name|CC0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|!=
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|==
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
operator|)
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|ASM_OPERANDS
case|:
for|for
control|(
name|i
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|body
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|ASM_OPERANDS_INPUT
argument_list|(
name|body
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|CALL
case|:
case|case
name|USE
case|:
case|case
name|IF_THEN_ELSE
case|:
return|return
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|body
argument_list|)
return|;
case|case
name|TRAP_IF
case|:
return|return
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|TRAP_CONDITION
argument_list|(
name|body
argument_list|)
argument_list|)
return|;
case|case
name|PREFETCH
case|:
return|return
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|UNSPEC
case|:
case|case
name|UNSPEC_VOLATILE
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|PARALLEL
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|reg_referenced_p
argument_list|(
name|x
argument_list|,
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|CLOBBER
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|COND_EXEC
case|:
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|COND_EXEC_TEST
argument_list|(
name|body
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|reg_referenced_p
argument_list|(
name|x
argument_list|,
name|COND_EXEC_CODE
argument_list|(
name|body
argument_list|)
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Nonzero if register REG is referenced in an insn between    FROM_INSN and TO_INSN (exclusive of those two).  Sets of REG do    not count.  */
end_comment

begin_function
name|int
name|reg_referenced_between_p
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|from_insn
parameter_list|,
name|rtx
name|to_insn
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|from_insn
operator|==
name|to_insn
condition|)
return|return
literal|0
return|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|from_insn
argument_list|)
init|;
name|insn
operator|!=
name|to_insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|reg_referenced_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|find_reg_fusage
argument_list|(
name|insn
argument_list|,
name|USE
argument_list|,
name|reg
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if register REG is set or clobbered in an insn between    FROM_INSN and TO_INSN (exclusive of those two).  */
end_comment

begin_function
name|int
name|reg_set_between_p
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|from_insn
parameter_list|,
name|rtx
name|to_insn
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|from_insn
operator|==
name|to_insn
condition|)
return|return
literal|0
return|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|from_insn
argument_list|)
init|;
name|insn
operator|!=
name|to_insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|reg_set_p
argument_list|(
name|reg
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Internals of reg_set_between_p.  */
end_comment

begin_function
name|int
name|reg_set_p
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
comment|/* We can be passed an insn or part of one.  If we are passed an insn,      check if a side-effect of the insn clobbers REG.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|FIND_REG_INC_NOTE
argument_list|(
name|insn
argument_list|,
name|reg
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
comment|/* We'd like to test call_used_regs here, but rtlanal.c can't 		 reference that variable due to its use in genattrtab.  So 		 we'll just be more conservative.  		 ??? Unless we could ensure that the CALL_INSN_FUNCTION_USAGE 		 information holds all clobbered registers.  */
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|MEM
operator|||
name|find_reg_fusage
argument_list|(
name|insn
argument_list|,
name|CLOBBER
argument_list|,
name|reg
argument_list|)
operator|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
name|set_of
argument_list|(
name|reg
argument_list|,
name|insn
argument_list|)
operator|!=
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Similar to reg_set_between_p, but check all registers in X.  Return 0    only if none of them are modified between START and END.  Do not    consider non-registers one way or the other.  */
end_comment

begin_function
name|int
name|regs_set_between_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|start
parameter_list|,
name|rtx
name|end
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
literal|0
return|;
case|case
name|REG
case|:
return|return
name|reg_set_between_p
argument_list|(
name|x
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
return|;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|regs_set_between_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|regs_set_between_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Similar to reg_set_between_p, but check all registers in X.  Return 0    only if none of them are modified between START and END.  Return 1 if    X contains a MEM; this routine does usememory aliasing.  */
end_comment

begin_function
name|int
name|modified_between_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|start
parameter_list|,
name|rtx
name|end
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|start
operator|==
name|end
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|0
return|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
if|if
condition|(
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|modified_between_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|start
argument_list|)
init|;
name|insn
operator|!=
name|end
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|memory_modified_in_insn_p
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
break|break;
case|case
name|REG
case|:
return|return
name|reg_set_between_p
argument_list|(
name|x
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
return|;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|modified_between_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|modified_between_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Similar to reg_set_p, but check all registers in X.  Return 0 only if none    of them are modified in INSN.  Return 1 if X contains a MEM; this routine    does use memory aliasing.  */
end_comment

begin_function
name|int
name|modified_in_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|0
return|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
if|if
condition|(
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|modified_in_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|memory_modified_in_insn_p
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
break|break;
case|case
name|REG
case|:
return|return
name|reg_set_p
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
return|;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|modified_in_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|modified_in_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if anything in insn X is (anti,output,true) dependent on    anything in insn Y.  */
end_comment

begin_function
name|int
name|insn_dependent_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
name|rtx
name|tmp
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|x
argument_list|)
operator|||
operator|!
name|INSN_P
argument_list|(
name|y
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|PATTERN
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn_dependent_p_1
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL_RTX
condition|)
return|return
literal|1
return|;
name|tmp
operator|=
name|PATTERN
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|y
argument_list|)
argument_list|,
name|insn_dependent_p_1
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL_RTX
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A helper routine for insn_dependent_p called through note_stores.  */
end_comment

begin_function
specifier|static
name|void
name|insn_dependent_p_1
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|pat
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|rtx
modifier|*
name|pinsn
init|=
operator|(
name|rtx
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|*
name|pinsn
operator|&&
name|reg_mentioned_p
argument_list|(
name|x
argument_list|,
operator|*
name|pinsn
argument_list|)
condition|)
operator|*
name|pinsn
operator|=
name|NULL_RTX
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper function for set_of.  */
end_comment

begin_struct
struct|struct
name|set_of_data
block|{
name|rtx
name|found
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|set_of_1
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|pat
parameter_list|,
name|void
modifier|*
name|data1
parameter_list|)
block|{
name|struct
name|set_of_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|set_of_data
operator|*
operator|)
operator|(
name|data1
operator|)
decl_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|data
operator|->
name|pat
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|data
operator|->
name|pat
argument_list|,
name|x
argument_list|)
operator|)
condition|)
name|data
operator|->
name|found
operator|=
name|pat
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Give an INSN, return a SET or CLOBBER expression that does modify PAT    (either directly or via STRICT_LOW_PART and similar modifiers).  */
end_comment

begin_function
name|rtx
name|set_of
parameter_list|(
name|rtx
name|pat
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|struct
name|set_of_data
name|data
decl_stmt|;
name|data
operator|.
name|found
operator|=
name|NULL_RTX
expr_stmt|;
name|data
operator|.
name|pat
operator|=
name|pat
expr_stmt|;
name|note_stores
argument_list|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|?
name|PATTERN
argument_list|(
name|insn
argument_list|)
else|:
name|insn
argument_list|,
name|set_of_1
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
return|return
name|data
operator|.
name|found
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an INSN, return a SET expression if this insn has only a single SET.    It may also have CLOBBERs, USEs, or SET whose output    will not be used, which we ignore.  */
end_comment

begin_function
name|rtx
name|single_set_2
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|pat
parameter_list|)
block|{
name|rtx
name|set
init|=
name|NULL
decl_stmt|;
name|int
name|set_verified
init|=
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|sub
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|sub
argument_list|)
condition|)
block|{
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
break|break;
case|case
name|SET
case|:
comment|/* We can consider insns having multiple sets, where all 		 but one are dead as single set insns.  In common case 		 only single set is present in the pattern so we want 		 to avoid checking for REG_UNUSED notes unless necessary.  		 When we reach set first time, we just expect this is 		 the single set we are looking for and only when more 		 sets are found in the insn, we check them.  */
if|if
condition|(
operator|!
name|set_verified
condition|)
block|{
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|set
argument_list|)
condition|)
name|set
operator|=
name|NULL
expr_stmt|;
else|else
name|set_verified
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|set
condition|)
name|set
operator|=
name|sub
operator|,
name|set_verified
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|SET_DEST
argument_list|(
name|sub
argument_list|)
argument_list|)
operator|||
name|side_effects_p
argument_list|(
name|sub
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
break|break;
default|default:
return|return
name|NULL_RTX
return|;
block|}
block|}
block|}
return|return
name|set
return|;
block|}
end_function

begin_comment
comment|/* Given an INSN, return nonzero if it has more than one SET, else return    zero.  */
end_comment

begin_function
name|int
name|multiple_sets
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|found
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* INSN must be an insn.  */
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Only a PARALLEL can have multiple SETs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|found
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
comment|/* If we have already found a SET, then return now.  */
if|if
condition|(
name|found
condition|)
return|return
literal|1
return|;
else|else
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Either zero or one SET.  */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if the destination of SET equals the source    and there are no side effects.  */
end_comment

begin_function
name|int
name|set_noop_p
parameter_list|(
name|rtx
name|set
parameter_list|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|dst
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
if|if
condition|(
name|dst
operator|==
name|pc_rtx
operator|&&
name|src
operator|==
name|pc_rtx
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|rtx_equal_p
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|dst
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
return|return
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|src
argument_list|)
operator|&&
operator|!
name|BYTES_BIG_ENDIAN
operator|&&
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|2
argument_list|)
operator|==
name|const0_rtx
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|src
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dst
operator|=
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|SUBREG_BYTE
argument_list|(
name|src
argument_list|)
operator|!=
name|SUBREG_BYTE
argument_list|(
name|dst
argument_list|)
condition|)
return|return
literal|0
return|;
name|src
operator|=
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|dst
operator|=
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|==
name|REGNO
argument_list|(
name|dst
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if an insn consists only of SETs, each of which only sets a    value to itself.  */
end_comment

begin_function
name|int
name|noop_move_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOOP_MOVE_INSN_CODE
condition|)
return|return
literal|1
return|;
comment|/* Insns carrying these notes are useful later on.  */
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* For now treat an insn with a REG_RETVAL note as a      a special insn which should not be considered a no-op.  */
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|set_noop_p
argument_list|(
name|pat
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* If nothing but SETs of registers to themselves, 	 this insn can also be deleted.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|tem
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CLOBBER
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|SET
operator|||
operator|!
name|set_noop_p
argument_list|(
name|tem
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the last thing that X was assigned from before *PINSN.  If VALID_TO    is not NULL_RTX then verify that the object is not modified up to VALID_TO.    If the object was modified, if we hit a partial assignment to X, or hit a    CODE_LABEL first, return X.  If we found an assignment, update *PINSN to    point to it.  ALLOW_HWREG is set to 1 if hardware registers are allowed to    be the src.  */
end_comment

begin_function
name|rtx
name|find_last_value
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
modifier|*
name|pinsn
parameter_list|,
name|rtx
name|valid_to
parameter_list|,
name|int
name|allow_hwreg
parameter_list|)
block|{
name|rtx
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|PREV_INSN
argument_list|(
operator|*
name|pinsn
argument_list|)
init|;
name|p
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|CODE_LABEL
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|EXPR_LIST
condition|)
name|src
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|valid_to
operator|==
name|NULL_RTX
operator|||
operator|!
name|modified_between_p
argument_list|(
name|src
argument_list|,
name|PREV_INSN
argument_list|(
name|p
argument_list|)
argument_list|,
name|valid_to
argument_list|)
operator|)
comment|/* Reject hard registers because we don't usually want 		   to use them; we'd rather use a pseudo.  */
operator|&&
operator|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
name|allow_hwreg
operator|)
condition|)
block|{
operator|*
name|pinsn
operator|=
name|p
expr_stmt|;
return|return
name|src
return|;
block|}
block|}
comment|/* If set in non-simple way, we don't have a value.  */
if|if
condition|(
name|reg_set_p
argument_list|(
name|x
argument_list|,
name|p
argument_list|)
condition|)
break|break;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if register in range [REGNO, ENDREGNO)    appears either explicitly or implicitly in X    other than being stored into.     References contained within the substructure at LOC do not count.    LOC may be zero, meaning don't ignore anything.  */
end_comment

begin_function
name|int
name|refers_to_regno_p
parameter_list|(
name|unsigned
name|int
name|regno
parameter_list|,
name|unsigned
name|int
name|endregno
parameter_list|,
name|rtx
name|x
parameter_list|,
name|rtx
modifier|*
name|loc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|x_regno
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|repeat
label|:
comment|/* The contents of a REG_NONNEG note is always zero, so we must come here      upon repeat in case the last REG_NOTE is a REG_NONNEG note.  */
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
name|x_regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If we modifying the stack, frame, or argument pointer, it will 	 clobber a virtual register.  In fact, we could be more precise, 	 but it isn't worth it.  */
if|if
condition|(
operator|(
name|x_regno
operator|==
name|STACK_POINTER_REGNUM
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|||
name|x_regno
operator|==
name|ARG_POINTER_REGNUM
endif|#
directive|endif
operator|||
name|x_regno
operator|==
name|FRAME_POINTER_REGNUM
operator|)
operator|&&
name|regno
operator|>=
name|FIRST_VIRTUAL_REGISTER
operator|&&
name|regno
operator|<=
name|LAST_VIRTUAL_REGISTER
condition|)
return|return
literal|1
return|;
return|return
operator|(
name|endregno
operator|>
name|x_regno
operator|&&
name|regno
operator|<
name|x_regno
operator|+
operator|(
name|x_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|HARD_REGNO_NREGS
argument_list|(
name|x_regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
literal|1
operator|)
operator|)
return|;
case|case
name|SUBREG
case|:
comment|/* If this is a SUBREG of a hard reg, we can see exactly which 	 registers are being modified.  Otherwise, handle normally.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|unsigned
name|int
name|inner_regno
init|=
name|subreg_regno
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|inner_endregno
init|=
name|inner_regno
operator|+
operator|(
name|inner_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
literal|1
operator|)
decl_stmt|;
return|return
name|endregno
operator|>
name|inner_regno
operator|&&
name|regno
operator|<
name|inner_endregno
return|;
block|}
break|break;
case|case
name|CLOBBER
case|:
case|case
name|SET
case|:
if|if
condition|(
operator|&
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|!=
name|loc
comment|/* Note setting a SUBREG counts as referring to the REG it is in for 	     a pseudo but not for hard registers since we can 	     treat each word individually.  */
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|loc
operator|!=
operator|&
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|loc
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|loc
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|code
operator|==
name|CLOBBER
operator|||
name|loc
operator|==
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
default|default:
break|break;
block|}
comment|/* X does not match, so try its subexpressions.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|loc
operator|!=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
elseif|else
if|if
condition|(
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|loc
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|loc
operator|!=
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|&&
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|loc
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if modifying X will affect IN.  If X is a register or a SUBREG,    we check if any register number in X conflicts with the relevant register    numbers.  If X is a constant, return 0.  If X is a MEM, return 1 iff IN    contains a MEM (we don't bother checking for memory addresses that can't    conflict because we expect this to be a rare case.  */
end_comment

begin_function
name|int
name|reg_overlap_mentioned_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|in
parameter_list|)
block|{
name|unsigned
name|int
name|regno
decl_stmt|,
name|endregno
decl_stmt|;
comment|/* Overly conservative.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If either argument is a constant, then modifying X can not affect IN.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|||
name|CONSTANT_P
argument_list|(
name|in
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|SUBREG
case|:
name|regno
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|regno
operator|=
name|subreg_regno
argument_list|(
name|x
argument_list|)
expr_stmt|;
goto|goto
name|do_reg
goto|;
case|case
name|REG
case|:
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|do_reg
label|:
name|endregno
operator|=
name|regno
operator|+
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
literal|1
operator|)
expr_stmt|;
return|return
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|in
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|)
return|;
case|case
name|MEM
case|:
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|XEXP
argument_list|(
name|in
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
case|case
name|SCRATCH
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
name|reg_mentioned_p
argument_list|(
name|x
argument_list|,
name|in
argument_list|)
return|;
case|case
name|PARALLEL
case|:
block|{
name|int
name|i
decl_stmt|;
comment|/* If any register in here refers to it we return true.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|in
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
default|default:
break|break;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the last value to which REG was set prior to INSN.  If we can't    find it easily, return 0.     We only return a REG, SUBREG, or constant because it is too hard to    check if a MEM remains unchanged.  */
end_comment

begin_function
name|rtx
name|reg_set_last
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|orig_insn
init|=
name|insn
decl_stmt|;
comment|/* Scan backwards until reg_set_last_1 changed one of the above flags.      Stop when we reach a label or X is a hard reg and we reach a      CALL_INSN (if reg_set_last_last_regno is a hard reg).       If we find a set of X, ensure that its SET_SRC remains unchanged.  */
comment|/* We compare with<= here, because reg_set_last_last_regno      is actually the number of the first reg *not* in X.  */
for|for
control|(
init|;
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|set
init|=
name|set_of
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
decl_stmt|;
comment|/* OK, this function modify our register.  See if we understand it.  */
if|if
condition|(
name|set
condition|)
block|{
name|rtx
name|last_value
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|!=
name|SET
operator|||
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|!=
name|x
condition|)
return|return
literal|0
return|;
name|last_value
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|last_value
argument_list|)
operator|||
operator|(
operator|(
name|GET_CODE
argument_list|(
name|last_value
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|last_value
argument_list|)
operator|==
name|SUBREG
operator|)
operator|&&
operator|!
name|reg_set_between_p
argument_list|(
name|last_value
argument_list|,
name|insn
argument_list|,
name|orig_insn
argument_list|)
operator|)
condition|)
return|return
name|last_value
return|;
else|else
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call FUN on each register or MEM that is stored into or clobbered by X.    (X would be the pattern of an insn).    FUN receives two arguments:      the REG, MEM, CC0 or PC being stored in or clobbered,      the SET or CLOBBER rtx that does the store.    If the item being stored in or clobbered is a SUBREG of a hard register,   the SUBREG will be passed.  */
end_comment

begin_function
name|void
name|note_stores
parameter_list|(
name|rtx
name|x
parameter_list|,
name|void
function_decl|(
modifier|*
name|fun
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|x
operator|=
name|COND_EXEC_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we have a PARALLEL, SET_DEST is a list of EXPR_LIST expressions, 	 each of whose first operand is a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
call|(
modifier|*
name|fun
call|)
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
call|(
modifier|*
name|fun
call|)
argument_list|(
name|dest
argument_list|,
name|x
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|note_stores
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|fun
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like notes_stores, but call FUN for each expression that is being    referenced in PBODY, a pointer to the PATTERN of an insn.  We only call    FUN for each expression, not any interior subexpressions.  FUN receives a    pointer to the expression and the DATA passed to this function.     Note that this is not quite the same test as that done in reg_referenced_p    since that considers something as being referenced if it is being    partially set, while we do not.  */
end_comment

begin_function
name|void
name|note_uses
parameter_list|(
name|rtx
modifier|*
name|pbody
parameter_list|,
name|void
function_decl|(
modifier|*
name|fun
function_decl|)
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|rtx
name|body
init|=
operator|*
name|pbody
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
condition|)
block|{
case|case
name|COND_EXEC
case|:
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|COND_EXEC_TEST
argument_list|(
name|body
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|note_uses
argument_list|(
operator|&
name|COND_EXEC_CODE
argument_list|(
name|body
argument_list|)
argument_list|,
name|fun
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
case|case
name|PARALLEL
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|note_uses
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|fun
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
case|case
name|USE
case|:
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
case|case
name|ASM_OPERANDS
case|:
for|for
control|(
name|i
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|body
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|ASM_OPERANDS_INPUT
argument_list|(
name|body
argument_list|,
name|i
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
case|case
name|TRAP_IF
case|:
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|TRAP_CONDITION
argument_list|(
name|body
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
case|case
name|PREFETCH
case|:
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNSPEC
case|:
case|case
name|UNSPEC_VOLATILE
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
case|case
name|CLOBBER
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
case|case
name|SET
case|:
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
decl_stmt|;
comment|/* For sets we replace everything in source plus registers in memory 	   expression in store and operands of a ZERO_EXTRACT.  */
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
block|{
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|1
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|2
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
call|(
modifier|*
name|fun
call|)
argument_list|(
operator|&
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
comment|/* All the other possibilities never store.  */
call|(
modifier|*
name|fun
call|)
argument_list|(
name|pbody
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if X's old contents don't survive after INSN.    This will be true if X is (cc0) or if X is a register and    X dies in INSN or because INSN entirely sets X.     "Entirely set" means set directly and not through a SUBREG,    ZERO_EXTRACT or SIGN_EXTRACT, so no trace of the old contents remains.    Likewise, REG_INC does not count.     REG may be a hard or pseudo reg.  Renumbering is not taken into account,    but for this use that makes no difference, since regs don't overlap    during their lifetimes.  Therefore, this function may be used    at any time after deaths have been computed (in flow.c).     If REG is a hard reg that occupies multiple machine registers, this    function will only return 1 if each of those registers will be replaced    by INSN.  */
end_comment

begin_function
name|int
name|dead_or_set_p
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|unsigned
name|int
name|regno
decl_stmt|,
name|last_regno
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Can't use cc0_rtx below since this file is used by genattrtab.c.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CC0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|last_regno
operator|=
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
name|regno
else|:
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<=
name|last_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|dead_or_set_regno_p
argument_list|(
name|insn
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Utility function for dead_or_set_p to check an individual register.  Also    called from flow.c.  */
end_comment

begin_function
name|int
name|dead_or_set_regno_p
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|unsigned
name|int
name|test_regno
parameter_list|)
block|{
name|unsigned
name|int
name|regno
decl_stmt|,
name|endregno
decl_stmt|;
name|rtx
name|pattern
decl_stmt|;
comment|/* See if there is a death note for something that includes TEST_REGNO.  */
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|test_regno
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|find_regno_fusage
argument_list|(
name|insn
argument_list|,
name|CLOBBER
argument_list|,
name|test_regno
argument_list|)
condition|)
return|return
literal|1
return|;
name|pattern
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|pattern
operator|=
name|COND_EXEC_CODE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
comment|/* A value is totally replaced if it is the destination or the 	 destination is a SUBREG of REGNO that does not change the number of 	 words in it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|==
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|endregno
operator|=
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
name|regno
operator|+
literal|1
else|:
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|test_regno
operator|>=
name|regno
operator|&&
name|test_regno
operator|<
name|endregno
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|body
init|=
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|body
operator|=
name|COND_EXEC_CODE
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|==
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
condition|)
continue|continue;
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|endregno
operator|=
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
name|regno
operator|+
literal|1
else|:
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|test_regno
operator|>=
name|regno
operator|&&
name|test_regno
operator|<
name|endregno
condition|)
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the reg-note of kind KIND in insn INSN, if there is one.    If DATUM is nonzero, look for one whose datum is DATUM.  */
end_comment

begin_function
name|rtx
name|find_reg_note
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|enum
name|reg_note
name|kind
parameter_list|,
name|rtx
name|datum
parameter_list|)
block|{
name|rtx
name|link
decl_stmt|;
comment|/* Ignore anything that is not an INSN, JUMP_INSN or CALL_INSN.  */
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|kind
operator|&&
operator|(
name|datum
operator|==
literal|0
operator|||
name|datum
operator|==
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|link
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the reg-note of kind KIND in insn INSN which applies to register    number REGNO, if any.  Return 0 if there is no such reg-note.  Note that    the REGNO of this NOTE need not be REGNO if REGNO is a hard register;    it might be the case that the note overlaps REGNO.  */
end_comment

begin_function
name|rtx
name|find_regno_note
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|enum
name|reg_note
name|kind
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|)
block|{
name|rtx
name|link
decl_stmt|;
comment|/* Ignore anything that is not an INSN, JUMP_INSN or CALL_INSN.  */
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|kind
comment|/* Verify that it is a register, so that scratch and MEM won't cause a 	   problem here.  */
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
name|regno
operator|&&
operator|(
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|+
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|>
name|regno
operator|)
condition|)
return|return
name|link
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return a REG_EQUIV or REG_EQUAL note if insn has only a single set and    has such a note.  */
end_comment

begin_function
name|rtx
name|find_reg_equal_equiv_note
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|link
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_EQUAL
operator|||
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_EQUIV
condition|)
block|{
if|if
condition|(
name|single_set
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|link
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return true if DATUM, or any overlap of DATUM, of kind CODE is found    in the CALL_INSN_FUNCTION_USAGE information of INSN.  */
end_comment

begin_function
name|int
name|find_reg_fusage
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|datum
parameter_list|)
block|{
comment|/* If it's not a CALL_INSN, it can't possibly have a      CALL_INSN_FUNCTION_USAGE field, so don't bother checking.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CALL_INSN
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|datum
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|datum
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|code
operator|&&
name|rtx_equal_p
argument_list|(
name|datum
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|datum
argument_list|)
decl_stmt|;
comment|/* CALL_INSN_FUNCTION_USAGE information cannot contain references 	 to pseudo registers, so don't bother checking.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|unsigned
name|int
name|end_regno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|datum
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|end_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|find_regno_fusage
argument_list|(
name|insn
argument_list|,
name|code
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if REGNO, or any overlap of REGNO, of kind CODE is found    in the CALL_INSN_FUNCTION_USAGE information of INSN.  */
end_comment

begin_function
name|int
name|find_regno_fusage
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|)
block|{
name|rtx
name|link
decl_stmt|;
comment|/* CALL_INSN_FUNCTION_USAGE information cannot contain references      to pseudo registers, so don't bother checking.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CALL_INSN
condition|)
return|return
literal|0
return|;
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|unsigned
name|int
name|regnote
decl_stmt|;
name|rtx
name|op
decl_stmt|,
name|reg
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|code
operator|&&
name|GET_CODE
argument_list|(
name|reg
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|regnote
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|)
operator|<=
name|regno
operator|&&
name|regnote
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regnote
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|>
name|regno
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if INSN is a call to a pure function.  */
end_comment

begin_function
name|int
name|pure_call_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|link
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CALL_INSN
operator|||
operator|!
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Look for the note that differentiates const and pure functions.  */
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|u
decl_stmt|,
name|m
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|u
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|m
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_MODE
argument_list|(
name|m
argument_list|)
operator|==
name|BLKmode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SCRATCH
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remove register note NOTE from the REG_NOTES of INSN.  */
end_comment

begin_function
name|void
name|remove_note
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|note
parameter_list|)
block|{
name|rtx
name|link
decl_stmt|;
if|if
condition|(
name|note
operator|==
name|NULL_RTX
condition|)
return|return;
if|if
condition|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|==
name|note
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|==
name|note
condition|)
block|{
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Search LISTP (an EXPR_LIST) for an entry whose first operand is NODE and    return 1 if it is found.  A simple equality test is used to determine if    NODE matches.  */
end_comment

begin_function
name|int
name|in_expr_list_p
parameter_list|(
name|rtx
name|listp
parameter_list|,
name|rtx
name|node
parameter_list|)
block|{
name|rtx
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|listp
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|node
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Search LISTP (an EXPR_LIST) for an entry whose first operand is NODE and    remove that entry from the list if it is found.     A simple equality test is used to determine if NODE matches.  */
end_comment

begin_function
name|void
name|remove_node_from_expr_list
parameter_list|(
name|rtx
name|node
parameter_list|,
name|rtx
modifier|*
name|listp
parameter_list|)
block|{
name|rtx
name|temp
init|=
operator|*
name|listp
decl_stmt|;
name|rtx
name|prev
init|=
name|NULL_RTX
decl_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|node
operator|==
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Splice the node out of the list.  */
if|if
condition|(
name|prev
condition|)
name|XEXP
argument_list|(
name|prev
argument_list|,
literal|1
argument_list|)
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
operator|*
name|listp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|prev
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if X contains any volatile instructions.  These are instructions    which may cause unpredictable machine state instructions, and thus no    instructions should be moved or combined across them.  This includes    only volatile asms and UNSPEC_VOLATILE instructions.  */
end_comment

begin_function
name|int
name|volatile_insn_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|RTX_CODE
name|code
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|REG
case|:
case|case
name|SCRATCH
case|:
case|case
name|CLOBBER
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
case|case
name|CALL
case|:
case|case
name|MEM
case|:
return|return
literal|0
return|;
case|case
name|UNSPEC_VOLATILE
case|:
comment|/* case TRAP_IF: This isn't clear yet.  */
return|return
literal|1
return|;
case|case
name|ASM_INPUT
case|:
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
default|default:
break|break;
block|}
comment|/* Recursively scan the operands of this expression.  */
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|volatile_insn_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|volatile_insn_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if X contains any volatile memory references    UNSPEC_VOLATILE operations or volatile ASM_OPERANDS expressions.  */
end_comment

begin_function
name|int
name|volatile_refs_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|RTX_CODE
name|code
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|REG
case|:
case|case
name|SCRATCH
case|:
case|case
name|CLOBBER
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return
literal|0
return|;
case|case
name|UNSPEC_VOLATILE
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
default|default:
break|break;
block|}
comment|/* Recursively scan the operands of this expression.  */
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|volatile_refs_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|volatile_refs_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Similar to above, except that it also rejects register pre- and post-    incrementing.  */
end_comment

begin_function
name|int
name|side_effects_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|RTX_CODE
name|code
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|REG
case|:
case|case
name|SCRATCH
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return
literal|0
return|;
case|case
name|CLOBBER
case|:
comment|/* Reject CLOBBER with a non-VOID mode.  These are made by combine.c 	 when some combination can't be done.  If we see one, don't think 	 that we can simplify the expression.  */
return|return
operator|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
operator|)
return|;
case|case
name|PRE_INC
case|:
case|case
name|PRE_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_MODIFY
case|:
case|case
name|POST_MODIFY
case|:
case|case
name|CALL
case|:
case|case
name|UNSPEC_VOLATILE
case|:
comment|/* case TRAP_IF: This isn't clear yet.  */
return|return
literal|1
return|;
case|case
name|MEM
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
default|default:
break|break;
block|}
comment|/* Recursively scan the operands of this expression.  */
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|side_effects_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|side_effects_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if evaluating rtx X might cause a trap.  */
end_comment

begin_function
name|int
name|may_trap_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Handle these cases quickly.  */
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|REG
case|:
case|case
name|SCRATCH
case|:
return|return
literal|0
return|;
case|case
name|ASM_INPUT
case|:
case|case
name|UNSPEC_VOLATILE
case|:
case|case
name|TRAP_IF
case|:
return|return
literal|1
return|;
case|case
name|ASM_OPERANDS
case|:
return|return
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
return|;
comment|/* Memory ref can trap unless it's a static var or a stack slot.  */
case|case
name|MEM
case|:
if|if
condition|(
name|MEM_NOTRAP_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|rtx_addr_can_trap_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Division by a non-constant might trap.  */
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
if|if
condition|(
name|HONOR_SNANS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|flag_trapping_math
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|EXPR_LIST
case|:
comment|/* An EXPR_LIST is used to represent a function call.  This 	 certainly may trap.  */
return|return
literal|1
return|;
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|COMPARE
case|:
comment|/* Some floating point comparisons may trap.  */
if|if
condition|(
operator|!
name|flag_trapping_math
condition|)
break|break;
comment|/* ??? There is no machine independent way to check for tests that trap 	 when COMPARE is used, though many targets do make this distinction. 	 For instance, sparc uses CCFPE for compares which generate exceptions 	 and CCFP for compares which do not generate exceptions.  */
if|if
condition|(
name|HONOR_NANS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* But often the compare has some CC mode, so check operand 	 modes as well.  */
if|if
condition|(
name|HONOR_NANS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|||
name|HONOR_NANS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|EQ
case|:
case|case
name|NE
case|:
if|if
condition|(
name|HONOR_SNANS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Often comparison is CC mode, so check operand modes.  */
if|if
condition|(
name|HONOR_SNANS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|||
name|HONOR_SNANS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|FIX
case|:
comment|/* Conversion of floating point might trap.  */
if|if
condition|(
name|flag_trapping_math
operator|&&
name|HONOR_NANS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|NEG
case|:
case|case
name|ABS
case|:
comment|/* These operations don't trap even with floating point.  */
break|break;
default|default:
comment|/* Any floating arithmetic may trap.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|flag_trapping_math
condition|)
return|return
literal|1
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|may_trap_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|may_trap_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if X contains a comparison that is not either EQ or NE,    i.e., an inequality.  */
end_comment

begin_function
name|int
name|inequality_comparisons_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|SCRATCH
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
return|return
literal|0
return|;
case|case
name|LT
case|:
case|case
name|LTU
case|:
case|case
name|GT
case|:
case|case
name|GTU
case|:
case|case
name|LE
case|:
case|case
name|LEU
case|:
case|case
name|GE
case|:
case|case
name|GEU
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|inequality_comparisons_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|inequality_comparisons_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Replace any occurrence of FROM in X with TO.  The function does    not enter into CONST_DOUBLE for the replace.     Note that copying is not done so X must not be shared unless all copies    are to be modified.  */
end_comment

begin_function
name|rtx
name|replace_rtx
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|from
parameter_list|,
name|rtx
name|to
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* The following prevents loops occurrence when we change MEM in      CONST_DOUBLE onto the same CONST_DOUBLE.  */
if|if
condition|(
name|x
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
name|x
return|;
if|if
condition|(
name|x
operator|==
name|from
condition|)
return|return
name|to
return|;
comment|/* Allow this function to make replacements in EXPR_LISTs.  */
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|rtx
name|new
init|=
name|replace_rtx
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|x
operator|=
name|simplify_subreg
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
operator|=
name|new
expr_stmt|;
return|return
name|x
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTEND
condition|)
block|{
name|rtx
name|new
init|=
name|replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|x
operator|=
name|simplify_unary_operation
argument_list|(
name|ZERO_EXTEND
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|new
expr_stmt|;
return|return
name|x
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|replace_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Throughout the rtx X, replace many registers according to REG_MAP.    Return the replacement for X (which may be X with altered contents).    REG_MAP[R] is the replacement for register R, or 0 for don't replace.    NREGS is the length of REG_MAP; regs>= NREGS are not mapped.     We only support REG_MAP entries of REG or SUBREG.  Also, hard registers    should not be mapped to pseudos or vice versa since validate_change    is not called.     If REPLACE_DEST is 1, replacements are also done in destinations;    otherwise, only sources are replaced.  */
end_comment

begin_function
name|rtx
name|replace_regs
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
modifier|*
name|reg_map
parameter_list|,
name|unsigned
name|int
name|nregs
parameter_list|,
name|int
name|replace_dest
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|x
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SCRATCH
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
name|x
return|;
case|case
name|REG
case|:
comment|/* Verify that the register has an entry before trying to access it.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|nregs
operator|&&
name|reg_map
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* SUBREGs can't be shared.  Always return a copy to ensure that if 	     this replacement occurs more than once then each instance will 	     get distinct rtx.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg_map
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
return|return
name|copy_rtx
argument_list|(
name|reg_map
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
return|;
return|return
name|reg_map
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
return|;
block|}
return|return
name|x
return|;
case|case
name|SUBREG
case|:
comment|/* Prevent making nested SUBREGs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|nregs
operator|&&
name|reg_map
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reg_map
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|rtx
name|map_val
init|=
name|reg_map
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
decl_stmt|;
return|return
name|simplify_gen_subreg
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|map_val
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|SET
case|:
if|if
condition|(
name|replace_dest
condition|)
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|=
name|replace_regs
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|nregs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
comment|/* Even if we are not to replace destinations, replace register if it 	   is CONTAINED in destination (destination is memory or 	   STRICT_LOW_PART).  */
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|replace_regs
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|nregs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
comment|/* Similarly, for ZERO_EXTRACT we replace all operands.  */
break|break;
name|SET_SRC
argument_list|(
name|x
argument_list|)
operator|=
name|replace_regs
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|nregs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|x
return|;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|replace_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|nregs
argument_list|,
name|replace_dest
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|replace_regs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|nregs
argument_list|,
name|replace_dest
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Replace occurrences of the old label in *X with the new one.    DATA is a REPLACE_LABEL_DATA containing the old and new labels.  */
end_comment

begin_function
name|int
name|replace_label
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|rtx
name|l
init|=
operator|*
name|x
decl_stmt|;
name|rtx
name|old_label
init|=
operator|(
operator|(
name|replace_label_data
operator|*
operator|)
name|data
operator|)
operator|->
name|r1
decl_stmt|;
name|rtx
name|new_label
init|=
operator|(
operator|(
name|replace_label_data
operator|*
operator|)
name|data
operator|)
operator|->
name|r2
decl_stmt|;
name|bool
name|update_label_nuses
init|=
operator|(
operator|(
name|replace_label_data
operator|*
operator|)
name|data
operator|)
operator|->
name|update_label_nuses
decl_stmt|;
if|if
condition|(
name|l
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|l
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|l
argument_list|)
condition|)
block|{
name|rtx
name|c
init|=
name|get_pool_constant
argument_list|(
name|l
argument_list|)
decl_stmt|;
if|if
condition|(
name|rtx_referenced_p
argument_list|(
name|old_label
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|rtx
name|new_c
decl_stmt|,
name|new_l
decl_stmt|;
name|replace_label_data
modifier|*
name|d
init|=
operator|(
name|replace_label_data
operator|*
operator|)
name|data
decl_stmt|;
comment|/* Create a copy of constant C; replace the label inside 	     but do not update LABEL_NUSES because uses in constant pool 	     are not counted.  */
name|new_c
operator|=
name|copy_rtx
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|d
operator|->
name|update_label_nuses
operator|=
name|false
expr_stmt|;
name|for_each_rtx
argument_list|(
operator|&
name|new_c
argument_list|,
name|replace_label
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|d
operator|->
name|update_label_nuses
operator|=
name|update_label_nuses
expr_stmt|;
comment|/* Add the new constant NEW_C to constant pool and replace 	     the old reference to constant by new reference.  */
name|new_l
operator|=
name|XEXP
argument_list|(
name|force_const_mem
argument_list|(
name|get_pool_mode
argument_list|(
name|l
argument_list|)
argument_list|,
name|new_c
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|x
operator|=
name|replace_rtx
argument_list|(
name|l
argument_list|,
name|l
argument_list|,
name|new_l
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* If this is a JUMP_INSN, then we also need to fix the JUMP_LABEL      field.  This is not handled by for_each_rtx because it doesn't      handle unprinted ('0') fields.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|l
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|l
argument_list|)
operator|==
name|old_label
condition|)
name|JUMP_LABEL
argument_list|(
name|l
argument_list|)
operator|=
name|new_label
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|l
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|l
argument_list|)
operator|==
name|INSN_LIST
operator|)
operator|&&
name|XEXP
argument_list|(
name|l
argument_list|,
literal|0
argument_list|)
operator|==
name|old_label
condition|)
block|{
name|XEXP
argument_list|(
name|l
argument_list|,
literal|0
argument_list|)
operator|=
name|new_label
expr_stmt|;
if|if
condition|(
name|update_label_nuses
condition|)
block|{
operator|++
name|LABEL_NUSES
argument_list|(
name|new_label
argument_list|)
expr_stmt|;
operator|--
name|LABEL_NUSES
argument_list|(
name|old_label
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* When *BODY is equal to X or X is directly referenced by *BODY    return nonzero, thus FOR_EACH_RTX stops traversing and returns nonzero    too, otherwise FOR_EACH_RTX continues traversing *BODY.  */
end_comment

begin_function
specifier|static
name|int
name|rtx_referenced_p_1
parameter_list|(
name|rtx
modifier|*
name|body
parameter_list|,
name|void
modifier|*
name|x
parameter_list|)
block|{
name|rtx
name|y
init|=
operator|(
name|rtx
operator|)
name|x
decl_stmt|;
if|if
condition|(
operator|*
name|body
operator|==
name|NULL_RTX
condition|)
return|return
name|y
operator|==
name|NULL_RTX
return|;
comment|/* Return true if a label_ref *BODY refers to label Y.  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|body
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CODE_LABEL
condition|)
return|return
name|XEXP
argument_list|(
operator|*
name|body
argument_list|,
literal|0
argument_list|)
operator|==
name|y
return|;
comment|/* If *BODY is a reference to pool constant traverse the constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|body
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
operator|*
name|body
argument_list|)
condition|)
return|return
name|rtx_referenced_p
argument_list|(
name|y
argument_list|,
name|get_pool_constant
argument_list|(
operator|*
name|body
argument_list|)
argument_list|)
return|;
comment|/* By default, compare the RTL expressions.  */
return|return
name|rtx_equal_p
argument_list|(
operator|*
name|body
argument_list|,
name|y
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if X is referenced in BODY.  */
end_comment

begin_function
name|int
name|rtx_referenced_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|body
parameter_list|)
block|{
return|return
name|for_each_rtx
argument_list|(
operator|&
name|body
argument_list|,
name|rtx_referenced_p_1
argument_list|,
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If INSN is a tablejump return true and store the label (before jump table) to    *LABELP and the jump table to *TABLEP.  LABELP and TABLEP may be NULL.  */
end_comment

begin_function
name|bool
name|tablejump_p
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
modifier|*
name|labelp
parameter_list|,
name|rtx
modifier|*
name|tablep
parameter_list|)
block|{
name|rtx
name|label
decl_stmt|,
name|table
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|label
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
operator|(
name|table
operator|=
name|next_active_insn
argument_list|(
name|label
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
name|GET_CODE
argument_list|(
name|table
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|table
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|table
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
block|{
if|if
condition|(
name|labelp
condition|)
operator|*
name|labelp
operator|=
name|label
expr_stmt|;
if|if
condition|(
name|tablep
condition|)
operator|*
name|tablep
operator|=
name|table
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of computed_jump_p, return 1 if X contains a REG or MEM or    constant that is not in the constant pool and not in the condition    of an IF_THEN_ELSE.  */
end_comment

begin_function
specifier|static
name|int
name|computed_jump_p_1
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|PC
case|:
return|return
literal|0
return|;
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|REG
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
return|return
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|IF_THEN_ELSE
case|:
return|return
operator|(
name|computed_jump_p_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|computed_jump_p_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|)
return|;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|computed_jump_p_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|computed_jump_p_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if INSN is an indirect jump (aka computed jump).     Tablejumps and casesi insns are not considered indirect jumps;    we can recognize them by a (use (label_ref)).  */
end_comment

begin_function
name|int
name|computed_jump_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LABEL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|has_use_labelref
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
condition|)
name|has_use_labelref
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|has_use_labelref
condition|)
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|computed_jump_p_1
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|computed_jump_p_1
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Traverse X via depth-first search, calling F for each    sub-expression (including X itself).  F is also passed the DATA.    If F returns -1, do not traverse sub-expressions, but continue    traversing the rest of the tree.  If F ever returns any other    nonzero value, stop the traversal, and return the value returned    by F.  Otherwise, return 0.  This function does not traverse inside    tree structure that contains RTX_EXPRs, or into sub-expressions    whose format code is `0' since it is not known whether or not those    codes are actually RTL.     This routine is very general, and could (should?) be used to    implement many of the other routines in this file.  */
end_comment

begin_function
name|int
name|for_each_rtx
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|rtx_function
name|f
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|int
name|length
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Call F on X.  */
name|result
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
name|x
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
comment|/* Do not traverse sub-expressions.  */
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
comment|/* Stop the traversal.  */
return|return
name|result
return|;
if|if
condition|(
operator|*
name|x
operator|==
name|NULL_RTX
condition|)
comment|/* There are no sub-expressions.  */
return|return
literal|0
return|;
name|length
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|format
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|format
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
name|result
operator|=
name|for_each_rtx
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|f
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
return|return
name|result
return|;
break|break;
case|case
literal|'V'
case|:
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|)
condition|;
operator|++
name|j
control|)
block|{
name|result
operator|=
name|for_each_rtx
argument_list|(
operator|&
name|XVECEXP
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|f
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
return|return
name|result
return|;
block|}
block|}
break|break;
default|default:
comment|/* Nothing to do.  */
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Searches X for any reference to REGNO, returning the rtx of the    reference found if any.  Otherwise, returns NULL_RTX.  */
end_comment

begin_function
name|rtx
name|regno_use_in
parameter_list|(
name|unsigned
name|int
name|regno
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|regno
condition|)
return|return
name|x
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
operator|(
name|tem
operator|=
name|regno_use_in
argument_list|(
name|regno
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|tem
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
operator|(
name|tem
operator|=
name|regno_use_in
argument_list|(
name|regno
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|tem
return|;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Return a value indicating whether OP, an operand of a commutative    operation, is preferred as the first or second operand.  The higher    the value, the stronger the preference for being the first operand.    We use negative values to indicate a preference for the first operand    and positive values for the second operand.  */
end_comment

begin_function
name|int
name|commutative_operand_precedence
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
comment|/* Constants always come the second operand.  Prefer "nice" constants.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|-
literal|5
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
operator|-
literal|4
return|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
operator|-
literal|3
return|;
comment|/* SUBREGs of objects should come second.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'o'
condition|)
return|return
operator|-
literal|2
return|;
comment|/* If only one operand is a `neg', `not',     `mult', `plus', or `minus' expression, it will be the first     operand.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NEG
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NOT
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MULT
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MINUS
condition|)
return|return
literal|2
return|;
comment|/* Complex expressions should be the first, so decrease priority      of objects.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
literal|'o'
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 iff it is necessary to swap operands of commutative operation    in order to canonicalize expression.  */
end_comment

begin_function
name|int
name|swap_commutative_operands_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
return|return
operator|(
name|commutative_operand_precedence
argument_list|(
name|x
argument_list|)
operator|<
name|commutative_operand_precedence
argument_list|(
name|y
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X is an autoincrement side effect and the register is    not the stack pointer.  */
end_comment

begin_function
name|int
name|auto_inc_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|PRE_INC
case|:
case|case
name|POST_INC
case|:
case|case
name|PRE_DEC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_MODIFY
case|:
case|case
name|POST_MODIFY
case|:
comment|/* There are no REG_INC notes for SP.  */
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
name|stack_pointer_rtx
condition|)
return|return
literal|1
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the sequence of instructions beginning with FROM and up    to and including TO is safe to move.  If NEW_TO is non-NULL, and    the sequence is not already safe to move, but can be easily    extended to a sequence which is safe, then NEW_TO will point to the    end of the extended sequence.     For now, this function only checks that the region contains whole    exception regions, but it could be extended to check additional    conditions as well.  */
end_comment

begin_function
name|int
name|insns_safe_to_move_p
parameter_list|(
name|rtx
name|from
parameter_list|,
name|rtx
name|to
parameter_list|,
name|rtx
modifier|*
name|new_to
parameter_list|)
block|{
name|int
name|eh_region_count
init|=
literal|0
decl_stmt|;
name|int
name|past_to_p
init|=
literal|0
decl_stmt|;
name|rtx
name|r
init|=
name|from
decl_stmt|;
comment|/* By default, assume the end of the region will be what was      suggested.  */
if|if
condition|(
name|new_to
condition|)
operator|*
name|new_to
operator|=
name|to
expr_stmt|;
while|while
condition|(
name|r
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|NOTE
condition|)
block|{
switch|switch
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|r
argument_list|)
condition|)
block|{
case|case
name|NOTE_INSN_EH_REGION_BEG
case|:
operator|++
name|eh_region_count
expr_stmt|;
break|break;
case|case
name|NOTE_INSN_EH_REGION_END
case|:
if|if
condition|(
name|eh_region_count
operator|==
literal|0
condition|)
comment|/* This sequence of instructions contains the end of 		   an exception region, but not he beginning.  Moving 		   it will cause chaos.  */
return|return
literal|0
return|;
operator|--
name|eh_region_count
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|past_to_p
condition|)
comment|/* If we've passed TO, and we see a non-note instruction, we 	   can't extend the sequence to a movable sequence.  */
return|return
literal|0
return|;
if|if
condition|(
name|r
operator|==
name|to
condition|)
block|{
if|if
condition|(
operator|!
name|new_to
condition|)
comment|/* It's OK to move the sequence if there were matched sets of 	       exception region notes.  */
return|return
name|eh_region_count
operator|==
literal|0
return|;
name|past_to_p
operator|=
literal|1
expr_stmt|;
block|}
comment|/* It's OK to move the sequence if there were matched sets of 	 exception region notes.  */
if|if
condition|(
name|past_to_p
operator|&&
name|eh_region_count
operator|==
literal|0
condition|)
block|{
operator|*
name|new_to
operator|=
name|r
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Go to the next instruction.  */
name|r
operator|=
name|NEXT_INSN
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if IN contains a piece of rtl that has the address LOC.  */
end_comment

begin_function
name|int
name|loc_mentioned_in_p
parameter_list|(
name|rtx
modifier|*
name|loc
parameter_list|,
name|rtx
name|in
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|in
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|loc
operator|==
operator|&
name|in
operator|->
name|u
operator|.
name|fld
index|[
name|i
index|]
operator|.
name|rtx
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|loc_mentioned_in_p
argument_list|(
name|loc
argument_list|,
name|XEXP
argument_list|(
name|in
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|in
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|loc_mentioned_in_p
argument_list|(
name|loc
argument_list|,
name|XVECEXP
argument_list|(
name|in
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a subreg X, return the bit offset where the subreg begins    (counting from the least significant bit of the reg).  */
end_comment

begin_function
name|unsigned
name|int
name|subreg_lsb
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|bitpos
decl_stmt|;
name|unsigned
name|int
name|byte
decl_stmt|;
name|unsigned
name|int
name|word
decl_stmt|;
comment|/* A paradoxical subreg begins at bit position 0.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
operator|!=
name|BYTES_BIG_ENDIAN
condition|)
comment|/* If the subreg crosses a word boundary ensure that        it also begins and ends on a word boundary.  */
if|if
condition|(
operator|(
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
operator|%
name|UNITS_PER_WORD
operator|+
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
operator|>
name|UNITS_PER_WORD
operator|&&
operator|(
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
operator|%
name|UNITS_PER_WORD
operator|||
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|%
name|UNITS_PER_WORD
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|word
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|inner_mode
argument_list|)
operator|-
operator|(
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
operator|+
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
else|else
name|word
operator|=
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
name|bitpos
operator|=
name|word
operator|*
name|BITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|byte
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|inner_mode
argument_list|)
operator|-
operator|(
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
operator|+
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
operator|)
operator|%
name|UNITS_PER_WORD
expr_stmt|;
else|else
name|byte
operator|=
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
operator|%
name|UNITS_PER_WORD
expr_stmt|;
name|bitpos
operator|+=
name|byte
operator|*
name|BITS_PER_UNIT
expr_stmt|;
return|return
name|bitpos
return|;
block|}
end_function

begin_comment
comment|/* This function returns the regno offset of a subreg expression.    xregno - A regno of an inner hard subreg_reg (or what will become one).    xmode  - The mode of xregno.    offset - The byte offset.    ymode  - The mode of a top level SUBREG (or what may become one).    RETURN - The regno offset which would be used.  */
end_comment

begin_function
name|unsigned
name|int
name|subreg_regno_offset
parameter_list|(
name|unsigned
name|int
name|xregno
parameter_list|,
name|enum
name|machine_mode
name|xmode
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|,
name|enum
name|machine_mode
name|ymode
parameter_list|)
block|{
name|int
name|nregs_xmode
decl_stmt|,
name|nregs_ymode
decl_stmt|;
name|int
name|mode_multiple
decl_stmt|,
name|nregs_multiple
decl_stmt|;
name|int
name|y_offset
decl_stmt|;
if|if
condition|(
name|xregno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|nregs_xmode
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|xregno
argument_list|,
name|xmode
argument_list|)
expr_stmt|;
name|nregs_ymode
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|xregno
argument_list|,
name|ymode
argument_list|)
expr_stmt|;
comment|/* If this is a big endian paradoxical subreg, which uses more actual      hard registers than the original register, we must return a negative      offset so that we find the proper highpart of the register.  */
if|if
condition|(
name|offset
operator|==
literal|0
operator|&&
name|nregs_ymode
operator|>
name|nregs_xmode
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|ymode
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|?
name|WORDS_BIG_ENDIAN
else|:
name|BYTES_BIG_ENDIAN
operator|)
condition|)
return|return
name|nregs_xmode
operator|-
name|nregs_ymode
return|;
if|if
condition|(
name|offset
operator|==
literal|0
operator|||
name|nregs_xmode
operator|==
name|nregs_ymode
condition|)
return|return
literal|0
return|;
comment|/* size of ymode must not be greater than the size of xmode.  */
name|mode_multiple
operator|=
name|GET_MODE_SIZE
argument_list|(
name|xmode
argument_list|)
operator|/
name|GET_MODE_SIZE
argument_list|(
name|ymode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_multiple
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|y_offset
operator|=
name|offset
operator|/
name|GET_MODE_SIZE
argument_list|(
name|ymode
argument_list|)
expr_stmt|;
name|nregs_multiple
operator|=
name|nregs_xmode
operator|/
name|nregs_ymode
expr_stmt|;
return|return
operator|(
name|y_offset
operator|/
operator|(
name|mode_multiple
operator|/
name|nregs_multiple
operator|)
operator|)
operator|*
name|nregs_ymode
return|;
block|}
end_function

begin_comment
comment|/* This function returns true when the offset is representable via    subreg_offset in the given regno.    xregno - A regno of an inner hard subreg_reg (or what will become one).    xmode  - The mode of xregno.    offset - The byte offset.    ymode  - The mode of a top level SUBREG (or what may become one).    RETURN - The regno offset which would be used.  */
end_comment

begin_function
name|bool
name|subreg_offset_representable_p
parameter_list|(
name|unsigned
name|int
name|xregno
parameter_list|,
name|enum
name|machine_mode
name|xmode
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|,
name|enum
name|machine_mode
name|ymode
parameter_list|)
block|{
name|int
name|nregs_xmode
decl_stmt|,
name|nregs_ymode
decl_stmt|;
name|int
name|mode_multiple
decl_stmt|,
name|nregs_multiple
decl_stmt|;
name|int
name|y_offset
decl_stmt|;
if|if
condition|(
name|xregno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|nregs_xmode
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|xregno
argument_list|,
name|xmode
argument_list|)
expr_stmt|;
name|nregs_ymode
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|xregno
argument_list|,
name|ymode
argument_list|)
expr_stmt|;
comment|/* paradoxical subregs are always valid.  */
if|if
condition|(
name|offset
operator|==
literal|0
operator|&&
name|nregs_ymode
operator|>
name|nregs_xmode
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|ymode
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|?
name|WORDS_BIG_ENDIAN
else|:
name|BYTES_BIG_ENDIAN
operator|)
condition|)
return|return
name|true
return|;
comment|/* Lowpart subregs are always valid.  */
if|if
condition|(
name|offset
operator|==
name|subreg_lowpart_offset
argument_list|(
name|ymode
argument_list|,
name|xmode
argument_list|)
condition|)
return|return
name|true
return|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* This should always pass, otherwise we don't know how to verify the      constraint.  These conditions may be relaxed but subreg_offset would      need to be redesigned.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|xmode
argument_list|)
operator|%
name|GET_MODE_SIZE
argument_list|(
name|ymode
argument_list|)
operator|||
name|GET_MODE_SIZE
argument_list|(
name|ymode
argument_list|)
operator|%
name|nregs_ymode
operator|||
name|nregs_xmode
operator|%
name|nregs_ymode
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* The XMODE value can be seen as a vector of NREGS_XMODE      values.  The subreg must represent a lowpart of given field.      Compute what field it is.  */
name|offset
operator|-=
name|subreg_lowpart_offset
argument_list|(
name|ymode
argument_list|,
name|mode_for_size
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|xmode
argument_list|)
operator|/
name|nregs_xmode
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* size of ymode must not be greater than the size of xmode.  */
name|mode_multiple
operator|=
name|GET_MODE_SIZE
argument_list|(
name|xmode
argument_list|)
operator|/
name|GET_MODE_SIZE
argument_list|(
name|ymode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_multiple
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|y_offset
operator|=
name|offset
operator|/
name|GET_MODE_SIZE
argument_list|(
name|ymode
argument_list|)
expr_stmt|;
name|nregs_multiple
operator|=
name|nregs_xmode
operator|/
name|nregs_ymode
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|offset
operator|%
name|GET_MODE_SIZE
argument_list|(
name|ymode
argument_list|)
operator|||
name|mode_multiple
operator|%
name|nregs_multiple
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|!
operator|(
name|y_offset
operator|%
operator|(
name|mode_multiple
operator|/
name|nregs_multiple
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the final regno that a subreg expression refers to.  */
end_comment

begin_function
name|unsigned
name|int
name|subreg_regno
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|unsigned
name|int
name|ret
decl_stmt|;
name|rtx
name|subreg
init|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|subreg
argument_list|)
decl_stmt|;
name|ret
operator|=
name|regno
operator|+
name|subreg_regno_offset
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|subreg
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_struct
struct|struct
name|parms_set_data
block|{
name|int
name|nregs
decl_stmt|;
name|HARD_REG_SET
name|regs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Helper function for noticing stores to parameter registers.  */
end_comment

begin_function
specifier|static
name|void
name|parms_set
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|pat
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|parms_set_data
modifier|*
name|d
init|=
name|data
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|d
operator|->
name|regs
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
name|d
operator|->
name|regs
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|nregs
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Look backward for first parameter to be loaded.    Do not skip BOUNDARY.  */
end_comment

begin_function
name|rtx
name|find_first_parameter_load
parameter_list|(
name|rtx
name|call_insn
parameter_list|,
name|rtx
name|boundary
parameter_list|)
block|{
name|struct
name|parms_set_data
name|parm
decl_stmt|;
name|rtx
name|p
decl_stmt|,
name|before
decl_stmt|;
comment|/* Since different machines initialize their parameter registers      in different orders, assume nothing.  Collect the set of all      parameter registers.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|parm
operator|.
name|regs
argument_list|)
expr_stmt|;
name|parm
operator|.
name|nregs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call_insn
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|XEXP
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* We only care about registers which can hold function 	   arguments.  */
if|if
condition|(
operator|!
name|FUNCTION_ARG_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
continue|continue;
name|SET_HARD_REG_BIT
argument_list|(
name|parm
operator|.
name|regs
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|parm
operator|.
name|nregs
operator|++
expr_stmt|;
block|}
name|before
operator|=
name|call_insn
expr_stmt|;
comment|/* Search backward for the first set of a register in this set.  */
while|while
condition|(
name|parm
operator|.
name|nregs
operator|&&
name|before
operator|!=
name|boundary
condition|)
block|{
name|before
operator|=
name|PREV_INSN
argument_list|(
name|before
argument_list|)
expr_stmt|;
comment|/* It is possible that some loads got CSEed from one call to          another.  Stop in that case.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|before
argument_list|)
operator|==
name|CALL_INSN
condition|)
break|break;
comment|/* Our caller needs either ensure that we will find all sets          (in case code has not been optimized yet), or take care          for possible labels in a way by setting boundary to preceding          CODE_LABEL.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|before
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
if|if
condition|(
name|before
operator|!=
name|boundary
condition|)
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|INSN_P
argument_list|(
name|before
argument_list|)
condition|)
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|before
argument_list|)
argument_list|,
name|parms_set
argument_list|,
operator|&
name|parm
argument_list|)
expr_stmt|;
block|}
return|return
name|before
return|;
block|}
end_function

begin_comment
comment|/* Return true if we should avoid inserting code between INSN and preceding    call instruction.  */
end_comment

begin_function
name|bool
name|keep_with_call_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|set
decl_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|fixed_regs
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|&&
name|general_operand
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|FUNCTION_VALUE_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|true
return|;
comment|/* There may be a stack pop just after the call and before the store 	 of the return register.  Search for the actual store when deciding 	 if we can break or not.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|stack_pointer_rtx
condition|)
block|{
name|rtx
name|i2
init|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|i2
operator|&&
name|keep_with_call_p
argument_list|(
name|i2
argument_list|)
condition|)
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true when store to register X can be hoisted to the place    with LIVE registers (can be NULL).  Value VAL contains destination    whose value will be used.  */
end_comment

begin_function
specifier|static
name|bool
name|hoist_test_store
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|val
parameter_list|,
name|regset
name|live
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SCRATCH
condition|)
return|return
name|true
return|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|val
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Allow subreg of X in case it is not writing just part of multireg pseudo.      Then we would need to update all users to care hoisting the store too.      Caller may represent that by specifying whole subreg as val.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
name|rtx_equal_p
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|val
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Anything except register store is not hoistable.  This includes the      partial stores to registers.  */
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Pseudo registers can be always replaced by another pseudo to avoid      the side effect, for hard register we must ensure that they are dead.      Eventually we may want to add code to try turn pseudos to hards, but it      is unlikely useful.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|live
condition|)
return|return
name|false
return|;
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|live
argument_list|,
name|regno
argument_list|)
condition|)
return|return
name|false
return|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|live
argument_list|,
name|regno
operator|+
name|n
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true if INSN can be hoisted to place with LIVE hard registers    (LIVE can be NULL when unknown).  VAL is expected to be stored by the insn    and used by the hoisting pass.  */
end_comment

begin_function
name|bool
name|can_hoist_insn_p
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|val
parameter_list|,
name|regset
name|live
parameter_list|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* It probably does not worth the complexity to handle multiple      set stores.  */
if|if
condition|(
operator|!
name|single_set
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We can move CALL_INSN, but we need to check that all caller clobbered      regs are dead.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return
name|false
return|;
comment|/* In future we will handle hoisting of libcall sequences, but      give up for now.  */
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
condition|)
block|{
case|case
name|SET
case|:
if|if
condition|(
operator|!
name|hoist_test_store
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
name|val
argument_list|,
name|live
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|USE
case|:
comment|/* USES do have sick semantics, so do not move them.  */
return|return
name|false
return|;
break|break;
case|case
name|CLOBBER
case|:
if|if
condition|(
operator|!
name|hoist_test_store
argument_list|(
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
argument_list|,
name|val
argument_list|,
name|live
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|PARALLEL
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|SET
case|:
if|if
condition|(
operator|!
name|hoist_test_store
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|val
argument_list|,
name|live
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|USE
case|:
comment|/* We need to fix callers to really ensure availability 	         of all values insn uses, but for now it is safe to prohibit 		 hoisting of any insn having such a hidden uses.  */
return|return
name|false
return|;
break|break;
case|case
name|CLOBBER
case|:
if|if
condition|(
operator|!
name|hoist_test_store
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|val
argument_list|,
name|live
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
default|default:
break|break;
block|}
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Update store after hoisting - replace all stores to pseudo registers    by new ones to avoid clobbering of values except for store to VAL that will    be updated to NEW.  */
end_comment

begin_function
specifier|static
name|void
name|hoist_update_store
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
modifier|*
name|xp
parameter_list|,
name|rtx
name|val
parameter_list|,
name|rtx
name|new
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|xp
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SCRATCH
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
operator|==
name|val
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
name|xp
argument_list|,
name|simplify_gen_subreg
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|,
name|GET_MODE
argument_list|(
name|new
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|val
argument_list|)
condition|)
block|{
name|validate_change
argument_list|(
name|insn
argument_list|,
name|xp
argument_list|,
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|xp
operator|=
operator|&
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
operator|*
name|xp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|x
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* We've verified that hard registers are dead, so we may keep the side      effect.  Otherwise replace it by new pseudo.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
name|xp
argument_list|,
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_UNUSED
argument_list|,
operator|*
name|xp
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a copy of INSN after AFTER replacing store of VAL to NEW    and each other side effect to pseudo register by new pseudo register.  */
end_comment

begin_function
name|rtx
name|hoist_insn_after
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|after
parameter_list|,
name|rtx
name|val
parameter_list|,
name|rtx
name|new
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|insn
operator|=
name|emit_copy_of_insn_after
argument_list|(
name|insn
argument_list|,
name|after
argument_list|)
expr_stmt|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Remove REG_UNUSED notes as we will re-emit them.  */
while|while
condition|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
comment|/* To get this working callers must ensure to move everything referenced      by REG_EQUAL/REG_EQUIV notes too.  Lets remove them, it is probably      easier.  */
while|while
condition|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
comment|/* Remove REG_DEAD notes as they might not be valid anymore in case      we create redundancy.  */
while|while
condition|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
condition|)
block|{
case|case
name|SET
case|:
name|hoist_update_store
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
name|val
argument_list|,
name|new
argument_list|)
expr_stmt|;
break|break;
case|case
name|USE
case|:
break|break;
case|case
name|CLOBBER
case|:
name|hoist_update_store
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
argument_list|,
name|val
argument_list|,
name|new
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARALLEL
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|SET
case|:
name|hoist_update_store
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|val
argument_list|,
name|new
argument_list|)
expr_stmt|;
break|break;
case|case
name|USE
case|:
break|break;
case|case
name|CLOBBER
case|:
name|hoist_update_store
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|val
argument_list|,
name|new
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|apply_change_group
argument_list|()
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_function
name|rtx
name|hoist_insn_to_edge
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|edge
name|e
parameter_list|,
name|rtx
name|val
parameter_list|,
name|rtx
name|new
parameter_list|)
block|{
name|rtx
name|new_insn
decl_stmt|;
comment|/* We cannot insert instructions on an abnormal critical edge.      It will be easier to find the culprit if we die now.  */
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
operator|&&
name|EDGE_CRITICAL_P
argument_list|(
name|e
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Do not use emit_insn_on_edge as we want to preserve notes and similar      stuff.  We also emit CALL_INSNS and firends.  */
if|if
condition|(
name|e
operator|->
name|insns
operator|==
name|NULL_RTX
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_note
argument_list|(
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
block|}
else|else
name|push_to_sequence
argument_list|(
name|e
operator|->
name|insns
argument_list|)
expr_stmt|;
name|new_insn
operator|=
name|hoist_insn_after
argument_list|(
name|insn
argument_list|,
name|get_last_insn
argument_list|()
argument_list|,
name|val
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|e
operator|->
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|new_insn
return|;
block|}
end_function

begin_comment
comment|/* Return true if LABEL is a target of JUMP_INSN.  This applies only    to non-complex jumps.  That is, direct unconditional, conditional,    and tablejumps, but not computed jumps or returns.  It also does    not apply to the fallthru case of a conditional jump.  */
end_comment

begin_function
name|bool
name|label_is_jump_target_p
parameter_list|(
name|rtx
name|label
parameter_list|,
name|rtx
name|jump_insn
parameter_list|)
block|{
name|rtx
name|tmp
init|=
name|JUMP_LABEL
argument_list|(
name|jump_insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|label
operator|==
name|tmp
condition|)
return|return
name|true
return|;
if|if
condition|(
name|tablejump_p
argument_list|(
name|jump_insn
argument_list|,
name|NULL
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
block|{
name|rtvec
name|vec
init|=
name|XVEC
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|veclen
init|=
name|GET_NUM_ELEM
argument_list|(
name|vec
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|veclen
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|label
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

end_unit

