begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Default error handlers for CPP Library.    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1998, 1999, 2000,    2001, 2002  Free Software Foundation, Inc.    Written by Per Bothner, 1994.    Based on CCCP program by Paul Rubin, June 1986    Adapted to ANSI C, Richard Stallman, Jan 1987  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"cpphash.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|print_location
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't remove the blank before do, as otherwise the exgettext    script will mistake this as a function definition */
end_comment

begin_define
define|#
directive|define
name|v_message
parameter_list|(
name|msgid
parameter_list|,
name|ap
parameter_list|)
define|\
value|do { vfprintf (stderr, _(msgid), ap); putc ('\n', stderr); } while (0)
end_define

begin_comment
comment|/* Print the logical file location (LINE, COL) in preparation for a    diagnostic.  Outputs the #include chain if it has changed.  */
end_comment

begin_function
specifier|static
name|void
name|print_location
parameter_list|(
name|pfile
parameter_list|,
name|line
parameter_list|,
name|col
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|,
name|col
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|struct
name|line_map
modifier|*
name|map
decl_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
block|{
name|line
operator|=
name|pfile
operator|->
name|cur_token
index|[
operator|-
literal|1
index|]
operator|.
name|line
expr_stmt|;
name|col
operator|=
name|pfile
operator|->
name|cur_token
index|[
operator|-
literal|1
index|]
operator|.
name|col
expr_stmt|;
block|}
name|map
operator|=
name|lookup_line
argument_list|(
operator|&
name|pfile
operator|->
name|line_maps
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|print_containing_files
argument_list|(
operator|&
name|pfile
operator|->
name|line_maps
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|line
operator|=
name|SOURCE_LINE
argument_list|(
name|map
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|col
operator|==
literal|0
condition|)
name|col
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:"
argument_list|,
name|map
operator|->
name|to_file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|show_column
argument_list|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%u:"
argument_list|,
name|map
operator|->
name|to_file
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%u:%u:"
argument_list|,
name|map
operator|->
name|to_file
argument_list|,
name|line
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set up for an error message: print the file and line, bump the error    counter, etc.  LINE is the logical line number; zero means to print    at the location of the previously lexed token, which tends to be the    correct place by default.  Returns 0 if the error has been suppressed.  */
end_comment

begin_function
name|int
name|_cpp_begin_message
parameter_list|(
name|pfile
parameter_list|,
name|code
parameter_list|,
name|line
parameter_list|,
name|column
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|enum
name|error_type
name|code
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|,
name|column
decl_stmt|;
block|{
name|int
name|is_warning
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PEDWARN
case|:
case|case
name|WARNING
case|:
if|if
condition|(
name|CPP_IN_SYSTEM_HEADER
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_system_headers
argument_list|)
condition|)
return|return
literal|0
return|;
case|case
name|WARNING_SYSHDR
case|:
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warnings_are_errors
argument_list|)
operator|||
operator|(
name|code
operator|==
name|PEDWARN
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pedantic_errors
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|inhibit_errors
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|pfile
operator|->
name|errors
operator|<
name|CPP_FATAL_LIMIT
condition|)
name|pfile
operator|->
name|errors
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|inhibit_warnings
argument_list|)
condition|)
return|return
literal|0
return|;
name|is_warning
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|ERROR
case|:
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|inhibit_errors
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|pfile
operator|->
name|errors
operator|<
name|CPP_FATAL_LIMIT
condition|)
name|pfile
operator|->
name|errors
operator|++
expr_stmt|;
break|break;
comment|/* Fatal errors cannot be inhibited.  */
case|case
name|FATAL
case|:
name|pfile
operator|->
name|errors
operator|=
name|CPP_FATAL_LIMIT
expr_stmt|;
break|break;
case|case
name|ICE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"internal error: "
argument_list|)
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|errors
operator|=
name|CPP_FATAL_LIMIT
expr_stmt|;
break|break;
block|}
name|print_location
argument_list|(
name|pfile
argument_list|,
name|line
argument_list|,
name|column
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_warning
condition|)
name|fputs
argument_list|(
name|_
argument_list|(
literal|"warning: "
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Exported interface.  */
end_comment

begin_comment
comment|/* For reporting internal errors.  Prints "internal error: " for you,    otherwise identical to cpp_fatal.  */
end_comment

begin_decl_stmt
name|void
name|cpp_ice
name|VPARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
name|pfile
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|cpp_reader
operator|*
argument_list|,
name|pfile
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|_cpp_begin_message
argument_list|(
name|pfile
argument_list|,
name|ICE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|v_message
argument_list|(
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Same as cpp_error, except we consider the error to be "fatal",    such as inconsistent options.  I.e. there is little point in continuing.    (We do not exit, to support use of cpplib as a library.    Instead, it is the caller's responsibility to check    CPP_FATAL_ERRORS.  */
end_comment

begin_decl_stmt
name|void
name|cpp_fatal
name|VPARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
name|pfile
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|cpp_reader
operator|*
argument_list|,
name|pfile
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|_cpp_begin_message
argument_list|(
name|pfile
argument_list|,
name|FATAL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|v_message
argument_list|(
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Print an error at the location of the previously lexed token.  */
end_comment

begin_decl_stmt
name|void
name|cpp_error
name|VPARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
name|pfile
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|cpp_reader
operator|*
argument_list|,
name|pfile
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|_cpp_begin_message
argument_list|(
name|pfile
argument_list|,
name|ERROR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|v_message
argument_list|(
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Print an error at a specific location.  */
end_comment

begin_decl_stmt
name|void
name|cpp_error_with_line
name|VPARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
name|pfile
operator|,
name|int
name|line
operator|,
name|int
name|column
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|cpp_reader
operator|*
argument_list|,
name|pfile
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|int
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|int
argument_list|,
name|column
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|_cpp_begin_message
argument_list|(
name|pfile
argument_list|,
name|ERROR
argument_list|,
name|line
argument_list|,
name|column
argument_list|)
condition|)
name|v_message
argument_list|(
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Error including a message from `errno'.  */
end_comment

begin_function
name|void
name|cpp_error_from_errno
parameter_list|(
name|pfile
parameter_list|,
name|name
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"%s: %s"
argument_list|,
name|name
argument_list|,
name|xstrerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a warning at the location of the previously lexed token.  */
end_comment

begin_decl_stmt
name|void
name|cpp_warning
name|VPARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
name|pfile
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|cpp_reader
operator|*
argument_list|,
name|pfile
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|_cpp_begin_message
argument_list|(
name|pfile
argument_list|,
name|WARNING
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|v_message
argument_list|(
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Print a warning at a specific location.  */
end_comment

begin_decl_stmt
name|void
name|cpp_warning_with_line
name|VPARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
name|pfile
operator|,
name|int
name|line
operator|,
name|int
name|column
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|cpp_reader
operator|*
argument_list|,
name|pfile
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|int
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|int
argument_list|,
name|column
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|_cpp_begin_message
argument_list|(
name|pfile
argument_list|,
name|WARNING
argument_list|,
name|line
argument_list|,
name|column
argument_list|)
condition|)
name|v_message
argument_list|(
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Pedwarn at the location of the previously lexed token.  */
end_comment

begin_decl_stmt
name|void
name|cpp_pedwarn
name|VPARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
name|pfile
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|cpp_reader
operator|*
argument_list|,
name|pfile
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|_cpp_begin_message
argument_list|(
name|pfile
argument_list|,
name|PEDWARN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|v_message
argument_list|(
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Pedwarn at a specific location.  */
end_comment

begin_decl_stmt
name|void
name|cpp_pedwarn_with_line
name|VPARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
name|pfile
operator|,
name|int
name|line
operator|,
name|int
name|column
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|cpp_reader
operator|*
argument_list|,
name|pfile
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|int
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|int
argument_list|,
name|column
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|_cpp_begin_message
argument_list|(
name|pfile
argument_list|,
name|PEDWARN
argument_list|,
name|line
argument_list|,
name|column
argument_list|)
condition|)
name|v_message
argument_list|(
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Print an error message not associated with the translation unit.  */
end_comment

begin_decl_stmt
name|void
name|cpp_notice
name|VPARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
name|pfile
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|cpp_reader
operator|*
argument_list|,
name|pfile
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|errors
operator|<
name|CPP_FATAL_LIMIT
condition|)
name|pfile
operator|->
name|errors
operator|++
expr_stmt|;
name|v_message
argument_list|(
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Print an error message originating from ERRNO and not associated    with the translation unit.  */
end_comment

begin_function
name|void
name|cpp_notice_from_errno
parameter_list|(
name|pfile
parameter_list|,
name|name
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|name
operator|=
literal|"stdout"
expr_stmt|;
name|cpp_notice
argument_list|(
name|pfile
argument_list|,
literal|"%s: %s"
argument_list|,
name|name
argument_list|,
name|xstrerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

