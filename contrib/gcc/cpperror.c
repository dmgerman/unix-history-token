begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Default error handlers for CPP Library.    Copyright (C) 1986, 87, 89, 92-95, 98, 1999 Free Software Foundation, Inc.    Written by Per Bothner, 1994.    Based on CCCP program by Paul Rubin, June 1986    Adapted to ANSI C, Richard Stallman, Jan 1987  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EMACS
end_ifndef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not EMACS */
end_comment

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_comment
comment|/* Print the file names and line numbers of the #include    commands which led to the current file.  */
end_comment

begin_function
name|void
name|cpp_print_containing_files
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|ip
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
comment|/* If stack of files hasn't changed since we last printed      this info, don't repeat it.  */
if|if
condition|(
name|pfile
operator|->
name|input_stack_listing_current
condition|)
return|return;
name|ip
operator|=
name|cpp_file_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* Give up if we don't find a source file.  */
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
return|return;
comment|/* Find the other, outer source files.  */
while|while
condition|(
operator|(
name|ip
operator|=
name|CPP_PREV_BUFFER
argument_list|(
name|ip
argument_list|)
operator|)
operator|,
name|ip
operator|!=
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
name|long
name|line
decl_stmt|,
name|col
decl_stmt|;
name|cpp_buf_line_and_col
argument_list|(
name|ip
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|col
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|fname
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
name|cpp_notice
argument_list|(
literal|"In file included from %s:%ld"
argument_list|,
name|ip
operator|->
name|nominal_fname
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
else|else
name|cpp_message
argument_list|(
name|pfile
argument_list|,
operator|-
literal|1
argument_list|,
literal|",\n                 from %s:%ld"
argument_list|,
name|ip
operator|->
name|nominal_fname
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|first
condition|)
name|fputs
argument_list|(
literal|":\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
comment|/* Record we have printed the status as of this time.  */
name|pfile
operator|->
name|input_stack_listing_current
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cpp_file_line_for_message
parameter_list|(
name|pfile
parameter_list|,
name|filename
parameter_list|,
name|line
parameter_list|,
name|column
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|,
name|column
decl_stmt|;
block|{
if|if
condition|(
name|column
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d:%d: "
argument_list|,
name|filename
argument_list|,
name|line
argument_list|,
name|column
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* IS_ERROR is 2 for "fatal" error, 1 for error, 0 for warning, -1 for notice */
end_comment

begin_function
name|void
name|v_cpp_message
parameter_list|(
name|pfile
parameter_list|,
name|is_error
parameter_list|,
name|msgid
parameter_list|,
name|ap
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|is_error
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
switch|switch
condition|(
name|is_error
condition|)
block|{
case|case
operator|-
literal|1
case|:
break|break;
case|case
literal|0
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"warning: "
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|pfile
operator|->
name|errors
operator|<
name|CPP_FATAL_LIMIT
condition|)
name|pfile
operator|->
name|errors
operator|++
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|pfile
operator|->
name|errors
operator|=
name|CPP_FATAL_LIMIT
expr_stmt|;
break|break;
default|default:
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"internal error: bad is_error(%d) in v_cpp_message"
argument_list|,
name|is_error
argument_list|)
expr_stmt|;
block|}
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|is_error
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|cpp_message
name|VPROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
name|pfile
operator|,
name|int
name|is_error
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|is_error
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|pfile
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|cpp_reader
operator|*
argument_list|)
expr_stmt|;
name|is_error
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v_cpp_message
argument_list|(
name|pfile
argument_list|,
name|is_error
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Same as cpp_error, except we consider the error to be "fatal",    such as inconsistent options.  I.e. there is little point in continuing.    (We do not exit, to support use of cpplib as a library.    Instead, it is the caller's responsibility to check    CPP_FATAL_ERRORS.  */
end_comment

begin_decl_stmt
name|void
name|cpp_fatal
name|VPROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
name|pfile
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|pfile
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|cpp_reader
operator|*
argument_list|)
expr_stmt|;
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|v_cpp_message
argument_list|(
name|pfile
argument_list|,
literal|2
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|cpp_pfatal_with_name
parameter_list|(
name|pfile
parameter_list|,
name|name
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|cpp_perror_with_name
argument_list|(
name|pfile
argument_list|,
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|exit
argument_list|(
name|vaxc$errno
argument_list|)
expr_stmt|;
else|#
directive|else
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Print an error message.  */
end_comment

begin_decl_stmt
name|void
name|cpp_notice
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|v_cpp_message
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_escape
end_escape

end_unit

