begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support routines for the various generation passes.    Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"hconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"gensupport.h"
end_include

begin_comment
comment|/* In case some macros used by files we include need it, define this here.  */
end_comment

begin_decl_stmt
name|int
name|target_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|insn_elision
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|rtl_obstack
init|=
operator|&
name|obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sequence_num
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|errors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|predicable_default
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|predicable_true
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|predicable_false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|htab_t
name|condition_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|base_dir
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We initially queue all patterns, process the define_insn and    define_cond_exec patterns, then return them one at a time.  */
end_comment

begin_struct
struct|struct
name|queue_elem
block|{
name|rtx
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|lineno
decl_stmt|;
name|struct
name|queue_elem
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|queue_elem
modifier|*
name|define_attr_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|queue_elem
modifier|*
modifier|*
name|define_attr_tail
init|=
operator|&
name|define_attr_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|queue_elem
modifier|*
name|define_insn_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|queue_elem
modifier|*
modifier|*
name|define_insn_tail
init|=
operator|&
name|define_insn_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|queue_elem
modifier|*
name|define_cond_exec_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|queue_elem
modifier|*
modifier|*
name|define_cond_exec_tail
init|=
operator|&
name|define_cond_exec_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|queue_elem
modifier|*
name|other_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|queue_elem
modifier|*
modifier|*
name|other_tail
init|=
operator|&
name|other_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|queue_pattern
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|queue_elem
operator|*
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current maximum length of directory names in the search path    for include files.  (Altered as we get more of them.)  */
end_comment

begin_decl_stmt
name|size_t
name|max_include_len
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|file_name_list
block|{
name|struct
name|file_name_list
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|file_name_list
modifier|*
name|first_dir_md_include
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First dir to search */
end_comment

begin_comment
comment|/* First dir to search for<file> */
end_comment

begin_decl_stmt
name|struct
name|file_name_list
modifier|*
name|first_bracket_include
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|file_name_list
modifier|*
name|last_dir_md_include
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last in chain */
end_comment

begin_decl_stmt
specifier|static
name|void
name|remove_constraints
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_rtx
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_predicable
name|PARAMS
argument_list|(
operator|(
expr|struct
name|queue_elem
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|identify_predicable_attribute
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_alternatives
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|collect_insn_data
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|alter_predicate_for_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|alter_test_for_insn
name|PARAMS
argument_list|(
operator|(
expr|struct
name|queue_elem
operator|*
operator|,
expr|struct
name|queue_elem
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|shift_output_template
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|alter_output_for_insn
name|PARAMS
argument_list|(
operator|(
expr|struct
name|queue_elem
operator|*
operator|,
expr|struct
name|queue_elem
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_one_cond_exec
name|PARAMS
argument_list|(
operator|(
expr|struct
name|queue_elem
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_define_cond_exec
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_include
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|save_string
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
name|void
name|message_with_line
name|VPARAMS
argument_list|(
operator|(
name|int
name|lineno
operator|,
specifier|const
name|char
operator|*
name|msg
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|int
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|read_rtx_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Make a version of gen_rtx_CONST_INT so that GEN_INT can be used in    the gensupport programs.  */
end_comment

begin_function
name|rtx
name|gen_rtx_CONST_INT
parameter_list|(
name|mode
parameter_list|,
name|arg
parameter_list|)
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|HOST_WIDE_INT
name|arg
decl_stmt|;
block|{
name|rtx
name|rt
init|=
name|rtx_alloc
argument_list|(
name|CONST_INT
argument_list|)
decl_stmt|;
name|XWINT
argument_list|(
name|rt
argument_list|,
literal|0
argument_list|)
operator|=
name|arg
expr_stmt|;
return|return
name|rt
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Queue PATTERN on LIST_TAIL.  */
end_comment

begin_function
specifier|static
name|void
name|queue_pattern
parameter_list|(
name|pattern
parameter_list|,
name|list_tail
parameter_list|,
name|filename
parameter_list|,
name|lineno
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
name|struct
name|queue_elem
modifier|*
modifier|*
modifier|*
name|list_tail
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|lineno
decl_stmt|;
block|{
name|struct
name|queue_elem
modifier|*
name|e
init|=
operator|(
expr|struct
name|queue_elem
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|e
argument_list|)
argument_list|)
decl_stmt|;
name|e
operator|->
name|data
operator|=
name|pattern
expr_stmt|;
name|e
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
name|e
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
name|e
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
operator|*
name|list_tail
operator|=
name|e
expr_stmt|;
operator|*
name|list_tail
operator|=
operator|&
name|e
operator|->
name|next
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Recursively remove constraints from an rtx.  */
end_comment

begin_function
specifier|static
name|void
name|remove_constraints
parameter_list|(
name|part
parameter_list|)
name|rtx
name|part
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
if|if
condition|(
name|part
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
operator|==
name|MATCH_OPERAND
condition|)
name|XSTR
argument_list|(
name|part
argument_list|,
literal|2
argument_list|)
operator|=
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
operator|==
name|MATCH_SCRATCH
condition|)
name|XSTR
argument_list|(
name|part
argument_list|,
literal|1
argument_list|)
operator|=
literal|""
expr_stmt|;
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
name|remove_constraints
argument_list|(
name|XEXP
argument_list|(
name|part
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|part
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|part
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|remove_constraints
argument_list|(
name|XVECEXP
argument_list|(
name|part
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Process an include file assuming that it lives in gcc/config/{target}/     if the include looks like (include "file").  */
end_comment

begin_function
specifier|static
name|void
name|process_include
parameter_list|(
name|desc
parameter_list|,
name|lineno
parameter_list|)
name|rtx
name|desc
decl_stmt|;
name|int
name|lineno
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|XSTR
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_filename
decl_stmt|;
name|int
name|old_lineno
decl_stmt|;
name|char
modifier|*
name|pathname
decl_stmt|;
name|FILE
modifier|*
name|input_file
decl_stmt|;
comment|/* If specified file name is absolute, skip the include stack.  */
if|if
condition|(
operator|!
name|IS_ABSOLUTE_PATHNAME
argument_list|(
name|filename
argument_list|)
condition|)
block|{
name|struct
name|file_name_list
modifier|*
name|stackp
decl_stmt|;
comment|/* Search directory path, trying to open the file.  */
for|for
control|(
name|stackp
operator|=
name|first_dir_md_include
init|;
name|stackp
condition|;
name|stackp
operator|=
name|stackp
operator|->
name|next
control|)
block|{
specifier|static
specifier|const
name|char
name|sep
index|[
literal|2
index|]
init|=
block|{
name|DIR_SEPARATOR
block|,
literal|'\0'
block|}
decl_stmt|;
name|pathname
operator|=
name|concat
argument_list|(
name|stackp
operator|->
name|fname
argument_list|,
name|sep
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|input_file
operator|=
name|fopen
argument_list|(
name|pathname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_file
operator|!=
name|NULL
condition|)
goto|goto
name|success
goto|;
name|free
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|base_dir
condition|)
name|pathname
operator|=
name|concat
argument_list|(
name|base_dir
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|pathname
operator|=
name|xstrdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|input_file
operator|=
name|fopen
argument_list|(
name|pathname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_file
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"include file `%s' not found"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|success
label|:
comment|/* Save old cursor; setup new for the new file.  Note that "lineno" the      argument to this function is the beginning of the include statement,      while read_rtx_lineno has already been advanced.  */
name|old_filename
operator|=
name|read_rtx_filename
expr_stmt|;
name|old_lineno
operator|=
name|read_rtx_lineno
expr_stmt|;
name|read_rtx_filename
operator|=
name|pathname
expr_stmt|;
name|read_rtx_lineno
operator|=
literal|1
expr_stmt|;
comment|/* Read the entire file.  */
while|while
condition|(
literal|1
condition|)
block|{
name|rtx
name|desc
decl_stmt|;
name|int
name|c
decl_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|ungetc
argument_list|(
name|c
argument_list|,
name|input_file
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|read_rtx_lineno
expr_stmt|;
name|desc
operator|=
name|read_rtx
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
name|process_rtx
argument_list|(
name|desc
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
comment|/* Do not free pathname.  It is attached to the various rtx queue      elements.  */
name|read_rtx_filename
operator|=
name|old_filename
expr_stmt|;
name|read_rtx_lineno
operator|=
name|old_lineno
expr_stmt|;
name|fclose
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a top level rtx in some way, queueing as appropriate.  */
end_comment

begin_function
specifier|static
name|void
name|process_rtx
parameter_list|(
name|desc
parameter_list|,
name|lineno
parameter_list|)
name|rtx
name|desc
decl_stmt|;
name|int
name|lineno
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
condition|)
block|{
case|case
name|DEFINE_INSN
case|:
name|queue_pattern
argument_list|(
name|desc
argument_list|,
operator|&
name|define_insn_tail
argument_list|,
name|read_rtx_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_COND_EXEC
case|:
name|queue_pattern
argument_list|(
name|desc
argument_list|,
operator|&
name|define_cond_exec_tail
argument_list|,
name|read_rtx_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_ATTR
case|:
name|queue_pattern
argument_list|(
name|desc
argument_list|,
operator|&
name|define_attr_tail
argument_list|,
name|read_rtx_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
case|case
name|INCLUDE
case|:
name|process_include
argument_list|(
name|desc
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_INSN_AND_SPLIT
case|:
block|{
specifier|const
name|char
modifier|*
name|split_cond
decl_stmt|;
name|rtx
name|split
decl_stmt|;
name|rtvec
name|attr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Create a split with values from the insn_and_split.  */
name|split
operator|=
name|rtx_alloc
argument_list|(
name|DEFINE_SPLIT
argument_list|)
expr_stmt|;
name|i
operator|=
name|XVECLEN
argument_list|(
name|desc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|split
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
name|XVECEXP
argument_list|(
name|split
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|desc
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|remove_constraints
argument_list|(
name|XVECEXP
argument_list|(
name|split
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the split condition starts with "&&", append it to the 	   insn condition to create the new split condition.  */
name|split_cond
operator|=
name|XSTR
argument_list|(
name|desc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|split_cond
index|[
literal|0
index|]
operator|==
literal|'&'
operator|&&
name|split_cond
index|[
literal|1
index|]
operator|==
literal|'&'
condition|)
name|split_cond
operator|=
name|concat
argument_list|(
name|XSTR
argument_list|(
name|desc
argument_list|,
literal|2
argument_list|)
argument_list|,
name|split_cond
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|split
argument_list|,
literal|1
argument_list|)
operator|=
name|split_cond
expr_stmt|;
name|XVEC
argument_list|(
name|split
argument_list|,
literal|2
argument_list|)
operator|=
name|XVEC
argument_list|(
name|desc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|split
argument_list|,
literal|3
argument_list|)
operator|=
name|XSTR
argument_list|(
name|desc
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* Fix up the DEFINE_INSN.  */
name|attr
operator|=
name|XVEC
argument_list|(
name|desc
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|desc
argument_list|,
name|DEFINE_INSN
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|desc
argument_list|,
literal|4
argument_list|)
operator|=
name|attr
expr_stmt|;
comment|/* Queue them.  */
name|queue_pattern
argument_list|(
name|desc
argument_list|,
operator|&
name|define_insn_tail
argument_list|,
name|read_rtx_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|queue_pattern
argument_list|(
name|split
argument_list|,
operator|&
name|other_tail
argument_list|,
name|read_rtx_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|queue_pattern
argument_list|(
name|desc
argument_list|,
operator|&
name|other_tail
argument_list|,
name|read_rtx_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if attribute PREDICABLE is true for ELEM, which holds    a DEFINE_INSN.  */
end_comment

begin_function
specifier|static
name|int
name|is_predicable
parameter_list|(
name|elem
parameter_list|)
name|struct
name|queue_elem
modifier|*
name|elem
decl_stmt|;
block|{
name|rtvec
name|vec
init|=
name|XVEC
argument_list|(
name|elem
operator|->
name|data
argument_list|,
literal|4
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|vec
condition|)
return|return
name|predicable_default
return|;
for|for
control|(
name|i
operator|=
name|GET_NUM_ELEM
argument_list|(
name|vec
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|rtx
name|sub
init|=
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|sub
argument_list|)
condition|)
block|{
case|case
name|SET_ATTR
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|sub
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"predicable"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|value
operator|=
name|XSTR
argument_list|(
name|sub
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
break|break;
case|case
name|SET_ATTR_ALTERNATIVE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|sub
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"predicable"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|message_with_line
argument_list|(
name|elem
operator|->
name|lineno
argument_list|,
literal|"multiple alternatives for `predicable'"
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|SET
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|sub
argument_list|)
argument_list|)
operator|!=
name|ATTR
operator|||
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|SET_DEST
argument_list|(
name|sub
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"predicable"
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|sub
operator|=
name|SET_SRC
argument_list|(
name|sub
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|sub
argument_list|)
operator|==
name|CONST_STRING
condition|)
block|{
name|value
operator|=
name|XSTR
argument_list|(
name|sub
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
comment|/* ??? It would be possible to handle this if we really tried. 	     It's not easy though, and I'm not going to bother until it 	     really proves necessary.  */
name|message_with_line
argument_list|(
name|elem
operator|->
name|lineno
argument_list|,
literal|"non-constant value for `predicable'"
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|predicable_default
return|;
name|found
label|:
comment|/* Verify that predicability does not vary on the alternative.  */
comment|/* ??? It should be possible to handle this by simply eliminating      the non-predicable alternatives from the insn.  FRV would like      to do this.  Delay this until we've got the basics solid.  */
if|if
condition|(
name|strchr
argument_list|(
name|value
argument_list|,
literal|','
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|message_with_line
argument_list|(
name|elem
operator|->
name|lineno
argument_list|,
literal|"multiple alternatives for `predicable'"
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Find out which value we're looking at.  */
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
name|predicable_true
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
name|predicable_false
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|message_with_line
argument_list|(
name|elem
operator|->
name|lineno
argument_list|,
literal|"unknown value `%s' for `predicable' attribute"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Examine the attribute "predicable"; discover its boolean values    and its default.  */
end_comment

begin_function
specifier|static
name|void
name|identify_predicable_attribute
parameter_list|()
block|{
name|struct
name|queue_elem
modifier|*
name|elem
decl_stmt|;
name|char
modifier|*
name|p_true
decl_stmt|,
modifier|*
name|p_false
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
comment|/* Look for the DEFINE_ATTR for `predicable', which must exist.  */
for|for
control|(
name|elem
operator|=
name|define_attr_queue
init|;
name|elem
condition|;
name|elem
operator|=
name|elem
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|elem
operator|->
name|data
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"predicable"
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
name|message_with_line
argument_list|(
name|define_cond_exec_queue
operator|->
name|lineno
argument_list|,
literal|"attribute `predicable' not defined"
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return;
name|found
label|:
name|value
operator|=
name|XSTR
argument_list|(
name|elem
operator|->
name|data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p_false
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|p_true
operator|=
name|strchr
argument_list|(
name|p_false
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_true
operator|==
name|NULL
operator|||
name|strchr
argument_list|(
operator|++
name|p_true
argument_list|,
literal|','
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|message_with_line
argument_list|(
name|elem
operator|->
name|lineno
argument_list|,
literal|"attribute `predicable' is not a boolean"
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|p_true
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|predicable_true
operator|=
name|p_true
expr_stmt|;
name|predicable_false
operator|=
name|p_false
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|elem
operator|->
name|data
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|CONST_STRING
case|:
name|value
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|elem
operator|->
name|data
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
name|message_with_line
argument_list|(
name|elem
operator|->
name|lineno
argument_list|,
literal|"attribute `predicable' cannot be const"
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return;
default|default:
name|message_with_line
argument_list|(
name|elem
operator|->
name|lineno
argument_list|,
literal|"attribute `predicable' must have a constant default"
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
name|p_true
argument_list|)
operator|==
literal|0
condition|)
name|predicable_default
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
name|p_false
argument_list|)
operator|==
literal|0
condition|)
name|predicable_default
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|message_with_line
argument_list|(
name|elem
operator|->
name|lineno
argument_list|,
literal|"unknown value `%s' for `predicable' attribute"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the number of alternatives in constraint S.  */
end_comment

begin_function
specifier|static
name|int
name|n_alternatives
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|n
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|s
condition|)
while|while
condition|(
operator|*
name|s
condition|)
name|n
operator|+=
operator|(
operator|*
name|s
operator|++
operator|==
literal|','
operator|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Determine how many alternatives there are in INSN, and how many    operands.  */
end_comment

begin_function
specifier|static
name|void
name|collect_insn_data
parameter_list|(
name|pattern
parameter_list|,
name|palt
parameter_list|,
name|pmax
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
name|int
modifier|*
name|palt
decl_stmt|,
decl|*
name|pmax
decl_stmt|;
end_function

begin_block
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|len
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MATCH_OPERAND
case|:
name|i
operator|=
name|n_alternatives
argument_list|(
name|XSTR
argument_list|(
name|pattern
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|palt
operator|=
operator|(
name|i
operator|>
operator|*
name|palt
condition|?
name|i
else|:
operator|*
name|palt
operator|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|MATCH_OPERATOR
case|:
case|case
name|MATCH_SCRATCH
case|:
case|case
name|MATCH_PARALLEL
case|:
case|case
name|MATCH_INSN
case|:
name|i
operator|=
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
operator|*
name|pmax
condition|)
operator|*
name|pmax
operator|=
name|i
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
name|collect_insn_data
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
argument_list|,
name|palt
argument_list|,
name|pmax
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
operator|==
name|NULL
condition|)
break|break;
comment|/* FALLTHRU */
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
name|collect_insn_data
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|palt
argument_list|,
name|pmax
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'w'
case|:
case|case
literal|'0'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_function
specifier|static
name|rtx
name|alter_predicate_for_insn
parameter_list|(
name|pattern
parameter_list|,
name|alt
parameter_list|,
name|max_op
parameter_list|,
name|lineno
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
name|int
name|alt
decl_stmt|,
name|max_op
decl_stmt|,
name|lineno
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|len
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MATCH_OPERAND
case|:
block|{
specifier|const
name|char
modifier|*
name|c
init|=
name|XSTR
argument_list|(
name|pattern
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|n_alternatives
argument_list|(
name|c
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"too many alternatives for operand %d"
argument_list|,
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Replicate C as needed to fill out ALT alternatives.  */
if|if
condition|(
name|c
operator|&&
operator|*
name|c
operator|&&
name|alt
operator|>
literal|1
condition|)
block|{
name|size_t
name|c_len
init|=
name|strlen
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|size_t
name|len
init|=
name|alt
operator|*
operator|(
name|c_len
operator|+
literal|1
operator|)
decl_stmt|;
name|char
modifier|*
name|new_c
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|new_c
argument_list|,
name|c
argument_list|,
name|c_len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|alt
condition|;
operator|++
name|i
control|)
block|{
name|new_c
index|[
name|i
operator|*
operator|(
name|c_len
operator|+
literal|1
operator|)
operator|-
literal|1
index|]
operator|=
literal|','
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|new_c
index|[
name|i
operator|*
operator|(
name|c_len
operator|+
literal|1
operator|)
index|]
argument_list|,
name|c
argument_list|,
name|c_len
argument_list|)
expr_stmt|;
block|}
name|new_c
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|XSTR
argument_list|(
name|pattern
argument_list|,
literal|2
argument_list|)
operator|=
name|new_c
expr_stmt|;
block|}
block|}
comment|/* FALLTHRU */
case|case
name|MATCH_OPERATOR
case|:
case|case
name|MATCH_SCRATCH
case|:
case|case
name|MATCH_PARALLEL
case|:
case|case
name|MATCH_INSN
case|:
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
operator|+=
name|max_op
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|r
decl_stmt|;
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
name|r
operator|=
name|alter_predicate_for_insn
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
argument_list|,
name|alt
argument_list|,
name|max_op
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
name|r
return|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
block|{
name|r
operator|=
name|alter_predicate_for_insn
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|alt
argument_list|,
name|max_op
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
name|r
return|;
block|}
break|break;
case|case
literal|'i'
case|:
case|case
literal|'w'
case|:
case|case
literal|'0'
case|:
case|case
literal|'s'
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|pattern
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|alter_test_for_insn
parameter_list|(
name|ce_elem
parameter_list|,
name|insn_elem
parameter_list|)
name|struct
name|queue_elem
modifier|*
name|ce_elem
decl_stmt|,
decl|*
name|insn_elem
decl_stmt|;
end_function

begin_block
block|{
specifier|const
name|char
modifier|*
name|ce_test
decl_stmt|,
modifier|*
name|insn_test
decl_stmt|;
name|ce_test
operator|=
name|XSTR
argument_list|(
name|ce_elem
operator|->
name|data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|insn_test
operator|=
name|XSTR
argument_list|(
name|insn_elem
operator|->
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ce_test
operator|||
operator|*
name|ce_test
operator|==
literal|'\0'
condition|)
return|return
name|insn_test
return|;
if|if
condition|(
operator|!
name|insn_test
operator|||
operator|*
name|insn_test
operator|==
literal|'\0'
condition|)
return|return
name|ce_test
return|;
return|return
name|concat
argument_list|(
literal|"("
argument_list|,
name|ce_test
argument_list|,
literal|")&& ("
argument_list|,
name|insn_test
argument_list|,
literal|")"
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Adjust all of the operand numbers in OLD to match the shift they'll    get from an operand displacement of DISP.  Return a pointer after the    adjusted string.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|shift_output_template
parameter_list|(
name|new
parameter_list|,
name|old
parameter_list|,
name|disp
parameter_list|)
name|char
modifier|*
name|new
decl_stmt|;
specifier|const
name|char
modifier|*
name|old
decl_stmt|;
name|int
name|disp
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|old
condition|)
block|{
name|char
name|c
init|=
operator|*
name|old
operator|++
decl_stmt|;
operator|*
name|new
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
name|c
operator|=
operator|*
name|old
operator|++
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
condition|)
name|c
operator|+=
name|disp
expr_stmt|;
elseif|else
if|if
condition|(
name|ISALPHA
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|*
name|new
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
operator|*
name|old
operator|++
operator|+
name|disp
expr_stmt|;
block|}
operator|*
name|new
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
return|return
name|new
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|alter_output_for_insn
parameter_list|(
name|ce_elem
parameter_list|,
name|insn_elem
parameter_list|,
name|alt
parameter_list|,
name|max_op
parameter_list|)
name|struct
name|queue_elem
modifier|*
name|ce_elem
decl_stmt|,
decl|*
name|insn_elem
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|alt
decl_stmt|,
name|max_op
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|const
name|char
modifier|*
name|ce_out
decl_stmt|,
modifier|*
name|insn_out
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|ce_len
decl_stmt|,
name|insn_len
decl_stmt|;
comment|/* ??? Could coordinate with genoutput to not duplicate code here.  */
name|ce_out
operator|=
name|XSTR
argument_list|(
name|ce_elem
operator|->
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|insn_out
operator|=
name|XTMPL
argument_list|(
name|insn_elem
operator|->
name|data
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ce_out
operator|||
operator|*
name|ce_out
operator|==
literal|'\0'
condition|)
return|return
name|insn_out
return|;
name|ce_len
operator|=
name|strlen
argument_list|(
name|ce_out
argument_list|)
expr_stmt|;
name|insn_len
operator|=
name|strlen
argument_list|(
name|insn_out
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|insn_out
operator|==
literal|'*'
condition|)
comment|/* You must take care of the predicate yourself.  */
return|return
name|insn_out
return|;
if|if
condition|(
operator|*
name|insn_out
operator|==
literal|'@'
condition|)
block|{
name|len
operator|=
operator|(
name|ce_len
operator|+
literal|1
operator|)
operator|*
name|alt
operator|+
name|insn_len
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|new
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
do|do
block|{
do|do
operator|*
name|p
operator|++
operator|=
operator|*
name|insn_out
operator|++
expr_stmt|;
do|while
condition|(
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|insn_out
argument_list|)
condition|)
do|;
if|if
condition|(
operator|*
name|insn_out
operator|!=
literal|'#'
condition|)
block|{
name|p
operator|=
name|shift_output_template
argument_list|(
name|p
argument_list|,
name|ce_out
argument_list|,
name|max_op
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
do|do
operator|*
name|p
operator|++
operator|=
operator|*
name|insn_out
operator|++
expr_stmt|;
do|while
condition|(
operator|*
name|insn_out
operator|&&
operator|*
name|insn_out
operator|!=
literal|'\n'
condition|)
do|;
block|}
do|while
condition|(
operator|*
name|insn_out
condition|)
do|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|ce_len
operator|+
literal|1
operator|+
name|insn_len
operator|+
literal|1
expr_stmt|;
name|new
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|=
name|shift_output_template
argument_list|(
name|new
argument_list|,
name|ce_out
argument_list|,
name|max_op
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|insn_out
argument_list|,
name|insn_len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|new
return|;
block|}
end_block

begin_comment
comment|/* Replicate insns as appropriate for the given DEFINE_COND_EXEC.  */
end_comment

begin_function
specifier|static
name|void
name|process_one_cond_exec
parameter_list|(
name|ce_elem
parameter_list|)
name|struct
name|queue_elem
modifier|*
name|ce_elem
decl_stmt|;
block|{
name|struct
name|queue_elem
modifier|*
name|insn_elem
decl_stmt|;
for|for
control|(
name|insn_elem
operator|=
name|define_insn_queue
init|;
name|insn_elem
condition|;
name|insn_elem
operator|=
name|insn_elem
operator|->
name|next
control|)
block|{
name|int
name|alternatives
decl_stmt|,
name|max_operand
decl_stmt|;
name|rtx
name|pred
decl_stmt|,
name|insn
decl_stmt|,
name|pattern
decl_stmt|;
if|if
condition|(
operator|!
name|is_predicable
argument_list|(
name|insn_elem
argument_list|)
condition|)
continue|continue;
name|alternatives
operator|=
literal|1
expr_stmt|;
name|max_operand
operator|=
operator|-
literal|1
expr_stmt|;
name|collect_insn_data
argument_list|(
name|insn_elem
operator|->
name|data
argument_list|,
operator|&
name|alternatives
argument_list|,
operator|&
name|max_operand
argument_list|)
expr_stmt|;
name|max_operand
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|XVECLEN
argument_list|(
name|ce_elem
operator|->
name|data
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|message_with_line
argument_list|(
name|ce_elem
operator|->
name|lineno
argument_list|,
literal|"too many patterns in predicate"
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|pred
operator|=
name|copy_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|ce_elem
operator|->
name|data
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pred
operator|=
name|alter_predicate_for_insn
argument_list|(
name|pred
argument_list|,
name|alternatives
argument_list|,
name|max_operand
argument_list|,
name|ce_elem
operator|->
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|pred
operator|==
name|NULL
condition|)
return|return;
comment|/* Construct a new pattern for the new insn.  */
name|insn
operator|=
name|copy_rtx
argument_list|(
name|insn_elem
operator|->
name|data
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
operator|=
literal|""
expr_stmt|;
name|pattern
operator|=
name|rtx_alloc
argument_list|(
name|COND_EXEC
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
operator|=
name|pred
expr_stmt|;
if|if
condition|(
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|=
name|pattern
expr_stmt|;
name|PUT_NUM_ELEM
argument_list|(
name|XVEC
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|)
operator|=
name|rtx_alloc
argument_list|(
name|PARALLEL
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|XVEC
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|=
name|pattern
expr_stmt|;
block|}
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|2
argument_list|)
operator|=
name|alter_test_for_insn
argument_list|(
name|ce_elem
argument_list|,
name|insn_elem
argument_list|)
expr_stmt|;
name|XTMPL
argument_list|(
name|insn
argument_list|,
literal|3
argument_list|)
operator|=
name|alter_output_for_insn
argument_list|(
name|ce_elem
argument_list|,
name|insn_elem
argument_list|,
name|alternatives
argument_list|,
name|max_operand
argument_list|)
expr_stmt|;
comment|/* ??? Set `predicable' to false.  Not crucial since it's really          only used here, and we won't reprocess this new pattern.  */
comment|/* Put the new pattern on the `other' list so that it 	 (a) is not reprocessed by other define_cond_exec patterns 	 (b) appears after all normal define_insn patterns.  	 ??? B is debatable.  If one has normal insns that match 	 cond_exec patterns, they will be preferred over these 	 generated patterns.  Whether this matters in practice, or if 	 it's a good thing, or whether we should thread these new 	 patterns into the define_insn chain just after their generator 	 is something we'll have to experiment with.  */
name|queue_pattern
argument_list|(
name|insn
argument_list|,
operator|&
name|other_tail
argument_list|,
name|insn_elem
operator|->
name|filename
argument_list|,
name|insn_elem
operator|->
name|lineno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If we have any DEFINE_COND_EXEC patterns, expand the DEFINE_INSN    patterns appropriately.  */
end_comment

begin_function
specifier|static
name|void
name|process_define_cond_exec
parameter_list|()
block|{
name|struct
name|queue_elem
modifier|*
name|elem
decl_stmt|;
name|identify_predicable_attribute
argument_list|()
expr_stmt|;
if|if
condition|(
name|errors
condition|)
return|return;
for|for
control|(
name|elem
operator|=
name|define_cond_exec_queue
init|;
name|elem
condition|;
name|elem
operator|=
name|elem
operator|->
name|next
control|)
name|process_one_cond_exec
argument_list|(
name|elem
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|save_string
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|result
init|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|result
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The entry point for initializing the reader.  */
end_comment

begin_function
name|int
name|init_md_reader_args
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|in_fname
decl_stmt|;
name|max_include_len
operator|=
literal|0
expr_stmt|;
name|in_fname
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
if|if
condition|(
name|in_fname
operator|==
name|NULL
condition|)
name|in_fname
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|int
name|c
init|=
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'I'
case|:
comment|/* Add directory to path for includes.  */
block|{
name|struct
name|file_name_list
modifier|*
name|dirtmp
decl_stmt|;
name|dirtmp
operator|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* New one goes on the end */
if|if
condition|(
name|first_dir_md_include
operator|==
literal|0
condition|)
name|first_dir_md_include
operator|=
name|dirtmp
expr_stmt|;
else|else
name|last_dir_md_include
operator|->
name|next
operator|=
name|dirtmp
expr_stmt|;
name|last_dir_md_include
operator|=
name|dirtmp
expr_stmt|;
comment|/* Tail follows the last one */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'I'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|dirtmp
operator|->
name|fname
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"directory name missing after -I option"
argument_list|)
expr_stmt|;
else|else
name|dirtmp
operator|->
name|fname
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|dirtmp
operator|->
name|fname
argument_list|)
operator|>
name|max_include_len
condition|)
name|max_include_len
operator|=
name|strlen
argument_list|(
name|dirtmp
operator|->
name|fname
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|fatal
argument_list|(
literal|"invalid option `%s'"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|init_md_reader
argument_list|(
name|in_fname
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The entry point for initializing the reader.  */
end_comment

begin_function
name|int
name|init_md_reader
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|FILE
modifier|*
name|input_file
decl_stmt|;
name|int
name|c
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|char
modifier|*
name|lastsl
decl_stmt|;
name|lastsl
operator|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastsl
operator|!=
name|NULL
condition|)
name|base_dir
operator|=
name|save_string
argument_list|(
name|filename
argument_list|,
name|lastsl
operator|-
name|filename
operator|+
literal|1
argument_list|)
expr_stmt|;
name|read_rtx_filename
operator|=
name|filename
expr_stmt|;
name|input_file
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_file
operator|==
literal|0
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
name|FATAL_EXIT_CODE
return|;
block|}
comment|/* Initialize the table of insn conditions.  */
name|condition_table
operator|=
name|htab_create
argument_list|(
name|n_insn_conditions
argument_list|,
name|hash_c_test
argument_list|,
name|cmp_c_test
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_insn_conditions
condition|;
name|i
operator|++
control|)
operator|*
operator|(
name|htab_find_slot
argument_list|(
name|condition_table
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|insn_conditions
index|[
name|i
index|]
argument_list|,
name|INSERT
argument_list|)
operator|)
operator|=
operator|(
name|PTR
operator|)
operator|&
name|insn_conditions
index|[
name|i
index|]
expr_stmt|;
name|obstack_init
argument_list|(
name|rtl_obstack
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|0
expr_stmt|;
name|sequence_num
operator|=
literal|0
expr_stmt|;
comment|/* Read the entire file.  */
while|while
condition|(
literal|1
condition|)
block|{
name|rtx
name|desc
decl_stmt|;
name|int
name|lineno
decl_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|ungetc
argument_list|(
name|c
argument_list|,
name|input_file
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|read_rtx_lineno
expr_stmt|;
name|desc
operator|=
name|read_rtx
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
name|process_rtx
argument_list|(
name|desc
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
comment|/* Process define_cond_exec patterns.  */
if|if
condition|(
name|define_cond_exec_queue
operator|!=
name|NULL
condition|)
name|process_define_cond_exec
argument_list|()
expr_stmt|;
return|return
name|errors
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
return|;
block|}
end_function

begin_comment
comment|/* The entry point for reading a single rtx from an md file.  */
end_comment

begin_function
name|rtx
name|read_md_rtx
parameter_list|(
name|lineno
parameter_list|,
name|seqnr
parameter_list|)
name|int
modifier|*
name|lineno
decl_stmt|;
name|int
modifier|*
name|seqnr
decl_stmt|;
block|{
name|struct
name|queue_elem
modifier|*
modifier|*
name|queue
decl_stmt|,
modifier|*
name|elem
decl_stmt|;
name|rtx
name|desc
decl_stmt|;
name|discard
label|:
comment|/* Read all patterns from a given queue before moving on to the next.  */
if|if
condition|(
name|define_attr_queue
operator|!=
name|NULL
condition|)
name|queue
operator|=
operator|&
name|define_attr_queue
expr_stmt|;
elseif|else
if|if
condition|(
name|define_insn_queue
operator|!=
name|NULL
condition|)
name|queue
operator|=
operator|&
name|define_insn_queue
expr_stmt|;
elseif|else
if|if
condition|(
name|other_queue
operator|!=
name|NULL
condition|)
name|queue
operator|=
operator|&
name|other_queue
expr_stmt|;
else|else
return|return
name|NULL_RTX
return|;
name|elem
operator|=
operator|*
name|queue
expr_stmt|;
operator|*
name|queue
operator|=
name|elem
operator|->
name|next
expr_stmt|;
name|desc
operator|=
name|elem
operator|->
name|data
expr_stmt|;
name|read_rtx_filename
operator|=
name|elem
operator|->
name|filename
expr_stmt|;
operator|*
name|lineno
operator|=
name|elem
operator|->
name|lineno
expr_stmt|;
operator|*
name|seqnr
operator|=
name|sequence_num
expr_stmt|;
name|free
argument_list|(
name|elem
argument_list|)
expr_stmt|;
comment|/* Discard insn patterns which we know can never match (because      their C test is provably always false).  If insn_elision is      false, our caller needs to see all the patterns.  Note that the      elided patterns are never counted by the sequence numbering; it      it is the caller's responsibility, when insn_elision is false, not      to use elided pattern numbers for anything.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
condition|)
block|{
case|case
name|DEFINE_INSN
case|:
case|case
name|DEFINE_EXPAND
case|:
if|if
condition|(
name|maybe_eval_c_test
argument_list|(
name|XSTR
argument_list|(
name|desc
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|sequence_num
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|insn_elision
condition|)
goto|goto
name|discard
goto|;
break|break;
case|case
name|DEFINE_SPLIT
case|:
case|case
name|DEFINE_PEEPHOLE
case|:
case|case
name|DEFINE_PEEPHOLE2
case|:
if|if
condition|(
name|maybe_eval_c_test
argument_list|(
name|XSTR
argument_list|(
name|desc
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|sequence_num
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|insn_elision
condition|)
goto|goto
name|discard
goto|;
break|break;
default|default:
break|break;
block|}
return|return
name|desc
return|;
block|}
end_function

begin_comment
comment|/* Helper functions for insn elision.  */
end_comment

begin_comment
comment|/* Compute a hash function of a c_test structure, which is keyed    by its ->expr field.  */
end_comment

begin_function
name|hashval_t
name|hash_c_test
parameter_list|(
name|x
parameter_list|)
specifier|const
name|PTR
name|x
decl_stmt|;
block|{
specifier|const
name|struct
name|c_test
modifier|*
name|a
init|=
operator|(
specifier|const
expr|struct
name|c_test
operator|*
operator|)
name|x
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|base
decl_stmt|,
modifier|*
name|s
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|a
operator|->
name|expr
decl_stmt|;
name|hashval_t
name|hash
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|base
operator|=
name|s
expr_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|hash
operator|+=
name|c
operator|+
operator|(
name|c
operator|<<
literal|17
operator|)
expr_stmt|;
name|hash
operator|^=
name|hash
operator|>>
literal|2
expr_stmt|;
block|}
name|len
operator|=
name|s
operator|-
name|base
expr_stmt|;
name|hash
operator|+=
name|len
operator|+
operator|(
name|len
operator|<<
literal|17
operator|)
expr_stmt|;
name|hash
operator|^=
name|hash
operator|>>
literal|2
expr_stmt|;
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/* Compare two c_test expression structures.  */
end_comment

begin_function
name|int
name|cmp_c_test
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
specifier|const
name|PTR
name|x
decl_stmt|;
specifier|const
name|PTR
name|y
decl_stmt|;
block|{
specifier|const
name|struct
name|c_test
modifier|*
name|a
init|=
operator|(
specifier|const
expr|struct
name|c_test
operator|*
operator|)
name|x
decl_stmt|;
specifier|const
name|struct
name|c_test
modifier|*
name|b
init|=
operator|(
specifier|const
expr|struct
name|c_test
operator|*
operator|)
name|y
decl_stmt|;
return|return
operator|!
name|strcmp
argument_list|(
name|a
operator|->
name|expr
argument_list|,
name|b
operator|->
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a string representing a C test expression, look it up in the    condition_table and report whether or not its value is known    at compile time.  Returns a tristate: 1 for known true, 0 for    known false, -1 for unknown.  */
end_comment

begin_function
name|int
name|maybe_eval_c_test
parameter_list|(
name|expr
parameter_list|)
specifier|const
name|char
modifier|*
name|expr
decl_stmt|;
block|{
specifier|const
name|struct
name|c_test
modifier|*
name|test
decl_stmt|;
name|struct
name|c_test
name|dummy
decl_stmt|;
if|if
condition|(
name|expr
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|insn_elision_unavailable
condition|)
return|return
operator|-
literal|1
return|;
name|dummy
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
name|test
operator|=
operator|(
specifier|const
expr|struct
name|c_test
operator|*
operator|)
name|htab_find
argument_list|(
name|condition_table
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|test
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|test
operator|->
name|value
return|;
block|}
end_function

begin_comment
comment|/* Given a string, return the number of comma-separated elements in it.    Return 0 for the null string.  */
end_comment

begin_function
name|int
name|n_comma_elts
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
for|for
control|(
name|n
operator|=
literal|1
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
name|n
operator|++
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a (char *), return a pointer to the beginning of the    next comma-separated element in the string.  Advance the pointer given    to the end of that element.  Return NULL if at end of string.  Caller    is responsible for copying the string if necessary.  White space between    a comma and an element is ignored.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|scan_comma_elt
parameter_list|(
name|pstr
parameter_list|)
specifier|const
name|char
modifier|*
modifier|*
name|pstr
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
operator|*
name|pstr
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
name|start
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|','
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|pstr
operator|=
name|p
expr_stmt|;
return|return
name|start
return|;
block|}
end_function

end_unit

