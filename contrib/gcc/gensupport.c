begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support routines for the various generation passes.    Copyright (C) 2000, 2001 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"hconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"gensupport.h"
end_include

begin_comment
comment|/* In case some macros used by files we include need it, define this here.  */
end_comment

begin_decl_stmt
name|int
name|target_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|rtl_obstack
init|=
operator|&
name|obstack
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
specifier|static
name|int
name|sequence_num
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|errors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|predicable_default
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|predicable_true
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|predicable_false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|base_dir
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We initially queue all patterns, process the define_insn and    define_cond_exec patterns, then return them one at a time.  */
end_comment

begin_struct
struct|struct
name|queue_elem
block|{
name|rtx
name|data
decl_stmt|;
name|int
name|lineno
decl_stmt|;
name|struct
name|queue_elem
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|queue_elem
modifier|*
name|define_attr_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|queue_elem
modifier|*
modifier|*
name|define_attr_tail
init|=
operator|&
name|define_attr_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|queue_elem
modifier|*
name|define_insn_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|queue_elem
modifier|*
modifier|*
name|define_insn_tail
init|=
operator|&
name|define_insn_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|queue_elem
modifier|*
name|define_cond_exec_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|queue_elem
modifier|*
modifier|*
name|define_cond_exec_tail
init|=
operator|&
name|define_cond_exec_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|queue_elem
modifier|*
name|other_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|queue_elem
modifier|*
modifier|*
name|other_tail
init|=
operator|&
name|other_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|queue_pattern
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|queue_elem
operator|*
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current maximum length of directory names in the search path    for include files.  (Altered as we get more of them.)  */
end_comment

begin_decl_stmt
name|size_t
name|max_include_len
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|file_name_list
block|{
name|struct
name|file_name_list
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|file_name_list
modifier|*
name|include
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First dir to search */
end_comment

begin_comment
comment|/* First dir to search for<file> */
end_comment

begin_decl_stmt
name|struct
name|file_name_list
modifier|*
name|first_bracket_include
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|file_name_list
modifier|*
name|last_include
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last in chain */
end_comment

begin_decl_stmt
specifier|static
name|void
name|remove_constraints
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_rtx
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_predicable
name|PARAMS
argument_list|(
operator|(
expr|struct
name|queue_elem
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|identify_predicable_attribute
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_alternatives
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|collect_insn_data
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|alter_predicate_for_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|alter_test_for_insn
name|PARAMS
argument_list|(
operator|(
expr|struct
name|queue_elem
operator|*
operator|,
expr|struct
name|queue_elem
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|shift_output_template
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|alter_output_for_insn
name|PARAMS
argument_list|(
operator|(
expr|struct
name|queue_elem
operator|*
operator|,
expr|struct
name|queue_elem
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_one_cond_exec
name|PARAMS
argument_list|(
operator|(
expr|struct
name|queue_elem
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_define_cond_exec
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|process_include
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|save_string
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|init_include_reader
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
name|void
name|message_with_line
name|VPARAMS
argument_list|(
operator|(
name|int
name|lineno
operator|,
specifier|const
name|char
operator|*
name|msg
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|int
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|read_rtx_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Make a version of gen_rtx_CONST_INT so that GEN_INT can be used in    the gensupport programs.  */
end_comment

begin_function
name|rtx
name|gen_rtx_CONST_INT
parameter_list|(
name|mode
parameter_list|,
name|arg
parameter_list|)
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|HOST_WIDE_INT
name|arg
decl_stmt|;
block|{
name|rtx
name|rt
init|=
name|rtx_alloc
argument_list|(
name|CONST_INT
argument_list|)
decl_stmt|;
name|XWINT
argument_list|(
name|rt
argument_list|,
literal|0
argument_list|)
operator|=
name|arg
expr_stmt|;
return|return
name|rt
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Queue PATTERN on LIST_TAIL.  */
end_comment

begin_function
specifier|static
name|void
name|queue_pattern
parameter_list|(
name|pattern
parameter_list|,
name|list_tail
parameter_list|,
name|lineno
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
name|struct
name|queue_elem
modifier|*
modifier|*
modifier|*
name|list_tail
decl_stmt|;
name|int
name|lineno
decl_stmt|;
block|{
name|struct
name|queue_elem
modifier|*
name|e
init|=
operator|(
expr|struct
name|queue_elem
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|e
argument_list|)
argument_list|)
decl_stmt|;
name|e
operator|->
name|data
operator|=
name|pattern
expr_stmt|;
name|e
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
name|e
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
operator|*
name|list_tail
operator|=
name|e
expr_stmt|;
operator|*
name|list_tail
operator|=
operator|&
name|e
operator|->
name|next
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Recursively remove constraints from an rtx.  */
end_comment

begin_function
specifier|static
name|void
name|remove_constraints
parameter_list|(
name|part
parameter_list|)
name|rtx
name|part
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
if|if
condition|(
name|part
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
operator|==
name|MATCH_OPERAND
condition|)
name|XSTR
argument_list|(
name|part
argument_list|,
literal|2
argument_list|)
operator|=
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
operator|==
name|MATCH_SCRATCH
condition|)
name|XSTR
argument_list|(
name|part
argument_list|,
literal|1
argument_list|)
operator|=
literal|""
expr_stmt|;
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
name|remove_constraints
argument_list|(
name|XEXP
argument_list|(
name|part
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|part
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|part
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|remove_constraints
argument_list|(
name|XVECEXP
argument_list|(
name|part
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* The entry point for initializing the reader.  */
end_comment

begin_function
specifier|static
name|int
name|init_include_reader
parameter_list|(
name|inf
parameter_list|)
name|FILE
modifier|*
name|inf
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|errors
operator|=
literal|0
expr_stmt|;
comment|/* Read the entire file.  */
while|while
condition|(
literal|1
condition|)
block|{
name|rtx
name|desc
decl_stmt|;
name|int
name|lineno
decl_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|inf
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|ungetc
argument_list|(
name|c
argument_list|,
name|inf
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|read_rtx_lineno
expr_stmt|;
name|desc
operator|=
name|read_rtx
argument_list|(
name|inf
argument_list|)
expr_stmt|;
name|process_rtx
argument_list|(
name|desc
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|inf
argument_list|)
expr_stmt|;
comment|/* Process define_cond_exec patterns.  */
if|if
condition|(
name|define_cond_exec_queue
operator|!=
name|NULL
condition|)
name|process_define_cond_exec
argument_list|()
expr_stmt|;
return|return
name|errors
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
return|;
block|}
end_function

begin_comment
comment|/* Process an include file assuming that it lives in gcc/config/{target}/     if the include looks line (include "file" )  */
end_comment

begin_function
specifier|static
name|int
name|process_include
parameter_list|(
name|desc
parameter_list|,
name|lineno
parameter_list|)
name|rtx
name|desc
decl_stmt|;
name|int
name|lineno
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|XSTR
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pathname
init|=
name|NULL
decl_stmt|;
name|FILE
modifier|*
name|input_file
decl_stmt|;
name|char
modifier|*
name|fname
init|=
name|NULL
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|stackp
decl_stmt|;
name|int
name|flen
decl_stmt|;
name|stackp
operator|=
name|include
expr_stmt|;
comment|/* If specified file name is absolute, just open it.  */
if|if
condition|(
name|IS_ABSOLUTE_PATHNAME
argument_list|(
name|filename
argument_list|)
operator|||
operator|!
name|stackp
condition|)
block|{
if|if
condition|(
name|base_dir
condition|)
block|{
name|pathname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|base_dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pathname
operator|=
name|strcpy
argument_list|(
name|pathname
argument_list|,
name|base_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|pathname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|pathname
argument_list|,
literal|"\0"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pathname
operator|=
name|xstrdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
name|read_rtx_filename
operator|=
name|pathname
expr_stmt|;
name|input_file
operator|=
name|fopen
argument_list|(
name|pathname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_file
operator|==
literal|0
condition|)
block|{
name|perror
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
return|return
name|FATAL_EXIT_CODE
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|stackp
condition|)
block|{
name|flen
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|fname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_include_len
operator|+
name|flen
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* + 2 above for slash and terminating null.  */
comment|/* Search directory path, trying to open the file.          Copy each filename tried into FNAME.  */
for|for
control|(
init|;
name|stackp
condition|;
name|stackp
operator|=
name|stackp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|stackp
operator|->
name|fname
condition|)
block|{
name|strcpy
argument_list|(
name|fname
argument_list|,
name|stackp
operator|->
name|fname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|fname
index|[
name|strlen
argument_list|(
name|fname
argument_list|)
operator|+
name|flen
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fname
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|strncat
argument_list|(
name|fname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|filename
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|read_rtx_filename
operator|=
name|fname
expr_stmt|;
name|input_file
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_file
operator|!=
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|stackp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|fname
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
operator|||
name|strchr
argument_list|(
name|fname
argument_list|,
literal|'\\'
argument_list|)
operator|||
name|base_dir
condition|)
block|{
if|if
condition|(
name|base_dir
condition|)
block|{
name|pathname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|base_dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pathname
operator|=
name|strcpy
argument_list|(
name|pathname
argument_list|,
name|base_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|pathname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|pathname
argument_list|,
literal|"\0"
argument_list|)
expr_stmt|;
block|}
else|else
name|pathname
operator|=
name|xstrdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
name|read_rtx_filename
operator|=
name|pathname
expr_stmt|;
name|input_file
operator|=
name|fopen
argument_list|(
name|pathname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_file
operator|==
literal|0
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
name|FATAL_EXIT_CODE
return|;
block|}
block|}
block|}
if|if
condition|(
name|init_include_reader
argument_list|(
name|input_file
argument_list|)
operator|==
name|FATAL_EXIT_CODE
condition|)
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"read errors found in include file  %s\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
condition|)
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
name|SUCCESS_EXIT_CODE
return|;
block|}
end_function

begin_comment
comment|/* Process a top level rtx in some way, queueing as appropriate.  */
end_comment

begin_function
specifier|static
name|void
name|process_rtx
parameter_list|(
name|desc
parameter_list|,
name|lineno
parameter_list|)
name|rtx
name|desc
decl_stmt|;
name|int
name|lineno
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
condition|)
block|{
case|case
name|DEFINE_INSN
case|:
name|queue_pattern
argument_list|(
name|desc
argument_list|,
operator|&
name|define_insn_tail
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_COND_EXEC
case|:
name|queue_pattern
argument_list|(
name|desc
argument_list|,
operator|&
name|define_cond_exec_tail
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_ATTR
case|:
name|queue_pattern
argument_list|(
name|desc
argument_list|,
operator|&
name|define_attr_tail
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
case|case
name|INCLUDE
case|:
if|if
condition|(
name|process_include
argument_list|(
name|desc
argument_list|,
name|lineno
argument_list|)
operator|==
name|FATAL_EXIT_CODE
condition|)
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|XSTR
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"include file at  %s not found\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DEFINE_INSN_AND_SPLIT
case|:
block|{
specifier|const
name|char
modifier|*
name|split_cond
decl_stmt|;
name|rtx
name|split
decl_stmt|;
name|rtvec
name|attr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Create a split with values from the insn_and_split.  */
name|split
operator|=
name|rtx_alloc
argument_list|(
name|DEFINE_SPLIT
argument_list|)
expr_stmt|;
name|i
operator|=
name|XVECLEN
argument_list|(
name|desc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|split
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
name|XVECEXP
argument_list|(
name|split
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|desc
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|remove_constraints
argument_list|(
name|XVECEXP
argument_list|(
name|split
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the split condition starts with "&&", append it to the 	   insn condition to create the new split condition.  */
name|split_cond
operator|=
name|XSTR
argument_list|(
name|desc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|split_cond
index|[
literal|0
index|]
operator|==
literal|'&'
operator|&&
name|split_cond
index|[
literal|1
index|]
operator|==
literal|'&'
condition|)
block|{
specifier|const
name|char
modifier|*
name|insn_cond
init|=
name|XSTR
argument_list|(
name|desc
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|size_t
name|insn_cond_len
init|=
name|strlen
argument_list|(
name|insn_cond
argument_list|)
decl_stmt|;
name|size_t
name|split_cond_len
init|=
name|strlen
argument_list|(
name|split_cond
argument_list|)
decl_stmt|;
name|char
modifier|*
name|combined
decl_stmt|;
name|combined
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|insn_cond_len
operator|+
name|split_cond_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|combined
argument_list|,
name|insn_cond
argument_list|,
name|insn_cond_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|combined
operator|+
name|insn_cond_len
argument_list|,
name|split_cond
argument_list|,
name|split_cond_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|split_cond
operator|=
name|combined
expr_stmt|;
block|}
name|XSTR
argument_list|(
name|split
argument_list|,
literal|1
argument_list|)
operator|=
name|split_cond
expr_stmt|;
name|XVEC
argument_list|(
name|split
argument_list|,
literal|2
argument_list|)
operator|=
name|XVEC
argument_list|(
name|desc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|split
argument_list|,
literal|3
argument_list|)
operator|=
name|XSTR
argument_list|(
name|desc
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* Fix up the DEFINE_INSN.  */
name|attr
operator|=
name|XVEC
argument_list|(
name|desc
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|desc
argument_list|,
name|DEFINE_INSN
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|desc
argument_list|,
literal|4
argument_list|)
operator|=
name|attr
expr_stmt|;
comment|/* Queue them.  */
name|queue_pattern
argument_list|(
name|desc
argument_list|,
operator|&
name|define_insn_tail
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|queue_pattern
argument_list|(
name|split
argument_list|,
operator|&
name|other_tail
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|queue_pattern
argument_list|(
name|desc
argument_list|,
operator|&
name|other_tail
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if attribute PREDICABLE is true for ELEM, which holds    a DEFINE_INSN.  */
end_comment

begin_function
specifier|static
name|int
name|is_predicable
parameter_list|(
name|elem
parameter_list|)
name|struct
name|queue_elem
modifier|*
name|elem
decl_stmt|;
block|{
name|rtvec
name|vec
init|=
name|XVEC
argument_list|(
name|elem
operator|->
name|data
argument_list|,
literal|4
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|vec
condition|)
return|return
name|predicable_default
return|;
for|for
control|(
name|i
operator|=
name|GET_NUM_ELEM
argument_list|(
name|vec
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|rtx
name|sub
init|=
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|sub
argument_list|)
condition|)
block|{
case|case
name|SET_ATTR
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|sub
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"predicable"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|value
operator|=
name|XSTR
argument_list|(
name|sub
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
break|break;
case|case
name|SET_ATTR_ALTERNATIVE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|sub
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"predicable"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|message_with_line
argument_list|(
name|elem
operator|->
name|lineno
argument_list|,
literal|"multiple alternatives for `predicable'"
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|SET
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|sub
argument_list|)
argument_list|)
operator|!=
name|ATTR
operator|||
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|SET_DEST
argument_list|(
name|sub
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"predicable"
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|sub
operator|=
name|SET_SRC
argument_list|(
name|sub
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|sub
argument_list|)
operator|==
name|CONST_STRING
condition|)
block|{
name|value
operator|=
name|XSTR
argument_list|(
name|sub
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
comment|/* ??? It would be possible to handle this if we really tried. 	     It's not easy though, and I'm not going to bother until it 	     really proves necessary.  */
name|message_with_line
argument_list|(
name|elem
operator|->
name|lineno
argument_list|,
literal|"non-constant value for `predicable'"
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|predicable_default
return|;
name|found
label|:
comment|/* Verify that predicability does not vary on the alternative.  */
comment|/* ??? It should be possible to handle this by simply eliminating      the non-predicable alternatives from the insn.  FRV would like      to do this.  Delay this until we've got the basics solid.  */
if|if
condition|(
name|strchr
argument_list|(
name|value
argument_list|,
literal|','
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|message_with_line
argument_list|(
name|elem
operator|->
name|lineno
argument_list|,
literal|"multiple alternatives for `predicable'"
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Find out which value we're looking at.  */
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
name|predicable_true
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
name|predicable_false
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|message_with_line
argument_list|(
name|elem
operator|->
name|lineno
argument_list|,
literal|"unknown value `%s' for `predicable' attribute"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Examine the attribute "predicable"; discover its boolean values    and its default.  */
end_comment

begin_function
specifier|static
name|void
name|identify_predicable_attribute
parameter_list|()
block|{
name|struct
name|queue_elem
modifier|*
name|elem
decl_stmt|;
name|char
modifier|*
name|p_true
decl_stmt|,
modifier|*
name|p_false
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/* Look for the DEFINE_ATTR for `predicable', which must exist.  */
for|for
control|(
name|elem
operator|=
name|define_attr_queue
init|;
name|elem
condition|;
name|elem
operator|=
name|elem
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|elem
operator|->
name|data
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"predicable"
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
name|message_with_line
argument_list|(
name|define_cond_exec_queue
operator|->
name|lineno
argument_list|,
literal|"attribute `predicable' not defined"
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return;
name|found
label|:
name|value
operator|=
name|XSTR
argument_list|(
name|elem
operator|->
name|data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|p_false
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p_false
argument_list|,
name|value
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p_true
operator|=
name|strchr
argument_list|(
name|p_false
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_true
operator|==
name|NULL
operator|||
name|strchr
argument_list|(
operator|++
name|p_true
argument_list|,
literal|','
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|message_with_line
argument_list|(
name|elem
operator|->
name|lineno
argument_list|,
literal|"attribute `predicable' is not a boolean"
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|p_true
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|predicable_true
operator|=
name|p_true
expr_stmt|;
name|predicable_false
operator|=
name|p_false
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|elem
operator|->
name|data
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|CONST_STRING
case|:
name|value
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|elem
operator|->
name|data
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
name|message_with_line
argument_list|(
name|elem
operator|->
name|lineno
argument_list|,
literal|"attribute `predicable' cannot be const"
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return;
default|default:
name|message_with_line
argument_list|(
name|elem
operator|->
name|lineno
argument_list|,
literal|"attribute `predicable' must have a constant default"
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
name|p_true
argument_list|)
operator|==
literal|0
condition|)
name|predicable_default
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
name|p_false
argument_list|)
operator|==
literal|0
condition|)
name|predicable_default
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|message_with_line
argument_list|(
name|elem
operator|->
name|lineno
argument_list|,
literal|"unknown value `%s' for `predicable' attribute"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the number of alternatives in constraint S.  */
end_comment

begin_function
specifier|static
name|int
name|n_alternatives
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|n
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|s
condition|)
while|while
condition|(
operator|*
name|s
condition|)
name|n
operator|+=
operator|(
operator|*
name|s
operator|++
operator|==
literal|','
operator|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Determine how many alternatives there are in INSN, and how many    operands.  */
end_comment

begin_function
specifier|static
name|void
name|collect_insn_data
parameter_list|(
name|pattern
parameter_list|,
name|palt
parameter_list|,
name|pmax
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
name|int
modifier|*
name|palt
decl_stmt|,
decl|*
name|pmax
decl_stmt|;
end_function

begin_block
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|len
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MATCH_OPERAND
case|:
name|i
operator|=
name|n_alternatives
argument_list|(
name|XSTR
argument_list|(
name|pattern
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|palt
operator|=
operator|(
name|i
operator|>
operator|*
name|palt
condition|?
name|i
else|:
operator|*
name|palt
operator|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|MATCH_OPERATOR
case|:
case|case
name|MATCH_SCRATCH
case|:
case|case
name|MATCH_PARALLEL
case|:
case|case
name|MATCH_INSN
case|:
name|i
operator|=
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
operator|*
name|pmax
condition|)
operator|*
name|pmax
operator|=
name|i
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
name|collect_insn_data
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
argument_list|,
name|palt
argument_list|,
name|pmax
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
operator|==
name|NULL
condition|)
break|break;
comment|/* FALLTHRU */
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
name|collect_insn_data
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|palt
argument_list|,
name|pmax
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'w'
case|:
case|case
literal|'0'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_function
specifier|static
name|rtx
name|alter_predicate_for_insn
parameter_list|(
name|pattern
parameter_list|,
name|alt
parameter_list|,
name|max_op
parameter_list|,
name|lineno
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
name|int
name|alt
decl_stmt|,
name|max_op
decl_stmt|,
name|lineno
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|len
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MATCH_OPERAND
case|:
block|{
specifier|const
name|char
modifier|*
name|c
init|=
name|XSTR
argument_list|(
name|pattern
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|n_alternatives
argument_list|(
name|c
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"too many alternatives for operand %d"
argument_list|,
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Replicate C as needed to fill out ALT alternatives.  */
if|if
condition|(
name|c
operator|&&
operator|*
name|c
operator|&&
name|alt
operator|>
literal|1
condition|)
block|{
name|size_t
name|c_len
init|=
name|strlen
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|size_t
name|len
init|=
name|alt
operator|*
operator|(
name|c_len
operator|+
literal|1
operator|)
decl_stmt|;
name|char
modifier|*
name|new_c
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|new_c
argument_list|,
name|c
argument_list|,
name|c_len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|alt
condition|;
operator|++
name|i
control|)
block|{
name|new_c
index|[
name|i
operator|*
operator|(
name|c_len
operator|+
literal|1
operator|)
operator|-
literal|1
index|]
operator|=
literal|','
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|new_c
index|[
name|i
operator|*
operator|(
name|c_len
operator|+
literal|1
operator|)
index|]
argument_list|,
name|c
argument_list|,
name|c_len
argument_list|)
expr_stmt|;
block|}
name|new_c
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|XSTR
argument_list|(
name|pattern
argument_list|,
literal|2
argument_list|)
operator|=
name|new_c
expr_stmt|;
block|}
block|}
comment|/* FALLTHRU */
case|case
name|MATCH_OPERATOR
case|:
case|case
name|MATCH_SCRATCH
case|:
case|case
name|MATCH_PARALLEL
case|:
case|case
name|MATCH_INSN
case|:
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
operator|+=
name|max_op
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|r
decl_stmt|;
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
name|r
operator|=
name|alter_predicate_for_insn
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
argument_list|,
name|alt
argument_list|,
name|max_op
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
name|r
return|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
block|{
name|r
operator|=
name|alter_predicate_for_insn
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|alt
argument_list|,
name|max_op
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
name|r
return|;
block|}
break|break;
case|case
literal|'i'
case|:
case|case
literal|'w'
case|:
case|case
literal|'0'
case|:
case|case
literal|'s'
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|pattern
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|alter_test_for_insn
parameter_list|(
name|ce_elem
parameter_list|,
name|insn_elem
parameter_list|)
name|struct
name|queue_elem
modifier|*
name|ce_elem
decl_stmt|,
decl|*
name|insn_elem
decl_stmt|;
end_function

begin_block
block|{
specifier|const
name|char
modifier|*
name|ce_test
decl_stmt|,
modifier|*
name|insn_test
decl_stmt|;
name|char
modifier|*
name|new_test
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|ce_len
decl_stmt|,
name|insn_len
decl_stmt|;
name|ce_test
operator|=
name|XSTR
argument_list|(
name|ce_elem
operator|->
name|data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|insn_test
operator|=
name|XSTR
argument_list|(
name|insn_elem
operator|->
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ce_test
operator|||
operator|*
name|ce_test
operator|==
literal|'\0'
condition|)
return|return
name|insn_test
return|;
if|if
condition|(
operator|!
name|insn_test
operator|||
operator|*
name|insn_test
operator|==
literal|'\0'
condition|)
return|return
name|ce_test
return|;
name|ce_len
operator|=
name|strlen
argument_list|(
name|ce_test
argument_list|)
expr_stmt|;
name|insn_len
operator|=
name|strlen
argument_list|(
name|insn_test
argument_list|)
expr_stmt|;
name|len
operator|=
literal|1
operator|+
name|ce_len
operator|+
literal|1
operator|+
literal|4
operator|+
literal|1
operator|+
name|insn_len
operator|+
literal|1
operator|+
literal|1
expr_stmt|;
name|new_test
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new_test
argument_list|,
literal|"(%s)&& (%s)"
argument_list|,
name|ce_test
argument_list|,
name|insn_test
argument_list|)
expr_stmt|;
return|return
name|new_test
return|;
block|}
end_block

begin_comment
comment|/* Adjust all of the operand numbers in OLD to match the shift they'll    get from an operand displacement of DISP.  Return a pointer after the    adjusted string.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|shift_output_template
parameter_list|(
name|new
parameter_list|,
name|old
parameter_list|,
name|disp
parameter_list|)
name|char
modifier|*
name|new
decl_stmt|;
specifier|const
name|char
modifier|*
name|old
decl_stmt|;
name|int
name|disp
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|old
condition|)
block|{
name|char
name|c
init|=
operator|*
name|old
operator|++
decl_stmt|;
operator|*
name|new
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
name|c
operator|=
operator|*
name|old
operator|++
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
condition|)
name|c
operator|+=
name|disp
expr_stmt|;
elseif|else
if|if
condition|(
name|ISALPHA
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|*
name|new
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
operator|*
name|old
operator|++
operator|+
name|disp
expr_stmt|;
block|}
operator|*
name|new
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
return|return
name|new
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|alter_output_for_insn
parameter_list|(
name|ce_elem
parameter_list|,
name|insn_elem
parameter_list|,
name|alt
parameter_list|,
name|max_op
parameter_list|)
name|struct
name|queue_elem
modifier|*
name|ce_elem
decl_stmt|,
decl|*
name|insn_elem
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|alt
decl_stmt|,
name|max_op
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|const
name|char
modifier|*
name|ce_out
decl_stmt|,
modifier|*
name|insn_out
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|ce_len
decl_stmt|,
name|insn_len
decl_stmt|;
comment|/* ??? Could coordinate with genoutput to not duplicate code here.  */
name|ce_out
operator|=
name|XSTR
argument_list|(
name|ce_elem
operator|->
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|insn_out
operator|=
name|XTMPL
argument_list|(
name|insn_elem
operator|->
name|data
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ce_out
operator|||
operator|*
name|ce_out
operator|==
literal|'\0'
condition|)
return|return
name|insn_out
return|;
name|ce_len
operator|=
name|strlen
argument_list|(
name|ce_out
argument_list|)
expr_stmt|;
name|insn_len
operator|=
name|strlen
argument_list|(
name|insn_out
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|insn_out
operator|==
literal|'*'
condition|)
comment|/* You must take care of the predicate yourself.  */
return|return
name|insn_out
return|;
if|if
condition|(
operator|*
name|insn_out
operator|==
literal|'@'
condition|)
block|{
name|len
operator|=
operator|(
name|ce_len
operator|+
literal|1
operator|)
operator|*
name|alt
operator|+
name|insn_len
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|new
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
do|do
block|{
do|do
operator|*
name|p
operator|++
operator|=
operator|*
name|insn_out
operator|++
expr_stmt|;
do|while
condition|(
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|insn_out
argument_list|)
condition|)
do|;
if|if
condition|(
operator|*
name|insn_out
operator|!=
literal|'#'
condition|)
block|{
name|p
operator|=
name|shift_output_template
argument_list|(
name|p
argument_list|,
name|ce_out
argument_list|,
name|max_op
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
do|do
operator|*
name|p
operator|++
operator|=
operator|*
name|insn_out
operator|++
expr_stmt|;
do|while
condition|(
operator|*
name|insn_out
operator|&&
operator|*
name|insn_out
operator|!=
literal|'\n'
condition|)
do|;
block|}
do|while
condition|(
operator|*
name|insn_out
condition|)
do|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|ce_len
operator|+
literal|1
operator|+
name|insn_len
operator|+
literal|1
expr_stmt|;
name|new
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|=
name|shift_output_template
argument_list|(
name|new
argument_list|,
name|ce_out
argument_list|,
name|max_op
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|insn_out
argument_list|,
name|insn_len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|new
return|;
block|}
end_block

begin_comment
comment|/* Replicate insns as appropriate for the given DEFINE_COND_EXEC.  */
end_comment

begin_function
specifier|static
name|void
name|process_one_cond_exec
parameter_list|(
name|ce_elem
parameter_list|)
name|struct
name|queue_elem
modifier|*
name|ce_elem
decl_stmt|;
block|{
name|struct
name|queue_elem
modifier|*
name|insn_elem
decl_stmt|;
for|for
control|(
name|insn_elem
operator|=
name|define_insn_queue
init|;
name|insn_elem
condition|;
name|insn_elem
operator|=
name|insn_elem
operator|->
name|next
control|)
block|{
name|int
name|alternatives
decl_stmt|,
name|max_operand
decl_stmt|;
name|rtx
name|pred
decl_stmt|,
name|insn
decl_stmt|,
name|pattern
decl_stmt|;
if|if
condition|(
operator|!
name|is_predicable
argument_list|(
name|insn_elem
argument_list|)
condition|)
continue|continue;
name|alternatives
operator|=
literal|1
expr_stmt|;
name|max_operand
operator|=
operator|-
literal|1
expr_stmt|;
name|collect_insn_data
argument_list|(
name|insn_elem
operator|->
name|data
argument_list|,
operator|&
name|alternatives
argument_list|,
operator|&
name|max_operand
argument_list|)
expr_stmt|;
name|max_operand
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|XVECLEN
argument_list|(
name|ce_elem
operator|->
name|data
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|message_with_line
argument_list|(
name|ce_elem
operator|->
name|lineno
argument_list|,
literal|"too many patterns in predicate"
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|pred
operator|=
name|copy_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|ce_elem
operator|->
name|data
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pred
operator|=
name|alter_predicate_for_insn
argument_list|(
name|pred
argument_list|,
name|alternatives
argument_list|,
name|max_operand
argument_list|,
name|ce_elem
operator|->
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|pred
operator|==
name|NULL
condition|)
return|return;
comment|/* Construct a new pattern for the new insn.  */
name|insn
operator|=
name|copy_rtx
argument_list|(
name|insn_elem
operator|->
name|data
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
operator|=
literal|""
expr_stmt|;
name|pattern
operator|=
name|rtx_alloc
argument_list|(
name|COND_EXEC
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
operator|=
name|pred
expr_stmt|;
if|if
condition|(
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|=
name|pattern
expr_stmt|;
name|PUT_NUM_ELEM
argument_list|(
name|XVEC
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|)
operator|=
name|rtx_alloc
argument_list|(
name|PARALLEL
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|XVEC
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|=
name|pattern
expr_stmt|;
block|}
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|2
argument_list|)
operator|=
name|alter_test_for_insn
argument_list|(
name|ce_elem
argument_list|,
name|insn_elem
argument_list|)
expr_stmt|;
name|XTMPL
argument_list|(
name|insn
argument_list|,
literal|3
argument_list|)
operator|=
name|alter_output_for_insn
argument_list|(
name|ce_elem
argument_list|,
name|insn_elem
argument_list|,
name|alternatives
argument_list|,
name|max_operand
argument_list|)
expr_stmt|;
comment|/* ??? Set `predicable' to false.  Not crucial since it's really          only used here, and we won't reprocess this new pattern.  */
comment|/* Put the new pattern on the `other' list so that it 	 (a) is not reprocessed by other define_cond_exec patterns 	 (b) appears after all normal define_insn patterns.  	 ??? B is debatable.  If one has normal insns that match 	 cond_exec patterns, they will be preferred over these 	 generated patterns.  Whether this matters in practice, or if 	 it's a good thing, or whether we should thread these new 	 patterns into the define_insn chain just after their generator 	 is something we'll have to experiment with.  */
name|queue_pattern
argument_list|(
name|insn
argument_list|,
operator|&
name|other_tail
argument_list|,
name|insn_elem
operator|->
name|lineno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If we have any DEFINE_COND_EXEC patterns, expand the DEFINE_INSN    patterns appropriately.  */
end_comment

begin_function
specifier|static
name|void
name|process_define_cond_exec
parameter_list|()
block|{
name|struct
name|queue_elem
modifier|*
name|elem
decl_stmt|;
name|identify_predicable_attribute
argument_list|()
expr_stmt|;
if|if
condition|(
name|errors
condition|)
return|return;
for|for
control|(
name|elem
operator|=
name|define_cond_exec_queue
init|;
name|elem
condition|;
name|elem
operator|=
name|elem
operator|->
name|next
control|)
name|process_one_cond_exec
argument_list|(
name|elem
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|save_string
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|result
init|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|result
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The entry point for initializing the reader.  */
end_comment

begin_function
name|int
name|init_md_reader_args
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|in_fname
decl_stmt|;
name|max_include_len
operator|=
literal|0
expr_stmt|;
name|in_fname
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
if|if
condition|(
name|in_fname
operator|==
name|NULL
condition|)
name|in_fname
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|int
name|c
init|=
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'I'
case|:
comment|/* Add directory to path for includes.  */
block|{
name|struct
name|file_name_list
modifier|*
name|dirtmp
decl_stmt|;
name|dirtmp
operator|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* New one goes on the end */
if|if
condition|(
name|include
operator|==
literal|0
condition|)
name|include
operator|=
name|dirtmp
expr_stmt|;
else|else
name|last_include
operator|->
name|next
operator|=
name|dirtmp
expr_stmt|;
name|last_include
operator|=
name|dirtmp
expr_stmt|;
comment|/* Tail follows the last one */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'I'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|dirtmp
operator|->
name|fname
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"directory name missing after -I option"
argument_list|)
expr_stmt|;
else|else
name|dirtmp
operator|->
name|fname
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|dirtmp
operator|->
name|fname
argument_list|)
operator|>
name|max_include_len
condition|)
name|max_include_len
operator|=
name|strlen
argument_list|(
name|dirtmp
operator|->
name|fname
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|fatal
argument_list|(
literal|"invalid option `%s'"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|init_md_reader
argument_list|(
name|in_fname
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The entry point for initializing the reader.  */
end_comment

begin_function
name|int
name|init_md_reader
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|FILE
modifier|*
name|input_file
decl_stmt|;
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|lastsl
decl_stmt|;
if|if
condition|(
operator|!
name|IS_ABSOLUTE_PATHNAME
argument_list|(
name|filename
argument_list|)
condition|)
block|{
name|lastsl
operator|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastsl
operator|!=
name|NULL
condition|)
name|base_dir
operator|=
name|save_string
argument_list|(
name|filename
argument_list|,
name|lastsl
operator|-
name|filename
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|read_rtx_filename
operator|=
name|filename
expr_stmt|;
name|input_file
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_file
operator|==
literal|0
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
name|FATAL_EXIT_CODE
return|;
block|}
name|obstack_init
argument_list|(
name|rtl_obstack
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|0
expr_stmt|;
name|sequence_num
operator|=
literal|0
expr_stmt|;
comment|/* Read the entire file.  */
while|while
condition|(
literal|1
condition|)
block|{
name|rtx
name|desc
decl_stmt|;
name|int
name|lineno
decl_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|ungetc
argument_list|(
name|c
argument_list|,
name|input_file
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|read_rtx_lineno
expr_stmt|;
name|desc
operator|=
name|read_rtx
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
name|process_rtx
argument_list|(
name|desc
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
comment|/* Process define_cond_exec patterns.  */
if|if
condition|(
name|define_cond_exec_queue
operator|!=
name|NULL
condition|)
name|process_define_cond_exec
argument_list|()
expr_stmt|;
return|return
name|errors
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
return|;
block|}
end_function

begin_comment
comment|/* The entry point for reading a single rtx from an md file.  */
end_comment

begin_function
name|rtx
name|read_md_rtx
parameter_list|(
name|lineno
parameter_list|,
name|seqnr
parameter_list|)
name|int
modifier|*
name|lineno
decl_stmt|;
name|int
modifier|*
name|seqnr
decl_stmt|;
block|{
name|struct
name|queue_elem
modifier|*
modifier|*
name|queue
decl_stmt|,
modifier|*
name|elem
decl_stmt|;
name|rtx
name|desc
decl_stmt|;
comment|/* Read all patterns from a given queue before moving on to the next.  */
if|if
condition|(
name|define_attr_queue
operator|!=
name|NULL
condition|)
name|queue
operator|=
operator|&
name|define_attr_queue
expr_stmt|;
elseif|else
if|if
condition|(
name|define_insn_queue
operator|!=
name|NULL
condition|)
name|queue
operator|=
operator|&
name|define_insn_queue
expr_stmt|;
elseif|else
if|if
condition|(
name|other_queue
operator|!=
name|NULL
condition|)
name|queue
operator|=
operator|&
name|other_queue
expr_stmt|;
else|else
return|return
name|NULL_RTX
return|;
name|elem
operator|=
operator|*
name|queue
expr_stmt|;
operator|*
name|queue
operator|=
name|elem
operator|->
name|next
expr_stmt|;
name|desc
operator|=
name|elem
operator|->
name|data
expr_stmt|;
operator|*
name|lineno
operator|=
name|elem
operator|->
name|lineno
expr_stmt|;
operator|*
name|seqnr
operator|=
name|sequence_num
expr_stmt|;
name|free
argument_list|(
name|elem
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
condition|)
block|{
case|case
name|DEFINE_INSN
case|:
case|case
name|DEFINE_EXPAND
case|:
case|case
name|DEFINE_SPLIT
case|:
case|case
name|DEFINE_PEEPHOLE
case|:
case|case
name|DEFINE_PEEPHOLE2
case|:
name|sequence_num
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|desc
return|;
block|}
end_function

end_unit

