begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support routines for the various generation passes.    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"gensupport.h"
end_include

begin_comment
comment|/* In case some macros used by files we include need it, define this here.  */
end_comment

begin_decl_stmt
name|int
name|target_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|insn_elision
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|in_fname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This callback will be invoked whenever an rtl include directive is    processed.  To be used for creation of the dependency file.  */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|include_callback
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|rtl_obstack
init|=
operator|&
name|obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sequence_num
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|errors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|predicable_default
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|predicable_true
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|predicable_false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|htab_t
name|condition_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|base_dir
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We initially queue all patterns, process the define_insn and    define_cond_exec patterns, then return them one at a time.  */
end_comment

begin_struct
struct|struct
name|queue_elem
block|{
name|rtx
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|lineno
decl_stmt|;
name|struct
name|queue_elem
modifier|*
name|next
decl_stmt|;
comment|/* In a DEFINE_INSN that came from a DEFINE_INSN_AND_SPLIT, SPLIT      points to the generated DEFINE_SPLIT.  */
name|struct
name|queue_elem
modifier|*
name|split
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|queue_elem
modifier|*
name|define_attr_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|queue_elem
modifier|*
modifier|*
name|define_attr_tail
init|=
operator|&
name|define_attr_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|queue_elem
modifier|*
name|define_pred_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|queue_elem
modifier|*
modifier|*
name|define_pred_tail
init|=
operator|&
name|define_pred_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|queue_elem
modifier|*
name|define_insn_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|queue_elem
modifier|*
modifier|*
name|define_insn_tail
init|=
operator|&
name|define_insn_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|queue_elem
modifier|*
name|define_cond_exec_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|queue_elem
modifier|*
modifier|*
name|define_cond_exec_tail
init|=
operator|&
name|define_cond_exec_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|queue_elem
modifier|*
name|other_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|queue_elem
modifier|*
modifier|*
name|other_tail
init|=
operator|&
name|other_queue
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|queue_elem
modifier|*
name|queue_pattern
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|queue_elem
modifier|*
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Current maximum length of directory names in the search path    for include files.  (Altered as we get more of them.)  */
end_comment

begin_decl_stmt
name|size_t
name|max_include_len
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|file_name_list
block|{
name|struct
name|file_name_list
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|file_name_list
modifier|*
name|first_dir_md_include
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First dir to search */
end_comment

begin_comment
comment|/* First dir to search for<file> */
end_comment

begin_decl_stmt
name|struct
name|file_name_list
modifier|*
name|first_bracket_include
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|file_name_list
modifier|*
name|last_dir_md_include
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last in chain */
end_comment

begin_function_decl
specifier|static
name|void
name|remove_constraints
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_rtx
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_predicable
parameter_list|(
name|struct
name|queue_elem
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|identify_predicable_attribute
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|n_alternatives
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|collect_insn_data
parameter_list|(
name|rtx
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|alter_predicate_for_insn
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|alter_test_for_insn
parameter_list|(
name|struct
name|queue_elem
modifier|*
parameter_list|,
name|struct
name|queue_elem
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|shift_output_template
parameter_list|(
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|alter_output_for_insn
parameter_list|(
name|struct
name|queue_elem
modifier|*
parameter_list|,
name|struct
name|queue_elem
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_one_cond_exec
parameter_list|(
name|struct
name|queue_elem
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_define_cond_exec
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_include
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|save_string
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_predicate_table
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_insn_name
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_function
name|void
name|message_with_line
parameter_list|(
name|int
name|lineno
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|read_rtx_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make a version of gen_rtx_CONST_INT so that GEN_INT can be used in    the gensupport programs.  */
end_comment

begin_decl_stmt
name|rtx
name|gen_rtx_CONST_INT
argument_list|(
expr|enum
name|machine_mode
name|ARG_UNUSED
argument_list|(
name|mode
argument_list|)
argument_list|,
name|HOST_WIDE_INT
name|arg
argument_list|)
block|{
name|rtx
name|rt
init|=
name|rtx_alloc
argument_list|(
name|CONST_INT
argument_list|)
decl_stmt|;
name|XWINT
argument_list|(
name|rt
argument_list|,
literal|0
argument_list|)
operator|=
name|arg
expr_stmt|;
return|return
name|rt
return|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Queue PATTERN on LIST_TAIL.  Return the address of the new queue    element.  */
end_comment

begin_function
specifier|static
name|struct
name|queue_elem
modifier|*
name|queue_pattern
parameter_list|(
name|rtx
name|pattern
parameter_list|,
name|struct
name|queue_elem
modifier|*
modifier|*
modifier|*
name|list_tail
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
name|struct
name|queue_elem
modifier|*
name|e
init|=
name|XNEW
argument_list|(
expr|struct
name|queue_elem
argument_list|)
decl_stmt|;
name|e
operator|->
name|data
operator|=
name|pattern
expr_stmt|;
name|e
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
name|e
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
name|e
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|split
operator|=
name|NULL
expr_stmt|;
operator|*
operator|*
name|list_tail
operator|=
name|e
expr_stmt|;
operator|*
name|list_tail
operator|=
operator|&
name|e
operator|->
name|next
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* Recursively remove constraints from an rtx.  */
end_comment

begin_function
specifier|static
name|void
name|remove_constraints
parameter_list|(
name|rtx
name|part
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
if|if
condition|(
name|part
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
operator|==
name|MATCH_OPERAND
condition|)
name|XSTR
argument_list|(
name|part
argument_list|,
literal|2
argument_list|)
operator|=
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
operator|==
name|MATCH_SCRATCH
condition|)
name|XSTR
argument_list|(
name|part
argument_list|,
literal|1
argument_list|)
operator|=
literal|""
expr_stmt|;
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
name|remove_constraints
argument_list|(
name|XEXP
argument_list|(
name|part
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|part
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|part
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|remove_constraints
argument_list|(
name|XVECEXP
argument_list|(
name|part
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Process an include file assuming that it lives in gcc/config/{target}/    if the include looks like (include "file").  */
end_comment

begin_function
specifier|static
name|void
name|process_include
parameter_list|(
name|rtx
name|desc
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|XSTR
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_filename
decl_stmt|;
name|int
name|old_lineno
decl_stmt|;
name|char
modifier|*
name|pathname
decl_stmt|;
name|FILE
modifier|*
name|input_file
decl_stmt|;
comment|/* If specified file name is absolute, skip the include stack.  */
if|if
condition|(
operator|!
name|IS_ABSOLUTE_PATH
argument_list|(
name|filename
argument_list|)
condition|)
block|{
name|struct
name|file_name_list
modifier|*
name|stackp
decl_stmt|;
comment|/* Search directory path, trying to open the file.  */
for|for
control|(
name|stackp
operator|=
name|first_dir_md_include
init|;
name|stackp
condition|;
name|stackp
operator|=
name|stackp
operator|->
name|next
control|)
block|{
specifier|static
specifier|const
name|char
name|sep
index|[
literal|2
index|]
init|=
block|{
name|DIR_SEPARATOR
block|,
literal|'\0'
block|}
decl_stmt|;
name|pathname
operator|=
name|concat
argument_list|(
name|stackp
operator|->
name|fname
argument_list|,
name|sep
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|input_file
operator|=
name|fopen
argument_list|(
name|pathname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_file
operator|!=
name|NULL
condition|)
goto|goto
name|success
goto|;
name|free
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|base_dir
condition|)
name|pathname
operator|=
name|concat
argument_list|(
name|base_dir
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|pathname
operator|=
name|xstrdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|input_file
operator|=
name|fopen
argument_list|(
name|pathname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_file
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"include file `%s' not found"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|success
label|:
comment|/* Save old cursor; setup new for the new file.  Note that "lineno" the      argument to this function is the beginning of the include statement,      while read_rtx_lineno has already been advanced.  */
name|old_filename
operator|=
name|read_rtx_filename
expr_stmt|;
name|old_lineno
operator|=
name|read_rtx_lineno
expr_stmt|;
name|read_rtx_filename
operator|=
name|pathname
expr_stmt|;
name|read_rtx_lineno
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|include_callback
condition|)
name|include_callback
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
comment|/* Read the entire file.  */
while|while
condition|(
name|read_rtx
argument_list|(
name|input_file
argument_list|,
operator|&
name|desc
argument_list|,
operator|&
name|lineno
argument_list|)
condition|)
name|process_rtx
argument_list|(
name|desc
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
comment|/* Do not free pathname.  It is attached to the various rtx queue      elements.  */
name|read_rtx_filename
operator|=
name|old_filename
expr_stmt|;
name|read_rtx_lineno
operator|=
name|old_lineno
expr_stmt|;
name|fclose
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a top level rtx in some way, queuing as appropriate.  */
end_comment

begin_function
specifier|static
name|void
name|process_rtx
parameter_list|(
name|rtx
name|desc
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
condition|)
block|{
case|case
name|DEFINE_INSN
case|:
name|queue_pattern
argument_list|(
name|desc
argument_list|,
operator|&
name|define_insn_tail
argument_list|,
name|read_rtx_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_COND_EXEC
case|:
name|queue_pattern
argument_list|(
name|desc
argument_list|,
operator|&
name|define_cond_exec_tail
argument_list|,
name|read_rtx_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_ATTR
case|:
name|queue_pattern
argument_list|(
name|desc
argument_list|,
operator|&
name|define_attr_tail
argument_list|,
name|read_rtx_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_PREDICATE
case|:
case|case
name|DEFINE_SPECIAL_PREDICATE
case|:
case|case
name|DEFINE_CONSTRAINT
case|:
case|case
name|DEFINE_REGISTER_CONSTRAINT
case|:
case|case
name|DEFINE_MEMORY_CONSTRAINT
case|:
case|case
name|DEFINE_ADDRESS_CONSTRAINT
case|:
name|queue_pattern
argument_list|(
name|desc
argument_list|,
operator|&
name|define_pred_tail
argument_list|,
name|read_rtx_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
case|case
name|INCLUDE
case|:
name|process_include
argument_list|(
name|desc
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_INSN_AND_SPLIT
case|:
block|{
specifier|const
name|char
modifier|*
name|split_cond
decl_stmt|;
name|rtx
name|split
decl_stmt|;
name|rtvec
name|attr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|queue_elem
modifier|*
name|insn_elem
decl_stmt|;
name|struct
name|queue_elem
modifier|*
name|split_elem
decl_stmt|;
comment|/* Create a split with values from the insn_and_split.  */
name|split
operator|=
name|rtx_alloc
argument_list|(
name|DEFINE_SPLIT
argument_list|)
expr_stmt|;
name|i
operator|=
name|XVECLEN
argument_list|(
name|desc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|split
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
name|XVECEXP
argument_list|(
name|split
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|desc
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|remove_constraints
argument_list|(
name|XVECEXP
argument_list|(
name|split
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the split condition starts with "&&", append it to the 	   insn condition to create the new split condition.  */
name|split_cond
operator|=
name|XSTR
argument_list|(
name|desc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|split_cond
index|[
literal|0
index|]
operator|==
literal|'&'
operator|&&
name|split_cond
index|[
literal|1
index|]
operator|==
literal|'&'
condition|)
block|{
name|copy_rtx_ptr_loc
argument_list|(
name|split_cond
operator|+
literal|2
argument_list|,
name|split_cond
argument_list|)
expr_stmt|;
name|split_cond
operator|=
name|join_c_conditions
argument_list|(
name|XSTR
argument_list|(
name|desc
argument_list|,
literal|2
argument_list|)
argument_list|,
name|split_cond
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
name|XSTR
argument_list|(
name|split
argument_list|,
literal|1
argument_list|)
operator|=
name|split_cond
expr_stmt|;
name|XVEC
argument_list|(
name|split
argument_list|,
literal|2
argument_list|)
operator|=
name|XVEC
argument_list|(
name|desc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|split
argument_list|,
literal|3
argument_list|)
operator|=
name|XSTR
argument_list|(
name|desc
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* Fix up the DEFINE_INSN.  */
name|attr
operator|=
name|XVEC
argument_list|(
name|desc
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|desc
argument_list|,
name|DEFINE_INSN
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|desc
argument_list|,
literal|4
argument_list|)
operator|=
name|attr
expr_stmt|;
comment|/* Queue them.  */
name|insn_elem
operator|=
name|queue_pattern
argument_list|(
name|desc
argument_list|,
operator|&
name|define_insn_tail
argument_list|,
name|read_rtx_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|split_elem
operator|=
name|queue_pattern
argument_list|(
name|split
argument_list|,
operator|&
name|other_tail
argument_list|,
name|read_rtx_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|insn_elem
operator|->
name|split
operator|=
name|split_elem
expr_stmt|;
break|break;
block|}
default|default:
name|queue_pattern
argument_list|(
name|desc
argument_list|,
operator|&
name|other_tail
argument_list|,
name|read_rtx_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if attribute PREDICABLE is true for ELEM, which holds    a DEFINE_INSN.  */
end_comment

begin_function
specifier|static
name|int
name|is_predicable
parameter_list|(
name|struct
name|queue_elem
modifier|*
name|elem
parameter_list|)
block|{
name|rtvec
name|vec
init|=
name|XVEC
argument_list|(
name|elem
operator|->
name|data
argument_list|,
literal|4
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|vec
condition|)
return|return
name|predicable_default
return|;
for|for
control|(
name|i
operator|=
name|GET_NUM_ELEM
argument_list|(
name|vec
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|rtx
name|sub
init|=
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|sub
argument_list|)
condition|)
block|{
case|case
name|SET_ATTR
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|sub
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"predicable"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|value
operator|=
name|XSTR
argument_list|(
name|sub
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
break|break;
case|case
name|SET_ATTR_ALTERNATIVE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|sub
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"predicable"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|message_with_line
argument_list|(
name|elem
operator|->
name|lineno
argument_list|,
literal|"multiple alternatives for `predicable'"
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|SET
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|sub
argument_list|)
argument_list|)
operator|!=
name|ATTR
operator|||
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|SET_DEST
argument_list|(
name|sub
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"predicable"
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|sub
operator|=
name|SET_SRC
argument_list|(
name|sub
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|sub
argument_list|)
operator|==
name|CONST_STRING
condition|)
block|{
name|value
operator|=
name|XSTR
argument_list|(
name|sub
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
comment|/* ??? It would be possible to handle this if we really tried. 	     It's not easy though, and I'm not going to bother until it 	     really proves necessary.  */
name|message_with_line
argument_list|(
name|elem
operator|->
name|lineno
argument_list|,
literal|"non-constant value for `predicable'"
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|predicable_default
return|;
name|found
label|:
comment|/* Verify that predicability does not vary on the alternative.  */
comment|/* ??? It should be possible to handle this by simply eliminating      the non-predicable alternatives from the insn.  FRV would like      to do this.  Delay this until we've got the basics solid.  */
if|if
condition|(
name|strchr
argument_list|(
name|value
argument_list|,
literal|','
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|message_with_line
argument_list|(
name|elem
operator|->
name|lineno
argument_list|,
literal|"multiple alternatives for `predicable'"
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Find out which value we're looking at.  */
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
name|predicable_true
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
name|predicable_false
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|message_with_line
argument_list|(
name|elem
operator|->
name|lineno
argument_list|,
literal|"unknown value `%s' for `predicable' attribute"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Examine the attribute "predicable"; discover its boolean values    and its default.  */
end_comment

begin_function
specifier|static
name|void
name|identify_predicable_attribute
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|queue_elem
modifier|*
name|elem
decl_stmt|;
name|char
modifier|*
name|p_true
decl_stmt|,
modifier|*
name|p_false
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
comment|/* Look for the DEFINE_ATTR for `predicable', which must exist.  */
for|for
control|(
name|elem
operator|=
name|define_attr_queue
init|;
name|elem
condition|;
name|elem
operator|=
name|elem
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|elem
operator|->
name|data
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"predicable"
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
name|message_with_line
argument_list|(
name|define_cond_exec_queue
operator|->
name|lineno
argument_list|,
literal|"attribute `predicable' not defined"
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return;
name|found
label|:
name|value
operator|=
name|XSTR
argument_list|(
name|elem
operator|->
name|data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p_false
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|p_true
operator|=
name|strchr
argument_list|(
name|p_false
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_true
operator|==
name|NULL
operator|||
name|strchr
argument_list|(
operator|++
name|p_true
argument_list|,
literal|','
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|message_with_line
argument_list|(
name|elem
operator|->
name|lineno
argument_list|,
literal|"attribute `predicable' is not a boolean"
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p_false
condition|)
name|free
argument_list|(
name|p_false
argument_list|)
expr_stmt|;
return|return;
block|}
name|p_true
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|predicable_true
operator|=
name|p_true
expr_stmt|;
name|predicable_false
operator|=
name|p_false
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|elem
operator|->
name|data
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|CONST_STRING
case|:
name|value
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|elem
operator|->
name|data
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
name|message_with_line
argument_list|(
name|elem
operator|->
name|lineno
argument_list|,
literal|"attribute `predicable' cannot be const"
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p_false
condition|)
name|free
argument_list|(
name|p_false
argument_list|)
expr_stmt|;
return|return;
default|default:
name|message_with_line
argument_list|(
name|elem
operator|->
name|lineno
argument_list|,
literal|"attribute `predicable' must have a constant default"
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p_false
condition|)
name|free
argument_list|(
name|p_false
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
name|p_true
argument_list|)
operator|==
literal|0
condition|)
name|predicable_default
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
name|p_false
argument_list|)
operator|==
literal|0
condition|)
name|predicable_default
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|message_with_line
argument_list|(
name|elem
operator|->
name|lineno
argument_list|,
literal|"unknown value `%s' for `predicable' attribute"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p_false
condition|)
name|free
argument_list|(
name|p_false
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the number of alternatives in constraint S.  */
end_comment

begin_function
specifier|static
name|int
name|n_alternatives
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|n
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|s
condition|)
while|while
condition|(
operator|*
name|s
condition|)
name|n
operator|+=
operator|(
operator|*
name|s
operator|++
operator|==
literal|','
operator|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Determine how many alternatives there are in INSN, and how many    operands.  */
end_comment

begin_function
specifier|static
name|void
name|collect_insn_data
parameter_list|(
name|rtx
name|pattern
parameter_list|,
name|int
modifier|*
name|palt
parameter_list|,
name|int
modifier|*
name|pmax
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|len
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MATCH_OPERAND
case|:
name|i
operator|=
name|n_alternatives
argument_list|(
name|XSTR
argument_list|(
name|pattern
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|palt
operator|=
operator|(
name|i
operator|>
operator|*
name|palt
condition|?
name|i
else|:
operator|*
name|palt
operator|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|MATCH_OPERATOR
case|:
case|case
name|MATCH_SCRATCH
case|:
case|case
name|MATCH_PARALLEL
case|:
name|i
operator|=
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
operator|*
name|pmax
condition|)
operator|*
name|pmax
operator|=
name|i
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
name|collect_insn_data
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
argument_list|,
name|palt
argument_list|,
name|pmax
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
operator|==
name|NULL
condition|)
break|break;
comment|/* Fall through.  */
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
name|collect_insn_data
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|palt
argument_list|,
name|pmax
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'w'
case|:
case|case
literal|'0'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|rtx
name|alter_predicate_for_insn
parameter_list|(
name|rtx
name|pattern
parameter_list|,
name|int
name|alt
parameter_list|,
name|int
name|max_op
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|len
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MATCH_OPERAND
case|:
block|{
specifier|const
name|char
modifier|*
name|c
init|=
name|XSTR
argument_list|(
name|pattern
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|n_alternatives
argument_list|(
name|c
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"too many alternatives for operand %d"
argument_list|,
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Replicate C as needed to fill out ALT alternatives.  */
if|if
condition|(
name|c
operator|&&
operator|*
name|c
operator|&&
name|alt
operator|>
literal|1
condition|)
block|{
name|size_t
name|c_len
init|=
name|strlen
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|size_t
name|len
init|=
name|alt
operator|*
operator|(
name|c_len
operator|+
literal|1
operator|)
decl_stmt|;
name|char
modifier|*
name|new_c
init|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|new_c
argument_list|,
name|c
argument_list|,
name|c_len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|alt
condition|;
operator|++
name|i
control|)
block|{
name|new_c
index|[
name|i
operator|*
operator|(
name|c_len
operator|+
literal|1
operator|)
operator|-
literal|1
index|]
operator|=
literal|','
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|new_c
index|[
name|i
operator|*
operator|(
name|c_len
operator|+
literal|1
operator|)
index|]
argument_list|,
name|c
argument_list|,
name|c_len
argument_list|)
expr_stmt|;
block|}
name|new_c
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|XSTR
argument_list|(
name|pattern
argument_list|,
literal|2
argument_list|)
operator|=
name|new_c
expr_stmt|;
block|}
block|}
comment|/* Fall through.  */
case|case
name|MATCH_OPERATOR
case|:
case|case
name|MATCH_SCRATCH
case|:
case|case
name|MATCH_PARALLEL
case|:
name|XINT
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
operator|+=
name|max_op
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|r
decl_stmt|;
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
name|r
operator|=
name|alter_predicate_for_insn
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
argument_list|,
name|alt
argument_list|,
name|max_op
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
name|r
return|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
block|{
name|r
operator|=
name|alter_predicate_for_insn
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|alt
argument_list|,
name|max_op
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
name|r
return|;
block|}
break|break;
case|case
literal|'i'
case|:
case|case
literal|'w'
case|:
case|case
literal|'0'
case|:
case|case
literal|'s'
case|:
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|pattern
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|alter_test_for_insn
parameter_list|(
name|struct
name|queue_elem
modifier|*
name|ce_elem
parameter_list|,
name|struct
name|queue_elem
modifier|*
name|insn_elem
parameter_list|)
block|{
return|return
name|join_c_conditions
argument_list|(
name|XSTR
argument_list|(
name|ce_elem
operator|->
name|data
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|insn_elem
operator|->
name|data
argument_list|,
literal|2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Adjust all of the operand numbers in SRC to match the shift they'll    get from an operand displacement of DISP.  Return a pointer after the    adjusted string.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|shift_output_template
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|int
name|disp
parameter_list|)
block|{
while|while
condition|(
operator|*
name|src
condition|)
block|{
name|char
name|c
init|=
operator|*
name|src
operator|++
decl_stmt|;
operator|*
name|dest
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
name|c
operator|=
operator|*
name|src
operator|++
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
condition|)
name|c
operator|+=
name|disp
expr_stmt|;
elseif|else
if|if
condition|(
name|ISALPHA
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|*
name|dest
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
operator|*
name|src
operator|++
operator|+
name|disp
expr_stmt|;
block|}
operator|*
name|dest
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
return|return
name|dest
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|alter_output_for_insn
parameter_list|(
name|struct
name|queue_elem
modifier|*
name|ce_elem
parameter_list|,
name|struct
name|queue_elem
modifier|*
name|insn_elem
parameter_list|,
name|int
name|alt
parameter_list|,
name|int
name|max_op
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ce_out
decl_stmt|,
modifier|*
name|insn_out
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|ce_len
decl_stmt|,
name|insn_len
decl_stmt|;
comment|/* ??? Could coordinate with genoutput to not duplicate code here.  */
name|ce_out
operator|=
name|XSTR
argument_list|(
name|ce_elem
operator|->
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|insn_out
operator|=
name|XTMPL
argument_list|(
name|insn_elem
operator|->
name|data
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ce_out
operator|||
operator|*
name|ce_out
operator|==
literal|'\0'
condition|)
return|return
name|insn_out
return|;
name|ce_len
operator|=
name|strlen
argument_list|(
name|ce_out
argument_list|)
expr_stmt|;
name|insn_len
operator|=
name|strlen
argument_list|(
name|insn_out
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|insn_out
operator|==
literal|'*'
condition|)
comment|/* You must take care of the predicate yourself.  */
return|return
name|insn_out
return|;
if|if
condition|(
operator|*
name|insn_out
operator|==
literal|'@'
condition|)
block|{
name|len
operator|=
operator|(
name|ce_len
operator|+
literal|1
operator|)
operator|*
name|alt
operator|+
name|insn_len
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|result
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|len
argument_list|)
expr_stmt|;
do|do
block|{
do|do
operator|*
name|p
operator|++
operator|=
operator|*
name|insn_out
operator|++
expr_stmt|;
do|while
condition|(
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|insn_out
argument_list|)
condition|)
do|;
if|if
condition|(
operator|*
name|insn_out
operator|!=
literal|'#'
condition|)
block|{
name|p
operator|=
name|shift_output_template
argument_list|(
name|p
argument_list|,
name|ce_out
argument_list|,
name|max_op
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
do|do
operator|*
name|p
operator|++
operator|=
operator|*
name|insn_out
operator|++
expr_stmt|;
do|while
condition|(
operator|*
name|insn_out
operator|&&
operator|*
name|insn_out
operator|!=
literal|'\n'
condition|)
do|;
block|}
do|while
condition|(
operator|*
name|insn_out
condition|)
do|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|ce_len
operator|+
literal|1
operator|+
name|insn_len
operator|+
literal|1
expr_stmt|;
name|result
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|=
name|shift_output_template
argument_list|(
name|result
argument_list|,
name|ce_out
argument_list|,
name|max_op
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|insn_out
argument_list|,
name|insn_len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Replicate insns as appropriate for the given DEFINE_COND_EXEC.  */
end_comment

begin_function
specifier|static
name|void
name|process_one_cond_exec
parameter_list|(
name|struct
name|queue_elem
modifier|*
name|ce_elem
parameter_list|)
block|{
name|struct
name|queue_elem
modifier|*
name|insn_elem
decl_stmt|;
for|for
control|(
name|insn_elem
operator|=
name|define_insn_queue
init|;
name|insn_elem
condition|;
name|insn_elem
operator|=
name|insn_elem
operator|->
name|next
control|)
block|{
name|int
name|alternatives
decl_stmt|,
name|max_operand
decl_stmt|;
name|rtx
name|pred
decl_stmt|,
name|insn
decl_stmt|,
name|pattern
decl_stmt|,
name|split
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|is_predicable
argument_list|(
name|insn_elem
argument_list|)
condition|)
continue|continue;
name|alternatives
operator|=
literal|1
expr_stmt|;
name|max_operand
operator|=
operator|-
literal|1
expr_stmt|;
name|collect_insn_data
argument_list|(
name|insn_elem
operator|->
name|data
argument_list|,
operator|&
name|alternatives
argument_list|,
operator|&
name|max_operand
argument_list|)
expr_stmt|;
name|max_operand
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|XVECLEN
argument_list|(
name|ce_elem
operator|->
name|data
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|message_with_line
argument_list|(
name|ce_elem
operator|->
name|lineno
argument_list|,
literal|"too many patterns in predicate"
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|pred
operator|=
name|copy_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|ce_elem
operator|->
name|data
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pred
operator|=
name|alter_predicate_for_insn
argument_list|(
name|pred
argument_list|,
name|alternatives
argument_list|,
name|max_operand
argument_list|,
name|ce_elem
operator|->
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|pred
operator|==
name|NULL
condition|)
return|return;
comment|/* Construct a new pattern for the new insn.  */
name|insn
operator|=
name|copy_rtx
argument_list|(
name|insn_elem
operator|->
name|data
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
operator|=
literal|""
expr_stmt|;
name|pattern
operator|=
name|rtx_alloc
argument_list|(
name|COND_EXEC
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
operator|=
name|pred
expr_stmt|;
if|if
condition|(
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|=
name|pattern
expr_stmt|;
name|PUT_NUM_ELEM
argument_list|(
name|XVEC
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|)
operator|=
name|rtx_alloc
argument_list|(
name|PARALLEL
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|XVEC
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|=
name|pattern
expr_stmt|;
block|}
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|2
argument_list|)
operator|=
name|alter_test_for_insn
argument_list|(
name|ce_elem
argument_list|,
name|insn_elem
argument_list|)
expr_stmt|;
name|XTMPL
argument_list|(
name|insn
argument_list|,
literal|3
argument_list|)
operator|=
name|alter_output_for_insn
argument_list|(
name|ce_elem
argument_list|,
name|insn_elem
argument_list|,
name|alternatives
argument_list|,
name|max_operand
argument_list|)
expr_stmt|;
comment|/* ??? Set `predicable' to false.  Not crucial since it's really          only used here, and we won't reprocess this new pattern.  */
comment|/* Put the new pattern on the `other' list so that it 	 (a) is not reprocessed by other define_cond_exec patterns 	 (b) appears after all normal define_insn patterns.  	 ??? B is debatable.  If one has normal insns that match 	 cond_exec patterns, they will be preferred over these 	 generated patterns.  Whether this matters in practice, or if 	 it's a good thing, or whether we should thread these new 	 patterns into the define_insn chain just after their generator 	 is something we'll have to experiment with.  */
name|queue_pattern
argument_list|(
name|insn
argument_list|,
operator|&
name|other_tail
argument_list|,
name|insn_elem
operator|->
name|filename
argument_list|,
name|insn_elem
operator|->
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn_elem
operator|->
name|split
condition|)
continue|continue;
comment|/* If the original insn came from a define_insn_and_split, 	 generate a new split to handle the predicated insn.  */
name|split
operator|=
name|copy_rtx
argument_list|(
name|insn_elem
operator|->
name|split
operator|->
name|data
argument_list|)
expr_stmt|;
comment|/* Predicate the pattern matched by the split.  */
name|pattern
operator|=
name|rtx_alloc
argument_list|(
name|COND_EXEC
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
operator|=
name|pred
expr_stmt|;
if|if
condition|(
name|XVECLEN
argument_list|(
name|split
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
condition|)
block|{
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|split
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|split
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|pattern
expr_stmt|;
name|PUT_NUM_ELEM
argument_list|(
name|XVEC
argument_list|(
name|split
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|)
operator|=
name|rtx_alloc
argument_list|(
name|PARALLEL
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|XVEC
argument_list|(
name|split
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|split
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|split
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|pattern
expr_stmt|;
block|}
comment|/* Predicate all of the insns generated by the split.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|split
argument_list|,
literal|2
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|pattern
operator|=
name|rtx_alloc
argument_list|(
name|COND_EXEC
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
operator|=
name|pred
expr_stmt|;
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|split
argument_list|,
literal|2
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|split
argument_list|,
literal|2
argument_list|,
name|i
argument_list|)
operator|=
name|pattern
expr_stmt|;
block|}
comment|/* Add the new split to the queue.  */
name|queue_pattern
argument_list|(
name|split
argument_list|,
operator|&
name|other_tail
argument_list|,
name|read_rtx_filename
argument_list|,
name|insn_elem
operator|->
name|split
operator|->
name|lineno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If we have any DEFINE_COND_EXEC patterns, expand the DEFINE_INSN    patterns appropriately.  */
end_comment

begin_function
specifier|static
name|void
name|process_define_cond_exec
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|queue_elem
modifier|*
name|elem
decl_stmt|;
name|identify_predicable_attribute
argument_list|()
expr_stmt|;
if|if
condition|(
name|errors
condition|)
return|return;
for|for
control|(
name|elem
operator|=
name|define_cond_exec_queue
init|;
name|elem
condition|;
name|elem
operator|=
name|elem
operator|->
name|next
control|)
name|process_one_cond_exec
argument_list|(
name|elem
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|save_string
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|char
modifier|*
name|result
init|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|result
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The entry point for initializing the reader.  */
end_comment

begin_function
name|int
name|init_md_reader_args_cb
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|bool
function_decl|(
modifier|*
name|parse_opt
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
parameter_list|)
block|{
name|FILE
modifier|*
name|input_file
decl_stmt|;
name|int
name|c
decl_stmt|,
name|i
decl_stmt|,
name|lineno
decl_stmt|;
name|char
modifier|*
name|lastsl
decl_stmt|;
name|rtx
name|desc
decl_stmt|;
name|bool
name|no_more_options
decl_stmt|;
name|bool
name|already_read_stdin
decl_stmt|;
comment|/* Unlock the stdio streams.  */
name|unlock_std_streams
argument_list|()
expr_stmt|;
comment|/* First we loop over all the options.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
continue|continue;
name|c
operator|=
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'I'
case|:
comment|/* Add directory to path for includes.  */
block|{
name|struct
name|file_name_list
modifier|*
name|dirtmp
decl_stmt|;
name|dirtmp
operator|=
name|XNEW
argument_list|(
expr|struct
name|file_name_list
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* New one goes on the end */
if|if
condition|(
name|first_dir_md_include
operator|==
literal|0
condition|)
name|first_dir_md_include
operator|=
name|dirtmp
expr_stmt|;
else|else
name|last_dir_md_include
operator|->
name|next
operator|=
name|dirtmp
expr_stmt|;
name|last_dir_md_include
operator|=
name|dirtmp
expr_stmt|;
comment|/* Tail follows the last one */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'I'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|dirtmp
operator|->
name|fname
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"directory name missing after -I option"
argument_list|)
expr_stmt|;
else|else
name|dirtmp
operator|->
name|fname
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|dirtmp
operator|->
name|fname
argument_list|)
operator|>
name|max_include_len
condition|)
name|max_include_len
operator|=
name|strlen
argument_list|(
name|dirtmp
operator|->
name|fname
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'\0'
case|:
comment|/* An argument consisting of exactly one dash is a request to 	     read stdin.  This will be handled in the second loop.  */
continue|continue;
case|case
literal|'-'
case|:
comment|/* An argument consisting of just two dashes causes option 	     parsing to cease.  */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
goto|goto
name|stop_parsing_options
goto|;
default|default:
comment|/* The program may have provided a callback so it can 	     accept its own options.  */
if|if
condition|(
name|parse_opt
operator|&&
name|parse_opt
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
name|fatal
argument_list|(
literal|"invalid option `%s'"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|stop_parsing_options
label|:
comment|/* Prepare to read input.  */
name|condition_table
operator|=
name|htab_create
argument_list|(
literal|500
argument_list|,
name|hash_c_test
argument_list|,
name|cmp_c_test
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|init_predicate_table
argument_list|()
expr_stmt|;
name|obstack_init
argument_list|(
name|rtl_obstack
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|0
expr_stmt|;
name|sequence_num
operator|=
literal|0
expr_stmt|;
name|no_more_options
operator|=
name|false
expr_stmt|;
name|already_read_stdin
operator|=
name|false
expr_stmt|;
comment|/* Now loop over all input files.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Read stdin.  */
if|if
condition|(
name|already_read_stdin
condition|)
name|fatal
argument_list|(
literal|"cannot read standard input twice"
argument_list|)
expr_stmt|;
name|base_dir
operator|=
name|NULL
expr_stmt|;
name|read_rtx_filename
operator|=
name|in_fname
operator|=
literal|"<stdin>"
expr_stmt|;
name|read_rtx_lineno
operator|=
literal|1
expr_stmt|;
name|input_file
operator|=
name|stdin
expr_stmt|;
name|already_read_stdin
operator|=
name|true
expr_stmt|;
while|while
condition|(
name|read_rtx
argument_list|(
name|input_file
argument_list|,
operator|&
name|desc
argument_list|,
operator|&
name|lineno
argument_list|)
condition|)
name|process_rtx
argument_list|(
name|desc
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* No further arguments are to be treated as options.  */
name|no_more_options
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|no_more_options
condition|)
continue|continue;
block|}
comment|/* If we get here we are looking at a non-option argument, i.e. 	 a file to be processed.  */
name|in_fname
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|lastsl
operator|=
name|strrchr
argument_list|(
name|in_fname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastsl
operator|!=
name|NULL
condition|)
name|base_dir
operator|=
name|save_string
argument_list|(
name|in_fname
argument_list|,
name|lastsl
operator|-
name|in_fname
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|base_dir
operator|=
name|NULL
expr_stmt|;
name|read_rtx_filename
operator|=
name|in_fname
expr_stmt|;
name|read_rtx_lineno
operator|=
literal|1
expr_stmt|;
name|input_file
operator|=
name|fopen
argument_list|(
name|in_fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_file
operator|==
literal|0
condition|)
block|{
name|perror
argument_list|(
name|in_fname
argument_list|)
expr_stmt|;
return|return
name|FATAL_EXIT_CODE
return|;
block|}
while|while
condition|(
name|read_rtx
argument_list|(
name|input_file
argument_list|,
operator|&
name|desc
argument_list|,
operator|&
name|lineno
argument_list|)
condition|)
name|process_rtx
argument_list|(
name|desc
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
block|}
comment|/* If we get to this point without having seen any files to process,      read standard input now.  */
if|if
condition|(
operator|!
name|in_fname
condition|)
block|{
name|base_dir
operator|=
name|NULL
expr_stmt|;
name|read_rtx_filename
operator|=
name|in_fname
operator|=
literal|"<stdin>"
expr_stmt|;
name|read_rtx_lineno
operator|=
literal|1
expr_stmt|;
name|input_file
operator|=
name|stdin
expr_stmt|;
while|while
condition|(
name|read_rtx
argument_list|(
name|input_file
argument_list|,
operator|&
name|desc
argument_list|,
operator|&
name|lineno
argument_list|)
condition|)
name|process_rtx
argument_list|(
name|desc
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
block|}
comment|/* Process define_cond_exec patterns.  */
if|if
condition|(
name|define_cond_exec_queue
operator|!=
name|NULL
condition|)
name|process_define_cond_exec
argument_list|()
expr_stmt|;
return|return
name|errors
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
return|;
block|}
end_function

begin_comment
comment|/* Programs that don't have their own options can use this entry point    instead.  */
end_comment

begin_function
name|int
name|init_md_reader_args
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
name|init_md_reader_args_cb
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The entry point for reading a single rtx from an md file.  */
end_comment

begin_function
name|rtx
name|read_md_rtx
parameter_list|(
name|int
modifier|*
name|lineno
parameter_list|,
name|int
modifier|*
name|seqnr
parameter_list|)
block|{
name|struct
name|queue_elem
modifier|*
modifier|*
name|queue
decl_stmt|,
modifier|*
name|elem
decl_stmt|;
name|rtx
name|desc
decl_stmt|;
name|discard
label|:
comment|/* Read all patterns from a given queue before moving on to the next.  */
if|if
condition|(
name|define_attr_queue
operator|!=
name|NULL
condition|)
name|queue
operator|=
operator|&
name|define_attr_queue
expr_stmt|;
elseif|else
if|if
condition|(
name|define_pred_queue
operator|!=
name|NULL
condition|)
name|queue
operator|=
operator|&
name|define_pred_queue
expr_stmt|;
elseif|else
if|if
condition|(
name|define_insn_queue
operator|!=
name|NULL
condition|)
name|queue
operator|=
operator|&
name|define_insn_queue
expr_stmt|;
elseif|else
if|if
condition|(
name|other_queue
operator|!=
name|NULL
condition|)
name|queue
operator|=
operator|&
name|other_queue
expr_stmt|;
else|else
return|return
name|NULL_RTX
return|;
name|elem
operator|=
operator|*
name|queue
expr_stmt|;
operator|*
name|queue
operator|=
name|elem
operator|->
name|next
expr_stmt|;
name|desc
operator|=
name|elem
operator|->
name|data
expr_stmt|;
name|read_rtx_filename
operator|=
name|elem
operator|->
name|filename
expr_stmt|;
operator|*
name|lineno
operator|=
name|elem
operator|->
name|lineno
expr_stmt|;
operator|*
name|seqnr
operator|=
name|sequence_num
expr_stmt|;
name|free
argument_list|(
name|elem
argument_list|)
expr_stmt|;
comment|/* Discard insn patterns which we know can never match (because      their C test is provably always false).  If insn_elision is      false, our caller needs to see all the patterns.  Note that the      elided patterns are never counted by the sequence numbering; it      it is the caller's responsibility, when insn_elision is false, not      to use elided pattern numbers for anything.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
condition|)
block|{
case|case
name|DEFINE_INSN
case|:
case|case
name|DEFINE_EXPAND
case|:
if|if
condition|(
name|maybe_eval_c_test
argument_list|(
name|XSTR
argument_list|(
name|desc
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|sequence_num
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|insn_elision
condition|)
goto|goto
name|discard
goto|;
comment|/* *seqnr is used here so the name table will match caller's 	 idea of insn numbering, whether or not elision is active.  */
name|record_insn_name
argument_list|(
operator|*
name|seqnr
argument_list|,
name|XSTR
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_SPLIT
case|:
case|case
name|DEFINE_PEEPHOLE
case|:
case|case
name|DEFINE_PEEPHOLE2
case|:
if|if
condition|(
name|maybe_eval_c_test
argument_list|(
name|XSTR
argument_list|(
name|desc
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|sequence_num
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|insn_elision
condition|)
goto|goto
name|discard
goto|;
break|break;
default|default:
break|break;
block|}
return|return
name|desc
return|;
block|}
end_function

begin_comment
comment|/* Helper functions for insn elision.  */
end_comment

begin_comment
comment|/* Compute a hash function of a c_test structure, which is keyed    by its ->expr field.  */
end_comment

begin_function
name|hashval_t
name|hash_c_test
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|)
block|{
specifier|const
name|struct
name|c_test
modifier|*
name|a
init|=
operator|(
specifier|const
expr|struct
name|c_test
operator|*
operator|)
name|x
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|base
decl_stmt|,
modifier|*
name|s
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|a
operator|->
name|expr
decl_stmt|;
name|hashval_t
name|hash
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|base
operator|=
name|s
expr_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|hash
operator|+=
name|c
operator|+
operator|(
name|c
operator|<<
literal|17
operator|)
expr_stmt|;
name|hash
operator|^=
name|hash
operator|>>
literal|2
expr_stmt|;
block|}
name|len
operator|=
name|s
operator|-
name|base
expr_stmt|;
name|hash
operator|+=
name|len
operator|+
operator|(
name|len
operator|<<
literal|17
operator|)
expr_stmt|;
name|hash
operator|^=
name|hash
operator|>>
literal|2
expr_stmt|;
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/* Compare two c_test expression structures.  */
end_comment

begin_function
name|int
name|cmp_c_test
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|,
specifier|const
name|void
modifier|*
name|y
parameter_list|)
block|{
specifier|const
name|struct
name|c_test
modifier|*
name|a
init|=
operator|(
specifier|const
expr|struct
name|c_test
operator|*
operator|)
name|x
decl_stmt|;
specifier|const
name|struct
name|c_test
modifier|*
name|b
init|=
operator|(
specifier|const
expr|struct
name|c_test
operator|*
operator|)
name|y
decl_stmt|;
return|return
operator|!
name|strcmp
argument_list|(
name|a
operator|->
name|expr
argument_list|,
name|b
operator|->
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a string representing a C test expression, look it up in the    condition_table and report whether or not its value is known    at compile time.  Returns a tristate: 1 for known true, 0 for    known false, -1 for unknown.  */
end_comment

begin_function
name|int
name|maybe_eval_c_test
parameter_list|(
specifier|const
name|char
modifier|*
name|expr
parameter_list|)
block|{
specifier|const
name|struct
name|c_test
modifier|*
name|test
decl_stmt|;
name|struct
name|c_test
name|dummy
decl_stmt|;
if|if
condition|(
name|expr
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|dummy
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
name|test
operator|=
operator|(
specifier|const
expr|struct
name|c_test
operator|*
operator|)
name|htab_find
argument_list|(
name|condition_table
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|test
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|test
operator|->
name|value
return|;
block|}
end_function

begin_comment
comment|/* Record the C test expression EXPR in the condition_table, with    value VAL.  Duplicates clobber previous entries.  */
end_comment

begin_function
name|void
name|add_c_test
parameter_list|(
specifier|const
name|char
modifier|*
name|expr
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|struct
name|c_test
modifier|*
name|test
decl_stmt|;
if|if
condition|(
name|expr
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return;
name|test
operator|=
name|XNEW
argument_list|(
expr|struct
name|c_test
argument_list|)
expr_stmt|;
name|test
operator|->
name|expr
operator|=
name|expr
expr_stmt|;
name|test
operator|->
name|value
operator|=
name|value
expr_stmt|;
operator|*
operator|(
name|htab_find_slot
argument_list|(
name|condition_table
argument_list|,
name|test
argument_list|,
name|INSERT
argument_list|)
operator|)
operator|=
name|test
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For every C test, call CALLBACK with two arguments: a pointer to    the condition structure and INFO.  Stops when CALLBACK returns zero.  */
end_comment

begin_function
name|void
name|traverse_c_tests
parameter_list|(
name|htab_trav
name|callback
parameter_list|,
name|void
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|condition_table
condition|)
name|htab_traverse
argument_list|(
name|condition_table
argument_list|,
name|callback
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a string, return the number of comma-separated elements in it.    Return 0 for the null string.  */
end_comment

begin_function
name|int
name|n_comma_elts
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
for|for
control|(
name|n
operator|=
literal|1
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
name|n
operator|++
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a (char *), return a pointer to the beginning of the    next comma-separated element in the string.  Advance the pointer given    to the end of that element.  Return NULL if at end of string.  Caller    is responsible for copying the string if necessary.  White space between    a comma and an element is ignored.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|scan_comma_elt
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|pstr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
operator|*
name|pstr
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
name|start
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|','
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|pstr
operator|=
name|p
expr_stmt|;
return|return
name|start
return|;
block|}
end_function

begin_comment
comment|/* Helper functions for define_predicate and define_special_predicate    processing.  Shared between genrecog.c and genpreds.c.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|predicate_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pred_data
modifier|*
name|first_predicate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pred_data
modifier|*
modifier|*
name|last_predicate
init|=
operator|&
name|first_predicate
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|hashval_t
name|hash_struct_pred_data
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
name|htab_hash_string
argument_list|(
operator|(
operator|(
specifier|const
expr|struct
name|pred_data
operator|*
operator|)
name|ptr
operator|)
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eq_struct_pred_data
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|!
name|strcmp
argument_list|(
operator|(
operator|(
specifier|const
expr|struct
name|pred_data
operator|*
operator|)
name|a
operator|)
operator|->
name|name
argument_list|,
operator|(
operator|(
specifier|const
expr|struct
name|pred_data
operator|*
operator|)
name|b
operator|)
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|pred_data
modifier|*
name|lookup_predicate
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|pred_data
name|key
decl_stmt|;
name|key
operator|.
name|name
operator|=
name|name
expr_stmt|;
return|return
operator|(
expr|struct
name|pred_data
operator|*
operator|)
name|htab_find
argument_list|(
name|predicate_table
argument_list|,
operator|&
name|key
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|add_predicate
parameter_list|(
name|struct
name|pred_data
modifier|*
name|pred
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
init|=
name|htab_find_slot
argument_list|(
name|predicate_table
argument_list|,
name|pred
argument_list|,
name|INSERT
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|slot
condition|)
block|{
name|error
argument_list|(
literal|"duplicate predicate definition for '%s'"
argument_list|,
name|pred
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|slot
operator|=
name|pred
expr_stmt|;
operator|*
name|last_predicate
operator|=
name|pred
expr_stmt|;
name|last_predicate
operator|=
operator|&
name|pred
operator|->
name|next
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This array gives the initial content of the predicate table.  It    has entries for all predicates defined in recog.c.  */
end_comment

begin_struct
struct|struct
name|std_pred_table
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bool
name|special
decl_stmt|;
name|RTX_CODE
name|codes
index|[
name|NUM_RTX_CODE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|std_pred_table
name|std_preds
index|[]
init|=
block|{
block|{
literal|"general_operand"
block|,
name|false
block|,
block|{
name|CONST_INT
block|,
name|CONST_DOUBLE
block|,
name|CONST
block|,
name|SYMBOL_REF
block|,
name|LABEL_REF
block|,
name|SUBREG
block|,
name|REG
block|,
name|MEM
block|}
block|}
block|,
block|{
literal|"address_operand"
block|,
name|true
block|,
block|{
name|CONST_INT
block|,
name|CONST_DOUBLE
block|,
name|CONST
block|,
name|SYMBOL_REF
block|,
name|LABEL_REF
block|,
name|SUBREG
block|,
name|REG
block|,
name|MEM
block|,
name|PLUS
block|,
name|MINUS
block|,
name|MULT
block|}
block|}
block|,
block|{
literal|"register_operand"
block|,
name|false
block|,
block|{
name|SUBREG
block|,
name|REG
block|}
block|}
block|,
block|{
literal|"pmode_register_operand"
block|,
name|true
block|,
block|{
name|SUBREG
block|,
name|REG
block|}
block|}
block|,
block|{
literal|"scratch_operand"
block|,
name|false
block|,
block|{
name|SCRATCH
block|,
name|REG
block|}
block|}
block|,
block|{
literal|"immediate_operand"
block|,
name|false
block|,
block|{
name|CONST_INT
block|,
name|CONST_DOUBLE
block|,
name|CONST
block|,
name|SYMBOL_REF
block|,
name|LABEL_REF
block|}
block|}
block|,
block|{
literal|"const_int_operand"
block|,
name|false
block|,
block|{
name|CONST_INT
block|}
block|}
block|,
block|{
literal|"const_double_operand"
block|,
name|false
block|,
block|{
name|CONST_INT
block|,
name|CONST_DOUBLE
block|}
block|}
block|,
block|{
literal|"nonimmediate_operand"
block|,
name|false
block|,
block|{
name|SUBREG
block|,
name|REG
block|,
name|MEM
block|}
block|}
block|,
block|{
literal|"nonmemory_operand"
block|,
name|false
block|,
block|{
name|CONST_INT
block|,
name|CONST_DOUBLE
block|,
name|CONST
block|,
name|SYMBOL_REF
block|,
name|LABEL_REF
block|,
name|SUBREG
block|,
name|REG
block|}
block|}
block|,
block|{
literal|"push_operand"
block|,
name|false
block|,
block|{
name|MEM
block|}
block|}
block|,
block|{
literal|"pop_operand"
block|,
name|false
block|,
block|{
name|MEM
block|}
block|}
block|,
block|{
literal|"memory_operand"
block|,
name|false
block|,
block|{
name|SUBREG
block|,
name|MEM
block|}
block|}
block|,
block|{
literal|"indirect_operand"
block|,
name|false
block|,
block|{
name|SUBREG
block|,
name|MEM
block|}
block|}
block|,
block|{
literal|"comparison_operator"
block|,
name|false
block|,
block|{
name|EQ
block|,
name|NE
block|,
name|LE
block|,
name|LT
block|,
name|GE
block|,
name|GT
block|,
name|LEU
block|,
name|LTU
block|,
name|GEU
block|,
name|GTU
block|,
name|UNORDERED
block|,
name|ORDERED
block|,
name|UNEQ
block|,
name|UNGE
block|,
name|UNGT
block|,
name|UNLE
block|,
name|UNLT
block|,
name|LTGT
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUM_KNOWN_STD_PREDS
value|ARRAY_SIZE (std_preds)
end_define

begin_comment
comment|/* Initialize the table of predicate definitions, starting with    the information we have on generic predicates.  */
end_comment

begin_function
specifier|static
name|void
name|init_predicate_table
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|pred_data
modifier|*
name|pred
decl_stmt|;
name|predicate_table
operator|=
name|htab_create_alloc
argument_list|(
literal|37
argument_list|,
name|hash_struct_pred_data
argument_list|,
name|eq_struct_pred_data
argument_list|,
literal|0
argument_list|,
name|xcalloc
argument_list|,
name|free
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_KNOWN_STD_PREDS
condition|;
name|i
operator|++
control|)
block|{
name|pred
operator|=
name|XCNEW
argument_list|(
expr|struct
name|pred_data
argument_list|)
expr_stmt|;
name|pred
operator|->
name|name
operator|=
name|std_preds
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|pred
operator|->
name|special
operator|=
name|std_preds
index|[
name|i
index|]
operator|.
name|special
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|std_preds
index|[
name|i
index|]
operator|.
name|codes
index|[
name|j
index|]
operator|!=
literal|0
condition|;
name|j
operator|++
control|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|std_preds
index|[
name|i
index|]
operator|.
name|codes
index|[
name|j
index|]
decl_stmt|;
name|pred
operator|->
name|codes
index|[
name|code
index|]
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
name|RTX_CONST_OBJ
condition|)
name|pred
operator|->
name|allows_non_const
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|REG
operator|&&
name|code
operator|!=
name|SUBREG
operator|&&
name|code
operator|!=
name|MEM
operator|&&
name|code
operator|!=
name|CONCAT
operator|&&
name|code
operator|!=
name|PARALLEL
operator|&&
name|code
operator|!=
name|STRICT_LOW_PART
condition|)
name|pred
operator|->
name|allows_non_lvalue
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|==
literal|1
condition|)
name|pred
operator|->
name|singleton
operator|=
name|std_preds
index|[
name|i
index|]
operator|.
name|codes
index|[
literal|0
index|]
expr_stmt|;
name|add_predicate
argument_list|(
name|pred
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These functions allow linkage with print-rtl.c.  Also, some generators    like to annotate their output with insn names.  */
end_comment

begin_comment
comment|/* Holds an array of names indexed by insn_code_number.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|insn_name_ptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_name_ptr_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|get_insn_name
parameter_list|(
name|int
name|code
parameter_list|)
block|{
if|if
condition|(
name|code
operator|<
name|insn_name_ptr_size
condition|)
return|return
name|insn_name_ptr
index|[
name|code
index|]
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|record_insn_name
parameter_list|(
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|last_real_name
init|=
literal|"insn"
decl_stmt|;
specifier|static
name|int
name|last_real_code
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|insn_name_ptr_size
operator|<=
name|code
condition|)
block|{
name|int
name|new_size
decl_stmt|;
name|new_size
operator|=
operator|(
name|insn_name_ptr_size
condition|?
name|insn_name_ptr_size
operator|*
literal|2
else|:
literal|512
operator|)
expr_stmt|;
name|insn_name_ptr
operator|=
name|xrealloc
argument_list|(
name|insn_name_ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|new_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|insn_name_ptr
operator|+
name|insn_name_ptr_size
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|new_size
operator|-
name|insn_name_ptr_size
operator|)
argument_list|)
expr_stmt|;
name|insn_name_ptr_size
operator|=
name|new_size
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|name
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|new
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|last_real_name
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new
argument_list|,
literal|"%s+%d"
argument_list|,
name|last_real_name
argument_list|,
name|code
operator|-
name|last_real_code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|last_real_name
operator|=
name|new
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|last_real_code
operator|=
name|code
expr_stmt|;
block|}
name|insn_name_ptr
index|[
name|code
index|]
operator|=
name|new
expr_stmt|;
block|}
end_function

end_unit

