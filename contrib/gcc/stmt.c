begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Expands front end tree to back end RTL for GCC    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,    1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file handles the generation of rtl code from tree structure    above the level of expressions, using subroutines in exp*.c and emit-rtl.c.    The functions whose names start with `expand_' are called by the    expander to generate RTL instructions for various kinds of constructs.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"libfuncs.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"machmode.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"predict.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Functions and data structures for expanding case statements.  */
end_comment

begin_comment
comment|/* Case label structure, used to hold info on labels within case    statements.  We handle "range" labels; for a single-value label    as in C, the high and low limits are the same.     We start with a vector of case nodes sorted in ascending order, and    the default label as the last element in the vector.  Before expanding    to RTL, we transform this vector into a list linked via the RIGHT    fields in the case_node struct.  Nodes with higher case values are    later in the list.     Switch statements can be output in three forms.  A branch table is    used if there are more than a few labels and the labels are dense    within the range between the smallest and largest case value.  If a    branch table is used, no further manipulations are done with the case    node chain.     The alternative to the use of a branch table is to generate a series    of compare and jump insns.  When that is done, we use the LEFT, RIGHT,    and PARENT fields to hold a binary tree.  Initially the tree is    totally unbalanced, with everything on the right.  We balance the tree    with nodes on the left having lower case values than the parent    and nodes on the right having higher values.  We then output the tree    in order.     For very small, suitable switch statements, we can generate a series    of simple bit test and branches instead.  */
end_comment

begin_decl_stmt
name|struct
name|case_node
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|struct
name|case_node
modifier|*
name|left
decl_stmt|;
comment|/* Left son in binary tree */
name|struct
name|case_node
modifier|*
name|right
decl_stmt|;
comment|/* Right son in binary tree; also node chain */
name|struct
name|case_node
modifier|*
name|parent
decl_stmt|;
comment|/* Parent of node in binary tree */
name|tree
name|low
decl_stmt|;
comment|/* Lowest index value for this label */
name|tree
name|high
decl_stmt|;
comment|/* Highest index value for this label */
name|tree
name|code_label
decl_stmt|;
comment|/* Label to jump to when node matches */
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_typedef
typedef|typedef
name|struct
name|case_node
name|case_node
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|case_node
modifier|*
name|case_node_ptr
typedef|;
end_typedef

begin_comment
comment|/* These are used by estimate_case_costs and balance_case_nodes.  */
end_comment

begin_comment
comment|/* This must be a signed type, and non-ANSI compilers lack signed char.  */
end_comment

begin_decl_stmt
specifier|static
name|short
name|cost_table_
index|[
literal|129
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|use_cost_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cost_table_initialized
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Special care is needed because we allow -1, but TREE_INT_CST_LOW    is unsigned.  */
end_comment

begin_define
define|#
directive|define
name|COST_TABLE
parameter_list|(
name|I
parameter_list|)
value|cost_table_[(unsigned HOST_WIDE_INT) ((I) + 1)]
end_define

begin_escape
end_escape

begin_function_decl
specifier|static
name|int
name|n_occurrences
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|tree_conflicts_with_clobbers_p
parameter_list|(
name|tree
parameter_list|,
name|HARD_REG_SET
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_nl_goto_receiver
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|check_operand_nalternatives
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|check_unique_operand_names
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|resolve_operand_name_1
parameter_list|(
name|char
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_null_return_1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_value_return
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|estimate_case_costs
parameter_list|(
name|case_node_ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|lshift_cheap_p
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|case_bit_test_cmp
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_case_bit_tests
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|case_node_ptr
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|balance_case_nodes
parameter_list|(
name|case_node_ptr
modifier|*
parameter_list|,
name|case_node_ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|node_has_low_bound
parameter_list|(
name|case_node_ptr
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|node_has_high_bound
parameter_list|(
name|case_node_ptr
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|node_is_bounded
parameter_list|(
name|case_node_ptr
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_case_nodes
parameter_list|(
name|rtx
parameter_list|,
name|case_node_ptr
parameter_list|,
name|rtx
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|case_node
modifier|*
name|add_case_node
parameter_list|(
name|struct
name|case_node
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Return the rtx-label that corresponds to a LABEL_DECL,    creating it if necessary.  */
end_comment

begin_function
name|rtx
name|label_rtx
parameter_list|(
name|tree
name|label
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|label
argument_list|)
operator|==
name|LABEL_DECL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_RTL_SET_P
argument_list|(
name|label
argument_list|)
condition|)
block|{
name|rtx
name|r
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
comment|/* APPLE LOCAL begin for-fsf-4_4 3274130 5295549 */
block|\
name|unsigned
name|align
init|=
name|DECL_ALIGN_UNIT
argument_list|(
name|label
argument_list|)
decl_stmt|;
name|int
name|align_log2
init|=
name|exact_log2
argument_list|(
name|align
argument_list|)
decl_stmt|;
comment|/* APPLE LOCAL end for-fsf-4_4 3274130 5295549 */
block|\
name|SET_DECL_RTL
argument_list|(
name|label
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|FORCED_LABEL
argument_list|(
name|label
argument_list|)
operator|||
name|DECL_NONLOCAL
argument_list|(
name|label
argument_list|)
condition|)
name|LABEL_PRESERVE_P
argument_list|(
name|r
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* APPLE LOCAL begin for-fsf-4_4 3274130 5295549 */
block|\
if|if
condition|(
name|align_log2
operator|>=
literal|0
operator|&&
name|align_log2
operator|<=
literal|0xFF
condition|)
name|SET_LABEL_ALIGN
argument_list|(
name|r
argument_list|,
name|align_log2
argument_list|,
name|align
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* APPLE LOCAL end for-fsf-4_4 3274130 5295549 */
block|\     }
return|return
name|DECL_RTL
argument_list|(
name|label
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* As above, but also put it on the forced-reference list of the    function that contains it.  */
end_comment

begin_function
name|rtx
name|force_label_rtx
parameter_list|(
name|tree
name|label
parameter_list|)
block|{
name|rtx
name|ref
init|=
name|label_rtx
argument_list|(
name|label
argument_list|)
decl_stmt|;
name|tree
name|function
init|=
name|decl_function_context
argument_list|(
name|label
argument_list|)
decl_stmt|;
name|struct
name|function
modifier|*
name|p
decl_stmt|;
name|gcc_assert
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|function
operator|!=
name|current_function_decl
condition|)
name|p
operator|=
name|find_function_data
argument_list|(
name|function
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|cfun
expr_stmt|;
name|p
operator|->
name|expr
operator|->
name|x_forced_labels
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|ref
argument_list|,
name|p
operator|->
name|expr
operator|->
name|x_forced_labels
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function

begin_comment
comment|/* Add an unconditional jump to LABEL as the next sequential instruction.  */
end_comment

begin_function
name|void
name|emit_jump
parameter_list|(
name|rtx
name|label
parameter_list|)
block|{
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit code to jump to the address    specified by the pointer expression EXP.  */
end_comment

begin_function
name|void
name|expand_computed_goto
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|rtx
name|x
init|=
name|expand_normal
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|x
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_indirect_jump
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle goto statements and the labels that they can go to.  */
end_comment

begin_comment
comment|/* Specify the location in the RTL code of a label LABEL,    which is a LABEL_DECL tree node.     APPLE LOCAL begin for-fsf-4_4 3274130 5295549    This is used for those labels created by the front-end that survive    through CFG generation, including all user labels.  (Some labels    are removed by cleanup_dead_labels in tree-cfg.c.)     APPLE LOCAL end for-fsf-4_4 3274130 5295549    Note that this has nothing to do with defining label *names*.    Languages vary in how they do that and what that even means.  */
end_comment

begin_function
name|void
name|expand_label
parameter_list|(
name|tree
name|label
parameter_list|)
block|{
name|rtx
name|label_r
init|=
name|label_rtx
argument_list|(
name|label
argument_list|)
decl_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label_r
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|label
argument_list|)
condition|)
name|LABEL_NAME
argument_list|(
name|DECL_RTL
argument_list|(
name|label
argument_list|)
argument_list|)
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NONLOCAL
argument_list|(
name|label
argument_list|)
condition|)
block|{
name|expand_nl_goto_receiver
argument_list|()
expr_stmt|;
name|nonlocal_goto_handler_labels
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|label_r
argument_list|,
name|nonlocal_goto_handler_labels
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FORCED_LABEL
argument_list|(
name|label
argument_list|)
condition|)
name|forced_labels
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|label_r
argument_list|,
name|forced_labels
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NONLOCAL
argument_list|(
name|label
argument_list|)
operator|||
name|FORCED_LABEL
argument_list|(
name|label
argument_list|)
condition|)
name|maybe_set_first_label_num
argument_list|(
name|label_r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL code for a `goto' statement with target label LABEL.    LABEL should be a LABEL_DECL tree node that was or will later be    defined with `expand_label'.  */
end_comment

begin_function
name|void
name|expand_goto
parameter_list|(
name|tree
name|label
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* Check for a nonlocal goto to a containing function.  Should have      gotten translated to __builtin_nonlocal_goto.  */
name|tree
name|context
init|=
name|decl_function_context
argument_list|(
name|label
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|context
operator|||
name|context
operator|==
name|current_function_decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_jump
argument_list|(
name|label_rtx
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the number of times character C occurs in string S.  */
end_comment

begin_function
specifier|static
name|int
name|n_occurrences
parameter_list|(
name|int
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|n
operator|+=
operator|(
operator|*
name|s
operator|++
operator|==
name|c
operator|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL for an asm statement (explicit assembler code).    STRING is a STRING_CST node containing the assembler code text,    or an ADDR_EXPR containing a STRING_CST.  VOL nonzero means the    insn is volatile; don't optimize it.  */
end_comment

begin_function
specifier|static
name|void
name|expand_asm
parameter_list|(
name|tree
name|string
parameter_list|,
name|int
name|vol
parameter_list|)
block|{
name|rtx
name|body
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|string
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|string
operator|=
name|TREE_OPERAND
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|body
operator|=
name|gen_rtx_ASM_INPUT
argument_list|(
name|VOIDmode
argument_list|,
name|ggc_strdup
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|string
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|body
argument_list|)
operator|=
name|vol
expr_stmt|;
name|emit_insn
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse the output constraint pointed to by *CONSTRAINT_P.  It is the    OPERAND_NUMth output operand, indexed from zero.  There are NINPUTS    inputs and NOUTPUTS outputs to this extended-asm.  Upon return,    *ALLOWS_MEM will be TRUE iff the constraint allows the use of a    memory operand.  Similarly, *ALLOWS_REG will be TRUE iff the    constraint allows the use of a register operand.  And, *IS_INOUT    will be true if the operand is read-write, i.e., if it is used as    an input as well as an output.  If *CONSTRAINT_P is not in    canonical form, it will be made canonical.  (Note that `+' will be    replaced with `=' as part of this process.)     Returns TRUE if all went well; FALSE if an error occurred.  */
end_comment

begin_function
name|bool
name|parse_output_constraint
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|constraint_p
parameter_list|,
name|int
name|operand_num
parameter_list|,
name|int
name|ninputs
parameter_list|,
name|int
name|noutputs
parameter_list|,
name|bool
modifier|*
name|allows_mem
parameter_list|,
name|bool
modifier|*
name|allows_reg
parameter_list|,
name|bool
modifier|*
name|is_inout
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|constraint
init|=
operator|*
name|constraint_p
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Assume the constraint doesn't allow the use of either a register      or memory.  */
operator|*
name|allows_mem
operator|=
name|false
expr_stmt|;
operator|*
name|allows_reg
operator|=
name|false
expr_stmt|;
comment|/* Allow the `=' or `+' to not be at the beginning of the string,      since it wasn't explicitly documented that way, and there is a      large body of code that puts it last.  Swap the character to      the front, so as not to uglify any place else.  */
name|p
operator|=
name|strchr
argument_list|(
name|constraint
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|strchr
argument_list|(
name|constraint
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
comment|/* If the string doesn't contain an `=', issue an error      message.  */
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|error
argument_list|(
literal|"output operand constraint lacks %<=%>"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* If the constraint begins with `+', then the operand is both read      from and written to.  */
operator|*
name|is_inout
operator|=
operator|(
operator|*
name|p
operator|==
literal|'+'
operator|)
expr_stmt|;
comment|/* Canonicalize the output constraint so that it begins with `='.  */
if|if
condition|(
name|p
operator|!=
name|constraint
operator|||
operator|*
name|is_inout
condition|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|c_len
init|=
name|strlen
argument_list|(
name|constraint
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|constraint
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"output constraint %qc for operand %d "
literal|"is not at the beginning"
argument_list|,
operator|*
name|p
argument_list|,
name|operand_num
argument_list|)
expr_stmt|;
comment|/* Make a copy of the constraint.  */
name|buf
operator|=
name|alloca
argument_list|(
name|c_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|constraint
argument_list|)
expr_stmt|;
comment|/* Swap the first character and the `=' or `+'.  */
name|buf
index|[
name|p
operator|-
name|constraint
index|]
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
comment|/* Make sure the first character is an `='.  (Until we do this, 	 it might be a `+'.)  */
name|buf
index|[
literal|0
index|]
operator|=
literal|'='
expr_stmt|;
comment|/* Replace the constraint with the canonicalized string.  */
operator|*
name|constraint_p
operator|=
name|ggc_alloc_string
argument_list|(
name|buf
argument_list|,
name|c_len
argument_list|)
expr_stmt|;
name|constraint
operator|=
operator|*
name|constraint_p
expr_stmt|;
block|}
comment|/* Loop through the constraint string.  */
for|for
control|(
name|p
operator|=
name|constraint
operator|+
literal|1
init|;
operator|*
name|p
condition|;
name|p
operator|+=
name|CONSTRAINT_LEN
argument_list|(
operator|*
name|p
argument_list|,
name|p
argument_list|)
control|)
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'+'
case|:
case|case
literal|'='
case|:
name|error
argument_list|(
literal|"operand constraint contains incorrectly positioned "
literal|"%<+%> or %<=%>"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
literal|'%'
case|:
if|if
condition|(
name|operand_num
operator|+
literal|1
operator|==
name|ninputs
operator|+
name|noutputs
condition|)
block|{
name|error
argument_list|(
literal|"%<%%%> constraint used with last operand"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
break|break;
case|case
literal|'V'
case|:
case|case
literal|'m'
case|:
case|case
literal|'o'
case|:
operator|*
name|allows_mem
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
case|case
literal|'!'
case|:
case|case
literal|'*'
case|:
case|case
literal|'&'
case|:
case|case
literal|'#'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'s'
case|:
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|','
case|:
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'['
case|:
name|error
argument_list|(
literal|"matching constraint not valid in output operand"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
comment|/* ??? Before flow, auto inc/dec insns are not supposed to exist, 	   excepting those that expand_call created.  So match memory 	   and hope.  */
operator|*
name|allows_mem
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'X'
case|:
operator|*
name|allows_reg
operator|=
name|true
expr_stmt|;
operator|*
name|allows_mem
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'r'
case|:
operator|*
name|allows_reg
operator|=
name|true
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|ISALPHA
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
if|if
condition|(
name|REG_CLASS_FROM_CONSTRAINT
argument_list|(
operator|*
name|p
argument_list|,
name|p
argument_list|)
operator|!=
name|NO_REGS
condition|)
operator|*
name|allows_reg
operator|=
name|true
expr_stmt|;
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT_STR
elseif|else
if|if
condition|(
name|EXTRA_ADDRESS_CONSTRAINT
argument_list|(
operator|*
name|p
argument_list|,
name|p
argument_list|)
condition|)
operator|*
name|allows_reg
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|EXTRA_MEMORY_CONSTRAINT
argument_list|(
operator|*
name|p
argument_list|,
name|p
argument_list|)
condition|)
operator|*
name|allows_mem
operator|=
name|true
expr_stmt|;
else|else
block|{
comment|/* Otherwise we can't assume anything about the nature of 	       the constraint except that it isn't purely registers. 	       Treat it like "g" and hope for the best.  */
operator|*
name|allows_reg
operator|=
name|true
expr_stmt|;
operator|*
name|allows_mem
operator|=
name|true
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Similar, but for input constraints.  */
end_comment

begin_function
name|bool
name|parse_input_constraint
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|constraint_p
parameter_list|,
name|int
name|input_num
parameter_list|,
name|int
name|ninputs
parameter_list|,
name|int
name|noutputs
parameter_list|,
name|int
name|ninout
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|constraints
parameter_list|,
name|bool
modifier|*
name|allows_mem
parameter_list|,
name|bool
modifier|*
name|allows_reg
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|constraint
init|=
operator|*
name|constraint_p
decl_stmt|;
specifier|const
name|char
modifier|*
name|orig_constraint
init|=
name|constraint
decl_stmt|;
name|size_t
name|c_len
init|=
name|strlen
argument_list|(
name|constraint
argument_list|)
decl_stmt|;
name|size_t
name|j
decl_stmt|;
name|bool
name|saw_match
init|=
name|false
decl_stmt|;
comment|/* Assume the constraint doesn't allow the use of either      a register or memory.  */
operator|*
name|allows_mem
operator|=
name|false
expr_stmt|;
operator|*
name|allows_reg
operator|=
name|false
expr_stmt|;
comment|/* Make sure constraint has neither `=', `+', nor '&'.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|c_len
condition|;
name|j
operator|+=
name|CONSTRAINT_LEN
argument_list|(
name|constraint
index|[
name|j
index|]
argument_list|,
name|constraint
operator|+
name|j
argument_list|)
control|)
switch|switch
condition|(
name|constraint
index|[
name|j
index|]
condition|)
block|{
case|case
literal|'+'
case|:
case|case
literal|'='
case|:
case|case
literal|'&'
case|:
if|if
condition|(
name|constraint
operator|==
name|orig_constraint
condition|)
block|{
name|error
argument_list|(
literal|"input operand constraint contains %qc"
argument_list|,
name|constraint
index|[
name|j
index|]
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
break|break;
case|case
literal|'%'
case|:
if|if
condition|(
name|constraint
operator|==
name|orig_constraint
operator|&&
name|input_num
operator|+
literal|1
operator|==
name|ninputs
operator|-
name|ninout
condition|)
block|{
name|error
argument_list|(
literal|"%<%%%> constraint used with last operand"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
break|break;
case|case
literal|'V'
case|:
case|case
literal|'m'
case|:
case|case
literal|'o'
case|:
operator|*
name|allows_mem
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'?'
case|:
case|case
literal|'!'
case|:
case|case
literal|'*'
case|:
case|case
literal|'#'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'s'
case|:
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|','
case|:
break|break;
comment|/* Whether or not a numeric constraint allows a register is 	   decided by the matching constraint, and so there is no need 	   to do anything special with them.  We must handle them in 	   the default case, so that we don't unnecessarily force 	   operands to memory.  */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|unsigned
name|long
name|match
decl_stmt|;
name|saw_match
operator|=
name|true
expr_stmt|;
name|match
operator|=
name|strtoul
argument_list|(
name|constraint
operator|+
name|j
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|>=
operator|(
name|unsigned
name|long
operator|)
name|noutputs
condition|)
block|{
name|error
argument_list|(
literal|"matching constraint references invalid operand number"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Try and find the real constraint for this dup.  Only do this 	     if the matching constraint is the only alternative.  */
if|if
condition|(
operator|*
name|end
operator|==
literal|'\0'
operator|&&
operator|(
name|j
operator|==
literal|0
operator|||
operator|(
name|j
operator|==
literal|1
operator|&&
name|constraint
index|[
literal|0
index|]
operator|==
literal|'%'
operator|)
operator|)
condition|)
block|{
name|constraint
operator|=
name|constraints
index|[
name|match
index|]
expr_stmt|;
operator|*
name|constraint_p
operator|=
name|constraint
expr_stmt|;
name|c_len
operator|=
name|strlen
argument_list|(
name|constraint
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
comment|/* ??? At the end of the loop, we will skip the first part of 		 the matched constraint.  This assumes not only that the 		 other constraint is an output constraint, but also that 		 the '=' or '+' come first.  */
break|break;
block|}
else|else
name|j
operator|=
name|end
operator|-
name|constraint
expr_stmt|;
comment|/* Anticipate increment at end of loop.  */
name|j
operator|--
expr_stmt|;
block|}
comment|/* Fall through.  */
case|case
literal|'p'
case|:
case|case
literal|'r'
case|:
operator|*
name|allows_reg
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'X'
case|:
operator|*
name|allows_reg
operator|=
name|true
expr_stmt|;
operator|*
name|allows_mem
operator|=
name|true
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|ISALPHA
argument_list|(
name|constraint
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid punctuation %qc in constraint"
argument_list|,
name|constraint
index|[
name|j
index|]
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|REG_CLASS_FROM_CONSTRAINT
argument_list|(
name|constraint
index|[
name|j
index|]
argument_list|,
name|constraint
operator|+
name|j
argument_list|)
operator|!=
name|NO_REGS
condition|)
operator|*
name|allows_reg
operator|=
name|true
expr_stmt|;
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT_STR
elseif|else
if|if
condition|(
name|EXTRA_ADDRESS_CONSTRAINT
argument_list|(
name|constraint
index|[
name|j
index|]
argument_list|,
name|constraint
operator|+
name|j
argument_list|)
condition|)
operator|*
name|allows_reg
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|EXTRA_MEMORY_CONSTRAINT
argument_list|(
name|constraint
index|[
name|j
index|]
argument_list|,
name|constraint
operator|+
name|j
argument_list|)
condition|)
operator|*
name|allows_mem
operator|=
name|true
expr_stmt|;
else|else
block|{
comment|/* Otherwise we can't assume anything about the nature of 	       the constraint except that it isn't purely registers. 	       Treat it like "g" and hope for the best.  */
operator|*
name|allows_reg
operator|=
name|true
expr_stmt|;
operator|*
name|allows_mem
operator|=
name|true
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|saw_match
operator|&&
operator|!
operator|*
name|allows_reg
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"matching constraint does not allow a register"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return DECL iff there's an overlap between *REGS and DECL, where DECL    can be an asm-declared register.  Called via walk_tree.  */
end_comment

begin_function
specifier|static
name|tree
name|decl_overlaps_hard_reg_set_p
parameter_list|(
name|tree
modifier|*
name|declp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|decl
init|=
operator|*
name|declp
decl_stmt|;
specifier|const
name|HARD_REG_SET
modifier|*
name|regs
init|=
name|data
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|DECL_HARD_REGISTER
argument_list|(
name|decl
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|rtx
name|reg
init|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
init|;
name|regno
operator|<
operator|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|hard_regno_nregs
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
index|[
name|GET_MODE
argument_list|(
name|reg
argument_list|)
index|]
operator|)
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
operator|*
name|regs
argument_list|,
name|regno
argument_list|)
condition|)
return|return
name|decl
return|;
block|}
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* If there is an overlap between *REGS and DECL, return the first overlap    found.  */
end_comment

begin_function
name|tree
name|tree_overlaps_hard_reg_set
parameter_list|(
name|tree
name|decl
parameter_list|,
name|HARD_REG_SET
modifier|*
name|regs
parameter_list|)
block|{
return|return
name|walk_tree
argument_list|(
operator|&
name|decl
argument_list|,
name|decl_overlaps_hard_reg_set_p
argument_list|,
name|regs
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check for overlap between registers marked in CLOBBERED_REGS and    anything inappropriate in T.  Emit error and return the register    variable definition for error, NULL_TREE for ok.  */
end_comment

begin_function
specifier|static
name|bool
name|tree_conflicts_with_clobbers_p
parameter_list|(
name|tree
name|t
parameter_list|,
name|HARD_REG_SET
modifier|*
name|clobbered_regs
parameter_list|)
block|{
comment|/* Conflicts between asm-declared register variables and the clobber      list are not allowed.  */
name|tree
name|overlap
init|=
name|tree_overlaps_hard_reg_set
argument_list|(
name|t
argument_list|,
name|clobbered_regs
argument_list|)
decl_stmt|;
if|if
condition|(
name|overlap
condition|)
block|{
name|error
argument_list|(
literal|"asm-specifier for variable %qs conflicts with asm clobber list"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|overlap
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Reset registerness to stop multiple errors emitted for a single 	 variable.  */
name|DECL_REGISTER
argument_list|(
name|overlap
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Generate RTL for an asm statement with arguments.    STRING is the instruction template.    OUTPUTS is a list of output arguments (lvalues); INPUTS a list of inputs.    Each output or input has an expression in the TREE_VALUE and    and a tree list in TREE_PURPOSE which in turn contains a constraint    name in TREE_VALUE (or NULL_TREE) and a constraint string    in TREE_PURPOSE.    CLOBBERS is a list of STRING_CST nodes each naming a hard register    that is clobbered by this insn.     Not all kinds of lvalue that may appear in OUTPUTS can be stored directly.    Some elements of OUTPUTS may be replaced with trees representing temporary    values.  The caller should copy those temporary values to the originally    specified lvalues.     VOL nonzero means the insn is volatile; don't optimize it.  */
end_comment

begin_function
specifier|static
name|void
name|expand_asm_operands
parameter_list|(
name|tree
name|string
parameter_list|,
name|tree
name|outputs
parameter_list|,
name|tree
name|inputs
parameter_list|,
name|tree
name|clobbers
parameter_list|,
name|int
name|vol
parameter_list|,
name|location_t
name|locus
parameter_list|)
block|{
name|rtvec
name|argvec
decl_stmt|,
name|constraintvec
decl_stmt|;
name|rtx
name|body
decl_stmt|;
name|int
name|ninputs
init|=
name|list_length
argument_list|(
name|inputs
argument_list|)
decl_stmt|;
name|int
name|noutputs
init|=
name|list_length
argument_list|(
name|outputs
argument_list|)
decl_stmt|;
name|int
name|ninout
decl_stmt|;
name|int
name|nclobbers
decl_stmt|;
name|HARD_REG_SET
name|clobbered_regs
decl_stmt|;
name|int
name|clobber_conflict_found
init|=
literal|0
decl_stmt|;
name|tree
name|tail
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Vector of RTX's of evaluated output operands.  */
name|rtx
modifier|*
name|output_rtx
init|=
name|alloca
argument_list|(
name|noutputs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
decl_stmt|;
name|int
modifier|*
name|inout_opnum
init|=
name|alloca
argument_list|(
name|noutputs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|real_output_rtx
init|=
name|alloca
argument_list|(
name|noutputs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
modifier|*
name|inout_mode
init|=
name|alloca
argument_list|(
name|noutputs
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|machine_mode
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|constraints
init|=
name|alloca
argument_list|(
operator|(
name|noutputs
operator|+
name|ninputs
operator|)
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|old_generating_concat_p
init|=
name|generating_concat_p
decl_stmt|;
comment|/* An ASM with no outputs needs to be treated as volatile, for now.  */
if|if
condition|(
name|noutputs
operator|==
literal|0
condition|)
name|vol
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|check_operand_nalternatives
argument_list|(
name|outputs
argument_list|,
name|inputs
argument_list|)
condition|)
return|return;
name|string
operator|=
name|resolve_asm_operand_names
argument_list|(
name|string
argument_list|,
name|outputs
argument_list|,
name|inputs
argument_list|)
expr_stmt|;
comment|/* Collect constraints.  */
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|outputs
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|,
name|i
operator|++
control|)
name|constraints
index|[
name|i
index|]
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|inputs
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|,
name|i
operator|++
control|)
name|constraints
index|[
name|i
index|]
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Sometimes we wish to automatically clobber registers across an asm.      Case in point is when the i386 backend moved from cc0 to a hard reg --      maintaining source-level compatibility means automatically clobbering      the flags register.  */
name|clobbers
operator|=
name|targetm
operator|.
name|md_asm_clobbers
argument_list|(
name|outputs
argument_list|,
name|inputs
argument_list|,
name|clobbers
argument_list|)
expr_stmt|;
comment|/* Count the number of meaningful clobbered registers, ignoring what      we would ignore later.  */
name|nclobbers
operator|=
literal|0
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|clobbered_regs
argument_list|)
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|clobbers
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|regname
decl_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return;
name|regname
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|decode_reg_name
argument_list|(
name|regname
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
operator|||
name|i
operator|==
operator|-
literal|4
condition|)
operator|++
name|nclobbers
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
operator|-
literal|2
condition|)
name|error
argument_list|(
literal|"unknown register name %qs in %<asm%>"
argument_list|,
name|regname
argument_list|)
expr_stmt|;
comment|/* Mark clobbered registers.  */
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
comment|/* Clobbering the PIC register is an error.  */
if|if
condition|(
name|i
operator|==
operator|(
name|int
operator|)
name|PIC_OFFSET_TABLE_REGNUM
condition|)
block|{
name|error
argument_list|(
literal|"PIC register %qs clobbered in %<asm%>"
argument_list|,
name|regname
argument_list|)
expr_stmt|;
return|return;
block|}
name|SET_HARD_REG_BIT
argument_list|(
name|clobbered_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* First pass over inputs and outputs checks validity and sets      mark_addressable if needed.  */
name|ninout
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|constraint
decl_stmt|;
name|bool
name|is_inout
decl_stmt|;
name|bool
name|allows_reg
decl_stmt|;
name|bool
name|allows_mem
decl_stmt|;
comment|/* If there's an erroneous arg, emit no insn.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* Try to parse the output constraint.  If that fails, there's 	 no point in going further.  */
name|constraint
operator|=
name|constraints
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|parse_output_constraint
argument_list|(
operator|&
name|constraint
argument_list|,
name|i
argument_list|,
name|ninputs
argument_list|,
name|noutputs
argument_list|,
operator|&
name|allows_mem
argument_list|,
operator|&
name|allows_reg
argument_list|,
operator|&
name|is_inout
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|allows_reg
operator|&&
operator|(
name|allows_mem
operator|||
name|is_inout
operator|||
operator|(
name|DECL_P
argument_list|(
name|val
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|DECL_RTL
argument_list|(
name|val
argument_list|)
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|val
argument_list|)
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|)
operator|)
condition|)
name|lang_hooks
operator|.
name|mark_addressable
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_inout
condition|)
name|ninout
operator|++
expr_stmt|;
block|}
name|ninputs
operator|+=
name|ninout
expr_stmt|;
if|if
condition|(
name|ninputs
operator|+
name|noutputs
operator|>
name|MAX_RECOG_OPERANDS
condition|)
block|{
name|error
argument_list|(
literal|"more than %d operands in %<asm%>"
argument_list|,
name|MAX_RECOG_OPERANDS
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|inputs
init|;
name|tail
condition|;
name|i
operator|++
operator|,
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|bool
name|allows_reg
decl_stmt|,
name|allows_mem
decl_stmt|;
specifier|const
name|char
modifier|*
name|constraint
decl_stmt|;
comment|/* If there's an erroneous arg, emit no insn, because the ASM_INPUT 	 would get VOIDmode and that could cause a crash in reload.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return;
name|constraint
operator|=
name|constraints
index|[
name|i
operator|+
name|noutputs
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|parse_input_constraint
argument_list|(
operator|&
name|constraint
argument_list|,
name|i
argument_list|,
name|ninputs
argument_list|,
name|noutputs
argument_list|,
name|ninout
argument_list|,
name|constraints
argument_list|,
operator|&
name|allows_mem
argument_list|,
operator|&
name|allows_reg
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|allows_reg
operator|&&
name|allows_mem
condition|)
name|lang_hooks
operator|.
name|mark_addressable
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Second pass evaluates arguments.  */
name|ninout
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|bool
name|is_inout
decl_stmt|;
name|bool
name|allows_reg
decl_stmt|;
name|bool
name|allows_mem
decl_stmt|;
name|rtx
name|op
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|ok
operator|=
name|parse_output_constraint
argument_list|(
operator|&
name|constraints
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|ninputs
argument_list|,
name|noutputs
argument_list|,
operator|&
name|allows_mem
argument_list|,
operator|&
name|allows_reg
argument_list|,
operator|&
name|is_inout
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ok
argument_list|)
expr_stmt|;
comment|/* If an output operand is not a decl or indirect ref and our constraint 	 allows a register, make a temporary to act as an intermediate. 	 Make the asm insn write into that, then our caller will copy it to 	 the real output operand.  Likewise for promoted variables.  */
name|generating_concat_p
operator|=
literal|0
expr_stmt|;
name|real_output_rtx
index|[
name|i
index|]
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|allows_mem
operator|)
operator|||
operator|(
name|DECL_P
argument_list|(
name|val
argument_list|)
operator|&&
operator|(
name|allows_mem
operator|||
name|REG_P
argument_list|(
name|DECL_RTL
argument_list|(
name|val
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|REG_P
argument_list|(
name|DECL_RTL
argument_list|(
name|val
argument_list|)
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|val
argument_list|)
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|)
operator|)
operator|||
operator|!
name|allows_reg
operator|||
name|is_inout
condition|)
block|{
name|op
operator|=
name|expand_expr
argument_list|(
name|val
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|MEM_P
argument_list|(
name|op
argument_list|)
condition|)
name|op
operator|=
name|validize_mem
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allows_reg
operator|&&
operator|!
name|MEM_P
argument_list|(
name|op
argument_list|)
condition|)
name|error
argument_list|(
literal|"output number %d not directly addressable"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|allows_mem
operator|&&
name|MEM_P
argument_list|(
name|op
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|real_output_rtx
index|[
name|i
index|]
operator|=
name|op
expr_stmt|;
name|op
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_inout
condition|)
name|emit_move_insn
argument_list|(
name|op
argument_list|,
name|real_output_rtx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|op
operator|=
name|assign_temp
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op
operator|=
name|validize_mem
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|=
name|make_tree
argument_list|(
name|type
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
name|output_rtx
index|[
name|i
index|]
operator|=
name|op
expr_stmt|;
name|generating_concat_p
operator|=
name|old_generating_concat_p
expr_stmt|;
if|if
condition|(
name|is_inout
condition|)
block|{
name|inout_mode
index|[
name|ninout
index|]
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|inout_opnum
index|[
name|ninout
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|tree_conflicts_with_clobbers_p
argument_list|(
name|val
argument_list|,
operator|&
name|clobbered_regs
argument_list|)
condition|)
name|clobber_conflict_found
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Make vectors for the expression-rtx, constraint strings,      and named operands.  */
name|argvec
operator|=
name|rtvec_alloc
argument_list|(
name|ninputs
argument_list|)
expr_stmt|;
name|constraintvec
operator|=
name|rtvec_alloc
argument_list|(
name|ninputs
argument_list|)
expr_stmt|;
name|body
operator|=
name|gen_rtx_ASM_OPERANDS
argument_list|(
operator|(
name|noutputs
operator|==
literal|0
condition|?
name|VOIDmode
else|:
name|GET_MODE
argument_list|(
name|output_rtx
index|[
literal|0
index|]
argument_list|)
operator|)
argument_list|,
name|ggc_strdup
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|string
argument_list|)
argument_list|)
argument_list|,
name|empty_string
argument_list|,
literal|0
argument_list|,
name|argvec
argument_list|,
name|constraintvec
argument_list|,
name|locus
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|body
argument_list|)
operator|=
name|vol
expr_stmt|;
comment|/* Eval the inputs and put them into ARGVEC.      Put their constraints into ASM_INPUTs and store in CONSTRAINTS.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|inputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
operator|++
name|i
control|)
block|{
name|bool
name|allows_reg
decl_stmt|,
name|allows_mem
decl_stmt|;
specifier|const
name|char
modifier|*
name|constraint
decl_stmt|;
name|tree
name|val
decl_stmt|,
name|type
decl_stmt|;
name|rtx
name|op
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|constraint
operator|=
name|constraints
index|[
name|i
operator|+
name|noutputs
index|]
expr_stmt|;
name|ok
operator|=
name|parse_input_constraint
argument_list|(
operator|&
name|constraint
argument_list|,
name|i
argument_list|,
name|ninputs
argument_list|,
name|noutputs
argument_list|,
name|ninout
argument_list|,
name|constraints
argument_list|,
operator|&
name|allows_mem
argument_list|,
operator|&
name|allows_reg
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|generating_concat_p
operator|=
literal|0
expr_stmt|;
name|val
operator|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* EXPAND_INITIALIZER will not generate code for valid initializer 	 constants, but will still generate code for other types of operand. 	 This is the behavior we want for constant constraints.  */
name|op
operator|=
name|expand_expr
argument_list|(
name|val
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|allows_reg
condition|?
name|EXPAND_NORMAL
else|:
name|allows_mem
condition|?
name|EXPAND_MEMORY
else|:
name|EXPAND_INITIALIZER
argument_list|)
expr_stmt|;
comment|/* Never pass a CONCAT to an ASM.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONCAT
condition|)
name|op
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|op
argument_list|)
condition|)
name|op
operator|=
name|validize_mem
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|asm_operand_ok
argument_list|(
name|op
argument_list|,
name|constraint
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|allows_reg
operator|&&
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|BLKmode
condition|)
name|op
operator|=
name|force_reg
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|allows_mem
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"asm operand %d probably doesn%'t match constraints"
argument_list|,
name|i
operator|+
name|noutputs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|op
argument_list|)
condition|)
block|{
comment|/* We won't recognize either volatile memory or memory 		 with a queued address as available a memory_operand 		 at this point.  Ignore it: clearly this *is* a memory.  */
block|}
else|else
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"use of memory input without lvalue in "
literal|"asm operand %d is deprecated"
argument_list|,
name|i
operator|+
name|noutputs
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|rtx
name|mem
init|=
name|force_const_mem
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mem
condition|)
name|op
operator|=
name|validize_mem
argument_list|(
name|mem
argument_list|)
expr_stmt|;
else|else
name|op
operator|=
name|force_reg
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|REG_P
argument_list|(
name|op
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|tree
name|qual_type
init|=
name|build_qualified_type
argument_list|(
name|type
argument_list|,
operator|(
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
operator||
name|TYPE_QUAL_CONST
operator|)
argument_list|)
decl_stmt|;
name|rtx
name|memloc
init|=
name|assign_temp
argument_list|(
name|qual_type
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|memloc
operator|=
name|validize_mem
argument_list|(
name|memloc
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|memloc
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|op
operator|=
name|memloc
expr_stmt|;
block|}
block|}
block|}
name|generating_concat_p
operator|=
name|old_generating_concat_p
expr_stmt|;
name|ASM_OPERANDS_INPUT
argument_list|(
name|body
argument_list|,
name|i
argument_list|)
operator|=
name|op
expr_stmt|;
name|ASM_OPERANDS_INPUT_CONSTRAINT_EXP
argument_list|(
name|body
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx_ASM_INPUT
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|ggc_strdup
argument_list|(
name|constraints
index|[
name|i
operator|+
name|noutputs
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_conflicts_with_clobbers_p
argument_list|(
name|val
argument_list|,
operator|&
name|clobbered_regs
argument_list|)
condition|)
name|clobber_conflict_found
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Protect all the operands from the queue now that they have all been      evaluated.  */
name|generating_concat_p
operator|=
literal|0
expr_stmt|;
comment|/* For in-out operands, copy output rtx to input rtx.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninout
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
init|=
name|inout_opnum
index|[
name|i
index|]
decl_stmt|;
name|char
name|buffer
index|[
literal|16
index|]
decl_stmt|;
name|ASM_OPERANDS_INPUT
argument_list|(
name|body
argument_list|,
name|ninputs
operator|-
name|ninout
operator|+
name|i
argument_list|)
operator|=
name|output_rtx
index|[
name|j
index|]
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|ASM_OPERANDS_INPUT_CONSTRAINT_EXP
argument_list|(
name|body
argument_list|,
name|ninputs
operator|-
name|ninout
operator|+
name|i
argument_list|)
operator|=
name|gen_rtx_ASM_INPUT
argument_list|(
name|inout_mode
index|[
name|i
index|]
argument_list|,
name|ggc_strdup
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|generating_concat_p
operator|=
name|old_generating_concat_p
expr_stmt|;
comment|/* Now, for each output, construct an rtx      (set OUTPUT (asm_operands INSN OUTPUTCONSTRAINT OUTPUTNUMBER 			       ARGVEC CONSTRAINTS OPNAMES))      If there is more than one, put them inside a PARALLEL.  */
if|if
condition|(
name|noutputs
operator|==
literal|1
operator|&&
name|nclobbers
operator|==
literal|0
condition|)
block|{
name|ASM_OPERANDS_OUTPUT_CONSTRAINT
argument_list|(
name|body
argument_list|)
operator|=
name|ggc_strdup
argument_list|(
name|constraints
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|output_rtx
index|[
literal|0
index|]
argument_list|,
name|body
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|noutputs
operator|==
literal|0
operator|&&
name|nclobbers
operator|==
literal|0
condition|)
block|{
comment|/* No output operands: put in a raw ASM_OPERANDS rtx.  */
name|emit_insn
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|obody
init|=
name|body
decl_stmt|;
name|int
name|num
init|=
name|noutputs
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
name|num
operator|=
literal|1
expr_stmt|;
name|body
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|num
operator|+
name|nclobbers
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For each output operand, store a SET.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|output_rtx
index|[
name|i
index|]
argument_list|,
name|gen_rtx_ASM_OPERANDS
argument_list|(
name|GET_MODE
argument_list|(
name|output_rtx
index|[
name|i
index|]
argument_list|)
argument_list|,
name|ggc_strdup
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|string
argument_list|)
argument_list|)
argument_list|,
name|ggc_strdup
argument_list|(
name|constraints
index|[
name|i
index|]
argument_list|)
argument_list|,
name|i
argument_list|,
name|argvec
argument_list|,
name|constraintvec
argument_list|,
name|locus
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
operator|=
name|vol
expr_stmt|;
block|}
comment|/* If there are no outputs (but there are some clobbers) 	 store the bare ASM_OPERANDS into the PARALLEL.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
operator|++
argument_list|)
operator|=
name|obody
expr_stmt|;
comment|/* Store (clobber REG) for each clobbered register specified.  */
for|for
control|(
name|tail
operator|=
name|clobbers
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|regname
init|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|j
init|=
name|decode_reg_name
argument_list|(
name|regname
argument_list|)
decl_stmt|;
name|rtx
name|clobbered_reg
decl_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|j
operator|==
operator|-
literal|3
condition|)
comment|/* `cc', which is not a register */
continue|continue;
if|if
condition|(
name|j
operator|==
operator|-
literal|4
condition|)
comment|/* `memory', don't cache memory across asm */
block|{
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
operator|++
argument_list|)
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|VOIDmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Ignore unknown register, error already signaled.  */
continue|continue;
block|}
comment|/* Use QImode since that's guaranteed to clobber just one reg.  */
name|clobbered_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|QImode
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|/* Do sanity check for overlap between clobbers and respectively 	     input and outputs that hasn't been handled.  Such overlap 	     should have been detected and reported above.  */
if|if
condition|(
operator|!
name|clobber_conflict_found
condition|)
block|{
name|int
name|opno
decl_stmt|;
comment|/* We test the old body (obody) contents to avoid tripping 		 over the under-construction body.  */
for|for
control|(
name|opno
operator|=
literal|0
init|;
name|opno
operator|<
name|noutputs
condition|;
name|opno
operator|++
control|)
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|clobbered_reg
argument_list|,
name|output_rtx
index|[
name|opno
index|]
argument_list|)
condition|)
name|internal_error
argument_list|(
literal|"asm clobber conflict with output operand"
argument_list|)
expr_stmt|;
for|for
control|(
name|opno
operator|=
literal|0
init|;
name|opno
operator|<
name|ninputs
operator|-
name|ninout
condition|;
name|opno
operator|++
control|)
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|clobbered_reg
argument_list|,
name|ASM_OPERANDS_INPUT
argument_list|(
name|obody
argument_list|,
name|opno
argument_list|)
argument_list|)
condition|)
name|internal_error
argument_list|(
literal|"asm clobber conflict with input operand"
argument_list|)
expr_stmt|;
block|}
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
operator|++
argument_list|)
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|clobbered_reg
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
comment|/* For any outputs that needed reloading into registers, spill them      back to where they belong.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noutputs
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|real_output_rtx
index|[
name|i
index|]
condition|)
name|emit_move_insn
argument_list|(
name|real_output_rtx
index|[
name|i
index|]
argument_list|,
name|output_rtx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|expand_asm_expr
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|int
name|noutputs
decl_stmt|,
name|i
decl_stmt|;
name|tree
name|outputs
decl_stmt|,
name|tail
decl_stmt|;
name|tree
modifier|*
name|o
decl_stmt|;
if|if
condition|(
name|ASM_INPUT_P
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|expand_asm
argument_list|(
name|ASM_STRING
argument_list|(
name|exp
argument_list|)
argument_list|,
name|ASM_VOLATILE_P
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|outputs
operator|=
name|ASM_OUTPUTS
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|noutputs
operator|=
name|list_length
argument_list|(
name|outputs
argument_list|)
expr_stmt|;
comment|/* o[I] is the place that output number I should be written.  */
name|o
operator|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
name|noutputs
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Record the contents of OUTPUTS before it is modified.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
name|o
index|[
name|i
index|]
operator|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
expr_stmt|;
comment|/* Generate the ASM_OPERANDS insn; store into the TREE_VALUEs of      OUTPUTS some trees for where the values were actually stored.  */
name|expand_asm_operands
argument_list|(
name|ASM_STRING
argument_list|(
name|exp
argument_list|)
argument_list|,
name|outputs
argument_list|,
name|ASM_INPUTS
argument_list|(
name|exp
argument_list|)
argument_list|,
name|ASM_CLOBBERS
argument_list|(
name|exp
argument_list|)
argument_list|,
name|ASM_VOLATILE_P
argument_list|(
name|exp
argument_list|)
argument_list|,
name|input_location
argument_list|)
expr_stmt|;
comment|/* Copy all the intermediate outputs into the specified outputs.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|o
index|[
name|i
index|]
operator|!=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
condition|)
block|{
name|expand_assignment
argument_list|(
name|o
index|[
name|i
index|]
argument_list|,
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
comment|/* Restore the original value so that it's correct the next 	     time we expand this function.  */
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|=
name|o
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* A subroutine of expand_asm_operands.  Check that all operands have    the same number of alternatives.  Return true if so.  */
end_comment

begin_function
specifier|static
name|bool
name|check_operand_nalternatives
parameter_list|(
name|tree
name|outputs
parameter_list|,
name|tree
name|inputs
parameter_list|)
block|{
if|if
condition|(
name|outputs
operator|||
name|inputs
condition|)
block|{
name|tree
name|tmp
init|=
name|TREE_PURPOSE
argument_list|(
name|outputs
condition|?
name|outputs
else|:
name|inputs
argument_list|)
decl_stmt|;
name|int
name|nalternatives
init|=
name|n_occurrences
argument_list|(
literal|','
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|next
init|=
name|inputs
decl_stmt|;
if|if
condition|(
name|nalternatives
operator|+
literal|1
operator|>
name|MAX_RECOG_ALTERNATIVES
condition|)
block|{
name|error
argument_list|(
literal|"too many alternatives in %<asm%>"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|tmp
operator|=
name|outputs
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
specifier|const
name|char
modifier|*
name|constraint
init|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|n_occurrences
argument_list|(
literal|','
argument_list|,
name|constraint
argument_list|)
operator|!=
name|nalternatives
condition|)
block|{
name|error
argument_list|(
literal|"operand constraints for %<asm%> differ "
literal|"in number of alternatives"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
condition|)
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
name|next
operator|,
name|next
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of expand_asm_operands.  Check that all operand names    are unique.  Return true if so.  We rely on the fact that these names    are identifiers, and so have been canonicalized by get_identifier,    so all we need are pointer comparisons.  */
end_comment

begin_function
specifier|static
name|bool
name|check_unique_operand_names
parameter_list|(
name|tree
name|outputs
parameter_list|,
name|tree
name|inputs
parameter_list|)
block|{
name|tree
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
name|outputs
init|;
name|i
condition|;
name|i
operator|=
name|TREE_CHAIN
argument_list|(
name|i
argument_list|)
control|)
block|{
name|tree
name|i_name
init|=
name|TREE_PURPOSE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|i_name
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
name|TREE_CHAIN
argument_list|(
name|i
argument_list|)
init|;
name|j
condition|;
name|j
operator|=
name|TREE_CHAIN
argument_list|(
name|j
argument_list|)
control|)
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|i_name
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|j
argument_list|)
argument_list|)
argument_list|)
condition|)
goto|goto
name|failure
goto|;
block|}
for|for
control|(
name|i
operator|=
name|inputs
init|;
name|i
condition|;
name|i
operator|=
name|TREE_CHAIN
argument_list|(
name|i
argument_list|)
control|)
block|{
name|tree
name|i_name
init|=
name|TREE_PURPOSE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|i_name
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
name|TREE_CHAIN
argument_list|(
name|i
argument_list|)
init|;
name|j
condition|;
name|j
operator|=
name|TREE_CHAIN
argument_list|(
name|j
argument_list|)
control|)
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|i_name
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|j
argument_list|)
argument_list|)
argument_list|)
condition|)
goto|goto
name|failure
goto|;
for|for
control|(
name|j
operator|=
name|outputs
init|;
name|j
condition|;
name|j
operator|=
name|TREE_CHAIN
argument_list|(
name|j
argument_list|)
control|)
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|i_name
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|j
argument_list|)
argument_list|)
argument_list|)
condition|)
goto|goto
name|failure
goto|;
block|}
return|return
name|true
return|;
name|failure
label|:
name|error
argument_list|(
literal|"duplicate asm operand name %qs"
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of expand_asm_operands.  Resolve the names of the operands    in *POUTPUTS and *PINPUTS to numbers, and replace the name expansions in    STRING and in the constraints to those numbers.  */
end_comment

begin_function
name|tree
name|resolve_asm_operand_names
parameter_list|(
name|tree
name|string
parameter_list|,
name|tree
name|outputs
parameter_list|,
name|tree
name|inputs
parameter_list|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|c
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|check_unique_operand_names
argument_list|(
name|outputs
argument_list|,
name|inputs
argument_list|)
expr_stmt|;
comment|/* Substitute [<name>] in input constraint strings.  There should be no      named operands in output constraints.  */
for|for
control|(
name|t
operator|=
name|inputs
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|c
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|c
argument_list|,
literal|'['
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|buffer
operator|=
name|xstrdup
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'['
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|p
operator|=
name|resolve_operand_name_1
argument_list|(
name|p
argument_list|,
name|outputs
argument_list|,
name|inputs
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|build_string
argument_list|(
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now check for any needed substitutions in the template.  */
name|c
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|string
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|strchr
argument_list|(
name|c
argument_list|,
literal|'%'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'['
condition|)
break|break;
elseif|else
if|if
condition|(
name|ISALPHA
argument_list|(
name|c
index|[
literal|1
index|]
argument_list|)
operator|&&
name|c
index|[
literal|2
index|]
operator|==
literal|'['
condition|)
break|break;
else|else
block|{
name|c
operator|+=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|c
condition|)
block|{
comment|/* OK, we need to make a copy so we can perform the substitutions. 	 Assume that we will not need extra space--we get to remove '[' 	 and ']', which means we cannot have a problem until we have more 	 than 999 operands.  */
name|buffer
operator|=
name|xstrdup
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|buffer
operator|+
operator|(
name|c
operator|-
name|TREE_STRING_POINTER
argument_list|(
name|string
argument_list|)
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'%'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'['
condition|)
name|p
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ISALPHA
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'['
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
else|else
block|{
name|p
operator|+=
literal|1
expr_stmt|;
continue|continue;
block|}
name|p
operator|=
name|resolve_operand_name_1
argument_list|(
name|p
argument_list|,
name|outputs
argument_list|,
name|inputs
argument_list|)
expr_stmt|;
block|}
name|string
operator|=
name|build_string
argument_list|(
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of resolve_operand_names.  P points to the '[' for a    potential named operand of the form [<name>].  In place, replace    the name and brackets with a number.  Return a pointer to the    balance of the string after substitution.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|resolve_operand_name_1
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|tree
name|outputs
parameter_list|,
name|tree
name|inputs
parameter_list|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|op
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/* Collect the operand name.  */
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
condition|)
block|{
name|error
argument_list|(
literal|"missing close brace for named operand"
argument_list|)
expr_stmt|;
return|return
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\0'
argument_list|)
return|;
block|}
name|len
operator|=
name|q
operator|-
name|p
operator|-
literal|1
expr_stmt|;
comment|/* Resolve the name to a number.  */
for|for
control|(
name|op
operator|=
literal|0
operator|,
name|t
operator|=
name|outputs
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|,
name|op
operator|++
control|)
block|{
name|tree
name|name
init|=
name|TREE_PURPOSE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
condition|)
block|{
specifier|const
name|char
modifier|*
name|c
init|=
name|TREE_STRING_POINTER
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|c
argument_list|,
name|p
operator|+
literal|1
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
name|c
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
goto|goto
name|found
goto|;
block|}
block|}
for|for
control|(
name|t
operator|=
name|inputs
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|,
name|op
operator|++
control|)
block|{
name|tree
name|name
init|=
name|TREE_PURPOSE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
condition|)
block|{
specifier|const
name|char
modifier|*
name|c
init|=
name|TREE_STRING_POINTER
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|c
argument_list|,
name|p
operator|+
literal|1
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
name|c
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
goto|goto
name|found
goto|;
block|}
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|error
argument_list|(
literal|"undefined named operand %qs"
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|op
operator|=
literal|0
expr_stmt|;
name|found
label|:
comment|/* Replace the name with the number.  Unfortunately, not all libraries      get the return value of sprintf correct, so search for the end of the      generated string by hand.  */
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%d"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* Verify the no extra buffer space assumption.  */
name|gcc_assert
argument_list|(
name|p
operator|<=
name|q
argument_list|)
expr_stmt|;
comment|/* Shift the rest of the buffer down to fill the gap.  */
name|memmove
argument_list|(
name|p
argument_list|,
name|q
operator|+
literal|1
argument_list|,
name|strlen
argument_list|(
name|q
operator|+
literal|1
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL to evaluate the expression EXP.  */
end_comment

begin_function
name|void
name|expand_expr_stmt
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|rtx
name|value
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|value
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* If all we do is reference a volatile value in memory,      copy it to a register to be sure it is actually touched.  */
if|if
condition|(
name|value
operator|&&
name|MEM_P
argument_list|(
name|value
argument_list|)
operator|&&
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOIDmode
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|BLKmode
condition|)
name|value
operator|=
name|copy_to_reg
argument_list|(
name|value
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|lab
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
comment|/* Compare the value with itself to reference it.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|value
argument_list|,
name|value
argument_list|,
name|EQ
argument_list|,
name|expand_normal
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|BLKmode
argument_list|,
literal|0
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|lab
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Free any temporaries used to evaluate this expression.  */
name|free_temp_slots
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Warn if EXP contains any computations whose results are not used.    Return 1 if a warning is printed; 0 otherwise.  LOCUS is the    (potential) location of the expression.  */
end_comment

begin_function
name|int
name|warn_if_unused_value
parameter_list|(
name|tree
name|exp
parameter_list|,
name|location_t
name|locus
parameter_list|)
block|{
name|restart
label|:
if|if
condition|(
name|TREE_USED
argument_list|(
name|exp
argument_list|)
operator|||
name|TREE_NO_WARNING
argument_list|(
name|exp
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Don't warn about void constructs.  This includes casting to void,      void function calls, and statement expressions with a final cast      to void.  */
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|EXPR_HAS_LOCATION
argument_list|(
name|exp
argument_list|)
condition|)
name|locus
operator|=
name|EXPR_LOCATION
argument_list|(
name|exp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
case|case
name|INIT_EXPR
case|:
case|case
name|TARGET_EXPR
case|:
case|case
name|CALL_EXPR
case|:
case|case
name|TRY_CATCH_EXPR
case|:
case|case
name|WITH_CLEANUP_EXPR
case|:
case|case
name|EXIT_EXPR
case|:
case|case
name|VA_ARG_EXPR
case|:
return|return
literal|0
return|;
case|case
name|BIND_EXPR
case|:
comment|/* For a binding, warn if no side effect within it.  */
name|exp
operator|=
name|BIND_EXPR_BODY
argument_list|(
name|exp
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
case|case
name|SAVE_EXPR
case|:
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
comment|/* In&& or ||, warn if 2nd operand has no side effect.  */
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
case|case
name|COMPOUND_EXPR
case|:
if|if
condition|(
name|warn_if_unused_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|locus
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Let people do `(foo (), 0)' without a warning.  */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
case|case
name|COND_EXPR
case|:
comment|/* If this is an expression with side effects, don't warn; this 	 case commonly appears in macro expansions.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|exp
argument_list|)
condition|)
return|return
literal|0
return|;
goto|goto
name|warn
goto|;
case|case
name|INDIRECT_REF
case|:
comment|/* Don't warn about automatic dereferencing of references, since 	 the user cannot control it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
comment|/* Fall through.  */
default|default:
comment|/* Referencing a volatile value is a side effect, so don't warn.  */
if|if
condition|(
operator|(
name|DECL_P
argument_list|(
name|exp
argument_list|)
operator|||
name|REFERENCE_CLASS_P
argument_list|(
name|exp
argument_list|)
operator|)
operator|&&
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If this is an expression which has no operands, there is no value 	 to be unused.  There are no such language-independent codes, 	 but front ends may define such.  */
if|if
condition|(
name|EXPRESSION_CLASS_P
argument_list|(
name|exp
argument_list|)
operator|&&
name|TREE_CODE_LENGTH
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|warn
label|:
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%Hvalue computed is not used"
argument_list|,
operator|&
name|locus
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL to return from the current function, with no value.    (That is, we do not do anything about returning any value.)  */
end_comment

begin_function
name|void
name|expand_null_return
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* If this function was declared to return a value, but we      didn't, clobber the return registers so that they are not      propagated live to the rest of the function.  */
name|clobber_return_register
argument_list|()
expr_stmt|;
name|expand_null_return_1
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL to return directly from the current function.    (That is, we bypass any return value.)  */
end_comment

begin_function
name|void
name|expand_naked_return
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|end_label
decl_stmt|;
name|clear_pending_stack_adjust
argument_list|()
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|end_label
operator|=
name|naked_return_label
expr_stmt|;
if|if
condition|(
name|end_label
operator|==
literal|0
condition|)
name|end_label
operator|=
name|naked_return_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_jump
argument_list|(
name|end_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL to return from the current function, with value VAL.  */
end_comment

begin_function
specifier|static
name|void
name|expand_value_return
parameter_list|(
name|rtx
name|val
parameter_list|)
block|{
comment|/* Copy the value to the return location      unless it's already there.  */
name|rtx
name|return_reg
init|=
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|return_reg
operator|!=
name|val
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|promote_function_return
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|unsignedp
init|=
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|old_mode
init|=
name|DECL_MODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|promote_mode
argument_list|(
name|type
argument_list|,
name|old_mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|old_mode
condition|)
name|val
operator|=
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|old_mode
argument_list|,
name|val
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|return_reg
argument_list|)
operator|==
name|PARALLEL
condition|)
name|emit_group_load
argument_list|(
name|return_reg
argument_list|,
name|val
argument_list|,
name|type
argument_list|,
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|return_reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|expand_null_return_1
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a return with no value.  */
end_comment

begin_function
specifier|static
name|void
name|expand_null_return_1
parameter_list|(
name|void
parameter_list|)
block|{
name|clear_pending_stack_adjust
argument_list|()
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_jump
argument_list|(
name|return_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL to evaluate the expression RETVAL and return it    from the current function.  */
end_comment

begin_function
name|void
name|expand_return
parameter_list|(
name|tree
name|retval
parameter_list|)
block|{
name|rtx
name|result_rtl
decl_stmt|;
name|rtx
name|val
init|=
literal|0
decl_stmt|;
name|tree
name|retval_rhs
decl_stmt|;
comment|/* If function wants no value, give it none.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|expand_normal
argument_list|(
name|retval
argument_list|)
expr_stmt|;
name|expand_null_return
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|retval
operator|==
name|error_mark_node
condition|)
block|{
comment|/* Treat this like a return of no value from a function that 	 returns a value.  */
name|expand_null_return
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|==
name|MODIFY_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|==
name|INIT_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|retval
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|RESULT_DECL
condition|)
name|retval_rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|retval
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|retval_rhs
operator|=
name|retval
expr_stmt|;
name|result_rtl
operator|=
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we are returning the RESULT_DECL, then the value has already      been stored into it, so we don't have to do anything special.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|retval_rhs
argument_list|)
operator|==
name|RESULT_DECL
condition|)
name|expand_value_return
argument_list|(
name|result_rtl
argument_list|)
expr_stmt|;
comment|/* If the result is an aggregate that is being returned in one (or more)      registers, load the registers here.  The compiler currently can't handle      copying a BLKmode value into registers.  We could put this code in a      more general area (for use by everyone instead of just function      call/return), but until this feature is generally usable it is kept here      (and in expand_call).  */
elseif|else
if|if
condition|(
name|retval_rhs
operator|!=
literal|0
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval_rhs
argument_list|)
argument_list|)
operator|==
name|BLKmode
operator|&&
name|REG_P
argument_list|(
name|result_rtl
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|bitpos
decl_stmt|,
name|xbitpos
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|padding_correction
init|=
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|bytes
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval_rhs
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|n_regs
init|=
operator|(
name|bytes
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
name|unsigned
name|int
name|bitsize
init|=
name|MIN
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval_rhs
argument_list|)
argument_list|)
argument_list|,
name|BITS_PER_WORD
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|result_pseudos
init|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
operator|*
name|n_regs
argument_list|)
decl_stmt|;
name|rtx
name|result_reg
decl_stmt|,
name|src
init|=
name|NULL_RTX
decl_stmt|,
name|dst
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|result_val
init|=
name|expand_normal
argument_list|(
name|retval_rhs
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmpmode
decl_stmt|,
name|result_reg_mode
decl_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|0
condition|)
block|{
name|expand_null_return
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* If the structure doesn't take up a whole number of words, see 	 whether the register value should be padded on the left or on 	 the right.  Set PADDING_CORRECTION to the number of padding 	 bits needed on the left side.  	 In most ABIs, the structure will be returned at the least end of 	 the register, which translates to right padding on little-endian 	 targets and left padding on big-endian targets.  The opposite 	 holds if the structure is returned at the most significant 	 end of the register.  */
if|if
condition|(
name|bytes
operator|%
name|UNITS_PER_WORD
operator|!=
literal|0
operator|&&
operator|(
name|targetm
operator|.
name|calls
operator|.
name|return_in_msb
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval_rhs
argument_list|)
argument_list|)
condition|?
operator|!
name|BYTES_BIG_ENDIAN
else|:
name|BYTES_BIG_ENDIAN
operator|)
condition|)
name|padding_correction
operator|=
operator|(
name|BITS_PER_WORD
operator|-
operator|(
operator|(
name|bytes
operator|%
name|UNITS_PER_WORD
operator|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
comment|/* Copy the structure BITSIZE bits at a time.  */
for|for
control|(
name|bitpos
operator|=
literal|0
operator|,
name|xbitpos
operator|=
name|padding_correction
init|;
name|bitpos
operator|<
name|bytes
operator|*
name|BITS_PER_UNIT
condition|;
name|bitpos
operator|+=
name|bitsize
operator|,
name|xbitpos
operator|+=
name|bitsize
control|)
block|{
comment|/* We need a new destination pseudo each time xbitpos is 	     on a word boundary and when xbitpos == padding_correction 	     (the first time through).  */
if|if
condition|(
name|xbitpos
operator|%
name|BITS_PER_WORD
operator|==
literal|0
operator|||
name|xbitpos
operator|==
name|padding_correction
condition|)
block|{
comment|/* Generate an appropriate register.  */
name|dst
operator|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
expr_stmt|;
name|result_pseudos
index|[
name|xbitpos
operator|/
name|BITS_PER_WORD
index|]
operator|=
name|dst
expr_stmt|;
comment|/* Clear the destination before we move anything into it.  */
name|emit_move_insn
argument_list|(
name|dst
argument_list|,
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We need a new source operand each time bitpos is on a word 	     boundary.  */
if|if
condition|(
name|bitpos
operator|%
name|BITS_PER_WORD
operator|==
literal|0
condition|)
name|src
operator|=
name|operand_subword_force
argument_list|(
name|result_val
argument_list|,
name|bitpos
operator|/
name|BITS_PER_WORD
argument_list|,
name|BLKmode
argument_list|)
expr_stmt|;
comment|/* Use bitpos for the source extraction (left justified) and 	     xbitpos for the destination store (right justified).  */
name|store_bit_field
argument_list|(
name|dst
argument_list|,
name|bitsize
argument_list|,
name|xbitpos
operator|%
name|BITS_PER_WORD
argument_list|,
name|word_mode
argument_list|,
name|extract_bit_field
argument_list|(
name|src
argument_list|,
name|bitsize
argument_list|,
name|bitpos
operator|%
name|BITS_PER_WORD
argument_list|,
literal|1
argument_list|,
name|NULL_RTX
argument_list|,
name|word_mode
argument_list|,
name|word_mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tmpmode
operator|=
name|GET_MODE
argument_list|(
name|result_rtl
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpmode
operator|==
name|BLKmode
condition|)
block|{
comment|/* Find the smallest integer mode large enough to hold the 	     entire structure and use that mode instead of BLKmode 	     on the USE insn for the return register.  */
for|for
control|(
name|tmpmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|tmpmode
operator|!=
name|VOIDmode
condition|;
name|tmpmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmpmode
argument_list|)
control|)
comment|/* Have we found a large enough mode?  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmpmode
argument_list|)
operator|>=
name|bytes
condition|)
break|break;
comment|/* A suitable mode should have been found.  */
name|gcc_assert
argument_list|(
name|tmpmode
operator|!=
name|VOIDmode
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|result_rtl
argument_list|,
name|tmpmode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmpmode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|word_mode
argument_list|)
condition|)
name|result_reg_mode
operator|=
name|word_mode
expr_stmt|;
else|else
name|result_reg_mode
operator|=
name|tmpmode
expr_stmt|;
name|result_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|result_reg_mode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_regs
condition|;
name|i
operator|++
control|)
name|emit_move_insn
argument_list|(
name|operand_subword
argument_list|(
name|result_reg
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|result_reg_mode
argument_list|)
argument_list|,
name|result_pseudos
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpmode
operator|!=
name|result_reg_mode
condition|)
name|result_reg
operator|=
name|gen_lowpart
argument_list|(
name|tmpmode
argument_list|,
name|result_reg
argument_list|)
expr_stmt|;
name|expand_value_return
argument_list|(
name|result_reg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|retval_rhs
operator|!=
literal|0
operator|&&
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval_rhs
argument_list|)
argument_list|)
operator|&&
operator|(
name|REG_P
argument_list|(
name|result_rtl
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|result_rtl
argument_list|)
operator|==
name|PARALLEL
operator|)
operator|)
condition|)
block|{
comment|/* Calculate the return value into a temporary (usually a pseudo          reg).  */
name|tree
name|ot
init|=
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|nt
init|=
name|build_qualified_type
argument_list|(
name|ot
argument_list|,
name|TYPE_QUALS
argument_list|(
name|ot
argument_list|)
operator||
name|TYPE_QUAL_CONST
argument_list|)
decl_stmt|;
name|val
operator|=
name|assign_temp
argument_list|(
name|nt
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|val
operator|=
name|expand_expr
argument_list|(
name|retval_rhs
argument_list|,
name|val
argument_list|,
name|GET_MODE
argument_list|(
name|val
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
name|force_not_mem
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Return the calculated value.  */
name|expand_value_return
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No hard reg used; calculate value into hard return reg.  */
name|expand_expr
argument_list|(
name|retval
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_value_return
argument_list|(
name|result_rtl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a pointer to a BLOCK node return nonzero if (and only if) the node    in question represents the outermost pair of curly braces (i.e. the "body    block") of a function or method.     For any BLOCK node representing a "body block" of a function or method, the    BLOCK_SUPERCONTEXT of the node will point to another BLOCK node which    represents the outermost (function) scope for the function or method (i.e.    the one which includes the formal parameters).  The BLOCK_SUPERCONTEXT of    *that* node in turn will point to the relevant FUNCTION_DECL node.  */
end_comment

begin_function
name|int
name|is_body_block
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
if|if
condition|(
name|lang_hooks
operator|.
name|no_body_blocks
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|BLOCK
condition|)
block|{
name|tree
name|parent
init|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|&&
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|==
name|BLOCK
condition|)
block|{
name|tree
name|grandparent
init|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|grandparent
operator|&&
name|TREE_CODE
argument_list|(
name|grandparent
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Emit code to restore vital registers at the beginning of a nonlocal goto    handler.  */
end_comment

begin_function
specifier|static
name|void
name|expand_nl_goto_receiver
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Clobber the FP when we get here, so we have to make sure it's      marked as used by this function.  */
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark the static chain as clobbered here so life information      doesn't get messed up for it.  */
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|static_chain_rtx
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_nonlocal_goto
if|if
condition|(
operator|!
name|HAVE_nonlocal_goto
condition|)
endif|#
directive|endif
comment|/* First adjust our frame pointer to its actual value.  It was        previously set to the start of the virtual area corresponding to        the stacked variables when we branched here and now needs to be        adjusted to the actual hardware fp value.         Assignments are to virtual registers are converted by        instantiate_virtual_regs into the corresponding assignment        to the underlying register (fp in this case) that makes        the original assignment true.        So the following insn will actually be        decrementing fp by STARTING_FRAME_OFFSET.  */
name|emit_move_insn
argument_list|(
name|virtual_stack_vars_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
if|if
condition|(
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
comment|/* If the argument pointer can be eliminated in favor of the 	 frame pointer, we don't need to restore it.  We assume here 	 that if such an elimination is present, it can always be used. 	 This is the case on all known machines; if we don't make this 	 assumption, we do unnecessary saving on many machines.  */
specifier|static
specifier|const
struct|struct
name|elims
block|{
specifier|const
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|}
name|elim_regs
index|[]
init|=
name|ELIMINABLE_REGS
struct|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|elim_regs
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|elim_regs
index|[
name|i
index|]
operator|.
name|from
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|elim_regs
index|[
name|i
index|]
operator|.
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|ARRAY_SIZE
argument_list|(
name|elim_regs
argument_list|)
condition|)
endif|#
directive|endif
block|{
comment|/* Now restore our arg pointer from the address at which it 	     was saved in our stack frame.  */
name|emit_move_insn
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
name|copy_to_reg
argument_list|(
name|get_arg_pointer_save_area
argument_list|(
name|cfun
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_nonlocal_goto_receiver
if|if
condition|(
name|HAVE_nonlocal_goto_receiver
condition|)
name|emit_insn
argument_list|(
name|gen_nonlocal_goto_receiver
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* @@@ This is a kludge.  Not all machine descriptions define a blockage      insn, but we must not allow the code we just generated to be reordered      by scheduling.  Specifically, the update of the frame pointer must      happen immediately, not later.  So emit an ASM_INPUT to act as blockage      insn.  */
name|emit_insn
argument_list|(
name|gen_rtx_ASM_INPUT
argument_list|(
name|VOIDmode
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL for the automatic variable declaration DECL.    (Other kinds of declarations are simply ignored if seen here.)  */
end_comment

begin_function
name|void
name|expand_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* For a CONST_DECL, set mode, alignment, and sizes from those of the      type in case this node is used in a reference.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, only automatic variables need any expansion done.  Static and      external variables, and external functions, will be handled by      `assemble_variable' (called from finish_decl).  TYPE_DECL requires      nothing.  PARM_DECLs are handled in `assign_parms'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
condition|)
return|return;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Create the RTL representation for the variable.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
comment|/* Variable with incomplete type.  */
block|{
name|rtx
name|x
decl_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
comment|/* Error message was already done; now avoid a crash.  */
name|x
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
else|else
comment|/* An initializer is going to decide the size of this array. 	   Until we know the size, represent its address with a reg.  */
name|x
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|x
argument_list|,
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|use_register_for_decl
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Automatic variable that can go in a register.  */
name|int
name|unsignedp
init|=
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|reg_mode
init|=
name|promote_mode
argument_list|(
name|type
argument_list|,
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|gen_reg_rtx
argument_list|(
name|reg_mode
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note if the object is a user variable.  */
if|if
condition|(
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|mark_user_reg
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Trust user variables which have a pointer type to really 	     be pointers.  Do not trust compiler generated temporaries 	     as our type system is totally busted as it relates to 	     pointer arithmetic which translates into lots of compiler 	     generated objects with pointer types, but which are not really 	     pointers.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|mark_reg_pointer
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
operator|(
name|flag_stack_check
operator|&&
operator|!
name|STACK_CHECK_BUILTIN
operator|&&
literal|0
operator|<
name|compare_tree_int
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|,
name|STACK_CHECK_MAX_VAR_SIZE
argument_list|)
operator|)
condition|)
block|{
comment|/* Variable of fixed size that goes on the stack.  */
name|rtx
name|oldaddr
init|=
literal|0
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
name|rtx
name|x
decl_stmt|;
comment|/* If we previously made RTL for this decl, it must be an array 	 whose size was determined by the initializer. 	 The old address was a register; set that register now 	 to the proper address.  */
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|MEM_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|oldaddr
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Set alignment we actually gave this decl.  */
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|==
name|BLKmode
condition|?
name|BIGGEST_ALIGNMENT
else|:
name|GET_MODE_BITSIZE
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|assign_temp
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|x
argument_list|,
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldaddr
condition|)
block|{
name|addr
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|oldaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
name|oldaddr
condition|)
name|emit_move_insn
argument_list|(
name|oldaddr
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Dynamic-size object: must push space on the stack.  */
block|{
name|rtx
name|address
decl_stmt|,
name|size
decl_stmt|,
name|x
decl_stmt|;
comment|/* Record the stack pointer on entry to block, if have 	 not already done so.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Compute the variable's size, in bytes.  This will expand any 	 needed SAVE_EXPRs for the first time.  */
name|size
operator|=
name|expand_normal
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
comment|/* Allocate space on the stack for the variable.  Note that 	 DECL_ALIGN says how the variable is to be aligned and we 	 cannot use it to conclude anything about the alignment of 	 the size.  */
name|address
operator|=
name|allocate_dynamic_stack_space
argument_list|(
name|size
argument_list|,
name|NULL_RTX
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Reference the variable indirect through that rtx.  */
name|x
operator|=
name|gen_rtx_MEM
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|x
argument_list|,
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Indicate the alignment we actually gave this variable.  */
ifdef|#
directive|ifdef
name|STACK_BOUNDARY
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|STACK_BOUNDARY
expr_stmt|;
else|#
directive|else
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|BIGGEST_ALIGNMENT
expr_stmt|;
endif|#
directive|endif
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit code to save the current value of stack.  */
end_comment

begin_function
name|rtx
name|expand_stack_save
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|ret
init|=
name|NULL_RTX
decl_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_stack_save
argument_list|(
name|SAVE_BLOCK
argument_list|,
operator|&
name|ret
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Emit code to restore the current value of stack.  */
end_comment

begin_function
name|void
name|expand_stack_restore
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|rtx
name|sa
init|=
name|DECL_RTL
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|emit_stack_restore
argument_list|(
name|SAVE_BLOCK
argument_list|,
name|sa
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* DECL is an anonymous union.  CLEANUP is a cleanup for DECL.    DECL_ELTS is the list of elements that belong to DECL's type.    In each, the TREE_VALUE is a VAR_DECL, and the TREE_PURPOSE a cleanup.  */
end_comment

begin_function
name|void
name|expand_anon_union_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|cleanup
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|decl_elts
parameter_list|)
block|{
name|rtx
name|x
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* If any of the elements are addressable, so is the entire union.  */
for|for
control|(
name|t
operator|=
name|decl_elts
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|x
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Go through the elements, assigning RTL to each.  */
for|for
control|(
name|t
operator|=
name|decl_elts
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|decl_elt
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl_elt
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|decl_rtl
decl_stmt|;
comment|/* If any of the elements are addressable, so is the entire 	 union.  */
if|if
condition|(
name|TREE_USED
argument_list|(
name|decl_elt
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Propagate the union's alignment to the elements.  */
name|DECL_ALIGN
argument_list|(
name|decl_elt
argument_list|)
operator|=
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|decl_elt
argument_list|)
operator|=
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If the element has BLKmode and the union doesn't, the union is          aligned such that the element doesn't need to have BLKmode, so          change the element's mode to the appropriate one for its size.  */
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|&&
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|BLKmode
condition|)
name|DECL_MODE
argument_list|(
name|decl_elt
argument_list|)
operator|=
name|mode
operator|=
name|mode_for_size_tree
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl_elt
argument_list|)
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
name|decl_rtl
operator|=
name|x
expr_stmt|;
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|x
argument_list|)
condition|)
comment|/* (SUBREG (MEM ...)) at RTL generation time is invalid, so we            instead create a new MEM rtx with the proper mode.  */
name|decl_rtl
operator|=
name|adjust_address_nv
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|REG_P
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|decl_rtl
operator|=
name|gen_lowpart_SUBREG
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|SET_DECL_RTL
argument_list|(
name|decl_elt
argument_list|,
name|decl_rtl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Do the insertion of a case label into case_list.  The labels are    fed to us in descending order from the sorted vector of case labels used    in the tree part of the middle end.  So the list we construct is    sorted in ascending order.  The bounds on the case range, LOW and HIGH,    are converted to case's index type TYPE.  */
end_comment

begin_function
specifier|static
name|struct
name|case_node
modifier|*
name|add_case_node
parameter_list|(
name|struct
name|case_node
modifier|*
name|head
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|low
parameter_list|,
name|tree
name|high
parameter_list|,
name|tree
name|label
parameter_list|)
block|{
name|tree
name|min_value
decl_stmt|,
name|max_value
decl_stmt|;
name|struct
name|case_node
modifier|*
name|r
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|low
argument_list|)
operator|==
name|INTEGER_CST
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|high
operator|||
name|TREE_CODE
argument_list|(
name|high
argument_list|)
operator|==
name|INTEGER_CST
argument_list|)
expr_stmt|;
name|min_value
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|max_value
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* If there's no HIGH value, then this is not a case range; it's      just a simple case label.  But that's just a degenerate case      range.      If the bounds are equal, turn this into the one-value case.  */
if|if
condition|(
operator|!
name|high
operator|||
name|tree_int_cst_equal
argument_list|(
name|low
argument_list|,
name|high
argument_list|)
condition|)
block|{
comment|/* If the simple case value is unreachable, ignore it.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|min_value
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_compare
argument_list|(
name|low
argument_list|,
name|min_value
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|max_value
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_compare
argument_list|(
name|low
argument_list|,
name|max_value
argument_list|)
operator|>
literal|0
operator|)
condition|)
return|return
name|head
return|;
name|low
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|low
argument_list|)
expr_stmt|;
name|high
operator|=
name|low
expr_stmt|;
block|}
else|else
block|{
comment|/* If the entire case range is unreachable, ignore it.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|min_value
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_compare
argument_list|(
name|high
argument_list|,
name|min_value
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|max_value
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_compare
argument_list|(
name|low
argument_list|,
name|max_value
argument_list|)
operator|>
literal|0
operator|)
condition|)
return|return
name|head
return|;
comment|/* If the lower bound is less than the index type's minimum 	 value, truncate the range bounds.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|min_value
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_compare
argument_list|(
name|low
argument_list|,
name|min_value
argument_list|)
operator|<
literal|0
condition|)
name|low
operator|=
name|min_value
expr_stmt|;
name|low
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|low
argument_list|)
expr_stmt|;
comment|/* If the upper bound is greater than the index type's maximum 	 value, truncate the range bounds.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|max_value
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_compare
argument_list|(
name|high
argument_list|,
name|max_value
argument_list|)
operator|>
literal|0
condition|)
name|high
operator|=
name|max_value
expr_stmt|;
name|high
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|high
argument_list|)
expr_stmt|;
block|}
comment|/* Add this label to the chain.  Make sure to drop overflow flags.  */
name|r
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|case_node
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|low
operator|=
name|build_int_cst_wide
argument_list|(
name|TREE_TYPE
argument_list|(
name|low
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|low
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|low
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|high
operator|=
name|build_int_cst_wide
argument_list|(
name|TREE_TYPE
argument_list|(
name|high
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|high
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|high
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|code_label
operator|=
name|label
expr_stmt|;
name|r
operator|->
name|parent
operator|=
name|r
operator|->
name|left
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|right
operator|=
name|head
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Maximum number of case bit tests.  */
end_comment

begin_define
define|#
directive|define
name|MAX_CASE_BIT_TESTS
value|3
end_define

begin_comment
comment|/* By default, enable case bit tests on targets with ashlsi3.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CASE_USE_BIT_TESTS
end_ifndef

begin_define
define|#
directive|define
name|CASE_USE_BIT_TESTS
value|(ashl_optab->handlers[word_mode].insn_code \ 			     != CODE_FOR_nothing)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A case_bit_test represents a set of case nodes that may be    selected from using a bit-wise comparison.  HI and LO hold    the integer to be tested against, LABEL contains the label    to jump to upon success and BITS counts the number of case    nodes handled by this test, typically the number of bits    set in HI:LO.  */
end_comment

begin_struct
struct|struct
name|case_bit_test
block|{
name|HOST_WIDE_INT
name|hi
decl_stmt|;
name|HOST_WIDE_INT
name|lo
decl_stmt|;
name|rtx
name|label
decl_stmt|;
name|int
name|bits
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Determine whether "1<< x" is relatively cheap in word_mode.  */
end_comment

begin_function
specifier|static
name|bool
name|lshift_cheap_p
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|bool
name|init
init|=
name|false
decl_stmt|;
specifier|static
name|bool
name|cheap
init|=
name|true
decl_stmt|;
if|if
condition|(
operator|!
name|init
condition|)
block|{
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
literal|10000
argument_list|)
decl_stmt|;
name|int
name|cost
init|=
name|rtx_cost
argument_list|(
name|gen_rtx_ASHIFT
argument_list|(
name|word_mode
argument_list|,
name|const1_rtx
argument_list|,
name|reg
argument_list|)
argument_list|,
name|SET
argument_list|)
decl_stmt|;
name|cheap
operator|=
name|cost
operator|<
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|init
operator|=
name|true
expr_stmt|;
block|}
return|return
name|cheap
return|;
block|}
end_function

begin_comment
comment|/* Comparison function for qsort to order bit tests by decreasing    number of case nodes, i.e. the node with the most cases gets    tested first.  */
end_comment

begin_function
specifier|static
name|int
name|case_bit_test_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|struct
name|case_bit_test
modifier|*
name|d1
init|=
name|p1
decl_stmt|;
specifier|const
name|struct
name|case_bit_test
modifier|*
name|d2
init|=
name|p2
decl_stmt|;
if|if
condition|(
name|d2
operator|->
name|bits
operator|!=
name|d1
operator|->
name|bits
condition|)
return|return
name|d2
operator|->
name|bits
operator|-
name|d1
operator|->
name|bits
return|;
comment|/* Stabilize the sort.  */
return|return
name|CODE_LABEL_NUMBER
argument_list|(
name|d2
operator|->
name|label
argument_list|)
operator|-
name|CODE_LABEL_NUMBER
argument_list|(
name|d1
operator|->
name|label
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  Expand a switch statement by a short sequence of bit-wise     comparisons.  "switch(x)" is effectively converted into     "if ((1<< (x-MINVAL))& CST)" where CST and MINVAL are     integer constants.      INDEX_EXPR is the value being switched on, which is of     type INDEX_TYPE.  MINVAL is the lowest case value of in     the case nodes, of INDEX_TYPE type, and RANGE is highest     value minus MINVAL, also of type INDEX_TYPE.  NODES is     the set of case nodes, and DEFAULT_LABEL is the label to     branch to should none of the cases match.      There *MUST* be MAX_CASE_BIT_TESTS or less unique case     node targets.  */
end_comment

begin_function
specifier|static
name|void
name|emit_case_bit_tests
parameter_list|(
name|tree
name|index_type
parameter_list|,
name|tree
name|index_expr
parameter_list|,
name|tree
name|minval
parameter_list|,
name|tree
name|range
parameter_list|,
name|case_node_ptr
name|nodes
parameter_list|,
name|rtx
name|default_label
parameter_list|)
block|{
name|struct
name|case_bit_test
name|test
index|[
name|MAX_CASE_BIT_TESTS
index|]
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|expr
decl_stmt|,
name|index
decl_stmt|,
name|label
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|lo
decl_stmt|,
name|hi
decl_stmt|;
name|struct
name|case_node
modifier|*
name|n
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|nodes
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
block|{
name|label
operator|=
name|label_rtx
argument_list|(
name|n
operator|->
name|code_label
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|label
operator|==
name|test
index|[
name|i
index|]
operator|.
name|label
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|count
condition|)
block|{
name|gcc_assert
argument_list|(
name|count
operator|<
name|MAX_CASE_BIT_TESTS
argument_list|)
expr_stmt|;
name|test
index|[
name|i
index|]
operator|.
name|hi
operator|=
literal|0
expr_stmt|;
name|test
index|[
name|i
index|]
operator|.
name|lo
operator|=
literal|0
expr_stmt|;
name|test
index|[
name|i
index|]
operator|.
name|label
operator|=
name|label
expr_stmt|;
name|test
index|[
name|i
index|]
operator|.
name|bits
operator|=
literal|1
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
else|else
name|test
index|[
name|i
index|]
operator|.
name|bits
operator|++
expr_stmt|;
name|lo
operator|=
name|tree_low_cst
argument_list|(
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index_type
argument_list|,
name|n
operator|->
name|low
argument_list|,
name|minval
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hi
operator|=
name|tree_low_cst
argument_list|(
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index_type
argument_list|,
name|n
operator|->
name|high
argument_list|,
name|minval
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|lo
init|;
name|j
operator|<=
name|hi
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|j
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|)
name|test
index|[
name|i
index|]
operator|.
name|hi
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|j
operator|-
name|HOST_BITS_PER_INT
operator|)
expr_stmt|;
else|else
name|test
index|[
name|i
index|]
operator|.
name|lo
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|j
expr_stmt|;
block|}
name|qsort
argument_list|(
name|test
argument_list|,
name|count
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|test
argument_list|)
argument_list|,
name|case_bit_test_cmp
argument_list|)
expr_stmt|;
name|index_expr
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index_type
argument_list|,
name|fold_convert
argument_list|(
name|index_type
argument_list|,
name|index_expr
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|index_type
argument_list|,
name|minval
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|=
name|expand_normal
argument_list|(
name|index_expr
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|index_type
argument_list|)
expr_stmt|;
name|expr
operator|=
name|expand_normal
argument_list|(
name|range
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|expr
argument_list|,
name|GTU
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
name|index
operator|=
name|convert_to_mode
argument_list|(
name|word_mode
argument_list|,
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|index
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|ashl_optab
argument_list|,
name|const1_rtx
argument_list|,
name|index
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|expr
operator|=
name|immed_double_const
argument_list|(
name|test
index|[
name|i
index|]
operator|.
name|lo
argument_list|,
name|test
index|[
name|i
index|]
operator|.
name|hi
argument_list|,
name|word_mode
argument_list|)
expr_stmt|;
name|expr
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|and_optab
argument_list|,
name|index
argument_list|,
name|expr
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|expr
argument_list|,
name|const0_rtx
argument_list|,
name|NE
argument_list|,
name|NULL_RTX
argument_list|,
name|word_mode
argument_list|,
literal|1
argument_list|,
name|test
index|[
name|i
index|]
operator|.
name|label
argument_list|)
expr_stmt|;
block|}
name|emit_jump
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_casesi
end_ifndef

begin_define
define|#
directive|define
name|HAVE_casesi
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_tablejump
end_ifndef

begin_define
define|#
directive|define
name|HAVE_tablejump
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Terminate a case (Pascal/Ada) or switch (C) statement    in which ORIG_INDEX is the expression to be tested.    If ORIG_TYPE is not NULL, it is the original ORIG_INDEX    type as given in the source before any compiler conversions.    Generate the code to test it and jump to the right place.  */
end_comment

begin_function
name|void
name|expand_case
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|minval
init|=
name|NULL_TREE
decl_stmt|,
name|maxval
init|=
name|NULL_TREE
decl_stmt|,
name|range
init|=
name|NULL_TREE
decl_stmt|;
name|rtx
name|default_label
init|=
literal|0
decl_stmt|;
name|struct
name|case_node
modifier|*
name|n
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|,
name|uniq
decl_stmt|;
name|rtx
name|index
decl_stmt|;
name|rtx
name|table_label
decl_stmt|;
name|int
name|ncases
decl_stmt|;
name|rtx
modifier|*
name|labelvec
decl_stmt|;
name|int
name|i
decl_stmt|,
name|fail
decl_stmt|;
name|rtx
name|before_case
decl_stmt|,
name|end
decl_stmt|,
name|lab
decl_stmt|;
name|tree
name|vec
init|=
name|SWITCH_LABELS
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|orig_type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|index_expr
init|=
name|SWITCH_COND
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|index_type
init|=
name|TREE_TYPE
argument_list|(
name|index_expr
argument_list|)
decl_stmt|;
name|int
name|unsignedp
init|=
name|TYPE_UNSIGNED
argument_list|(
name|index_type
argument_list|)
decl_stmt|;
comment|/* The insn after which the case dispatch should finally      be emitted.  Zero for a dummy.  */
name|rtx
name|start
decl_stmt|;
comment|/* A list of case labels; it is first built as a list and it may then      be rearranged into a nearly balanced binary tree.  */
name|struct
name|case_node
modifier|*
name|case_list
init|=
literal|0
decl_stmt|;
comment|/* Label to jump to if no case matches.  */
name|tree
name|default_label_decl
decl_stmt|;
comment|/* The switch body is lowered in gimplify.c, we should never have      switches with a non-NULL SWITCH_BODY here.  */
name|gcc_assert
argument_list|(
operator|!
name|SWITCH_BODY
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|SWITCH_LABELS
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* An ERROR_MARK occurs for various reasons including invalid data type.  */
if|if
condition|(
name|index_type
operator|!=
name|error_mark_node
condition|)
block|{
name|tree
name|elt
decl_stmt|;
name|bitmap
name|label_bitmap
decl_stmt|;
comment|/* cleanup_tree_cfg removes all SWITCH_EXPR with their index 	 expressions being INTEGER_CST.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|index_expr
argument_list|)
operator|!=
name|INTEGER_CST
argument_list|)
expr_stmt|;
comment|/* The default case is at the end of TREE_VEC.  */
name|elt
operator|=
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|vec
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|CASE_HIGH
argument_list|(
name|elt
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|CASE_LOW
argument_list|(
name|elt
argument_list|)
argument_list|)
expr_stmt|;
name|default_label_decl
operator|=
name|CASE_LABEL
argument_list|(
name|elt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|vec
argument_list|)
operator|-
literal|1
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|tree
name|low
decl_stmt|,
name|high
decl_stmt|;
name|elt
operator|=
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|low
operator|=
name|CASE_LOW
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|low
argument_list|)
expr_stmt|;
name|high
operator|=
name|CASE_HIGH
argument_list|(
name|elt
argument_list|)
expr_stmt|;
comment|/* Discard empty ranges.  */
if|if
condition|(
name|high
operator|&&
name|INT_CST_LT
argument_list|(
name|high
argument_list|,
name|low
argument_list|)
condition|)
continue|continue;
name|case_list
operator|=
name|add_case_node
argument_list|(
name|case_list
argument_list|,
name|index_type
argument_list|,
name|low
argument_list|,
name|high
argument_list|,
name|CASE_LABEL
argument_list|(
name|elt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|before_case
operator|=
name|start
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|default_label
operator|=
name|label_rtx
argument_list|(
name|default_label_decl
argument_list|)
expr_stmt|;
comment|/* Get upper and lower bounds of case values.  */
name|uniq
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|label_bitmap
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|case_list
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
block|{
comment|/* Count the elements and track the largest and smallest 	     of them (treating them as signed even if they are not).  */
if|if
condition|(
name|count
operator|++
operator|==
literal|0
condition|)
block|{
name|minval
operator|=
name|n
operator|->
name|low
expr_stmt|;
name|maxval
operator|=
name|n
operator|->
name|high
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|INT_CST_LT
argument_list|(
name|n
operator|->
name|low
argument_list|,
name|minval
argument_list|)
condition|)
name|minval
operator|=
name|n
operator|->
name|low
expr_stmt|;
if|if
condition|(
name|INT_CST_LT
argument_list|(
name|maxval
argument_list|,
name|n
operator|->
name|high
argument_list|)
condition|)
name|maxval
operator|=
name|n
operator|->
name|high
expr_stmt|;
block|}
comment|/* A range counts double, since it requires two compares.  */
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|n
operator|->
name|low
argument_list|,
name|n
operator|->
name|high
argument_list|)
condition|)
name|count
operator|++
expr_stmt|;
comment|/* If we have not seen this label yet, then increase the 	     number of unique case node targets seen.  */
name|lab
operator|=
name|label_rtx
argument_list|(
name|n
operator|->
name|code_label
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|label_bitmap
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|lab
argument_list|)
argument_list|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|label_bitmap
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|lab
argument_list|)
argument_list|)
expr_stmt|;
name|uniq
operator|++
expr_stmt|;
block|}
block|}
name|BITMAP_FREE
argument_list|(
name|label_bitmap
argument_list|)
expr_stmt|;
comment|/* cleanup_tree_cfg removes all SWITCH_EXPR with a single 	 destination, such as one with a default case only.  However, 	 it doesn't remove cases that are out of range for the switch 	 type, so we may still get a zero here.  */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|emit_jump
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Compute span of values.  */
name|range
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index_type
argument_list|,
name|maxval
argument_list|,
name|minval
argument_list|)
expr_stmt|;
comment|/* Try implementing this switch statement by a short sequence of 	 bit-wise comparisons.  However, we let the binary-tree case 	 below handle constant index expressions.  */
if|if
condition|(
name|CASE_USE_BIT_TESTS
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|index_expr
argument_list|)
operator|&&
name|compare_tree_int
argument_list|(
name|range
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|word_mode
argument_list|)
argument_list|)
operator|<
literal|0
operator|&&
name|compare_tree_int
argument_list|(
name|range
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
operator|&&
name|lshift_cheap_p
argument_list|()
operator|&&
operator|(
operator|(
name|uniq
operator|==
literal|1
operator|&&
name|count
operator|>=
literal|3
operator|)
operator|||
operator|(
name|uniq
operator|==
literal|2
operator|&&
name|count
operator|>=
literal|5
operator|)
operator|||
operator|(
name|uniq
operator|==
literal|3
operator|&&
name|count
operator|>=
literal|6
operator|)
operator|)
condition|)
block|{
comment|/* Optimize the case where all the case values fit in a 	     word without having to subtract MINVAL.  In this case, 	     we can optimize away the subtraction.  */
if|if
condition|(
name|compare_tree_int
argument_list|(
name|minval
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
operator|&&
name|compare_tree_int
argument_list|(
name|maxval
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|word_mode
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|minval
operator|=
name|build_int_cst
argument_list|(
name|index_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|range
operator|=
name|maxval
expr_stmt|;
block|}
name|emit_case_bit_tests
argument_list|(
name|index_type
argument_list|,
name|index_expr
argument_list|,
name|minval
argument_list|,
name|range
argument_list|,
name|case_list
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
block|}
comment|/* If range of values is much bigger than number of values, 	 make a sequence of conditional branches instead of a dispatch. 	 If the switch-index is a constant, do it this way 	 because we can optimize it.  */
elseif|else
if|if
condition|(
name|count
operator|<
name|case_values_threshold
argument_list|()
operator|||
name|compare_tree_int
argument_list|(
name|range
argument_list|,
operator|(
name|optimize_size
condition|?
literal|3
else|:
literal|10
operator|)
operator|*
name|count
argument_list|)
operator|>
literal|0
comment|/* RANGE may be signed, and really large ranges will show up 		  as negative numbers.  */
operator|||
name|compare_tree_int
argument_list|(
name|range
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
ifndef|#
directive|ifndef
name|ASM_OUTPUT_ADDR_DIFF_ELT
operator|||
name|flag_pic
endif|#
directive|endif
operator|||
operator|!
name|flag_jump_tables
operator|||
name|TREE_CONSTANT
argument_list|(
name|index_expr
argument_list|)
comment|/* If neither casesi or tablejump is available, we can 		  only go this way.  */
operator|||
operator|(
operator|!
name|HAVE_casesi
operator|&&
operator|!
name|HAVE_tablejump
operator|)
condition|)
block|{
name|index
operator|=
name|expand_normal
argument_list|(
name|index_expr
argument_list|)
expr_stmt|;
comment|/* If the index is a short or char that we do not have 	     an insn to handle comparisons directly, convert it to 	     a full integer now, rather than letting each comparison 	     generate the conversion.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|index
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|have_insn_for
argument_list|(
name|COMPARE
argument_list|,
name|GET_MODE
argument_list|(
name|index
argument_list|)
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|wider_mode
decl_stmt|;
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE
argument_list|(
name|index
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
if|if
condition|(
name|have_insn_for
argument_list|(
name|COMPARE
argument_list|,
name|wider_mode
argument_list|)
condition|)
block|{
name|index
operator|=
name|convert_to_mode
argument_list|(
name|wider_mode
argument_list|,
name|index
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
if|if
condition|(
name|MEM_P
argument_list|(
name|index
argument_list|)
condition|)
name|index
operator|=
name|copy_to_reg
argument_list|(
name|index
argument_list|)
expr_stmt|;
comment|/* We generate a binary decision tree to select the 	     appropriate target code.  This is done as follows:  	     The list of cases is rearranged into a binary tree, 	     nearly optimal assuming equal probability for each case.  	     The tree is transformed into RTL, eliminating 	     redundant test conditions at the same time.  	     If program flow could reach the end of the 	     decision tree an unconditional jump to the 	     default code is emitted.  */
name|use_cost_table
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|orig_type
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|estimate_case_costs
argument_list|(
name|case_list
argument_list|)
operator|)
expr_stmt|;
name|balance_case_nodes
argument_list|(
operator|&
name|case_list
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|case_list
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
name|emit_jump
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|table_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|try_casesi
argument_list|(
name|index_type
argument_list|,
name|index_expr
argument_list|,
name|minval
argument_list|,
name|range
argument_list|,
name|table_label
argument_list|,
name|default_label
argument_list|)
condition|)
block|{
name|bool
name|ok
decl_stmt|;
comment|/* Index jumptables from zero for suitable values of                  minval to avoid a subtraction.  */
if|if
condition|(
operator|!
name|optimize_size
operator|&&
name|compare_tree_int
argument_list|(
name|minval
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
operator|&&
name|compare_tree_int
argument_list|(
name|minval
argument_list|,
literal|3
argument_list|)
operator|<
literal|0
condition|)
block|{
name|minval
operator|=
name|build_int_cst
argument_list|(
name|index_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|range
operator|=
name|maxval
expr_stmt|;
block|}
name|ok
operator|=
name|try_tablejump
argument_list|(
name|index_type
argument_list|,
name|index_expr
argument_list|,
name|minval
argument_list|,
name|range
argument_list|,
name|table_label
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
comment|/* Get table of labels to jump to, in order of case index.  */
name|ncases
operator|=
name|tree_low_cst
argument_list|(
name|range
argument_list|,
literal|0
argument_list|)
operator|+
literal|1
expr_stmt|;
name|labelvec
operator|=
name|alloca
argument_list|(
name|ncases
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|labelvec
argument_list|,
literal|0
argument_list|,
name|ncases
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|case_list
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
block|{
comment|/* Compute the low and high bounds relative to the minimum 		 value since that should fit in a HOST_WIDE_INT while the 		 actual values may not.  */
name|HOST_WIDE_INT
name|i_low
init|=
name|tree_low_cst
argument_list|(
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index_type
argument_list|,
name|n
operator|->
name|low
argument_list|,
name|minval
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|i_high
init|=
name|tree_low_cst
argument_list|(
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index_type
argument_list|,
name|n
operator|->
name|high
argument_list|,
name|minval
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|i_low
init|;
name|i
operator|<=
name|i_high
condition|;
name|i
operator|++
control|)
name|labelvec
index|[
name|i
index|]
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|label_rtx
argument_list|(
name|n
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Fill in the gaps with the default.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncases
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|labelvec
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|labelvec
index|[
name|i
index|]
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
comment|/* Output the table.  */
name|emit_label
argument_list|(
name|table_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|CASE_VECTOR_PC_RELATIVE
operator|||
name|flag_pic
condition|)
name|emit_jump_insn
argument_list|(
name|gen_rtx_ADDR_DIFF_VEC
argument_list|(
name|CASE_VECTOR_MODE
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|table_label
argument_list|)
argument_list|,
name|gen_rtvec_v
argument_list|(
name|ncases
argument_list|,
name|labelvec
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_jump_insn
argument_list|(
name|gen_rtx_ADDR_VEC
argument_list|(
name|CASE_VECTOR_MODE
argument_list|,
name|gen_rtvec_v
argument_list|(
name|ncases
argument_list|,
name|labelvec
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Record no drop-through after the table.  */
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
name|before_case
operator|=
name|NEXT_INSN
argument_list|(
name|before_case
argument_list|)
expr_stmt|;
name|end
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|fail
operator|=
name|squeeze_notes
argument_list|(
operator|&
name|before_case
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|fail
argument_list|)
expr_stmt|;
name|reorder_insns
argument_list|(
name|before_case
argument_list|,
name|end
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
name|free_temp_slots
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to jump to LABEL if OP0 and OP1 are equal in mode MODE.  */
end_comment

begin_function
specifier|static
name|void
name|do_jump_if_equal
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|label
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
name|do_compare_rtx_and_jump
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|EQ
argument_list|,
name|unsignedp
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Not all case values are encountered equally.  This function    uses a heuristic to weight case labels, in cases where that    looks like a reasonable thing to do.     Right now, all we try to guess is text, and we establish the    following weights:  	chars above space:	16 	digits:			16 	default:		12 	space, punct:		8 	tab:			4 	newline:		2 	other "\" chars:	1 	remaining chars:	0     If we find any cases in the switch that are not either -1 or in the range    of valid ASCII characters, or are control characters other than those    commonly used with "\", don't treat this switch scanning text.     Return 1 if these nodes are suitable for cost estimation, otherwise    return 0.  */
end_comment

begin_function
specifier|static
name|int
name|estimate_case_costs
parameter_list|(
name|case_node_ptr
name|node
parameter_list|)
block|{
name|tree
name|min_ascii
init|=
name|integer_minus_one_node
decl_stmt|;
name|tree
name|max_ascii
init|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|node
operator|->
name|high
argument_list|)
argument_list|,
literal|127
argument_list|)
decl_stmt|;
name|case_node_ptr
name|n
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If we haven't already made the cost table, make it now.  Note that the      lower bound of the table is -1, not zero.  */
if|if
condition|(
operator|!
name|cost_table_initialized
condition|)
block|{
name|cost_table_initialized
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ISALNUM
argument_list|(
name|i
argument_list|)
condition|)
name|COST_TABLE
argument_list|(
name|i
argument_list|)
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|ISPUNCT
argument_list|(
name|i
argument_list|)
condition|)
name|COST_TABLE
argument_list|(
name|i
argument_list|)
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|ISCNTRL
argument_list|(
name|i
argument_list|)
condition|)
name|COST_TABLE
argument_list|(
name|i
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|COST_TABLE
argument_list|(
literal|' '
argument_list|)
operator|=
literal|8
expr_stmt|;
name|COST_TABLE
argument_list|(
literal|'\t'
argument_list|)
operator|=
literal|4
expr_stmt|;
name|COST_TABLE
argument_list|(
literal|'\0'
argument_list|)
operator|=
literal|4
expr_stmt|;
name|COST_TABLE
argument_list|(
literal|'\n'
argument_list|)
operator|=
literal|2
expr_stmt|;
name|COST_TABLE
argument_list|(
literal|'\f'
argument_list|)
operator|=
literal|1
expr_stmt|;
name|COST_TABLE
argument_list|(
literal|'\v'
argument_list|)
operator|=
literal|1
expr_stmt|;
name|COST_TABLE
argument_list|(
literal|'\b'
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* See if all the case expressions look like text.  It is text if the      constant is>= -1 and the highest constant is<= 127.  Do all comparisons      as signed arithmetic since we don't want to ever access cost_table with a      value less than -1.  Also check that none of the constants in a range      are strange control characters.  */
for|for
control|(
name|n
operator|=
name|node
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
block|{
if|if
condition|(
operator|(
name|INT_CST_LT
argument_list|(
name|n
operator|->
name|low
argument_list|,
name|min_ascii
argument_list|)
operator|)
operator|||
name|INT_CST_LT
argument_list|(
name|max_ascii
argument_list|,
name|n
operator|->
name|high
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|low
argument_list|)
init|;
name|i
operator|<=
operator|(
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|high
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|COST_TABLE
argument_list|(
name|i
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* All interesting values are within the range of interesting      ASCII characters.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Take an ordered list of case nodes    and transform them into a near optimal binary tree,    on the assumption that any target code selection value is as    likely as any other.     The transformation is performed by splitting the ordered    list into two equal sections plus a pivot.  The parts are    then attached to the pivot as left and right branches.  Each    branch is then transformed recursively.  */
end_comment

begin_function
specifier|static
name|void
name|balance_case_nodes
parameter_list|(
name|case_node_ptr
modifier|*
name|head
parameter_list|,
name|case_node_ptr
name|parent
parameter_list|)
block|{
name|case_node_ptr
name|np
decl_stmt|;
name|np
operator|=
operator|*
name|head
expr_stmt|;
if|if
condition|(
name|np
condition|)
block|{
name|int
name|cost
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|ranges
init|=
literal|0
decl_stmt|;
name|case_node_ptr
modifier|*
name|npp
decl_stmt|;
name|case_node_ptr
name|left
decl_stmt|;
comment|/* Count the number of entries on branch.  Also count the ranges.  */
while|while
condition|(
name|np
condition|)
block|{
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|np
operator|->
name|low
argument_list|,
name|np
operator|->
name|high
argument_list|)
condition|)
block|{
name|ranges
operator|++
expr_stmt|;
if|if
condition|(
name|use_cost_table
condition|)
name|cost
operator|+=
name|COST_TABLE
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|np
operator|->
name|high
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|use_cost_table
condition|)
name|cost
operator|+=
name|COST_TABLE
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|np
operator|->
name|low
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|np
operator|=
name|np
operator|->
name|right
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|2
condition|)
block|{
comment|/* Split this list if it is long enough for that to help.  */
name|npp
operator|=
name|head
expr_stmt|;
name|left
operator|=
operator|*
name|npp
expr_stmt|;
if|if
condition|(
name|use_cost_table
condition|)
block|{
comment|/* Find the place in the list that bisects the list's total cost, 		 Here I gets half the total cost.  */
name|int
name|n_moved
init|=
literal|0
decl_stmt|;
name|i
operator|=
operator|(
name|cost
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Skip nodes while their cost does not reach that amount.  */
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
operator|(
operator|*
name|npp
operator|)
operator|->
name|low
argument_list|,
operator|(
operator|*
name|npp
operator|)
operator|->
name|high
argument_list|)
condition|)
name|i
operator|-=
name|COST_TABLE
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
operator|(
operator|*
name|npp
operator|)
operator|->
name|high
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|-=
name|COST_TABLE
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
operator|(
operator|*
name|npp
operator|)
operator|->
name|low
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
break|break;
name|npp
operator|=
operator|&
operator|(
operator|*
name|npp
operator|)
operator|->
name|right
expr_stmt|;
name|n_moved
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|n_moved
operator|==
literal|0
condition|)
block|{
comment|/* Leave this branch lopsided, but optimize left-hand 		     side and fill in `parent' fields for right-hand side.  */
name|np
operator|=
operator|*
name|head
expr_stmt|;
name|np
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|balance_case_nodes
argument_list|(
operator|&
name|np
operator|->
name|left
argument_list|,
name|np
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|np
operator|->
name|right
condition|;
name|np
operator|=
name|np
operator|->
name|right
control|)
name|np
operator|->
name|right
operator|->
name|parent
operator|=
name|np
expr_stmt|;
return|return;
block|}
block|}
comment|/* If there are just three nodes, split at the middle one.  */
elseif|else
if|if
condition|(
name|i
operator|==
literal|3
condition|)
name|npp
operator|=
operator|&
operator|(
operator|*
name|npp
operator|)
operator|->
name|right
expr_stmt|;
else|else
block|{
comment|/* Find the place in the list that bisects the list's total cost, 		 where ranges count as 2. 		 Here I gets half the total cost.  */
name|i
operator|=
operator|(
name|i
operator|+
name|ranges
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Skip nodes while their cost does not reach that amount.  */
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
operator|(
operator|*
name|npp
operator|)
operator|->
name|low
argument_list|,
operator|(
operator|*
name|npp
operator|)
operator|->
name|high
argument_list|)
condition|)
name|i
operator|--
expr_stmt|;
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
break|break;
name|npp
operator|=
operator|&
operator|(
operator|*
name|npp
operator|)
operator|->
name|right
expr_stmt|;
block|}
block|}
operator|*
name|head
operator|=
name|np
operator|=
operator|*
name|npp
expr_stmt|;
operator|*
name|npp
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|np
operator|->
name|left
operator|=
name|left
expr_stmt|;
comment|/* Optimize each of the two split parts.  */
name|balance_case_nodes
argument_list|(
operator|&
name|np
operator|->
name|left
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|balance_case_nodes
argument_list|(
operator|&
name|np
operator|->
name|right
argument_list|,
name|np
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Else leave this branch as one level, 	     but fill in `parent' fields.  */
name|np
operator|=
operator|*
name|head
expr_stmt|;
name|np
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
for|for
control|(
init|;
name|np
operator|->
name|right
condition|;
name|np
operator|=
name|np
operator|->
name|right
control|)
name|np
operator|->
name|right
operator|->
name|parent
operator|=
name|np
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Search the parent sections of the case node tree    to see if a test for the lower bound of NODE would be redundant.    INDEX_TYPE is the type of the index expression.     The instructions to generate the case decision tree are    output in the same order as nodes are processed so it is    known that if a parent node checks the range of the current    node minus one that the current node is bounded at its lower    span.  Thus the test would be redundant.  */
end_comment

begin_function
specifier|static
name|int
name|node_has_low_bound
parameter_list|(
name|case_node_ptr
name|node
parameter_list|,
name|tree
name|index_type
parameter_list|)
block|{
name|tree
name|low_minus_one
decl_stmt|;
name|case_node_ptr
name|pnode
decl_stmt|;
comment|/* If the lower bound of this node is the lowest value in the index type,      we need not test it.  */
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|node
operator|->
name|low
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|index_type
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If this node has a left branch, the value at the left must be less      than that at this node, so it cannot be bounded at the bottom and      we need not bother testing any further.  */
if|if
condition|(
name|node
operator|->
name|left
condition|)
return|return
literal|0
return|;
name|low_minus_one
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|node
operator|->
name|low
argument_list|)
argument_list|,
name|node
operator|->
name|low
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|node
operator|->
name|low
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the subtraction above overflowed, we can't verify anything.      Otherwise, look for a parent that tests our value - 1.  */
if|if
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|low_minus_one
argument_list|,
name|node
operator|->
name|low
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|pnode
operator|=
name|node
operator|->
name|parent
init|;
name|pnode
condition|;
name|pnode
operator|=
name|pnode
operator|->
name|parent
control|)
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|low_minus_one
argument_list|,
name|pnode
operator|->
name|high
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Search the parent sections of the case node tree    to see if a test for the upper bound of NODE would be redundant.    INDEX_TYPE is the type of the index expression.     The instructions to generate the case decision tree are    output in the same order as nodes are processed so it is    known that if a parent node checks the range of the current    node plus one that the current node is bounded at its upper    span.  Thus the test would be redundant.  */
end_comment

begin_function
specifier|static
name|int
name|node_has_high_bound
parameter_list|(
name|case_node_ptr
name|node
parameter_list|,
name|tree
name|index_type
parameter_list|)
block|{
name|tree
name|high_plus_one
decl_stmt|;
name|case_node_ptr
name|pnode
decl_stmt|;
comment|/* If there is no upper bound, obviously no test is needed.  */
if|if
condition|(
name|TYPE_MAX_VALUE
argument_list|(
name|index_type
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* If the upper bound of this node is the highest value in the type      of the index expression, we need not test against it.  */
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|index_type
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If this node has a right branch, the value at the right must be greater      than that at this node, so it cannot be bounded at the top and      we need not bother testing any further.  */
if|if
condition|(
name|node
operator|->
name|right
condition|)
return|return
literal|0
return|;
name|high_plus_one
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|node
operator|->
name|high
argument_list|)
argument_list|,
name|node
operator|->
name|high
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|node
operator|->
name|high
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the addition above overflowed, we can't verify anything.      Otherwise, look for a parent that tests our value + 1.  */
if|if
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|high_plus_one
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|pnode
operator|=
name|node
operator|->
name|parent
init|;
name|pnode
condition|;
name|pnode
operator|=
name|pnode
operator|->
name|parent
control|)
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|high_plus_one
argument_list|,
name|pnode
operator|->
name|low
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Search the parent sections of the    case node tree to see if both tests for the upper and lower    bounds of NODE would be redundant.  */
end_comment

begin_function
specifier|static
name|int
name|node_is_bounded
parameter_list|(
name|case_node_ptr
name|node
parameter_list|,
name|tree
name|index_type
parameter_list|)
block|{
return|return
operator|(
name|node_has_low_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
operator|&&
name|node_has_high_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit step-by-step code to select a case for the value of INDEX.    The thus generated decision tree follows the form of the    case-node binary tree NODE, whose nodes represent test conditions.    INDEX_TYPE is the type of the index of the switch.     Care is taken to prune redundant tests from the decision tree    by detecting any boundary conditions already checked by    emitted rtx.  (See node_has_high_bound, node_has_low_bound    and node_is_bounded, above.)     Where the test conditions can be shown to be redundant we emit    an unconditional jump to the target code.  As a further    optimization, the subordinates of a tree node are examined to    check for bounded nodes.  In this case conditional and/or    unconditional jumps as a result of the boundary check for the    current node are arranged to target the subordinates associated    code for out of bound conditions on the current node.     We can assume that when control reaches the code generated here,    the index value has already been compared with the parents    of this node, and determined to be on the same side of each parent    as this node is.  Thus, if this node tests for the value 51,    and a parent tested for 52, we don't need to consider    the possibility of a value greater than 51.  If another parent    tests for the value 50, then this node need not test anything.  */
end_comment

begin_function
specifier|static
name|void
name|emit_case_nodes
parameter_list|(
name|rtx
name|index
parameter_list|,
name|case_node_ptr
name|node
parameter_list|,
name|rtx
name|default_label
parameter_list|,
name|tree
name|index_type
parameter_list|)
block|{
comment|/* If INDEX has an unsigned type, we must make unsigned branches.  */
name|int
name|unsignedp
init|=
name|TYPE_UNSIGNED
argument_list|(
name|index_type
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|imode
init|=
name|TYPE_MODE
argument_list|(
name|index_type
argument_list|)
decl_stmt|;
comment|/* Handle indices detected as constant during RTL expansion.  */
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|imode
expr_stmt|;
comment|/* See if our parents have already tested everything for us.      If they have, emit an unconditional jump for this node.  */
if|if
condition|(
name|node_is_bounded
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
condition|)
name|emit_jump
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|node
operator|->
name|low
argument_list|,
name|node
operator|->
name|high
argument_list|)
condition|)
block|{
comment|/* Node is single valued.  First see if the index expression matches 	 this node and then check our children, if any.  */
name|do_jump_if_equal
argument_list|(
name|mode
argument_list|,
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_normal
argument_list|(
name|node
operator|->
name|low
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|right
operator|!=
literal|0
operator|&&
name|node
operator|->
name|left
operator|!=
literal|0
condition|)
block|{
comment|/* This node has children on both sides. 	     Dispatch to one side or the other 	     by comparing the index value with this node's value. 	     If one subtree is bounded, check that one first, 	     so we can avoid real branches in the tree.  */
if|if
condition|(
name|node_is_bounded
argument_list|(
name|node
operator|->
name|right
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_normal
argument_list|(
name|node
operator|->
name|high
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|right
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|left
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node_is_bounded
argument_list|(
name|node
operator|->
name|left
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_normal
argument_list|(
name|node
operator|->
name|high
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|LT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|left
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|right
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
comment|/* If both children are single-valued cases with no 	     children, finish up all the work.  This way, we can save 	     one ordered comparison.  */
elseif|else
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|node
operator|->
name|right
operator|->
name|low
argument_list|,
name|node
operator|->
name|right
operator|->
name|high
argument_list|)
operator|&&
name|node
operator|->
name|right
operator|->
name|left
operator|==
literal|0
operator|&&
name|node
operator|->
name|right
operator|->
name|right
operator|==
literal|0
operator|&&
name|tree_int_cst_equal
argument_list|(
name|node
operator|->
name|left
operator|->
name|low
argument_list|,
name|node
operator|->
name|left
operator|->
name|high
argument_list|)
operator|&&
name|node
operator|->
name|left
operator|->
name|left
operator|==
literal|0
operator|&&
name|node
operator|->
name|left
operator|->
name|right
operator|==
literal|0
condition|)
block|{
comment|/* Neither node is bounded.  First distinguish the two sides; 		 then emit the code for one side at a time.  */
comment|/* See if the value matches what the right hand side 		 wants.  */
name|do_jump_if_equal
argument_list|(
name|mode
argument_list|,
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_normal
argument_list|(
name|node
operator|->
name|right
operator|->
name|low
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|right
operator|->
name|code_label
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* See if the value matches what the left hand side 		 wants.  */
name|do_jump_if_equal
argument_list|(
name|mode
argument_list|,
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_normal
argument_list|(
name|node
operator|->
name|left
operator|->
name|low
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|left
operator|->
name|code_label
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Neither node is bounded.  First distinguish the two sides; 		 then emit the code for one side at a time.  */
name|tree
name|test_label
init|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
comment|/* See if the value is on the right.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_normal
argument_list|(
name|node
operator|->
name|high
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|label_rtx
argument_list|(
name|test_label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Value must be on the left. 		 Handle the left-hand subtree.  */
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|left
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
comment|/* If left-hand subtree does nothing, 		 go to default.  */
name|emit_jump
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
comment|/* Code branches here for the right-hand subtree.  */
name|expand_label
argument_list|(
name|test_label
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|right
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|right
operator|!=
literal|0
operator|&&
name|node
operator|->
name|left
operator|==
literal|0
condition|)
block|{
comment|/* Here we have a right child but no left so we issue a conditional 	     branch to default and process the right child.  	     Omit the conditional branch to default if the right child 	     does not have any children and is single valued; it would 	     cost too much space to save so little time.  */
if|if
condition|(
name|node
operator|->
name|right
operator|->
name|right
operator|||
name|node
operator|->
name|right
operator|->
name|left
operator|||
operator|!
name|tree_int_cst_equal
argument_list|(
name|node
operator|->
name|right
operator|->
name|low
argument_list|,
name|node
operator|->
name|right
operator|->
name|high
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|node_has_low_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_normal
argument_list|(
name|node
operator|->
name|high
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|LT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
block|}
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|right
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We cannot process node->right normally 	       since we haven't ruled out the numbers less than 	       this node's value.  So handle node->right explicitly.  */
name|do_jump_if_equal
argument_list|(
name|mode
argument_list|,
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_normal
argument_list|(
name|node
operator|->
name|right
operator|->
name|low
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|right
operator|->
name|code_label
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|right
operator|==
literal|0
operator|&&
name|node
operator|->
name|left
operator|!=
literal|0
condition|)
block|{
comment|/* Just one subtree, on the left.  */
if|if
condition|(
name|node
operator|->
name|left
operator|->
name|left
operator|||
name|node
operator|->
name|left
operator|->
name|right
operator|||
operator|!
name|tree_int_cst_equal
argument_list|(
name|node
operator|->
name|left
operator|->
name|low
argument_list|,
name|node
operator|->
name|left
operator|->
name|high
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|node_has_high_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_normal
argument_list|(
name|node
operator|->
name|high
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
block|}
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|left
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We cannot process node->left normally 	       since we haven't ruled out the numbers less than 	       this node's value.  So handle node->left explicitly.  */
name|do_jump_if_equal
argument_list|(
name|mode
argument_list|,
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_normal
argument_list|(
name|node
operator|->
name|left
operator|->
name|low
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|left
operator|->
name|code_label
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Node is a range.  These cases are very similar to those for a single 	 value, except that we do not start by testing whether this node 	 is the one to branch to.  */
if|if
condition|(
name|node
operator|->
name|right
operator|!=
literal|0
operator|&&
name|node
operator|->
name|left
operator|!=
literal|0
condition|)
block|{
comment|/* Node has subtrees on both sides. 	     If the right-hand subtree is bounded, 	     test for it first, since we can go straight there. 	     Otherwise, we need to make a branch in the control structure, 	     then handle the two subtrees.  */
name|tree
name|test_label
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|node_is_bounded
argument_list|(
name|node
operator|->
name|right
argument_list|,
name|index_type
argument_list|)
condition|)
comment|/* Right hand node is fully bounded so we can eliminate any 	       testing and branch directly to the target code.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_normal
argument_list|(
name|node
operator|->
name|high
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|right
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Right hand node requires testing. 		 Branch to a label where we will handle it later.  */
name|test_label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_normal
argument_list|(
name|node
operator|->
name|high
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|label_rtx
argument_list|(
name|test_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Value belongs to this node or to the left-hand subtree.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_normal
argument_list|(
name|node
operator|->
name|low
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|GE
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle the left-hand subtree.  */
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|left
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
comment|/* If right node had to be handled later, do that now.  */
if|if
condition|(
name|test_label
condition|)
block|{
comment|/* If the left-hand subtree fell through, 		 don't let it fall into the right-hand subtree.  */
name|emit_jump
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
name|expand_label
argument_list|(
name|test_label
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|right
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|right
operator|!=
literal|0
operator|&&
name|node
operator|->
name|left
operator|==
literal|0
condition|)
block|{
comment|/* Deal with values to the left of this node, 	     if they are possible.  */
if|if
condition|(
operator|!
name|node_has_low_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_normal
argument_list|(
name|node
operator|->
name|low
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|LT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
block|}
comment|/* Value belongs to this node or to the right-hand subtree.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_normal
argument_list|(
name|node
operator|->
name|high
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|LE
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|right
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|right
operator|==
literal|0
operator|&&
name|node
operator|->
name|left
operator|!=
literal|0
condition|)
block|{
comment|/* Deal with values to the right of this node, 	     if they are possible.  */
if|if
condition|(
operator|!
name|node_has_high_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_normal
argument_list|(
name|node
operator|->
name|high
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
block|}
comment|/* Value belongs to this node or to the left-hand subtree.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_normal
argument_list|(
name|node
operator|->
name|low
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|GE
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|left
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Node has no children so we check low and high bounds to remove 	     redundant tests.  Only one of the bounds can exist, 	     since otherwise this node is bounded--a case tested already.  */
name|int
name|high_bound
init|=
name|node_has_high_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
decl_stmt|;
name|int
name|low_bound
init|=
name|node_has_low_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|high_bound
operator|&&
name|low_bound
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_normal
argument_list|(
name|node
operator|->
name|high
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|low_bound
operator|&&
name|high_bound
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_normal
argument_list|(
name|node
operator|->
name|low
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|LT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|low_bound
operator|&&
operator|!
name|high_bound
condition|)
block|{
comment|/* Widen LOW and HIGH to the same width as INDEX.  */
name|tree
name|type
init|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|mode
argument_list|,
name|unsignedp
argument_list|)
decl_stmt|;
name|tree
name|low
init|=
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|node
operator|->
name|low
argument_list|)
decl_stmt|;
name|tree
name|high
init|=
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|node
operator|->
name|high
argument_list|)
decl_stmt|;
name|rtx
name|low_rtx
decl_stmt|,
name|new_index
decl_stmt|,
name|new_bound
decl_stmt|;
comment|/* Instead of doing two branches, emit one unsigned branch for 		 (index-low)> (high-low).  */
name|low_rtx
operator|=
name|expand_expr
argument_list|(
name|low
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|new_index
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|MINUS
argument_list|,
name|index
argument_list|,
name|low_rtx
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|new_bound
operator|=
name|expand_expr
argument_list|(
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|high
argument_list|,
name|low
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|new_index
argument_list|,
name|new_bound
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
block|}
name|emit_jump
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

