begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Expands front end tree to back end RTL for GNU C-Compiler    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,    1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file handles the generation of rtl code from tree structure    above the level of expressions, using subroutines in exp*.c and emit-rtl.c.    It also creates the rtl expressions for parameters and auto variables    and has full responsibility for allocating stack slots.     The functions whose names start with `expand_' are called by the    parser to generate RTL instructions for various kinds of constructs.     Some control and binding constructs require calling several such    functions at different times.  For example, a simple if-then    is expanded by calling `expand_start_cond' (with the condition-expression    as argument) before parsing the then-clause and calling `expand_end_cond'    after parsing the then-clause.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"libfuncs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"loop.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"machmode.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
name|struct
name|obstack
name|stmt_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Assume that case vectors are not pc-relative.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CASE_VECTOR_PC_RELATIVE
end_ifndef

begin_define
define|#
directive|define
name|CASE_VECTOR_PC_RELATIVE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Functions and data structures for expanding case statements.  */
end_comment

begin_comment
comment|/* Case label structure, used to hold info on labels within case    statements.  We handle "range" labels; for a single-value label    as in C, the high and low limits are the same.     An AVL tree of case nodes is initially created, and later transformed    to a list linked via the RIGHT fields in the nodes.  Nodes with    higher case values are later in the list.     Switch statements can be output in one of two forms.  A branch table    is used if there are more than a few labels and the labels are dense    within the range between the smallest and largest case value.  If a    branch table is used, no further manipulations are done with the case    node chain.     The alternative to the use of a branch table is to generate a series    of compare and jump insns.  When that is done, we use the LEFT, RIGHT,    and PARENT fields to hold a binary tree.  Initially the tree is    totally unbalanced, with everything on the right.  We balance the tree    with nodes on the left having lower case values than the parent    and nodes on the right having higher values.  We then output the tree    in order.  */
end_comment

begin_struct
struct|struct
name|case_node
block|{
name|struct
name|case_node
modifier|*
name|left
decl_stmt|;
comment|/* Left son in binary tree */
name|struct
name|case_node
modifier|*
name|right
decl_stmt|;
comment|/* Right son in binary tree; also node chain */
name|struct
name|case_node
modifier|*
name|parent
decl_stmt|;
comment|/* Parent of node in binary tree */
name|tree
name|low
decl_stmt|;
comment|/* Lowest index value for this label */
name|tree
name|high
decl_stmt|;
comment|/* Highest index value for this label */
name|tree
name|code_label
decl_stmt|;
comment|/* Label to jump to when node matches */
name|int
name|balance
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|case_node
name|case_node
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|case_node
modifier|*
name|case_node_ptr
typedef|;
end_typedef

begin_comment
comment|/* These are used by estimate_case_costs and balance_case_nodes.  */
end_comment

begin_comment
comment|/* This must be a signed type, and non-ANSI compilers lack signed char.  */
end_comment

begin_decl_stmt
specifier|static
name|short
name|cost_table_
index|[
literal|129
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|use_cost_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cost_table_initialized
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Special care is needed because we allow -1, but TREE_INT_CST_LOW    is unsigned.  */
end_comment

begin_define
define|#
directive|define
name|COST_TABLE
parameter_list|(
name|I
parameter_list|)
value|cost_table_[(unsigned HOST_WIDE_INT) ((I) + 1)]
end_define

begin_escape
end_escape

begin_comment
comment|/* Stack of control and binding constructs we are currently inside.     These constructs begin when you call `expand_start_WHATEVER'    and end when you call `expand_end_WHATEVER'.  This stack records    info about how the construct began that tells the end-function    what to do.  It also may provide information about the construct    to alter the behavior of other constructs within the body.    For example, they may affect the behavior of C `break' and `continue'.     Each construct gets one `struct nesting' object.    All of these objects are chained through the `all' field.    `nesting_stack' points to the first object (innermost construct).    The position of an entry on `nesting_stack' is in its `depth' field.     Each type of construct has its own individual stack.    For example, loops have `loop_stack'.  Each object points to the    next object of the same type through the `next' field.     Some constructs are visible to `break' exit-statements and others    are not.  Which constructs are visible depends on the language.    Therefore, the data structure allows each construct to be visible    or not, according to the args given when the construct is started.    The construct is visible if the `exit_label' field is non-null.    In that case, the value should be a CODE_LABEL rtx.  */
end_comment

begin_struct
struct|struct
name|nesting
block|{
name|struct
name|nesting
modifier|*
name|all
decl_stmt|;
name|struct
name|nesting
modifier|*
name|next
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|rtx
name|exit_label
decl_stmt|;
union|union
block|{
comment|/* For conds (if-then and if-then-else statements).  */
struct|struct
block|{
comment|/* Label for the end of the if construct. 	     There is none if EXITFLAG was not set 	     and no `else' has been seen yet.  */
name|rtx
name|endif_label
decl_stmt|;
comment|/* Label for the end of this alternative. 	     This may be the end of the if or the next else/elseif.  */
name|rtx
name|next_label
decl_stmt|;
block|}
name|cond
struct|;
comment|/* For loops.  */
struct|struct
block|{
comment|/* Label at the top of the loop; place to loop back to.  */
name|rtx
name|start_label
decl_stmt|;
comment|/* Label at the end of the whole construct.  */
name|rtx
name|end_label
decl_stmt|;
comment|/* Label before a jump that branches to the end of the whole 	     construct.  This is where destructors go if any.  */
name|rtx
name|alt_end_label
decl_stmt|;
comment|/* Label for `continue' statement to jump to; 	     this is in front of the stepper of the loop.  */
name|rtx
name|continue_label
decl_stmt|;
block|}
name|loop
struct|;
comment|/* For variable binding contours.  */
struct|struct
block|{
comment|/* Sequence number of this binding contour within the function, 	     in order of entry.  */
name|int
name|block_start_count
decl_stmt|;
comment|/* Nonzero => value to restore stack to on exit.  */
name|rtx
name|stack_level
decl_stmt|;
comment|/* The NOTE that starts this contour. 	     Used by expand_goto to check whether the destination 	     is within each contour or not.  */
name|rtx
name|first_insn
decl_stmt|;
comment|/* Innermost containing binding contour that has a stack level.  */
name|struct
name|nesting
modifier|*
name|innermost_stack_block
decl_stmt|;
comment|/* List of cleanups to be run on exit from this contour. 	     This is a list of expressions to be evaluated. 	     The TREE_PURPOSE of each link is the ..._DECL node 	     which the cleanup pertains to.  */
name|tree
name|cleanups
decl_stmt|;
comment|/* List of cleanup-lists of blocks containing this block, 	     as they were at the locus where this block appears. 	     There is an element for each containing block, 	     ordered innermost containing block first. 	     The tail of this list can be 0, 	     if all remaining elements would be empty lists. 	     The element's TREE_VALUE is the cleanup-list of that block, 	     which may be null.  */
name|tree
name|outer_cleanups
decl_stmt|;
comment|/* Chain of labels defined inside this binding contour. 	     For contours that have stack levels or cleanups.  */
name|struct
name|label_chain
modifier|*
name|label_chain
decl_stmt|;
comment|/* Number of function calls seen, as of start of this block.  */
name|int
name|n_function_calls
decl_stmt|;
comment|/* Nonzero if this is associated with a EH region.  */
name|int
name|exception_region
decl_stmt|;
comment|/* The saved target_temp_slot_level from our outer block. 	     We may reset target_temp_slot_level to be the level of 	     this block, if that is done, target_temp_slot_level 	     reverts to the saved target_temp_slot_level at the very 	     end of the block.  */
name|int
name|block_target_temp_slot_level
decl_stmt|;
comment|/* True if we are currently emitting insns in an area of 	     output code that is controlled by a conditional 	     expression.  This is used by the cleanup handling code to 	     generate conditional cleanup actions.  */
name|int
name|conditional_code
decl_stmt|;
comment|/* A place to move the start of the exception region for any 	     of the conditional cleanups, must be at the end or after 	     the start of the last unconditional cleanup, and before any 	     conditional branch points.  */
name|rtx
name|last_unconditional_cleanup
decl_stmt|;
comment|/* When in a conditional context, this is the specific 	     cleanup list associated with last_unconditional_cleanup, 	     where we place the conditionalized cleanups.  */
name|tree
modifier|*
name|cleanup_ptr
decl_stmt|;
block|}
name|block
struct|;
comment|/* For switch (C) or case (Pascal) statements, 	 and also for dummies (see `expand_start_case_dummy').  */
struct|struct
block|{
comment|/* The insn after which the case dispatch should finally 	     be emitted.  Zero for a dummy.  */
name|rtx
name|start
decl_stmt|;
comment|/* A list of case labels; it is first built as an AVL tree. 	     During expand_end_case, this is converted to a list, and may be 	     rearranged into a nearly balanced binary tree.  */
name|struct
name|case_node
modifier|*
name|case_list
decl_stmt|;
comment|/* Label to jump to if no case matches.  */
name|tree
name|default_label
decl_stmt|;
comment|/* The expression to be dispatched on.  */
name|tree
name|index_expr
decl_stmt|;
comment|/* Type that INDEX_EXPR should be converted to.  */
name|tree
name|nominal_type
decl_stmt|;
comment|/* Name of this kind of statement, for warnings.  */
specifier|const
name|char
modifier|*
name|printname
decl_stmt|;
comment|/* Used to save no_line_numbers till we see the first case label. 	     We set this to -1 when we see the first case label in this 	     case statement.  */
name|int
name|line_number_status
decl_stmt|;
block|}
name|case_stmt
struct|;
block|}
name|data
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Allocate and return a new `struct nesting'.  */
end_comment

begin_define
define|#
directive|define
name|ALLOC_NESTING
parameter_list|()
define|\
value|(struct nesting *) obstack_alloc (&stmt_obstack, sizeof (struct nesting))
end_define

begin_comment
comment|/* Pop the nesting stack element by element until we pop off    the element which is at the top of STACK.    Update all the other stacks, popping off elements from them    as we pop them from nesting_stack.  */
end_comment

begin_define
define|#
directive|define
name|POPSTACK
parameter_list|(
name|STACK
parameter_list|)
define|\
value|do { struct nesting *target = STACK;			\      struct nesting *this;				\      do { this = nesting_stack;				\ 	  if (loop_stack == this)			\ 	    loop_stack = loop_stack->next;		\ 	  if (cond_stack == this)			\ 	    cond_stack = cond_stack->next;		\ 	  if (block_stack == this)			\ 	    block_stack = block_stack->next;		\ 	  if (stack_block_stack == this)		\ 	    stack_block_stack = stack_block_stack->next; \ 	  if (case_stack == this)			\ 	    case_stack = case_stack->next;		\ 	  nesting_depth = nesting_stack->depth - 1;	\ 	  nesting_stack = this->all;			\ 	  obstack_free (&stmt_obstack, this); }		\      while (this != target); } while (0)
end_define

begin_escape
end_escape

begin_comment
comment|/* In some cases it is impossible to generate code for a forward goto    until the label definition is seen.  This happens when it may be necessary    for the goto to reset the stack pointer: we don't yet know how to do that.    So expand_goto puts an entry on this fixup list.    Each time a binding contour that resets the stack is exited,    we check each fixup.    If the target label has now been defined, we can insert the proper code.  */
end_comment

begin_struct
struct|struct
name|goto_fixup
block|{
comment|/* Points to following fixup.  */
name|struct
name|goto_fixup
modifier|*
name|next
decl_stmt|;
comment|/* Points to the insn before the jump insn.      If more code must be inserted, it goes after this insn.  */
name|rtx
name|before_jump
decl_stmt|;
comment|/* The LABEL_DECL that this jump is jumping to, or 0      for break, continue or return.  */
name|tree
name|target
decl_stmt|;
comment|/* The BLOCK for the place where this goto was found.  */
name|tree
name|context
decl_stmt|;
comment|/* The CODE_LABEL rtx that this is jumping to.  */
name|rtx
name|target_rtl
decl_stmt|;
comment|/* Number of binding contours started in current function      before the label reference.  */
name|int
name|block_start_count
decl_stmt|;
comment|/* The outermost stack level that should be restored for this jump.      Each time a binding contour that resets the stack is exited,      if the target label is *not* yet defined, this slot is updated.  */
name|rtx
name|stack_level
decl_stmt|;
comment|/* List of lists of cleanup expressions to be run by this goto.      There is one element for each block that this goto is within.      The tail of this list can be 0,      if all remaining elements would be empty.      The TREE_VALUE contains the cleanup list of that block as of the      time this goto was seen.      The TREE_ADDRESSABLE flag is 1 for a block that has been exited.  */
name|tree
name|cleanup_list_list
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Within any binding contour that must restore a stack level,    all labels are recorded with a chain of these structures.  */
end_comment

begin_struct
struct|struct
name|label_chain
block|{
comment|/* Points to following fixup.  */
name|struct
name|label_chain
modifier|*
name|next
decl_stmt|;
name|tree
name|label
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|stmt_status
block|{
comment|/* Chain of all pending binding contours.  */
name|struct
name|nesting
modifier|*
name|x_block_stack
decl_stmt|;
comment|/* If any new stacks are added here, add them to POPSTACKS too.  */
comment|/* Chain of all pending binding contours that restore stack levels      or have cleanups.  */
name|struct
name|nesting
modifier|*
name|x_stack_block_stack
decl_stmt|;
comment|/* Chain of all pending conditional statements.  */
name|struct
name|nesting
modifier|*
name|x_cond_stack
decl_stmt|;
comment|/* Chain of all pending loops.  */
name|struct
name|nesting
modifier|*
name|x_loop_stack
decl_stmt|;
comment|/* Chain of all pending case or switch statements.  */
name|struct
name|nesting
modifier|*
name|x_case_stack
decl_stmt|;
comment|/* Separate chain including all of the above,      chained through the `all' field.  */
name|struct
name|nesting
modifier|*
name|x_nesting_stack
decl_stmt|;
comment|/* Number of entries on nesting_stack now.  */
name|int
name|x_nesting_depth
decl_stmt|;
comment|/* Number of binding contours started so far in this function.  */
name|int
name|x_block_start_count
decl_stmt|;
comment|/* Each time we expand an expression-statement,      record the expr's type and its RTL value here.  */
name|tree
name|x_last_expr_type
decl_stmt|;
name|rtx
name|x_last_expr_value
decl_stmt|;
comment|/* Nonzero if within a ({...}) grouping, in which case we must      always compute a value for each expr-stmt in case it is the last one.  */
name|int
name|x_expr_stmts_for_value
decl_stmt|;
comment|/* Filename and line number of last line-number note,      whether we actually emitted it or not.  */
specifier|const
name|char
modifier|*
name|x_emit_filename
decl_stmt|;
name|int
name|x_emit_lineno
decl_stmt|;
name|struct
name|goto_fixup
modifier|*
name|x_goto_fixup_chain
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|block_stack
value|(cfun->stmt->x_block_stack)
end_define

begin_define
define|#
directive|define
name|stack_block_stack
value|(cfun->stmt->x_stack_block_stack)
end_define

begin_define
define|#
directive|define
name|cond_stack
value|(cfun->stmt->x_cond_stack)
end_define

begin_define
define|#
directive|define
name|loop_stack
value|(cfun->stmt->x_loop_stack)
end_define

begin_define
define|#
directive|define
name|case_stack
value|(cfun->stmt->x_case_stack)
end_define

begin_define
define|#
directive|define
name|nesting_stack
value|(cfun->stmt->x_nesting_stack)
end_define

begin_define
define|#
directive|define
name|nesting_depth
value|(cfun->stmt->x_nesting_depth)
end_define

begin_define
define|#
directive|define
name|current_block_start_count
value|(cfun->stmt->x_block_start_count)
end_define

begin_define
define|#
directive|define
name|last_expr_type
value|(cfun->stmt->x_last_expr_type)
end_define

begin_define
define|#
directive|define
name|last_expr_value
value|(cfun->stmt->x_last_expr_value)
end_define

begin_define
define|#
directive|define
name|expr_stmts_for_value
value|(cfun->stmt->x_expr_stmts_for_value)
end_define

begin_define
define|#
directive|define
name|emit_filename
value|(cfun->stmt->x_emit_filename)
end_define

begin_define
define|#
directive|define
name|emit_lineno
value|(cfun->stmt->x_emit_lineno)
end_define

begin_define
define|#
directive|define
name|goto_fixup_chain
value|(cfun->stmt->x_goto_fixup_chain)
end_define

begin_comment
comment|/* Non-zero if we are using EH to handle cleanus.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|using_eh_for_cleanups_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_occurrences
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|parse_input_constraint
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|,
name|bool
operator|*
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_goto_internal
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|expand_fixup
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_nl_handler_label
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_nl_goto_receiver
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_nl_goto_receivers
name|PARAMS
argument_list|(
operator|(
expr|struct
name|nesting
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_gotos
name|PARAMS
argument_list|(
operator|(
expr|struct
name|nesting
operator|*
operator|,
name|rtx
operator|,
name|tree
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|check_operand_nalternatives
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|check_unique_operand_names
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|resolve_operand_names
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
specifier|const
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|resolve_operand_name_1
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_null_return_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_value_return
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tail_recursion_args
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_cleanups
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_seenlabel
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_jump_if_equal
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|estimate_case_costs
name|PARAMS
argument_list|(
operator|(
name|case_node_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|group_case_nodes
name|PARAMS
argument_list|(
operator|(
name|case_node_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|balance_case_nodes
name|PARAMS
argument_list|(
operator|(
name|case_node_ptr
operator|*
operator|,
name|case_node_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|node_has_low_bound
name|PARAMS
argument_list|(
operator|(
name|case_node_ptr
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|node_has_high_bound
name|PARAMS
argument_list|(
operator|(
name|case_node_ptr
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|node_is_bounded
name|PARAMS
argument_list|(
operator|(
name|case_node_ptr
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_jump_if_reachable
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_case_nodes
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|case_node_ptr
operator|,
name|rtx
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|case_node
modifier|*
name|case_tree2list
name|PARAMS
argument_list|(
operator|(
name|case_node
operator|*
operator|,
name|case_node
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_cond_nesting
name|PARAMS
argument_list|(
operator|(
expr|struct
name|nesting
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_loop_nesting
name|PARAMS
argument_list|(
operator|(
expr|struct
name|nesting
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_block_nesting
name|PARAMS
argument_list|(
operator|(
expr|struct
name|nesting
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_case_nesting
name|PARAMS
argument_list|(
operator|(
expr|struct
name|nesting
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_case_node
name|PARAMS
argument_list|(
operator|(
expr|struct
name|case_node
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_goto_fixup
name|PARAMS
argument_list|(
operator|(
expr|struct
name|goto_fixup
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_case_nodes
name|PARAMS
argument_list|(
operator|(
name|case_node_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|using_eh_for_cleanups
parameter_list|()
block|{
name|using_eh_for_cleanups_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark N (known to be a cond-nesting) for GC.  */
end_comment

begin_function
specifier|static
name|void
name|mark_cond_nesting
parameter_list|(
name|n
parameter_list|)
name|struct
name|nesting
modifier|*
name|n
decl_stmt|;
block|{
while|while
condition|(
name|n
condition|)
block|{
name|ggc_mark_rtx
argument_list|(
name|n
operator|->
name|exit_label
argument_list|)
expr_stmt|;
name|ggc_mark_rtx
argument_list|(
name|n
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
argument_list|)
expr_stmt|;
name|ggc_mark_rtx
argument_list|(
name|n
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
argument_list|)
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark N (known to be a loop-nesting) for GC.  */
end_comment

begin_function
specifier|static
name|void
name|mark_loop_nesting
parameter_list|(
name|n
parameter_list|)
name|struct
name|nesting
modifier|*
name|n
decl_stmt|;
block|{
while|while
condition|(
name|n
condition|)
block|{
name|ggc_mark_rtx
argument_list|(
name|n
operator|->
name|exit_label
argument_list|)
expr_stmt|;
name|ggc_mark_rtx
argument_list|(
name|n
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
argument_list|)
expr_stmt|;
name|ggc_mark_rtx
argument_list|(
name|n
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
argument_list|)
expr_stmt|;
name|ggc_mark_rtx
argument_list|(
name|n
operator|->
name|data
operator|.
name|loop
operator|.
name|alt_end_label
argument_list|)
expr_stmt|;
name|ggc_mark_rtx
argument_list|(
name|n
operator|->
name|data
operator|.
name|loop
operator|.
name|continue_label
argument_list|)
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark N (known to be a block-nesting) for GC.  */
end_comment

begin_function
specifier|static
name|void
name|mark_block_nesting
parameter_list|(
name|n
parameter_list|)
name|struct
name|nesting
modifier|*
name|n
decl_stmt|;
block|{
while|while
condition|(
name|n
condition|)
block|{
name|struct
name|label_chain
modifier|*
name|l
decl_stmt|;
name|ggc_mark_rtx
argument_list|(
name|n
operator|->
name|exit_label
argument_list|)
expr_stmt|;
name|ggc_mark_rtx
argument_list|(
name|n
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
argument_list|)
expr_stmt|;
name|ggc_mark_rtx
argument_list|(
name|n
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|n
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|n
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|n
operator|->
name|data
operator|.
name|block
operator|.
name|label_chain
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|ggc_mark
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|l
operator|->
name|label
argument_list|)
expr_stmt|;
block|}
name|ggc_mark_rtx
argument_list|(
name|n
operator|->
name|data
operator|.
name|block
operator|.
name|last_unconditional_cleanup
argument_list|)
expr_stmt|;
comment|/* ??? cleanup_ptr never points outside the stack, does it?  */
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark N (known to be a case-nesting) for GC.  */
end_comment

begin_function
specifier|static
name|void
name|mark_case_nesting
parameter_list|(
name|n
parameter_list|)
name|struct
name|nesting
modifier|*
name|n
decl_stmt|;
block|{
while|while
condition|(
name|n
condition|)
block|{
name|ggc_mark_rtx
argument_list|(
name|n
operator|->
name|exit_label
argument_list|)
expr_stmt|;
name|ggc_mark_rtx
argument_list|(
name|n
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|start
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|n
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|n
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|index_expr
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|n
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
argument_list|)
expr_stmt|;
name|mark_case_node
argument_list|(
name|n
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
argument_list|)
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark C for GC.  */
end_comment

begin_function
specifier|static
name|void
name|mark_case_node
parameter_list|(
name|c
parameter_list|)
name|struct
name|case_node
modifier|*
name|c
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
block|{
name|ggc_mark_tree
argument_list|(
name|c
operator|->
name|low
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|c
operator|->
name|high
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|c
operator|->
name|code_label
argument_list|)
expr_stmt|;
name|mark_case_node
argument_list|(
name|c
operator|->
name|right
argument_list|)
expr_stmt|;
name|mark_case_node
argument_list|(
name|c
operator|->
name|left
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark G for GC.  */
end_comment

begin_function
specifier|static
name|void
name|mark_goto_fixup
parameter_list|(
name|g
parameter_list|)
name|struct
name|goto_fixup
modifier|*
name|g
decl_stmt|;
block|{
while|while
condition|(
name|g
condition|)
block|{
name|ggc_mark
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|ggc_mark_rtx
argument_list|(
name|g
operator|->
name|before_jump
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|g
operator|->
name|target
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|g
operator|->
name|context
argument_list|)
expr_stmt|;
name|ggc_mark_rtx
argument_list|(
name|g
operator|->
name|target_rtl
argument_list|)
expr_stmt|;
name|ggc_mark_rtx
argument_list|(
name|g
operator|->
name|stack_level
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|g
operator|->
name|cleanup_list_list
argument_list|)
expr_stmt|;
name|g
operator|=
name|g
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Clear out all parts of the state in F that can safely be discarded    after the function has been compiled, to let garbage collection    reclaim the memory.  */
end_comment

begin_function
name|void
name|free_stmt_status
parameter_list|(
name|f
parameter_list|)
name|struct
name|function
modifier|*
name|f
decl_stmt|;
block|{
comment|/* We're about to free the function obstack.  If we hold pointers to      things allocated there, then we'll try to mark them when we do      GC.  So, we clear them out here explicitly.  */
if|if
condition|(
name|f
operator|->
name|stmt
condition|)
name|free
argument_list|(
name|f
operator|->
name|stmt
argument_list|)
expr_stmt|;
name|f
operator|->
name|stmt
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark P for GC.  */
end_comment

begin_function
name|void
name|mark_stmt_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|stmt_status
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return;
name|mark_block_nesting
argument_list|(
name|p
operator|->
name|x_block_stack
argument_list|)
expr_stmt|;
name|mark_cond_nesting
argument_list|(
name|p
operator|->
name|x_cond_stack
argument_list|)
expr_stmt|;
name|mark_loop_nesting
argument_list|(
name|p
operator|->
name|x_loop_stack
argument_list|)
expr_stmt|;
name|mark_case_nesting
argument_list|(
name|p
operator|->
name|x_case_stack
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|p
operator|->
name|x_last_expr_type
argument_list|)
expr_stmt|;
comment|/* last_epxr_value is only valid if last_expr_type is nonzero.  */
if|if
condition|(
name|p
operator|->
name|x_last_expr_type
condition|)
name|ggc_mark_rtx
argument_list|(
name|p
operator|->
name|x_last_expr_value
argument_list|)
expr_stmt|;
name|mark_goto_fixup
argument_list|(
name|p
operator|->
name|x_goto_fixup_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_stmt
parameter_list|()
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|stmt_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_stmt_for_function
parameter_list|()
block|{
name|cfun
operator|->
name|stmt
operator|=
operator|(
expr|struct
name|stmt_status
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|stmt_status
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We are not currently within any block, conditional, loop or case.  */
name|block_stack
operator|=
literal|0
expr_stmt|;
name|stack_block_stack
operator|=
literal|0
expr_stmt|;
name|loop_stack
operator|=
literal|0
expr_stmt|;
name|case_stack
operator|=
literal|0
expr_stmt|;
name|cond_stack
operator|=
literal|0
expr_stmt|;
name|nesting_stack
operator|=
literal|0
expr_stmt|;
name|nesting_depth
operator|=
literal|0
expr_stmt|;
name|current_block_start_count
operator|=
literal|0
expr_stmt|;
comment|/* No gotos have been expanded yet.  */
name|goto_fixup_chain
operator|=
literal|0
expr_stmt|;
comment|/* We are not processing a ({...}) grouping.  */
name|expr_stmts_for_value
operator|=
literal|0
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
name|last_expr_value
operator|=
name|NULL_RTX
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if anything is pushed on the loop, condition, or case    stack.  */
end_comment

begin_function
name|int
name|in_control_zone_p
parameter_list|()
block|{
return|return
name|cond_stack
operator|||
name|loop_stack
operator|||
name|case_stack
return|;
block|}
end_function

begin_comment
comment|/* Record the current file and line.  Called from emit_line_note.  */
end_comment

begin_function
name|void
name|set_file_and_line_for_stmt
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
comment|/* If we're outputting an inline function, and we add a line note,      there may be no CFUN->STMT information.  So, there's no need to      update it.  */
if|if
condition|(
name|cfun
operator|->
name|stmt
condition|)
block|{
name|emit_filename
operator|=
name|file
expr_stmt|;
name|emit_lineno
operator|=
name|line
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit a no-op instruction.  */
end_comment

begin_function
name|void
name|emit_nop
parameter_list|()
block|{
name|rtx
name|last_insn
decl_stmt|;
name|last_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|optimize
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|last_insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
operator|(
name|GET_CODE
argument_list|(
name|last_insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|prev_real_insn
argument_list|(
name|last_insn
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
name|emit_insn
argument_list|(
name|gen_nop
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the rtx-label that corresponds to a LABEL_DECL,    creating it if necessary.  */
end_comment

begin_function
name|rtx
name|label_rtx
parameter_list|(
name|label
parameter_list|)
name|tree
name|label
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|LABEL_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_RTL_SET_P
argument_list|(
name|label
argument_list|)
condition|)
name|SET_DECL_RTL
argument_list|(
name|label
argument_list|,
name|gen_label_rtx
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|DECL_RTL
argument_list|(
name|label
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add an unconditional jump to LABEL as the next sequential instruction.  */
end_comment

begin_function
name|void
name|emit_jump
parameter_list|(
name|label
parameter_list|)
name|rtx
name|label
decl_stmt|;
block|{
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit code to jump to the address    specified by the pointer expression EXP.  */
end_comment

begin_function
name|void
name|expand_computed_goto
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|rtx
name|x
init|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|Pmode
condition|)
name|x
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_queue
argument_list|()
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_indirect_jump
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|current_function_has_computed_jump
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle goto statements and the labels that they can go to.  */
end_comment

begin_comment
comment|/* Specify the location in the RTL code of a label LABEL,    which is a LABEL_DECL tree node.     This is used for the kind of label that the user can jump to with a    goto statement, and for alternatives of a switch or case statement.    RTL labels generated for loops and conditionals don't go through here;    they are generated directly at the RTL level, by other functions below.     Note that this has nothing to do with defining label *names*.    Languages vary in how they do that and what that even means.  */
end_comment

begin_function
name|void
name|expand_label
parameter_list|(
name|label
parameter_list|)
name|tree
name|label
decl_stmt|;
block|{
name|struct
name|label_chain
modifier|*
name|p
decl_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label_rtx
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|label
argument_list|)
condition|)
name|LABEL_NAME
argument_list|(
name|DECL_RTL
argument_list|(
name|label
argument_list|)
argument_list|)
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack_block_stack
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
operator|(
expr|struct
name|label_chain
operator|*
operator|)
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|label_chain
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|stack_block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|label_chain
expr_stmt|;
name|stack_block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|label_chain
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|label
operator|=
name|label
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Declare that LABEL (a LABEL_DECL) may be used for nonlocal gotos    from nested functions.  */
end_comment

begin_function
name|void
name|declare_nonlocal_label
parameter_list|(
name|label
parameter_list|)
name|tree
name|label
decl_stmt|;
block|{
name|rtx
name|slot
init|=
name|assign_stack_local
argument_list|(
name|Pmode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|nonlocal_labels
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|label
argument_list|,
name|nonlocal_labels
argument_list|)
expr_stmt|;
name|LABEL_PRESERVE_P
argument_list|(
name|label_rtx
argument_list|(
name|label
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nonlocal_goto_handler_slots
operator|==
literal|0
condition|)
block|{
name|emit_stack_save
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
operator|&
name|nonlocal_goto_stack_level
argument_list|,
name|PREV_INSN
argument_list|(
name|tail_recursion_reentry
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|nonlocal_goto_handler_slots
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|slot
argument_list|,
name|nonlocal_goto_handler_slots
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL code for a `goto' statement with target label LABEL.    LABEL should be a LABEL_DECL tree node that was or will later be    defined with `expand_label'.  */
end_comment

begin_function
name|void
name|expand_goto
parameter_list|(
name|label
parameter_list|)
name|tree
name|label
decl_stmt|;
block|{
name|tree
name|context
decl_stmt|;
comment|/* Check for a nonlocal goto to a containing function.  */
name|context
operator|=
name|decl_function_context
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|!=
literal|0
operator|&&
name|context
operator|!=
name|current_function_decl
condition|)
block|{
name|struct
name|function
modifier|*
name|p
init|=
name|find_function_data
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|rtx
name|label_ref
init|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|label_rtx
argument_list|(
name|label
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|handler_slot
decl_stmt|,
name|static_chain
decl_stmt|,
name|save_area
decl_stmt|,
name|insn
decl_stmt|;
name|tree
name|link
decl_stmt|;
comment|/* Find the corresponding handler slot for this label.  */
name|handler_slot
operator|=
name|p
operator|->
name|x_nonlocal_goto_handler_slots
expr_stmt|;
for|for
control|(
name|link
operator|=
name|p
operator|->
name|x_nonlocal_labels
init|;
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
operator|!=
name|label
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|handler_slot
operator|=
name|XEXP
argument_list|(
name|handler_slot
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|handler_slot
operator|=
name|XEXP
argument_list|(
name|handler_slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|has_nonlocal_label
operator|=
literal|1
expr_stmt|;
name|current_function_has_nonlocal_goto
operator|=
literal|1
expr_stmt|;
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|label_ref
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Copy the rtl for the slots so that they won't be shared in 	 case the virtual stack vars register gets instantiated differently 	 in the parent than in the child.  */
name|static_chain
operator|=
name|copy_to_reg
argument_list|(
name|lookup_static_chain
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get addr of containing function's current nonlocal goto handler, 	 which will do any cleanups and then jump to the label.  */
name|handler_slot
operator|=
name|copy_to_reg
argument_list|(
name|replace_rtx
argument_list|(
name|copy_rtx
argument_list|(
name|handler_slot
argument_list|)
argument_list|,
name|virtual_stack_vars_rtx
argument_list|,
name|static_chain
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get addr of containing function's nonlocal save area.  */
name|save_area
operator|=
name|p
operator|->
name|x_nonlocal_goto_stack_level
expr_stmt|;
if|if
condition|(
name|save_area
condition|)
name|save_area
operator|=
name|replace_rtx
argument_list|(
name|copy_rtx
argument_list|(
name|save_area
argument_list|)
argument_list|,
name|virtual_stack_vars_rtx
argument_list|,
name|static_chain
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_nonlocal_goto
if|if
condition|(
name|HAVE_nonlocal_goto
condition|)
name|emit_insn
argument_list|(
name|gen_nonlocal_goto
argument_list|(
name|static_chain
argument_list|,
name|handler_slot
argument_list|,
name|save_area
argument_list|,
name|label_ref
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
comment|/* Restore frame pointer for containing function. 	     This sets the actual hard register used for the frame pointer 	     to the location of the function's incoming static chain info. 	     The non-local goto handler will then adjust it to contain the 	     proper value and reload the argument pointer, if needed.  */
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|static_chain
argument_list|)
expr_stmt|;
name|emit_stack_restore
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
name|save_area
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* USE of hard_frame_pointer_rtx added for consistency; 	     not clear if really needed.  */
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_indirect_jump
argument_list|(
name|handler_slot
argument_list|)
expr_stmt|;
block|}
comment|/* Search backwards to the jump insn and mark it as a  	 non-local goto.  */
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_NON_LOCAL_GOTO
argument_list|,
name|const0_rtx
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
break|break;
block|}
block|}
else|else
name|expand_goto_internal
argument_list|(
name|label
argument_list|,
name|label_rtx
argument_list|(
name|label
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL code for a `goto' statement with target label BODY.    LABEL should be a LABEL_REF.    LAST_INSN, if non-0, is the rtx we should consider as the last    insn emitted (for the purposes of cleaning up a return).  */
end_comment

begin_function
specifier|static
name|void
name|expand_goto_internal
parameter_list|(
name|body
parameter_list|,
name|label
parameter_list|,
name|last_insn
parameter_list|)
name|tree
name|body
decl_stmt|;
name|rtx
name|label
decl_stmt|;
name|rtx
name|last_insn
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|block
decl_stmt|;
name|rtx
name|stack_level
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If label has already been defined, we can tell now      whether and how we must alter the stack level.  */
if|if
condition|(
name|PREV_INSN
argument_list|(
name|label
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Find the innermost pending block that contains the label. 	 (Check containment by comparing insn-uids.) 	 Then restore the outermost stack level within that block, 	 and do cleanups of all blocks contained in it.  */
for|for
control|(
name|block
operator|=
name|block_stack
init|;
name|block
condition|;
name|block
operator|=
name|block
operator|->
name|next
control|)
block|{
if|if
condition|(
name|INSN_UID
argument_list|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
argument_list|)
operator|<
name|INSN_UID
argument_list|(
name|label
argument_list|)
condition|)
break|break;
if|if
condition|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|!=
literal|0
condition|)
name|stack_level
operator|=
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
expr_stmt|;
comment|/* Execute the cleanups for blocks we are exiting.  */
if|if
condition|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|!=
literal|0
condition|)
block|{
name|expand_cleanups
argument_list|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stack_level
condition|)
block|{
comment|/* Ensure stack adjust isn't done by emit_jump, as this 	     would clobber the stack pointer.  This one should be 	     deleted as dead by flow.  */
name|clear_pending_stack_adjust
argument_list|()
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Don't do this adjust if it's to the end label and this function 	     is to return with a depressed stack pointer.  */
if|if
condition|(
name|label
operator|==
name|return_label
operator|&&
operator|(
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|&&
operator|(
name|TYPE_RETURNS_STACK_DEPRESSED
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
empty_stmt|;
else|else
name|emit_stack_restore
argument_list|(
name|SAVE_BLOCK
argument_list|,
name|stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|body
operator|!=
literal|0
operator|&&
name|DECL_TOO_LATE
argument_list|(
name|body
argument_list|)
condition|)
name|error
argument_list|(
literal|"jump to `%s' invalidly jumps into binding contour"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Label not yet defined: may need to put this goto      on the fixup list.  */
elseif|else
if|if
condition|(
operator|!
name|expand_fixup
argument_list|(
name|body
argument_list|,
name|label
argument_list|,
name|last_insn
argument_list|)
condition|)
block|{
comment|/* No fixup needed.  Record that the label is the target 	 of at least one goto that has no fixup.  */
if|if
condition|(
name|body
operator|!=
literal|0
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|body
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|emit_jump
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate if necessary a fixup for a goto    whose target label in tree structure (if any) is TREE_LABEL    and whose target in rtl is RTL_LABEL.     If LAST_INSN is nonzero, we pretend that the jump appears    after insn LAST_INSN instead of at the current point in the insn stream.     The fixup will be used later to insert insns just before the goto.    Those insns will restore the stack level as appropriate for the    target label, and will (in the case of C++) also invoke any object    destructors which have to be invoked when we exit the scopes which    are exited by the goto.     Value is nonzero if a fixup is made.  */
end_comment

begin_function
specifier|static
name|int
name|expand_fixup
parameter_list|(
name|tree_label
parameter_list|,
name|rtl_label
parameter_list|,
name|last_insn
parameter_list|)
name|tree
name|tree_label
decl_stmt|;
name|rtx
name|rtl_label
decl_stmt|;
name|rtx
name|last_insn
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|block
decl_stmt|,
modifier|*
name|end_block
decl_stmt|;
comment|/* See if we can recognize which block the label will be output in.      This is possible in some very common cases.      If we succeed, set END_BLOCK to that block.      Otherwise, set it to 0.  */
if|if
condition|(
name|cond_stack
operator|&&
operator|(
name|rtl_label
operator|==
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
operator|||
name|rtl_label
operator|==
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
operator|)
condition|)
name|end_block
operator|=
name|cond_stack
expr_stmt|;
comment|/* If we are in a loop, recognize certain labels which      are likely targets.  This reduces the number of fixups      we need to create.  */
elseif|else
if|if
condition|(
name|loop_stack
operator|&&
operator|(
name|rtl_label
operator|==
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
operator|||
name|rtl_label
operator|==
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
operator|||
name|rtl_label
operator|==
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|continue_label
operator|)
condition|)
name|end_block
operator|=
name|loop_stack
expr_stmt|;
else|else
name|end_block
operator|=
literal|0
expr_stmt|;
comment|/* Now set END_BLOCK to the binding level to which we will return.  */
if|if
condition|(
name|end_block
condition|)
block|{
name|struct
name|nesting
modifier|*
name|next_block
init|=
name|end_block
operator|->
name|all
decl_stmt|;
name|block
operator|=
name|block_stack
expr_stmt|;
comment|/* First see if the END_BLOCK is inside the innermost binding level. 	 If so, then no cleanups or stack levels are relevant.  */
while|while
condition|(
name|next_block
operator|&&
name|next_block
operator|!=
name|block
condition|)
name|next_block
operator|=
name|next_block
operator|->
name|all
expr_stmt|;
if|if
condition|(
name|next_block
condition|)
return|return
literal|0
return|;
comment|/* Otherwise, set END_BLOCK to the innermost binding level 	 which is outside the relevant control-structure nesting.  */
name|next_block
operator|=
name|block_stack
operator|->
name|next
expr_stmt|;
for|for
control|(
name|block
operator|=
name|block_stack
init|;
name|block
operator|!=
name|end_block
condition|;
name|block
operator|=
name|block
operator|->
name|all
control|)
if|if
condition|(
name|block
operator|==
name|next_block
condition|)
name|next_block
operator|=
name|next_block
operator|->
name|next
expr_stmt|;
name|end_block
operator|=
name|next_block
expr_stmt|;
block|}
comment|/* Does any containing block have a stack level or cleanups?      If not, no fixup is needed, and that is the normal case      (the only case, for standard C).  */
for|for
control|(
name|block
operator|=
name|block_stack
init|;
name|block
operator|!=
name|end_block
condition|;
name|block
operator|=
name|block
operator|->
name|next
control|)
if|if
condition|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|!=
literal|0
operator|||
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|block
operator|!=
name|end_block
condition|)
block|{
comment|/* Ok, a fixup is needed.  Add a fixup to the list of such.  */
name|struct
name|goto_fixup
modifier|*
name|fixup
init|=
operator|(
expr|struct
name|goto_fixup
operator|*
operator|)
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|goto_fixup
argument_list|)
argument_list|)
decl_stmt|;
comment|/* In case an old stack level is restored, make sure that comes 	 after any pending stack adjust.  */
comment|/* ?? If the fixup isn't to come at the present position, 	 doing the stack adjust here isn't useful.  Doing it with our 	 settings at that location isn't useful either.  Let's hope 	 someone does it!  */
if|if
condition|(
name|last_insn
operator|==
literal|0
condition|)
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|fixup
operator|->
name|target
operator|=
name|tree_label
expr_stmt|;
name|fixup
operator|->
name|target_rtl
operator|=
name|rtl_label
expr_stmt|;
comment|/* Create a BLOCK node and a corresponding matched set of 	 NOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes at 	 this point.  The notes will encapsulate any and all fixup 	 code which we might later insert at this point in the insn 	 stream.  Also, the BLOCK node will be the parent (i.e. the 	 `SUPERBLOCK') of any other BLOCK nodes which we might create 	 later on when we are expanding the fixup code.  	 Note that optimization passes (including expand_end_loop) 	 might move the *_BLOCK notes away, so we use a NOTE_INSN_DELETED 	 as a placeholder.  */
block|{
name|rtx
name|original_before_jump
init|=
name|last_insn
condition|?
name|last_insn
else|:
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|start
decl_stmt|;
name|rtx
name|end
decl_stmt|;
name|tree
name|block
decl_stmt|;
name|block
operator|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|cfun
operator|->
name|x_whole_function_mode_p
condition|)
name|insert_block
argument_list|(
name|block
argument_list|)
expr_stmt|;
else|else
block|{
name|BLOCK_CHAIN
argument_list|(
name|block
argument_list|)
operator|=
name|BLOCK_CHAIN
argument_list|(
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|BLOCK_CHAIN
argument_list|(
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|=
name|block
expr_stmt|;
block|}
name|start_sequence
argument_list|()
expr_stmt|;
name|start
operator|=
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_BLOCK_BEG
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|x_whole_function_mode_p
condition|)
name|NOTE_BLOCK
argument_list|(
name|start
argument_list|)
operator|=
name|block
expr_stmt|;
name|fixup
operator|->
name|before_jump
operator|=
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|end
operator|=
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_BLOCK_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|x_whole_function_mode_p
condition|)
name|NOTE_BLOCK
argument_list|(
name|end
argument_list|)
operator|=
name|block
expr_stmt|;
name|fixup
operator|->
name|context
operator|=
name|block
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_after
argument_list|(
name|start
argument_list|,
name|original_before_jump
argument_list|)
expr_stmt|;
block|}
name|fixup
operator|->
name|block_start_count
operator|=
name|current_block_start_count
expr_stmt|;
name|fixup
operator|->
name|stack_level
operator|=
literal|0
expr_stmt|;
name|fixup
operator|->
name|cleanup_list_list
operator|=
operator|(
operator|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
operator|||
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|)
condition|?
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|,
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|fixup
operator|->
name|next
operator|=
name|goto_fixup_chain
expr_stmt|;
name|goto_fixup_chain
operator|=
name|fixup
expr_stmt|;
block|}
return|return
name|block
operator|!=
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand any needed fixups in the outputmost binding level of the    function.  FIRST_INSN is the first insn in the function.  */
end_comment

begin_function
name|void
name|expand_fixups
parameter_list|(
name|first_insn
parameter_list|)
name|rtx
name|first_insn
decl_stmt|;
block|{
name|fixup_gotos
argument_list|(
name|NULL
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_TREE
argument_list|,
name|first_insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When exiting a binding contour, process all pending gotos requiring fixups.    THISBLOCK is the structure that describes the block being exited.    STACK_LEVEL is the rtx for the stack level to restore exiting this contour.    CLEANUP_LIST is a list of expressions to evaluate on exiting this contour.    FIRST_INSN is the insn that began this contour.     Gotos that jump out of this contour must restore the    stack level and do the cleanups before actually jumping.     DONT_JUMP_IN nonzero means report error there is a jump into this    contour from before the beginning of the contour.    This is also done if STACK_LEVEL is nonzero.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_gotos
parameter_list|(
name|thisblock
parameter_list|,
name|stack_level
parameter_list|,
name|cleanup_list
parameter_list|,
name|first_insn
parameter_list|,
name|dont_jump_in
parameter_list|)
name|struct
name|nesting
modifier|*
name|thisblock
decl_stmt|;
name|rtx
name|stack_level
decl_stmt|;
name|tree
name|cleanup_list
decl_stmt|;
name|rtx
name|first_insn
decl_stmt|;
name|int
name|dont_jump_in
decl_stmt|;
block|{
name|struct
name|goto_fixup
modifier|*
name|f
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
comment|/* F is the fixup we are considering; PREV is the previous one.  */
comment|/* We run this loop in two passes so that cleanups of exited blocks      are run first, and blocks that are exited are marked so      afterwards.  */
for|for
control|(
name|prev
operator|=
literal|0
operator|,
name|f
operator|=
name|goto_fixup_chain
init|;
name|f
condition|;
name|prev
operator|=
name|f
operator|,
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
comment|/* Test for a fixup that is inactive because it is already handled.  */
if|if
condition|(
name|f
operator|->
name|before_jump
operator|==
literal|0
condition|)
block|{
comment|/* Delete inactive fixup from the chain, if that is easy to do.  */
if|if
condition|(
name|prev
operator|!=
literal|0
condition|)
name|prev
operator|->
name|next
operator|=
name|f
operator|->
name|next
expr_stmt|;
block|}
comment|/* Has this fixup's target label been defined? 	 If so, we can finalize it.  */
elseif|else
if|if
condition|(
name|PREV_INSN
argument_list|(
name|f
operator|->
name|target_rtl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rtx
name|cleanup_insns
decl_stmt|;
comment|/* If this fixup jumped into this contour from before the beginning 	     of this contour, report an error.   This code used to use 	     the first non-label insn after f->target_rtl, but that's 	     wrong since such can be added, by things like put_var_into_stack 	     and have INSN_UIDs that are out of the range of the block.  */
comment|/* ??? Bug: this does not detect jumping in through intermediate 	     blocks that have stack levels or cleanups. 	     It detects only a problem with the innermost block 	     around the label.  */
if|if
condition|(
name|f
operator|->
name|target
operator|!=
literal|0
operator|&&
operator|(
name|dont_jump_in
operator|||
name|stack_level
operator|||
name|cleanup_list
operator|)
operator|&&
name|INSN_UID
argument_list|(
name|first_insn
argument_list|)
operator|<
name|INSN_UID
argument_list|(
name|f
operator|->
name|target_rtl
argument_list|)
operator|&&
name|INSN_UID
argument_list|(
name|first_insn
argument_list|)
operator|>
name|INSN_UID
argument_list|(
name|f
operator|->
name|before_jump
argument_list|)
operator|&&
operator|!
name|DECL_ERROR_ISSUED
argument_list|(
name|f
operator|->
name|target
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|f
operator|->
name|target
argument_list|,
literal|"label `%s' used before containing binding contour"
argument_list|)
expr_stmt|;
comment|/* Prevent multiple errors for one label.  */
name|DECL_ERROR_ISSUED
argument_list|(
name|f
operator|->
name|target
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We will expand the cleanups into a sequence of their own and 	     then later on we will attach this new sequence to the insn 	     stream just ahead of the actual jump insn.  */
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Temporarily restore the lexical context where we will 	     logically be inserting the fixup code.  We do this for the 	     sake of getting the debugging information right.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|set_block
argument_list|(
name|f
operator|->
name|context
argument_list|)
expr_stmt|;
comment|/* Expand the cleanups for blocks this jump exits.  */
if|if
condition|(
name|f
operator|->
name|cleanup_list_list
condition|)
block|{
name|tree
name|lists
decl_stmt|;
for|for
control|(
name|lists
operator|=
name|f
operator|->
name|cleanup_list_list
init|;
name|lists
condition|;
name|lists
operator|=
name|TREE_CHAIN
argument_list|(
name|lists
argument_list|)
control|)
comment|/* Marked elements correspond to blocks that have been closed. 		   Do their cleanups.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|lists
argument_list|)
operator|&&
name|TREE_VALUE
argument_list|(
name|lists
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|expand_cleanups
argument_list|(
name|TREE_VALUE
argument_list|(
name|lists
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Pop any pushes done in the cleanups, 		       in case function is about to return.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Restore stack level for the biggest contour that this 	     jump jumps out of.  */
if|if
condition|(
name|f
operator|->
name|stack_level
operator|&&
operator|!
operator|(
name|f
operator|->
name|target_rtl
operator|==
name|return_label
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|&&
operator|(
name|TYPE_RETURNS_STACK_DEPRESSED
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
name|emit_stack_restore
argument_list|(
name|SAVE_BLOCK
argument_list|,
name|f
operator|->
name|stack_level
argument_list|,
name|f
operator|->
name|before_jump
argument_list|)
expr_stmt|;
comment|/* Finish up the sequence containing the insns which implement the 	     necessary cleanups, and then attach that whole sequence to the 	     insn stream just ahead of the actual jump insn.  Attaching it 	     at that point insures that any cleanups which are in fact 	     implicit C++ object destructions (which must be executed upon 	     leaving the block) appear (to the debugger) to be taking place 	     in an area of the generated code where the object(s) being 	     destructed are still "in scope".  */
name|cleanup_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_after
argument_list|(
name|cleanup_insns
argument_list|,
name|f
operator|->
name|before_jump
argument_list|)
expr_stmt|;
name|f
operator|->
name|before_jump
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* For any still-undefined labels, do the cleanups for this block now.      We must do this now since items in the cleanup list may go out      of scope when the block ends.  */
for|for
control|(
name|prev
operator|=
literal|0
operator|,
name|f
operator|=
name|goto_fixup_chain
init|;
name|f
condition|;
name|prev
operator|=
name|f
operator|,
name|f
operator|=
name|f
operator|->
name|next
control|)
if|if
condition|(
name|f
operator|->
name|before_jump
operator|!=
literal|0
operator|&&
name|PREV_INSN
argument_list|(
name|f
operator|->
name|target_rtl
argument_list|)
operator|==
literal|0
comment|/* Label has still not appeared.  If we are exiting a block with 	   a stack level to restore, that started before the fixup, 	   mark this stack level as needing restoration 	   when the fixup is later finalized.  */
operator|&&
name|thisblock
operator|!=
literal|0
comment|/* Note: if THISBLOCK == 0 and we have a label that hasn't appeared, it 	   means the label is undefined.  That's erroneous, but possible.  */
operator|&&
operator|(
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|block_start_count
operator|<=
name|f
operator|->
name|block_start_count
operator|)
condition|)
block|{
name|tree
name|lists
init|=
name|f
operator|->
name|cleanup_list_list
decl_stmt|;
name|rtx
name|cleanup_insns
decl_stmt|;
for|for
control|(
init|;
name|lists
condition|;
name|lists
operator|=
name|TREE_CHAIN
argument_list|(
name|lists
argument_list|)
control|)
comment|/* If the following elt. corresponds to our containing block 	     then the elt. must be for this block.  */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|lists
argument_list|)
operator|==
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|set_block
argument_list|(
name|f
operator|->
name|context
argument_list|)
expr_stmt|;
name|expand_cleanups
argument_list|(
name|TREE_VALUE
argument_list|(
name|lists
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|cleanup_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|cleanup_insns
operator|!=
literal|0
condition|)
name|f
operator|->
name|before_jump
operator|=
name|emit_insns_after
argument_list|(
name|cleanup_insns
argument_list|,
name|f
operator|->
name|before_jump
argument_list|)
expr_stmt|;
name|f
operator|->
name|cleanup_list_list
operator|=
name|TREE_CHAIN
argument_list|(
name|lists
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stack_level
condition|)
name|f
operator|->
name|stack_level
operator|=
name|stack_level
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the number of times character C occurs in string S.  */
end_comment

begin_function
specifier|static
name|int
name|n_occurrences
parameter_list|(
name|c
parameter_list|,
name|s
parameter_list|)
name|int
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|n
operator|+=
operator|(
operator|*
name|s
operator|++
operator|==
name|c
operator|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL for an asm statement (explicit assembler code).    BODY is a STRING_CST node containing the assembler code text,    or an ADDR_EXPR containing a STRING_CST.  */
end_comment

begin_function
name|void
name|expand_asm
parameter_list|(
name|body
parameter_list|)
name|tree
name|body
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|body
operator|=
name|TREE_OPERAND
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_ASM_INPUT
argument_list|(
name|VOIDmode
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse the output constraint pointed to by *CONSTRAINT_P.  It is the    OPERAND_NUMth output operand, indexed from zero.  There are NINPUTS    inputs and NOUTPUTS outputs to this extended-asm.  Upon return,    *ALLOWS_MEM will be TRUE iff the constraint allows the use of a    memory operand.  Similarly, *ALLOWS_REG will be TRUE iff the    constraint allows the use of a register operand.  And, *IS_INOUT    will be true if the operand is read-write, i.e., if it is used as    an input as well as an output.  If *CONSTRAINT_P is not in    canonical form, it will be made canonical.  (Note that `+' will be    rpelaced with `=' as part of this process.)     Returns TRUE if all went well; FALSE if an error occurred.  */
end_comment

begin_function
name|bool
name|parse_output_constraint
parameter_list|(
name|constraint_p
parameter_list|,
name|operand_num
parameter_list|,
name|ninputs
parameter_list|,
name|noutputs
parameter_list|,
name|allows_mem
parameter_list|,
name|allows_reg
parameter_list|,
name|is_inout
parameter_list|)
specifier|const
name|char
modifier|*
modifier|*
name|constraint_p
decl_stmt|;
name|int
name|operand_num
decl_stmt|;
name|int
name|ninputs
decl_stmt|;
name|int
name|noutputs
decl_stmt|;
name|bool
modifier|*
name|allows_mem
decl_stmt|;
name|bool
modifier|*
name|allows_reg
decl_stmt|;
name|bool
modifier|*
name|is_inout
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|constraint
init|=
operator|*
name|constraint_p
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Assume the constraint doesn't allow the use of either a register      or memory.  */
operator|*
name|allows_mem
operator|=
name|false
expr_stmt|;
operator|*
name|allows_reg
operator|=
name|false
expr_stmt|;
comment|/* Allow the `=' or `+' to not be at the beginning of the string,      since it wasn't explicitly documented that way, and there is a      large body of code that puts it last.  Swap the character to      the front, so as not to uglify any place else.  */
name|p
operator|=
name|strchr
argument_list|(
name|constraint
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|strchr
argument_list|(
name|constraint
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
comment|/* If the string doesn't contain an `=', issue an error      message.  */
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|error
argument_list|(
literal|"output operand constraint lacks `='"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* If the constraint begins with `+', then the operand is both read      from and written to.  */
operator|*
name|is_inout
operator|=
operator|(
operator|*
name|p
operator|==
literal|'+'
operator|)
expr_stmt|;
comment|/* Canonicalize the output constraint so that it begins with `='.  */
if|if
condition|(
name|p
operator|!=
name|constraint
operator|||
name|is_inout
condition|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|c_len
init|=
name|strlen
argument_list|(
name|constraint
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|constraint
condition|)
name|warning
argument_list|(
literal|"output constraint `%c' for operand %d is not at the beginning"
argument_list|,
operator|*
name|p
argument_list|,
name|operand_num
argument_list|)
expr_stmt|;
comment|/* Make a copy of the constraint.  */
name|buf
operator|=
name|alloca
argument_list|(
name|c_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|constraint
argument_list|)
expr_stmt|;
comment|/* Swap the first character and the `=' or `+'.  */
name|buf
index|[
name|p
operator|-
name|constraint
index|]
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
comment|/* Make sure the first character is an `='.  (Until we do this, 	 it might be a `+'.)  */
name|buf
index|[
literal|0
index|]
operator|=
literal|'='
expr_stmt|;
comment|/* Replace the constraint with the canonicalized string.  */
operator|*
name|constraint_p
operator|=
name|ggc_alloc_string
argument_list|(
name|buf
argument_list|,
name|c_len
argument_list|)
expr_stmt|;
name|constraint
operator|=
operator|*
name|constraint_p
expr_stmt|;
block|}
comment|/* Loop through the constraint string.  */
for|for
control|(
name|p
operator|=
name|constraint
operator|+
literal|1
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'+'
case|:
case|case
literal|'='
case|:
name|error
argument_list|(
literal|"operand constraint contains incorrectly positioned '+' or '='"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
literal|'%'
case|:
if|if
condition|(
name|operand_num
operator|+
literal|1
operator|==
name|ninputs
operator|+
name|noutputs
condition|)
block|{
name|error
argument_list|(
literal|"`%%' constraint used with last operand"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
break|break;
case|case
literal|'V'
case|:
case|case
literal|'m'
case|:
case|case
literal|'o'
case|:
operator|*
name|allows_mem
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
case|case
literal|'!'
case|:
case|case
literal|'*'
case|:
case|case
literal|'&'
case|:
case|case
literal|'#'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'s'
case|:
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|','
case|:
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'['
case|:
name|error
argument_list|(
literal|"matching constraint not valid in output operand"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
comment|/* ??? Before flow, auto inc/dec insns are not supposed to exist, 	   excepting those that expand_call created.  So match memory 	   and hope.  */
operator|*
name|allows_mem
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'X'
case|:
operator|*
name|allows_reg
operator|=
name|true
expr_stmt|;
operator|*
name|allows_mem
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'r'
case|:
operator|*
name|allows_reg
operator|=
name|true
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|ISALPHA
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
if|if
condition|(
name|REG_CLASS_FROM_LETTER
argument_list|(
operator|*
name|p
argument_list|)
operator|!=
name|NO_REGS
condition|)
operator|*
name|allows_reg
operator|=
name|true
expr_stmt|;
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT
else|else
block|{
comment|/* Otherwise we can't assume anything about the nature of 	       the constraint except that it isn't purely registers. 	       Treat it like "g" and hope for the best.  */
operator|*
name|allows_reg
operator|=
name|true
expr_stmt|;
operator|*
name|allows_mem
operator|=
name|true
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Similar, but for input constraints.  */
end_comment

begin_function
specifier|static
name|bool
name|parse_input_constraint
parameter_list|(
name|constraint_p
parameter_list|,
name|input_num
parameter_list|,
name|ninputs
parameter_list|,
name|noutputs
parameter_list|,
name|ninout
parameter_list|,
name|constraints
parameter_list|,
name|allows_mem
parameter_list|,
name|allows_reg
parameter_list|)
specifier|const
name|char
modifier|*
modifier|*
name|constraint_p
decl_stmt|;
name|int
name|input_num
decl_stmt|;
name|int
name|ninputs
decl_stmt|;
name|int
name|noutputs
decl_stmt|;
name|int
name|ninout
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|constraints
decl_stmt|;
name|bool
modifier|*
name|allows_mem
decl_stmt|;
name|bool
modifier|*
name|allows_reg
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|constraint
init|=
operator|*
name|constraint_p
decl_stmt|;
specifier|const
name|char
modifier|*
name|orig_constraint
init|=
name|constraint
decl_stmt|;
name|size_t
name|c_len
init|=
name|strlen
argument_list|(
name|constraint
argument_list|)
decl_stmt|;
name|size_t
name|j
decl_stmt|;
comment|/* Assume the constraint doesn't allow the use of either      a register or memory.  */
operator|*
name|allows_mem
operator|=
name|false
expr_stmt|;
operator|*
name|allows_reg
operator|=
name|false
expr_stmt|;
comment|/* Make sure constraint has neither `=', `+', nor '&'.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|c_len
condition|;
name|j
operator|++
control|)
switch|switch
condition|(
name|constraint
index|[
name|j
index|]
condition|)
block|{
case|case
literal|'+'
case|:
case|case
literal|'='
case|:
case|case
literal|'&'
case|:
if|if
condition|(
name|constraint
operator|==
name|orig_constraint
condition|)
block|{
name|error
argument_list|(
literal|"input operand constraint contains `%c'"
argument_list|,
name|constraint
index|[
name|j
index|]
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
break|break;
case|case
literal|'%'
case|:
if|if
condition|(
name|constraint
operator|==
name|orig_constraint
operator|&&
name|input_num
operator|+
literal|1
operator|==
name|ninputs
operator|-
name|ninout
condition|)
block|{
name|error
argument_list|(
literal|"`%%' constraint used with last operand"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
break|break;
case|case
literal|'V'
case|:
case|case
literal|'m'
case|:
case|case
literal|'o'
case|:
operator|*
name|allows_mem
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'?'
case|:
case|case
literal|'!'
case|:
case|case
literal|'*'
case|:
case|case
literal|'#'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'s'
case|:
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|','
case|:
break|break;
comment|/* Whether or not a numeric constraint allows a register is 	   decided by the matching constraint, and so there is no need 	   to do anything special with them.  We must handle them in 	   the default case, so that we don't unnecessarily force 	   operands to memory.  */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|unsigned
name|long
name|match
decl_stmt|;
name|match
operator|=
name|strtoul
argument_list|(
name|constraint
operator|+
name|j
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|>=
operator|(
name|unsigned
name|long
operator|)
name|noutputs
condition|)
block|{
name|error
argument_list|(
literal|"matching constraint references invalid operand number"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Try and find the real constraint for this dup.  Only do this 	     if the matching constraint is the only alternative.  */
if|if
condition|(
operator|*
name|end
operator|==
literal|'\0'
operator|&&
operator|(
name|j
operator|==
literal|0
operator|||
operator|(
name|j
operator|==
literal|1
operator|&&
name|constraint
index|[
literal|0
index|]
operator|==
literal|'%'
operator|)
operator|)
condition|)
block|{
name|constraint
operator|=
name|constraints
index|[
name|match
index|]
expr_stmt|;
operator|*
name|constraint_p
operator|=
name|constraint
expr_stmt|;
name|c_len
operator|=
name|strlen
argument_list|(
name|constraint
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
break|break;
block|}
else|else
name|j
operator|=
name|end
operator|-
name|constraint
expr_stmt|;
block|}
comment|/* Fall through.  */
case|case
literal|'p'
case|:
case|case
literal|'r'
case|:
operator|*
name|allows_reg
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'X'
case|:
operator|*
name|allows_reg
operator|=
name|true
expr_stmt|;
operator|*
name|allows_mem
operator|=
name|true
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|ISALPHA
argument_list|(
name|constraint
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid punctuation `%c' in constraint"
argument_list|,
name|constraint
index|[
name|j
index|]
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|REG_CLASS_FROM_LETTER
argument_list|(
name|constraint
index|[
name|j
index|]
argument_list|)
operator|!=
name|NO_REGS
condition|)
operator|*
name|allows_reg
operator|=
name|true
expr_stmt|;
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT
else|else
block|{
comment|/* Otherwise we can't assume anything about the nature of 	       the constraint except that it isn't purely registers. 	       Treat it like "g" and hope for the best.  */
operator|*
name|allows_reg
operator|=
name|true
expr_stmt|;
operator|*
name|allows_mem
operator|=
name|true
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Generate RTL for an asm statement with arguments.    STRING is the instruction template.    OUTPUTS is a list of output arguments (lvalues); INPUTS a list of inputs.    Each output or input has an expression in the TREE_VALUE and    and a tree list in TREE_PURPOSE which in turn contains a constraint    name in TREE_VALUE (or NULL_TREE) and a constraint string     in TREE_PURPOSE.    CLOBBERS is a list of STRING_CST nodes each naming a hard register    that is clobbered by this insn.     Not all kinds of lvalue that may appear in OUTPUTS can be stored directly.    Some elements of OUTPUTS may be replaced with trees representing temporary    values.  The caller should copy those temporary values to the originally    specified lvalues.     VOL nonzero means the insn is volatile; don't optimize it.  */
end_comment

begin_function
name|void
name|expand_asm_operands
parameter_list|(
name|string
parameter_list|,
name|outputs
parameter_list|,
name|inputs
parameter_list|,
name|clobbers
parameter_list|,
name|vol
parameter_list|,
name|filename
parameter_list|,
name|line
parameter_list|)
name|tree
name|string
decl_stmt|,
name|outputs
decl_stmt|,
name|inputs
decl_stmt|,
name|clobbers
decl_stmt|;
name|int
name|vol
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|rtvec
name|argvec
decl_stmt|,
name|constraintvec
decl_stmt|;
name|rtx
name|body
decl_stmt|;
name|int
name|ninputs
init|=
name|list_length
argument_list|(
name|inputs
argument_list|)
decl_stmt|;
name|int
name|noutputs
init|=
name|list_length
argument_list|(
name|outputs
argument_list|)
decl_stmt|;
name|int
name|ninout
decl_stmt|;
name|int
name|nclobbers
decl_stmt|;
name|tree
name|tail
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Vector of RTX's of evaluated output operands.  */
name|rtx
modifier|*
name|output_rtx
init|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|noutputs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
decl_stmt|;
name|int
modifier|*
name|inout_opnum
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|noutputs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|real_output_rtx
init|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|noutputs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
modifier|*
name|inout_mode
init|=
operator|(
expr|enum
name|machine_mode
operator|*
operator|)
name|alloca
argument_list|(
name|noutputs
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|machine_mode
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|constraints
init|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|noutputs
operator|+
name|ninputs
operator|)
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
comment|/* The insn we have emitted.  */
name|rtx
name|insn
decl_stmt|;
name|int
name|old_generating_concat_p
init|=
name|generating_concat_p
decl_stmt|;
comment|/* An ASM with no outputs needs to be treated as volatile, for now.  */
if|if
condition|(
name|noutputs
operator|==
literal|0
condition|)
name|vol
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|check_operand_nalternatives
argument_list|(
name|outputs
argument_list|,
name|inputs
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|check_unique_operand_names
argument_list|(
name|outputs
argument_list|,
name|inputs
argument_list|)
condition|)
return|return;
name|string
operator|=
name|resolve_operand_names
argument_list|(
name|string
argument_list|,
name|outputs
argument_list|,
name|inputs
argument_list|,
name|constraints
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MD_ASM_CLOBBERS
comment|/* Sometimes we wish to automatically clobber registers across an asm.      Case in point is when the i386 backend moved from cc0 to a hard reg --      maintaining source-level compatibility means automatically clobbering      the flags register.  */
name|MD_ASM_CLOBBERS
argument_list|(
name|clobbers
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Count the number of meaningful clobbered registers, ignoring what      we would ignore later.  */
name|nclobbers
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|clobbers
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|regname
init|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
decl_stmt|;
name|i
operator|=
name|decode_reg_name
argument_list|(
name|regname
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
operator|||
name|i
operator|==
operator|-
literal|4
condition|)
operator|++
name|nclobbers
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
operator|-
literal|2
condition|)
name|error
argument_list|(
literal|"unknown register name `%s' in `asm'"
argument_list|,
name|regname
argument_list|)
expr_stmt|;
block|}
name|last_expr_type
operator|=
literal|0
expr_stmt|;
comment|/* First pass over inputs and outputs checks validity and sets      mark_addressable if needed.  */
name|ninout
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|constraint
decl_stmt|;
name|bool
name|is_inout
decl_stmt|;
name|bool
name|allows_reg
decl_stmt|;
name|bool
name|allows_mem
decl_stmt|;
comment|/* If there's an erroneous arg, emit no insn.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* Try to parse the output constraint.  If that fails, there's 	 no point in going further.  */
name|constraint
operator|=
name|constraints
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|parse_output_constraint
argument_list|(
operator|&
name|constraint
argument_list|,
name|i
argument_list|,
name|ninputs
argument_list|,
name|noutputs
argument_list|,
operator|&
name|allows_mem
argument_list|,
operator|&
name|allows_reg
argument_list|,
operator|&
name|is_inout
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|allows_reg
operator|&&
operator|(
name|allows_mem
operator|||
name|is_inout
operator|||
operator|(
name|DECL_P
argument_list|(
name|val
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|val
argument_list|)
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|)
operator|)
condition|)
name|mark_addressable
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_inout
condition|)
name|ninout
operator|++
expr_stmt|;
block|}
name|ninputs
operator|+=
name|ninout
expr_stmt|;
if|if
condition|(
name|ninputs
operator|+
name|noutputs
operator|>
name|MAX_RECOG_OPERANDS
condition|)
block|{
name|error
argument_list|(
literal|"more than %d operands in `asm'"
argument_list|,
name|MAX_RECOG_OPERANDS
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|inputs
init|;
name|tail
condition|;
name|i
operator|++
operator|,
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|bool
name|allows_reg
decl_stmt|,
name|allows_mem
decl_stmt|;
specifier|const
name|char
modifier|*
name|constraint
decl_stmt|;
comment|/* If there's an erroneous arg, emit no insn, because the ASM_INPUT 	 would get VOIDmode and that could cause a crash in reload.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return;
name|constraint
operator|=
name|constraints
index|[
name|i
operator|+
name|noutputs
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|parse_input_constraint
argument_list|(
operator|&
name|constraint
argument_list|,
name|i
argument_list|,
name|ninputs
argument_list|,
name|noutputs
argument_list|,
name|ninout
argument_list|,
name|constraints
argument_list|,
operator|&
name|allows_mem
argument_list|,
operator|&
name|allows_reg
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|allows_reg
operator|&&
name|allows_mem
condition|)
name|mark_addressable
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Second pass evaluates arguments.  */
name|ninout
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|bool
name|is_inout
decl_stmt|;
name|bool
name|allows_reg
decl_stmt|;
name|bool
name|allows_mem
decl_stmt|;
if|if
condition|(
operator|!
name|parse_output_constraint
argument_list|(
operator|&
name|constraints
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|ninputs
argument_list|,
name|noutputs
argument_list|,
operator|&
name|allows_mem
argument_list|,
operator|&
name|allows_reg
argument_list|,
operator|&
name|is_inout
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If an output operand is not a decl or indirect ref and our constraint 	 allows a register, make a temporary to act as an intermediate. 	 Make the asm insn write into that, then our caller will copy it to 	 the real output operand.  Likewise for promoted variables.  */
name|generating_concat_p
operator|=
literal|0
expr_stmt|;
name|real_output_rtx
index|[
name|i
index|]
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|allows_mem
operator|)
operator|||
operator|(
name|DECL_P
argument_list|(
name|val
argument_list|)
operator|&&
operator|(
name|allows_mem
operator|||
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|val
argument_list|)
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|)
operator|)
operator|||
operator|!
name|allows_reg
operator|||
name|is_inout
condition|)
block|{
name|output_rtx
index|[
name|i
index|]
operator|=
name|expand_expr
argument_list|(
name|val
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allows_reg
operator|&&
name|GET_CODE
argument_list|(
name|output_rtx
index|[
name|i
index|]
argument_list|)
operator|!=
name|MEM
condition|)
name|error
argument_list|(
literal|"output number %d not directly addressable"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|allows_mem
operator|&&
name|GET_CODE
argument_list|(
name|output_rtx
index|[
name|i
index|]
argument_list|)
operator|==
name|MEM
operator|)
operator|||
name|GET_CODE
argument_list|(
name|output_rtx
index|[
name|i
index|]
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|real_output_rtx
index|[
name|i
index|]
operator|=
name|protect_from_queue
argument_list|(
name|output_rtx
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|output_rtx
index|[
name|i
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|output_rtx
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_inout
condition|)
name|emit_move_insn
argument_list|(
name|output_rtx
index|[
name|i
index|]
argument_list|,
name|real_output_rtx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|output_rtx
index|[
name|i
index|]
operator|=
name|assign_temp
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|=
name|make_tree
argument_list|(
name|type
argument_list|,
name|output_rtx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|generating_concat_p
operator|=
name|old_generating_concat_p
expr_stmt|;
if|if
condition|(
name|is_inout
condition|)
block|{
name|inout_mode
index|[
name|ninout
index|]
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|inout_opnum
index|[
name|ninout
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* Make vectors for the expression-rtx, constraint strings,      and named operands.  */
name|argvec
operator|=
name|rtvec_alloc
argument_list|(
name|ninputs
argument_list|)
expr_stmt|;
name|constraintvec
operator|=
name|rtvec_alloc
argument_list|(
name|ninputs
argument_list|)
expr_stmt|;
name|body
operator|=
name|gen_rtx_ASM_OPERANDS
argument_list|(
operator|(
name|noutputs
operator|==
literal|0
condition|?
name|VOIDmode
else|:
name|GET_MODE
argument_list|(
name|output_rtx
index|[
literal|0
index|]
argument_list|)
operator|)
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|string
argument_list|)
argument_list|,
name|empty_string
argument_list|,
literal|0
argument_list|,
name|argvec
argument_list|,
name|constraintvec
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|body
argument_list|)
operator|=
name|vol
expr_stmt|;
comment|/* Eval the inputs and put them into ARGVEC.      Put their constraints into ASM_INPUTs and store in CONSTRAINTS.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|inputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
operator|++
name|i
control|)
block|{
name|bool
name|allows_reg
decl_stmt|,
name|allows_mem
decl_stmt|;
specifier|const
name|char
modifier|*
name|constraint
decl_stmt|;
name|tree
name|val
decl_stmt|,
name|type
decl_stmt|;
name|rtx
name|op
decl_stmt|;
name|constraint
operator|=
name|constraints
index|[
name|i
operator|+
name|noutputs
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|parse_input_constraint
argument_list|(
operator|&
name|constraint
argument_list|,
name|i
argument_list|,
name|ninputs
argument_list|,
name|noutputs
argument_list|,
name|ninout
argument_list|,
name|constraints
argument_list|,
operator|&
name|allows_mem
argument_list|,
operator|&
name|allows_reg
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|generating_concat_p
operator|=
literal|0
expr_stmt|;
name|val
operator|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|op
operator|=
name|expand_expr
argument_list|(
name|val
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Never pass a CONCAT to an ASM.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONCAT
condition|)
name|op
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|asm_operand_ok
argument_list|(
name|op
argument_list|,
name|constraint
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|allows_reg
condition|)
name|op
operator|=
name|force_reg
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|allows_mem
condition|)
name|warning
argument_list|(
literal|"asm operand %d probably doesn't match constraints"
argument_list|,
name|i
operator|+
name|noutputs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
name|op
operator|=
name|force_const_mem
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ADDRESSOF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|tree
name|qual_type
init|=
name|build_qualified_type
argument_list|(
name|type
argument_list|,
operator|(
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
operator||
name|TYPE_QUAL_CONST
operator|)
argument_list|)
decl_stmt|;
name|rtx
name|memloc
init|=
name|assign_temp
argument_list|(
name|qual_type
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|memloc
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|op
operator|=
name|memloc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|op
argument_list|)
condition|)
block|{
comment|/* We won't recognize volatile memory as available a 		 memory_operand at this point.  Ignore it.  */
block|}
elseif|else
if|if
condition|(
name|queued_subexp_p
argument_list|(
name|op
argument_list|)
condition|)
empty_stmt|;
else|else
comment|/* ??? Leave this only until we have experience with what 	       happens in combine and elsewhere when constraints are 	       not satisfied.  */
name|warning
argument_list|(
literal|"asm operand %d probably doesn't match constraints"
argument_list|,
name|i
operator|+
name|noutputs
argument_list|)
expr_stmt|;
block|}
name|generating_concat_p
operator|=
name|old_generating_concat_p
expr_stmt|;
name|ASM_OPERANDS_INPUT
argument_list|(
name|body
argument_list|,
name|i
argument_list|)
operator|=
name|op
expr_stmt|;
name|ASM_OPERANDS_INPUT_CONSTRAINT_EXP
argument_list|(
name|body
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx_ASM_INPUT
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|constraints
index|[
name|i
operator|+
name|noutputs
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Protect all the operands from the queue now that they have all been      evaluated.  */
name|generating_concat_p
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninputs
operator|-
name|ninout
condition|;
name|i
operator|++
control|)
name|ASM_OPERANDS_INPUT
argument_list|(
name|body
argument_list|,
name|i
argument_list|)
operator|=
name|protect_from_queue
argument_list|(
name|ASM_OPERANDS_INPUT
argument_list|(
name|body
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noutputs
condition|;
name|i
operator|++
control|)
name|output_rtx
index|[
name|i
index|]
operator|=
name|protect_from_queue
argument_list|(
name|output_rtx
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* For in-out operands, copy output rtx to input rtx.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninout
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
init|=
name|inout_opnum
index|[
name|i
index|]
decl_stmt|;
name|char
name|buffer
index|[
literal|16
index|]
decl_stmt|;
name|ASM_OPERANDS_INPUT
argument_list|(
name|body
argument_list|,
name|ninputs
operator|-
name|ninout
operator|+
name|i
argument_list|)
operator|=
name|output_rtx
index|[
name|j
index|]
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|ASM_OPERANDS_INPUT_CONSTRAINT_EXP
argument_list|(
name|body
argument_list|,
name|ninputs
operator|-
name|ninout
operator|+
name|i
argument_list|)
operator|=
name|gen_rtx_ASM_INPUT
argument_list|(
name|inout_mode
index|[
name|i
index|]
argument_list|,
name|ggc_alloc_string
argument_list|(
name|buffer
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|generating_concat_p
operator|=
name|old_generating_concat_p
expr_stmt|;
comment|/* Now, for each output, construct an rtx      (set OUTPUT (asm_operands INSN OUTPUTCONSTRAINT OUTPUTNUMBER 			       ARGVEC CONSTRAINTS OPNAMES))      If there is more than one, put them inside a PARALLEL.  */
if|if
condition|(
name|noutputs
operator|==
literal|1
operator|&&
name|nclobbers
operator|==
literal|0
condition|)
block|{
name|ASM_OPERANDS_OUTPUT_CONSTRAINT
argument_list|(
name|body
argument_list|)
operator|=
name|constraints
index|[
literal|0
index|]
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|output_rtx
index|[
literal|0
index|]
argument_list|,
name|body
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|noutputs
operator|==
literal|0
operator|&&
name|nclobbers
operator|==
literal|0
condition|)
block|{
comment|/* No output operands: put in a raw ASM_OPERANDS rtx.  */
name|insn
operator|=
name|emit_insn
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|obody
init|=
name|body
decl_stmt|;
name|int
name|num
init|=
name|noutputs
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
name|num
operator|=
literal|1
expr_stmt|;
name|body
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|num
operator|+
name|nclobbers
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For each output operand, store a SET.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|output_rtx
index|[
name|i
index|]
argument_list|,
name|gen_rtx_ASM_OPERANDS
argument_list|(
name|GET_MODE
argument_list|(
name|output_rtx
index|[
name|i
index|]
argument_list|)
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|string
argument_list|)
argument_list|,
name|constraints
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|argvec
argument_list|,
name|constraintvec
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
operator|=
name|vol
expr_stmt|;
block|}
comment|/* If there are no outputs (but there are some clobbers) 	 store the bare ASM_OPERANDS into the PARALLEL.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
operator|++
argument_list|)
operator|=
name|obody
expr_stmt|;
comment|/* Store (clobber REG) for each clobbered register specified.  */
for|for
control|(
name|tail
operator|=
name|clobbers
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|regname
init|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|j
init|=
name|decode_reg_name
argument_list|(
name|regname
argument_list|)
decl_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|j
operator|==
operator|-
literal|3
condition|)
comment|/* `cc', which is not a register */
continue|continue;
if|if
condition|(
name|j
operator|==
operator|-
literal|4
condition|)
comment|/* `memory', don't cache memory across asm */
block|{
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
operator|++
argument_list|)
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|VOIDmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Ignore unknown register, error already signaled.  */
continue|continue;
block|}
comment|/* Use QImode since that's guaranteed to clobber just one reg.  */
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
operator|++
argument_list|)
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|QImode
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_insn
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
comment|/* For any outputs that needed reloading into registers, spill them      back to where they belong.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noutputs
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|real_output_rtx
index|[
name|i
index|]
condition|)
name|emit_move_insn
argument_list|(
name|real_output_rtx
index|[
name|i
index|]
argument_list|,
name|output_rtx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of expand_asm_operands.  Check that all operands have    the same number of alternatives.  Return true if so.  */
end_comment

begin_function
specifier|static
name|bool
name|check_operand_nalternatives
parameter_list|(
name|outputs
parameter_list|,
name|inputs
parameter_list|)
name|tree
name|outputs
decl_stmt|,
name|inputs
decl_stmt|;
block|{
if|if
condition|(
name|outputs
operator|||
name|inputs
condition|)
block|{
name|tree
name|tmp
init|=
name|TREE_PURPOSE
argument_list|(
name|outputs
condition|?
name|outputs
else|:
name|inputs
argument_list|)
decl_stmt|;
name|int
name|nalternatives
init|=
name|n_occurrences
argument_list|(
literal|','
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|next
init|=
name|inputs
decl_stmt|;
if|if
condition|(
name|nalternatives
operator|+
literal|1
operator|>
name|MAX_RECOG_ALTERNATIVES
condition|)
block|{
name|error
argument_list|(
literal|"too many alternatives in `asm'"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|tmp
operator|=
name|outputs
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
specifier|const
name|char
modifier|*
name|constraint
init|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|n_occurrences
argument_list|(
literal|','
argument_list|,
name|constraint
argument_list|)
operator|!=
name|nalternatives
condition|)
block|{
name|error
argument_list|(
literal|"operand constraints for `asm' differ in number of alternatives"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
condition|)
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
name|next
operator|,
name|next
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of expand_asm_operands.  Check that all operand names    are unique.  Return true if so.  We rely on the fact that these names    are identifiers, and so have been canonicalized by get_identifier,    so all we need are pointer comparisons.  */
end_comment

begin_function
specifier|static
name|bool
name|check_unique_operand_names
parameter_list|(
name|outputs
parameter_list|,
name|inputs
parameter_list|)
name|tree
name|outputs
decl_stmt|,
name|inputs
decl_stmt|;
block|{
name|tree
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
name|outputs
init|;
name|i
condition|;
name|i
operator|=
name|TREE_CHAIN
argument_list|(
name|i
argument_list|)
control|)
block|{
name|tree
name|i_name
init|=
name|TREE_PURPOSE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|i_name
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
name|TREE_CHAIN
argument_list|(
name|i
argument_list|)
init|;
name|j
condition|;
name|j
operator|=
name|TREE_CHAIN
argument_list|(
name|j
argument_list|)
control|)
if|if
condition|(
name|i_name
operator|==
name|TREE_PURPOSE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|j
argument_list|)
argument_list|)
condition|)
goto|goto
name|failure
goto|;
block|}
for|for
control|(
name|i
operator|=
name|inputs
init|;
name|i
condition|;
name|i
operator|=
name|TREE_CHAIN
argument_list|(
name|i
argument_list|)
control|)
block|{
name|tree
name|i_name
init|=
name|TREE_PURPOSE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|i_name
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
name|TREE_CHAIN
argument_list|(
name|i
argument_list|)
init|;
name|j
condition|;
name|j
operator|=
name|TREE_CHAIN
argument_list|(
name|j
argument_list|)
control|)
if|if
condition|(
name|i_name
operator|==
name|TREE_PURPOSE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|j
argument_list|)
argument_list|)
condition|)
goto|goto
name|failure
goto|;
for|for
control|(
name|j
operator|=
name|outputs
init|;
name|j
condition|;
name|j
operator|=
name|TREE_CHAIN
argument_list|(
name|j
argument_list|)
control|)
if|if
condition|(
name|i_name
operator|==
name|TREE_PURPOSE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|j
argument_list|)
argument_list|)
condition|)
goto|goto
name|failure
goto|;
block|}
return|return
name|true
return|;
name|failure
label|:
name|error
argument_list|(
literal|"duplicate asm operand name '%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of expand_asm_operands.  Resolve the names of the operands    in *POUTPUTS and *PINPUTS to numbers, and replace the name expansions in    STRING and in the constraints to those numbers.  */
end_comment

begin_function
specifier|static
name|tree
name|resolve_operand_names
parameter_list|(
name|string
parameter_list|,
name|outputs
parameter_list|,
name|inputs
parameter_list|,
name|pconstraints
parameter_list|)
name|tree
name|string
decl_stmt|;
name|tree
name|outputs
decl_stmt|,
name|inputs
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pconstraints
decl_stmt|;
block|{
name|char
modifier|*
name|buffer
init|=
name|xstrdup
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|string
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* Assume that we will not need extra space to perform the substitution.      This because we get to remove '[' and ']', which means we cannot have      a problem until we have more than 999 operands.  */
name|p
operator|=
name|buffer
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'%'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'['
condition|)
name|p
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ISALPHA
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'['
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
else|else
block|{
name|p
operator|+=
literal|1
expr_stmt|;
continue|continue;
block|}
name|p
operator|=
name|resolve_operand_name_1
argument_list|(
name|p
argument_list|,
name|outputs
argument_list|,
name|inputs
argument_list|)
expr_stmt|;
block|}
name|string
operator|=
name|build_string
argument_list|(
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* Collect output constraints here because it's convenient.      There should be no named operands here; this is verified      in expand_asm_operand.  */
for|for
control|(
name|t
operator|=
name|outputs
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|,
name|pconstraints
operator|++
control|)
operator|*
name|pconstraints
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Substitute [<name>] in input constraint strings.  */
for|for
control|(
name|t
operator|=
name|inputs
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|,
name|pconstraints
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|c
init|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|c
argument_list|,
literal|'['
argument_list|)
operator|==
name|NULL
condition|)
operator|*
name|pconstraints
operator|=
name|c
expr_stmt|;
else|else
block|{
name|p
operator|=
name|buffer
operator|=
name|xstrdup
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'['
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|p
operator|=
name|resolve_operand_name_1
argument_list|(
name|p
argument_list|,
name|outputs
argument_list|,
name|inputs
argument_list|)
expr_stmt|;
operator|*
name|pconstraints
operator|=
name|ggc_alloc_string
argument_list|(
name|buffer
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of resolve_operand_names.  P points to the '[' for a    potential named operand of the form [<name>].  In place, replace    the name and brackets with a number.  Return a pointer to the     balance of the string after substitution.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|resolve_operand_name_1
parameter_list|(
name|p
parameter_list|,
name|outputs
parameter_list|,
name|inputs
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|tree
name|outputs
decl_stmt|,
name|inputs
decl_stmt|;
block|{
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|op
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/* Collect the operand name.  */
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
condition|)
block|{
name|error
argument_list|(
literal|"missing close brace for named operand"
argument_list|)
expr_stmt|;
return|return
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\0'
argument_list|)
return|;
block|}
name|len
operator|=
name|q
operator|-
name|p
operator|-
literal|1
expr_stmt|;
comment|/* Resolve the name to a number.  */
for|for
control|(
name|op
operator|=
literal|0
operator|,
name|t
operator|=
name|outputs
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|,
name|op
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|c
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|c
argument_list|,
name|p
operator|+
literal|1
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
name|c
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
goto|goto
name|found
goto|;
block|}
for|for
control|(
name|t
operator|=
name|inputs
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|,
name|op
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|c
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|c
argument_list|,
name|p
operator|+
literal|1
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
name|c
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
goto|goto
name|found
goto|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|error
argument_list|(
literal|"undefined named operand '%s'"
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|op
operator|=
literal|0
expr_stmt|;
name|found
label|:
comment|/* Replace the name with the number.  Unfortunately, not all libraries      get the return value of sprintf correct, so search for the end of the      generated string by hand.  */
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%d"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* Verify the no extra buffer space assumption.  */
if|if
condition|(
name|p
operator|>
name|q
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Shift the rest of the buffer down to fill the gap.  */
name|memmove
argument_list|(
name|p
argument_list|,
name|q
operator|+
literal|1
argument_list|,
name|strlen
argument_list|(
name|q
operator|+
literal|1
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL to evaluate the expression EXP    and remember it in case this is the VALUE in a ({... VALUE; }) constr.    Provided just for backward-compatibility.  expand_expr_stmt_value()    should be used for new code.  */
end_comment

begin_function
name|void
name|expand_expr_stmt
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|expand_expr_stmt_value
argument_list|(
name|exp
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL to evaluate the expression EXP.  WANT_VALUE tells    whether to (1) save the value of the expression, (0) discard it or    (-1) use expr_stmts_for_value to tell.  The use of -1 is    deprecated, and retained only for backward compatibility.  */
end_comment

begin_function
name|void
name|expand_expr_stmt_value
parameter_list|(
name|exp
parameter_list|,
name|want_value
parameter_list|,
name|maybe_last
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|int
name|want_value
decl_stmt|,
name|maybe_last
decl_stmt|;
block|{
name|rtx
name|value
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|want_value
operator|==
operator|-
literal|1
condition|)
name|want_value
operator|=
name|expr_stmts_for_value
operator|!=
literal|0
expr_stmt|;
comment|/* If -W, warn about statements with no side effects,      except for an explicit cast to void (e.g. for assert()), and      except for last statement in ({...}) where they may be useful.  */
if|if
condition|(
operator|!
name|want_value
operator|&&
operator|(
name|expr_stmts_for_value
operator|==
literal|0
operator|||
operator|!
name|maybe_last
operator|)
operator|&&
name|exp
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|exp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|extra_warnings
operator|||
name|warn_unused_value
operator|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONVERT_EXPR
operator|&&
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|)
condition|)
name|warning_with_file_and_line
argument_list|(
name|emit_filename
argument_list|,
name|emit_lineno
argument_list|,
literal|"statement with no effect"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|warn_unused_value
condition|)
name|warn_if_unused_value
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
comment|/* If EXP is of function type and we are expanding statements for      value, convert it to pointer-to-function.  */
if|if
condition|(
name|want_value
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|exp
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
comment|/* The call to `expand_expr' could cause last_expr_type and      last_expr_value to get reset.  Therefore, we set last_expr_value      and last_expr_type *after* calling expand_expr.  */
name|value
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|want_value
condition|?
name|NULL_RTX
else|:
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* If all we do is reference a volatile value in memory,      copy it to a register to be sure it is actually touched.  */
if|if
condition|(
name|value
operator|&&
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|MEM
operator|&&
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOIDmode
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|BLKmode
condition|)
name|value
operator|=
name|copy_to_reg
argument_list|(
name|value
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|lab
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
comment|/* Compare the value with itself to reference it.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|value
argument_list|,
name|value
argument_list|,
name|EQ
argument_list|,
name|expand_expr
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|BLKmode
argument_list|,
literal|0
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|lab
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this expression is part of a ({...}) and is in memory, we may have      to preserve temporaries.  */
name|preserve_temp_slots
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Free any temporaries used to evaluate this expression.  Any temporary      used as a result of this expression will already have been preserved      above.  */
name|free_temp_slots
argument_list|()
expr_stmt|;
if|if
condition|(
name|want_value
condition|)
block|{
name|last_expr_value
operator|=
name|value
expr_stmt|;
name|last_expr_type
operator|=
name|type
expr_stmt|;
block|}
name|emit_queue
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Warn if EXP contains any computations whose results are not used.    Return 1 if a warning is printed; 0 otherwise.  */
end_comment

begin_function
name|int
name|warn_if_unused_value
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|TREE_USED
argument_list|(
name|exp
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Don't warn about void constructs.  This includes casting to void,      void function calls, and statement expressions with a final cast      to void.  */
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If this is an expression with side effects, don't warn.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|exp
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
case|case
name|INIT_EXPR
case|:
case|case
name|TARGET_EXPR
case|:
case|case
name|CALL_EXPR
case|:
case|case
name|METHOD_CALL_EXPR
case|:
case|case
name|RTL_EXPR
case|:
case|case
name|TRY_CATCH_EXPR
case|:
case|case
name|WITH_CLEANUP_EXPR
case|:
case|case
name|EXIT_EXPR
case|:
return|return
literal|0
return|;
case|case
name|BIND_EXPR
case|:
comment|/* For a binding, warn if no side effect within it.  */
return|return
name|warn_if_unused_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|SAVE_EXPR
case|:
return|return
name|warn_if_unused_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
comment|/* In&& or ||, warn if 2nd operand has no side effect.  */
return|return
name|warn_if_unused_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|COMPOUND_EXPR
case|:
if|if
condition|(
name|TREE_NO_UNUSED_WARNING
argument_list|(
name|exp
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|warn_if_unused_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Let people do `(foo (), 0)' without a warning.  */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|warn_if_unused_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
comment|/* Don't warn about conversions not explicit in the user's program.  */
if|if
condition|(
name|TREE_NO_UNUSED_WARNING
argument_list|(
name|exp
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Assignment to a cast usually results in a cast of a modify. 	 Don't complain about that.  There can be an arbitrary number of 	 casts before the modify, so we must loop until we find the first 	 non-cast expression and then test to see if that is a modify.  */
block|{
name|tree
name|tem
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|MODIFY_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|INIT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CALL_EXPR
condition|)
return|return
literal|0
return|;
block|}
goto|goto
name|warn
goto|;
case|case
name|INDIRECT_REF
case|:
comment|/* Don't warn about automatic dereferencing of references, since 	 the user cannot control it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
return|return
name|warn_if_unused_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Fall through.  */
default|default:
comment|/* Referencing a volatile value is a side effect, so don't warn.  */
if|if
condition|(
operator|(
name|DECL_P
argument_list|(
name|exp
argument_list|)
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|'r'
operator|)
operator|&&
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If this is an expression which has no operands, there is no value 	 to be unused.  There are no such language-independent codes, 	 but front ends may define such.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|'e'
operator|&&
name|TREE_CODE_LENGTH
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|warn
label|:
name|warning_with_file_and_line
argument_list|(
name|emit_filename
argument_list|,
name|emit_lineno
argument_list|,
literal|"value computed is not used"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Clear out the memory of the last expression evaluated.  */
end_comment

begin_function
name|void
name|clear_last_expr
parameter_list|()
block|{
name|last_expr_type
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a statement which will return a value.    Return the RTL_EXPR for this statement expr.    The caller must save that value and pass it to expand_end_stmt_expr.  */
end_comment

begin_function
name|tree
name|expand_start_stmt_expr
parameter_list|()
block|{
name|tree
name|t
decl_stmt|;
comment|/* Make the RTL_EXPR node temporary, not momentary,      so that rtl_expr_chain doesn't become garbage.  */
name|t
operator|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|start_sequence_for_rtl_expr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
name|expr_stmts_for_value
operator|++
expr_stmt|;
name|last_expr_value
operator|=
name|NULL_RTX
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Restore the previous state at the end of a statement that returns a value.    Returns a tree node representing the statement's value and the    insns to compute the value.     The nodes of that expression have been freed by now, so we cannot use them.    But we don't want to do that anyway; the expression has already been    evaluated and now we just want to use the value.  So generate a RTL_EXPR    with the proper type and RTL value.     If the last substatement was not an expression,    return something with type `void'.  */
end_comment

begin_function
name|tree
name|expand_end_stmt_expr
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|OK_DEFER_POP
expr_stmt|;
if|if
condition|(
operator|!
name|last_expr_value
operator|||
operator|!
name|last_expr_type
condition|)
block|{
name|last_expr_value
operator|=
name|const0_rtx
expr_stmt|;
name|last_expr_type
operator|=
name|void_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|last_expr_value
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|last_expr_value
argument_list|)
condition|)
comment|/* Remove any possible QUEUED.  */
name|last_expr_value
operator|=
name|protect_from_queue
argument_list|(
name|last_expr_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|last_expr_type
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|t
argument_list|)
operator|=
name|last_expr_value
expr_stmt|;
name|RTL_EXPR_SEQUENCE
argument_list|(
name|t
argument_list|)
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|rtl_expr_chain
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|rtl_expr_chain
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Don't consider deleting this expr or containing exprs at tree level.  */
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Propagate volatility of the actual RTL expr.  */
name|TREE_THIS_VOLATILE
argument_list|(
name|t
argument_list|)
operator|=
name|volatile_refs_p
argument_list|(
name|last_expr_value
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
name|expr_stmts_for_value
operator|--
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL for the start of an if-then.  COND is the expression    whose truth should be tested.     If EXITFLAG is nonzero, this conditional is visible to    `exit_something'.  */
end_comment

begin_function
name|void
name|expand_start_cond
parameter_list|(
name|cond
parameter_list|,
name|exitflag
parameter_list|)
name|tree
name|cond
decl_stmt|;
name|int
name|exitflag
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thiscond
init|=
name|ALLOC_NESTING
argument_list|()
decl_stmt|;
comment|/* Make an entry on cond_stack for the cond we are entering.  */
name|thiscond
operator|->
name|next
operator|=
name|cond_stack
expr_stmt|;
name|thiscond
operator|->
name|all
operator|=
name|nesting_stack
expr_stmt|;
name|thiscond
operator|->
name|depth
operator|=
operator|++
name|nesting_depth
expr_stmt|;
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* Before we encounter an `else', we don't need a separate exit label      unless there are supposed to be exit statements      to exit this conditional.  */
name|thiscond
operator|->
name|exit_label
operator|=
name|exitflag
condition|?
name|gen_label_rtx
argument_list|()
else|:
literal|0
expr_stmt|;
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
operator|=
name|thiscond
operator|->
name|exit_label
expr_stmt|;
name|cond_stack
operator|=
name|thiscond
expr_stmt|;
name|nesting_stack
operator|=
name|thiscond
expr_stmt|;
name|do_jump
argument_list|(
name|cond
argument_list|,
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL between then-clause and the elseif-clause    of an if-then-elseif-....  */
end_comment

begin_function
name|void
name|expand_start_elseif
parameter_list|(
name|cond
parameter_list|)
name|tree
name|cond
decl_stmt|;
block|{
if|if
condition|(
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
operator|==
literal|0
condition|)
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_jump
argument_list|(
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
argument_list|)
expr_stmt|;
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|cond
argument_list|,
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL between the then-clause and the else-clause    of an if-then-else.  */
end_comment

begin_function
name|void
name|expand_start_else
parameter_list|()
block|{
if|if
condition|(
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
operator|==
literal|0
condition|)
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_jump
argument_list|(
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
argument_list|)
expr_stmt|;
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
operator|=
literal|0
expr_stmt|;
comment|/* No more _else or _elseif calls.  */
block|}
end_function

begin_comment
comment|/* After calling expand_start_else, turn this "else" into an "else if"    by providing another condition.  */
end_comment

begin_function
name|void
name|expand_elseif
parameter_list|(
name|cond
parameter_list|)
name|tree
name|cond
decl_stmt|;
block|{
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|cond
argument_list|,
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL for the end of an if-then.    Pop the record for it off of cond_stack.  */
end_comment

begin_function
name|void
name|expand_end_cond
parameter_list|()
block|{
name|struct
name|nesting
modifier|*
name|thiscond
init|=
name|cond_stack
decl_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
if|if
condition|(
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
condition|)
name|emit_label
argument_list|(
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
condition|)
name|emit_label
argument_list|(
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
argument_list|)
expr_stmt|;
name|POPSTACK
argument_list|(
name|cond_stack
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL for the start of a loop.  EXIT_FLAG is nonzero if this    loop should be exited by `exit_something'.  This is a loop for which    `expand_continue' will jump to the top of the loop.     Make an entry on loop_stack to record the labels associated with    this loop.  */
end_comment

begin_function
name|struct
name|nesting
modifier|*
name|expand_start_loop
parameter_list|(
name|exit_flag
parameter_list|)
name|int
name|exit_flag
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thisloop
init|=
name|ALLOC_NESTING
argument_list|()
decl_stmt|;
comment|/* Make an entry on loop_stack for the loop we are entering.  */
name|thisloop
operator|->
name|next
operator|=
name|loop_stack
expr_stmt|;
name|thisloop
operator|->
name|all
operator|=
name|nesting_stack
expr_stmt|;
name|thisloop
operator|->
name|depth
operator|=
operator|++
name|nesting_depth
expr_stmt|;
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|alt_end_label
operator|=
literal|0
expr_stmt|;
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|continue_label
operator|=
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
expr_stmt|;
name|thisloop
operator|->
name|exit_label
operator|=
name|exit_flag
condition|?
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
else|:
literal|0
expr_stmt|;
name|loop_stack
operator|=
name|thisloop
expr_stmt|;
name|nesting_stack
operator|=
name|thisloop
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_LOOP_BEG
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
argument_list|)
expr_stmt|;
return|return
name|thisloop
return|;
block|}
end_function

begin_comment
comment|/* Like expand_start_loop but for a loop where the continuation point    (for expand_continue_loop) will be specified explicitly.  */
end_comment

begin_function
name|struct
name|nesting
modifier|*
name|expand_start_loop_continue_elsewhere
parameter_list|(
name|exit_flag
parameter_list|)
name|int
name|exit_flag
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thisloop
init|=
name|expand_start_loop
argument_list|(
name|exit_flag
argument_list|)
decl_stmt|;
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|continue_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
return|return
name|thisloop
return|;
block|}
end_function

begin_comment
comment|/* Begin a null, aka do { } while (0) "loop".  But since the contents    of said loop can still contain a break, we must frob the loop nest.  */
end_comment

begin_function
name|struct
name|nesting
modifier|*
name|expand_start_null_loop
parameter_list|()
block|{
name|struct
name|nesting
modifier|*
name|thisloop
init|=
name|ALLOC_NESTING
argument_list|()
decl_stmt|;
comment|/* Make an entry on loop_stack for the loop we are entering.  */
name|thisloop
operator|->
name|next
operator|=
name|loop_stack
expr_stmt|;
name|thisloop
operator|->
name|all
operator|=
name|nesting_stack
expr_stmt|;
name|thisloop
operator|->
name|depth
operator|=
operator|++
name|nesting_depth
expr_stmt|;
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
operator|=
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|alt_end_label
operator|=
name|NULL_RTX
expr_stmt|;
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|continue_label
operator|=
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
expr_stmt|;
name|thisloop
operator|->
name|exit_label
operator|=
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
expr_stmt|;
name|loop_stack
operator|=
name|thisloop
expr_stmt|;
name|nesting_stack
operator|=
name|thisloop
expr_stmt|;
return|return
name|thisloop
return|;
block|}
end_function

begin_comment
comment|/* Specify the continuation point for a loop started with    expand_start_loop_continue_elsewhere.    Use this at the point in the code to which a continue statement    should jump.  */
end_comment

begin_function
name|void
name|expand_loop_continue_here
parameter_list|()
block|{
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_LOOP_CONT
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|continue_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a loop.  Generate a jump back to the top and the loop-exit label.    Pop the block off of loop_stack.  */
end_comment

begin_function
name|void
name|expand_end_loop
parameter_list|()
block|{
name|rtx
name|start_label
init|=
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
decl_stmt|;
name|rtx
name|etc_note
decl_stmt|;
name|int
name|eh_regions
decl_stmt|,
name|debug_blocks
decl_stmt|;
comment|/* Mark the continue-point at the top of the loop if none elsewhere.  */
if|if
condition|(
name|start_label
operator|==
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|continue_label
condition|)
name|emit_note_before
argument_list|(
name|NOTE_INSN_LOOP_CONT
argument_list|,
name|start_label
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* If the loop starts with a loop exit, roll that to the end where      it will optimize together with the jump back.       If the loop presently looks like this (in pseudo-C):  	LOOP_BEG 	start_label: 	  if (test) goto end_label; 	LOOP_END_TOP_COND 	  body; 	  goto start_label; 	end_label:       transform it to look like:  	LOOP_BEG 	  goto start_label; 	top_label: 	  body; 	start_label: 	  if (test) goto end_label; 	  goto top_label; 	end_label:       We rely on the presence of NOTE_INSN_LOOP_END_TOP_COND to mark      the end of the entry condtional.  Without this, our lexical scan      can't tell the difference between an entry conditional and a      body conditional that exits the loop.  Mistaking the two means      that we can misplace the NOTE_INSN_LOOP_CONT note, which can       screw up loop unrolling.       Things will be oh so much better when loop optimization is done      off of a proper control flow graph...  */
comment|/* Scan insns from the top of the loop looking for the END_TOP_COND note.  */
name|eh_regions
operator|=
name|debug_blocks
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|etc_note
operator|=
name|start_label
init|;
name|etc_note
condition|;
name|etc_note
operator|=
name|NEXT_INSN
argument_list|(
name|etc_note
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|etc_note
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|etc_note
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END_TOP_COND
condition|)
break|break;
comment|/* We must not walk into a nested loop.  */
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|etc_note
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
block|{
name|etc_note
operator|=
name|NULL_RTX
expr_stmt|;
break|break;
block|}
comment|/* At the same time, scan for EH region notes, as we don't want 	   to scrog region nesting.  This shouldn't happen, but...  */
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|etc_note
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_BEG
condition|)
name|eh_regions
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|etc_note
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_END
condition|)
block|{
if|if
condition|(
operator|--
name|eh_regions
operator|<
literal|0
condition|)
comment|/* We've come to the end of an EH region, but never saw the 		 beginning of that region.  That means that an EH region 		 begins before the top of the loop, and ends in the middle 		 of it.  The existence of such a situation violates a basic 		 assumption in this code, since that would imply that even 		 when EH_REGIONS is zero, we might move code out of an 		 exception region.  */
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Likewise for debug scopes.  In this case we'll either (1) move 	   all of the notes if they are properly nested or (2) leave the 	   notes alone and only rotate the loop at high optimization  	   levels when we expect to scrog debug info.  */
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|etc_note
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
condition|)
name|debug_blocks
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|etc_note
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_END
condition|)
name|debug_blocks
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|etc_note
operator|&&
name|optimize
operator|&&
name|eh_regions
operator|==
literal|0
operator|&&
operator|(
name|debug_blocks
operator|==
literal|0
operator|||
name|optimize
operator|>=
literal|2
operator|)
operator|&&
name|NEXT_INSN
argument_list|(
name|etc_note
argument_list|)
operator|!=
name|NULL_RTX
operator|&&
operator|!
name|any_condjump_p
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
condition|)
block|{
comment|/* We found one.  Move everything from START to ETC to the end 	 of the loop, and add a jump from the top of the loop.  */
name|rtx
name|top_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|start_move
init|=
name|start_label
decl_stmt|;
comment|/* If the start label is preceded by a NOTE_INSN_LOOP_CONT note, 	 then we want to move this note also.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|start_move
argument_list|)
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|PREV_INSN
argument_list|(
name|start_move
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_LOOP_CONT
condition|)
name|start_move
operator|=
name|PREV_INSN
argument_list|(
name|start_move
argument_list|)
expr_stmt|;
name|emit_label_before
argument_list|(
name|top_label
argument_list|,
name|start_move
argument_list|)
expr_stmt|;
comment|/* Actually move the insns.  If the debug scopes are nested, we 	 can move everything at once.  Otherwise we have to move them 	 one by one and squeeze out the block notes.  */
if|if
condition|(
name|debug_blocks
operator|==
literal|0
condition|)
name|reorder_insns
argument_list|(
name|start_move
argument_list|,
name|etc_note
argument_list|,
name|get_last_insn
argument_list|()
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|insn
decl_stmt|,
name|next_insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|start_move
init|;
name|insn
condition|;
name|insn
operator|=
name|next_insn
control|)
block|{
comment|/* Figure out which insn comes after this one.  We have 		 to do this before we move INSN.  */
name|next_insn
operator|=
operator|(
name|insn
operator|==
name|etc_note
condition|?
name|NULL
else|:
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_END
operator|)
condition|)
continue|continue;
name|reorder_insns
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|,
name|get_last_insn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Add the jump from the top of the loop.  */
name|emit_jump_insn_before
argument_list|(
name|gen_jump
argument_list|(
name|start_label
argument_list|)
argument_list|,
name|top_label
argument_list|)
expr_stmt|;
name|emit_barrier_before
argument_list|(
name|top_label
argument_list|)
expr_stmt|;
name|start_label
operator|=
name|top_label
expr_stmt|;
block|}
name|emit_jump
argument_list|(
name|start_label
argument_list|)
expr_stmt|;
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_LOOP_END
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
argument_list|)
expr_stmt|;
name|POPSTACK
argument_list|(
name|loop_stack
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a null loop, aka do { } while (0).  */
end_comment

begin_function
name|void
name|expand_end_null_loop
parameter_list|()
block|{
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
argument_list|)
expr_stmt|;
name|POPSTACK
argument_list|(
name|loop_stack
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a jump to the current loop's continue-point.    This is usually the top of the loop, but may be specified    explicitly elsewhere.  If not currently inside a loop,    return 0 and do nothing; caller will print an error message.  */
end_comment

begin_function
name|int
name|expand_continue_loop
parameter_list|(
name|whichloop
parameter_list|)
name|struct
name|nesting
modifier|*
name|whichloop
decl_stmt|;
block|{
name|last_expr_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|whichloop
operator|==
literal|0
condition|)
name|whichloop
operator|=
name|loop_stack
expr_stmt|;
if|if
condition|(
name|whichloop
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|expand_goto_internal
argument_list|(
name|NULL_TREE
argument_list|,
name|whichloop
operator|->
name|data
operator|.
name|loop
operator|.
name|continue_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Generate a jump to exit the current loop.  If not currently inside a loop,    return 0 and do nothing; caller will print an error message.  */
end_comment

begin_function
name|int
name|expand_exit_loop
parameter_list|(
name|whichloop
parameter_list|)
name|struct
name|nesting
modifier|*
name|whichloop
decl_stmt|;
block|{
name|last_expr_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|whichloop
operator|==
literal|0
condition|)
name|whichloop
operator|=
name|loop_stack
expr_stmt|;
if|if
condition|(
name|whichloop
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|expand_goto_internal
argument_list|(
name|NULL_TREE
argument_list|,
name|whichloop
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Generate a conditional jump to exit the current loop if COND    evaluates to zero.  If not currently inside a loop,    return 0 and do nothing; caller will print an error message.  */
end_comment

begin_function
name|int
name|expand_exit_loop_if_false
parameter_list|(
name|whichloop
parameter_list|,
name|cond
parameter_list|)
name|struct
name|nesting
modifier|*
name|whichloop
decl_stmt|;
name|tree
name|cond
decl_stmt|;
block|{
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|last_insn
decl_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|whichloop
operator|==
literal|0
condition|)
name|whichloop
operator|=
name|loop_stack
expr_stmt|;
if|if
condition|(
name|whichloop
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* In order to handle fixups, we actually create a conditional jump      around an unconditional branch to exit the loop.  If fixups are      necessary, they go before the unconditional branch.  */
name|do_jump
argument_list|(
name|cond
argument_list|,
name|NULL_RTX
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|last_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|last_insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|whichloop
operator|->
name|data
operator|.
name|loop
operator|.
name|alt_end_label
operator|=
name|last_insn
expr_stmt|;
name|expand_goto_internal
argument_list|(
name|NULL_TREE
argument_list|,
name|whichloop
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Like expand_exit_loop_if_false except also emit a note marking    the end of the conditional.  Should only be used immediately     after expand_loop_start.  */
end_comment

begin_function
name|int
name|expand_exit_loop_top_cond
parameter_list|(
name|whichloop
parameter_list|,
name|cond
parameter_list|)
name|struct
name|nesting
modifier|*
name|whichloop
decl_stmt|;
name|tree
name|cond
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|expand_exit_loop_if_false
argument_list|(
name|whichloop
argument_list|,
name|cond
argument_list|)
condition|)
return|return
literal|0
return|;
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_LOOP_END_TOP_COND
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the loop nest is empty.  Else return zero.  */
end_comment

begin_function
name|int
name|stmt_loop_nest_empty
parameter_list|()
block|{
comment|/* cfun->stmt can be NULL if we are building a call to get the      EH context for a setjmp/longjmp EH target and the current      function was a deferred inline function.  */
return|return
operator|(
name|cfun
operator|->
name|stmt
operator|==
name|NULL
operator|||
name|loop_stack
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if we should preserve sub-expressions as separate    pseudos.  We never do so if we aren't optimizing.  We always do so    if -fexpensive-optimizations.     Otherwise, we only do so if we are in the "early" part of a loop.  I.e.,    the loop may still be a small one.  */
end_comment

begin_function
name|int
name|preserve_subexpressions_p
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|flag_expensive_optimizations
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|optimize
operator|==
literal|0
operator|||
name|cfun
operator|==
literal|0
operator|||
name|cfun
operator|->
name|stmt
operator|==
literal|0
operator|||
name|loop_stack
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|insn
operator|=
name|get_last_insn_anywhere
argument_list|()
expr_stmt|;
return|return
operator|(
name|insn
operator|&&
operator|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|-
name|INSN_UID
argument_list|(
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
argument_list|)
operator|<
name|n_non_fixed_regs
operator|*
literal|3
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Generate a jump to exit the current loop, conditional, binding contour    or case statement.  Not all such constructs are visible to this function,    only those started with EXIT_FLAG nonzero.  Individual languages use    the EXIT_FLAG parameter to control which kinds of constructs you can    exit this way.     If not currently inside anything that can be exited,    return 0 and do nothing; caller will print an error message.  */
end_comment

begin_function
name|int
name|expand_exit_something
parameter_list|()
block|{
name|struct
name|nesting
modifier|*
name|n
decl_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|nesting_stack
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|all
control|)
if|if
condition|(
name|n
operator|->
name|exit_label
operator|!=
literal|0
condition|)
block|{
name|expand_goto_internal
argument_list|(
name|NULL_TREE
argument_list|,
name|n
operator|->
name|exit_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL to return from the current function, with no value.    (That is, we do not do anything about returning any value.)  */
end_comment

begin_function
name|void
name|expand_null_return
parameter_list|()
block|{
name|rtx
name|last_insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
comment|/* If this function was declared to return a value, but we      didn't, clobber the return registers so that they are not      propagated live to the rest of the function.  */
name|clobber_return_register
argument_list|()
expr_stmt|;
name|expand_null_return_1
argument_list|(
name|last_insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL to return from the current function, with value VAL.  */
end_comment

begin_function
specifier|static
name|void
name|expand_value_return
parameter_list|(
name|val
parameter_list|)
name|rtx
name|val
decl_stmt|;
block|{
name|rtx
name|last_insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|return_reg
init|=
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Copy the value to the return location      unless it's already there.  */
if|if
condition|(
name|return_reg
operator|!=
name|val
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_FUNCTION_RETURN
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|old_mode
init|=
name|DECL_MODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|promote_mode
argument_list|(
name|type
argument_list|,
name|old_mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|old_mode
condition|)
name|val
operator|=
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|old_mode
argument_list|,
name|val
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|GET_CODE
argument_list|(
name|return_reg
argument_list|)
operator|==
name|PARALLEL
condition|)
name|emit_group_load
argument_list|(
name|return_reg
argument_list|,
name|val
argument_list|,
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|return_reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|expand_null_return_1
argument_list|(
name|last_insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a return with no value.  If LAST_INSN is nonzero,    pretend that the return takes place after LAST_INSN.  */
end_comment

begin_function
specifier|static
name|void
name|expand_null_return_1
parameter_list|(
name|last_insn
parameter_list|)
name|rtx
name|last_insn
decl_stmt|;
block|{
name|rtx
name|end_label
init|=
name|cleanup_label
condition|?
name|cleanup_label
else|:
name|return_label
decl_stmt|;
name|clear_pending_stack_adjust
argument_list|()
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|end_label
operator|==
literal|0
condition|)
name|end_label
operator|=
name|return_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|expand_goto_internal
argument_list|(
name|NULL_TREE
argument_list|,
name|end_label
argument_list|,
name|last_insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL to evaluate the expression RETVAL and return it    from the current function.  */
end_comment

begin_function
name|void
name|expand_return
parameter_list|(
name|retval
parameter_list|)
name|tree
name|retval
decl_stmt|;
block|{
comment|/* If there are any cleanups to be performed, then they will      be inserted following LAST_INSN.  It is desirable      that the last_insn, for such purposes, should be the      last insn before computing the return value.  Otherwise, cleanups      which call functions can clobber the return value.  */
comment|/* ??? rms: I think that is erroneous, because in C++ it would      run destructors on variables that might be used in the subsequent      computation of the return value.  */
name|rtx
name|last_insn
init|=
literal|0
decl_stmt|;
name|rtx
name|result_rtl
decl_stmt|;
name|rtx
name|val
init|=
literal|0
decl_stmt|;
name|tree
name|retval_rhs
decl_stmt|;
comment|/* If function wants no value, give it none.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|expand_expr
argument_list|(
name|retval
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|expand_null_return
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|retval
operator|==
name|error_mark_node
condition|)
block|{
comment|/* Treat this like a return of no value from a function that 	 returns a value.  */
name|expand_null_return
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|==
name|RESULT_DECL
condition|)
name|retval_rhs
operator|=
name|retval
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|==
name|MODIFY_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|==
name|INIT_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|retval
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|RESULT_DECL
condition|)
name|retval_rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|retval
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval
argument_list|)
argument_list|)
condition|)
comment|/* Recognize tail-recursive call to void function.  */
name|retval_rhs
operator|=
name|retval
expr_stmt|;
else|else
name|retval_rhs
operator|=
name|NULL_TREE
expr_stmt|;
name|last_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Distribute return down conditional expr if either of the sides      may involve tail recursion (see test below).  This enhances the number      of tail recursions we see.  Don't do this always since it can produce      sub-optimal code in some cases and we distribute assignments into      conditional expressions when it would help.  */
if|if
condition|(
name|optimize
operator|&&
name|retval_rhs
operator|!=
literal|0
operator|&&
name|frame_offset
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|retval_rhs
argument_list|)
operator|==
name|COND_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|retval_rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CALL_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|retval_rhs
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CALL_EXPR
operator|)
condition|)
block|{
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|retval_rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
name|expr
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|,
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|retval_rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_return
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|,
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|retval_rhs
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_return
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|end_cleanup_deferral
argument_list|()
expr_stmt|;
return|return;
block|}
name|result_rtl
operator|=
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the result is an aggregate that is being returned in one (or more)      registers, load the registers here.  The compiler currently can't handle      copying a BLKmode value into registers.  We could put this code in a      more general area (for use by everyone instead of just function      call/return), but until this feature is generally usable it is kept here      (and in expand_call).  The value must go into a pseudo in case there      are cleanups that will clobber the real return register.  */
if|if
condition|(
name|retval_rhs
operator|!=
literal|0
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval_rhs
argument_list|)
argument_list|)
operator|==
name|BLKmode
operator|&&
name|GET_CODE
argument_list|(
name|result_rtl
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|bitpos
decl_stmt|,
name|xbitpos
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|big_endian_correction
init|=
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|bytes
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval_rhs
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|n_regs
init|=
operator|(
name|bytes
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
name|unsigned
name|int
name|bitsize
init|=
name|MIN
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval_rhs
argument_list|)
argument_list|)
argument_list|,
name|BITS_PER_WORD
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|result_pseudos
init|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
operator|*
name|n_regs
argument_list|)
decl_stmt|;
name|rtx
name|result_reg
decl_stmt|,
name|src
init|=
name|NULL_RTX
decl_stmt|,
name|dst
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|result_val
init|=
name|expand_expr
argument_list|(
name|retval_rhs
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmpmode
decl_stmt|,
name|result_reg_mode
decl_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|0
condition|)
block|{
name|expand_null_return
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Structures whose size is not a multiple of a word are aligned 	 to the least significant byte (to the right).  On a BYTES_BIG_ENDIAN 	 machine, this means we must skip the empty high order bytes when 	 calculating the bit offset.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
operator|!
name|FUNCTION_ARG_REG_LITTLE_ENDIAN
operator|&&
name|bytes
operator|%
name|UNITS_PER_WORD
condition|)
name|big_endian_correction
operator|=
operator|(
name|BITS_PER_WORD
operator|-
operator|(
operator|(
name|bytes
operator|%
name|UNITS_PER_WORD
operator|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
comment|/* Copy the structure BITSIZE bits at a time.  */
for|for
control|(
name|bitpos
operator|=
literal|0
operator|,
name|xbitpos
operator|=
name|big_endian_correction
init|;
name|bitpos
operator|<
name|bytes
operator|*
name|BITS_PER_UNIT
condition|;
name|bitpos
operator|+=
name|bitsize
operator|,
name|xbitpos
operator|+=
name|bitsize
control|)
block|{
comment|/* We need a new destination pseudo each time xbitpos is 	     on a word boundary and when xbitpos == big_endian_correction 	     (the first time through).  */
if|if
condition|(
name|xbitpos
operator|%
name|BITS_PER_WORD
operator|==
literal|0
operator|||
name|xbitpos
operator|==
name|big_endian_correction
condition|)
block|{
comment|/* Generate an appropriate register.  */
name|dst
operator|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
expr_stmt|;
name|result_pseudos
index|[
name|xbitpos
operator|/
name|BITS_PER_WORD
index|]
operator|=
name|dst
expr_stmt|;
comment|/* Clear the destination before we move anything into it.  */
name|emit_move_insn
argument_list|(
name|dst
argument_list|,
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We need a new source operand each time bitpos is on a word 	     boundary.  */
if|if
condition|(
name|bitpos
operator|%
name|BITS_PER_WORD
operator|==
literal|0
condition|)
name|src
operator|=
name|operand_subword_force
argument_list|(
name|result_val
argument_list|,
name|bitpos
operator|/
name|BITS_PER_WORD
argument_list|,
name|BLKmode
argument_list|)
expr_stmt|;
comment|/* Use bitpos for the source extraction (left justified) and 	     xbitpos for the destination store (right justified).  */
name|store_bit_field
argument_list|(
name|dst
argument_list|,
name|bitsize
argument_list|,
name|xbitpos
operator|%
name|BITS_PER_WORD
argument_list|,
name|word_mode
argument_list|,
name|extract_bit_field
argument_list|(
name|src
argument_list|,
name|bitsize
argument_list|,
name|bitpos
operator|%
name|BITS_PER_WORD
argument_list|,
literal|1
argument_list|,
name|NULL_RTX
argument_list|,
name|word_mode
argument_list|,
name|word_mode
argument_list|,
name|BITS_PER_WORD
argument_list|)
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
comment|/* Find the smallest integer mode large enough to hold the 	 entire structure and use that mode instead of BLKmode 	 on the USE insn for the return register.  */
for|for
control|(
name|tmpmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|tmpmode
operator|!=
name|VOIDmode
condition|;
name|tmpmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmpmode
argument_list|)
control|)
comment|/* Have we found a large enough mode?  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmpmode
argument_list|)
operator|>=
name|bytes
condition|)
break|break;
comment|/* No suitable mode found.  */
if|if
condition|(
name|tmpmode
operator|==
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|PUT_MODE
argument_list|(
name|result_rtl
argument_list|,
name|tmpmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmpmode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|word_mode
argument_list|)
condition|)
name|result_reg_mode
operator|=
name|word_mode
expr_stmt|;
else|else
name|result_reg_mode
operator|=
name|tmpmode
expr_stmt|;
name|result_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|result_reg_mode
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_regs
condition|;
name|i
operator|++
control|)
name|emit_move_insn
argument_list|(
name|operand_subword
argument_list|(
name|result_reg
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|result_reg_mode
argument_list|)
argument_list|,
name|result_pseudos
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpmode
operator|!=
name|result_reg_mode
condition|)
name|result_reg
operator|=
name|gen_lowpart
argument_list|(
name|tmpmode
argument_list|,
name|result_reg
argument_list|)
expr_stmt|;
name|expand_value_return
argument_list|(
name|result_reg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|retval_rhs
operator|!=
literal|0
operator|&&
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval_rhs
argument_list|)
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|result_rtl
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|result_rtl
argument_list|)
operator|==
name|PARALLEL
operator|)
operator|)
condition|)
block|{
comment|/* Calculate the return value into a temporary (usually a pseudo          reg).  */
name|tree
name|ot
init|=
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|nt
init|=
name|build_qualified_type
argument_list|(
name|ot
argument_list|,
name|TYPE_QUALS
argument_list|(
name|ot
argument_list|)
operator||
name|TYPE_QUAL_CONST
argument_list|)
decl_stmt|;
name|val
operator|=
name|assign_temp
argument_list|(
name|nt
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|val
operator|=
name|expand_expr
argument_list|(
name|retval_rhs
argument_list|,
name|val
argument_list|,
name|GET_MODE
argument_list|(
name|val
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
name|force_not_mem
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* Return the calculated value, doing cleanups first.  */
name|expand_value_return
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No cleanups or no hard reg used; 	 calculate value into hard return reg.  */
name|expand_expr
argument_list|(
name|retval
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|expand_value_return
argument_list|(
name|result_rtl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if the end of the generated RTX is not a barrier.    This means code already compiled can drop through.  */
end_comment

begin_function
name|int
name|drop_through_at_end_p
parameter_list|()
block|{
name|rtx
name|insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
while|while
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Attempt to optimize a potential tail recursion call into a goto.    ARGUMENTS are the arguments to a CALL_EXPR; LAST_INSN indicates    where to place the jump to the tail recursion label.     Return TRUE if the call was optimized into a goto.  */
end_comment

begin_function
name|int
name|optimize_tail_recursion
parameter_list|(
name|arguments
parameter_list|,
name|last_insn
parameter_list|)
name|tree
name|arguments
decl_stmt|;
name|rtx
name|last_insn
decl_stmt|;
block|{
comment|/* Finish checking validity, and if valid emit code to set the      argument variables for the new call.  */
if|if
condition|(
name|tail_recursion_args
argument_list|(
name|arguments
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|tail_recursion_label
operator|==
literal|0
condition|)
block|{
name|tail_recursion_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label_after
argument_list|(
name|tail_recursion_label
argument_list|,
name|tail_recursion_reentry
argument_list|)
expr_stmt|;
block|}
name|emit_queue
argument_list|()
expr_stmt|;
name|expand_goto_internal
argument_list|(
name|NULL_TREE
argument_list|,
name|tail_recursion_label
argument_list|,
name|last_insn
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Emit code to alter this function's formal parms for a tail-recursive call.    ACTUALS is a list of actual parameter expressions (chain of TREE_LISTs).    FORMALS is the chain of decls of formals.    Return 1 if this can be done;    otherwise return 0 and do not emit any code.  */
end_comment

begin_function
specifier|static
name|int
name|tail_recursion_args
parameter_list|(
name|actuals
parameter_list|,
name|formals
parameter_list|)
name|tree
name|actuals
decl_stmt|,
name|formals
decl_stmt|;
block|{
name|tree
name|a
init|=
name|actuals
decl_stmt|,
name|f
init|=
name|formals
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
modifier|*
name|argvec
decl_stmt|;
comment|/* Check that number and types of actuals are compatible      with the formals.  This is not always true in valid C code.      Also check that no formal needs to be addressable      and that all formals are scalars.  */
comment|/* Also count the args.  */
for|for
control|(
name|a
operator|=
name|actuals
operator|,
name|f
operator|=
name|formals
operator|,
name|i
operator|=
literal|0
init|;
name|a
operator|&&
name|f
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
operator|,
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|f
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|f
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|DECL_MODE
argument_list|(
name|f
argument_list|)
operator|==
name|BLKmode
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|a
operator|!=
literal|0
operator|||
name|f
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Compute all the actuals.  */
name|argvec
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|actuals
operator|,
name|i
operator|=
literal|0
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
operator|,
name|i
operator|++
control|)
name|argvec
index|[
name|i
index|]
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Find which actual values refer to current values of previous formals.      Copy each of them now, before any formal is changed.  */
for|for
control|(
name|a
operator|=
name|actuals
operator|,
name|i
operator|=
literal|0
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|int
name|copy
init|=
literal|0
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|f
operator|=
name|formals
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
operator|,
name|j
operator|++
control|)
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|DECL_RTL
argument_list|(
name|f
argument_list|)
argument_list|,
name|argvec
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|copy
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|copy
condition|)
name|argvec
index|[
name|i
index|]
operator|=
name|copy_to_reg
argument_list|(
name|argvec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Store the values of the actuals into the formals.  */
for|for
control|(
name|f
operator|=
name|formals
operator|,
name|a
operator|=
name|actuals
operator|,
name|i
operator|=
literal|0
init|;
name|f
condition|;
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
operator|,
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|f
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|argvec
index|[
name|i
index|]
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|DECL_RTL
argument_list|(
name|f
argument_list|)
argument_list|,
name|argvec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|convert_move
argument_list|(
name|DECL_RTL
argument_list|(
name|f
argument_list|)
argument_list|,
name|argvec
index|[
name|i
index|]
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free_temp_slots
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate the RTL code for entering a binding contour.    The variables are declared one by one, by calls to `expand_decl'.     FLAGS is a bitwise or of the following flags:       1 - Nonzero if this construct should be visible to          `exit_something'.       2 - Nonzero if this contour does not require a 	 NOTE_INSN_BLOCK_BEG note.  Virtually all calls from 	 language-independent code should set this flag because they 	 will not create corresponding BLOCK nodes.  (There should be 	 a one-to-one correspondence between NOTE_INSN_BLOCK_BEG notes 	 and BLOCKs.)  If this flag is set, MARK_ENDS should be zero 	 when expand_end_bindings is called.      If we are creating a NOTE_INSN_BLOCK_BEG note, a BLOCK may     optionally be supplied.  If so, it becomes the NOTE_BLOCK for the     note.  */
end_comment

begin_function
name|void
name|expand_start_bindings_and_block
parameter_list|(
name|flags
parameter_list|,
name|block
parameter_list|)
name|int
name|flags
decl_stmt|;
name|tree
name|block
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thisblock
init|=
name|ALLOC_NESTING
argument_list|()
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|int
name|exit_flag
init|=
operator|(
operator|(
name|flags
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|)
decl_stmt|;
name|int
name|block_flag
init|=
operator|(
operator|(
name|flags
operator|&
literal|2
operator|)
operator|==
literal|0
operator|)
decl_stmt|;
comment|/* If a BLOCK is supplied, then the caller should be requesting a      NOTE_INSN_BLOCK_BEG note.  */
if|if
condition|(
operator|!
name|block_flag
operator|&&
name|block
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Create a note to mark the beginning of the block.  */
if|if
condition|(
name|block_flag
condition|)
block|{
name|note
operator|=
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_BLOCK_BEG
argument_list|)
expr_stmt|;
name|NOTE_BLOCK
argument_list|(
name|note
argument_list|)
operator|=
name|block
expr_stmt|;
block|}
else|else
name|note
operator|=
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
comment|/* Make an entry on block_stack for the block we are entering.  */
name|thisblock
operator|->
name|next
operator|=
name|block_stack
expr_stmt|;
name|thisblock
operator|->
name|all
operator|=
name|nesting_stack
expr_stmt|;
name|thisblock
operator|->
name|depth
operator|=
operator|++
name|nesting_depth
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|=
literal|0
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|=
literal|0
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|n_function_calls
operator|=
literal|0
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|exception_region
operator|=
literal|0
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|block_target_temp_slot_level
operator|=
name|target_temp_slot_level
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|conditional_code
operator|=
literal|0
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|last_unconditional_cleanup
operator|=
name|note
expr_stmt|;
comment|/* When we insert instructions after the last unconditional cleanup,      we don't adjust last_insn.  That means that a later add_insn will      clobber the instructions we've just added.  The easiest way to      fix this is to just insert another instruction here, so that the      instructions inserted after the last unconditional cleanup are      never the last instruction.  */
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanup_ptr
operator|=
operator|&
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
expr_stmt|;
if|if
condition|(
name|block_stack
operator|&&
operator|!
operator|(
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|==
name|NULL_TREE
operator|&&
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
operator|==
name|NULL_TREE
operator|)
condition|)
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|,
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
argument_list|)
expr_stmt|;
else|else
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
operator|=
literal|0
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|label_chain
operator|=
literal|0
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|innermost_stack_block
operator|=
name|stack_block_stack
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
operator|=
name|note
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|block_start_count
operator|=
operator|++
name|current_block_start_count
expr_stmt|;
name|thisblock
operator|->
name|exit_label
operator|=
name|exit_flag
condition|?
name|gen_label_rtx
argument_list|()
else|:
literal|0
expr_stmt|;
name|block_stack
operator|=
name|thisblock
expr_stmt|;
name|nesting_stack
operator|=
name|thisblock
expr_stmt|;
comment|/* Make a new level for allocating stack slots.  */
name|push_temp_slots
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Specify the scope of temporaries created by TARGET_EXPRs.  Similar    to CLEANUP_POINT_EXPR, but handles cases when a series of calls to    expand_expr are made.  After we end the region, we know that all    space for all temporaries that were created by TARGET_EXPRs will be    destroyed and their space freed for reuse.  */
end_comment

begin_function
name|void
name|expand_start_target_temps
parameter_list|()
block|{
comment|/* This is so that even if the result is preserved, the space      allocated will be freed, as we know that it is no longer in use.  */
name|push_temp_slots
argument_list|()
expr_stmt|;
comment|/* Start a new binding layer that will keep track of all cleanup      actions to be performed.  */
name|expand_start_bindings
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|target_temp_slot_level
operator|=
name|temp_slot_level
expr_stmt|;
block|}
end_function

begin_function
name|void
name|expand_end_target_temps
parameter_list|()
block|{
name|expand_end_bindings
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This is so that even if the result is preserved, the space      allocated will be freed, as we know that it is no longer in use.  */
name|pop_temp_slots
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a BLOCK node return non-zero if (and only if) the node    in question represents the outermost pair of curly braces (i.e. the "body    block") of a function or method.     For any BLOCK node representing a "body block" of a function or method, the    BLOCK_SUPERCONTEXT of the node will point to another BLOCK node which    represents the outermost (function) scope for the function or method (i.e.    the one which includes the formal parameters).  The BLOCK_SUPERCONTEXT of    *that* node in turn will point to the relevant FUNCTION_DECL node.  */
end_comment

begin_function
name|int
name|is_body_block
parameter_list|(
name|stmt
parameter_list|)
name|tree
name|stmt
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|BLOCK
condition|)
block|{
name|tree
name|parent
init|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|&&
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|==
name|BLOCK
condition|)
block|{
name|tree
name|grandparent
init|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|grandparent
operator|&&
name|TREE_CODE
argument_list|(
name|grandparent
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* True if we are currently emitting insns in an area of output code    that is controlled by a conditional expression.  This is used by    the cleanup handling code to generate conditional cleanup actions.  */
end_comment

begin_function
name|int
name|conditional_context
parameter_list|()
block|{
return|return
name|block_stack
operator|&&
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|conditional_code
return|;
block|}
end_function

begin_comment
comment|/* Return an opaque pointer to the current nesting level, so frontend code    can check its own sanity.  */
end_comment

begin_function
name|struct
name|nesting
modifier|*
name|current_nesting_level
parameter_list|()
block|{
return|return
name|cfun
condition|?
name|block_stack
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Emit a handler label for a nonlocal goto handler.    Also emit code to store the handler label in SLOT before BEFORE_INSN.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_nl_handler_label
parameter_list|(
name|slot
parameter_list|,
name|before_insn
parameter_list|)
name|rtx
name|slot
decl_stmt|,
name|before_insn
decl_stmt|;
block|{
name|rtx
name|insns
decl_stmt|;
name|rtx
name|handler_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
comment|/* Don't let cleanup_cfg delete the handler.  */
name|LABEL_PRESERVE_P
argument_list|(
name|handler_label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|slot
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|handler_label
argument_list|)
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_before
argument_list|(
name|insns
argument_list|,
name|before_insn
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|handler_label
argument_list|)
expr_stmt|;
return|return
name|handler_label
return|;
block|}
end_function

begin_comment
comment|/* Emit code to restore vital registers at the beginning of a nonlocal goto    handler.  */
end_comment

begin_function
specifier|static
name|void
name|expand_nl_goto_receiver
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|HAVE_nonlocal_goto
if|if
condition|(
operator|!
name|HAVE_nonlocal_goto
condition|)
endif|#
directive|endif
comment|/* First adjust our frame pointer to its actual value.  It was        previously set to the start of the virtual area corresponding to        the stacked variables when we branched here and now needs to be        adjusted to the actual hardware fp value.         Assignments are to virtual registers are converted by        instantiate_virtual_regs into the corresponding assignment        to the underlying register (fp in this case) that makes        the original assignment true.        So the following insn will actually be        decrementing fp by STARTING_FRAME_OFFSET.  */
name|emit_move_insn
argument_list|(
name|virtual_stack_vars_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
if|if
condition|(
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
comment|/* If the argument pointer can be eliminated in favor of the 	 frame pointer, we don't need to restore it.  We assume here 	 that if such an elimination is present, it can always be used. 	 This is the case on all known machines; if we don't make this 	 assumption, we do unnecessary saving on many machines.  */
specifier|static
specifier|const
struct|struct
name|elims
block|{
specifier|const
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|}
name|elim_regs
index|[]
init|=
name|ELIMINABLE_REGS
struct|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|elim_regs
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|elim_regs
index|[
name|i
index|]
operator|.
name|from
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|elim_regs
index|[
name|i
index|]
operator|.
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|ARRAY_SIZE
argument_list|(
name|elim_regs
argument_list|)
condition|)
endif|#
directive|endif
block|{
comment|/* Now restore our arg pointer from the address at which it 	     was saved in our stack frame.  */
name|emit_move_insn
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
name|copy_to_reg
argument_list|(
name|get_arg_pointer_save_area
argument_list|(
name|cfun
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_nonlocal_goto_receiver
if|if
condition|(
name|HAVE_nonlocal_goto_receiver
condition|)
name|emit_insn
argument_list|(
name|gen_nonlocal_goto_receiver
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Make handlers for nonlocal gotos taking place in the function calls in    block THISBLOCK.  */
end_comment

begin_function
specifier|static
name|void
name|expand_nl_goto_receivers
parameter_list|(
name|thisblock
parameter_list|)
name|struct
name|nesting
modifier|*
name|thisblock
decl_stmt|;
block|{
name|tree
name|link
decl_stmt|;
name|rtx
name|afterward
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|insns
decl_stmt|,
name|slot
decl_stmt|;
name|rtx
name|label_list
decl_stmt|;
name|int
name|any_invalid
decl_stmt|;
comment|/* Record the handler address in the stack slot for that purpose,      during this block, saving and restoring the outer value.  */
if|if
condition|(
name|thisblock
operator|->
name|next
operator|!=
literal|0
condition|)
for|for
control|(
name|slot
operator|=
name|nonlocal_goto_handler_slots
init|;
name|slot
condition|;
name|slot
operator|=
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|save_receiver
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
argument_list|,
name|save_receiver
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|save_receiver
argument_list|,
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_before
argument_list|(
name|insns
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
argument_list|)
expr_stmt|;
block|}
comment|/* Jump around the handlers; they run only when specially invoked.  */
name|emit_jump
argument_list|(
name|afterward
argument_list|)
expr_stmt|;
comment|/* Make a separate handler for each label.  */
name|link
operator|=
name|nonlocal_labels
expr_stmt|;
name|slot
operator|=
name|nonlocal_goto_handler_slots
expr_stmt|;
name|label_list
operator|=
name|NULL_RTX
expr_stmt|;
for|for
control|(
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
operator|,
name|slot
operator|=
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|1
argument_list|)
control|)
comment|/* Skip any labels we shouldn't be able to jump to from here,        we generate one special handler for all of them below which just calls        abort.  */
if|if
condition|(
operator|!
name|DECL_TOO_LATE
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|lab
decl_stmt|;
name|lab
operator|=
name|expand_nl_handler_label
argument_list|(
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
argument_list|)
expr_stmt|;
name|label_list
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|lab
argument_list|,
name|label_list
argument_list|)
expr_stmt|;
name|expand_nl_goto_receiver
argument_list|()
expr_stmt|;
comment|/* Jump to the "real" nonlocal label.  */
name|expand_goto
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* A second pass over all nonlocal labels; this time we handle those      we should not be able to jump to at this point.  */
name|link
operator|=
name|nonlocal_labels
expr_stmt|;
name|slot
operator|=
name|nonlocal_goto_handler_slots
expr_stmt|;
name|any_invalid
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
operator|,
name|slot
operator|=
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|DECL_TOO_LATE
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|lab
decl_stmt|;
name|lab
operator|=
name|expand_nl_handler_label
argument_list|(
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
argument_list|)
expr_stmt|;
name|label_list
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|lab
argument_list|,
name|label_list
argument_list|)
expr_stmt|;
name|any_invalid
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|any_invalid
condition|)
block|{
name|expand_nl_goto_receiver
argument_list|()
expr_stmt|;
name|emit_library_call
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"abort"
argument_list|)
argument_list|,
name|LCT_NORETURN
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
name|nonlocal_goto_handler_labels
operator|=
name|label_list
expr_stmt|;
name|emit_label
argument_list|(
name|afterward
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Warn about any unused VARS (which may contain nodes other than    VAR_DECLs, but such nodes are ignored).  The nodes are connected    via the TREE_CHAIN field.  */
end_comment

begin_function
name|void
name|warn_about_unused_variables
parameter_list|(
name|vars
parameter_list|)
name|tree
name|vars
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|warn_unused_variable
condition|)
for|for
control|(
name|decl
operator|=
name|vars
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"unused variable `%s'"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL code to terminate a binding contour.     VARS is the chain of VAR_DECL nodes for the variables bound in this    contour.  There may actually be other nodes in this chain, but any    nodes other than VAR_DECLS are ignored.     MARK_ENDS is nonzero if we should put a note at the beginning    and end of this binding contour.     DONT_JUMP_IN is nonzero if it is not valid to jump into this contour.    (That is true automatically if the contour has a saved stack level.)  */
end_comment

begin_function
name|void
name|expand_end_bindings
parameter_list|(
name|vars
parameter_list|,
name|mark_ends
parameter_list|,
name|dont_jump_in
parameter_list|)
name|tree
name|vars
decl_stmt|;
name|int
name|mark_ends
decl_stmt|;
name|int
name|dont_jump_in
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thisblock
init|=
name|block_stack
decl_stmt|;
comment|/* If any of the variables in this scope were not used, warn the      user.  */
name|warn_about_unused_variables
argument_list|(
name|vars
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisblock
operator|->
name|exit_label
condition|)
block|{
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|thisblock
operator|->
name|exit_label
argument_list|)
expr_stmt|;
block|}
comment|/* If necessary, make handlers for nonlocal gotos taking      place in the function calls in this block.  */
if|if
condition|(
name|function_call_count
operator|!=
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|n_function_calls
operator|&&
name|nonlocal_labels
comment|/* Make handler for outermost block 	 if there were any nonlocal gotos to this function.  */
operator|&&
operator|(
name|thisblock
operator|->
name|next
operator|==
literal|0
condition|?
name|current_function_has_nonlocal_label
comment|/* Make handler for inner block if it has something 	     special to do when you jump out of it.  */
else|:
operator|(
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|!=
literal|0
operator|||
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|!=
literal|0
operator|)
operator|)
condition|)
name|expand_nl_goto_receivers
argument_list|(
name|thisblock
argument_list|)
expr_stmt|;
comment|/* Don't allow jumping into a block that has a stack level.      Cleanups are allowed, though.  */
if|if
condition|(
name|dont_jump_in
operator|||
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|!=
literal|0
condition|)
block|{
name|struct
name|label_chain
modifier|*
name|chain
decl_stmt|;
comment|/* Any labels in this block are no longer valid to go to. 	 Mark them to cause an error message.  */
for|for
control|(
name|chain
operator|=
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|label_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|chain
operator|->
name|next
control|)
block|{
name|DECL_TOO_LATE
argument_list|(
name|chain
operator|->
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If any goto without a fixup came to this label, 	     that must be an error, because gotos without fixups 	     come from outside all saved stack-levels.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|chain
operator|->
name|label
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|chain
operator|->
name|label
argument_list|,
literal|"label `%s' used before containing binding contour"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Restore stack level in effect before the block      (only if variable-size objects allocated).  */
comment|/* Perform any cleanups associated with the block.  */
if|if
condition|(
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|!=
literal|0
operator|||
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|!=
literal|0
condition|)
block|{
name|int
name|reachable
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Don't let cleanups affect ({...}) constructs.  */
name|int
name|old_expr_stmts_for_value
init|=
name|expr_stmts_for_value
decl_stmt|;
name|rtx
name|old_last_expr_value
init|=
name|last_expr_value
decl_stmt|;
name|tree
name|old_last_expr_type
init|=
name|last_expr_type
decl_stmt|;
name|expr_stmts_for_value
operator|=
literal|0
expr_stmt|;
comment|/* Only clean up here if this point can actually be reached.  */
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|reachable
operator|=
operator|(
operator|!
name|insn
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
operator|)
expr_stmt|;
comment|/* Do the cleanups.  */
name|expand_cleanups
argument_list|(
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
name|reachable
argument_list|)
expr_stmt|;
if|if
condition|(
name|reachable
condition|)
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|expr_stmts_for_value
operator|=
name|old_expr_stmts_for_value
expr_stmt|;
name|last_expr_value
operator|=
name|old_last_expr_value
expr_stmt|;
name|last_expr_type
operator|=
name|old_last_expr_type
expr_stmt|;
comment|/* Restore the stack level.  */
if|if
condition|(
name|reachable
operator|&&
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|!=
literal|0
condition|)
block|{
name|emit_stack_restore
argument_list|(
name|thisblock
operator|->
name|next
condition|?
name|SAVE_BLOCK
else|:
name|SAVE_FUNCTION
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonlocal_goto_handler_slots
operator|!=
literal|0
condition|)
name|emit_stack_save
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
operator|&
name|nonlocal_goto_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
comment|/* Any gotos out of this block must also do these things. 	 Also report any gotos with fixups that came to labels in this 	 level.  */
name|fixup_gotos
argument_list|(
name|thisblock
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
argument_list|,
name|dont_jump_in
argument_list|)
expr_stmt|;
block|}
comment|/* Mark the beginning and end of the scope if requested.      We do this now, after running cleanups on the variables      just going out of scope, so they are in scope for their cleanups.  */
if|if
condition|(
name|mark_ends
condition|)
block|{
name|rtx
name|note
init|=
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_BLOCK_END
argument_list|)
decl_stmt|;
name|NOTE_BLOCK
argument_list|(
name|note
argument_list|)
operator|=
name|NOTE_BLOCK
argument_list|(
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Get rid of the beginning-mark if we don't make an end-mark.  */
name|NOTE_LINE_NUMBER
argument_list|(
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
comment|/* Restore the temporary level of TARGET_EXPRs.  */
name|target_temp_slot_level
operator|=
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|block_target_temp_slot_level
expr_stmt|;
comment|/* Restore block_stack level for containing block.  */
name|stack_block_stack
operator|=
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|innermost_stack_block
expr_stmt|;
name|POPSTACK
argument_list|(
name|block_stack
argument_list|)
expr_stmt|;
comment|/* Pop the stack slot nesting and free any slots at this level.  */
name|pop_temp_slots
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to save the stack pointer at the start of the current block    and set up to restore it on exit.  */
end_comment

begin_function
name|void
name|save_stack_pointer
parameter_list|()
block|{
name|struct
name|nesting
modifier|*
name|thisblock
init|=
name|block_stack
decl_stmt|;
if|if
condition|(
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|==
literal|0
condition|)
block|{
name|emit_stack_save
argument_list|(
name|thisblock
operator|->
name|next
condition|?
name|SAVE_BLOCK
else|:
name|SAVE_FUNCTION
argument_list|,
operator|&
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
argument_list|)
expr_stmt|;
name|stack_block_stack
operator|=
name|thisblock
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL for the automatic variable declaration DECL.    (Other kinds of declarations are simply ignored if seen here.)  */
end_comment

begin_function
name|void
name|expand_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thisblock
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* For a CONST_DECL, set mode, alignment, and sizes from those of the      type in case this node is used in a reference.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, only automatic variables need any expansion done.  Static and      external variables, and external functions, will be handled by      `assemble_variable' (called from finish_decl).  TYPE_DECL requires      nothing.  PARM_DECLs are handled in `assign_parms'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
condition|)
return|return;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|thisblock
operator|=
name|block_stack
expr_stmt|;
comment|/* Create the RTL representation for the variable.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
comment|/* Variable with incomplete type.  */
block|{
name|rtx
name|x
decl_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
comment|/* Error message was already done; now avoid a crash.  */
name|x
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
else|else
comment|/* An initializer is going to decide the size of this array. 	   Until we know the size, represent its address with a reg.  */
name|x
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|x
argument_list|,
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|BLKmode
comment|/* If -ffloat-store, don't put explicit float vars 	      into regs.  */
operator|&&
operator|!
operator|(
name|flag_float_store
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|||
name|optimize
operator|)
condition|)
block|{
comment|/* Automatic variable that can go in a register.  */
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|reg_mode
init|=
name|promote_mode
argument_list|(
name|type
argument_list|,
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|gen_reg_rtx
argument_list|(
name|reg_mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|REGNO_DECL
argument_list|(
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|=
name|decl
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|REGNO_DECL
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|=
name|decl
expr_stmt|;
name|REGNO_DECL
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
name|mark_user_reg
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|mark_reg_pointer
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|maybe_set_unchanging
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* If something wants our address, try to use ADDRESSOF.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
condition|)
name|put_var_into_stack
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
operator|(
name|flag_stack_check
operator|&&
operator|!
name|STACK_CHECK_BUILTIN
operator|&&
literal|0
operator|<
name|compare_tree_int
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|,
name|STACK_CHECK_MAX_VAR_SIZE
argument_list|)
operator|)
condition|)
block|{
comment|/* Variable of fixed size that goes on the stack.  */
name|rtx
name|oldaddr
init|=
literal|0
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
name|rtx
name|x
decl_stmt|;
comment|/* If we previously made RTL for this decl, it must be an array 	 whose size was determined by the initializer. 	 The old address was a register; set that register now 	 to the proper address.  */
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|oldaddr
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Set alignment we actually gave this decl.  */
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|==
name|BLKmode
condition|?
name|BIGGEST_ALIGNMENT
else|:
name|GET_MODE_BITSIZE
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|assign_temp
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|x
argument_list|,
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldaddr
condition|)
block|{
name|addr
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|oldaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
name|oldaddr
condition|)
name|emit_move_insn
argument_list|(
name|oldaddr
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Dynamic-size object: must push space on the stack.  */
block|{
name|rtx
name|address
decl_stmt|,
name|size
decl_stmt|,
name|x
decl_stmt|;
comment|/* Record the stack pointer on entry to block, if have 	 not already done so.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|save_stack_pointer
argument_list|()
expr_stmt|;
comment|/* In function-at-a-time mode, variable_size doesn't expand this, 	 so do it now.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|)
name|expand_expr
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Compute the variable's size, in bytes.  */
name|size
operator|=
name|expand_expr
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
comment|/* Allocate space on the stack for the variable.  Note that 	 DECL_ALIGN says how the variable is to be aligned and we 	 cannot use it to conclude anything about the alignment of 	 the size.  */
name|address
operator|=
name|allocate_dynamic_stack_space
argument_list|(
name|size
argument_list|,
name|NULL_RTX
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Reference the variable indirect through that rtx.  */
name|x
operator|=
name|gen_rtx_MEM
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|x
argument_list|,
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Indicate the alignment we actually gave this variable.  */
ifdef|#
directive|ifdef
name|STACK_BOUNDARY
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|STACK_BOUNDARY
expr_stmt|;
else|#
directive|else
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|BIGGEST_ALIGNMENT
expr_stmt|;
endif|#
directive|endif
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit code to perform the initialization of a declaration DECL.  */
end_comment

begin_function
name|void
name|expand_decl_init
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|int
name|was_used
init|=
name|TREE_USED
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* If this is a CONST_DECL, we don't have to generate any code.  Likewise      for static decls.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|CONST_DECL
operator|||
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Compute and store the initial value now.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|INTEGER_TYPE
operator|||
name|code
operator|==
name|REAL_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
operator|||
name|code
operator|==
name|POINTER_TYPE
operator|||
name|code
operator|==
name|REFERENCE_TYPE
condition|)
name|expand_assignment
argument_list|(
name|decl
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
name|emit_line_note
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|expand_assignment
argument_list|(
name|decl
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
block|}
comment|/* Don't let the initialization count as "using" the variable.  */
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
name|was_used
expr_stmt|;
comment|/* Free any temporaries we made while initializing the decl.  */
name|preserve_temp_slots
argument_list|(
name|NULL_RTX
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* CLEANUP is an expression to be executed at exit from this binding contour;    for example, in C++, it might call the destructor for this variable.     We wrap CLEANUP in an UNSAVE_EXPR node, so that we can expand the    CLEANUP multiple times, and have the correct semantics.  This    happens in exception handling, for gotos, returns, breaks that    leave the current scope.     If CLEANUP is nonzero and DECL is zero, we record a cleanup    that is not associated with any particular variable.  */
end_comment

begin_function
name|int
name|expand_decl_cleanup
parameter_list|(
name|decl
parameter_list|,
name|cleanup
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|cleanup
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thisblock
decl_stmt|;
comment|/* Error if we are not in any block.  */
if|if
condition|(
name|cfun
operator|==
literal|0
operator|||
name|block_stack
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|thisblock
operator|=
name|block_stack
expr_stmt|;
comment|/* Record the cleanup if there is one.  */
if|if
condition|(
name|cleanup
operator|!=
literal|0
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|tree
modifier|*
name|cleanups
init|=
operator|&
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
decl_stmt|;
name|int
name|cond_context
init|=
name|conditional_context
argument_list|()
decl_stmt|;
if|if
condition|(
name|cond_context
condition|)
block|{
name|rtx
name|flag
init|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
decl_stmt|;
name|rtx
name|set_flag_0
decl_stmt|;
name|tree
name|cond
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|flag
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|set_flag_0
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|last_unconditional_cleanup
operator|=
name|emit_insns_after
argument_list|(
name|set_flag_0
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|last_unconditional_cleanup
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|flag
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|cond
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type_for_mode
argument_list|(
name|word_mode
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|cond
argument_list|,
name|flag
argument_list|)
expr_stmt|;
comment|/* Conditionalize the cleanup.  */
name|cleanup
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|truthvalue_conversion
argument_list|(
name|cond
argument_list|)
argument_list|,
name|cleanup
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|cleanup
operator|=
name|fold
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
name|cleanups
operator|=
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanup_ptr
expr_stmt|;
block|}
name|cleanup
operator|=
name|unsave_expr
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
name|t
operator|=
operator|*
name|cleanups
operator|=
name|tree_cons
argument_list|(
name|decl
argument_list|,
name|cleanup
argument_list|,
operator|*
name|cleanups
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond_context
condition|)
comment|/* If this block has a cleanup, it belongs in stack_block_stack.  */
name|stack_block_stack
operator|=
name|thisblock
expr_stmt|;
if|if
condition|(
name|cond_context
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|using_eh_for_cleanups_p
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|expand_eh_region_start
argument_list|()
expr_stmt|;
if|if
condition|(
name|cond_context
condition|)
block|{
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|seq
condition|)
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|last_unconditional_cleanup
operator|=
name|emit_insns_after
argument_list|(
name|seq
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|last_unconditional_cleanup
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|last_unconditional_cleanup
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* When we insert instructions after the last unconditional cleanup, 	     we don't adjust last_insn.  That means that a later add_insn will 	     clobber the instructions we've just added.  The easiest way to 	     fix this is to just insert another instruction here, so that the 	     instructions inserted after the last unconditional cleanup are 	     never the last instruction.  */
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanup_ptr
operator|=
operator|&
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* DECL is an anonymous union.  CLEANUP is a cleanup for DECL.    DECL_ELTS is the list of elements that belong to DECL's type.    In each, the TREE_VALUE is a VAR_DECL, and the TREE_PURPOSE a cleanup.  */
end_comment

begin_function
name|void
name|expand_anon_union_decl
parameter_list|(
name|decl
parameter_list|,
name|cleanup
parameter_list|,
name|decl_elts
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|cleanup
decl_stmt|,
name|decl_elts
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thisblock
init|=
name|cfun
operator|==
literal|0
condition|?
literal|0
else|:
name|block_stack
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* If any of the elements are addressable, so is the entire union.  */
for|for
control|(
name|t
operator|=
name|decl_elts
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|expand_decl_cleanup
argument_list|(
name|decl
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|x
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Go through the elements, assigning RTL to each.  */
for|for
control|(
name|t
operator|=
name|decl_elts
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|decl_elt
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|cleanup_elt
init|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl_elt
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Propagate the union's alignment to the elements.  */
name|DECL_ALIGN
argument_list|(
name|decl_elt
argument_list|)
operator|=
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|decl_elt
argument_list|)
operator|=
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If the element has BLKmode and the union doesn't, the union is          aligned such that the element doesn't need to have BLKmode, so          change the element's mode to the appropriate one for its size.  */
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|&&
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|BLKmode
condition|)
name|DECL_MODE
argument_list|(
name|decl_elt
argument_list|)
operator|=
name|mode
operator|=
name|mode_for_size_tree
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl_elt
argument_list|)
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* (SUBREG (MEM ...)) at RTL generation time is invalid, so we          instead create a new MEM rtx with the proper mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
name|SET_DECL_RTL
argument_list|(
name|decl_elt
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|SET_DECL_RTL
argument_list|(
name|decl_elt
argument_list|,
name|adjust_address_nv
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
name|SET_DECL_RTL
argument_list|(
name|decl_elt
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|SET_DECL_RTL
argument_list|(
name|decl_elt
argument_list|,
name|gen_lowpart_SUBREG
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Record the cleanup if there is one.  */
if|if
condition|(
name|cleanup
operator|!=
literal|0
condition|)
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|=
name|tree_cons
argument_list|(
name|decl_elt
argument_list|,
name|cleanup_elt
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand a list of cleanups LIST.    Elements may be expressions or may be nested lists.     If DONT_DO is nonnull, then any list-element    whose TREE_PURPOSE matches DONT_DO is omitted.    This is sometimes used to avoid a cleanup associated with    a value that is being returned out of the scope.     If IN_FIXUP is non-zero, we are generating this cleanup for a fixup    goto and handle protection regions specially in that case.     If REACHABLE, we emit code, otherwise just inform the exception handling    code about this finalization.  */
end_comment

begin_function
specifier|static
name|void
name|expand_cleanups
parameter_list|(
name|list
parameter_list|,
name|dont_do
parameter_list|,
name|in_fixup
parameter_list|,
name|reachable
parameter_list|)
name|tree
name|list
decl_stmt|;
name|tree
name|dont_do
decl_stmt|;
name|int
name|in_fixup
decl_stmt|;
name|int
name|reachable
decl_stmt|;
block|{
name|tree
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|list
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
if|if
condition|(
name|dont_do
operator|==
literal|0
operator|||
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|!=
name|dont_do
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|expand_cleanups
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
name|dont_do
argument_list|,
name|in_fixup
argument_list|,
name|reachable
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|in_fixup
operator|&&
name|using_eh_for_cleanups_p
condition|)
name|expand_eh_region_end_cleanup
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reachable
condition|)
block|{
comment|/* Cleanups may be run multiple times.  For example, 		   when exiting a binding contour, we expand the 		   cleanups associated with that contour.  When a goto 		   within that binding contour has a target outside that 		   contour, it will expand all cleanups from its scope to 		   the target.  Though the cleanups are expanded multiple 		   times, the control paths are non-overlapping so the 		   cleanups will not be executed twice.  */
comment|/* We may need to protect from outer cleanups.  */
if|if
condition|(
name|in_fixup
operator|&&
name|using_eh_for_cleanups_p
condition|)
block|{
name|expand_eh_region_start
argument_list|()
expr_stmt|;
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_eh_region_end_fixup
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Mark when the context we are emitting RTL for as a conditional    context, so that any cleanup actions we register with    expand_decl_init will be properly conditionalized when those    cleanup actions are later performed.  Must be called before any    expression (tree) is expanded that is within a conditional context.  */
end_comment

begin_function
name|void
name|start_cleanup_deferral
parameter_list|()
block|{
comment|/* block_stack can be NULL if we are inside the parameter list.  It is      OK to do nothing, because cleanups aren't possible here.  */
if|if
condition|(
name|block_stack
condition|)
operator|++
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|conditional_code
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark the end of a conditional region of code.  Because cleanup    deferrals may be nested, we may still be in a conditional region    after we end the currently deferred cleanups, only after we end all    deferred cleanups, are we back in unconditional code.  */
end_comment

begin_function
name|void
name|end_cleanup_deferral
parameter_list|()
block|{
comment|/* block_stack can be NULL if we are inside the parameter list.  It is      OK to do nothing, because cleanups aren't possible here.  */
if|if
condition|(
name|block_stack
condition|)
operator|--
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|conditional_code
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move all cleanups from the current block_stack    to the containing block_stack, where they are assumed to    have been created.  If anything can cause a temporary to    be created, but not expanded for more than one level of    block_stacks, then this code will have to change.  */
end_comment

begin_function
name|void
name|move_cleanups_up
parameter_list|()
block|{
name|struct
name|nesting
modifier|*
name|block
init|=
name|block_stack
decl_stmt|;
name|struct
name|nesting
modifier|*
name|outer
init|=
name|block
operator|->
name|next
decl_stmt|;
name|outer
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|=
name|chainon
argument_list|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|,
name|outer
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|)
expr_stmt|;
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|last_cleanup_this_contour
parameter_list|()
block|{
if|if
condition|(
name|block_stack
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if there are any pending cleanups at this point.    If THIS_CONTOUR is nonzero, check the current contour as well.    Otherwise, look only at the contours that enclose this one.  */
end_comment

begin_function
name|int
name|any_pending_cleanups
parameter_list|(
name|this_contour
parameter_list|)
name|int
name|this_contour
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|block
decl_stmt|;
if|if
condition|(
name|cfun
operator|==
name|NULL
operator|||
name|cfun
operator|->
name|stmt
operator|==
name|NULL
operator|||
name|block_stack
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|this_contour
operator|&&
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|!=
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|==
literal|0
operator|&&
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|block
operator|=
name|block_stack
operator|->
name|next
init|;
name|block
condition|;
name|block
operator|=
name|block
operator|->
name|next
control|)
if|if
condition|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Enter a case (Pascal) or switch (C) statement.    Push a block onto case_stack and nesting_stack    to accumulate the case-labels that are seen    and to record the labels generated for the statement.     EXIT_FLAG is nonzero if `exit_something' should exit this case stmt.    Otherwise, this construct is transparent for `exit_something'.     EXPR is the index-expression to be dispatched on.    TYPE is its nominal type.  We could simply convert EXPR to this type,    but instead we take short cuts.  */
end_comment

begin_function
name|void
name|expand_start_case
parameter_list|(
name|exit_flag
parameter_list|,
name|expr
parameter_list|,
name|type
parameter_list|,
name|printname
parameter_list|)
name|int
name|exit_flag
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|tree
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|printname
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thiscase
init|=
name|ALLOC_NESTING
argument_list|()
decl_stmt|;
comment|/* Make an entry on case_stack for the case we are entering.  */
name|thiscase
operator|->
name|next
operator|=
name|case_stack
expr_stmt|;
name|thiscase
operator|->
name|all
operator|=
name|nesting_stack
expr_stmt|;
name|thiscase
operator|->
name|depth
operator|=
operator|++
name|nesting_depth
expr_stmt|;
name|thiscase
operator|->
name|exit_label
operator|=
name|exit_flag
condition|?
name|gen_label_rtx
argument_list|()
else|:
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|index_expr
operator|=
name|expr
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
operator|=
name|type
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|printname
operator|=
name|printname
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|line_number_status
operator|=
name|force_line_numbers
argument_list|()
expr_stmt|;
name|case_stack
operator|=
name|thiscase
expr_stmt|;
name|nesting_stack
operator|=
name|thiscase
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Make sure case_stmt.start points to something that won't      need any transformation before expand_end_case.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
operator|!=
name|NOTE
condition|)
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|start
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start a "dummy case statement" within which case labels are invalid    and are not connected to any larger real case statement.    This can be used if you don't want to let a case statement jump    into the middle of certain kinds of constructs.  */
end_comment

begin_function
name|void
name|expand_start_case_dummy
parameter_list|()
block|{
name|struct
name|nesting
modifier|*
name|thiscase
init|=
name|ALLOC_NESTING
argument_list|()
decl_stmt|;
comment|/* Make an entry on case_stack for the dummy.  */
name|thiscase
operator|->
name|next
operator|=
name|case_stack
expr_stmt|;
name|thiscase
operator|->
name|all
operator|=
name|nesting_stack
expr_stmt|;
name|thiscase
operator|->
name|depth
operator|=
operator|++
name|nesting_depth
expr_stmt|;
name|thiscase
operator|->
name|exit_label
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|=
literal|0
expr_stmt|;
name|case_stack
operator|=
name|thiscase
expr_stmt|;
name|nesting_stack
operator|=
name|thiscase
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End a dummy case statement.  */
end_comment

begin_function
name|void
name|expand_end_case_dummy
parameter_list|()
block|{
name|end_cleanup_deferral
argument_list|()
expr_stmt|;
name|POPSTACK
argument_list|(
name|case_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the data type of the index-expression    of the innermost case statement, or null if none.  */
end_comment

begin_function
name|tree
name|case_index_expr_type
parameter_list|()
block|{
if|if
condition|(
name|case_stack
condition|)
return|return
name|TREE_TYPE
argument_list|(
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|index_expr
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|check_seenlabel
parameter_list|()
block|{
comment|/* If this is the first label, warn if any insns have been emitted.  */
if|if
condition|(
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|line_number_status
operator|>=
literal|0
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
name|restore_line_number_status
argument_list|(
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|line_number_status
argument_list|)
expr_stmt|;
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|line_number_status
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|start
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|)
condition|)
block|{
do|do
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
do|while
condition|(
name|insn
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
operator|)
condition|)
do|;
comment|/* If insn is zero, then there must have been a syntax error.  */
if|if
condition|(
name|insn
condition|)
name|warning_with_file_and_line
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|"unreachable code at beginning of %s"
argument_list|,
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|printname
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Accumulate one case or default label inside a case or switch statement.    VALUE is the value of the case (a null pointer, for a default label).    The function CONVERTER, when applied to arguments T and V,    converts the value V to the type T.     If not currently inside a case or switch statement, return 1 and do    nothing.  The caller will print a language-specific error message.    If VALUE is a duplicate or overlaps, return 2 and do nothing    except store the (first) duplicate node in *DUPLICATE.    If VALUE is out of range, return 3 and do nothing.    If we are jumping into the scope of a cleanup or var-sized array, return 5.    Return 0 on success.     Extended to handle range statements.  */
end_comment

begin_function_decl
name|int
name|pushcase
parameter_list|(
name|value
parameter_list|,
name|converter
parameter_list|,
name|label
parameter_list|,
name|duplicate
parameter_list|)
name|tree
name|value
decl_stmt|;
function_decl|tree
parameter_list|(
function_decl|*converter
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|tree
name|label
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
modifier|*
name|duplicate
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|index_type
decl_stmt|;
name|tree
name|nominal_type
decl_stmt|;
comment|/* Fail if not inside a real case statement.  */
if|if
condition|(
operator|!
operator|(
name|case_stack
operator|&&
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|start
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|stack_block_stack
operator|&&
name|stack_block_stack
operator|->
name|depth
operator|>
name|case_stack
operator|->
name|depth
condition|)
return|return
literal|5
return|;
name|index_type
operator|=
name|TREE_TYPE
argument_list|(
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|index_expr
argument_list|)
expr_stmt|;
name|nominal_type
operator|=
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
expr_stmt|;
comment|/* If the index is erroneous, avoid more problems: pretend to succeed.  */
if|if
condition|(
name|index_type
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
comment|/* Convert VALUE to the type in which the comparisons are nominally done.  */
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
name|value
operator|=
call|(
modifier|*
name|converter
call|)
argument_list|(
name|nominal_type
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|check_seenlabel
argument_list|()
expr_stmt|;
comment|/* Fail if this value is out of range for the actual type of the index      (which may be narrower than NOMINAL_TYPE).  */
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
operator|(
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|||
operator|!
name|int_fits_type_p
argument_list|(
name|value
argument_list|,
name|index_type
argument_list|)
operator|)
condition|)
return|return
literal|3
return|;
return|return
name|add_case_node
argument_list|(
name|value
argument_list|,
name|value
argument_list|,
name|label
argument_list|,
name|duplicate
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Like pushcase but this case applies to all values between VALUE1 and    VALUE2 (inclusive).  If VALUE1 is NULL, the range starts at the lowest    value of the index type and ends at VALUE2.  If VALUE2 is NULL, the range    starts at VALUE1 and ends at the highest value of the index type.    If both are NULL, this case applies to all values.     The return value is the same as that of pushcase but there is one    additional error code: 4 means the specified range was empty.  */
end_comment

begin_function_decl
name|int
name|pushcase_range
parameter_list|(
name|value1
parameter_list|,
name|value2
parameter_list|,
name|converter
parameter_list|,
name|label
parameter_list|,
name|duplicate
parameter_list|)
name|tree
name|value1
decl_stmt|,
name|value2
decl_stmt|;
function_decl|tree
parameter_list|(
function_decl|*converter
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|tree
name|label
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
modifier|*
name|duplicate
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|index_type
decl_stmt|;
name|tree
name|nominal_type
decl_stmt|;
comment|/* Fail if not inside a real case statement.  */
if|if
condition|(
operator|!
operator|(
name|case_stack
operator|&&
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|start
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|stack_block_stack
operator|&&
name|stack_block_stack
operator|->
name|depth
operator|>
name|case_stack
operator|->
name|depth
condition|)
return|return
literal|5
return|;
name|index_type
operator|=
name|TREE_TYPE
argument_list|(
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|index_expr
argument_list|)
expr_stmt|;
name|nominal_type
operator|=
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
expr_stmt|;
comment|/* If the index is erroneous, avoid more problems: pretend to succeed.  */
if|if
condition|(
name|index_type
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
name|check_seenlabel
argument_list|()
expr_stmt|;
comment|/* Convert VALUEs to type in which the comparisons are nominally done      and replace any unspecified value with the corresponding bound.  */
if|if
condition|(
name|value1
operator|==
literal|0
condition|)
name|value1
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|index_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|value2
operator|==
literal|0
condition|)
name|value2
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|index_type
argument_list|)
expr_stmt|;
comment|/* Fail if the range is empty.  Do this before any conversion since      we want to allow out-of-range empty ranges.  */
if|if
condition|(
name|value2
operator|!=
literal|0
operator|&&
name|tree_int_cst_lt
argument_list|(
name|value2
argument_list|,
name|value1
argument_list|)
condition|)
return|return
literal|4
return|;
comment|/* If the max was unbounded, use the max of the nominal_type we are      converting to.  Do this after the< check above to suppress false      positives.  */
if|if
condition|(
name|value2
operator|==
literal|0
condition|)
name|value2
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|nominal_type
argument_list|)
expr_stmt|;
name|value1
operator|=
call|(
modifier|*
name|converter
call|)
argument_list|(
name|nominal_type
argument_list|,
name|value1
argument_list|)
expr_stmt|;
name|value2
operator|=
call|(
modifier|*
name|converter
call|)
argument_list|(
name|nominal_type
argument_list|,
name|value2
argument_list|)
expr_stmt|;
comment|/* Fail if these values are out of range.  */
if|if
condition|(
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|value1
argument_list|)
operator|||
operator|!
name|int_fits_type_p
argument_list|(
name|value1
argument_list|,
name|index_type
argument_list|)
condition|)
return|return
literal|3
return|;
if|if
condition|(
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|value2
argument_list|)
operator|||
operator|!
name|int_fits_type_p
argument_list|(
name|value2
argument_list|,
name|index_type
argument_list|)
condition|)
return|return
literal|3
return|;
return|return
name|add_case_node
argument_list|(
name|value1
argument_list|,
name|value2
argument_list|,
name|label
argument_list|,
name|duplicate
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Do the actual insertion of a case label for pushcase and pushcase_range    into case_stack->data.case_stmt.case_list.  Use an AVL tree to avoid    slowdown for large switch statements.  */
end_comment

begin_function
name|int
name|add_case_node
parameter_list|(
name|low
parameter_list|,
name|high
parameter_list|,
name|label
parameter_list|,
name|duplicate
parameter_list|)
name|tree
name|low
decl_stmt|,
name|high
decl_stmt|;
name|tree
name|label
decl_stmt|;
name|tree
modifier|*
name|duplicate
decl_stmt|;
block|{
name|struct
name|case_node
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|;
comment|/* If there's no HIGH value, then this is not a case range; it's      just a simple case label.  But that's just a degenerate case      range.  */
if|if
condition|(
operator|!
name|high
condition|)
name|high
operator|=
name|low
expr_stmt|;
comment|/* Handle default labels specially.  */
if|if
condition|(
operator|!
name|high
operator|&&
operator|!
name|low
condition|)
block|{
if|if
condition|(
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|!=
literal|0
condition|)
block|{
operator|*
name|duplicate
operator|=
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
expr_stmt|;
return|return
literal|2
return|;
block|}
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|=
name|label
expr_stmt|;
name|expand_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|q
operator|=
operator|&
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
expr_stmt|;
name|p
operator|=
operator|*
name|q
expr_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
operator|*
name|q
operator|)
condition|)
block|{
name|p
operator|=
name|r
expr_stmt|;
comment|/* Keep going past elements distinctly greater than HIGH.  */
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|high
argument_list|,
name|p
operator|->
name|low
argument_list|)
condition|)
name|q
operator|=
operator|&
name|p
operator|->
name|left
expr_stmt|;
comment|/* or distinctly less than LOW.  */
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|p
operator|->
name|high
argument_list|,
name|low
argument_list|)
condition|)
name|q
operator|=
operator|&
name|p
operator|->
name|right
expr_stmt|;
else|else
block|{
comment|/* We have an overlap; this is an error.  */
operator|*
name|duplicate
operator|=
name|p
operator|->
name|code_label
expr_stmt|;
return|return
literal|2
return|;
block|}
block|}
comment|/* Add this label to the chain, and succeed.  */
name|r
operator|=
operator|(
expr|struct
name|case_node
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|case_node
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|low
operator|=
name|low
expr_stmt|;
comment|/* If the bounds are equal, turn this into the one-value case.  */
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|low
argument_list|,
name|high
argument_list|)
condition|)
name|r
operator|->
name|high
operator|=
name|r
operator|->
name|low
expr_stmt|;
else|else
name|r
operator|->
name|high
operator|=
name|high
expr_stmt|;
name|r
operator|->
name|code_label
operator|=
name|label
expr_stmt|;
name|expand_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
name|r
expr_stmt|;
name|r
operator|->
name|parent
operator|=
name|p
expr_stmt|;
name|r
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|right
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|struct
name|case_node
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|p
operator|->
name|left
condition|)
block|{
name|int
name|b
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|b
operator|=
name|p
operator|->
name|balance
operator|)
condition|)
comment|/* Growth propagation from left side.  */
name|p
operator|->
name|balance
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|balance
operator|<
literal|0
condition|)
block|{
comment|/* R-Rotation */
if|if
condition|(
operator|(
name|p
operator|->
name|left
operator|=
name|s
operator|=
name|r
operator|->
name|right
operator|)
condition|)
name|s
operator|->
name|parent
operator|=
name|p
expr_stmt|;
name|r
operator|->
name|right
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|parent
expr_stmt|;
name|p
operator|->
name|parent
operator|=
name|r
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|->
name|parent
operator|=
name|s
operator|)
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|left
operator|==
name|p
condition|)
name|s
operator|->
name|left
operator|=
name|r
expr_stmt|;
else|else
name|s
operator|->
name|right
operator|=
name|r
expr_stmt|;
block|}
else|else
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|=
name|r
expr_stmt|;
block|}
else|else
comment|/* r->balance == +1 */
block|{
comment|/* LR-Rotation */
name|int
name|b2
decl_stmt|;
name|struct
name|case_node
modifier|*
name|t
init|=
name|r
operator|->
name|right
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|left
operator|=
name|s
operator|=
name|t
operator|->
name|right
operator|)
condition|)
name|s
operator|->
name|parent
operator|=
name|p
expr_stmt|;
name|t
operator|->
name|right
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|->
name|right
operator|=
name|s
operator|=
name|t
operator|->
name|left
operator|)
condition|)
name|s
operator|->
name|parent
operator|=
name|r
expr_stmt|;
name|t
operator|->
name|left
operator|=
name|r
expr_stmt|;
name|b
operator|=
name|t
operator|->
name|balance
expr_stmt|;
name|b2
operator|=
name|b
operator|<
literal|0
expr_stmt|;
name|p
operator|->
name|balance
operator|=
name|b2
expr_stmt|;
name|b2
operator|=
operator|-
name|b2
operator|-
name|b
expr_stmt|;
name|r
operator|->
name|balance
operator|=
name|b2
expr_stmt|;
name|t
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|parent
expr_stmt|;
name|p
operator|->
name|parent
operator|=
name|t
expr_stmt|;
name|r
operator|->
name|parent
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|parent
operator|=
name|s
operator|)
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|left
operator|==
name|p
condition|)
name|s
operator|->
name|left
operator|=
name|t
expr_stmt|;
else|else
name|s
operator|->
name|right
operator|=
name|t
expr_stmt|;
block|}
else|else
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|=
name|t
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
comment|/* p->balance == +1; growth of left side balances the node.  */
name|p
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
comment|/* r == p->right */
block|{
name|int
name|b
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|b
operator|=
name|p
operator|->
name|balance
operator|)
condition|)
comment|/* Growth propagation from right side.  */
name|p
operator|->
name|balance
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|balance
operator|>
literal|0
condition|)
block|{
comment|/* L-Rotation */
if|if
condition|(
operator|(
name|p
operator|->
name|right
operator|=
name|s
operator|=
name|r
operator|->
name|left
operator|)
condition|)
name|s
operator|->
name|parent
operator|=
name|p
expr_stmt|;
name|r
operator|->
name|left
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|parent
expr_stmt|;
name|p
operator|->
name|parent
operator|=
name|r
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|->
name|parent
operator|=
name|s
operator|)
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|left
operator|==
name|p
condition|)
name|s
operator|->
name|left
operator|=
name|r
expr_stmt|;
else|else
name|s
operator|->
name|right
operator|=
name|r
expr_stmt|;
block|}
else|else
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|=
name|r
expr_stmt|;
block|}
else|else
comment|/* r->balance == -1 */
block|{
comment|/* RL-Rotation */
name|int
name|b2
decl_stmt|;
name|struct
name|case_node
modifier|*
name|t
init|=
name|r
operator|->
name|left
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|right
operator|=
name|s
operator|=
name|t
operator|->
name|left
operator|)
condition|)
name|s
operator|->
name|parent
operator|=
name|p
expr_stmt|;
name|t
operator|->
name|left
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|->
name|left
operator|=
name|s
operator|=
name|t
operator|->
name|right
operator|)
condition|)
name|s
operator|->
name|parent
operator|=
name|r
expr_stmt|;
name|t
operator|->
name|right
operator|=
name|r
expr_stmt|;
name|b
operator|=
name|t
operator|->
name|balance
expr_stmt|;
name|b2
operator|=
name|b
operator|<
literal|0
expr_stmt|;
name|r
operator|->
name|balance
operator|=
name|b2
expr_stmt|;
name|b2
operator|=
operator|-
name|b2
operator|-
name|b
expr_stmt|;
name|p
operator|->
name|balance
operator|=
name|b2
expr_stmt|;
name|t
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|parent
expr_stmt|;
name|p
operator|->
name|parent
operator|=
name|t
expr_stmt|;
name|r
operator|->
name|parent
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|parent
operator|=
name|s
operator|)
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|left
operator|==
name|p
condition|)
name|s
operator|->
name|left
operator|=
name|t
expr_stmt|;
else|else
name|s
operator|->
name|right
operator|=
name|t
expr_stmt|;
block|}
else|else
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|=
name|t
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
comment|/* p->balance == -1; growth of right side balances the node.  */
name|p
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|r
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|parent
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns the number of possible values of TYPE.    Returns -1 if the number is unknown, variable, or if the number does not    fit in a HOST_WIDE_INT.    Sets *SPARENESS to 2 if TYPE is an ENUMERAL_TYPE whose values    do not increase monotonically (there may be duplicates);    to 1 if the values increase monotonically, but not always by 1;    otherwise sets it to 0.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|all_cases_count
parameter_list|(
name|type
parameter_list|,
name|spareness
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
modifier|*
name|spareness
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|HOST_WIDE_INT
name|count
decl_stmt|,
name|minval
decl_stmt|,
name|lastval
decl_stmt|;
operator|*
name|spareness
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|BOOLEAN_TYPE
case|:
name|count
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|CHAR_TYPE
case|:
name|count
operator|=
literal|1
operator|<<
name|BITS_PER_UNIT
expr_stmt|;
break|break;
default|default:
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
literal|0
operator|!=
operator|(
name|t
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
literal|0
operator|!=
operator|(
name|t
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|host_integerp
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
condition|)
name|count
operator|=
name|tree_low_cst
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
comment|/* Don't waste time with enumeral types with huge values.  */
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|||
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|||
operator|!
name|host_integerp
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|lastval
operator|=
name|minval
operator|=
name|tree_low_cst
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|HOST_WIDE_INT
name|thisval
init|=
name|tree_low_cst
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|spareness
operator|==
literal|2
operator|||
name|thisval
operator|<
name|lastval
condition|)
operator|*
name|spareness
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|thisval
operator|!=
name|minval
operator|+
name|count
condition|)
operator|*
name|spareness
operator|=
literal|1
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
end_function

begin_define
define|#
directive|define
name|BITARRAY_TEST
parameter_list|(
name|ARRAY
parameter_list|,
name|INDEX
parameter_list|)
define|\
value|((ARRAY)[(unsigned) (INDEX) / HOST_BITS_PER_CHAR]\& (1<< ((unsigned) (INDEX) % HOST_BITS_PER_CHAR)))
end_define

begin_define
define|#
directive|define
name|BITARRAY_SET
parameter_list|(
name|ARRAY
parameter_list|,
name|INDEX
parameter_list|)
define|\
value|((ARRAY)[(unsigned) (INDEX) / HOST_BITS_PER_CHAR]\ 			  |= 1<< ((unsigned) (INDEX) % HOST_BITS_PER_CHAR))
end_define

begin_comment
comment|/* Set the elements of the bitstring CASES_SEEN (which has length COUNT),    with the case values we have seen, assuming the case expression    has the given TYPE.    SPARSENESS is as determined by all_cases_count.     The time needed is proportional to COUNT, unless    SPARSENESS is 2, in which case quadratic time is needed.  */
end_comment

begin_function
name|void
name|mark_seen_cases
parameter_list|(
name|type
parameter_list|,
name|cases_seen
parameter_list|,
name|count
parameter_list|,
name|sparseness
parameter_list|)
name|tree
name|type
decl_stmt|;
name|unsigned
name|char
modifier|*
name|cases_seen
decl_stmt|;
name|HOST_WIDE_INT
name|count
decl_stmt|;
name|int
name|sparseness
decl_stmt|;
block|{
name|tree
name|next_node_to_try
init|=
name|NULL_TREE
decl_stmt|;
name|HOST_WIDE_INT
name|next_node_offset
init|=
literal|0
decl_stmt|;
name|struct
name|case_node
modifier|*
name|n
decl_stmt|,
modifier|*
name|root
init|=
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
decl_stmt|;
name|tree
name|val
init|=
name|make_node
argument_list|(
name|INTEGER_CST
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
operator|!
name|root
condition|)
comment|/* Do nothing.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|sparseness
operator|==
literal|2
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|xlo
decl_stmt|;
comment|/* This less efficient loop is only needed to handle 	 duplicate case values (multiple enum constants 	 with the same value).  */
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|root
operator|->
name|low
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
operator|,
name|xlo
operator|=
literal|0
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|,
name|xlo
operator|++
control|)
block|{
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|root
expr_stmt|;
do|do
block|{
comment|/* Keep going past elements distinctly greater than VAL.  */
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|val
argument_list|,
name|n
operator|->
name|low
argument_list|)
condition|)
name|n
operator|=
name|n
operator|->
name|left
expr_stmt|;
comment|/* or distinctly less than VAL.  */
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|n
operator|->
name|high
argument_list|,
name|val
argument_list|)
condition|)
name|n
operator|=
name|n
operator|->
name|right
expr_stmt|;
else|else
block|{
comment|/* We have found a matching range.  */
name|BITARRAY_SET
argument_list|(
name|cases_seen
argument_list|,
name|xlo
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|n
condition|)
do|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|root
operator|->
name|left
condition|)
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|=
name|root
operator|=
name|case_tree2list
argument_list|(
name|root
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|root
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
block|{
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|low
argument_list|)
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|n
operator|->
name|low
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|n
operator|->
name|high
argument_list|,
name|val
argument_list|)
condition|)
block|{
comment|/* Calculate (into xlo) the "offset" of the integer (val). 		 The element with lowest value has offset 0, the next smallest 		 element has offset 1, etc.  */
name|unsigned
name|HOST_WIDE_INT
name|xlo
decl_stmt|;
name|HOST_WIDE_INT
name|xhi
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|sparseness
operator|&&
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* The TYPE_VALUES will be in increasing order, so 		     starting searching where we last ended.  */
name|t
operator|=
name|next_node_to_try
expr_stmt|;
name|xlo
operator|=
name|next_node_offset
expr_stmt|;
name|xhi
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
block|{
name|t
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|xlo
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|val
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|next_node_to_try
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|next_node_offset
operator|=
name|xlo
operator|+
literal|1
expr_stmt|;
break|break;
block|}
name|xlo
operator|++
expr_stmt|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|next_node_to_try
condition|)
block|{
name|xlo
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|t
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|neg_double
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|xlo
argument_list|,
operator|&
name|xhi
argument_list|)
expr_stmt|;
else|else
name|xlo
operator|=
name|xhi
operator|=
literal|0
expr_stmt|;
name|add_double
argument_list|(
name|xlo
argument_list|,
name|xhi
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
argument_list|,
operator|&
name|xlo
argument_list|,
operator|&
name|xhi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xhi
operator|==
literal|0
operator|&&
name|xlo
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|count
condition|)
name|BITARRAY_SET
argument_list|(
name|cases_seen
argument_list|,
name|xlo
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
argument_list|,
operator|&
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Called when the index of a switch statement is an enumerated type    and there is no default label.     Checks that all enumeration literals are covered by the case    expressions of a switch.  Also, warn if there are any extra    switch cases that are *not* elements of the enumerated type.     If all enumeration literals were covered by the case expressions,    turn one of the expressions into the default expression since it should    not be possible to fall through such a switch.  */
end_comment

begin_function
name|void
name|check_for_full_enumeration_handling
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|struct
name|case_node
modifier|*
name|n
decl_stmt|;
name|tree
name|chain
decl_stmt|;
comment|/* True iff the selector type is a numbered set mode.  */
name|int
name|sparseness
init|=
literal|0
decl_stmt|;
comment|/* The number of possible selector values.  */
name|HOST_WIDE_INT
name|size
decl_stmt|;
comment|/* For each possible selector value. a one iff it has been matched      by a case value alternative.  */
name|unsigned
name|char
modifier|*
name|cases_seen
decl_stmt|;
comment|/* The allocated size of cases_seen, in chars.  */
name|HOST_WIDE_INT
name|bytes_needed
decl_stmt|;
if|if
condition|(
operator|!
name|warn_switch
condition|)
return|return;
name|size
operator|=
name|all_cases_count
argument_list|(
name|type
argument_list|,
operator|&
name|sparseness
argument_list|)
expr_stmt|;
name|bytes_needed
operator|=
operator|(
name|size
operator|+
name|HOST_BITS_PER_CHAR
operator|)
operator|/
name|HOST_BITS_PER_CHAR
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|<
literal|600000
comment|/* We deliberately use calloc here, not cmalloc, so that we can suppress 	 this optimization if we don't have enough memory rather than 	 aborting, as xmalloc would do.  */
operator|&&
operator|(
name|cases_seen
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|really_call_calloc
argument_list|(
name|bytes_needed
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|HOST_WIDE_INT
name|i
decl_stmt|;
name|tree
name|v
init|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* The time complexity of this code is normally O(N), where 	 N being the number of members in the enumerated type. 	 However, if type is a ENUMERAL_TYPE whose values do not 	 increase monotonically, O(N*log(N)) time may be needed.  */
name|mark_seen_cases
argument_list|(
name|type
argument_list|,
name|cases_seen
argument_list|,
name|size
argument_list|,
name|sparseness
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|v
operator|!=
name|NULL_TREE
operator|&&
name|i
operator|<
name|size
condition|;
name|i
operator|++
operator|,
name|v
operator|=
name|TREE_CHAIN
argument_list|(
name|v
argument_list|)
control|)
if|if
condition|(
name|BITARRAY_TEST
argument_list|(
name|cases_seen
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"enumeration value `%s' not handled in switch"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|v
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cases_seen
argument_list|)
expr_stmt|;
block|}
comment|/* Now we go the other way around; we warn if there are case      expressions that don't correspond to enumerators.  This can      occur since C and C++ don't enforce type-checking of      assignments to enumeration variables.  */
if|if
condition|(
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|&&
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|->
name|left
condition|)
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|=
name|case_tree2list
argument_list|(
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_switch
condition|)
for|for
control|(
name|n
operator|=
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
block|{
for|for
control|(
name|chain
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
init|;
name|chain
operator|&&
operator|!
name|tree_int_cst_equal
argument_list|(
name|n
operator|->
name|low
argument_list|,
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|chain
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"case value `%ld' not in enumerated type"
argument_list|,
operator|(
name|long
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|low
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"case value `%ld' not in enumerated type `%s'"
argument_list|,
operator|(
name|long
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|low
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|)
condition|?
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
else|:
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|n
operator|->
name|low
argument_list|,
name|n
operator|->
name|high
argument_list|)
condition|)
block|{
for|for
control|(
name|chain
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
init|;
name|chain
operator|&&
operator|!
name|tree_int_cst_equal
argument_list|(
name|n
operator|->
name|high
argument_list|,
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|chain
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"case value `%ld' not in enumerated type"
argument_list|,
operator|(
name|long
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|high
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"case value `%ld' not in enumerated type `%s'"
argument_list|,
operator|(
name|long
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|high
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|)
condition|?
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
else|:
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Free CN, and its children.  */
end_comment

begin_function
specifier|static
name|void
name|free_case_nodes
parameter_list|(
name|cn
parameter_list|)
name|case_node_ptr
name|cn
decl_stmt|;
block|{
if|if
condition|(
name|cn
condition|)
block|{
name|free_case_nodes
argument_list|(
name|cn
operator|->
name|left
argument_list|)
expr_stmt|;
name|free_case_nodes
argument_list|(
name|cn
operator|->
name|right
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Terminate a case (Pascal) or switch (C) statement    in which ORIG_INDEX is the expression to be tested.    Generate the code to test it and jump to the right place.  */
end_comment

begin_function
name|void
name|expand_end_case
parameter_list|(
name|orig_index
parameter_list|)
name|tree
name|orig_index
decl_stmt|;
block|{
name|tree
name|minval
init|=
name|NULL_TREE
decl_stmt|,
name|maxval
init|=
name|NULL_TREE
decl_stmt|,
name|range
init|=
name|NULL_TREE
decl_stmt|;
name|rtx
name|default_label
init|=
literal|0
decl_stmt|;
name|struct
name|case_node
modifier|*
name|n
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|rtx
name|index
decl_stmt|;
name|rtx
name|table_label
decl_stmt|;
name|int
name|ncases
decl_stmt|;
name|rtx
modifier|*
name|labelvec
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|before_case
decl_stmt|,
name|end
decl_stmt|;
name|struct
name|nesting
modifier|*
name|thiscase
init|=
name|case_stack
decl_stmt|;
name|tree
name|index_expr
decl_stmt|,
name|index_type
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
comment|/* Don't crash due to previous errors.  */
if|if
condition|(
name|thiscase
operator|==
name|NULL
condition|)
return|return;
name|table_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|index_expr
operator|=
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|index_expr
expr_stmt|;
name|index_type
operator|=
name|TREE_TYPE
argument_list|(
name|index_expr
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|index_type
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* This might get an spurious warning in the presence of a syntax error;      it could be fixed by moving the call to check_seenlabel after the      check for error_mark_node, and copying the code of check_seenlabel that      deals with case_stack->data.case_stmt.line_number_status /      restore_line_number_status in front of the call to end_cleanup_deferral;      However, this might miss some useful warnings in the presence of      non-syntax errors.  */
name|check_seenlabel
argument_list|()
expr_stmt|;
comment|/* An ERROR_MARK occurs for various reasons including invalid data type.  */
if|if
condition|(
name|index_type
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* If switch expression was an enumerated type, check that all 	 enumeration literals are covered by the cases. 	 No sense trying this if there's a default case, however.  */
if|if
condition|(
operator|!
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_index
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|index_expr
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|check_for_full_enumeration_handling
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_index
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we don't have a default-label, create one here, 	 after the body of the switch.  */
if|if
condition|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|==
literal|0
condition|)
block|{
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|expand_label
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
argument_list|)
expr_stmt|;
block|}
name|default_label
operator|=
name|label_rtx
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
argument_list|)
expr_stmt|;
name|before_case
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|&&
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|->
name|left
condition|)
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|=
name|case_tree2list
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Simplify the case-list before we count it.  */
name|group_case_nodes
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
argument_list|)
expr_stmt|;
comment|/* Get upper and lower bounds of case values. 	 Also convert all the case values to the index expr's data type.  */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
block|{
comment|/* Check low and high label values are integers.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
operator|->
name|low
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
operator|->
name|high
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|abort
argument_list|()
expr_stmt|;
name|n
operator|->
name|low
operator|=
name|convert
argument_list|(
name|index_type
argument_list|,
name|n
operator|->
name|low
argument_list|)
expr_stmt|;
name|n
operator|->
name|high
operator|=
name|convert
argument_list|(
name|index_type
argument_list|,
name|n
operator|->
name|high
argument_list|)
expr_stmt|;
comment|/* Count the elements and track the largest and smallest 	     of them (treating them as signed even if they are not).  */
if|if
condition|(
name|count
operator|++
operator|==
literal|0
condition|)
block|{
name|minval
operator|=
name|n
operator|->
name|low
expr_stmt|;
name|maxval
operator|=
name|n
operator|->
name|high
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|INT_CST_LT
argument_list|(
name|n
operator|->
name|low
argument_list|,
name|minval
argument_list|)
condition|)
name|minval
operator|=
name|n
operator|->
name|low
expr_stmt|;
if|if
condition|(
name|INT_CST_LT
argument_list|(
name|maxval
argument_list|,
name|n
operator|->
name|high
argument_list|)
condition|)
name|maxval
operator|=
name|n
operator|->
name|high
expr_stmt|;
block|}
comment|/* A range counts double, since it requires two compares.  */
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|n
operator|->
name|low
argument_list|,
name|n
operator|->
name|high
argument_list|)
condition|)
name|count
operator|++
expr_stmt|;
block|}
comment|/* Compute span of values.  */
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
name|range
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index_type
argument_list|,
name|maxval
argument_list|,
name|minval
argument_list|)
argument_list|)
expr_stmt|;
name|end_cleanup_deferral
argument_list|()
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|expand_expr
argument_list|(
name|index_expr
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|emit_jump
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
block|}
comment|/* If range of values is much bigger than number of values, 	 make a sequence of conditional branches instead of a dispatch. 	 If the switch-index is a constant, do it this way 	 because we can optimize it.  */
elseif|else
if|if
condition|(
name|count
operator|<
name|case_values_threshold
argument_list|()
operator|||
name|compare_tree_int
argument_list|(
name|range
argument_list|,
literal|10
operator|*
name|count
argument_list|)
operator|>
literal|0
comment|/* RANGE may be signed, and really large ranges will show up 		  as negative numbers.  */
operator|||
name|compare_tree_int
argument_list|(
name|range
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
ifndef|#
directive|ifndef
name|ASM_OUTPUT_ADDR_DIFF_ELT
operator|||
name|flag_pic
endif|#
directive|endif
operator|||
name|TREE_CODE
argument_list|(
name|index_expr
argument_list|)
operator|==
name|INTEGER_CST
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|index_expr
argument_list|)
operator|==
name|COMPOUND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|index_expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|)
condition|)
block|{
name|index
operator|=
name|expand_expr
argument_list|(
name|index_expr
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the index is a short or char that we do not have 	     an insn to handle comparisons directly, convert it to 	     a full integer now, rather than letting each comparison 	     generate the conversion.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|index
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|have_insn_for
argument_list|(
name|COMPARE
argument_list|,
name|GET_MODE
argument_list|(
name|index
argument_list|)
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|wider_mode
decl_stmt|;
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE
argument_list|(
name|index
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
if|if
condition|(
name|have_insn_for
argument_list|(
name|COMPARE
argument_list|,
name|wider_mode
argument_list|)
condition|)
block|{
name|index
operator|=
name|convert_to_mode
argument_list|(
name|wider_mode
argument_list|,
name|index
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|emit_queue
argument_list|()
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|index
operator|=
name|protect_from_queue
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|MEM
condition|)
name|index
operator|=
name|copy_to_reg
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|CONST_INT
operator|||
name|TREE_CODE
argument_list|(
name|index_expr
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* Make a tree node with the proper constant value 		 if we don't already have one.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index_expr
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|index_expr
operator|=
name|build_int_2
argument_list|(
name|INTVAL
argument_list|(
name|index
argument_list|)
argument_list|,
name|unsignedp
operator|||
name|INTVAL
argument_list|(
name|index
argument_list|)
operator|>=
literal|0
condition|?
literal|0
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
name|index_expr
operator|=
name|convert
argument_list|(
name|index_type
argument_list|,
name|index_expr
argument_list|)
expr_stmt|;
block|}
comment|/* For constant index expressions we need only 		 issue an unconditional branch to the appropriate 		 target code.  The job of removing any unreachable 		 code is left to the optimisation phase if the 		 "-O" option is specified.  */
for|for
control|(
name|n
operator|=
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
if|if
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|index_expr
argument_list|,
name|n
operator|->
name|low
argument_list|)
operator|&&
operator|!
name|tree_int_cst_lt
argument_list|(
name|n
operator|->
name|high
argument_list|,
name|index_expr
argument_list|)
condition|)
break|break;
if|if
condition|(
name|n
condition|)
name|emit_jump
argument_list|(
name|label_rtx
argument_list|(
name|n
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_jump
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the index expression is not constant we generate 		 a binary decision tree to select the appropriate 		 target code.  This is done as follows:  		 The list of cases is rearranged into a binary tree, 		 nearly optimal assuming equal probability for each case.  		 The tree is transformed into RTL, eliminating 		 redundant test conditions at the same time.  		 If program flow could reach the end of the 		 decision tree an unconditional jump to the 		 default code is emitted.  */
name|use_cost_table
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_index
argument_list|)
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|estimate_case_costs
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
argument_list|)
operator|)
expr_stmt|;
name|balance_case_nodes
argument_list|(
operator|&
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
name|emit_jump_if_reachable
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|try_casesi
argument_list|(
name|index_type
argument_list|,
name|index_expr
argument_list|,
name|minval
argument_list|,
name|range
argument_list|,
name|table_label
argument_list|,
name|default_label
argument_list|)
condition|)
block|{
name|index_type
operator|=
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
expr_stmt|;
comment|/* Index jumptables from zero for suitable values of                  minval to avoid a subtraction.  */
if|if
condition|(
operator|!
name|optimize_size
operator|&&
name|compare_tree_int
argument_list|(
name|minval
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
operator|&&
name|compare_tree_int
argument_list|(
name|minval
argument_list|,
literal|3
argument_list|)
operator|<
literal|0
condition|)
block|{
name|minval
operator|=
name|integer_zero_node
expr_stmt|;
name|range
operator|=
name|maxval
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|try_tablejump
argument_list|(
name|index_type
argument_list|,
name|index_expr
argument_list|,
name|minval
argument_list|,
name|range
argument_list|,
name|table_label
argument_list|,
name|default_label
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Get table of labels to jump to, in order of case index.  */
name|ncases
operator|=
name|tree_low_cst
argument_list|(
name|range
argument_list|,
literal|0
argument_list|)
operator|+
literal|1
expr_stmt|;
name|labelvec
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|ncases
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|labelvec
argument_list|,
literal|0
argument_list|,
name|ncases
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
block|{
comment|/* Compute the low and high bounds relative to the minimum 		 value since that should fit in a HOST_WIDE_INT while the 		 actual values may not.  */
name|HOST_WIDE_INT
name|i_low
init|=
name|tree_low_cst
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index_type
argument_list|,
name|n
operator|->
name|low
argument_list|,
name|minval
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|i_high
init|=
name|tree_low_cst
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index_type
argument_list|,
name|n
operator|->
name|high
argument_list|,
name|minval
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|i_low
init|;
name|i
operator|<=
name|i_high
condition|;
name|i
operator|++
control|)
name|labelvec
index|[
name|i
index|]
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|label_rtx
argument_list|(
name|n
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Fill in the gaps with the default.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncases
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|labelvec
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|labelvec
index|[
name|i
index|]
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
comment|/* Output the table */
name|emit_label
argument_list|(
name|table_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|CASE_VECTOR_PC_RELATIVE
operator|||
name|flag_pic
condition|)
name|emit_jump_insn
argument_list|(
name|gen_rtx_ADDR_DIFF_VEC
argument_list|(
name|CASE_VECTOR_MODE
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|table_label
argument_list|)
argument_list|,
name|gen_rtvec_v
argument_list|(
name|ncases
argument_list|,
name|labelvec
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_jump_insn
argument_list|(
name|gen_rtx_ADDR_VEC
argument_list|(
name|CASE_VECTOR_MODE
argument_list|,
name|gen_rtvec_v
argument_list|(
name|ncases
argument_list|,
name|labelvec
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the case insn drops through the table, 	     after the table we must jump to the default-label. 	     Otherwise record no drop-through after the table.  */
ifdef|#
directive|ifdef
name|CASE_DROPS_THROUGH
name|emit_jump
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_barrier
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|before_case
operator|=
name|NEXT_INSN
argument_list|(
name|before_case
argument_list|)
expr_stmt|;
name|end
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|squeeze_notes
argument_list|(
operator|&
name|before_case
argument_list|,
operator|&
name|end
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|reorder_insns
argument_list|(
name|before_case
argument_list|,
name|end
argument_list|,
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|start
argument_list|)
expr_stmt|;
block|}
else|else
name|end_cleanup_deferral
argument_list|()
expr_stmt|;
if|if
condition|(
name|thiscase
operator|->
name|exit_label
condition|)
name|emit_label
argument_list|(
name|thiscase
operator|->
name|exit_label
argument_list|)
expr_stmt|;
name|free_case_nodes
argument_list|(
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
argument_list|)
expr_stmt|;
name|POPSTACK
argument_list|(
name|case_stack
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert the tree NODE into a list linked by the right field, with the left    field zeroed.  RIGHT is used for recursion; it is a list to be placed    rightmost in the resulting list.  */
end_comment

begin_function
specifier|static
name|struct
name|case_node
modifier|*
name|case_tree2list
parameter_list|(
name|node
parameter_list|,
name|right
parameter_list|)
name|struct
name|case_node
modifier|*
name|node
decl_stmt|,
decl|*
name|right
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|case_node
modifier|*
name|left
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|right
condition|)
name|right
operator|=
name|case_tree2list
argument_list|(
name|node
operator|->
name|right
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|node
operator|->
name|right
operator|=
name|right
expr_stmt|;
if|if
condition|(
operator|(
name|left
operator|=
name|node
operator|->
name|left
operator|)
condition|)
block|{
name|node
operator|->
name|left
operator|=
literal|0
expr_stmt|;
return|return
name|case_tree2list
argument_list|(
name|left
argument_list|,
name|node
argument_list|)
return|;
block|}
return|return
name|node
return|;
block|}
end_block

begin_comment
comment|/* Generate code to jump to LABEL if OP1 and OP2 are equal.  */
end_comment

begin_function
specifier|static
name|void
name|do_jump_if_equal
parameter_list|(
name|op1
parameter_list|,
name|op2
parameter_list|,
name|label
parameter_list|,
name|unsignedp
parameter_list|)
name|rtx
name|op1
decl_stmt|,
name|op2
decl_stmt|,
name|label
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|op2
argument_list|)
condition|)
name|emit_jump
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_cmp_and_jump_insns
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
operator|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|==
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|op2
argument_list|)
else|:
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|)
argument_list|,
name|unsignedp
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Not all case values are encountered equally.  This function    uses a heuristic to weight case labels, in cases where that    looks like a reasonable thing to do.     Right now, all we try to guess is text, and we establish the    following weights:  	chars above space:	16 	digits:			16 	default:		12 	space, punct:		8 	tab:			4 	newline:		2 	other "\" chars:	1 	remaining chars:	0     If we find any cases in the switch that are not either -1 or in the range    of valid ASCII characters, or are control characters other than those    commonly used with "\", don't treat this switch scanning text.     Return 1 if these nodes are suitable for cost estimation, otherwise    return 0.  */
end_comment

begin_function
specifier|static
name|int
name|estimate_case_costs
parameter_list|(
name|node
parameter_list|)
name|case_node_ptr
name|node
decl_stmt|;
block|{
name|tree
name|min_ascii
init|=
name|integer_minus_one_node
decl_stmt|;
name|tree
name|max_ascii
init|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|node
operator|->
name|high
argument_list|)
argument_list|,
name|build_int_2
argument_list|(
literal|127
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|case_node_ptr
name|n
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If we haven't already made the cost table, make it now.  Note that the      lower bound of the table is -1, not zero.  */
if|if
condition|(
operator|!
name|cost_table_initialized
condition|)
block|{
name|cost_table_initialized
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ISALNUM
argument_list|(
name|i
argument_list|)
condition|)
name|COST_TABLE
argument_list|(
name|i
argument_list|)
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|ISPUNCT
argument_list|(
name|i
argument_list|)
condition|)
name|COST_TABLE
argument_list|(
name|i
argument_list|)
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|ISCNTRL
argument_list|(
name|i
argument_list|)
condition|)
name|COST_TABLE
argument_list|(
name|i
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|COST_TABLE
argument_list|(
literal|' '
argument_list|)
operator|=
literal|8
expr_stmt|;
name|COST_TABLE
argument_list|(
literal|'\t'
argument_list|)
operator|=
literal|4
expr_stmt|;
name|COST_TABLE
argument_list|(
literal|'\0'
argument_list|)
operator|=
literal|4
expr_stmt|;
name|COST_TABLE
argument_list|(
literal|'\n'
argument_list|)
operator|=
literal|2
expr_stmt|;
name|COST_TABLE
argument_list|(
literal|'\f'
argument_list|)
operator|=
literal|1
expr_stmt|;
name|COST_TABLE
argument_list|(
literal|'\v'
argument_list|)
operator|=
literal|1
expr_stmt|;
name|COST_TABLE
argument_list|(
literal|'\b'
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* See if all the case expressions look like text.  It is text if the      constant is>= -1 and the highest constant is<= 127.  Do all comparisons      as signed arithmetic since we don't want to ever access cost_table with a      value less than -1.  Also check that none of the constants in a range      are strange control characters.  */
for|for
control|(
name|n
operator|=
name|node
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
block|{
if|if
condition|(
operator|(
name|INT_CST_LT
argument_list|(
name|n
operator|->
name|low
argument_list|,
name|min_ascii
argument_list|)
operator|)
operator|||
name|INT_CST_LT
argument_list|(
name|max_ascii
argument_list|,
name|n
operator|->
name|high
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|low
argument_list|)
init|;
name|i
operator|<=
operator|(
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|high
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|COST_TABLE
argument_list|(
name|i
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* All interesting values are within the range of interesting      ASCII characters.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Scan an ordered list of case nodes    combining those with consecutive values or ranges.     Eg. three separate entries 1: 2: 3: become one entry 1..3:  */
end_comment

begin_function
specifier|static
name|void
name|group_case_nodes
parameter_list|(
name|head
parameter_list|)
name|case_node_ptr
name|head
decl_stmt|;
block|{
name|case_node_ptr
name|node
init|=
name|head
decl_stmt|;
while|while
condition|(
name|node
condition|)
block|{
name|rtx
name|lb
init|=
name|next_real_insn
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|lb2
decl_stmt|;
name|case_node_ptr
name|np
init|=
name|node
decl_stmt|;
comment|/* Try to group the successors of NODE with NODE.  */
while|while
condition|(
operator|(
operator|(
name|np
operator|=
name|np
operator|->
name|right
operator|)
operator|!=
literal|0
operator|)
comment|/* Do they jump to the same place?  */
operator|&&
operator|(
operator|(
name|lb2
operator|=
name|next_real_insn
argument_list|(
name|label_rtx
argument_list|(
name|np
operator|->
name|code_label
argument_list|)
argument_list|)
operator|)
operator|==
name|lb
operator|||
operator|(
name|lb
operator|!=
literal|0
operator|&&
name|lb2
operator|!=
literal|0
operator|&&
name|simplejump_p
argument_list|(
name|lb
argument_list|)
operator|&&
name|simplejump_p
argument_list|(
name|lb2
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|lb
argument_list|)
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|lb2
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
comment|/* Are their ranges consecutive?  */
operator|&&
name|tree_int_cst_equal
argument_list|(
name|np
operator|->
name|low
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|node
operator|->
name|high
argument_list|)
argument_list|,
name|node
operator|->
name|high
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|)
comment|/* An overflow is not consecutive.  */
operator|&&
name|tree_int_cst_lt
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|node
operator|->
name|high
argument_list|)
argument_list|,
name|node
operator|->
name|high
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|node
operator|->
name|high
operator|=
name|np
operator|->
name|high
expr_stmt|;
block|}
comment|/* NP is the first node after NODE which can't be grouped with it. 	 Delete the nodes in between, and move on to that node.  */
name|node
operator|->
name|right
operator|=
name|np
expr_stmt|;
name|node
operator|=
name|np
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Take an ordered list of case nodes    and transform them into a near optimal binary tree,    on the assumption that any target code selection value is as    likely as any other.     The transformation is performed by splitting the ordered    list into two equal sections plus a pivot.  The parts are    then attached to the pivot as left and right branches.  Each    branch is then transformed recursively.  */
end_comment

begin_function
specifier|static
name|void
name|balance_case_nodes
parameter_list|(
name|head
parameter_list|,
name|parent
parameter_list|)
name|case_node_ptr
modifier|*
name|head
decl_stmt|;
name|case_node_ptr
name|parent
decl_stmt|;
block|{
name|case_node_ptr
name|np
decl_stmt|;
name|np
operator|=
operator|*
name|head
expr_stmt|;
if|if
condition|(
name|np
condition|)
block|{
name|int
name|cost
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|ranges
init|=
literal|0
decl_stmt|;
name|case_node_ptr
modifier|*
name|npp
decl_stmt|;
name|case_node_ptr
name|left
decl_stmt|;
comment|/* Count the number of entries on branch.  Also count the ranges.  */
while|while
condition|(
name|np
condition|)
block|{
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|np
operator|->
name|low
argument_list|,
name|np
operator|->
name|high
argument_list|)
condition|)
block|{
name|ranges
operator|++
expr_stmt|;
if|if
condition|(
name|use_cost_table
condition|)
name|cost
operator|+=
name|COST_TABLE
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|np
operator|->
name|high
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|use_cost_table
condition|)
name|cost
operator|+=
name|COST_TABLE
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|np
operator|->
name|low
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|np
operator|=
name|np
operator|->
name|right
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|2
condition|)
block|{
comment|/* Split this list if it is long enough for that to help.  */
name|npp
operator|=
name|head
expr_stmt|;
name|left
operator|=
operator|*
name|npp
expr_stmt|;
if|if
condition|(
name|use_cost_table
condition|)
block|{
comment|/* Find the place in the list that bisects the list's total cost, 		 Here I gets half the total cost.  */
name|int
name|n_moved
init|=
literal|0
decl_stmt|;
name|i
operator|=
operator|(
name|cost
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Skip nodes while their cost does not reach that amount.  */
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
operator|(
operator|*
name|npp
operator|)
operator|->
name|low
argument_list|,
operator|(
operator|*
name|npp
operator|)
operator|->
name|high
argument_list|)
condition|)
name|i
operator|-=
name|COST_TABLE
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
operator|(
operator|*
name|npp
operator|)
operator|->
name|high
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|-=
name|COST_TABLE
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
operator|(
operator|*
name|npp
operator|)
operator|->
name|low
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
break|break;
name|npp
operator|=
operator|&
operator|(
operator|*
name|npp
operator|)
operator|->
name|right
expr_stmt|;
name|n_moved
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|n_moved
operator|==
literal|0
condition|)
block|{
comment|/* Leave this branch lopsided, but optimize left-hand 		     side and fill in `parent' fields for right-hand side.  */
name|np
operator|=
operator|*
name|head
expr_stmt|;
name|np
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|balance_case_nodes
argument_list|(
operator|&
name|np
operator|->
name|left
argument_list|,
name|np
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|np
operator|->
name|right
condition|;
name|np
operator|=
name|np
operator|->
name|right
control|)
name|np
operator|->
name|right
operator|->
name|parent
operator|=
name|np
expr_stmt|;
return|return;
block|}
block|}
comment|/* If there are just three nodes, split at the middle one.  */
elseif|else
if|if
condition|(
name|i
operator|==
literal|3
condition|)
name|npp
operator|=
operator|&
operator|(
operator|*
name|npp
operator|)
operator|->
name|right
expr_stmt|;
else|else
block|{
comment|/* Find the place in the list that bisects the list's total cost, 		 where ranges count as 2. 		 Here I gets half the total cost.  */
name|i
operator|=
operator|(
name|i
operator|+
name|ranges
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Skip nodes while their cost does not reach that amount.  */
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
operator|(
operator|*
name|npp
operator|)
operator|->
name|low
argument_list|,
operator|(
operator|*
name|npp
operator|)
operator|->
name|high
argument_list|)
condition|)
name|i
operator|--
expr_stmt|;
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
break|break;
name|npp
operator|=
operator|&
operator|(
operator|*
name|npp
operator|)
operator|->
name|right
expr_stmt|;
block|}
block|}
operator|*
name|head
operator|=
name|np
operator|=
operator|*
name|npp
expr_stmt|;
operator|*
name|npp
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|np
operator|->
name|left
operator|=
name|left
expr_stmt|;
comment|/* Optimize each of the two split parts.  */
name|balance_case_nodes
argument_list|(
operator|&
name|np
operator|->
name|left
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|balance_case_nodes
argument_list|(
operator|&
name|np
operator|->
name|right
argument_list|,
name|np
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Else leave this branch as one level, 	     but fill in `parent' fields.  */
name|np
operator|=
operator|*
name|head
expr_stmt|;
name|np
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
for|for
control|(
init|;
name|np
operator|->
name|right
condition|;
name|np
operator|=
name|np
operator|->
name|right
control|)
name|np
operator|->
name|right
operator|->
name|parent
operator|=
name|np
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Search the parent sections of the case node tree    to see if a test for the lower bound of NODE would be redundant.    INDEX_TYPE is the type of the index expression.     The instructions to generate the case decision tree are    output in the same order as nodes are processed so it is    known that if a parent node checks the range of the current    node minus one that the current node is bounded at its lower    span.  Thus the test would be redundant.  */
end_comment

begin_function
specifier|static
name|int
name|node_has_low_bound
parameter_list|(
name|node
parameter_list|,
name|index_type
parameter_list|)
name|case_node_ptr
name|node
decl_stmt|;
name|tree
name|index_type
decl_stmt|;
block|{
name|tree
name|low_minus_one
decl_stmt|;
name|case_node_ptr
name|pnode
decl_stmt|;
comment|/* If the lower bound of this node is the lowest value in the index type,      we need not test it.  */
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|node
operator|->
name|low
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|index_type
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If this node has a left branch, the value at the left must be less      than that at this node, so it cannot be bounded at the bottom and      we need not bother testing any further.  */
if|if
condition|(
name|node
operator|->
name|left
condition|)
return|return
literal|0
return|;
name|low_minus_one
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|node
operator|->
name|low
argument_list|)
argument_list|,
name|node
operator|->
name|low
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the subtraction above overflowed, we can't verify anything.      Otherwise, look for a parent that tests our value - 1.  */
if|if
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|low_minus_one
argument_list|,
name|node
operator|->
name|low
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|pnode
operator|=
name|node
operator|->
name|parent
init|;
name|pnode
condition|;
name|pnode
operator|=
name|pnode
operator|->
name|parent
control|)
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|low_minus_one
argument_list|,
name|pnode
operator|->
name|high
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Search the parent sections of the case node tree    to see if a test for the upper bound of NODE would be redundant.    INDEX_TYPE is the type of the index expression.     The instructions to generate the case decision tree are    output in the same order as nodes are processed so it is    known that if a parent node checks the range of the current    node plus one that the current node is bounded at its upper    span.  Thus the test would be redundant.  */
end_comment

begin_function
specifier|static
name|int
name|node_has_high_bound
parameter_list|(
name|node
parameter_list|,
name|index_type
parameter_list|)
name|case_node_ptr
name|node
decl_stmt|;
name|tree
name|index_type
decl_stmt|;
block|{
name|tree
name|high_plus_one
decl_stmt|;
name|case_node_ptr
name|pnode
decl_stmt|;
comment|/* If there is no upper bound, obviously no test is needed.  */
if|if
condition|(
name|TYPE_MAX_VALUE
argument_list|(
name|index_type
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* If the upper bound of this node is the highest value in the type      of the index expression, we need not test against it.  */
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|index_type
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If this node has a right branch, the value at the right must be greater      than that at this node, so it cannot be bounded at the top and      we need not bother testing any further.  */
if|if
condition|(
name|node
operator|->
name|right
condition|)
return|return
literal|0
return|;
name|high_plus_one
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|node
operator|->
name|high
argument_list|)
argument_list|,
name|node
operator|->
name|high
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the addition above overflowed, we can't verify anything.      Otherwise, look for a parent that tests our value + 1.  */
if|if
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|high_plus_one
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|pnode
operator|=
name|node
operator|->
name|parent
init|;
name|pnode
condition|;
name|pnode
operator|=
name|pnode
operator|->
name|parent
control|)
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|high_plus_one
argument_list|,
name|pnode
operator|->
name|low
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Search the parent sections of the    case node tree to see if both tests for the upper and lower    bounds of NODE would be redundant.  */
end_comment

begin_function
specifier|static
name|int
name|node_is_bounded
parameter_list|(
name|node
parameter_list|,
name|index_type
parameter_list|)
name|case_node_ptr
name|node
decl_stmt|;
name|tree
name|index_type
decl_stmt|;
block|{
return|return
operator|(
name|node_has_low_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
operator|&&
name|node_has_high_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  Emit an unconditional jump to LABEL unless it would be dead code.  */
end_comment

begin_function
specifier|static
name|void
name|emit_jump_if_reachable
parameter_list|(
name|label
parameter_list|)
name|rtx
name|label
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
operator|!=
name|BARRIER
condition|)
name|emit_jump
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit step-by-step code to select a case for the value of INDEX.    The thus generated decision tree follows the form of the    case-node binary tree NODE, whose nodes represent test conditions.    INDEX_TYPE is the type of the index of the switch.     Care is taken to prune redundant tests from the decision tree    by detecting any boundary conditions already checked by    emitted rtx.  (See node_has_high_bound, node_has_low_bound    and node_is_bounded, above.)     Where the test conditions can be shown to be redundant we emit    an unconditional jump to the target code.  As a further    optimization, the subordinates of a tree node are examined to    check for bounded nodes.  In this case conditional and/or    unconditional jumps as a result of the boundary check for the    current node are arranged to target the subordinates associated    code for out of bound conditions on the current node.     We can assume that when control reaches the code generated here,    the index value has already been compared with the parents    of this node, and determined to be on the same side of each parent    as this node is.  Thus, if this node tests for the value 51,    and a parent tested for 52, we don't need to consider    the possibility of a value greater than 51.  If another parent    tests for the value 50, then this node need not test anything.  */
end_comment

begin_function
specifier|static
name|void
name|emit_case_nodes
parameter_list|(
name|index
parameter_list|,
name|node
parameter_list|,
name|default_label
parameter_list|,
name|index_type
parameter_list|)
name|rtx
name|index
decl_stmt|;
name|case_node_ptr
name|node
decl_stmt|;
name|rtx
name|default_label
decl_stmt|;
name|tree
name|index_type
decl_stmt|;
block|{
comment|/* If INDEX has an unsigned type, we must make unsigned branches.  */
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|index_type
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|imode
init|=
name|TYPE_MODE
argument_list|(
name|index_type
argument_list|)
decl_stmt|;
comment|/* See if our parents have already tested everything for us.      If they have, emit an unconditional jump for this node.  */
if|if
condition|(
name|node_is_bounded
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
condition|)
name|emit_jump
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|node
operator|->
name|low
argument_list|,
name|node
operator|->
name|high
argument_list|)
condition|)
block|{
comment|/* Node is single valued.  First see if the index expression matches 	 this node and then check our children, if any.  */
name|do_jump_if_equal
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|low
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|right
operator|!=
literal|0
operator|&&
name|node
operator|->
name|left
operator|!=
literal|0
condition|)
block|{
comment|/* This node has children on both sides. 	     Dispatch to one side or the other 	     by comparing the index value with this node's value. 	     If one subtree is bounded, check that one first, 	     so we can avoid real branches in the tree.  */
if|if
condition|(
name|node_is_bounded
argument_list|(
name|node
operator|->
name|right
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|right
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|left
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node_is_bounded
argument_list|(
name|node
operator|->
name|left
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|LT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|left
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|right
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Neither node is bounded.  First distinguish the two sides; 		 then emit the code for one side at a time.  */
name|tree
name|test_label
init|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
comment|/* See if the value is on the right.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|label_rtx
argument_list|(
name|test_label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Value must be on the left. 		 Handle the left-hand subtree.  */
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|left
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
comment|/* If left-hand subtree does nothing, 		 go to default.  */
name|emit_jump_if_reachable
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
comment|/* Code branches here for the right-hand subtree.  */
name|expand_label
argument_list|(
name|test_label
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|right
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|right
operator|!=
literal|0
operator|&&
name|node
operator|->
name|left
operator|==
literal|0
condition|)
block|{
comment|/* Here we have a right child but no left so we issue conditional 	     branch to default and process the right child.  	     Omit the conditional branch to default if we it avoid only one 	     right child; it costs too much space to save so little time.  */
if|if
condition|(
name|node
operator|->
name|right
operator|->
name|right
operator|||
name|node
operator|->
name|right
operator|->
name|left
operator|||
operator|!
name|tree_int_cst_equal
argument_list|(
name|node
operator|->
name|right
operator|->
name|low
argument_list|,
name|node
operator|->
name|right
operator|->
name|high
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|node_has_low_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|LT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
block|}
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|right
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We cannot process node->right normally 	       since we haven't ruled out the numbers less than 	       this node's value.  So handle node->right explicitly.  */
name|do_jump_if_equal
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|right
operator|->
name|low
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|right
operator|->
name|code_label
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|right
operator|==
literal|0
operator|&&
name|node
operator|->
name|left
operator|!=
literal|0
condition|)
block|{
comment|/* Just one subtree, on the left.  */
if|if
condition|(
name|node
operator|->
name|left
operator|->
name|left
operator|||
name|node
operator|->
name|left
operator|->
name|right
operator|||
operator|!
name|tree_int_cst_equal
argument_list|(
name|node
operator|->
name|left
operator|->
name|low
argument_list|,
name|node
operator|->
name|left
operator|->
name|high
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|node_has_high_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
block|}
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|left
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We cannot process node->left normally 	       since we haven't ruled out the numbers less than 	       this node's value.  So handle node->left explicitly.  */
name|do_jump_if_equal
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|left
operator|->
name|low
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|left
operator|->
name|code_label
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Node is a range.  These cases are very similar to those for a single 	 value, except that we do not start by testing whether this node 	 is the one to branch to.  */
if|if
condition|(
name|node
operator|->
name|right
operator|!=
literal|0
operator|&&
name|node
operator|->
name|left
operator|!=
literal|0
condition|)
block|{
comment|/* Node has subtrees on both sides. 	     If the right-hand subtree is bounded, 	     test for it first, since we can go straight there. 	     Otherwise, we need to make a branch in the control structure, 	     then handle the two subtrees.  */
name|tree
name|test_label
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|node_is_bounded
argument_list|(
name|node
operator|->
name|right
argument_list|,
name|index_type
argument_list|)
condition|)
comment|/* Right hand node is fully bounded so we can eliminate any 	       testing and branch directly to the target code.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|right
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Right hand node requires testing. 		 Branch to a label where we will handle it later.  */
name|test_label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|label_rtx
argument_list|(
name|test_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Value belongs to this node or to the left-hand subtree.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|low
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|GE
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle the left-hand subtree.  */
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|left
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
comment|/* If right node had to be handled later, do that now.  */
if|if
condition|(
name|test_label
condition|)
block|{
comment|/* If the left-hand subtree fell through, 		 don't let it fall into the right-hand subtree.  */
name|emit_jump_if_reachable
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
name|expand_label
argument_list|(
name|test_label
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|right
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|right
operator|!=
literal|0
operator|&&
name|node
operator|->
name|left
operator|==
literal|0
condition|)
block|{
comment|/* Deal with values to the left of this node, 	     if they are possible.  */
if|if
condition|(
operator|!
name|node_has_low_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|low
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|LT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
block|}
comment|/* Value belongs to this node or to the right-hand subtree.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|LE
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|right
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|right
operator|==
literal|0
operator|&&
name|node
operator|->
name|left
operator|!=
literal|0
condition|)
block|{
comment|/* Deal with values to the right of this node, 	     if they are possible.  */
if|if
condition|(
operator|!
name|node_has_high_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
block|}
comment|/* Value belongs to this node or to the left-hand subtree.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|low
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|GE
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|left
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Node has no children so we check low and high bounds to remove 	     redundant tests.  Only one of the bounds can exist, 	     since otherwise this node is bounded--a case tested already.  */
name|int
name|high_bound
init|=
name|node_has_high_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
decl_stmt|;
name|int
name|low_bound
init|=
name|node_has_low_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|high_bound
operator|&&
name|low_bound
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|low_bound
operator|&&
name|high_bound
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|imode
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|low
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|LT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|low_bound
operator|&&
operator|!
name|high_bound
condition|)
block|{
comment|/* Widen LOW and HIGH to the same width as INDEX.  */
name|tree
name|type
init|=
name|type_for_mode
argument_list|(
name|mode
argument_list|,
name|unsignedp
argument_list|)
decl_stmt|;
name|tree
name|low
init|=
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|node
operator|->
name|low
argument_list|)
decl_stmt|;
name|tree
name|high
init|=
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|node
operator|->
name|high
argument_list|)
decl_stmt|;
name|rtx
name|low_rtx
decl_stmt|,
name|new_index
decl_stmt|,
name|new_bound
decl_stmt|;
comment|/* Instead of doing two branches, emit one unsigned branch for 		 (index-low)> (high-low).  */
name|low_rtx
operator|=
name|expand_expr
argument_list|(
name|low
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new_index
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|MINUS
argument_list|,
name|index
argument_list|,
name|low_rtx
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|new_bound
operator|=
name|expand_expr
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|high
argument_list|,
name|low
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|new_index
argument_list|,
name|new_bound
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
block|}
name|emit_jump
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

