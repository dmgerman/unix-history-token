begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Expands front end tree to back end RTL for GNU C-Compiler    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file handles the generation of rtl code from tree structure    above the level of expressions, using subroutines in exp*.c and emit-rtl.c.    It also creates the rtl expressions for parameters and auto variables    and has full responsibility for allocating stack slots.     The functions whose names start with `expand_' are called by the    parser to generate RTL instructions for various kinds of constructs.     Some control and binding constructs require calling several such    functions at different times.  For example, a simple if-then    is expanded by calling `expand_start_cond' (with the condition-expression    as argument) before parsing the then-clause and calling `expand_end_cond'    after parsing the then-clause.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"loop.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"machmode.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
name|struct
name|obstack
name|stmt_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Assume that case vectors are not pc-relative.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CASE_VECTOR_PC_RELATIVE
end_ifndef

begin_define
define|#
directive|define
name|CASE_VECTOR_PC_RELATIVE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Filename and line number of last line-number note,    whether we actually emitted it or not.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|emit_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|emit_lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if within a ({...}) grouping, in which case we must    always compute a value for each expr-stmt in case it is the last one.  */
end_comment

begin_decl_stmt
name|int
name|expr_stmts_for_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Each time we expand an expression-statement,    record the expr's type and its RTL value here.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|last_expr_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|last_expr_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Each time we expand the end of a binding contour (in `expand_end_bindings')    and we emit a new NOTE_INSN_BLOCK_END note, we save a pointer to it here.    This is used by the `remember_end_note' function to record the endpoint    of each generated block in its associated BLOCK node.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_block_end_note
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of binding contours started so far in this function.  */
end_comment

begin_decl_stmt
name|int
name|block_start_count
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Functions and data structures for expanding case statements.  */
end_comment

begin_comment
comment|/* Case label structure, used to hold info on labels within case    statements.  We handle "range" labels; for a single-value label    as in C, the high and low limits are the same.     An AVL tree of case nodes is initially created, and later transformed    to a list linked via the RIGHT fields in the nodes.  Nodes with    higher case values are later in the list.     Switch statements can be output in one of two forms.  A branch table    is used if there are more than a few labels and the labels are dense    within the range between the smallest and largest case value.  If a    branch table is used, no further manipulations are done with the case    node chain.     The alternative to the use of a branch table is to generate a series    of compare and jump insns.  When that is done, we use the LEFT, RIGHT,    and PARENT fields to hold a binary tree.  Initially the tree is    totally unbalanced, with everything on the right.  We balance the tree    with nodes on the left having lower case values than the parent    and nodes on the right having higher values.  We then output the tree    in order.  */
end_comment

begin_struct
struct|struct
name|case_node
block|{
name|struct
name|case_node
modifier|*
name|left
decl_stmt|;
comment|/* Left son in binary tree */
name|struct
name|case_node
modifier|*
name|right
decl_stmt|;
comment|/* Right son in binary tree; also node chain */
name|struct
name|case_node
modifier|*
name|parent
decl_stmt|;
comment|/* Parent of node in binary tree */
name|tree
name|low
decl_stmt|;
comment|/* Lowest index value for this label */
name|tree
name|high
decl_stmt|;
comment|/* Highest index value for this label */
name|tree
name|code_label
decl_stmt|;
comment|/* Label to jump to when node matches */
name|int
name|balance
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|case_node
name|case_node
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|case_node
modifier|*
name|case_node_ptr
typedef|;
end_typedef

begin_comment
comment|/* These are used by estimate_case_costs and balance_case_nodes.  */
end_comment

begin_comment
comment|/* This must be a signed type, and non-ANSI compilers lack signed char.  */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|cost_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|use_cost_table
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Stack of control and binding constructs we are currently inside.     These constructs begin when you call `expand_start_WHATEVER'    and end when you call `expand_end_WHATEVER'.  This stack records    info about how the construct began that tells the end-function    what to do.  It also may provide information about the construct    to alter the behavior of other constructs within the body.    For example, they may affect the behavior of C `break' and `continue'.     Each construct gets one `struct nesting' object.    All of these objects are chained through the `all' field.    `nesting_stack' points to the first object (innermost construct).    The position of an entry on `nesting_stack' is in its `depth' field.     Each type of construct has its own individual stack.    For example, loops have `loop_stack'.  Each object points to the    next object of the same type through the `next' field.     Some constructs are visible to `break' exit-statements and others    are not.  Which constructs are visible depends on the language.    Therefore, the data structure allows each construct to be visible    or not, according to the args given when the construct is started.    The construct is visible if the `exit_label' field is non-null.    In that case, the value should be a CODE_LABEL rtx.  */
end_comment

begin_struct
struct|struct
name|nesting
block|{
name|struct
name|nesting
modifier|*
name|all
decl_stmt|;
name|struct
name|nesting
modifier|*
name|next
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|rtx
name|exit_label
decl_stmt|;
union|union
block|{
comment|/* For conds (if-then and if-then-else statements).  */
struct|struct
block|{
comment|/* Label for the end of the if construct. 	     There is none if EXITFLAG was not set 	     and no `else' has been seen yet.  */
name|rtx
name|endif_label
decl_stmt|;
comment|/* Label for the end of this alternative. 	     This may be the end of the if or the next else/elseif.  */
name|rtx
name|next_label
decl_stmt|;
block|}
name|cond
struct|;
comment|/* For loops.  */
struct|struct
block|{
comment|/* Label at the top of the loop; place to loop back to.  */
name|rtx
name|start_label
decl_stmt|;
comment|/* Label at the end of the whole construct.  */
name|rtx
name|end_label
decl_stmt|;
comment|/* Label before a jump that branches to the end of the whole 	     construct.  This is where destructors go if any.  */
name|rtx
name|alt_end_label
decl_stmt|;
comment|/* Label for `continue' statement to jump to; 	     this is in front of the stepper of the loop.  */
name|rtx
name|continue_label
decl_stmt|;
block|}
name|loop
struct|;
comment|/* For variable binding contours.  */
struct|struct
block|{
comment|/* Sequence number of this binding contour within the function, 	     in order of entry.  */
name|int
name|block_start_count
decl_stmt|;
comment|/* Nonzero => value to restore stack to on exit.  */
name|rtx
name|stack_level
decl_stmt|;
comment|/* The NOTE that starts this contour. 	     Used by expand_goto to check whether the destination 	     is within each contour or not.  */
name|rtx
name|first_insn
decl_stmt|;
comment|/* Innermost containing binding contour that has a stack level.  */
name|struct
name|nesting
modifier|*
name|innermost_stack_block
decl_stmt|;
comment|/* List of cleanups to be run on exit from this contour. 	     This is a list of expressions to be evaluated. 	     The TREE_PURPOSE of each link is the ..._DECL node 	     which the cleanup pertains to.  */
name|tree
name|cleanups
decl_stmt|;
comment|/* List of cleanup-lists of blocks containing this block, 	     as they were at the locus where this block appears. 	     There is an element for each containing block, 	     ordered innermost containing block first. 	     The tail of this list can be 0, 	     if all remaining elements would be empty lists. 	     The element's TREE_VALUE is the cleanup-list of that block, 	     which may be null.  */
name|tree
name|outer_cleanups
decl_stmt|;
comment|/* Chain of labels defined inside this binding contour. 	     For contours that have stack levels or cleanups.  */
name|struct
name|label_chain
modifier|*
name|label_chain
decl_stmt|;
comment|/* Number of function calls seen, as of start of this block.  */
name|int
name|function_call_count
decl_stmt|;
comment|/* Nonzero if this is associated with a EH region.  */
name|int
name|exception_region
decl_stmt|;
comment|/* The saved target_temp_slot_level from our outer block. 	     We may reset target_temp_slot_level to be the level of 	     this block, if that is done, target_temp_slot_level 	     reverts to the saved target_temp_slot_level at the very 	     end of the block.  */
name|int
name|target_temp_slot_level
decl_stmt|;
comment|/* True if we are currently emitting insns in an area of 	     output code that is controlled by a conditional 	     expression.  This is used by the cleanup handling code to 	     generate conditional cleanup actions.  */
name|int
name|conditional_code
decl_stmt|;
comment|/* A place to move the start of the exception region for any 	     of the conditional cleanups, must be at the end or after 	     the start of the last unconditional cleanup, and before any 	     conditional branch points.  */
name|rtx
name|last_unconditional_cleanup
decl_stmt|;
comment|/* When in a conditional context, this is the specific 	     cleanup list associated with last_unconditional_cleanup, 	     where we place the conditionalized cleanups.  */
name|tree
modifier|*
name|cleanup_ptr
decl_stmt|;
block|}
name|block
struct|;
comment|/* For switch (C) or case (Pascal) statements, 	 and also for dummies (see `expand_start_case_dummy').  */
struct|struct
block|{
comment|/* The insn after which the case dispatch should finally 	     be emitted.  Zero for a dummy.  */
name|rtx
name|start
decl_stmt|;
comment|/* A list of case labels; it is first built as an AVL tree. 	     During expand_end_case, this is converted to a list, and may be 	     rearranged into a nearly balanced binary tree.  */
name|struct
name|case_node
modifier|*
name|case_list
decl_stmt|;
comment|/* Label to jump to if no case matches.  */
name|tree
name|default_label
decl_stmt|;
comment|/* The expression to be dispatched on.  */
name|tree
name|index_expr
decl_stmt|;
comment|/* Type that INDEX_EXPR should be converted to.  */
name|tree
name|nominal_type
decl_stmt|;
comment|/* Number of range exprs in case statement.  */
name|int
name|num_ranges
decl_stmt|;
comment|/* Name of this kind of statement, for warnings.  */
specifier|const
name|char
modifier|*
name|printname
decl_stmt|;
comment|/* Used to save no_line_numbers till we see the first case label. 	     We set this to -1 when we see the first case label in this 	     case statement.  */
name|int
name|line_number_status
decl_stmt|;
block|}
name|case_stmt
struct|;
block|}
name|data
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Chain of all pending binding contours.  */
end_comment

begin_decl_stmt
name|struct
name|nesting
modifier|*
name|block_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If any new stacks are added here, add them to POPSTACKS too.  */
end_comment

begin_comment
comment|/* Chain of all pending binding contours that restore stack levels    or have cleanups.  */
end_comment

begin_decl_stmt
name|struct
name|nesting
modifier|*
name|stack_block_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of all pending conditional statements.  */
end_comment

begin_decl_stmt
name|struct
name|nesting
modifier|*
name|cond_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of all pending loops.  */
end_comment

begin_decl_stmt
name|struct
name|nesting
modifier|*
name|loop_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of all pending case or switch statements.  */
end_comment

begin_decl_stmt
name|struct
name|nesting
modifier|*
name|case_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Separate chain including all of the above,    chained through the `all' field.  */
end_comment

begin_decl_stmt
name|struct
name|nesting
modifier|*
name|nesting_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of entries on nesting_stack now.  */
end_comment

begin_decl_stmt
name|int
name|nesting_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate and return a new `struct nesting'.  */
end_comment

begin_define
define|#
directive|define
name|ALLOC_NESTING
parameter_list|()
define|\
value|(struct nesting *) obstack_alloc (&stmt_obstack, sizeof (struct nesting))
end_define

begin_comment
comment|/* Pop the nesting stack element by element until we pop off    the element which is at the top of STACK.    Update all the other stacks, popping off elements from them    as we pop them from nesting_stack.  */
end_comment

begin_define
define|#
directive|define
name|POPSTACK
parameter_list|(
name|STACK
parameter_list|)
define|\
value|do { struct nesting *target = STACK;			\      struct nesting *this;				\      do { this = nesting_stack;				\ 	  if (loop_stack == this)			\ 	    loop_stack = loop_stack->next;		\ 	  if (cond_stack == this)			\ 	    cond_stack = cond_stack->next;		\ 	  if (block_stack == this)			\ 	    block_stack = block_stack->next;		\ 	  if (stack_block_stack == this)		\ 	    stack_block_stack = stack_block_stack->next; \ 	  if (case_stack == this)			\ 	    case_stack = case_stack->next;		\ 	  nesting_depth = nesting_stack->depth - 1;	\ 	  nesting_stack = this->all;			\ 	  obstack_free (&stmt_obstack, this); }		\      while (this != target); } while (0)
end_define

begin_escape
end_escape

begin_comment
comment|/* In some cases it is impossible to generate code for a forward goto    until the label definition is seen.  This happens when it may be necessary    for the goto to reset the stack pointer: we don't yet know how to do that.    So expand_goto puts an entry on this fixup list.    Each time a binding contour that resets the stack is exited,    we check each fixup.    If the target label has now been defined, we can insert the proper code.  */
end_comment

begin_struct
struct|struct
name|goto_fixup
block|{
comment|/* Points to following fixup.  */
name|struct
name|goto_fixup
modifier|*
name|next
decl_stmt|;
comment|/* Points to the insn before the jump insn.      If more code must be inserted, it goes after this insn.  */
name|rtx
name|before_jump
decl_stmt|;
comment|/* The LABEL_DECL that this jump is jumping to, or 0      for break, continue or return.  */
name|tree
name|target
decl_stmt|;
comment|/* The BLOCK for the place where this goto was found.  */
name|tree
name|context
decl_stmt|;
comment|/* The CODE_LABEL rtx that this is jumping to.  */
name|rtx
name|target_rtl
decl_stmt|;
comment|/* Number of binding contours started in current function      before the label reference.  */
name|int
name|block_start_count
decl_stmt|;
comment|/* The outermost stack level that should be restored for this jump.      Each time a binding contour that resets the stack is exited,      if the target label is *not* yet defined, this slot is updated.  */
name|rtx
name|stack_level
decl_stmt|;
comment|/* List of lists of cleanup expressions to be run by this goto.      There is one element for each block that this goto is within.      The tail of this list can be 0,      if all remaining elements would be empty.      The TREE_VALUE contains the cleanup list of that block as of the      time this goto was seen.      The TREE_ADDRESSABLE flag is 1 for a block that has been exited.  */
name|tree
name|cleanup_list_list
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|goto_fixup
modifier|*
name|goto_fixup_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Within any binding contour that must restore a stack level,    all labels are recorded with a chain of these structures.  */
end_comment

begin_struct
struct|struct
name|label_chain
block|{
comment|/* Points to following fixup.  */
name|struct
name|label_chain
modifier|*
name|next
decl_stmt|;
name|tree
name|label
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Non-zero if we are using EH to handle cleanus.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|using_eh_for_cleanups_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_occurrences
name|PROTO
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_goto_internal
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|expand_fixup
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_nl_handler_label
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_nl_goto_receiver
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_nl_goto_receivers
name|PROTO
argument_list|(
operator|(
expr|struct
name|nesting
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_gotos
name|PROTO
argument_list|(
operator|(
expr|struct
name|nesting
operator|*
operator|,
name|rtx
operator|,
name|tree
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_null_return_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_value_return
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tail_recursion_args
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_cleanups
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_seenlabel
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_jump_if_equal
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|estimate_case_costs
name|PROTO
argument_list|(
operator|(
name|case_node_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|group_case_nodes
name|PROTO
argument_list|(
operator|(
name|case_node_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|balance_case_nodes
name|PROTO
argument_list|(
operator|(
name|case_node_ptr
operator|*
operator|,
name|case_node_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|node_has_low_bound
name|PROTO
argument_list|(
operator|(
name|case_node_ptr
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|node_has_high_bound
name|PROTO
argument_list|(
operator|(
name|case_node_ptr
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|node_is_bounded
name|PROTO
argument_list|(
operator|(
name|case_node_ptr
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_jump_if_reachable
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_case_nodes
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|case_node_ptr
operator|,
name|rtx
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_case_node
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|case_node
modifier|*
name|case_tree2list
name|PROTO
argument_list|(
operator|(
name|case_node
operator|*
operator|,
name|case_node
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|using_eh_for_cleanups
parameter_list|()
block|{
name|using_eh_for_cleanups_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_stmt
parameter_list|()
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|stmt_obstack
argument_list|)
expr_stmt|;
name|init_eh
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_stmt_for_function
parameter_list|()
block|{
comment|/* We are not currently within any block, conditional, loop or case.  */
name|block_stack
operator|=
literal|0
expr_stmt|;
name|stack_block_stack
operator|=
literal|0
expr_stmt|;
name|loop_stack
operator|=
literal|0
expr_stmt|;
name|case_stack
operator|=
literal|0
expr_stmt|;
name|cond_stack
operator|=
literal|0
expr_stmt|;
name|nesting_stack
operator|=
literal|0
expr_stmt|;
name|nesting_depth
operator|=
literal|0
expr_stmt|;
name|block_start_count
operator|=
literal|0
expr_stmt|;
comment|/* No gotos have been expanded yet.  */
name|goto_fixup_chain
operator|=
literal|0
expr_stmt|;
comment|/* We are not processing a ({...}) grouping.  */
name|expr_stmts_for_value
operator|=
literal|0
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
name|init_eh_for_function
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|save_stmt_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|p
operator|->
name|block_stack
operator|=
name|block_stack
expr_stmt|;
name|p
operator|->
name|stack_block_stack
operator|=
name|stack_block_stack
expr_stmt|;
name|p
operator|->
name|cond_stack
operator|=
name|cond_stack
expr_stmt|;
name|p
operator|->
name|loop_stack
operator|=
name|loop_stack
expr_stmt|;
name|p
operator|->
name|case_stack
operator|=
name|case_stack
expr_stmt|;
name|p
operator|->
name|nesting_stack
operator|=
name|nesting_stack
expr_stmt|;
name|p
operator|->
name|nesting_depth
operator|=
name|nesting_depth
expr_stmt|;
name|p
operator|->
name|block_start_count
operator|=
name|block_start_count
expr_stmt|;
name|p
operator|->
name|last_expr_type
operator|=
name|last_expr_type
expr_stmt|;
name|p
operator|->
name|last_expr_value
operator|=
name|last_expr_value
expr_stmt|;
name|p
operator|->
name|expr_stmts_for_value
operator|=
name|expr_stmts_for_value
expr_stmt|;
name|p
operator|->
name|emit_filename
operator|=
name|emit_filename
expr_stmt|;
name|p
operator|->
name|emit_lineno
operator|=
name|emit_lineno
expr_stmt|;
name|p
operator|->
name|goto_fixup_chain
operator|=
name|goto_fixup_chain
expr_stmt|;
name|save_eh_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|restore_stmt_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|block_stack
operator|=
name|p
operator|->
name|block_stack
expr_stmt|;
name|stack_block_stack
operator|=
name|p
operator|->
name|stack_block_stack
expr_stmt|;
name|cond_stack
operator|=
name|p
operator|->
name|cond_stack
expr_stmt|;
name|loop_stack
operator|=
name|p
operator|->
name|loop_stack
expr_stmt|;
name|case_stack
operator|=
name|p
operator|->
name|case_stack
expr_stmt|;
name|nesting_stack
operator|=
name|p
operator|->
name|nesting_stack
expr_stmt|;
name|nesting_depth
operator|=
name|p
operator|->
name|nesting_depth
expr_stmt|;
name|block_start_count
operator|=
name|p
operator|->
name|block_start_count
expr_stmt|;
name|last_expr_type
operator|=
name|p
operator|->
name|last_expr_type
expr_stmt|;
name|last_expr_value
operator|=
name|p
operator|->
name|last_expr_value
expr_stmt|;
name|expr_stmts_for_value
operator|=
name|p
operator|->
name|expr_stmts_for_value
expr_stmt|;
name|emit_filename
operator|=
name|p
operator|->
name|emit_filename
expr_stmt|;
name|emit_lineno
operator|=
name|p
operator|->
name|emit_lineno
expr_stmt|;
name|goto_fixup_chain
operator|=
name|p
operator|->
name|goto_fixup_chain
expr_stmt|;
name|restore_eh_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit a no-op instruction.  */
end_comment

begin_function
name|void
name|emit_nop
parameter_list|()
block|{
name|rtx
name|last_insn
decl_stmt|;
name|last_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|optimize
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|last_insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
operator|(
name|GET_CODE
argument_list|(
name|last_insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|prev_real_insn
argument_list|(
name|last_insn
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
name|emit_insn
argument_list|(
name|gen_nop
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the rtx-label that corresponds to a LABEL_DECL,    creating it if necessary.  */
end_comment

begin_function
name|rtx
name|label_rtx
parameter_list|(
name|label
parameter_list|)
name|tree
name|label
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|LABEL_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|DECL_RTL
argument_list|(
name|label
argument_list|)
condition|)
return|return
name|DECL_RTL
argument_list|(
name|label
argument_list|)
return|;
return|return
name|DECL_RTL
argument_list|(
name|label
argument_list|)
operator|=
name|gen_label_rtx
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Add an unconditional jump to LABEL as the next sequential instruction.  */
end_comment

begin_function
name|void
name|emit_jump
parameter_list|(
name|label
parameter_list|)
name|rtx
name|label
decl_stmt|;
block|{
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit code to jump to the address    specified by the pointer expression EXP.  */
end_comment

begin_function
name|void
name|expand_computed_goto
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|rtx
name|x
init|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
name|x
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* Be sure the function is executable.  */
if|if
condition|(
name|current_function_check_memory_usage
condition|)
name|emit_library_call
argument_list|(
name|chkr_check_exec_libfunc
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|,
name|x
argument_list|,
name|ptr_mode
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_indirect_jump
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|current_function_has_computed_jump
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle goto statements and the labels that they can go to.  */
end_comment

begin_comment
comment|/* Specify the location in the RTL code of a label LABEL,    which is a LABEL_DECL tree node.     This is used for the kind of label that the user can jump to with a    goto statement, and for alternatives of a switch or case statement.    RTL labels generated for loops and conditionals don't go through here;    they are generated directly at the RTL level, by other functions below.     Note that this has nothing to do with defining label *names*.    Languages vary in how they do that and what that even means.  */
end_comment

begin_function
name|void
name|expand_label
parameter_list|(
name|label
parameter_list|)
name|tree
name|label
decl_stmt|;
block|{
name|struct
name|label_chain
modifier|*
name|p
decl_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label_rtx
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|label
argument_list|)
condition|)
name|LABEL_NAME
argument_list|(
name|DECL_RTL
argument_list|(
name|label
argument_list|)
argument_list|)
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack_block_stack
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
operator|(
expr|struct
name|label_chain
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|label_chain
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|stack_block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|label_chain
expr_stmt|;
name|stack_block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|label_chain
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|label
operator|=
name|label
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Declare that LABEL (a LABEL_DECL) may be used for nonlocal gotos    from nested functions.  */
end_comment

begin_function
name|void
name|declare_nonlocal_label
parameter_list|(
name|label
parameter_list|)
name|tree
name|label
decl_stmt|;
block|{
name|rtx
name|slot
init|=
name|assign_stack_local
argument_list|(
name|Pmode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|nonlocal_labels
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|label
argument_list|,
name|nonlocal_labels
argument_list|)
expr_stmt|;
name|LABEL_PRESERVE_P
argument_list|(
name|label_rtx
argument_list|(
name|label
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nonlocal_goto_handler_slots
operator|==
literal|0
condition|)
block|{
name|emit_stack_save
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
operator|&
name|nonlocal_goto_stack_level
argument_list|,
name|PREV_INSN
argument_list|(
name|tail_recursion_reentry
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|nonlocal_goto_handler_slots
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|slot
argument_list|,
name|nonlocal_goto_handler_slots
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL code for a `goto' statement with target label LABEL.    LABEL should be a LABEL_DECL tree node that was or will later be    defined with `expand_label'.  */
end_comment

begin_function
name|void
name|expand_goto
parameter_list|(
name|label
parameter_list|)
name|tree
name|label
decl_stmt|;
block|{
name|tree
name|context
decl_stmt|;
comment|/* Check for a nonlocal goto to a containing function.  */
name|context
operator|=
name|decl_function_context
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|!=
literal|0
operator|&&
name|context
operator|!=
name|current_function_decl
condition|)
block|{
name|struct
name|function
modifier|*
name|p
init|=
name|find_function_data
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|rtx
name|label_ref
init|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|label_rtx
argument_list|(
name|label
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|,
name|handler_slot
decl_stmt|;
name|tree
name|link
decl_stmt|;
comment|/* Find the corresponding handler slot for this label.  */
name|handler_slot
operator|=
name|p
operator|->
name|nonlocal_goto_handler_slots
expr_stmt|;
for|for
control|(
name|link
operator|=
name|p
operator|->
name|nonlocal_labels
init|;
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
operator|!=
name|label
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|handler_slot
operator|=
name|XEXP
argument_list|(
name|handler_slot
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|handler_slot
operator|=
name|XEXP
argument_list|(
name|handler_slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|has_nonlocal_label
operator|=
literal|1
expr_stmt|;
name|current_function_has_nonlocal_goto
operator|=
literal|1
expr_stmt|;
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|label_ref
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Copy the rtl for the slots so that they won't be shared in 	 case the virtual stack vars register gets instantiated differently 	 in the parent than in the child.  */
if|#
directive|if
name|HAVE_nonlocal_goto
if|if
condition|(
name|HAVE_nonlocal_goto
condition|)
name|emit_insn
argument_list|(
name|gen_nonlocal_goto
argument_list|(
name|lookup_static_chain
argument_list|(
name|label
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|handler_slot
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|p
operator|->
name|nonlocal_goto_stack_level
argument_list|)
argument_list|,
name|label_ref
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|rtx
name|addr
decl_stmt|;
comment|/* Restore frame pointer for containing function. 	     This sets the actual hard register used for the frame pointer 	     to the location of the function's incoming static chain info. 	     The non-local goto handler will then adjust it to contain the 	     proper value and reload the argument pointer, if needed.  */
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|lookup_static_chain
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We have now loaded the frame pointer hardware register with 	     the address of that corresponds to the start of the virtual 	     stack vars.  So replace virtual_stack_vars_rtx in all 	     addresses we use with stack_pointer_rtx.  */
comment|/* Get addr of containing function's current nonlocal goto handler, 	     which will do any cleanups and then jump to the label.  */
name|addr
operator|=
name|copy_rtx
argument_list|(
name|handler_slot
argument_list|)
expr_stmt|;
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|replace_rtx
argument_list|(
name|addr
argument_list|,
name|virtual_stack_vars_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore the stack pointer.  Note this uses fp just restored.  */
name|addr
operator|=
name|p
operator|->
name|nonlocal_goto_stack_level
expr_stmt|;
if|if
condition|(
name|addr
condition|)
name|addr
operator|=
name|replace_rtx
argument_list|(
name|copy_rtx
argument_list|(
name|addr
argument_list|)
argument_list|,
name|virtual_stack_vars_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
name|emit_stack_restore
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
name|addr
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* USE of hard_frame_pointer_rtx added for consistency; not clear if 	     really needed.  */
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_indirect_jump
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|expand_goto_internal
argument_list|(
name|label
argument_list|,
name|label_rtx
argument_list|(
name|label
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL code for a `goto' statement with target label BODY.    LABEL should be a LABEL_REF.    LAST_INSN, if non-0, is the rtx we should consider as the last    insn emitted (for the purposes of cleaning up a return).  */
end_comment

begin_function
specifier|static
name|void
name|expand_goto_internal
parameter_list|(
name|body
parameter_list|,
name|label
parameter_list|,
name|last_insn
parameter_list|)
name|tree
name|body
decl_stmt|;
name|rtx
name|label
decl_stmt|;
name|rtx
name|last_insn
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|block
decl_stmt|;
name|rtx
name|stack_level
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If label has already been defined, we can tell now      whether and how we must alter the stack level.  */
if|if
condition|(
name|PREV_INSN
argument_list|(
name|label
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Find the innermost pending block that contains the label. 	 (Check containment by comparing insn-uids.) 	 Then restore the outermost stack level within that block, 	 and do cleanups of all blocks contained in it.  */
for|for
control|(
name|block
operator|=
name|block_stack
init|;
name|block
condition|;
name|block
operator|=
name|block
operator|->
name|next
control|)
block|{
if|if
condition|(
name|INSN_UID
argument_list|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
argument_list|)
operator|<
name|INSN_UID
argument_list|(
name|label
argument_list|)
condition|)
break|break;
if|if
condition|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|!=
literal|0
condition|)
name|stack_level
operator|=
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
expr_stmt|;
comment|/* Execute the cleanups for blocks we are exiting.  */
if|if
condition|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|!=
literal|0
condition|)
block|{
name|expand_cleanups
argument_list|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stack_level
condition|)
block|{
comment|/* Ensure stack adjust isn't done by emit_jump, as this 	     would clobber the stack pointer.  This one should be 	     deleted as dead by flow.  */
name|clear_pending_stack_adjust
argument_list|()
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_stack_restore
argument_list|(
name|SAVE_BLOCK
argument_list|,
name|stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|body
operator|!=
literal|0
operator|&&
name|DECL_TOO_LATE
argument_list|(
name|body
argument_list|)
condition|)
name|error
argument_list|(
literal|"jump to `%s' invalidly jumps into binding contour"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Label not yet defined: may need to put this goto      on the fixup list.  */
elseif|else
if|if
condition|(
operator|!
name|expand_fixup
argument_list|(
name|body
argument_list|,
name|label
argument_list|,
name|last_insn
argument_list|)
condition|)
block|{
comment|/* No fixup needed.  Record that the label is the target 	 of at least one goto that has no fixup.  */
if|if
condition|(
name|body
operator|!=
literal|0
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|body
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|emit_jump
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate if necessary a fixup for a goto    whose target label in tree structure (if any) is TREE_LABEL    and whose target in rtl is RTL_LABEL.     If LAST_INSN is nonzero, we pretend that the jump appears    after insn LAST_INSN instead of at the current point in the insn stream.     The fixup will be used later to insert insns just before the goto.    Those insns will restore the stack level as appropriate for the    target label, and will (in the case of C++) also invoke any object    destructors which have to be invoked when we exit the scopes which    are exited by the goto.     Value is nonzero if a fixup is made.  */
end_comment

begin_function
specifier|static
name|int
name|expand_fixup
parameter_list|(
name|tree_label
parameter_list|,
name|rtl_label
parameter_list|,
name|last_insn
parameter_list|)
name|tree
name|tree_label
decl_stmt|;
name|rtx
name|rtl_label
decl_stmt|;
name|rtx
name|last_insn
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|block
decl_stmt|,
modifier|*
name|end_block
decl_stmt|;
comment|/* See if we can recognize which block the label will be output in.      This is possible in some very common cases.      If we succeed, set END_BLOCK to that block.      Otherwise, set it to 0.  */
if|if
condition|(
name|cond_stack
operator|&&
operator|(
name|rtl_label
operator|==
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
operator|||
name|rtl_label
operator|==
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
operator|)
condition|)
name|end_block
operator|=
name|cond_stack
expr_stmt|;
comment|/* If we are in a loop, recognize certain labels which      are likely targets.  This reduces the number of fixups      we need to create.  */
elseif|else
if|if
condition|(
name|loop_stack
operator|&&
operator|(
name|rtl_label
operator|==
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
operator|||
name|rtl_label
operator|==
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
operator|||
name|rtl_label
operator|==
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|continue_label
operator|)
condition|)
name|end_block
operator|=
name|loop_stack
expr_stmt|;
else|else
name|end_block
operator|=
literal|0
expr_stmt|;
comment|/* Now set END_BLOCK to the binding level to which we will return.  */
if|if
condition|(
name|end_block
condition|)
block|{
name|struct
name|nesting
modifier|*
name|next_block
init|=
name|end_block
operator|->
name|all
decl_stmt|;
name|block
operator|=
name|block_stack
expr_stmt|;
comment|/* First see if the END_BLOCK is inside the innermost binding level. 	 If so, then no cleanups or stack levels are relevant.  */
while|while
condition|(
name|next_block
operator|&&
name|next_block
operator|!=
name|block
condition|)
name|next_block
operator|=
name|next_block
operator|->
name|all
expr_stmt|;
if|if
condition|(
name|next_block
condition|)
return|return
literal|0
return|;
comment|/* Otherwise, set END_BLOCK to the innermost binding level 	 which is outside the relevant control-structure nesting.  */
name|next_block
operator|=
name|block_stack
operator|->
name|next
expr_stmt|;
for|for
control|(
name|block
operator|=
name|block_stack
init|;
name|block
operator|!=
name|end_block
condition|;
name|block
operator|=
name|block
operator|->
name|all
control|)
if|if
condition|(
name|block
operator|==
name|next_block
condition|)
name|next_block
operator|=
name|next_block
operator|->
name|next
expr_stmt|;
name|end_block
operator|=
name|next_block
expr_stmt|;
block|}
comment|/* Does any containing block have a stack level or cleanups?      If not, no fixup is needed, and that is the normal case      (the only case, for standard C).  */
for|for
control|(
name|block
operator|=
name|block_stack
init|;
name|block
operator|!=
name|end_block
condition|;
name|block
operator|=
name|block
operator|->
name|next
control|)
if|if
condition|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|!=
literal|0
operator|||
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|block
operator|!=
name|end_block
condition|)
block|{
comment|/* Ok, a fixup is needed.  Add a fixup to the list of such.  */
name|struct
name|goto_fixup
modifier|*
name|fixup
init|=
operator|(
expr|struct
name|goto_fixup
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|goto_fixup
argument_list|)
argument_list|)
decl_stmt|;
comment|/* In case an old stack level is restored, make sure that comes 	 after any pending stack adjust.  */
comment|/* ?? If the fixup isn't to come at the present position, 	 doing the stack adjust here isn't useful.  Doing it with our 	 settings at that location isn't useful either.  Let's hope 	 someone does it!  */
if|if
condition|(
name|last_insn
operator|==
literal|0
condition|)
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|fixup
operator|->
name|target
operator|=
name|tree_label
expr_stmt|;
name|fixup
operator|->
name|target_rtl
operator|=
name|rtl_label
expr_stmt|;
comment|/* Create a BLOCK node and a corresponding matched set of 	 NOTE_INSN_BEGIN_BLOCK and NOTE_INSN_END_BLOCK notes at 	 this point.  The notes will encapsulate any and all fixup 	 code which we might later insert at this point in the insn 	 stream.  Also, the BLOCK node will be the parent (i.e. the 	 `SUPERBLOCK') of any other BLOCK nodes which we might create 	 later on when we are expanding the fixup code.  	 Note that optimization passes (including expand_end_loop) 	 might move the *_BLOCK notes away, so we use a NOTE_INSN_DELETED 	 as a placeholder.  */
block|{
specifier|register
name|rtx
name|original_before_jump
init|=
name|last_insn
condition|?
name|last_insn
else|:
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|start
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|start
operator|=
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_BLOCK_BEG
argument_list|)
expr_stmt|;
name|fixup
operator|->
name|before_jump
operator|=
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|last_block_end_note
operator|=
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_BLOCK_END
argument_list|)
expr_stmt|;
name|fixup
operator|->
name|context
operator|=
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Create the BLOCK node now! */
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_after
argument_list|(
name|start
argument_list|,
name|original_before_jump
argument_list|)
expr_stmt|;
block|}
name|fixup
operator|->
name|block_start_count
operator|=
name|block_start_count
expr_stmt|;
name|fixup
operator|->
name|stack_level
operator|=
literal|0
expr_stmt|;
name|fixup
operator|->
name|cleanup_list_list
operator|=
operator|(
operator|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
operator|||
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|)
condition|?
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|,
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|fixup
operator|->
name|next
operator|=
name|goto_fixup_chain
expr_stmt|;
name|goto_fixup_chain
operator|=
name|fixup
expr_stmt|;
block|}
return|return
name|block
operator|!=
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand any needed fixups in the outputmost binding level of the    function.  FIRST_INSN is the first insn in the function.  */
end_comment

begin_function
name|void
name|expand_fixups
parameter_list|(
name|first_insn
parameter_list|)
name|rtx
name|first_insn
decl_stmt|;
block|{
name|fixup_gotos
argument_list|(
name|NULL_PTR
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_TREE
argument_list|,
name|first_insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When exiting a binding contour, process all pending gotos requiring fixups.    THISBLOCK is the structure that describes the block being exited.    STACK_LEVEL is the rtx for the stack level to restore exiting this contour.    CLEANUP_LIST is a list of expressions to evaluate on exiting this contour.    FIRST_INSN is the insn that began this contour.     Gotos that jump out of this contour must restore the    stack level and do the cleanups before actually jumping.     DONT_JUMP_IN nonzero means report error there is a jump into this    contour from before the beginning of the contour.    This is also done if STACK_LEVEL is nonzero.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_gotos
parameter_list|(
name|thisblock
parameter_list|,
name|stack_level
parameter_list|,
name|cleanup_list
parameter_list|,
name|first_insn
parameter_list|,
name|dont_jump_in
parameter_list|)
name|struct
name|nesting
modifier|*
name|thisblock
decl_stmt|;
name|rtx
name|stack_level
decl_stmt|;
name|tree
name|cleanup_list
decl_stmt|;
name|rtx
name|first_insn
decl_stmt|;
name|int
name|dont_jump_in
decl_stmt|;
block|{
specifier|register
name|struct
name|goto_fixup
modifier|*
name|f
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
comment|/* F is the fixup we are considering; PREV is the previous one.  */
comment|/* We run this loop in two passes so that cleanups of exited blocks      are run first, and blocks that are exited are marked so      afterwards.  */
for|for
control|(
name|prev
operator|=
literal|0
operator|,
name|f
operator|=
name|goto_fixup_chain
init|;
name|f
condition|;
name|prev
operator|=
name|f
operator|,
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
comment|/* Test for a fixup that is inactive because it is already handled.  */
if|if
condition|(
name|f
operator|->
name|before_jump
operator|==
literal|0
condition|)
block|{
comment|/* Delete inactive fixup from the chain, if that is easy to do.  */
if|if
condition|(
name|prev
operator|!=
literal|0
condition|)
name|prev
operator|->
name|next
operator|=
name|f
operator|->
name|next
expr_stmt|;
block|}
comment|/* Has this fixup's target label been defined? 	 If so, we can finalize it.  */
elseif|else
if|if
condition|(
name|PREV_INSN
argument_list|(
name|f
operator|->
name|target_rtl
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|register
name|rtx
name|cleanup_insns
decl_stmt|;
comment|/* Get the first non-label after the label 	     this goto jumps to.  If that's before this scope begins, 	     we don't have a jump into the scope.  */
name|rtx
name|after_label
init|=
name|f
operator|->
name|target_rtl
decl_stmt|;
while|while
condition|(
name|after_label
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|after_label
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|after_label
operator|=
name|NEXT_INSN
argument_list|(
name|after_label
argument_list|)
expr_stmt|;
comment|/* If this fixup jumped into this contour from before the beginning 	     of this contour, report an error.  */
comment|/* ??? Bug: this does not detect jumping in through intermediate 	     blocks that have stack levels or cleanups. 	     It detects only a problem with the innermost block 	     around the label.  */
if|if
condition|(
name|f
operator|->
name|target
operator|!=
literal|0
operator|&&
operator|(
name|dont_jump_in
operator|||
name|stack_level
operator|||
name|cleanup_list
operator|)
comment|/* If AFTER_LABEL is 0, it means the jump goes to the end 		 of the rtl, which means it jumps into this scope.  */
operator|&&
operator|(
name|after_label
operator|==
literal|0
operator|||
name|INSN_UID
argument_list|(
name|first_insn
argument_list|)
operator|<
name|INSN_UID
argument_list|(
name|after_label
argument_list|)
operator|)
operator|&&
name|INSN_UID
argument_list|(
name|first_insn
argument_list|)
operator|>
name|INSN_UID
argument_list|(
name|f
operator|->
name|before_jump
argument_list|)
operator|&&
operator|!
name|DECL_ERROR_ISSUED
argument_list|(
name|f
operator|->
name|target
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|f
operator|->
name|target
argument_list|,
literal|"label `%s' used before containing binding contour"
argument_list|)
expr_stmt|;
comment|/* Prevent multiple errors for one label.  */
name|DECL_ERROR_ISSUED
argument_list|(
name|f
operator|->
name|target
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We will expand the cleanups into a sequence of their own and 	     then later on we will attach this new sequence to the insn 	     stream just ahead of the actual jump insn.  */
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Temporarily restore the lexical context where we will 	     logically be inserting the fixup code.  We do this for the 	     sake of getting the debugging information right.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|set_block
argument_list|(
name|f
operator|->
name|context
argument_list|)
expr_stmt|;
comment|/* Expand the cleanups for blocks this jump exits.  */
if|if
condition|(
name|f
operator|->
name|cleanup_list_list
condition|)
block|{
name|tree
name|lists
decl_stmt|;
for|for
control|(
name|lists
operator|=
name|f
operator|->
name|cleanup_list_list
init|;
name|lists
condition|;
name|lists
operator|=
name|TREE_CHAIN
argument_list|(
name|lists
argument_list|)
control|)
comment|/* Marked elements correspond to blocks that have been closed. 		   Do their cleanups.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|lists
argument_list|)
operator|&&
name|TREE_VALUE
argument_list|(
name|lists
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|expand_cleanups
argument_list|(
name|TREE_VALUE
argument_list|(
name|lists
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Pop any pushes done in the cleanups, 		       in case function is about to return.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Restore stack level for the biggest contour that this 	     jump jumps out of.  */
if|if
condition|(
name|f
operator|->
name|stack_level
condition|)
name|emit_stack_restore
argument_list|(
name|SAVE_BLOCK
argument_list|,
name|f
operator|->
name|stack_level
argument_list|,
name|f
operator|->
name|before_jump
argument_list|)
expr_stmt|;
comment|/* Finish up the sequence containing the insns which implement the 	     necessary cleanups, and then attach that whole sequence to the 	     insn stream just ahead of the actual jump insn.  Attaching it 	     at that point insures that any cleanups which are in fact 	     implicit C++ object destructions (which must be executed upon 	     leaving the block) appear (to the debugger) to be taking place 	     in an area of the generated code where the object(s) being 	     destructed are still "in scope".  */
name|cleanup_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_after
argument_list|(
name|cleanup_insns
argument_list|,
name|f
operator|->
name|before_jump
argument_list|)
expr_stmt|;
name|f
operator|->
name|before_jump
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* For any still-undefined labels, do the cleanups for this block now.      We must do this now since items in the cleanup list may go out      of scope when the block ends.  */
for|for
control|(
name|prev
operator|=
literal|0
operator|,
name|f
operator|=
name|goto_fixup_chain
init|;
name|f
condition|;
name|prev
operator|=
name|f
operator|,
name|f
operator|=
name|f
operator|->
name|next
control|)
if|if
condition|(
name|f
operator|->
name|before_jump
operator|!=
literal|0
operator|&&
name|PREV_INSN
argument_list|(
name|f
operator|->
name|target_rtl
argument_list|)
operator|==
literal|0
comment|/* Label has still not appeared.  If we are exiting a block with 	   a stack level to restore, that started before the fixup, 	   mark this stack level as needing restoration 	   when the fixup is later finalized.   */
operator|&&
name|thisblock
operator|!=
literal|0
comment|/* Note: if THISBLOCK == 0 and we have a label that hasn't appeared, it 	   means the label is undefined.  That's erroneous, but possible.  */
operator|&&
operator|(
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|block_start_count
operator|<=
name|f
operator|->
name|block_start_count
operator|)
condition|)
block|{
name|tree
name|lists
init|=
name|f
operator|->
name|cleanup_list_list
decl_stmt|;
name|rtx
name|cleanup_insns
decl_stmt|;
for|for
control|(
init|;
name|lists
condition|;
name|lists
operator|=
name|TREE_CHAIN
argument_list|(
name|lists
argument_list|)
control|)
comment|/* If the following elt. corresponds to our containing block 	     then the elt. must be for this block.  */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|lists
argument_list|)
operator|==
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|set_block
argument_list|(
name|f
operator|->
name|context
argument_list|)
expr_stmt|;
name|expand_cleanups
argument_list|(
name|TREE_VALUE
argument_list|(
name|lists
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|cleanup_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|cleanup_insns
operator|!=
literal|0
condition|)
name|f
operator|->
name|before_jump
operator|=
name|emit_insns_after
argument_list|(
name|cleanup_insns
argument_list|,
name|f
operator|->
name|before_jump
argument_list|)
expr_stmt|;
name|f
operator|->
name|cleanup_list_list
operator|=
name|TREE_CHAIN
argument_list|(
name|lists
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stack_level
condition|)
name|f
operator|->
name|stack_level
operator|=
name|stack_level
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the number of times character C occurs in string S.  */
end_comment

begin_function
specifier|static
name|int
name|n_occurrences
parameter_list|(
name|c
parameter_list|,
name|s
parameter_list|)
name|int
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|n
operator|+=
operator|(
operator|*
name|s
operator|++
operator|==
name|c
operator|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL for an asm statement (explicit assembler code).    BODY is a STRING_CST node containing the assembler code text,    or an ADDR_EXPR containing a STRING_CST.  */
end_comment

begin_function
name|void
name|expand_asm
parameter_list|(
name|body
parameter_list|)
name|tree
name|body
decl_stmt|;
block|{
if|if
condition|(
name|current_function_check_memory_usage
condition|)
block|{
name|error
argument_list|(
literal|"`asm' cannot be used with `-fcheck-memory-usage'"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|body
operator|=
name|TREE_OPERAND
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_ASM_INPUT
argument_list|(
name|VOIDmode
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL for an asm statement with arguments.    STRING is the instruction template.    OUTPUTS is a list of output arguments (lvalues); INPUTS a list of inputs.    Each output or input has an expression in the TREE_VALUE and    a constraint-string in the TREE_PURPOSE.    CLOBBERS is a list of STRING_CST nodes each naming a hard register    that is clobbered by this insn.     Not all kinds of lvalue that may appear in OUTPUTS can be stored directly.    Some elements of OUTPUTS may be replaced with trees representing temporary    values.  The caller should copy those temporary values to the originally    specified lvalues.     VOL nonzero means the insn is volatile; don't optimize it.  */
end_comment

begin_function
name|void
name|expand_asm_operands
parameter_list|(
name|string
parameter_list|,
name|outputs
parameter_list|,
name|inputs
parameter_list|,
name|clobbers
parameter_list|,
name|vol
parameter_list|,
name|filename
parameter_list|,
name|line
parameter_list|)
name|tree
name|string
decl_stmt|,
name|outputs
decl_stmt|,
name|inputs
decl_stmt|,
name|clobbers
decl_stmt|;
name|int
name|vol
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|rtvec
name|argvec
decl_stmt|,
name|constraints
decl_stmt|;
name|rtx
name|body
decl_stmt|;
name|int
name|ninputs
init|=
name|list_length
argument_list|(
name|inputs
argument_list|)
decl_stmt|;
name|int
name|noutputs
init|=
name|list_length
argument_list|(
name|outputs
argument_list|)
decl_stmt|;
name|int
name|ninout
init|=
literal|0
decl_stmt|;
name|int
name|nclobbers
decl_stmt|;
name|tree
name|tail
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Vector of RTX's of evaluated output operands.  */
name|rtx
modifier|*
name|output_rtx
init|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|noutputs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
decl_stmt|;
name|int
modifier|*
name|inout_opnum
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|noutputs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|real_output_rtx
init|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|noutputs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
modifier|*
name|inout_mode
init|=
operator|(
expr|enum
name|machine_mode
operator|*
operator|)
name|alloca
argument_list|(
name|noutputs
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|machine_mode
argument_list|)
argument_list|)
decl_stmt|;
comment|/* The insn we have emitted.  */
name|rtx
name|insn
decl_stmt|;
comment|/* An ASM with no outputs needs to be treated as volatile, for now.  */
if|if
condition|(
name|noutputs
operator|==
literal|0
condition|)
name|vol
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|current_function_check_memory_usage
condition|)
block|{
name|error
argument_list|(
literal|"`asm' cannot be used with `-fcheck-memory-usage'"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Count the number of meaningful clobbered registers, ignoring what      we would ignore later.  */
name|nclobbers
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|clobbers
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|char
modifier|*
name|regname
init|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
decl_stmt|;
name|i
operator|=
name|decode_reg_name
argument_list|(
name|regname
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
operator|||
name|i
operator|==
operator|-
literal|4
condition|)
operator|++
name|nclobbers
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
operator|-
literal|2
condition|)
name|error
argument_list|(
literal|"unknown register name `%s' in `asm'"
argument_list|,
name|regname
argument_list|)
expr_stmt|;
block|}
name|last_expr_type
operator|=
literal|0
expr_stmt|;
comment|/* Check that the number of alternatives is constant across all      operands.  */
if|if
condition|(
name|outputs
operator|||
name|inputs
condition|)
block|{
name|tree
name|tmp
init|=
name|TREE_PURPOSE
argument_list|(
name|outputs
condition|?
name|outputs
else|:
name|inputs
argument_list|)
decl_stmt|;
name|int
name|nalternatives
init|=
name|n_occurrences
argument_list|(
literal|','
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|tmp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|next
init|=
name|inputs
decl_stmt|;
if|if
condition|(
name|nalternatives
operator|+
literal|1
operator|>
name|MAX_RECOG_ALTERNATIVES
condition|)
block|{
name|error
argument_list|(
literal|"too many alternatives in `asm'"
argument_list|)
expr_stmt|;
return|return;
block|}
name|tmp
operator|=
name|outputs
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
name|char
modifier|*
name|constraint
init|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tmp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|n_occurrences
argument_list|(
literal|','
argument_list|,
name|constraint
argument_list|)
operator|!=
name|nalternatives
condition|)
block|{
name|error
argument_list|(
literal|"operand constraints for `asm' differ in number of alternatives"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
condition|)
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
name|next
operator|,
name|next
operator|=
literal|0
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|char
modifier|*
name|constraint
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|c_len
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|is_inout
init|=
literal|0
decl_stmt|;
name|int
name|allows_reg
init|=
literal|0
decl_stmt|;
name|int
name|allows_mem
init|=
literal|0
decl_stmt|;
comment|/* If there's an erroneous arg, emit no insn.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* Make sure constraint has `=' and does not have `+'.  Also, see 	 if it allows any register.  Be liberal on the latter test, since 	 the worst that happens if we get it wrong is we issue an error 	 message.  */
name|c_len
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
name|constraint
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allow the `=' or `+' to not be at the beginning of the string, 	 since it wasn't explicitly documented that way, and there is a 	 large body of code that puts it last.  Swap the character to 	 the front, so as not to uglify any place else.  */
switch|switch
condition|(
name|c_len
condition|)
block|{
default|default:
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|constraint
argument_list|,
literal|'='
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
break|break;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|constraint
argument_list|,
literal|'+'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
break|break;
case|case
literal|0
case|:
name|error
argument_list|(
literal|"output operand constraint lacks `='"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|!=
name|constraint
condition|)
block|{
name|j
operator|=
operator|*
name|p
expr_stmt|;
name|bcopy
argument_list|(
name|constraint
argument_list|,
name|constraint
operator|+
literal|1
argument_list|,
name|p
operator|-
name|constraint
argument_list|)
expr_stmt|;
operator|*
name|constraint
operator|=
name|j
expr_stmt|;
name|warning
argument_list|(
literal|"output constraint `%c' for operand %d is not at the beginning"
argument_list|,
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|is_inout
operator|=
name|constraint
index|[
literal|0
index|]
operator|==
literal|'+'
expr_stmt|;
comment|/* Replace '+' with '='.  */
name|constraint
index|[
literal|0
index|]
operator|=
literal|'='
expr_stmt|;
comment|/* Make sure we can specify the matching operand.  */
if|if
condition|(
name|is_inout
operator|&&
name|i
operator|>
literal|9
condition|)
block|{
name|error
argument_list|(
literal|"output operand constraint %d contains `+'"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|c_len
condition|;
name|j
operator|++
control|)
switch|switch
condition|(
name|constraint
index|[
name|j
index|]
condition|)
block|{
case|case
literal|'+'
case|:
case|case
literal|'='
case|:
name|error
argument_list|(
literal|"operand constraint contains '+' or '=' at illegal position."
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'%'
case|:
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|ninputs
operator|+
name|noutputs
condition|)
block|{
name|error
argument_list|(
literal|"`%%' constraint used with last operand"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|'?'
case|:
case|case
literal|'!'
case|:
case|case
literal|'*'
case|:
case|case
literal|'&'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'s'
case|:
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|','
case|:
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
endif|#
directive|endif
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|error
argument_list|(
literal|"matching constraint not valid in output operand"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
case|case
literal|'m'
case|:
case|case
literal|'o'
case|:
name|allows_mem
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
comment|/* ??? Before flow, auto inc/dec insns are not supposed to exist,              excepting those that expand_call created.  So match memory 	     and hope.  */
name|allows_mem
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'X'
case|:
name|allows_reg
operator|=
literal|1
expr_stmt|;
name|allows_mem
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'r'
case|:
default|default:
name|allows_reg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* If an output operand is not a decl or indirect ref and our constraint 	 allows a register, make a temporary to act as an intermediate. 	 Make the asm insn write into that, then our caller will copy it to 	 the real output operand.  Likewise for promoted variables.  */
name|real_output_rtx
index|[
name|i
index|]
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|allows_mem
operator|)
operator|||
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
literal|'d'
operator|&&
operator|(
name|allows_mem
operator|||
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|val
argument_list|)
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|)
operator|)
operator|||
operator|!
name|allows_reg
operator|||
name|is_inout
condition|)
block|{
if|if
condition|(
operator|!
name|allows_reg
condition|)
name|mark_addressable
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
name|output_rtx
index|[
name|i
index|]
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_MEMORY_USE_WO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allows_reg
operator|&&
name|GET_CODE
argument_list|(
name|output_rtx
index|[
name|i
index|]
argument_list|)
operator|!=
name|MEM
condition|)
name|error
argument_list|(
literal|"output number %d not directly addressable"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allows_mem
operator|&&
name|GET_CODE
argument_list|(
name|output_rtx
index|[
name|i
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|real_output_rtx
index|[
name|i
index|]
operator|=
name|protect_from_queue
argument_list|(
name|output_rtx
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|output_rtx
index|[
name|i
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|output_rtx
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_inout
condition|)
name|emit_move_insn
argument_list|(
name|output_rtx
index|[
name|i
index|]
argument_list|,
name|real_output_rtx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|output_rtx
index|[
name|i
index|]
operator|=
name|assign_temp
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|=
name|make_tree
argument_list|(
name|type
argument_list|,
name|output_rtx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_inout
condition|)
block|{
name|inout_mode
index|[
name|ninout
index|]
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|inout_opnum
index|[
name|ninout
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
name|ninputs
operator|+=
name|ninout
expr_stmt|;
if|if
condition|(
name|ninputs
operator|+
name|noutputs
operator|>
name|MAX_RECOG_OPERANDS
condition|)
block|{
name|error
argument_list|(
literal|"more than %d operands in `asm'"
argument_list|,
name|MAX_RECOG_OPERANDS
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Make vectors for the expression-rtx and constraint strings.  */
name|argvec
operator|=
name|rtvec_alloc
argument_list|(
name|ninputs
argument_list|)
expr_stmt|;
name|constraints
operator|=
name|rtvec_alloc
argument_list|(
name|ninputs
argument_list|)
expr_stmt|;
name|body
operator|=
name|gen_rtx_ASM_OPERANDS
argument_list|(
name|VOIDmode
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|string
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
name|argvec
argument_list|,
name|constraints
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|body
argument_list|)
operator|=
name|vol
expr_stmt|;
comment|/* Eval the inputs and put them into ARGVEC.      Put their constraints into ASM_INPUTs and store in CONSTRAINTS.  */
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|inputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|allows_reg
init|=
literal|0
decl_stmt|,
name|allows_mem
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|constraint
decl_stmt|,
modifier|*
name|orig_constraint
decl_stmt|;
name|int
name|c_len
decl_stmt|;
name|rtx
name|op
decl_stmt|;
comment|/* If there's an erroneous arg, emit no insn, 	 because the ASM_INPUT would get VOIDmode 	 and that could cause a crash in reload.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* ??? Can this happen, and does the error message make any sense? */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"hard register `%s' listed as input operand to `asm'"
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|c_len
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
name|constraint
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
name|orig_constraint
operator|=
name|constraint
expr_stmt|;
comment|/* Make sure constraint has neither `=', `+', nor '&'.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|c_len
condition|;
name|j
operator|++
control|)
switch|switch
condition|(
name|constraint
index|[
name|j
index|]
condition|)
block|{
case|case
literal|'+'
case|:
case|case
literal|'='
case|:
case|case
literal|'&'
case|:
if|if
condition|(
name|constraint
operator|==
name|orig_constraint
condition|)
block|{
name|error
argument_list|(
literal|"input operand constraint contains `%c'"
argument_list|,
name|constraint
index|[
name|j
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|'%'
case|:
if|if
condition|(
name|constraint
operator|==
name|orig_constraint
operator|&&
name|i
operator|+
literal|1
operator|==
name|ninputs
operator|-
name|ninout
condition|)
block|{
name|error
argument_list|(
literal|"`%%' constraint used with last operand"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|'V'
case|:
case|case
literal|'m'
case|:
case|case
literal|'o'
case|:
name|allows_mem
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'?'
case|:
case|case
literal|'!'
case|:
case|case
literal|'*'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'X'
case|:
case|case
literal|'s'
case|:
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|','
case|:
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
endif|#
directive|endif
break|break;
comment|/* Whether or not a numeric constraint allows a register is 	       decided by the matching constraint, and so there is no need 	       to do anything special with them.  We must handle them in 	       the default case, so that we don't unnecessarily force 	       operands to memory.  */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|constraint
index|[
name|j
index|]
operator|>=
literal|'0'
operator|+
name|noutputs
condition|)
block|{
name|error
argument_list|(
literal|"matching constraint references invalid operand number"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Try and find the real constraint for this dup.  */
if|if
condition|(
operator|(
name|j
operator|==
literal|0
operator|&&
name|c_len
operator|==
literal|1
operator|)
operator|||
operator|(
name|j
operator|==
literal|1
operator|&&
name|c_len
operator|==
literal|2
operator|&&
name|constraint
index|[
literal|0
index|]
operator|==
literal|'%'
operator|)
condition|)
block|{
name|tree
name|o
init|=
name|outputs
decl_stmt|;
for|for
control|(
name|j
operator|=
name|constraint
index|[
name|j
index|]
operator|-
literal|'0'
init|;
name|j
operator|>
literal|0
condition|;
operator|--
name|j
control|)
name|o
operator|=
name|TREE_CHAIN
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|c_len
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|o
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
name|constraint
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* ... fall through ... */
case|case
literal|'p'
case|:
case|case
literal|'r'
case|:
default|default:
name|allows_reg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|allows_reg
operator|=
literal|1
expr_stmt|;
name|allows_mem
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|allows_reg
operator|&&
name|allows_mem
condition|)
name|mark_addressable
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|asm_operand_ok
argument_list|(
name|op
argument_list|,
name|constraint
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|allows_reg
condition|)
name|op
operator|=
name|force_reg
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|allows_mem
condition|)
name|warning
argument_list|(
literal|"asm operand %d probably doesn't match constraints"
argument_list|,
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
name|op
operator|=
name|force_const_mem
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|memloc
init|=
name|assign_temp
argument_list|(
name|type
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|memloc
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|op
operator|=
name|memloc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|op
argument_list|)
condition|)
comment|/* We won't recognize volatile memory as available a 	       memory_operand at this point.  Ignore it.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|queued_subexp_p
argument_list|(
name|op
argument_list|)
condition|)
empty_stmt|;
else|else
comment|/* ??? Leave this only until we have experience with what 	       happens in combine and elsewhere when constraints are 	       not satisfied.  */
name|warning
argument_list|(
literal|"asm operand %d probably doesn't match constraints"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
operator|=
name|op
expr_stmt|;
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|4
argument_list|,
name|i
argument_list|)
comment|/* constraints */
operator|=
name|gen_rtx_ASM_INPUT
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|orig_constraint
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
comment|/* Protect all the operands from the queue,      now that they have all been evaluated.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninputs
operator|-
name|ninout
condition|;
name|i
operator|++
control|)
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
operator|=
name|protect_from_queue
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noutputs
condition|;
name|i
operator|++
control|)
name|output_rtx
index|[
name|i
index|]
operator|=
name|protect_from_queue
argument_list|(
name|output_rtx
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* For in-out operands, copy output rtx to input rtx. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninout
condition|;
name|i
operator|++
control|)
block|{
specifier|static
name|char
name|match
index|[
literal|9
operator|+
literal|1
index|]
index|[
literal|2
index|]
init|=
block|{
literal|"0"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"8"
block|,
literal|"9"
block|}
decl_stmt|;
name|int
name|j
init|=
name|inout_opnum
index|[
name|i
index|]
decl_stmt|;
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|3
argument_list|,
name|ninputs
operator|-
name|ninout
operator|+
name|i
argument_list|)
comment|/* argvec */
operator|=
name|output_rtx
index|[
name|j
index|]
expr_stmt|;
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|4
argument_list|,
name|ninputs
operator|-
name|ninout
operator|+
name|i
argument_list|)
comment|/* constraints */
operator|=
name|gen_rtx_ASM_INPUT
argument_list|(
name|inout_mode
index|[
name|j
index|]
argument_list|,
name|match
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Now, for each output, construct an rtx      (set OUTPUT (asm_operands INSN OUTPUTNUMBER OUTPUTCONSTRAINT 			       ARGVEC CONSTRAINTS))      If there is more than one, put them inside a PARALLEL.  */
if|if
condition|(
name|noutputs
operator|==
literal|1
operator|&&
name|nclobbers
operator|==
literal|0
condition|)
block|{
name|XSTR
argument_list|(
name|body
argument_list|,
literal|1
argument_list|)
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|outputs
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|output_rtx
index|[
literal|0
index|]
argument_list|,
name|body
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|noutputs
operator|==
literal|0
operator|&&
name|nclobbers
operator|==
literal|0
condition|)
block|{
comment|/* No output operands: put in a raw ASM_OPERANDS rtx.  */
name|insn
operator|=
name|emit_insn
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|obody
init|=
name|body
decl_stmt|;
name|int
name|num
init|=
name|noutputs
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
name|num
operator|=
literal|1
expr_stmt|;
name|body
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|num
operator|+
name|nclobbers
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For each output operand, store a SET.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|output_rtx
index|[
name|i
index|]
argument_list|,
name|gen_rtx_ASM_OPERANDS
argument_list|(
name|VOIDmode
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|string
argument_list|)
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|,
name|i
argument_list|,
name|argvec
argument_list|,
name|constraints
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
operator|=
name|vol
expr_stmt|;
block|}
comment|/* If there are no outputs (but there are some clobbers) 	 store the bare ASM_OPERANDS into the PARALLEL.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
operator|++
argument_list|)
operator|=
name|obody
expr_stmt|;
comment|/* Store (clobber REG) for each clobbered register specified.  */
for|for
control|(
name|tail
operator|=
name|clobbers
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|char
modifier|*
name|regname
init|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|j
init|=
name|decode_reg_name
argument_list|(
name|regname
argument_list|)
decl_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|j
operator|==
operator|-
literal|3
condition|)
comment|/* `cc', which is not a register */
continue|continue;
if|if
condition|(
name|j
operator|==
operator|-
literal|4
condition|)
comment|/* `memory', don't cache memory across asm */
block|{
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
operator|++
argument_list|)
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|VOIDmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Ignore unknown register, error already signaled.  */
continue|continue;
block|}
comment|/* Use QImode since that's guaranteed to clobber just one reg.  */
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
operator|++
argument_list|)
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|QImode
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_insn
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
comment|/* For any outputs that needed reloading into registers, spill them      back to where they belong.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noutputs
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|real_output_rtx
index|[
name|i
index|]
condition|)
name|emit_move_insn
argument_list|(
name|real_output_rtx
index|[
name|i
index|]
argument_list|,
name|output_rtx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL to evaluate the expression EXP    and remember it in case this is the VALUE in a ({... VALUE; }) constr.  */
end_comment

begin_function
name|void
name|expand_expr_stmt
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
comment|/* If -W, warn about statements with no side effects,      except for an explicit cast to void (e.g. for assert()), and      except inside a ({...}) where they may be useful.  */
if|if
condition|(
name|expr_stmts_for_value
operator|==
literal|0
operator|&&
name|exp
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|exp
argument_list|)
operator|&&
operator|(
name|extra_warnings
operator|||
name|warn_unused
operator|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONVERT_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|==
name|void_type_node
operator|)
condition|)
name|warning_with_file_and_line
argument_list|(
name|emit_filename
argument_list|,
name|emit_lineno
argument_list|,
literal|"statement with no effect"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_unused
condition|)
name|warn_if_unused_value
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
comment|/* If EXP is of function type and we are expanding statements for      value, convert it to pointer-to-function.  */
if|if
condition|(
name|expr_stmts_for_value
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|exp
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|last_expr_value
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
operator|(
name|expr_stmts_for_value
condition|?
name|NULL_RTX
else|:
name|const0_rtx
operator|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If all we do is reference a volatile value in memory,      copy it to a register to be sure it is actually touched.  */
if|if
condition|(
name|last_expr_value
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|last_expr_value
argument_list|)
operator|==
name|MEM
operator|&&
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|VOIDmode
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|BLKmode
condition|)
name|copy_to_reg
argument_list|(
name|last_expr_value
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|lab
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
comment|/* Compare the value with itself to reference it.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|last_expr_value
argument_list|,
name|last_expr_value
argument_list|,
name|EQ
argument_list|,
name|expand_expr
argument_list|(
name|TYPE_SIZE
argument_list|(
name|last_expr_type
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|BLKmode
argument_list|,
literal|0
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|last_expr_type
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|lab
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this expression is part of a ({...}) and is in memory, we may have      to preserve temporaries.  */
name|preserve_temp_slots
argument_list|(
name|last_expr_value
argument_list|)
expr_stmt|;
comment|/* Free any temporaries used to evaluate this expression.  Any temporary      used as a result of this expression will already have been preserved      above.  */
name|free_temp_slots
argument_list|()
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Warn if EXP contains any computations whose results are not used.    Return 1 if a warning is printed; 0 otherwise.  */
end_comment

begin_function
name|int
name|warn_if_unused_value
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|TREE_USED
argument_list|(
name|exp
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
case|case
name|INIT_EXPR
case|:
case|case
name|TARGET_EXPR
case|:
case|case
name|CALL_EXPR
case|:
case|case
name|METHOD_CALL_EXPR
case|:
case|case
name|RTL_EXPR
case|:
case|case
name|TRY_CATCH_EXPR
case|:
case|case
name|WITH_CLEANUP_EXPR
case|:
case|case
name|EXIT_EXPR
case|:
comment|/* We don't warn about COND_EXPR because it may be a useful 	 construct if either arm contains a side effect.  */
case|case
name|COND_EXPR
case|:
return|return
literal|0
return|;
case|case
name|BIND_EXPR
case|:
comment|/* For a binding, warn if no side effect within it.  */
return|return
name|warn_if_unused_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|SAVE_EXPR
case|:
return|return
name|warn_if_unused_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
comment|/* In&& or ||, warn if 2nd operand has no side effect.  */
return|return
name|warn_if_unused_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|COMPOUND_EXPR
case|:
if|if
condition|(
name|TREE_NO_UNUSED_WARNING
argument_list|(
name|exp
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|warn_if_unused_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Let people do `(foo (), 0)' without a warning.  */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|warn_if_unused_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
comment|/* Don't warn about values cast to void.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|==
name|void_type_node
condition|)
return|return
literal|0
return|;
comment|/* Don't warn about conversions not explicit in the user's program.  */
if|if
condition|(
name|TREE_NO_UNUSED_WARNING
argument_list|(
name|exp
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Assignment to a cast usually results in a cast of a modify. 	 Don't complain about that.  There can be an arbitrary number of 	 casts before the modify, so we must loop until we find the first 	 non-cast expression and then test to see if that is a modify.  */
block|{
name|tree
name|tem
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|MODIFY_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|INIT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CALL_EXPR
condition|)
return|return
literal|0
return|;
block|}
goto|goto
name|warn
goto|;
case|case
name|INDIRECT_REF
case|:
comment|/* Don't warn about automatic dereferencing of references, since 	 the user cannot control it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
return|return
name|warn_if_unused_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* ... fall through ...  */
default|default:
comment|/* Referencing a volatile value is a side effect, so don't warn.  */
if|if
condition|(
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|'d'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|'r'
operator|)
operator|&&
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
condition|)
return|return
literal|0
return|;
name|warn
label|:
name|warning_with_file_and_line
argument_list|(
name|emit_filename
argument_list|,
name|emit_lineno
argument_list|,
literal|"value computed is not used"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Clear out the memory of the last expression evaluated.  */
end_comment

begin_function
name|void
name|clear_last_expr
parameter_list|()
block|{
name|last_expr_type
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a statement which will return a value.    Return the RTL_EXPR for this statement expr.    The caller must save that value and pass it to expand_end_stmt_expr.  */
end_comment

begin_function
name|tree
name|expand_start_stmt_expr
parameter_list|()
block|{
name|int
name|momentary
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* Make the RTL_EXPR node temporary, not momentary,      so that rtl_expr_chain doesn't become garbage.  */
name|momentary
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
expr_stmt|;
name|resume_momentary
argument_list|(
name|momentary
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|start_sequence_for_rtl_expr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
name|expr_stmts_for_value
operator|++
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Restore the previous state at the end of a statement that returns a value.    Returns a tree node representing the statement's value and the    insns to compute the value.     The nodes of that expression have been freed by now, so we cannot use them.    But we don't want to do that anyway; the expression has already been    evaluated and now we just want to use the value.  So generate a RTL_EXPR    with the proper type and RTL value.     If the last substatement was not an expression,    return something with type `void'.  */
end_comment

begin_function
name|tree
name|expand_end_stmt_expr
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|OK_DEFER_POP
expr_stmt|;
if|if
condition|(
name|last_expr_type
operator|==
literal|0
condition|)
block|{
name|last_expr_type
operator|=
name|void_type_node
expr_stmt|;
name|last_expr_value
operator|=
name|const0_rtx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last_expr_value
operator|==
literal|0
condition|)
comment|/* There are some cases where this can happen, such as when the        statement is void type.  */
name|last_expr_value
operator|=
name|const0_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|last_expr_value
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|last_expr_value
argument_list|)
condition|)
comment|/* Remove any possible QUEUED.  */
name|last_expr_value
operator|=
name|protect_from_queue
argument_list|(
name|last_expr_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|last_expr_type
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|t
argument_list|)
operator|=
name|last_expr_value
expr_stmt|;
name|RTL_EXPR_SEQUENCE
argument_list|(
name|t
argument_list|)
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|rtl_expr_chain
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|rtl_expr_chain
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Don't consider deleting this expr or containing exprs at tree level.  */
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Propagate volatility of the actual RTL expr.  */
name|TREE_THIS_VOLATILE
argument_list|(
name|t
argument_list|)
operator|=
name|volatile_refs_p
argument_list|(
name|last_expr_value
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
name|expr_stmts_for_value
operator|--
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL for the start of an if-then.  COND is the expression    whose truth should be tested.     If EXITFLAG is nonzero, this conditional is visible to    `exit_something'.  */
end_comment

begin_function
name|void
name|expand_start_cond
parameter_list|(
name|cond
parameter_list|,
name|exitflag
parameter_list|)
name|tree
name|cond
decl_stmt|;
name|int
name|exitflag
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thiscond
init|=
name|ALLOC_NESTING
argument_list|()
decl_stmt|;
comment|/* Make an entry on cond_stack for the cond we are entering.  */
name|thiscond
operator|->
name|next
operator|=
name|cond_stack
expr_stmt|;
name|thiscond
operator|->
name|all
operator|=
name|nesting_stack
expr_stmt|;
name|thiscond
operator|->
name|depth
operator|=
operator|++
name|nesting_depth
expr_stmt|;
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* Before we encounter an `else', we don't need a separate exit label      unless there are supposed to be exit statements      to exit this conditional.  */
name|thiscond
operator|->
name|exit_label
operator|=
name|exitflag
condition|?
name|gen_label_rtx
argument_list|()
else|:
literal|0
expr_stmt|;
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
operator|=
name|thiscond
operator|->
name|exit_label
expr_stmt|;
name|cond_stack
operator|=
name|thiscond
expr_stmt|;
name|nesting_stack
operator|=
name|thiscond
expr_stmt|;
name|do_jump
argument_list|(
name|cond
argument_list|,
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL between then-clause and the elseif-clause    of an if-then-elseif-....  */
end_comment

begin_function
name|void
name|expand_start_elseif
parameter_list|(
name|cond
parameter_list|)
name|tree
name|cond
decl_stmt|;
block|{
if|if
condition|(
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
operator|==
literal|0
condition|)
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_jump
argument_list|(
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
argument_list|)
expr_stmt|;
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|cond
argument_list|,
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL between the then-clause and the else-clause    of an if-then-else.  */
end_comment

begin_function
name|void
name|expand_start_else
parameter_list|()
block|{
if|if
condition|(
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
operator|==
literal|0
condition|)
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_jump
argument_list|(
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
argument_list|)
expr_stmt|;
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
operator|=
literal|0
expr_stmt|;
comment|/* No more _else or _elseif calls.  */
block|}
end_function

begin_comment
comment|/* After calling expand_start_else, turn this "else" into an "else if"    by providing another condition.  */
end_comment

begin_function
name|void
name|expand_elseif
parameter_list|(
name|cond
parameter_list|)
name|tree
name|cond
decl_stmt|;
block|{
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|cond
argument_list|,
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL for the end of an if-then.    Pop the record for it off of cond_stack.  */
end_comment

begin_function
name|void
name|expand_end_cond
parameter_list|()
block|{
name|struct
name|nesting
modifier|*
name|thiscond
init|=
name|cond_stack
decl_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
if|if
condition|(
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
condition|)
name|emit_label
argument_list|(
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
condition|)
name|emit_label
argument_list|(
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
argument_list|)
expr_stmt|;
name|POPSTACK
argument_list|(
name|cond_stack
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL for the start of a loop.  EXIT_FLAG is nonzero if this    loop should be exited by `exit_something'.  This is a loop for which    `expand_continue' will jump to the top of the loop.     Make an entry on loop_stack to record the labels associated with    this loop.  */
end_comment

begin_function
name|struct
name|nesting
modifier|*
name|expand_start_loop
parameter_list|(
name|exit_flag
parameter_list|)
name|int
name|exit_flag
decl_stmt|;
block|{
specifier|register
name|struct
name|nesting
modifier|*
name|thisloop
init|=
name|ALLOC_NESTING
argument_list|()
decl_stmt|;
comment|/* Make an entry on loop_stack for the loop we are entering.  */
name|thisloop
operator|->
name|next
operator|=
name|loop_stack
expr_stmt|;
name|thisloop
operator|->
name|all
operator|=
name|nesting_stack
expr_stmt|;
name|thisloop
operator|->
name|depth
operator|=
operator|++
name|nesting_depth
expr_stmt|;
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|alt_end_label
operator|=
literal|0
expr_stmt|;
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|continue_label
operator|=
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
expr_stmt|;
name|thisloop
operator|->
name|exit_label
operator|=
name|exit_flag
condition|?
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
else|:
literal|0
expr_stmt|;
name|loop_stack
operator|=
name|thisloop
expr_stmt|;
name|nesting_stack
operator|=
name|thisloop
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_LOOP_BEG
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
argument_list|)
expr_stmt|;
return|return
name|thisloop
return|;
block|}
end_function

begin_comment
comment|/* Like expand_start_loop but for a loop where the continuation point    (for expand_continue_loop) will be specified explicitly.  */
end_comment

begin_function
name|struct
name|nesting
modifier|*
name|expand_start_loop_continue_elsewhere
parameter_list|(
name|exit_flag
parameter_list|)
name|int
name|exit_flag
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thisloop
init|=
name|expand_start_loop
argument_list|(
name|exit_flag
argument_list|)
decl_stmt|;
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|continue_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
return|return
name|thisloop
return|;
block|}
end_function

begin_comment
comment|/* Specify the continuation point for a loop started with    expand_start_loop_continue_elsewhere.    Use this at the point in the code to which a continue statement    should jump.  */
end_comment

begin_function
name|void
name|expand_loop_continue_here
parameter_list|()
block|{
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_LOOP_CONT
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|continue_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a loop.  Generate a jump back to the top and the loop-exit label.    Pop the block off of loop_stack.  */
end_comment

begin_function
name|void
name|expand_end_loop
parameter_list|()
block|{
name|rtx
name|start_label
init|=
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
decl_stmt|;
name|rtx
name|insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|int
name|needs_end_jump
init|=
literal|1
decl_stmt|;
comment|/* Mark the continue-point at the top of the loop if none elsewhere.  */
if|if
condition|(
name|start_label
operator|==
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|continue_label
condition|)
name|emit_note_before
argument_list|(
name|NOTE_INSN_LOOP_CONT
argument_list|,
name|start_label
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* If optimizing, perhaps reorder the loop.      First, try to use a condjump near the end.      expand_exit_loop_if_false ends loops with unconditional jumps,      like this:       if (test) goto label;      optional: cleanup      goto loop_stack->data.loop.end_label      barrier      label:       If we find such a pattern, we can end the loop earlier.  */
if|if
condition|(
name|optimize
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|LABEL_NAME
argument_list|(
name|insn
argument_list|)
operator|==
name|NULL
operator|&&
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|rtx
name|label
init|=
name|insn
decl_stmt|;
name|rtx
name|jump
init|=
name|PREV_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|label
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|jump
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
operator|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
operator|)
condition|)
block|{
name|rtx
name|prev
decl_stmt|;
comment|/* The test might be complex and reference LABEL multiple times, 	     like the loop in loop_iterations to set vtop.  To handle this, 	     we move LABEL.  */
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|reorder_insns
argument_list|(
name|label
argument_list|,
name|label
argument_list|,
name|start_label
argument_list|)
expr_stmt|;
for|for
control|(
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|jump
argument_list|)
init|;
condition|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
control|)
block|{
comment|/* We ignore line number notes, but if we see any other note, 		 in particular NOTE_INSN_BLOCK_*, NOTE_INSN_EH_REGION_*, 		 NOTE_INSN_LOOP_*, we disable this optimization.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|prev
argument_list|)
operator|<
literal|0
condition|)
break|break;
continue|continue;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|label
condition|)
block|{
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|start_label
expr_stmt|;
name|emit_note_after
argument_list|(
name|NOTE_INSN_LOOP_END
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|needs_end_jump
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
comment|/* If the loop starts with a loop exit, roll that to the end where      it will optimize together with the jump back.       We look for the conditional branch to the exit, except that once      we find such a branch, we don't look past 30 instructions.       In more detail, if the loop presently looks like this (in pseudo-C):           start_label:          if (test) goto end_label; 	 body; 	 goto start_label; 	 end_label: 	       transform it to look like:           goto start_label;          newstart_label: 	 body; 	 start_label: 	 if (test) goto end_label; 	 goto newstart_label; 	 end_label:       Here, the `test' may actually consist of some reasonably complex      code, terminating in a test.  */
if|if
condition|(
name|optimize
operator|&&
name|needs_end_jump
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|)
condition|)
block|{
name|int
name|eh_regions
init|=
literal|0
decl_stmt|;
name|int
name|num_insns
init|=
literal|0
decl_stmt|;
name|rtx
name|last_test_insn
init|=
name|NULL_RTX
decl_stmt|;
comment|/* Scan insns from the top of the loop looking for a qualified 	 conditional exit.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|optimize
operator|<
literal|2
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_END
operator|)
condition|)
comment|/* The code that actually moves the exit test will 		   carefully leave BLOCK notes in their original 		   location.  That means, however, that we can't debug 		   the exit test itself.  So, we refuse to move code 		   containing BLOCK notes at low optimization levels.  */
break|break;
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_BEG
condition|)
operator|++
name|eh_regions
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_END
condition|)
block|{
operator|--
name|eh_regions
expr_stmt|;
if|if
condition|(
name|eh_regions
operator|<
literal|0
condition|)
comment|/* We've come to the end of an EH region, but 		       never saw the beginning of that region.  That 		       means that an EH region begins before the top 		       of the loop, and ends in the middle of it.  The 		       existence of such a situation violates a basic 		       assumption in this code, since that would imply 		       that even when EH_REGIONS is zero, we might 		       move code out of an exception region.  */
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* We must not walk into a nested loop.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
break|break;
comment|/* We already know this INSN is a NOTE, so there's no 		 point in looking at it to see if it's a JUMP.  */
continue|continue;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
condition|)
name|num_insns
operator|++
expr_stmt|;
if|if
condition|(
name|last_test_insn
operator|&&
name|num_insns
operator|>
literal|30
condition|)
break|break;
if|if
condition|(
name|eh_regions
operator|>
literal|0
condition|)
comment|/* We don't want to move a partial EH region.  Consider:  		  while ( ( { try { 				if (cond ()) 0;	 				else { 				  bar(); 				  1; 				} 			      } catch (...) {  				1; 			      } )) { 		     body; 		  }   	        This isn't legal C++, but here's what it's supposed to 	        mean: if cond() is true, stop looping.  Otherwise, 	        call bar, and keep looping.  In addition, if cond 	        throws an exception, catch it and keep looping. Such 	        constructs are certainy legal in LISP.    		We should not move the `if (cond()) 0' test since then 		the EH-region for the try-block would be broken up. 		(In this case we would the EH_BEG note for the `try' 		and `if cond()' but not the call to bar() or the 		EH_END note.)    	        So we don't look for tests within an EH region.  */
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|pc_rtx
condition|)
block|{
comment|/* This is indeed a jump.  */
name|rtx
name|dest1
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|dest2
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|potential_last_test
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
block|{
comment|/* A conditional jump.  */
name|dest1
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dest2
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|potential_last_test
operator|=
name|insn
expr_stmt|;
block|}
else|else
block|{
comment|/* An unconditional jump.  */
name|dest1
operator|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Include the BARRIER after the JUMP.  */
name|potential_last_test
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
do|do
block|{
if|if
condition|(
name|dest1
operator|&&
name|GET_CODE
argument_list|(
name|dest1
argument_list|)
operator|==
name|LABEL_REF
operator|&&
operator|(
operator|(
name|XEXP
argument_list|(
name|dest1
argument_list|,
literal|0
argument_list|)
operator|==
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|alt_end_label
operator|)
operator|||
operator|(
name|XEXP
argument_list|(
name|dest1
argument_list|,
literal|0
argument_list|)
operator|==
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
operator|)
operator|)
condition|)
block|{
name|last_test_insn
operator|=
name|potential_last_test
expr_stmt|;
break|break;
block|}
comment|/* If this was a conditional jump, there may be 		   another label at which we should look.  */
name|dest1
operator|=
name|dest2
expr_stmt|;
name|dest2
operator|=
name|NULL_RTX
expr_stmt|;
block|}
do|while
condition|(
name|dest1
condition|)
do|;
block|}
block|}
if|if
condition|(
name|last_test_insn
operator|!=
literal|0
operator|&&
name|last_test_insn
operator|!=
name|get_last_insn
argument_list|()
condition|)
block|{
comment|/* We found one.  Move everything from there up 	     to the end of the loop, and add a jump into the loop 	     to jump to there.  */
specifier|register
name|rtx
name|newstart_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
specifier|register
name|rtx
name|start_move
init|=
name|start_label
decl_stmt|;
name|rtx
name|next_insn
decl_stmt|;
comment|/* If the start label is preceded by a NOTE_INSN_LOOP_CONT note, 	     then we want to move this note also.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|start_move
argument_list|)
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|PREV_INSN
argument_list|(
name|start_move
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_LOOP_CONT
operator|)
condition|)
name|start_move
operator|=
name|PREV_INSN
argument_list|(
name|start_move
argument_list|)
expr_stmt|;
name|emit_label_after
argument_list|(
name|newstart_label
argument_list|,
name|PREV_INSN
argument_list|(
name|start_move
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Actually move the insns.  Start at the beginning, and 	     keep copying insns until we've copied the 	     last_test_insn.  */
for|for
control|(
name|insn
operator|=
name|start_move
init|;
name|insn
condition|;
name|insn
operator|=
name|next_insn
control|)
block|{
comment|/* Figure out which insn comes after this one.  We have 		 to do this before we move INSN.  */
if|if
condition|(
name|insn
operator|==
name|last_test_insn
condition|)
comment|/* We've moved all the insns.  */
name|next_insn
operator|=
name|NULL_RTX
expr_stmt|;
else|else
name|next_insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_END
operator|)
condition|)
comment|/* We don't want to move NOTE_INSN_BLOCK_BEGs or 		   NOTE_INSN_BLOCK_ENDs because the correct generation 		   of debugging information depends on these appearing 		   in the same order in the RTL and in the tree 		   structure, where they are represented as BLOCKs. 		   So, we don't move block notes.  Of course, moving 		   the code inside the block is likely to make it 		   impossible to debug the instructions in the exit 		   test, but such is the price of optimization.  */
continue|continue;
comment|/* Move the INSN.  */
name|reorder_insns
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|,
name|get_last_insn
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|emit_jump_insn_after
argument_list|(
name|gen_jump
argument_list|(
name|start_label
argument_list|)
argument_list|,
name|PREV_INSN
argument_list|(
name|newstart_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier_after
argument_list|(
name|PREV_INSN
argument_list|(
name|newstart_label
argument_list|)
argument_list|)
expr_stmt|;
name|start_label
operator|=
name|newstart_label
expr_stmt|;
block|}
block|}
if|if
condition|(
name|needs_end_jump
condition|)
block|{
name|emit_jump
argument_list|(
name|start_label
argument_list|)
expr_stmt|;
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_LOOP_END
argument_list|)
expr_stmt|;
block|}
name|emit_label
argument_list|(
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
argument_list|)
expr_stmt|;
name|POPSTACK
argument_list|(
name|loop_stack
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a jump to the current loop's continue-point.    This is usually the top of the loop, but may be specified    explicitly elsewhere.  If not currently inside a loop,    return 0 and do nothing; caller will print an error message.  */
end_comment

begin_function
name|int
name|expand_continue_loop
parameter_list|(
name|whichloop
parameter_list|)
name|struct
name|nesting
modifier|*
name|whichloop
decl_stmt|;
block|{
name|last_expr_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|whichloop
operator|==
literal|0
condition|)
name|whichloop
operator|=
name|loop_stack
expr_stmt|;
if|if
condition|(
name|whichloop
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|expand_goto_internal
argument_list|(
name|NULL_TREE
argument_list|,
name|whichloop
operator|->
name|data
operator|.
name|loop
operator|.
name|continue_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Generate a jump to exit the current loop.  If not currently inside a loop,    return 0 and do nothing; caller will print an error message.  */
end_comment

begin_function
name|int
name|expand_exit_loop
parameter_list|(
name|whichloop
parameter_list|)
name|struct
name|nesting
modifier|*
name|whichloop
decl_stmt|;
block|{
name|last_expr_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|whichloop
operator|==
literal|0
condition|)
name|whichloop
operator|=
name|loop_stack
expr_stmt|;
if|if
condition|(
name|whichloop
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|expand_goto_internal
argument_list|(
name|NULL_TREE
argument_list|,
name|whichloop
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Generate a conditional jump to exit the current loop if COND    evaluates to zero.  If not currently inside a loop,    return 0 and do nothing; caller will print an error message.  */
end_comment

begin_function
name|int
name|expand_exit_loop_if_false
parameter_list|(
name|whichloop
parameter_list|,
name|cond
parameter_list|)
name|struct
name|nesting
modifier|*
name|whichloop
decl_stmt|;
name|tree
name|cond
decl_stmt|;
block|{
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|last_insn
decl_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|whichloop
operator|==
literal|0
condition|)
name|whichloop
operator|=
name|loop_stack
expr_stmt|;
if|if
condition|(
name|whichloop
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* In order to handle fixups, we actually create a conditional jump      around a unconditional branch to exit the loop.  If fixups are      necessary, they go before the unconditional branch.  */
name|do_jump
argument_list|(
name|cond
argument_list|,
name|NULL_RTX
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|last_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|last_insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|whichloop
operator|->
name|data
operator|.
name|loop
operator|.
name|alt_end_label
operator|=
name|last_insn
expr_stmt|;
name|expand_goto_internal
argument_list|(
name|NULL_TREE
argument_list|,
name|whichloop
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the loop nest is empty.  Else return zero.  */
end_comment

begin_function
name|int
name|stmt_loop_nest_empty
parameter_list|()
block|{
return|return
operator|(
name|loop_stack
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if we should preserve sub-expressions as separate    pseudos.  We never do so if we aren't optimizing.  We always do so    if -fexpensive-optimizations.     Otherwise, we only do so if we are in the "early" part of a loop.  I.e.,    the loop may still be a small one.  */
end_comment

begin_function
name|int
name|preserve_subexpressions_p
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|flag_expensive_optimizations
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|optimize
operator|==
literal|0
operator|||
name|loop_stack
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|insn
operator|=
name|get_last_insn_anywhere
argument_list|()
expr_stmt|;
return|return
operator|(
name|insn
operator|&&
operator|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|-
name|INSN_UID
argument_list|(
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
argument_list|)
operator|<
name|n_non_fixed_regs
operator|*
literal|3
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Generate a jump to exit the current loop, conditional, binding contour    or case statement.  Not all such constructs are visible to this function,    only those started with EXIT_FLAG nonzero.  Individual languages use    the EXIT_FLAG parameter to control which kinds of constructs you can    exit this way.     If not currently inside anything that can be exited,    return 0 and do nothing; caller will print an error message.  */
end_comment

begin_function
name|int
name|expand_exit_something
parameter_list|()
block|{
name|struct
name|nesting
modifier|*
name|n
decl_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|nesting_stack
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|all
control|)
if|if
condition|(
name|n
operator|->
name|exit_label
operator|!=
literal|0
condition|)
block|{
name|expand_goto_internal
argument_list|(
name|NULL_TREE
argument_list|,
name|n
operator|->
name|exit_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL to return from the current function, with no value.    (That is, we do not do anything about returning any value.)  */
end_comment

begin_function
name|void
name|expand_null_return
parameter_list|()
block|{
name|struct
name|nesting
modifier|*
name|block
init|=
name|block_stack
decl_stmt|;
name|rtx
name|last_insn
init|=
literal|0
decl_stmt|;
comment|/* Does any pending block have cleanups?  */
while|while
condition|(
name|block
operator|&&
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|==
literal|0
condition|)
name|block
operator|=
name|block
operator|->
name|next
expr_stmt|;
comment|/* If yes, use a goto to return, since that runs cleanups.  */
name|expand_null_return_1
argument_list|(
name|last_insn
argument_list|,
name|block
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL to return from the current function, with value VAL.  */
end_comment

begin_function
specifier|static
name|void
name|expand_value_return
parameter_list|(
name|val
parameter_list|)
name|rtx
name|val
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|block
init|=
name|block_stack
decl_stmt|;
name|rtx
name|last_insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|return_reg
init|=
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Copy the value to the return location      unless it's already there.  */
if|if
condition|(
name|return_reg
operator|!=
name|val
condition|)
block|{
ifdef|#
directive|ifdef
name|PROMOTE_FUNCTION_RETURN
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|old_mode
init|=
name|DECL_MODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|promote_mode
argument_list|(
name|type
argument_list|,
name|old_mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|old_mode
condition|)
name|val
operator|=
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|old_mode
argument_list|,
name|val
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_move_insn
argument_list|(
name|return_reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|return_reg
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|return_reg
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|return_reg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle calls that return values in multiple non-contiguous locations.      The Irix 6 ABI has examples of this.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|return_reg
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|return_reg
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|return_reg
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Does any pending block have cleanups?  */
while|while
condition|(
name|block
operator|&&
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|==
literal|0
condition|)
name|block
operator|=
name|block
operator|->
name|next
expr_stmt|;
comment|/* If yes, use a goto to return, since that runs cleanups.      Use LAST_INSN to put cleanups *before* the move insn emitted above.  */
name|expand_null_return_1
argument_list|(
name|last_insn
argument_list|,
name|block
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a return with no value.  If LAST_INSN is nonzero,    pretend that the return takes place after LAST_INSN.    If USE_GOTO is nonzero then don't use a return instruction;    go to the return label instead.  This causes any cleanups    of pending blocks to be executed normally.  */
end_comment

begin_function
specifier|static
name|void
name|expand_null_return_1
parameter_list|(
name|last_insn
parameter_list|,
name|use_goto
parameter_list|)
name|rtx
name|last_insn
decl_stmt|;
name|int
name|use_goto
decl_stmt|;
block|{
name|rtx
name|end_label
init|=
name|cleanup_label
condition|?
name|cleanup_label
else|:
name|return_label
decl_stmt|;
name|clear_pending_stack_adjust
argument_list|()
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
comment|/* PCC-struct return always uses an epilogue.  */
if|if
condition|(
name|current_function_returns_pcc_struct
operator|||
name|use_goto
condition|)
block|{
if|if
condition|(
name|end_label
operator|==
literal|0
condition|)
name|end_label
operator|=
name|return_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|expand_goto_internal
argument_list|(
name|NULL_TREE
argument_list|,
name|end_label
argument_list|,
name|last_insn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Otherwise output a simple return-insn if one is available,      unless it won't do the job.  */
ifdef|#
directive|ifdef
name|HAVE_return
if|if
condition|(
name|HAVE_return
operator|&&
name|use_goto
operator|==
literal|0
operator|&&
name|cleanup_label
operator|==
literal|0
condition|)
block|{
name|emit_jump_insn
argument_list|(
name|gen_return
argument_list|()
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Otherwise jump to the epilogue.  */
name|expand_goto_internal
argument_list|(
name|NULL_TREE
argument_list|,
name|end_label
argument_list|,
name|last_insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL to evaluate the expression RETVAL and return it    from the current function.  */
end_comment

begin_function
name|void
name|expand_return
parameter_list|(
name|retval
parameter_list|)
name|tree
name|retval
decl_stmt|;
block|{
comment|/* If there are any cleanups to be performed, then they will      be inserted following LAST_INSN.  It is desirable      that the last_insn, for such purposes, should be the      last insn before computing the return value.  Otherwise, cleanups      which call functions can clobber the return value.  */
comment|/* ??? rms: I think that is erroneous, because in C++ it would      run destructors on variables that might be used in the subsequent      computation of the return value.  */
name|rtx
name|last_insn
init|=
literal|0
decl_stmt|;
specifier|register
name|rtx
name|val
init|=
literal|0
decl_stmt|;
specifier|register
name|rtx
name|op0
decl_stmt|;
name|tree
name|retval_rhs
decl_stmt|;
name|int
name|cleanups
decl_stmt|;
comment|/* If function wants no value, give it none.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|expand_expr
argument_list|(
name|retval
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|expand_null_return
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Are any cleanups needed?  E.g. C++ destructors to be run?  */
comment|/* This is not sufficient.  We also need to watch for cleanups of the      expression we are about to expand.  Unfortunately, we cannot know      if it has cleanups until we expand it, and we want to change how we      expand it depending upon if we need cleanups.  We can't win.  */
if|#
directive|if
literal|0
block|cleanups = any_pending_cleanups (1);
else|#
directive|else
name|cleanups
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|==
name|RESULT_DECL
condition|)
name|retval_rhs
operator|=
name|retval
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|==
name|MODIFY_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|==
name|INIT_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|retval
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|RESULT_DECL
condition|)
name|retval_rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|retval
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|retval
argument_list|)
operator|==
name|void_type_node
condition|)
comment|/* Recognize tail-recursive call to void function.  */
name|retval_rhs
operator|=
name|retval
expr_stmt|;
else|else
name|retval_rhs
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Only use `last_insn' if there are cleanups which must be run.  */
if|if
condition|(
name|cleanups
operator|||
name|cleanup_label
operator|!=
literal|0
condition|)
name|last_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Distribute return down conditional expr if either of the sides      may involve tail recursion (see test below).  This enhances the number      of tail recursions we see.  Don't do this always since it can produce      sub-optimal code in some cases and we distribute assignments into      conditional expressions when it would help.  */
if|if
condition|(
name|optimize
operator|&&
name|retval_rhs
operator|!=
literal|0
operator|&&
name|frame_offset
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|retval_rhs
argument_list|)
operator|==
name|COND_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|retval_rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CALL_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|retval_rhs
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CALL_EXPR
operator|)
condition|)
block|{
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|retval_rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
name|expr
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|,
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|retval_rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_return
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|,
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|retval_rhs
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_return
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|end_cleanup_deferral
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Attempt to optimize the call if it is tail recursive.  */
if|if
condition|(
name|optimize_tail_recursion
argument_list|(
name|retval_rhs
argument_list|,
name|last_insn
argument_list|)
condition|)
return|return;
ifdef|#
directive|ifdef
name|HAVE_return
comment|/* This optimization is safe if there are local cleanups      because expand_null_return takes care of them.      ??? I think it should also be safe when there is a cleanup label,      because expand_null_return takes care of them, too.      Any reason why not?  */
if|if
condition|(
name|HAVE_return
operator|&&
name|cleanup_label
operator|==
literal|0
operator|&&
operator|!
name|current_function_returns_pcc_struct
operator|&&
name|BRANCH_COST
operator|<=
literal|1
condition|)
block|{
comment|/* If this is  return x == y;  then generate 	 if (x == y) return 1; else return 0; 	 if we can do it with explicit return insns and branches are cheap, 	 but not if we have the corresponding scc insn.  */
name|int
name|has_scc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|retval_rhs
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|retval_rhs
argument_list|)
condition|)
block|{
case|case
name|EQ_EXPR
case|:
ifdef|#
directive|ifdef
name|HAVE_seq
name|has_scc
operator|=
name|HAVE_seq
expr_stmt|;
endif|#
directive|endif
case|case
name|NE_EXPR
case|:
ifdef|#
directive|ifdef
name|HAVE_sne
name|has_scc
operator|=
name|HAVE_sne
expr_stmt|;
endif|#
directive|endif
case|case
name|GT_EXPR
case|:
ifdef|#
directive|ifdef
name|HAVE_sgt
name|has_scc
operator|=
name|HAVE_sgt
expr_stmt|;
endif|#
directive|endif
case|case
name|GE_EXPR
case|:
ifdef|#
directive|ifdef
name|HAVE_sge
name|has_scc
operator|=
name|HAVE_sge
expr_stmt|;
endif|#
directive|endif
case|case
name|LT_EXPR
case|:
ifdef|#
directive|ifdef
name|HAVE_slt
name|has_scc
operator|=
name|HAVE_slt
expr_stmt|;
endif|#
directive|endif
case|case
name|LE_EXPR
case|:
ifdef|#
directive|ifdef
name|HAVE_sle
name|has_scc
operator|=
name|HAVE_sle
expr_stmt|;
endif|#
directive|endif
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
if|if
condition|(
operator|!
name|has_scc
condition|)
block|{
name|op0
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|jumpifnot
argument_list|(
name|retval_rhs
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|expand_value_return
argument_list|(
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|expand_value_return
argument_list|(
name|const0_rtx
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
default|default:
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_return */
comment|/* If the result is an aggregate that is being returned in one (or more)      registers, load the registers here.  The compiler currently can't handle      copying a BLKmode value into registers.  We could put this code in a      more general area (for use by everyone instead of just function      call/return), but until this feature is generally usable it is kept here      (and in expand_call).  The value must go into a pseudo in case there      are cleanups that will clobber the real return register.  */
if|if
condition|(
name|retval_rhs
operator|!=
literal|0
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval_rhs
argument_list|)
argument_list|)
operator|==
name|BLKmode
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|i
decl_stmt|,
name|bitpos
decl_stmt|,
name|xbitpos
decl_stmt|;
name|int
name|big_endian_correction
init|=
literal|0
decl_stmt|;
name|int
name|bytes
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval_rhs
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|n_regs
init|=
operator|(
name|bytes
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
name|int
name|bitsize
init|=
name|MIN
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval_rhs
argument_list|)
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|BITS_PER_WORD
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|result_pseudos
init|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
operator|*
name|n_regs
argument_list|)
decl_stmt|;
name|rtx
name|result_reg
decl_stmt|,
name|src
init|=
name|NULL_RTX
decl_stmt|,
name|dst
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|result_val
init|=
name|expand_expr
argument_list|(
name|retval_rhs
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmpmode
decl_stmt|,
name|result_reg_mode
decl_stmt|;
comment|/* Structures whose size is not a multiple of a word are aligned 	 to the least significant byte (to the right).  On a BYTES_BIG_ENDIAN 	 machine, this means we must skip the empty high order bytes when 	 calculating the bit offset.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|bytes
operator|%
name|UNITS_PER_WORD
condition|)
name|big_endian_correction
operator|=
operator|(
name|BITS_PER_WORD
operator|-
operator|(
operator|(
name|bytes
operator|%
name|UNITS_PER_WORD
operator|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
comment|/* Copy the structure BITSIZE bits at a time.  */
for|for
control|(
name|bitpos
operator|=
literal|0
operator|,
name|xbitpos
operator|=
name|big_endian_correction
init|;
name|bitpos
operator|<
name|bytes
operator|*
name|BITS_PER_UNIT
condition|;
name|bitpos
operator|+=
name|bitsize
operator|,
name|xbitpos
operator|+=
name|bitsize
control|)
block|{
comment|/* We need a new destination pseudo each time xbitpos is 	     on a word boundary and when xbitpos == big_endian_correction 	     (the first time through).  */
if|if
condition|(
name|xbitpos
operator|%
name|BITS_PER_WORD
operator|==
literal|0
operator|||
name|xbitpos
operator|==
name|big_endian_correction
condition|)
block|{
comment|/* Generate an appropriate register.  */
name|dst
operator|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
expr_stmt|;
name|result_pseudos
index|[
name|xbitpos
operator|/
name|BITS_PER_WORD
index|]
operator|=
name|dst
expr_stmt|;
comment|/* Clobber the destination before we move anything into it.  */
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We need a new source operand each time bitpos is on a word 	     boundary.  */
if|if
condition|(
name|bitpos
operator|%
name|BITS_PER_WORD
operator|==
literal|0
condition|)
name|src
operator|=
name|operand_subword_force
argument_list|(
name|result_val
argument_list|,
name|bitpos
operator|/
name|BITS_PER_WORD
argument_list|,
name|BLKmode
argument_list|)
expr_stmt|;
comment|/* Use bitpos for the source extraction (left justified) and 	     xbitpos for the destination store (right justified).  */
name|store_bit_field
argument_list|(
name|dst
argument_list|,
name|bitsize
argument_list|,
name|xbitpos
operator|%
name|BITS_PER_WORD
argument_list|,
name|word_mode
argument_list|,
name|extract_bit_field
argument_list|(
name|src
argument_list|,
name|bitsize
argument_list|,
name|bitpos
operator|%
name|BITS_PER_WORD
argument_list|,
literal|1
argument_list|,
name|NULL_RTX
argument_list|,
name|word_mode
argument_list|,
name|word_mode
argument_list|,
name|bitsize
operator|/
name|BITS_PER_UNIT
argument_list|,
name|BITS_PER_WORD
argument_list|)
argument_list|,
name|bitsize
operator|/
name|BITS_PER_UNIT
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
comment|/* Find the smallest integer mode large enough to hold the 	 entire structure and use that mode instead of BLKmode 	 on the USE insn for the return register.   */
name|bytes
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval_rhs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|tmpmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|tmpmode
operator|!=
name|MAX_MACHINE_MODE
condition|;
name|tmpmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmpmode
argument_list|)
control|)
block|{
comment|/* Have we found a large enough mode?  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmpmode
argument_list|)
operator|>=
name|bytes
condition|)
break|break;
block|}
comment|/* No suitable mode found.  */
if|if
condition|(
name|tmpmode
operator|==
name|MAX_MACHINE_MODE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|PUT_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|,
name|tmpmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmpmode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|word_mode
argument_list|)
condition|)
name|result_reg_mode
operator|=
name|word_mode
expr_stmt|;
else|else
name|result_reg_mode
operator|=
name|tmpmode
expr_stmt|;
name|result_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|result_reg_mode
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_regs
condition|;
name|i
operator|++
control|)
name|emit_move_insn
argument_list|(
name|operand_subword
argument_list|(
name|result_reg
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|result_reg_mode
argument_list|)
argument_list|,
name|result_pseudos
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpmode
operator|!=
name|result_reg_mode
condition|)
name|result_reg
operator|=
name|gen_lowpart
argument_list|(
name|tmpmode
argument_list|,
name|result_reg
argument_list|)
expr_stmt|;
name|expand_value_return
argument_list|(
name|result_reg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cleanups
operator|&&
name|retval_rhs
operator|!=
literal|0
operator|&&
name|TREE_TYPE
argument_list|(
name|retval_rhs
argument_list|)
operator|!=
name|void_type_node
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* Calculate the return value into a pseudo reg.  */
name|val
operator|=
name|gen_reg_rtx
argument_list|(
name|DECL_MODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|expand_expr
argument_list|(
name|retval_rhs
argument_list|,
name|val
argument_list|,
name|GET_MODE
argument_list|(
name|val
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
name|force_not_mem
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* Return the calculated value, doing cleanups first.  */
name|expand_value_return
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No cleanups or no hard reg used; 	 calculate value into hard return reg.  */
name|expand_expr
argument_list|(
name|retval
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|expand_value_return
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if the end of the generated RTX is not a barrier.    This means code already compiled can drop through.  */
end_comment

begin_function
name|int
name|drop_through_at_end_p
parameter_list|()
block|{
name|rtx
name|insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
while|while
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Test CALL_EXPR to determine if it is a potential tail recursion call    and emit code to optimize the tail recursion.  LAST_INSN indicates where    to place the jump to the tail recursion label.  Return TRUE if the    call was optimized into a goto.     This is only used by expand_return, but expand_call is expected to    use it soon.  */
end_comment

begin_function
name|int
name|optimize_tail_recursion
parameter_list|(
name|call_expr
parameter_list|,
name|last_insn
parameter_list|)
name|tree
name|call_expr
decl_stmt|;
name|rtx
name|last_insn
decl_stmt|;
block|{
comment|/* For tail-recursive call to current function,      just jump back to the beginning.      It's unsafe if any auto variable in this function      has its address taken; for simplicity,      require stack frame to be empty.  */
if|if
condition|(
name|optimize
operator|&&
name|call_expr
operator|!=
literal|0
operator|&&
name|frame_offset
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|call_expr
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|call_expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|call_expr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|current_function_decl
comment|/* Finish checking validity, and if valid emit code 	 to set the argument variables for the new call.  */
operator|&&
name|tail_recursion_args
argument_list|(
name|TREE_OPERAND
argument_list|(
name|call_expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|tail_recursion_label
operator|==
literal|0
condition|)
block|{
name|tail_recursion_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label_after
argument_list|(
name|tail_recursion_label
argument_list|,
name|tail_recursion_reentry
argument_list|)
expr_stmt|;
block|}
name|emit_queue
argument_list|()
expr_stmt|;
name|expand_goto_internal
argument_list|(
name|NULL_TREE
argument_list|,
name|tail_recursion_label
argument_list|,
name|last_insn
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Emit code to alter this function's formal parms for a tail-recursive call.    ACTUALS is a list of actual parameter expressions (chain of TREE_LISTs).    FORMALS is the chain of decls of formals.    Return 1 if this can be done;    otherwise return 0 and do not emit any code.  */
end_comment

begin_function
specifier|static
name|int
name|tail_recursion_args
parameter_list|(
name|actuals
parameter_list|,
name|formals
parameter_list|)
name|tree
name|actuals
decl_stmt|,
name|formals
decl_stmt|;
block|{
specifier|register
name|tree
name|a
init|=
name|actuals
decl_stmt|,
name|f
init|=
name|formals
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|rtx
modifier|*
name|argvec
decl_stmt|;
comment|/* Check that number and types of actuals are compatible      with the formals.  This is not always true in valid C code.      Also check that no formal needs to be addressable      and that all formals are scalars.  */
comment|/* Also count the args.  */
for|for
control|(
name|a
operator|=
name|actuals
operator|,
name|f
operator|=
name|formals
operator|,
name|i
operator|=
literal|0
init|;
name|a
operator|&&
name|f
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
operator|,
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|f
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|f
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|DECL_MODE
argument_list|(
name|f
argument_list|)
operator|==
name|BLKmode
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|a
operator|!=
literal|0
operator|||
name|f
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Compute all the actuals.  */
name|argvec
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|actuals
operator|,
name|i
operator|=
literal|0
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
operator|,
name|i
operator|++
control|)
name|argvec
index|[
name|i
index|]
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Find which actual values refer to current values of previous formals.      Copy each of them now, before any formal is changed.  */
for|for
control|(
name|a
operator|=
name|actuals
operator|,
name|i
operator|=
literal|0
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|int
name|copy
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|f
operator|=
name|formals
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
operator|,
name|j
operator|++
control|)
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|DECL_RTL
argument_list|(
name|f
argument_list|)
argument_list|,
name|argvec
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|copy
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|copy
condition|)
name|argvec
index|[
name|i
index|]
operator|=
name|copy_to_reg
argument_list|(
name|argvec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Store the values of the actuals into the formals.  */
for|for
control|(
name|f
operator|=
name|formals
operator|,
name|a
operator|=
name|actuals
operator|,
name|i
operator|=
literal|0
init|;
name|f
condition|;
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
operator|,
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|f
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|argvec
index|[
name|i
index|]
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|DECL_RTL
argument_list|(
name|f
argument_list|)
argument_list|,
name|argvec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|convert_move
argument_list|(
name|DECL_RTL
argument_list|(
name|f
argument_list|)
argument_list|,
name|argvec
index|[
name|i
index|]
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free_temp_slots
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate the RTL code for entering a binding contour.    The variables are declared one by one, by calls to `expand_decl'.     EXIT_FLAG is nonzero if this construct should be visible to    `exit_something'.  */
end_comment

begin_function
name|void
name|expand_start_bindings
parameter_list|(
name|exit_flag
parameter_list|)
name|int
name|exit_flag
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thisblock
init|=
name|ALLOC_NESTING
argument_list|()
decl_stmt|;
name|rtx
name|note
init|=
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_BLOCK_BEG
argument_list|)
decl_stmt|;
comment|/* Make an entry on block_stack for the block we are entering.  */
name|thisblock
operator|->
name|next
operator|=
name|block_stack
expr_stmt|;
name|thisblock
operator|->
name|all
operator|=
name|nesting_stack
expr_stmt|;
name|thisblock
operator|->
name|depth
operator|=
operator|++
name|nesting_depth
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|=
literal|0
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|=
literal|0
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|function_call_count
operator|=
literal|0
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|exception_region
operator|=
literal|0
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|target_temp_slot_level
operator|=
name|target_temp_slot_level
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|conditional_code
operator|=
literal|0
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|last_unconditional_cleanup
operator|=
name|note
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanup_ptr
operator|=
operator|&
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
expr_stmt|;
if|if
condition|(
name|block_stack
operator|&&
operator|!
operator|(
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|==
name|NULL_TREE
operator|&&
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
operator|==
name|NULL_TREE
operator|)
condition|)
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|,
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
argument_list|)
expr_stmt|;
else|else
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
operator|=
literal|0
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|label_chain
operator|=
literal|0
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|innermost_stack_block
operator|=
name|stack_block_stack
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
operator|=
name|note
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|block_start_count
operator|=
operator|++
name|block_start_count
expr_stmt|;
name|thisblock
operator|->
name|exit_label
operator|=
name|exit_flag
condition|?
name|gen_label_rtx
argument_list|()
else|:
literal|0
expr_stmt|;
name|block_stack
operator|=
name|thisblock
expr_stmt|;
name|nesting_stack
operator|=
name|thisblock
expr_stmt|;
comment|/* Make a new level for allocating stack slots.  */
name|push_temp_slots
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Specify the scope of temporaries created by TARGET_EXPRs.  Similar    to CLEANUP_POINT_EXPR, but handles cases when a series of calls to    expand_expr are made.  After we end the region, we know that all    space for all temporaries that were created by TARGET_EXPRs will be    destroyed and their space freed for reuse.  */
end_comment

begin_function
name|void
name|expand_start_target_temps
parameter_list|()
block|{
comment|/* This is so that even if the result is preserved, the space      allocated will be freed, as we know that it is no longer in use.  */
name|push_temp_slots
argument_list|()
expr_stmt|;
comment|/* Start a new binding layer that will keep track of all cleanup      actions to be performed.  */
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|target_temp_slot_level
operator|=
name|temp_slot_level
expr_stmt|;
block|}
end_function

begin_function
name|void
name|expand_end_target_temps
parameter_list|()
block|{
name|expand_end_bindings
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This is so that even if the result is preserved, the space      allocated will be freed, as we know that it is no longer in use.  */
name|pop_temp_slots
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark top block of block_stack as an implicit binding for an    exception region.  This is used to prevent infinite recursion when    ending a binding with expand_end_bindings.  It is only ever called    by expand_eh_region_start, as that it the only way to create a    block stack for a exception region.  */
end_comment

begin_function
name|void
name|mark_block_as_eh_region
parameter_list|()
block|{
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|exception_region
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|block_stack
operator|->
name|next
operator|&&
name|block_stack
operator|->
name|next
operator|->
name|data
operator|.
name|block
operator|.
name|conditional_code
condition|)
block|{
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|conditional_code
operator|=
name|block_stack
operator|->
name|next
operator|->
name|data
operator|.
name|block
operator|.
name|conditional_code
expr_stmt|;
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|last_unconditional_cleanup
operator|=
name|block_stack
operator|->
name|next
operator|->
name|data
operator|.
name|block
operator|.
name|last_unconditional_cleanup
expr_stmt|;
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|cleanup_ptr
operator|=
name|block_stack
operator|->
name|next
operator|->
name|data
operator|.
name|block
operator|.
name|cleanup_ptr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* True if we are currently emitting insns in an area of output code    that is controlled by a conditional expression.  This is used by    the cleanup handling code to generate conditional cleanup actions.  */
end_comment

begin_function
name|int
name|conditional_context
parameter_list|()
block|{
return|return
name|block_stack
operator|&&
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|conditional_code
return|;
block|}
end_function

begin_comment
comment|/* Mark top block of block_stack as not for an implicit binding for an    exception region.  This is only ever done by expand_eh_region_end    to let expand_end_bindings know that it is being called explicitly    to end the binding layer for just the binding layer associated with    the exception region, otherwise expand_end_bindings would try and    end all implicit binding layers for exceptions regions, and then    one normal binding layer.  */
end_comment

begin_function
name|void
name|mark_block_as_not_eh_region
parameter_list|()
block|{
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|exception_region
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* True if the top block of block_stack was marked as for an exception    region by mark_block_as_eh_region.  */
end_comment

begin_function
name|int
name|is_eh_region
parameter_list|()
block|{
return|return
name|block_stack
operator|&&
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|exception_region
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a BLOCK node, save a pointer to the most recently    generated NOTE_INSN_BLOCK_END in the BLOCK_END_NOTE field of the given    BLOCK node.  */
end_comment

begin_function
name|void
name|remember_end_note
parameter_list|(
name|block
parameter_list|)
specifier|register
name|tree
name|block
decl_stmt|;
block|{
name|BLOCK_END_NOTE
argument_list|(
name|block
argument_list|)
operator|=
name|last_block_end_note
expr_stmt|;
name|last_block_end_note
operator|=
name|NULL_RTX
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit a handler label for a nonlocal goto handler.    Also emit code to store the handler label in SLOT before BEFORE_INSN.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_nl_handler_label
parameter_list|(
name|slot
parameter_list|,
name|before_insn
parameter_list|)
name|rtx
name|slot
decl_stmt|,
name|before_insn
decl_stmt|;
block|{
name|rtx
name|insns
decl_stmt|;
name|rtx
name|handler_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
comment|/* Don't let jump_optimize delete the handler.  */
name|LABEL_PRESERVE_P
argument_list|(
name|handler_label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|slot
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|handler_label
argument_list|)
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_before
argument_list|(
name|insns
argument_list|,
name|before_insn
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|handler_label
argument_list|)
expr_stmt|;
return|return
name|handler_label
return|;
block|}
end_function

begin_comment
comment|/* Emit code to restore vital registers at the beginning of a nonlocal goto    handler.  */
end_comment

begin_function
specifier|static
name|void
name|expand_nl_goto_receiver
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|HAVE_nonlocal_goto
if|if
condition|(
operator|!
name|HAVE_nonlocal_goto
condition|)
endif|#
directive|endif
comment|/* First adjust our frame pointer to its actual value.  It was        previously set to the start of the virtual area corresponding to        the stacked variables when we branched here and now needs to be        adjusted to the actual hardware fp value.         Assignments are to virtual registers are converted by        instantiate_virtual_regs into the corresponding assignment        to the underlying register (fp in this case) that makes        the original assignment true.        So the following insn will actually be        decrementing fp by STARTING_FRAME_OFFSET.  */
name|emit_move_insn
argument_list|(
name|virtual_stack_vars_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
if|if
condition|(
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
comment|/* If the argument pointer can be eliminated in favor of the 	 frame pointer, we don't need to restore it.  We assume here 	 that if such an elimination is present, it can always be used. 	 This is the case on all known machines; if we don't make this 	 assumption, we do unnecessary saving on many machines.  */
specifier|static
struct|struct
name|elims
block|{
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|}
name|elim_regs
index|[]
init|=
name|ELIMINABLE_REGS
struct|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|elim_regs
operator|/
sizeof|sizeof
name|elim_regs
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|elim_regs
index|[
name|i
index|]
operator|.
name|from
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|elim_regs
index|[
name|i
index|]
operator|.
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
break|break;
if|if
condition|(
name|i
operator|==
sizeof|sizeof
name|elim_regs
operator|/
sizeof|sizeof
name|elim_regs
index|[
literal|0
index|]
condition|)
endif|#
directive|endif
block|{
comment|/* Now restore our arg pointer from the address at which it 	     was saved in our stack frame. 	     If there hasn't be space allocated for it yet, make 	     some now.  */
if|if
condition|(
name|arg_pointer_save_area
operator|==
literal|0
condition|)
name|arg_pointer_save_area
operator|=
name|assign_stack_local
argument_list|(
name|Pmode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
comment|/* We need a pseudo here, or else 			     instantiate_virtual_regs_1 complains.  */
name|copy_to_reg
argument_list|(
name|arg_pointer_save_area
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_nonlocal_goto_receiver
if|if
condition|(
name|HAVE_nonlocal_goto_receiver
condition|)
name|emit_insn
argument_list|(
name|gen_nonlocal_goto_receiver
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Make handlers for nonlocal gotos taking place in the function calls in    block THISBLOCK.  */
end_comment

begin_function
specifier|static
name|void
name|expand_nl_goto_receivers
parameter_list|(
name|thisblock
parameter_list|)
name|struct
name|nesting
modifier|*
name|thisblock
decl_stmt|;
block|{
name|tree
name|link
decl_stmt|;
name|rtx
name|afterward
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|insns
decl_stmt|,
name|slot
decl_stmt|;
name|rtx
name|label_list
decl_stmt|;
name|int
name|any_invalid
decl_stmt|;
comment|/* Record the handler address in the stack slot for that purpose,      during this block, saving and restoring the outer value.  */
if|if
condition|(
name|thisblock
operator|->
name|next
operator|!=
literal|0
condition|)
for|for
control|(
name|slot
operator|=
name|nonlocal_goto_handler_slots
init|;
name|slot
condition|;
name|slot
operator|=
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|save_receiver
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
argument_list|,
name|save_receiver
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|save_receiver
argument_list|,
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_before
argument_list|(
name|insns
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
argument_list|)
expr_stmt|;
block|}
comment|/* Jump around the handlers; they run only when specially invoked.  */
name|emit_jump
argument_list|(
name|afterward
argument_list|)
expr_stmt|;
comment|/* Make a separate handler for each label.  */
name|link
operator|=
name|nonlocal_labels
expr_stmt|;
name|slot
operator|=
name|nonlocal_goto_handler_slots
expr_stmt|;
name|label_list
operator|=
name|NULL_RTX
expr_stmt|;
for|for
control|(
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
operator|,
name|slot
operator|=
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|1
argument_list|)
control|)
comment|/* Skip any labels we shouldn't be able to jump to from here,        we generate one special handler for all of them below which just calls        abort.  */
if|if
condition|(
operator|!
name|DECL_TOO_LATE
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|lab
decl_stmt|;
name|lab
operator|=
name|expand_nl_handler_label
argument_list|(
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
argument_list|)
expr_stmt|;
name|label_list
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|lab
argument_list|,
name|label_list
argument_list|)
expr_stmt|;
name|expand_nl_goto_receiver
argument_list|()
expr_stmt|;
comment|/* Jump to the "real" nonlocal label.  */
name|expand_goto
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* A second pass over all nonlocal labels; this time we handle those      we should not be able to jump to at this point.  */
name|link
operator|=
name|nonlocal_labels
expr_stmt|;
name|slot
operator|=
name|nonlocal_goto_handler_slots
expr_stmt|;
name|any_invalid
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
operator|,
name|slot
operator|=
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|DECL_TOO_LATE
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|lab
decl_stmt|;
name|lab
operator|=
name|expand_nl_handler_label
argument_list|(
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
argument_list|)
expr_stmt|;
name|label_list
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|lab
argument_list|,
name|label_list
argument_list|)
expr_stmt|;
name|any_invalid
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|any_invalid
condition|)
block|{
name|expand_nl_goto_receiver
argument_list|()
expr_stmt|;
name|emit_library_call
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"abort"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
name|nonlocal_goto_handler_labels
operator|=
name|label_list
expr_stmt|;
name|emit_label
argument_list|(
name|afterward
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL code to terminate a binding contour.     VARS is the chain of VAR_DECL nodes for the variables bound in this    contour.  There may actually be other nodes in this chain, but any    nodes other than VAR_DECLS are ignored.     MARK_ENDS is nonzero if we should put a note at the beginning    and end of this binding contour.     DONT_JUMP_IN is nonzero if it is not valid to jump into this contour.    (That is true automatically if the contour has a saved stack level.)  */
end_comment

begin_function
name|void
name|expand_end_bindings
parameter_list|(
name|vars
parameter_list|,
name|mark_ends
parameter_list|,
name|dont_jump_in
parameter_list|)
name|tree
name|vars
decl_stmt|;
name|int
name|mark_ends
decl_stmt|;
name|int
name|dont_jump_in
decl_stmt|;
block|{
specifier|register
name|struct
name|nesting
modifier|*
name|thisblock
decl_stmt|;
specifier|register
name|tree
name|decl
decl_stmt|;
while|while
condition|(
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|exception_region
condition|)
block|{
comment|/* Because we don't need or want a new temporary level and 	 because we didn't create one in expand_eh_region_start, 	 create a fake one now to avoid removing one in 	 expand_end_bindings.  */
name|push_temp_slots
argument_list|()
expr_stmt|;
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|exception_region
operator|=
literal|0
expr_stmt|;
name|expand_end_bindings
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Since expand_eh_region_start does an expand_start_bindings, we      have to first end all the bindings that were created by      expand_eh_region_start.  */
name|thisblock
operator|=
name|block_stack
expr_stmt|;
if|if
condition|(
name|warn_unused
condition|)
for|for
control|(
name|decl
operator|=
name|vars
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"unused variable `%s'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisblock
operator|->
name|exit_label
condition|)
block|{
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|thisblock
operator|->
name|exit_label
argument_list|)
expr_stmt|;
block|}
comment|/* If necessary, make handlers for nonlocal gotos taking      place in the function calls in this block.  */
if|if
condition|(
name|function_call_count
operator|!=
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|function_call_count
operator|&&
name|nonlocal_labels
comment|/* Make handler for outermost block 	 if there were any nonlocal gotos to this function.  */
operator|&&
operator|(
name|thisblock
operator|->
name|next
operator|==
literal|0
condition|?
name|current_function_has_nonlocal_label
comment|/* Make handler for inner block if it has something 	     special to do when you jump out of it.  */
else|:
operator|(
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|!=
literal|0
operator|||
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|!=
literal|0
operator|)
operator|)
condition|)
name|expand_nl_goto_receivers
argument_list|(
name|thisblock
argument_list|)
expr_stmt|;
comment|/* Don't allow jumping into a block that has a stack level.      Cleanups are allowed, though.  */
if|if
condition|(
name|dont_jump_in
operator|||
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|!=
literal|0
condition|)
block|{
name|struct
name|label_chain
modifier|*
name|chain
decl_stmt|;
comment|/* Any labels in this block are no longer valid to go to. 	 Mark them to cause an error message.  */
for|for
control|(
name|chain
operator|=
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|label_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|chain
operator|->
name|next
control|)
block|{
name|DECL_TOO_LATE
argument_list|(
name|chain
operator|->
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If any goto without a fixup came to this label, 	     that must be an error, because gotos without fixups 	     come from outside all saved stack-levels.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|chain
operator|->
name|label
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|chain
operator|->
name|label
argument_list|,
literal|"label `%s' used before containing binding contour"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Restore stack level in effect before the block      (only if variable-size objects allocated).  */
comment|/* Perform any cleanups associated with the block.  */
if|if
condition|(
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|!=
literal|0
operator|||
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|!=
literal|0
condition|)
block|{
comment|/* Only clean up here if this point can actually be reached.  */
name|int
name|reachable
init|=
name|GET_CODE
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
operator|!=
name|BARRIER
decl_stmt|;
comment|/* Don't let cleanups affect ({...}) constructs.  */
name|int
name|old_expr_stmts_for_value
init|=
name|expr_stmts_for_value
decl_stmt|;
name|rtx
name|old_last_expr_value
init|=
name|last_expr_value
decl_stmt|;
name|tree
name|old_last_expr_type
init|=
name|last_expr_type
decl_stmt|;
name|expr_stmts_for_value
operator|=
literal|0
expr_stmt|;
comment|/* Do the cleanups.  */
name|expand_cleanups
argument_list|(
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
name|reachable
argument_list|)
expr_stmt|;
if|if
condition|(
name|reachable
condition|)
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|expr_stmts_for_value
operator|=
name|old_expr_stmts_for_value
expr_stmt|;
name|last_expr_value
operator|=
name|old_last_expr_value
expr_stmt|;
name|last_expr_type
operator|=
name|old_last_expr_type
expr_stmt|;
comment|/* Restore the stack level.  */
if|if
condition|(
name|reachable
operator|&&
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|!=
literal|0
condition|)
block|{
name|emit_stack_restore
argument_list|(
name|thisblock
operator|->
name|next
condition|?
name|SAVE_BLOCK
else|:
name|SAVE_FUNCTION
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonlocal_goto_handler_slots
operator|!=
literal|0
condition|)
name|emit_stack_save
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
operator|&
name|nonlocal_goto_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
comment|/* Any gotos out of this block must also do these things. 	 Also report any gotos with fixups that came to labels in this 	 level.  */
name|fixup_gotos
argument_list|(
name|thisblock
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
argument_list|,
name|dont_jump_in
argument_list|)
expr_stmt|;
block|}
comment|/* Mark the beginning and end of the scope if requested.      We do this now, after running cleanups on the variables      just going out of scope, so they are in scope for their cleanups.  */
if|if
condition|(
name|mark_ends
condition|)
name|last_block_end_note
operator|=
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_BLOCK_END
argument_list|)
expr_stmt|;
else|else
comment|/* Get rid of the beginning-mark if we don't make an end-mark.  */
name|NOTE_LINE_NUMBER
argument_list|(
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
comment|/* If doing stupid register allocation, make sure lives of all      register variables declared here extend thru end of scope.  */
if|if
condition|(
name|obey_regdecls
condition|)
for|for
control|(
name|decl
operator|=
name|vars
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
condition|)
name|use_variable
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore the temporary level of TARGET_EXPRs.  */
name|target_temp_slot_level
operator|=
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|target_temp_slot_level
expr_stmt|;
comment|/* Restore block_stack level for containing block.  */
name|stack_block_stack
operator|=
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|innermost_stack_block
expr_stmt|;
name|POPSTACK
argument_list|(
name|block_stack
argument_list|)
expr_stmt|;
comment|/* Pop the stack slot nesting and free any slots at this level.  */
name|pop_temp_slots
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL for the automatic variable declaration DECL.    (Other kinds of declarations are simply ignored if seen here.)  */
end_comment

begin_function
name|void
name|expand_decl
parameter_list|(
name|decl
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thisblock
init|=
name|block_stack
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Only automatic variables need any expansion done.      Static and external variables, and external functions,      will be handled by `assemble_variable' (called from finish_decl).      TYPE_DECL and CONST_DECL require nothing.      PARM_DECLs are handled in `assign_parms'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
condition|)
return|return;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Create the RTL representation for the variable.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
comment|/* Variable with incomplete type.  */
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
comment|/* Error message was already done; now avoid a crash.  */
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|assign_stack_temp
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
comment|/* An initializer is going to decide the size of this array. 	   Until we know the size, represent its address with a reg.  */
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|BLKmode
comment|/* If -ffloat-store, don't put explicit float vars 	      into regs.  */
operator|&&
operator|!
operator|(
name|flag_float_store
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|obey_regdecls
operator|)
comment|/* if -fcheck-memory-usage, check all variables.  */
operator|&&
operator|!
name|current_function_check_memory_usage
condition|)
block|{
comment|/* Automatic variable that can go in a register.  */
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|reg_mode
init|=
name|promote_mode
argument_list|(
name|type
argument_list|,
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_reg_rtx
argument_list|(
name|reg_mode
argument_list|)
expr_stmt|;
name|mark_user_reg
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|mark_reg_pointer
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
operator|(
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
operator|(
name|flag_stack_check
operator|&&
operator|!
name|STACK_CHECK_BUILTIN
operator|&&
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|>
name|STACK_CHECK_MAX_VAR_SIZE
operator|*
name|BITS_PER_UNIT
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Variable of fixed size that goes on the stack.  */
name|rtx
name|oldaddr
init|=
literal|0
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
comment|/* If we previously made RTL for this decl, it must be an array 	 whose size was determined by the initializer. 	 The old address was a register; set that register now 	 to the proper address.  */
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|oldaddr
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|assign_temp
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set alignment we actually gave this decl.  */
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|==
name|BLKmode
condition|?
name|BIGGEST_ALIGNMENT
else|:
name|GET_MODE_BITSIZE
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|oldaddr
condition|)
block|{
name|addr
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|oldaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
name|oldaddr
condition|)
name|emit_move_insn
argument_list|(
name|oldaddr
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a memory ref that contains aggregate components, 	 mark it as such for cse and loop optimize.  */
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* If this is in memory because of -ffloat-store, 	 set the volatile bit, to prevent optimizations from 	 undoing the effects.  */
block|if (flag_float_store&& TREE_CODE (type) == REAL_TYPE) 	MEM_VOLATILE_P (DECL_RTL (decl)) = 1;
endif|#
directive|endif
name|MEM_ALIAS_SET
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|get_alias_set
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Dynamic-size object: must push space on the stack.  */
block|{
name|rtx
name|address
decl_stmt|,
name|size
decl_stmt|;
comment|/* Record the stack pointer on entry to block, if have 	 not already done so.  */
if|if
condition|(
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|==
literal|0
condition|)
block|{
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_stack_save
argument_list|(
name|thisblock
operator|->
name|next
condition|?
name|SAVE_BLOCK
else|:
name|SAVE_FUNCTION
argument_list|,
operator|&
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
argument_list|)
expr_stmt|;
name|stack_block_stack
operator|=
name|thisblock
expr_stmt|;
block|}
comment|/* Compute the variable's size, in bytes.  */
name|size
operator|=
name|expand_expr
argument_list|(
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
comment|/* Allocate space on the stack for the variable.  Note that 	 DECL_ALIGN says how the variable is to be aligned and we  	 cannot use it to conclude anything about the alignment of 	 the size.  */
name|address
operator|=
name|allocate_dynamic_stack_space
argument_list|(
name|size
argument_list|,
name|NULL_RTX
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Reference the variable indirect through that rtx.  */
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_rtx_MEM
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|address
argument_list|)
expr_stmt|;
comment|/* If this is a memory ref that contains aggregate components, 	 mark it as such for cse and loop optimize.  */
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Indicate the alignment we actually gave this variable.  */
ifdef|#
directive|ifdef
name|STACK_BOUNDARY
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|STACK_BOUNDARY
expr_stmt|;
else|#
directive|else
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|BIGGEST_ALIGNMENT
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
condition|)
name|MEM_VOLATILE_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* A variable is not necessarily unchanging 	 just because it is const.  RTX_UNCHANGING_P 	 means no change in the function, 	 not merely no change in the variable's scope. 	 It is correct to set RTX_UNCHANGING_P if the variable's scope 	 is the whole function.  There's no convenient way to test that.  */
block|if (TREE_READONLY (decl))     RTX_UNCHANGING_P (DECL_RTL (decl)) = 1;
endif|#
directive|endif
comment|/* If doing stupid register allocation, make sure life of any      register variable starts here, at the start of its scope.  */
if|if
condition|(
name|obey_regdecls
condition|)
name|use_variable
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit code to perform the initialization of a declaration DECL.  */
end_comment

begin_function
name|void
name|expand_decl_init
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|int
name|was_used
init|=
name|TREE_USED
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* If this is a CONST_DECL, we don't have to generate any code, but      if DECL_INITIAL is a constant, call expand_expr to force TREE_CST_RTL      to be set while in the obstack containing the constant.  If we don't      do this, we can lose if we have functions nested three deep and the middle      function makes a CONST_DECL whose DECL_INITIAL is a STRING_CST while      the innermost function is the first to expand that STRING_CST.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|expand_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_INITIALIZER
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Compute and store the initial value now.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|INTEGER_TYPE
operator|||
name|code
operator|==
name|REAL_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
operator|||
name|code
operator|==
name|POINTER_TYPE
operator|||
name|code
operator|==
name|REFERENCE_TYPE
condition|)
name|expand_assignment
argument_list|(
name|decl
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
name|emit_line_note
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|expand_assignment
argument_list|(
name|decl
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
block|}
comment|/* Don't let the initialization count as "using" the variable.  */
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
name|was_used
expr_stmt|;
comment|/* Free any temporaries we made while initializing the decl.  */
name|preserve_temp_slots
argument_list|(
name|NULL_RTX
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* CLEANUP is an expression to be executed at exit from this binding contour;    for example, in C++, it might call the destructor for this variable.     We wrap CLEANUP in an UNSAVE_EXPR node, so that we can expand the    CLEANUP multiple times, and have the correct semantics.  This    happens in exception handling, for gotos, returns, breaks that    leave the current scope.     If CLEANUP is nonzero and DECL is zero, we record a cleanup    that is not associated with any particular variable.   */
end_comment

begin_function
name|int
name|expand_decl_cleanup
parameter_list|(
name|decl
parameter_list|,
name|cleanup
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|cleanup
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thisblock
init|=
name|block_stack
decl_stmt|;
comment|/* Error if we are not in any block.  */
if|if
condition|(
name|thisblock
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Record the cleanup if there is one.  */
if|if
condition|(
name|cleanup
operator|!=
literal|0
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|tree
modifier|*
name|cleanups
init|=
operator|&
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
decl_stmt|;
name|int
name|cond_context
init|=
name|conditional_context
argument_list|()
decl_stmt|;
if|if
condition|(
name|cond_context
condition|)
block|{
name|rtx
name|flag
init|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
decl_stmt|;
name|rtx
name|set_flag_0
decl_stmt|;
name|tree
name|cond
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|flag
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|set_flag_0
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|last_unconditional_cleanup
operator|=
name|emit_insns_after
argument_list|(
name|set_flag_0
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|last_unconditional_cleanup
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|flag
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
comment|/* All cleanups must be on the function_obstack.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
name|cond
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type_for_mode
argument_list|(
name|word_mode
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_RTL
argument_list|(
name|cond
argument_list|)
operator|=
name|flag
expr_stmt|;
comment|/* Conditionalize the cleanup.  */
name|cleanup
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|truthvalue_conversion
argument_list|(
name|cond
argument_list|)
argument_list|,
name|cleanup
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|cleanup
operator|=
name|fold
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
name|cleanups
operator|=
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanup_ptr
expr_stmt|;
block|}
comment|/* All cleanups must be on the function_obstack.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
name|cleanup
operator|=
name|unsave_expr
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
name|t
operator|=
operator|*
name|cleanups
operator|=
name|temp_tree_cons
argument_list|(
name|decl
argument_list|,
name|cleanup
argument_list|,
operator|*
name|cleanups
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond_context
condition|)
comment|/* If this block has a cleanup, it belongs in stack_block_stack.  */
name|stack_block_stack
operator|=
name|thisblock
expr_stmt|;
if|if
condition|(
name|cond_context
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
block|}
comment|/* If this was optimized so that there is no exception region for the 	 cleanup, then mark the TREE_LIST node, so that we can later tell 	 if we need to call expand_eh_region_end.  */
if|if
condition|(
operator|!
name|using_eh_for_cleanups_p
operator|||
name|expand_eh_region_start_tree
argument_list|(
name|decl
argument_list|,
name|cleanup
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If that started a new EH region, we're in a new block.  */
name|thisblock
operator|=
name|block_stack
expr_stmt|;
if|if
condition|(
name|cond_context
condition|)
block|{
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|seq
condition|)
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|last_unconditional_cleanup
operator|=
name|emit_insns_after
argument_list|(
name|seq
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|last_unconditional_cleanup
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|last_unconditional_cleanup
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanup_ptr
operator|=
operator|&
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Like expand_decl_cleanup, but suppress generating an exception handler    to perform the cleanup.  */
end_comment

begin_function
name|int
name|expand_decl_cleanup_no_eh
parameter_list|(
name|decl
parameter_list|,
name|cleanup
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|cleanup
decl_stmt|;
block|{
name|int
name|save_eh
init|=
name|using_eh_for_cleanups_p
decl_stmt|;
name|int
name|result
decl_stmt|;
name|using_eh_for_cleanups_p
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|expand_decl_cleanup
argument_list|(
name|decl
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|using_eh_for_cleanups_p
operator|=
name|save_eh
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Arrange for the top element of the dynamic cleanup chain to be    popped if we exit the current binding contour.  DECL is the    associated declaration, if any, otherwise NULL_TREE.  If the    current contour is left via an exception, then __sjthrow will pop    the top element off the dynamic cleanup chain.  The code that    avoids doing the action we push into the cleanup chain in the    exceptional case is contained in expand_cleanups.     This routine is only used by expand_eh_region_start, and that is    the only way in which an exception region should be started.  This    routine is only used when using the setjmp/longjmp codegen method    for exception handling.  */
end_comment

begin_function
name|int
name|expand_dcc_cleanup
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thisblock
init|=
name|block_stack
decl_stmt|;
name|tree
name|cleanup
decl_stmt|;
comment|/* Error if we are not in any block.  */
if|if
condition|(
name|thisblock
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Record the cleanup for the dynamic handler chain.  */
comment|/* All cleanups must be on the function_obstack.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
name|cleanup
operator|=
name|make_node
argument_list|(
name|POPDCC_EXPR
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
comment|/* Add the cleanup in a manner similar to expand_decl_cleanup.  */
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|=
name|temp_tree_cons
argument_list|(
name|decl
argument_list|,
name|cleanup
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|)
expr_stmt|;
comment|/* If this block has a cleanup, it belongs in stack_block_stack.  */
name|stack_block_stack
operator|=
name|thisblock
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Arrange for the top element of the dynamic handler chain to be    popped if we exit the current binding contour.  DECL is the    associated declaration, if any, otherwise NULL_TREE.  If the current    contour is left via an exception, then __sjthrow will pop the top    element off the dynamic handler chain.  The code that avoids doing    the action we push into the handler chain in the exceptional case    is contained in expand_cleanups.     This routine is only used by expand_eh_region_start, and that is    the only way in which an exception region should be started.  This    routine is only used when using the setjmp/longjmp codegen method    for exception handling.  */
end_comment

begin_function
name|int
name|expand_dhc_cleanup
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thisblock
init|=
name|block_stack
decl_stmt|;
name|tree
name|cleanup
decl_stmt|;
comment|/* Error if we are not in any block.  */
if|if
condition|(
name|thisblock
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Record the cleanup for the dynamic handler chain.  */
comment|/* All cleanups must be on the function_obstack.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
name|cleanup
operator|=
name|make_node
argument_list|(
name|POPDHC_EXPR
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
comment|/* Add the cleanup in a manner similar to expand_decl_cleanup.  */
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|=
name|temp_tree_cons
argument_list|(
name|decl
argument_list|,
name|cleanup
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|)
expr_stmt|;
comment|/* If this block has a cleanup, it belongs in stack_block_stack.  */
name|stack_block_stack
operator|=
name|thisblock
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* DECL is an anonymous union.  CLEANUP is a cleanup for DECL.    DECL_ELTS is the list of elements that belong to DECL's type.    In each, the TREE_VALUE is a VAR_DECL, and the TREE_PURPOSE a cleanup.  */
end_comment

begin_function
name|void
name|expand_anon_union_decl
parameter_list|(
name|decl
parameter_list|,
name|cleanup
parameter_list|,
name|decl_elts
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|cleanup
decl_stmt|,
name|decl_elts
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thisblock
init|=
name|block_stack
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|expand_decl_cleanup
argument_list|(
name|decl
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|x
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
while|while
condition|(
name|decl_elts
condition|)
block|{
name|tree
name|decl_elt
init|=
name|TREE_VALUE
argument_list|(
name|decl_elts
argument_list|)
decl_stmt|;
name|tree
name|cleanup_elt
init|=
name|TREE_PURPOSE
argument_list|(
name|decl_elts
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl_elt
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Propagate the union's alignment to the elements.  */
name|DECL_ALIGN
argument_list|(
name|decl_elt
argument_list|)
operator|=
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If the element has BLKmode and the union doesn't, the union is          aligned such that the element doesn't need to have BLKmode, so          change the element's mode to the appropriate one for its size.  */
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|&&
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|BLKmode
condition|)
name|DECL_MODE
argument_list|(
name|decl_elt
argument_list|)
operator|=
name|mode
operator|=
name|mode_for_size
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl_elt
argument_list|)
argument_list|)
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* (SUBREG (MEM ...)) at RTL generation time is invalid, so we          instead create a new MEM rtx with the proper mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
name|DECL_RTL
argument_list|(
name|decl_elt
argument_list|)
operator|=
name|x
expr_stmt|;
else|else
block|{
name|DECL_RTL
argument_list|(
name|decl_elt
argument_list|)
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_COPY_ATTRIBUTES
argument_list|(
name|DECL_RTL
argument_list|(
name|decl_elt
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl_elt
argument_list|)
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
name|DECL_RTL
argument_list|(
name|decl_elt
argument_list|)
operator|=
name|x
expr_stmt|;
else|else
name|DECL_RTL
argument_list|(
name|decl_elt
argument_list|)
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Record the cleanup if there is one.  */
if|if
condition|(
name|cleanup
operator|!=
literal|0
condition|)
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|=
name|temp_tree_cons
argument_list|(
name|decl_elt
argument_list|,
name|cleanup_elt
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|)
expr_stmt|;
name|decl_elts
operator|=
name|TREE_CHAIN
argument_list|(
name|decl_elts
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand a list of cleanups LIST.    Elements may be expressions or may be nested lists.     If DONT_DO is nonnull, then any list-element    whose TREE_PURPOSE matches DONT_DO is omitted.    This is sometimes used to avoid a cleanup associated with    a value that is being returned out of the scope.     If IN_FIXUP is non-zero, we are generating this cleanup for a fixup    goto and handle protection regions specially in that case.     If REACHABLE, we emit code, otherwise just inform the exception handling    code about this finalization.  */
end_comment

begin_function
specifier|static
name|void
name|expand_cleanups
parameter_list|(
name|list
parameter_list|,
name|dont_do
parameter_list|,
name|in_fixup
parameter_list|,
name|reachable
parameter_list|)
name|tree
name|list
decl_stmt|;
name|tree
name|dont_do
decl_stmt|;
name|int
name|in_fixup
decl_stmt|;
name|int
name|reachable
decl_stmt|;
block|{
name|tree
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|list
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
if|if
condition|(
name|dont_do
operator|==
literal|0
operator|||
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|!=
name|dont_do
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|expand_cleanups
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
name|dont_do
argument_list|,
name|in_fixup
argument_list|,
name|reachable
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|in_fixup
condition|)
block|{
name|tree
name|cleanup
init|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
decl_stmt|;
comment|/* See expand_d{h,c}c_cleanup for why we avoid this.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cleanup
argument_list|)
operator|!=
name|POPDHC_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|cleanup
argument_list|)
operator|!=
name|POPDCC_EXPR
comment|/* See expand_eh_region_start_tree for this case.  */
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|tail
argument_list|)
condition|)
block|{
name|cleanup
operator|=
name|protect_with_terminate
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
name|expand_eh_region_end
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reachable
condition|)
block|{
comment|/* Cleanups may be run multiple times.  For example, 		   when exiting a binding contour, we expand the 		   cleanups associated with that contour.  When a goto 		   within that binding contour has a target outside that 		   contour, it will expand all cleanups from its scope to 		   the target.  Though the cleanups are expanded multiple 		   times, the control paths are non-overlapping so the 		   cleanups will not be executed twice.  */
comment|/* We may need to protect fixups with rethrow regions.  */
name|int
name|protect
init|=
operator|(
name|in_fixup
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|tail
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|protect
condition|)
name|expand_fixup_region_start
argument_list|()
expr_stmt|;
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|protect
condition|)
name|expand_fixup_region_end
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Mark when the context we are emitting RTL for as a conditional    context, so that any cleanup actions we register with    expand_decl_init will be properly conditionalized when those    cleanup actions are later performed.  Must be called before any    expression (tree) is expanded that is within a conditional context.  */
end_comment

begin_function
name|void
name|start_cleanup_deferral
parameter_list|()
block|{
comment|/* block_stack can be NULL if we are inside the parameter list.  It is      OK to do nothing, because cleanups aren't possible here.  */
if|if
condition|(
name|block_stack
condition|)
operator|++
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|conditional_code
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark the end of a conditional region of code.  Because cleanup    deferrals may be nested, we may still be in a conditional region    after we end the currently deferred cleanups, only after we end all    deferred cleanups, are we back in unconditional code.  */
end_comment

begin_function
name|void
name|end_cleanup_deferral
parameter_list|()
block|{
comment|/* block_stack can be NULL if we are inside the parameter list.  It is      OK to do nothing, because cleanups aren't possible here.  */
if|if
condition|(
name|block_stack
condition|)
operator|--
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|conditional_code
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move all cleanups from the current block_stack    to the containing block_stack, where they are assumed to    have been created.  If anything can cause a temporary to    be created, but not expanded for more than one level of    block_stacks, then this code will have to change.  */
end_comment

begin_function
name|void
name|move_cleanups_up
parameter_list|()
block|{
name|struct
name|nesting
modifier|*
name|block
init|=
name|block_stack
decl_stmt|;
name|struct
name|nesting
modifier|*
name|outer
init|=
name|block
operator|->
name|next
decl_stmt|;
name|outer
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|=
name|chainon
argument_list|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|,
name|outer
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|)
expr_stmt|;
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|last_cleanup_this_contour
parameter_list|()
block|{
if|if
condition|(
name|block_stack
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if there are any pending cleanups at this point.    If THIS_CONTOUR is nonzero, check the current contour as well.    Otherwise, look only at the contours that enclose this one.  */
end_comment

begin_function
name|int
name|any_pending_cleanups
parameter_list|(
name|this_contour
parameter_list|)
name|int
name|this_contour
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|block
decl_stmt|;
if|if
condition|(
name|block_stack
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|this_contour
operator|&&
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|!=
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|==
literal|0
operator|&&
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|block
operator|=
name|block_stack
operator|->
name|next
init|;
name|block
condition|;
name|block
operator|=
name|block
operator|->
name|next
control|)
if|if
condition|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Enter a case (Pascal) or switch (C) statement.    Push a block onto case_stack and nesting_stack    to accumulate the case-labels that are seen    and to record the labels generated for the statement.     EXIT_FLAG is nonzero if `exit_something' should exit this case stmt.    Otherwise, this construct is transparent for `exit_something'.     EXPR is the index-expression to be dispatched on.    TYPE is its nominal type.  We could simply convert EXPR to this type,    but instead we take short cuts.  */
end_comment

begin_function
name|void
name|expand_start_case
parameter_list|(
name|exit_flag
parameter_list|,
name|expr
parameter_list|,
name|type
parameter_list|,
name|printname
parameter_list|)
name|int
name|exit_flag
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|tree
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|printname
decl_stmt|;
block|{
specifier|register
name|struct
name|nesting
modifier|*
name|thiscase
init|=
name|ALLOC_NESTING
argument_list|()
decl_stmt|;
comment|/* Make an entry on case_stack for the case we are entering.  */
name|thiscase
operator|->
name|next
operator|=
name|case_stack
expr_stmt|;
name|thiscase
operator|->
name|all
operator|=
name|nesting_stack
expr_stmt|;
name|thiscase
operator|->
name|depth
operator|=
operator|++
name|nesting_depth
expr_stmt|;
name|thiscase
operator|->
name|exit_label
operator|=
name|exit_flag
condition|?
name|gen_label_rtx
argument_list|()
else|:
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|index_expr
operator|=
name|expr
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
operator|=
name|type
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|num_ranges
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|printname
operator|=
name|printname
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|line_number_status
operator|=
name|force_line_numbers
argument_list|()
expr_stmt|;
name|case_stack
operator|=
name|thiscase
expr_stmt|;
name|nesting_stack
operator|=
name|thiscase
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Make sure case_stmt.start points to something that won't      need any transformation before expand_end_case.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
operator|!=
name|NOTE
condition|)
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|start
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start a "dummy case statement" within which case labels are invalid    and are not connected to any larger real case statement.    This can be used if you don't want to let a case statement jump    into the middle of certain kinds of constructs.  */
end_comment

begin_function
name|void
name|expand_start_case_dummy
parameter_list|()
block|{
specifier|register
name|struct
name|nesting
modifier|*
name|thiscase
init|=
name|ALLOC_NESTING
argument_list|()
decl_stmt|;
comment|/* Make an entry on case_stack for the dummy.  */
name|thiscase
operator|->
name|next
operator|=
name|case_stack
expr_stmt|;
name|thiscase
operator|->
name|all
operator|=
name|nesting_stack
expr_stmt|;
name|thiscase
operator|->
name|depth
operator|=
operator|++
name|nesting_depth
expr_stmt|;
name|thiscase
operator|->
name|exit_label
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|num_ranges
operator|=
literal|0
expr_stmt|;
name|case_stack
operator|=
name|thiscase
expr_stmt|;
name|nesting_stack
operator|=
name|thiscase
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End a dummy case statement.  */
end_comment

begin_function
name|void
name|expand_end_case_dummy
parameter_list|()
block|{
name|end_cleanup_deferral
argument_list|()
expr_stmt|;
name|POPSTACK
argument_list|(
name|case_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the data type of the index-expression    of the innermost case statement, or null if none.  */
end_comment

begin_function
name|tree
name|case_index_expr_type
parameter_list|()
block|{
if|if
condition|(
name|case_stack
condition|)
return|return
name|TREE_TYPE
argument_list|(
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|index_expr
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|check_seenlabel
parameter_list|()
block|{
comment|/* If this is the first label, warn if any insns have been emitted.  */
if|if
condition|(
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|line_number_status
operator|>=
literal|0
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
name|restore_line_number_status
argument_list|(
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|line_number_status
argument_list|)
expr_stmt|;
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|line_number_status
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|start
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|)
condition|)
block|{
do|do
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
do|while
condition|(
name|insn
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
operator|)
condition|)
do|;
comment|/* If insn is zero, then there must have been a syntax error.  */
if|if
condition|(
name|insn
condition|)
name|warning_with_file_and_line
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|"unreachable code at beginning of %s"
argument_list|,
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|printname
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Accumulate one case or default label inside a case or switch statement.    VALUE is the value of the case (a null pointer, for a default label).    The function CONVERTER, when applied to arguments T and V,    converts the value V to the type T.     If not currently inside a case or switch statement, return 1 and do    nothing.  The caller will print a language-specific error message.    If VALUE is a duplicate or overlaps, return 2 and do nothing    except store the (first) duplicate node in *DUPLICATE.    If VALUE is out of range, return 3 and do nothing.    If we are jumping into the scope of a cleanup or var-sized array, return 5.    Return 0 on success.     Extended to handle range statements.  */
end_comment

begin_function_decl
name|int
name|pushcase
parameter_list|(
name|value
parameter_list|,
name|converter
parameter_list|,
name|label
parameter_list|,
name|duplicate
parameter_list|)
specifier|register
name|tree
name|value
decl_stmt|;
function_decl|tree
parameter_list|(
function_decl|*converter
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|tree
name|label
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
modifier|*
name|duplicate
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|index_type
decl_stmt|;
name|tree
name|nominal_type
decl_stmt|;
comment|/* Fail if not inside a real case statement.  */
if|if
condition|(
operator|!
operator|(
name|case_stack
operator|&&
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|start
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|stack_block_stack
operator|&&
name|stack_block_stack
operator|->
name|depth
operator|>
name|case_stack
operator|->
name|depth
condition|)
return|return
literal|5
return|;
name|index_type
operator|=
name|TREE_TYPE
argument_list|(
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|index_expr
argument_list|)
expr_stmt|;
name|nominal_type
operator|=
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
expr_stmt|;
comment|/* If the index is erroneous, avoid more problems: pretend to succeed.  */
if|if
condition|(
name|index_type
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
comment|/* Convert VALUE to the type in which the comparisons are nominally done.  */
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
name|value
operator|=
call|(
modifier|*
name|converter
call|)
argument_list|(
name|nominal_type
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|check_seenlabel
argument_list|()
expr_stmt|;
comment|/* Fail if this value is out of range for the actual type of the index      (which may be narrower than NOMINAL_TYPE).  */
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|value
argument_list|,
name|index_type
argument_list|)
condition|)
return|return
literal|3
return|;
comment|/* Fail if this is a duplicate or overlaps another entry.  */
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|!=
literal|0
condition|)
block|{
operator|*
name|duplicate
operator|=
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
expr_stmt|;
return|return
literal|2
return|;
block|}
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|=
name|label
expr_stmt|;
block|}
else|else
return|return
name|add_case_node
argument_list|(
name|value
argument_list|,
name|value
argument_list|,
name|label
argument_list|,
name|duplicate
argument_list|)
return|;
name|expand_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Like pushcase but this case applies to all values between VALUE1 and    VALUE2 (inclusive).  If VALUE1 is NULL, the range starts at the lowest    value of the index type and ends at VALUE2.  If VALUE2 is NULL, the range    starts at VALUE1 and ends at the highest value of the index type.    If both are NULL, this case applies to all values.     The return value is the same as that of pushcase but there is one    additional error code: 4 means the specified range was empty.  */
end_comment

begin_function_decl
name|int
name|pushcase_range
parameter_list|(
name|value1
parameter_list|,
name|value2
parameter_list|,
name|converter
parameter_list|,
name|label
parameter_list|,
name|duplicate
parameter_list|)
specifier|register
name|tree
name|value1
decl_stmt|,
name|value2
decl_stmt|;
function_decl|tree
parameter_list|(
function_decl|*converter
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|tree
name|label
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
modifier|*
name|duplicate
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|index_type
decl_stmt|;
name|tree
name|nominal_type
decl_stmt|;
comment|/* Fail if not inside a real case statement.  */
if|if
condition|(
operator|!
operator|(
name|case_stack
operator|&&
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|start
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|stack_block_stack
operator|&&
name|stack_block_stack
operator|->
name|depth
operator|>
name|case_stack
operator|->
name|depth
condition|)
return|return
literal|5
return|;
name|index_type
operator|=
name|TREE_TYPE
argument_list|(
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|index_expr
argument_list|)
expr_stmt|;
name|nominal_type
operator|=
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
expr_stmt|;
comment|/* If the index is erroneous, avoid more problems: pretend to succeed.  */
if|if
condition|(
name|index_type
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
name|check_seenlabel
argument_list|()
expr_stmt|;
comment|/* Convert VALUEs to type in which the comparisons are nominally done      and replace any unspecified value with the corresponding bound.  */
if|if
condition|(
name|value1
operator|==
literal|0
condition|)
name|value1
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|index_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|value2
operator|==
literal|0
condition|)
name|value2
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|index_type
argument_list|)
expr_stmt|;
comment|/* Fail if the range is empty.  Do this before any conversion since      we want to allow out-of-range empty ranges.  */
if|if
condition|(
name|value2
operator|&&
name|tree_int_cst_lt
argument_list|(
name|value2
argument_list|,
name|value1
argument_list|)
condition|)
return|return
literal|4
return|;
name|value1
operator|=
call|(
modifier|*
name|converter
call|)
argument_list|(
name|nominal_type
argument_list|,
name|value1
argument_list|)
expr_stmt|;
comment|/* If the max was unbounded, use the max of the nominal_type we are       converting to.  Do this after the< check above to suppress false      positives.  */
if|if
condition|(
operator|!
name|value2
condition|)
name|value2
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|nominal_type
argument_list|)
expr_stmt|;
name|value2
operator|=
call|(
modifier|*
name|converter
call|)
argument_list|(
name|nominal_type
argument_list|,
name|value2
argument_list|)
expr_stmt|;
comment|/* Fail if these values are out of range.  */
if|if
condition|(
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|value1
argument_list|)
operator|||
operator|!
name|int_fits_type_p
argument_list|(
name|value1
argument_list|,
name|index_type
argument_list|)
condition|)
return|return
literal|3
return|;
if|if
condition|(
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|value2
argument_list|)
operator|||
operator|!
name|int_fits_type_p
argument_list|(
name|value2
argument_list|,
name|index_type
argument_list|)
condition|)
return|return
literal|3
return|;
return|return
name|add_case_node
argument_list|(
name|value1
argument_list|,
name|value2
argument_list|,
name|label
argument_list|,
name|duplicate
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Do the actual insertion of a case label for pushcase and pushcase_range    into case_stack->data.case_stmt.case_list.  Use an AVL tree to avoid    slowdown for large switch statements.  */
end_comment

begin_function
specifier|static
name|int
name|add_case_node
parameter_list|(
name|low
parameter_list|,
name|high
parameter_list|,
name|label
parameter_list|,
name|duplicate
parameter_list|)
name|tree
name|low
decl_stmt|,
name|high
decl_stmt|;
name|tree
name|label
decl_stmt|;
name|tree
modifier|*
name|duplicate
decl_stmt|;
block|{
name|struct
name|case_node
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|q
operator|=
operator|&
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
expr_stmt|;
name|p
operator|=
operator|*
name|q
expr_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
operator|*
name|q
operator|)
condition|)
block|{
name|p
operator|=
name|r
expr_stmt|;
comment|/* Keep going past elements distinctly greater than HIGH.  */
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|high
argument_list|,
name|p
operator|->
name|low
argument_list|)
condition|)
name|q
operator|=
operator|&
name|p
operator|->
name|left
expr_stmt|;
comment|/* or distinctly less than LOW.  */
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|p
operator|->
name|high
argument_list|,
name|low
argument_list|)
condition|)
name|q
operator|=
operator|&
name|p
operator|->
name|right
expr_stmt|;
else|else
block|{
comment|/* We have an overlap; this is an error.  */
operator|*
name|duplicate
operator|=
name|p
operator|->
name|code_label
expr_stmt|;
return|return
literal|2
return|;
block|}
block|}
comment|/* Add this label to the chain, and succeed.      Copy LOW, HIGH so they are on temporary rather than momentary      obstack and will thus survive till the end of the case statement.  */
name|r
operator|=
operator|(
expr|struct
name|case_node
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|case_node
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|low
operator|=
name|copy_node
argument_list|(
name|low
argument_list|)
expr_stmt|;
comment|/* If the bounds are equal, turn this into the one-value case.  */
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|low
argument_list|,
name|high
argument_list|)
condition|)
name|r
operator|->
name|high
operator|=
name|r
operator|->
name|low
expr_stmt|;
else|else
block|{
name|r
operator|->
name|high
operator|=
name|copy_node
argument_list|(
name|high
argument_list|)
expr_stmt|;
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|num_ranges
operator|++
expr_stmt|;
block|}
name|r
operator|->
name|code_label
operator|=
name|label
expr_stmt|;
name|expand_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
name|r
expr_stmt|;
name|r
operator|->
name|parent
operator|=
name|p
expr_stmt|;
name|r
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|right
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|struct
name|case_node
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|p
operator|->
name|left
condition|)
block|{
name|int
name|b
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|b
operator|=
name|p
operator|->
name|balance
operator|)
condition|)
comment|/* Growth propagation from left side.  */
name|p
operator|->
name|balance
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|balance
operator|<
literal|0
condition|)
block|{
comment|/* R-Rotation */
if|if
condition|(
operator|(
name|p
operator|->
name|left
operator|=
name|s
operator|=
name|r
operator|->
name|right
operator|)
condition|)
name|s
operator|->
name|parent
operator|=
name|p
expr_stmt|;
name|r
operator|->
name|right
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|parent
expr_stmt|;
name|p
operator|->
name|parent
operator|=
name|r
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|->
name|parent
operator|=
name|s
operator|)
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|left
operator|==
name|p
condition|)
name|s
operator|->
name|left
operator|=
name|r
expr_stmt|;
else|else
name|s
operator|->
name|right
operator|=
name|r
expr_stmt|;
block|}
else|else
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|=
name|r
expr_stmt|;
block|}
else|else
comment|/* r->balance == +1 */
block|{
comment|/* LR-Rotation */
name|int
name|b2
decl_stmt|;
name|struct
name|case_node
modifier|*
name|t
init|=
name|r
operator|->
name|right
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|left
operator|=
name|s
operator|=
name|t
operator|->
name|right
operator|)
condition|)
name|s
operator|->
name|parent
operator|=
name|p
expr_stmt|;
name|t
operator|->
name|right
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|->
name|right
operator|=
name|s
operator|=
name|t
operator|->
name|left
operator|)
condition|)
name|s
operator|->
name|parent
operator|=
name|r
expr_stmt|;
name|t
operator|->
name|left
operator|=
name|r
expr_stmt|;
name|b
operator|=
name|t
operator|->
name|balance
expr_stmt|;
name|b2
operator|=
name|b
operator|<
literal|0
expr_stmt|;
name|p
operator|->
name|balance
operator|=
name|b2
expr_stmt|;
name|b2
operator|=
operator|-
name|b2
operator|-
name|b
expr_stmt|;
name|r
operator|->
name|balance
operator|=
name|b2
expr_stmt|;
name|t
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|parent
expr_stmt|;
name|p
operator|->
name|parent
operator|=
name|t
expr_stmt|;
name|r
operator|->
name|parent
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|parent
operator|=
name|s
operator|)
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|left
operator|==
name|p
condition|)
name|s
operator|->
name|left
operator|=
name|t
expr_stmt|;
else|else
name|s
operator|->
name|right
operator|=
name|t
expr_stmt|;
block|}
else|else
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|=
name|t
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
comment|/* p->balance == +1; growth of left side balances the node.  */
name|p
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
comment|/* r == p->right */
block|{
name|int
name|b
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|b
operator|=
name|p
operator|->
name|balance
operator|)
condition|)
comment|/* Growth propagation from right side.  */
name|p
operator|->
name|balance
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|balance
operator|>
literal|0
condition|)
block|{
comment|/* L-Rotation */
if|if
condition|(
operator|(
name|p
operator|->
name|right
operator|=
name|s
operator|=
name|r
operator|->
name|left
operator|)
condition|)
name|s
operator|->
name|parent
operator|=
name|p
expr_stmt|;
name|r
operator|->
name|left
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|parent
expr_stmt|;
name|p
operator|->
name|parent
operator|=
name|r
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|->
name|parent
operator|=
name|s
operator|)
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|left
operator|==
name|p
condition|)
name|s
operator|->
name|left
operator|=
name|r
expr_stmt|;
else|else
name|s
operator|->
name|right
operator|=
name|r
expr_stmt|;
block|}
else|else
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|=
name|r
expr_stmt|;
block|}
else|else
comment|/* r->balance == -1 */
block|{
comment|/* RL-Rotation */
name|int
name|b2
decl_stmt|;
name|struct
name|case_node
modifier|*
name|t
init|=
name|r
operator|->
name|left
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|right
operator|=
name|s
operator|=
name|t
operator|->
name|left
operator|)
condition|)
name|s
operator|->
name|parent
operator|=
name|p
expr_stmt|;
name|t
operator|->
name|left
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|->
name|left
operator|=
name|s
operator|=
name|t
operator|->
name|right
operator|)
condition|)
name|s
operator|->
name|parent
operator|=
name|r
expr_stmt|;
name|t
operator|->
name|right
operator|=
name|r
expr_stmt|;
name|b
operator|=
name|t
operator|->
name|balance
expr_stmt|;
name|b2
operator|=
name|b
operator|<
literal|0
expr_stmt|;
name|r
operator|->
name|balance
operator|=
name|b2
expr_stmt|;
name|b2
operator|=
operator|-
name|b2
operator|-
name|b
expr_stmt|;
name|p
operator|->
name|balance
operator|=
name|b2
expr_stmt|;
name|t
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|parent
expr_stmt|;
name|p
operator|->
name|parent
operator|=
name|t
expr_stmt|;
name|r
operator|->
name|parent
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|parent
operator|=
name|s
operator|)
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|left
operator|==
name|p
condition|)
name|s
operator|->
name|left
operator|=
name|t
expr_stmt|;
else|else
name|s
operator|->
name|right
operator|=
name|t
expr_stmt|;
block|}
else|else
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|=
name|t
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
comment|/* p->balance == -1; growth of right side balances the node.  */
name|p
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|r
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|parent
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns the number of possible values of TYPE.    Returns -1 if the number is unknown or variable.    Returns -2 if the number does not fit in a HOST_WIDE_INT.    Sets *SPARENESS to 2 if TYPE is an ENUMERAL_TYPE whose values    do not increase monotonically (there may be duplicates);    to 1 if the values increase monotonically, but not always by 1;    otherwise sets it to 0.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|all_cases_count
parameter_list|(
name|type
parameter_list|,
name|spareness
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
modifier|*
name|spareness
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|count
decl_stmt|;
operator|*
name|spareness
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|t
decl_stmt|;
case|case
name|BOOLEAN_TYPE
case|:
name|count
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|CHAR_TYPE
case|:
name|count
operator|=
literal|1
operator|<<
name|BITS_PER_UNIT
expr_stmt|;
break|break;
default|default:
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
operator|-
literal|1
return|;
else|else
block|{
comment|/* count 	     = TREE_INT_CST_LOW (TYPE_MAX_VALUE (type)) 	     - TREE_INT_CST_LOW (TYPE_MIN_VALUE (type)) + 1 	     but with overflow checking.  */
name|tree
name|mint
init|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|maxt
init|=
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|lo
decl_stmt|,
name|hi
decl_stmt|;
name|neg_double
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|mint
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|mint
argument_list|)
argument_list|,
operator|&
name|lo
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|maxt
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|maxt
argument_list|)
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|,
operator|&
name|lo
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|lo
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi
operator|!=
literal|0
operator|||
name|lo
operator|<
literal|0
condition|)
return|return
operator|-
literal|2
return|;
name|count
operator|=
name|lo
expr_stmt|;
block|}
break|break;
case|case
name|ENUMERAL_TYPE
case|:
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|+
name|count
operator|!=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
operator|*
name|spareness
operator|=
literal|1
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|spareness
operator|==
literal|1
condition|)
block|{
name|tree
name|prev
init|=
name|TREE_VALUE
argument_list|(
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|t
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
init|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|,
name|t
operator|!=
name|NULL_TREE
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|prev
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|spareness
operator|=
literal|2
expr_stmt|;
break|break;
block|}
name|prev
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|count
return|;
block|}
end_function

begin_define
define|#
directive|define
name|BITARRAY_TEST
parameter_list|(
name|ARRAY
parameter_list|,
name|INDEX
parameter_list|)
define|\
value|((ARRAY)[(unsigned) (INDEX) / HOST_BITS_PER_CHAR]\& (1<< ((unsigned) (INDEX) % HOST_BITS_PER_CHAR)))
end_define

begin_define
define|#
directive|define
name|BITARRAY_SET
parameter_list|(
name|ARRAY
parameter_list|,
name|INDEX
parameter_list|)
define|\
value|((ARRAY)[(unsigned) (INDEX) / HOST_BITS_PER_CHAR]\ 			  |= 1<< ((unsigned) (INDEX) % HOST_BITS_PER_CHAR))
end_define

begin_comment
comment|/* Set the elements of the bitstring CASES_SEEN (which has length COUNT),    with the case values we have seen, assuming the case expression    has the given TYPE.    SPARSENESS is as determined by all_cases_count.     The time needed is proportional to COUNT, unless    SPARSENESS is 2, in which case quadratic time is needed.  */
end_comment

begin_function
name|void
name|mark_seen_cases
parameter_list|(
name|type
parameter_list|,
name|cases_seen
parameter_list|,
name|count
parameter_list|,
name|sparseness
parameter_list|)
name|tree
name|type
decl_stmt|;
name|unsigned
name|char
modifier|*
name|cases_seen
decl_stmt|;
name|long
name|count
decl_stmt|;
name|int
name|sparseness
decl_stmt|;
block|{
name|tree
name|next_node_to_try
init|=
name|NULL_TREE
decl_stmt|;
name|long
name|next_node_offset
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|case_node
modifier|*
name|n
decl_stmt|,
modifier|*
name|root
init|=
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
decl_stmt|;
name|tree
name|val
init|=
name|make_node
argument_list|(
name|INTEGER_CST
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
operator|!
name|root
condition|)
empty_stmt|;
comment|/* Do nothing */
elseif|else
if|if
condition|(
name|sparseness
operator|==
literal|2
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|HOST_WIDE_INT
name|xlo
decl_stmt|;
comment|/* This less efficient loop is only needed to handle 	 duplicate case values (multiple enum constants 	 with the same value).  */
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|root
operator|->
name|low
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
operator|,
name|xlo
operator|=
literal|0
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|,
name|xlo
operator|++
control|)
block|{
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|root
expr_stmt|;
do|do
block|{
comment|/* Keep going past elements distinctly greater than VAL.  */
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|val
argument_list|,
name|n
operator|->
name|low
argument_list|)
condition|)
name|n
operator|=
name|n
operator|->
name|left
expr_stmt|;
comment|/* or distinctly less than VAL.  */
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|n
operator|->
name|high
argument_list|,
name|val
argument_list|)
condition|)
name|n
operator|=
name|n
operator|->
name|right
expr_stmt|;
else|else
block|{
comment|/* We have found a matching range.  */
name|BITARRAY_SET
argument_list|(
name|cases_seen
argument_list|,
name|xlo
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|n
condition|)
do|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|root
operator|->
name|left
condition|)
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|=
name|root
operator|=
name|case_tree2list
argument_list|(
name|root
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|root
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
block|{
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|low
argument_list|)
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|n
operator|->
name|low
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|n
operator|->
name|high
argument_list|,
name|val
argument_list|)
condition|)
block|{
comment|/* Calculate (into xlo) the "offset" of the integer (val). 		 The element with lowest value has offset 0, the next smallest 		 element has offset 1, etc.  */
name|HOST_WIDE_INT
name|xlo
decl_stmt|,
name|xhi
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|sparseness
operator|&&
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* The TYPE_VALUES will be in increasing order, so 		     starting searching where we last ended.  */
name|t
operator|=
name|next_node_to_try
expr_stmt|;
name|xlo
operator|=
name|next_node_offset
expr_stmt|;
name|xhi
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
block|{
name|t
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|xlo
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|val
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|next_node_to_try
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|next_node_offset
operator|=
name|xlo
operator|+
literal|1
expr_stmt|;
break|break;
block|}
name|xlo
operator|++
expr_stmt|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|next_node_to_try
condition|)
block|{
name|xlo
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|t
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|neg_double
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|xlo
argument_list|,
operator|&
name|xhi
argument_list|)
expr_stmt|;
else|else
name|xlo
operator|=
name|xhi
operator|=
literal|0
expr_stmt|;
name|add_double
argument_list|(
name|xlo
argument_list|,
name|xhi
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
argument_list|,
operator|&
name|xlo
argument_list|,
operator|&
name|xhi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xhi
operator|==
literal|0
operator|&&
name|xlo
operator|>=
literal|0
operator|&&
name|xlo
operator|<
name|count
condition|)
name|BITARRAY_SET
argument_list|(
name|cases_seen
argument_list|,
name|xlo
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
argument_list|,
operator|&
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Called when the index of a switch statement is an enumerated type    and there is no default label.     Checks that all enumeration literals are covered by the case    expressions of a switch.  Also, warn if there are any extra    switch cases that are *not* elements of the enumerated type.     If all enumeration literals were covered by the case expressions,    turn one of the expressions into the default expression since it should    not be possible to fall through such a switch.  */
end_comment

begin_function
name|void
name|check_for_full_enumeration_handling
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
specifier|register
name|struct
name|case_node
modifier|*
name|n
decl_stmt|;
specifier|register
name|tree
name|chain
decl_stmt|;
if|#
directive|if
literal|0
comment|/* variable used by 'if 0'ed  code below. */
block|register struct case_node **l;   int all_values = 1;
endif|#
directive|endif
comment|/* True iff the selector type is a numbered set mode.  */
name|int
name|sparseness
init|=
literal|0
decl_stmt|;
comment|/* The number of possible selector values.  */
name|HOST_WIDE_INT
name|size
decl_stmt|;
comment|/* For each possible selector value. a one iff it has been matched      by a case value alternative.  */
name|unsigned
name|char
modifier|*
name|cases_seen
decl_stmt|;
comment|/* The allocated size of cases_seen, in chars.  */
name|long
name|bytes_needed
decl_stmt|;
if|if
condition|(
operator|!
name|warn_switch
condition|)
return|return;
name|size
operator|=
name|all_cases_count
argument_list|(
name|type
argument_list|,
operator|&
name|sparseness
argument_list|)
expr_stmt|;
name|bytes_needed
operator|=
operator|(
name|size
operator|+
name|HOST_BITS_PER_CHAR
operator|)
operator|/
name|HOST_BITS_PER_CHAR
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|<
literal|600000
comment|/* We deliberately use malloc here - not xmalloc.  */
operator|&&
operator|(
name|cases_seen
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bytes_needed
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|long
name|i
decl_stmt|;
name|tree
name|v
init|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|cases_seen
argument_list|,
name|bytes_needed
argument_list|)
expr_stmt|;
comment|/* The time complexity of this code is normally O(N), where 	 N being the number of members in the enumerated type. 	 However, if type is a ENUMERAL_TYPE whose values do not 	 increase monotonically, O(N*log(N)) time may be needed.  */
name|mark_seen_cases
argument_list|(
name|type
argument_list|,
name|cases_seen
argument_list|,
name|size
argument_list|,
name|sparseness
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|v
operator|!=
name|NULL_TREE
operator|&&
name|i
operator|<
name|size
condition|;
name|i
operator|++
operator|,
name|v
operator|=
name|TREE_CHAIN
argument_list|(
name|v
argument_list|)
control|)
block|{
if|if
condition|(
name|BITARRAY_TEST
argument_list|(
name|cases_seen
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"enumeration value `%s' not handled in switch"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|v
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|cases_seen
argument_list|)
expr_stmt|;
block|}
comment|/* Now we go the other way around; we warn if there are case      expressions that don't correspond to enumerators.  This can      occur since C and C++ don't enforce type-checking of      assignments to enumeration variables.  */
if|if
condition|(
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|&&
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|->
name|left
condition|)
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|=
name|case_tree2list
argument_list|(
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_switch
condition|)
for|for
control|(
name|n
operator|=
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
block|{
for|for
control|(
name|chain
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
init|;
name|chain
operator|&&
operator|!
name|tree_int_cst_equal
argument_list|(
name|n
operator|->
name|low
argument_list|,
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|chain
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"case value `%ld' not in enumerated type"
argument_list|,
operator|(
name|long
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|low
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"case value `%ld' not in enumerated type `%s'"
argument_list|,
operator|(
name|long
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|low
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|)
condition|?
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
else|:
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|n
operator|->
name|low
argument_list|,
name|n
operator|->
name|high
argument_list|)
condition|)
block|{
for|for
control|(
name|chain
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
init|;
name|chain
operator|&&
operator|!
name|tree_int_cst_equal
argument_list|(
name|n
operator|->
name|high
argument_list|,
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|chain
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"case value `%ld' not in enumerated type"
argument_list|,
operator|(
name|long
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|high
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"case value `%ld' not in enumerated type `%s'"
argument_list|,
operator|(
name|long
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|high
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|)
condition|?
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
else|:
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|#
directive|if
literal|0
comment|/* ??? This optimization is disabled because it causes valid programs to      fail.  ANSI C does not guarantee that an expression with enum type      will have a value that is the same as one of the enumeration literals.  */
comment|/* If all values were found as case labels, make one of them the default      label.  Thus, this switch will never fall through.  We arbitrarily pick      the last one to make the default since this is likely the most      efficient choice.  */
block|if (all_values)     {       for (l =&case_stack->data.case_stmt.case_list; 	   (*l)->right != 0; 	   l =&(*l)->right) 	;        case_stack->data.case_stmt.default_label = (*l)->code_label;       *l = 0;     }
endif|#
directive|endif
comment|/* 0 */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Terminate a case (Pascal) or switch (C) statement    in which ORIG_INDEX is the expression to be tested.    Generate the code to test it and jump to the right place.  */
end_comment

begin_function
name|void
name|expand_end_case
parameter_list|(
name|orig_index
parameter_list|)
name|tree
name|orig_index
decl_stmt|;
block|{
name|tree
name|minval
init|=
name|NULL_TREE
decl_stmt|,
name|maxval
init|=
name|NULL_TREE
decl_stmt|,
name|range
decl_stmt|,
name|orig_minval
decl_stmt|;
name|rtx
name|default_label
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|case_node
modifier|*
name|n
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|rtx
name|index
decl_stmt|;
name|rtx
name|table_label
decl_stmt|;
name|int
name|ncases
decl_stmt|;
name|rtx
modifier|*
name|labelvec
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|before_case
decl_stmt|;
specifier|register
name|struct
name|nesting
modifier|*
name|thiscase
init|=
name|case_stack
decl_stmt|;
name|tree
name|index_expr
decl_stmt|,
name|index_type
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|table_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|index_expr
operator|=
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|index_expr
expr_stmt|;
name|index_type
operator|=
name|TREE_TYPE
argument_list|(
name|index_expr
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|index_type
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* This might get an spurious warning in the presence of a syntax error;      it could be fixed by moving the call to check_seenlabel after the      check for error_mark_node, and copying the code of check_seenlabel that      deals with case_stack->data.case_stmt.line_number_status /      restore_line_number_status in front of the call to end_cleanup_deferral;      However, this might miss some useful warnings in the presence of      non-syntax errors.  */
name|check_seenlabel
argument_list|()
expr_stmt|;
comment|/* An ERROR_MARK occurs for various reasons including invalid data type.  */
if|if
condition|(
name|index_type
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* If switch expression was an enumerated type, check that all 	 enumeration literals are covered by the cases. 	 No sense trying this if there's a default case, however.  */
if|if
condition|(
operator|!
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_index
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|index_expr
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|check_for_full_enumeration_handling
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_index
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we don't have a default-label, create one here, 	 after the body of the switch.  */
if|if
condition|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|==
literal|0
condition|)
block|{
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|expand_label
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
argument_list|)
expr_stmt|;
block|}
name|default_label
operator|=
name|label_rtx
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
argument_list|)
expr_stmt|;
name|before_case
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|&&
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|->
name|left
condition|)
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|=
name|case_tree2list
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Simplify the case-list before we count it.  */
name|group_case_nodes
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
argument_list|)
expr_stmt|;
comment|/* Get upper and lower bounds of case values. 	 Also convert all the case values to the index expr's data type.  */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
block|{
comment|/* Check low and high label values are integers.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
operator|->
name|low
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
operator|->
name|high
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|abort
argument_list|()
expr_stmt|;
name|n
operator|->
name|low
operator|=
name|convert
argument_list|(
name|index_type
argument_list|,
name|n
operator|->
name|low
argument_list|)
expr_stmt|;
name|n
operator|->
name|high
operator|=
name|convert
argument_list|(
name|index_type
argument_list|,
name|n
operator|->
name|high
argument_list|)
expr_stmt|;
comment|/* Count the elements and track the largest and smallest 	     of them (treating them as signed even if they are not).  */
if|if
condition|(
name|count
operator|++
operator|==
literal|0
condition|)
block|{
name|minval
operator|=
name|n
operator|->
name|low
expr_stmt|;
name|maxval
operator|=
name|n
operator|->
name|high
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|INT_CST_LT
argument_list|(
name|n
operator|->
name|low
argument_list|,
name|minval
argument_list|)
condition|)
name|minval
operator|=
name|n
operator|->
name|low
expr_stmt|;
if|if
condition|(
name|INT_CST_LT
argument_list|(
name|maxval
argument_list|,
name|n
operator|->
name|high
argument_list|)
condition|)
name|maxval
operator|=
name|n
operator|->
name|high
expr_stmt|;
block|}
comment|/* A range counts double, since it requires two compares.  */
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|n
operator|->
name|low
argument_list|,
name|n
operator|->
name|high
argument_list|)
condition|)
name|count
operator|++
expr_stmt|;
block|}
name|orig_minval
operator|=
name|minval
expr_stmt|;
comment|/* Compute span of values.  */
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
name|range
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index_type
argument_list|,
name|maxval
argument_list|,
name|minval
argument_list|)
argument_list|)
expr_stmt|;
name|end_cleanup_deferral
argument_list|()
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|expand_expr
argument_list|(
name|index_expr
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|emit_jump
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
block|}
comment|/* If range of values is much bigger than number of values, 	 make a sequence of conditional branches instead of a dispatch. 	 If the switch-index is a constant, do it this way 	 because we can optimize it.  */
ifndef|#
directive|ifndef
name|CASE_VALUES_THRESHOLD
ifdef|#
directive|ifdef
name|HAVE_casesi
define|#
directive|define
name|CASE_VALUES_THRESHOLD
value|(HAVE_casesi ? 4 : 5)
else|#
directive|else
comment|/* If machine does not have a case insn that compares the 	 bounds, this means extra overhead for dispatch tables 	 which raises the threshold for using them.  */
define|#
directive|define
name|CASE_VALUES_THRESHOLD
value|5
endif|#
directive|endif
comment|/* HAVE_casesi */
endif|#
directive|endif
comment|/* CASE_VALUES_THRESHOLD */
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|range
argument_list|)
operator|!=
literal|0
operator|||
name|count
operator|<
operator|(
name|unsigned
name|int
operator|)
name|CASE_VALUES_THRESHOLD
operator|||
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|range
argument_list|)
argument_list|)
operator|>
literal|10
operator|*
name|count
operator|)
ifndef|#
directive|ifndef
name|ASM_OUTPUT_ADDR_DIFF_ELT
operator|||
name|flag_pic
endif|#
directive|endif
operator|||
name|TREE_CODE
argument_list|(
name|index_expr
argument_list|)
operator|==
name|INTEGER_CST
comment|/* These will reduce to a constant.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|index_expr
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|index_expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|index_expr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_FUNCTION_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|index_expr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|BUILT_IN_CLASSIFY_TYPE
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|index_expr
argument_list|)
operator|==
name|COMPOUND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|index_expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|)
condition|)
block|{
name|index
operator|=
name|expand_expr
argument_list|(
name|index_expr
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the index is a short or char that we do not have 	     an insn to handle comparisons directly, convert it to 	     a full integer now, rather than letting each comparison 	     generate the conversion.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|index
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|index
argument_list|)
index|]
operator|.
name|insn_code
operator|==
name|CODE_FOR_nothing
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|wider_mode
decl_stmt|;
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE
argument_list|(
name|index
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
if|if
condition|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|index
operator|=
name|convert_to_mode
argument_list|(
name|wider_mode
argument_list|,
name|index
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|emit_queue
argument_list|()
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|index
operator|=
name|protect_from_queue
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|MEM
condition|)
name|index
operator|=
name|copy_to_reg
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|CONST_INT
operator|||
name|TREE_CODE
argument_list|(
name|index_expr
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* Make a tree node with the proper constant value 		 if we don't already have one.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index_expr
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|index_expr
operator|=
name|build_int_2
argument_list|(
name|INTVAL
argument_list|(
name|index
argument_list|)
argument_list|,
name|unsignedp
operator|||
name|INTVAL
argument_list|(
name|index
argument_list|)
operator|>=
literal|0
condition|?
literal|0
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
name|index_expr
operator|=
name|convert
argument_list|(
name|index_type
argument_list|,
name|index_expr
argument_list|)
expr_stmt|;
block|}
comment|/* For constant index expressions we need only 		 issue a unconditional branch to the appropriate 		 target code.  The job of removing any unreachable 		 code is left to the optimisation phase if the 		 "-O" option is specified.  */
for|for
control|(
name|n
operator|=
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
if|if
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|index_expr
argument_list|,
name|n
operator|->
name|low
argument_list|)
operator|&&
operator|!
name|tree_int_cst_lt
argument_list|(
name|n
operator|->
name|high
argument_list|,
name|index_expr
argument_list|)
condition|)
break|break;
if|if
condition|(
name|n
condition|)
name|emit_jump
argument_list|(
name|label_rtx
argument_list|(
name|n
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_jump
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the index expression is not constant we generate 		 a binary decision tree to select the appropriate 		 target code.  This is done as follows:  		 The list of cases is rearranged into a binary tree, 		 nearly optimal assuming equal probability for each case.  		 The tree is transformed into RTL, eliminating 		 redundant test conditions at the same time.  		 If program flow could reach the end of the 		 decision tree an unconditional jump to the 		 default code is emitted.  */
name|use_cost_table
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_index
argument_list|)
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|estimate_case_costs
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
argument_list|)
operator|)
expr_stmt|;
name|balance_case_nodes
argument_list|(
operator|&
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
name|emit_jump_if_reachable
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|win
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_casesi
if|if
condition|(
name|HAVE_casesi
condition|)
block|{
name|enum
name|machine_mode
name|index_mode
init|=
name|SImode
decl_stmt|;
name|int
name|index_bits
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|index_mode
argument_list|)
decl_stmt|;
name|rtx
name|op1
decl_stmt|,
name|op2
decl_stmt|;
name|enum
name|machine_mode
name|op_mode
decl_stmt|;
comment|/* Convert the index to SImode.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|index_type
argument_list|)
argument_list|)
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|index_mode
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|omode
init|=
name|TYPE_MODE
argument_list|(
name|index_type
argument_list|)
decl_stmt|;
name|rtx
name|rangertx
init|=
name|expand_expr
argument_list|(
name|range
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* We must handle the endpoints in the original mode.  */
name|index_expr
operator|=
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index_type
argument_list|,
name|index_expr
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|minval
operator|=
name|integer_zero_node
expr_stmt|;
name|index
operator|=
name|expand_expr
argument_list|(
name|index_expr
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|rangertx
argument_list|,
name|index
argument_list|,
name|LTU
argument_list|,
name|NULL_RTX
argument_list|,
name|omode
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
comment|/* Now we can safely truncate.  */
name|index
operator|=
name|convert_to_mode
argument_list|(
name|index_mode
argument_list|,
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|index_type
argument_list|)
operator|!=
name|index_mode
condition|)
block|{
name|index_expr
operator|=
name|convert
argument_list|(
name|type_for_size
argument_list|(
name|index_bits
argument_list|,
literal|0
argument_list|)
argument_list|,
name|index_expr
argument_list|)
expr_stmt|;
name|index_type
operator|=
name|TREE_TYPE
argument_list|(
name|index_expr
argument_list|)
expr_stmt|;
block|}
name|index
operator|=
name|expand_expr
argument_list|(
name|index_expr
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|emit_queue
argument_list|()
expr_stmt|;
name|index
operator|=
name|protect_from_queue
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|op_mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_casesi
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_casesi
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|index
argument_list|,
name|op_mode
argument_list|)
condition|)
name|index
operator|=
name|copy_to_mode_reg
argument_list|(
name|op_mode
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|minval
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op_mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_casesi
index|]
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_casesi
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|op1
argument_list|,
name|op_mode
argument_list|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|op_mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|op2
operator|=
name|expand_expr
argument_list|(
name|range
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op_mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_casesi
index|]
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_casesi
index|]
index|[
literal|2
index|]
call|)
argument_list|(
name|op2
argument_list|,
name|op_mode
argument_list|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|op_mode
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_casesi
argument_list|(
name|index
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|table_label
argument_list|,
name|default_label
argument_list|)
argument_list|)
expr_stmt|;
name|win
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_tablejump
if|if
condition|(
operator|!
name|win
operator|&&
name|HAVE_tablejump
condition|)
block|{
name|index_expr
operator|=
name|convert
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index_type
argument_list|,
name|index_expr
argument_list|,
name|minval
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|index_type
operator|=
name|TREE_TYPE
argument_list|(
name|index_expr
argument_list|)
expr_stmt|;
name|index
operator|=
name|expand_expr
argument_list|(
name|index_expr
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|index
operator|=
name|protect_from_queue
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|do_tablejump
argument_list|(
name|index
argument_list|,
name|TYPE_MODE
argument_list|(
name|index_type
argument_list|)
argument_list|,
name|expand_expr
argument_list|(
name|range
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|table_label
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
name|win
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|win
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Get table of labels to jump to, in order of case index.  */
name|ncases
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|range
argument_list|)
operator|+
literal|1
expr_stmt|;
name|labelvec
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|ncases
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|labelvec
argument_list|,
name|ncases
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
block|{
specifier|register
name|HOST_WIDE_INT
name|i
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|low
argument_list|)
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|orig_minval
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|labelvec
index|[
name|i
index|]
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|label_rtx
argument_list|(
name|n
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
name|TREE_INT_CST_LOW
argument_list|(
name|orig_minval
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|high
argument_list|)
condition|)
break|break;
name|i
operator|++
expr_stmt|;
block|}
block|}
comment|/* Fill in the gaps with the default.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncases
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|labelvec
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|labelvec
index|[
name|i
index|]
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
comment|/* Output the table */
name|emit_label
argument_list|(
name|table_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|CASE_VECTOR_PC_RELATIVE
operator|||
name|flag_pic
condition|)
name|emit_jump_insn
argument_list|(
name|gen_rtx_ADDR_DIFF_VEC
argument_list|(
name|CASE_VECTOR_MODE
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|table_label
argument_list|)
argument_list|,
name|gen_rtvec_v
argument_list|(
name|ncases
argument_list|,
name|labelvec
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|const0_rtx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_jump_insn
argument_list|(
name|gen_rtx_ADDR_VEC
argument_list|(
name|CASE_VECTOR_MODE
argument_list|,
name|gen_rtvec_v
argument_list|(
name|ncases
argument_list|,
name|labelvec
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the case insn drops through the table, 	     after the table we must jump to the default-label. 	     Otherwise record no drop-through after the table.  */
ifdef|#
directive|ifdef
name|CASE_DROPS_THROUGH
name|emit_jump
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_barrier
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|before_case
operator|=
name|squeeze_notes
argument_list|(
name|NEXT_INSN
argument_list|(
name|before_case
argument_list|)
argument_list|,
name|get_last_insn
argument_list|()
argument_list|)
expr_stmt|;
name|reorder_insns
argument_list|(
name|before_case
argument_list|,
name|get_last_insn
argument_list|()
argument_list|,
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|start
argument_list|)
expr_stmt|;
block|}
else|else
name|end_cleanup_deferral
argument_list|()
expr_stmt|;
if|if
condition|(
name|thiscase
operator|->
name|exit_label
condition|)
name|emit_label
argument_list|(
name|thiscase
operator|->
name|exit_label
argument_list|)
expr_stmt|;
name|POPSTACK
argument_list|(
name|case_stack
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert the tree NODE into a list linked by the right field, with the left    field zeroed.  RIGHT is used for recursion; it is a list to be placed    rightmost in the resulting list.  */
end_comment

begin_function
specifier|static
name|struct
name|case_node
modifier|*
name|case_tree2list
parameter_list|(
name|node
parameter_list|,
name|right
parameter_list|)
name|struct
name|case_node
modifier|*
name|node
decl_stmt|,
decl|*
name|right
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|case_node
modifier|*
name|left
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|right
condition|)
name|right
operator|=
name|case_tree2list
argument_list|(
name|node
operator|->
name|right
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|node
operator|->
name|right
operator|=
name|right
expr_stmt|;
if|if
condition|(
operator|(
name|left
operator|=
name|node
operator|->
name|left
operator|)
condition|)
block|{
name|node
operator|->
name|left
operator|=
literal|0
expr_stmt|;
return|return
name|case_tree2list
argument_list|(
name|left
argument_list|,
name|node
argument_list|)
return|;
block|}
return|return
name|node
return|;
block|}
end_block

begin_comment
comment|/* Generate code to jump to LABEL if OP1 and OP2 are equal.  */
end_comment

begin_function
specifier|static
name|void
name|do_jump_if_equal
parameter_list|(
name|op1
parameter_list|,
name|op2
parameter_list|,
name|label
parameter_list|,
name|unsignedp
parameter_list|)
name|rtx
name|op1
decl_stmt|,
name|op2
decl_stmt|,
name|label
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|op2
argument_list|)
condition|)
name|emit_jump
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|op1
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op2
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Not all case values are encountered equally.  This function    uses a heuristic to weight case labels, in cases where that    looks like a reasonable thing to do.     Right now, all we try to guess is text, and we establish the    following weights:  	chars above space:	16 	digits:			16 	default:		12 	space, punct:		8 	tab:			4 	newline:		2 	other "\" chars:	1 	remaining chars:	0     If we find any cases in the switch that are not either -1 or in the range    of valid ASCII characters, or are control characters other than those    commonly used with "\", don't treat this switch scanning text.     Return 1 if these nodes are suitable for cost estimation, otherwise    return 0.  */
end_comment

begin_function
specifier|static
name|int
name|estimate_case_costs
parameter_list|(
name|node
parameter_list|)
name|case_node_ptr
name|node
decl_stmt|;
block|{
name|tree
name|min_ascii
init|=
name|build_int_2
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|tree
name|max_ascii
init|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|node
operator|->
name|high
argument_list|)
argument_list|,
name|build_int_2
argument_list|(
literal|127
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|case_node_ptr
name|n
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If we haven't already made the cost table, make it now.  Note that the      lower bound of the table is -1, not zero.  */
if|if
condition|(
name|cost_table
operator|==
name|NULL
condition|)
block|{
name|cost_table
operator|=
operator|(
operator|(
name|short
operator|*
operator|)
name|xmalloc
argument_list|(
literal|129
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
operator|)
operator|+
literal|1
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|cost_table
operator|-
literal|1
operator|)
argument_list|,
literal|129
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ISALNUM
argument_list|(
name|i
argument_list|)
condition|)
name|cost_table
index|[
name|i
index|]
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|ISPUNCT
argument_list|(
name|i
argument_list|)
condition|)
name|cost_table
index|[
name|i
index|]
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|ISCNTRL
argument_list|(
name|i
argument_list|)
condition|)
name|cost_table
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|cost_table
index|[
literal|' '
index|]
operator|=
literal|8
expr_stmt|;
name|cost_table
index|[
literal|'\t'
index|]
operator|=
literal|4
expr_stmt|;
name|cost_table
index|[
literal|'\0'
index|]
operator|=
literal|4
expr_stmt|;
name|cost_table
index|[
literal|'\n'
index|]
operator|=
literal|2
expr_stmt|;
name|cost_table
index|[
literal|'\f'
index|]
operator|=
literal|1
expr_stmt|;
name|cost_table
index|[
literal|'\v'
index|]
operator|=
literal|1
expr_stmt|;
name|cost_table
index|[
literal|'\b'
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* See if all the case expressions look like text.  It is text if the      constant is>= -1 and the highest constant is<= 127.  Do all comparisons      as signed arithmetic since we don't want to ever access cost_table with a      value less than -1.  Also check that none of the constants in a range      are strange control characters.  */
for|for
control|(
name|n
operator|=
name|node
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
block|{
if|if
condition|(
operator|(
name|INT_CST_LT
argument_list|(
name|n
operator|->
name|low
argument_list|,
name|min_ascii
argument_list|)
operator|)
operator|||
name|INT_CST_LT
argument_list|(
name|max_ascii
argument_list|,
name|n
operator|->
name|high
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|low
argument_list|)
init|;
name|i
operator|<=
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|high
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cost_table
index|[
name|i
index|]
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* All interesting values are within the range of interesting      ASCII characters.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Scan an ordered list of case nodes    combining those with consecutive values or ranges.     Eg. three separate entries 1: 2: 3: become one entry 1..3:  */
end_comment

begin_function
specifier|static
name|void
name|group_case_nodes
parameter_list|(
name|head
parameter_list|)
name|case_node_ptr
name|head
decl_stmt|;
block|{
name|case_node_ptr
name|node
init|=
name|head
decl_stmt|;
while|while
condition|(
name|node
condition|)
block|{
name|rtx
name|lb
init|=
name|next_real_insn
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|lb2
decl_stmt|;
name|case_node_ptr
name|np
init|=
name|node
decl_stmt|;
comment|/* Try to group the successors of NODE with NODE.  */
while|while
condition|(
operator|(
operator|(
name|np
operator|=
name|np
operator|->
name|right
operator|)
operator|!=
literal|0
operator|)
comment|/* Do they jump to the same place?  */
operator|&&
operator|(
operator|(
name|lb2
operator|=
name|next_real_insn
argument_list|(
name|label_rtx
argument_list|(
name|np
operator|->
name|code_label
argument_list|)
argument_list|)
operator|)
operator|==
name|lb
operator|||
operator|(
name|lb
operator|!=
literal|0
operator|&&
name|lb2
operator|!=
literal|0
operator|&&
name|simplejump_p
argument_list|(
name|lb
argument_list|)
operator|&&
name|simplejump_p
argument_list|(
name|lb2
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|lb
argument_list|)
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|lb2
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
comment|/* Are their ranges consecutive?  */
operator|&&
name|tree_int_cst_equal
argument_list|(
name|np
operator|->
name|low
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|node
operator|->
name|high
argument_list|)
argument_list|,
name|node
operator|->
name|high
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|)
comment|/* An overflow is not consecutive.  */
operator|&&
name|tree_int_cst_lt
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|node
operator|->
name|high
argument_list|)
argument_list|,
name|node
operator|->
name|high
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|node
operator|->
name|high
operator|=
name|np
operator|->
name|high
expr_stmt|;
block|}
comment|/* NP is the first node after NODE which can't be grouped with it. 	 Delete the nodes in between, and move on to that node.  */
name|node
operator|->
name|right
operator|=
name|np
expr_stmt|;
name|node
operator|=
name|np
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Take an ordered list of case nodes    and transform them into a near optimal binary tree,    on the assumption that any target code selection value is as    likely as any other.     The transformation is performed by splitting the ordered    list into two equal sections plus a pivot.  The parts are    then attached to the pivot as left and right branches.  Each    branch is then transformed recursively.  */
end_comment

begin_function
specifier|static
name|void
name|balance_case_nodes
parameter_list|(
name|head
parameter_list|,
name|parent
parameter_list|)
name|case_node_ptr
modifier|*
name|head
decl_stmt|;
name|case_node_ptr
name|parent
decl_stmt|;
block|{
specifier|register
name|case_node_ptr
name|np
decl_stmt|;
name|np
operator|=
operator|*
name|head
expr_stmt|;
if|if
condition|(
name|np
condition|)
block|{
name|int
name|cost
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|ranges
init|=
literal|0
decl_stmt|;
specifier|register
name|case_node_ptr
modifier|*
name|npp
decl_stmt|;
name|case_node_ptr
name|left
decl_stmt|;
comment|/* Count the number of entries on branch.  Also count the ranges.  */
while|while
condition|(
name|np
condition|)
block|{
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|np
operator|->
name|low
argument_list|,
name|np
operator|->
name|high
argument_list|)
condition|)
block|{
name|ranges
operator|++
expr_stmt|;
if|if
condition|(
name|use_cost_table
condition|)
name|cost
operator|+=
name|cost_table
index|[
name|TREE_INT_CST_LOW
argument_list|(
name|np
operator|->
name|high
argument_list|)
index|]
expr_stmt|;
block|}
if|if
condition|(
name|use_cost_table
condition|)
name|cost
operator|+=
name|cost_table
index|[
name|TREE_INT_CST_LOW
argument_list|(
name|np
operator|->
name|low
argument_list|)
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|np
operator|=
name|np
operator|->
name|right
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|2
condition|)
block|{
comment|/* Split this list if it is long enough for that to help.  */
name|npp
operator|=
name|head
expr_stmt|;
name|left
operator|=
operator|*
name|npp
expr_stmt|;
if|if
condition|(
name|use_cost_table
condition|)
block|{
comment|/* Find the place in the list that bisects the list's total cost, 		 Here I gets half the total cost.  */
name|int
name|n_moved
init|=
literal|0
decl_stmt|;
name|i
operator|=
operator|(
name|cost
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Skip nodes while their cost does not reach that amount.  */
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
operator|(
operator|*
name|npp
operator|)
operator|->
name|low
argument_list|,
operator|(
operator|*
name|npp
operator|)
operator|->
name|high
argument_list|)
condition|)
name|i
operator|-=
name|cost_table
index|[
name|TREE_INT_CST_LOW
argument_list|(
operator|(
operator|*
name|npp
operator|)
operator|->
name|high
argument_list|)
index|]
expr_stmt|;
name|i
operator|-=
name|cost_table
index|[
name|TREE_INT_CST_LOW
argument_list|(
operator|(
operator|*
name|npp
operator|)
operator|->
name|low
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
break|break;
name|npp
operator|=
operator|&
operator|(
operator|*
name|npp
operator|)
operator|->
name|right
expr_stmt|;
name|n_moved
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|n_moved
operator|==
literal|0
condition|)
block|{
comment|/* Leave this branch lopsided, but optimize left-hand 		     side and fill in `parent' fields for right-hand side.  */
name|np
operator|=
operator|*
name|head
expr_stmt|;
name|np
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|balance_case_nodes
argument_list|(
operator|&
name|np
operator|->
name|left
argument_list|,
name|np
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|np
operator|->
name|right
condition|;
name|np
operator|=
name|np
operator|->
name|right
control|)
name|np
operator|->
name|right
operator|->
name|parent
operator|=
name|np
expr_stmt|;
return|return;
block|}
block|}
comment|/* If there are just three nodes, split at the middle one.  */
elseif|else
if|if
condition|(
name|i
operator|==
literal|3
condition|)
name|npp
operator|=
operator|&
operator|(
operator|*
name|npp
operator|)
operator|->
name|right
expr_stmt|;
else|else
block|{
comment|/* Find the place in the list that bisects the list's total cost, 		 where ranges count as 2. 		 Here I gets half the total cost.  */
name|i
operator|=
operator|(
name|i
operator|+
name|ranges
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Skip nodes while their cost does not reach that amount.  */
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
operator|(
operator|*
name|npp
operator|)
operator|->
name|low
argument_list|,
operator|(
operator|*
name|npp
operator|)
operator|->
name|high
argument_list|)
condition|)
name|i
operator|--
expr_stmt|;
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
break|break;
name|npp
operator|=
operator|&
operator|(
operator|*
name|npp
operator|)
operator|->
name|right
expr_stmt|;
block|}
block|}
operator|*
name|head
operator|=
name|np
operator|=
operator|*
name|npp
expr_stmt|;
operator|*
name|npp
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|np
operator|->
name|left
operator|=
name|left
expr_stmt|;
comment|/* Optimize each of the two split parts.  */
name|balance_case_nodes
argument_list|(
operator|&
name|np
operator|->
name|left
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|balance_case_nodes
argument_list|(
operator|&
name|np
operator|->
name|right
argument_list|,
name|np
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Else leave this branch as one level, 	     but fill in `parent' fields.  */
name|np
operator|=
operator|*
name|head
expr_stmt|;
name|np
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
for|for
control|(
init|;
name|np
operator|->
name|right
condition|;
name|np
operator|=
name|np
operator|->
name|right
control|)
name|np
operator|->
name|right
operator|->
name|parent
operator|=
name|np
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Search the parent sections of the case node tree    to see if a test for the lower bound of NODE would be redundant.    INDEX_TYPE is the type of the index expression.     The instructions to generate the case decision tree are    output in the same order as nodes are processed so it is    known that if a parent node checks the range of the current    node minus one that the current node is bounded at its lower    span.  Thus the test would be redundant.  */
end_comment

begin_function
specifier|static
name|int
name|node_has_low_bound
parameter_list|(
name|node
parameter_list|,
name|index_type
parameter_list|)
name|case_node_ptr
name|node
decl_stmt|;
name|tree
name|index_type
decl_stmt|;
block|{
name|tree
name|low_minus_one
decl_stmt|;
name|case_node_ptr
name|pnode
decl_stmt|;
comment|/* If the lower bound of this node is the lowest value in the index type,      we need not test it.  */
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|node
operator|->
name|low
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|index_type
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If this node has a left branch, the value at the left must be less      than that at this node, so it cannot be bounded at the bottom and      we need not bother testing any further.  */
if|if
condition|(
name|node
operator|->
name|left
condition|)
return|return
literal|0
return|;
name|low_minus_one
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|node
operator|->
name|low
argument_list|)
argument_list|,
name|node
operator|->
name|low
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the subtraction above overflowed, we can't verify anything.      Otherwise, look for a parent that tests our value - 1.  */
if|if
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|low_minus_one
argument_list|,
name|node
operator|->
name|low
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|pnode
operator|=
name|node
operator|->
name|parent
init|;
name|pnode
condition|;
name|pnode
operator|=
name|pnode
operator|->
name|parent
control|)
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|low_minus_one
argument_list|,
name|pnode
operator|->
name|high
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Search the parent sections of the case node tree    to see if a test for the upper bound of NODE would be redundant.    INDEX_TYPE is the type of the index expression.     The instructions to generate the case decision tree are    output in the same order as nodes are processed so it is    known that if a parent node checks the range of the current    node plus one that the current node is bounded at its upper    span.  Thus the test would be redundant.  */
end_comment

begin_function
specifier|static
name|int
name|node_has_high_bound
parameter_list|(
name|node
parameter_list|,
name|index_type
parameter_list|)
name|case_node_ptr
name|node
decl_stmt|;
name|tree
name|index_type
decl_stmt|;
block|{
name|tree
name|high_plus_one
decl_stmt|;
name|case_node_ptr
name|pnode
decl_stmt|;
comment|/* If there is no upper bound, obviously no test is needed.  */
if|if
condition|(
name|TYPE_MAX_VALUE
argument_list|(
name|index_type
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* If the upper bound of this node is the highest value in the type      of the index expression, we need not test against it.  */
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|index_type
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If this node has a right branch, the value at the right must be greater      than that at this node, so it cannot be bounded at the top and      we need not bother testing any further.  */
if|if
condition|(
name|node
operator|->
name|right
condition|)
return|return
literal|0
return|;
name|high_plus_one
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|node
operator|->
name|high
argument_list|)
argument_list|,
name|node
operator|->
name|high
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the addition above overflowed, we can't verify anything.      Otherwise, look for a parent that tests our value + 1.  */
if|if
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|high_plus_one
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|pnode
operator|=
name|node
operator|->
name|parent
init|;
name|pnode
condition|;
name|pnode
operator|=
name|pnode
operator|->
name|parent
control|)
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|high_plus_one
argument_list|,
name|pnode
operator|->
name|low
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Search the parent sections of the    case node tree to see if both tests for the upper and lower    bounds of NODE would be redundant.  */
end_comment

begin_function
specifier|static
name|int
name|node_is_bounded
parameter_list|(
name|node
parameter_list|,
name|index_type
parameter_list|)
name|case_node_ptr
name|node
decl_stmt|;
name|tree
name|index_type
decl_stmt|;
block|{
return|return
operator|(
name|node_has_low_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
operator|&&
name|node_has_high_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  Emit an unconditional jump to LABEL unless it would be dead code.  */
end_comment

begin_function
specifier|static
name|void
name|emit_jump_if_reachable
parameter_list|(
name|label
parameter_list|)
name|rtx
name|label
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
operator|!=
name|BARRIER
condition|)
name|emit_jump
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit step-by-step code to select a case for the value of INDEX.    The thus generated decision tree follows the form of the    case-node binary tree NODE, whose nodes represent test conditions.    INDEX_TYPE is the type of the index of the switch.     Care is taken to prune redundant tests from the decision tree    by detecting any boundary conditions already checked by    emitted rtx.  (See node_has_high_bound, node_has_low_bound    and node_is_bounded, above.)     Where the test conditions can be shown to be redundant we emit    an unconditional jump to the target code.  As a further    optimization, the subordinates of a tree node are examined to    check for bounded nodes.  In this case conditional and/or    unconditional jumps as a result of the boundary check for the    current node are arranged to target the subordinates associated    code for out of bound conditions on the current node.     We can assume that when control reaches the code generated here,    the index value has already been compared with the parents    of this node, and determined to be on the same side of each parent    as this node is.  Thus, if this node tests for the value 51,    and a parent tested for 52, we don't need to consider    the possibility of a value greater than 51.  If another parent    tests for the value 50, then this node need not test anything.  */
end_comment

begin_function
specifier|static
name|void
name|emit_case_nodes
parameter_list|(
name|index
parameter_list|,
name|node
parameter_list|,
name|default_label
parameter_list|,
name|index_type
parameter_list|)
name|rtx
name|index
decl_stmt|;
name|case_node_ptr
name|node
decl_stmt|;
name|rtx
name|default_label
decl_stmt|;
name|tree
name|index_type
decl_stmt|;
block|{
comment|/* If INDEX has an unsigned type, we must make unsigned branches.  */
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|index_type
argument_list|)
decl_stmt|;
typedef|typedef
name|rtx
name|rtx_fn
parameter_list|()
function_decl|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|index
argument_list|)
decl_stmt|;
comment|/* See if our parents have already tested everything for us.      If they have, emit an unconditional jump for this node.  */
if|if
condition|(
name|node_is_bounded
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
condition|)
name|emit_jump
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|node
operator|->
name|low
argument_list|,
name|node
operator|->
name|high
argument_list|)
condition|)
block|{
comment|/* Node is single valued.  First see if the index expression matches 	 this node and then check our children, if any.  */
name|do_jump_if_equal
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|low
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|right
operator|!=
literal|0
operator|&&
name|node
operator|->
name|left
operator|!=
literal|0
condition|)
block|{
comment|/* This node has children on both sides. 	     Dispatch to one side or the other 	     by comparing the index value with this node's value. 	     If one subtree is bounded, check that one first, 	     so we can avoid real branches in the tree.  */
if|if
condition|(
name|node_is_bounded
argument_list|(
name|node
operator|->
name|right
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|right
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|left
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node_is_bounded
argument_list|(
name|node
operator|->
name|left
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|left
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|right
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Neither node is bounded.  First distinguish the two sides; 		 then emit the code for one side at a time.  */
name|tree
name|test_label
init|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
comment|/* See if the value is on the right.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|,
name|label_rtx
argument_list|(
name|test_label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Value must be on the left. 		 Handle the left-hand subtree.  */
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|left
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
comment|/* If left-hand subtree does nothing, 		 go to default.  */
name|emit_jump_if_reachable
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
comment|/* Code branches here for the right-hand subtree.  */
name|expand_label
argument_list|(
name|test_label
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|right
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|right
operator|!=
literal|0
operator|&&
name|node
operator|->
name|left
operator|==
literal|0
condition|)
block|{
comment|/* Here we have a right child but no left so we issue conditional 	     branch to default and process the right child.  	     Omit the conditional branch to default if we it avoid only one 	     right child; it costs too much space to save so little time.  */
if|if
condition|(
name|node
operator|->
name|right
operator|->
name|right
operator|||
name|node
operator|->
name|right
operator|->
name|left
operator|||
operator|!
name|tree_int_cst_equal
argument_list|(
name|node
operator|->
name|right
operator|->
name|low
argument_list|,
name|node
operator|->
name|right
operator|->
name|high
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|node_has_low_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
block|}
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|right
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We cannot process node->right normally 	       since we haven't ruled out the numbers less than 	       this node's value.  So handle node->right explicitly.  */
name|do_jump_if_equal
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|right
operator|->
name|low
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|right
operator|->
name|code_label
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|right
operator|==
literal|0
operator|&&
name|node
operator|->
name|left
operator|!=
literal|0
condition|)
block|{
comment|/* Just one subtree, on the left.  */
if|#
directive|if
literal|0
comment|/* The following code and comment were formerly part 	 of the condition here, but they didn't work 	 and I don't understand what the idea was.  -- rms.  */
comment|/* If our "most probable entry" is less probable 	     than the default label, emit a jump to 	     the default label using condition codes 	     already lying around.  With no right branch, 	     a branch-greater-than will get us to the default 	     label correctly.  */
block|if (use_cost_table&& cost_table[TREE_INT_CST_LOW (node->high)]< 12) 	    ;
endif|#
directive|endif
comment|/* 0 */
if|if
condition|(
name|node
operator|->
name|left
operator|->
name|left
operator|||
name|node
operator|->
name|left
operator|->
name|right
operator|||
operator|!
name|tree_int_cst_equal
argument_list|(
name|node
operator|->
name|left
operator|->
name|low
argument_list|,
name|node
operator|->
name|left
operator|->
name|high
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|node_has_high_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
block|}
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|left
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We cannot process node->left normally 	       since we haven't ruled out the numbers less than 	       this node's value.  So handle node->left explicitly.  */
name|do_jump_if_equal
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|left
operator|->
name|low
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|left
operator|->
name|code_label
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Node is a range.  These cases are very similar to those for a single 	 value, except that we do not start by testing whether this node 	 is the one to branch to.  */
if|if
condition|(
name|node
operator|->
name|right
operator|!=
literal|0
operator|&&
name|node
operator|->
name|left
operator|!=
literal|0
condition|)
block|{
comment|/* Node has subtrees on both sides. 	     If the right-hand subtree is bounded, 	     test for it first, since we can go straight there. 	     Otherwise, we need to make a branch in the control structure, 	     then handle the two subtrees.  */
name|tree
name|test_label
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|node_is_bounded
argument_list|(
name|node
operator|->
name|right
argument_list|,
name|index_type
argument_list|)
condition|)
comment|/* Right hand node is fully bounded so we can eliminate any 	       testing and branch directly to the target code.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|right
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Right hand node requires testing. 		 Branch to a label where we will handle it later.  */
name|test_label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|,
name|label_rtx
argument_list|(
name|test_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Value belongs to this node or to the left-hand subtree.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|low
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GE
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle the left-hand subtree.  */
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|left
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
comment|/* If right node had to be handled later, do that now.  */
if|if
condition|(
name|test_label
condition|)
block|{
comment|/* If the left-hand subtree fell through, 		 don't let it fall into the right-hand subtree.  */
name|emit_jump_if_reachable
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
name|expand_label
argument_list|(
name|test_label
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|right
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|right
operator|!=
literal|0
operator|&&
name|node
operator|->
name|left
operator|==
literal|0
condition|)
block|{
comment|/* Deal with values to the left of this node, 	     if they are possible.  */
if|if
condition|(
operator|!
name|node_has_low_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|low
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
block|}
comment|/* Value belongs to this node or to the right-hand subtree.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LE
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|right
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|right
operator|==
literal|0
operator|&&
name|node
operator|->
name|left
operator|!=
literal|0
condition|)
block|{
comment|/* Deal with values to the right of this node, 	     if they are possible.  */
if|if
condition|(
operator|!
name|node_has_high_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
block|}
comment|/* Value belongs to this node or to the left-hand subtree.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|low
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GE
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|left
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Node has no children so we check low and high bounds to remove 	     redundant tests.  Only one of the bounds can exist, 	     since otherwise this node is bounded--a case tested already.  */
if|if
condition|(
operator|!
name|node_has_high_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|node_has_low_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|low
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
block|}
name|emit_jump
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These routines are used by the loop unrolling code.  They copy BLOCK trees    so that the debugging info will be correct for the unrolled loop.  */
end_comment

begin_comment
comment|/* Indexed by block number, contains a pointer to the N'th block node.    Allocated by the call to identify_blocks, then released after the call   to reorder_blocks in the function unroll_block_trees.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|block_vector
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|find_loop_tree_blocks
parameter_list|()
block|{
name|tree
name|block
init|=
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|block_vector
operator|=
name|identify_blocks
argument_list|(
name|block
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|unroll_block_trees
parameter_list|()
block|{
name|tree
name|block
init|=
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|reorder_blocks
argument_list|(
name|block_vector
argument_list|,
name|block
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Release any memory allocated by identify_blocks.  */
if|if
condition|(
name|block_vector
condition|)
name|free
argument_list|(
name|block_vector
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

