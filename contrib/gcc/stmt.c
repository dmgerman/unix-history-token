begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Expands front end tree to back end RTL for GNU C-Compiler    Copyright (C) 1987, 88, 89, 92, 93, 94, 1995 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file handles the generation of rtl code from tree structure    above the level of expressions, using subroutines in exp*.c and emit-rtl.c.    It also creates the rtl expressions for parameters and auto variables    and has full responsibility for allocating stack slots.     The functions whose names start with `expand_' are called by the    parser to generate RTL instructions for various kinds of constructs.     Some control and binding constructs require calling several such    functions at different times.  For example, a simple if-then    is expanded by calling `expand_start_cond' (with the condition-expression    as argument) before parsing the then-clause and calling `expand_end_cond'    after parsing the then-clause.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"loop.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"machmode.h"
end_include

begin_include
include|#
directive|include
file|"bytecode.h"
end_include

begin_include
include|#
directive|include
file|"bc-typecd.h"
end_include

begin_include
include|#
directive|include
file|"bc-opcode.h"
end_include

begin_include
include|#
directive|include
file|"bc-optab.h"
end_include

begin_include
include|#
directive|include
file|"bc-emit.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
name|struct
name|obstack
name|stmt_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Filename and line number of last line-number note,    whether we actually emitted it or not.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|emit_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|emit_lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if within a ({...}) grouping, in which case we must    always compute a value for each expr-stmt in case it is the last one.  */
end_comment

begin_decl_stmt
name|int
name|expr_stmts_for_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Each time we expand an expression-statement,    record the expr's type and its RTL value here.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|last_expr_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|last_expr_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Each time we expand the end of a binding contour (in `expand_end_bindings')    and we emit a new NOTE_INSN_BLOCK_END note, we save a pointer to it here.    This is used by the `remember_end_note' function to record the endpoint    of each generated block in its associated BLOCK node.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_block_end_note
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of binding contours started so far in this function.  */
end_comment

begin_decl_stmt
name|int
name|block_start_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if function being compiled needs to    return the address of where it has put a structure value.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|current_function_returns_pcc_struct
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Label that will go on parm cleanup code, if any.    Jumping to this label runs cleanup code for parameters, if    such code must be run.  Following this code is the logical return label.  */
end_comment

begin_decl_stmt
specifier|extern
name|rtx
name|cleanup_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Label that will go on function epilogue.    Jumping to this label serves as a "return" instruction    on machines which require execution of the epilogue on all returns.  */
end_comment

begin_decl_stmt
specifier|extern
name|rtx
name|return_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List (chain of EXPR_LISTs) of pseudo-regs of SAVE_EXPRs.    So we can mark them all live at the end of the function, if nonopt.  */
end_comment

begin_decl_stmt
specifier|extern
name|rtx
name|save_expr_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offset to end of allocated area of stack frame.    If stack grows down, this is the address of the last stack slot allocated.    If stack grows up, this is the address for the next slot.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|frame_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Label to jump back to for tail recursion, or 0 if we have    not yet needed one for this function.  */
end_comment

begin_decl_stmt
specifier|extern
name|rtx
name|tail_recursion_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Place after which to insert the tail_recursion_label if we need one.  */
end_comment

begin_decl_stmt
specifier|extern
name|rtx
name|tail_recursion_reentry
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Location at which to save the argument pointer if it will need to be    referenced.  There are two cases where this is done: if nonlocal gotos    exist, or if vars whose is an offset from the argument pointer will be    needed by inner routines.  */
end_comment

begin_decl_stmt
specifier|extern
name|rtx
name|arg_pointer_save_area
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of all RTL_EXPRs that have insns in them.  */
end_comment

begin_decl_stmt
specifier|extern
name|tree
name|rtl_expr_chain
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Turned off because 0 seems to work just as well.  */
end_comment

begin_comment
comment|/* Cleanup lists are required for binding levels regardless of whether    that binding level has cleanups or not.  This node serves as the    cleanup list whenever an empty list is required.  */
end_comment

begin_endif
unit|static tree empty_cleanup_list;
endif|#
directive|endif
end_endif

begin_extern
extern|extern void (*interim_eh_hook
end_extern

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_escape
end_escape

begin_comment
comment|/* Functions and data structures for expanding case statements.  */
end_comment

begin_comment
comment|/* Case label structure, used to hold info on labels within case    statements.  We handle "range" labels; for a single-value label    as in C, the high and low limits are the same.     A chain of case nodes is initially maintained via the RIGHT fields    in the nodes.  Nodes with higher case values are later in the list.     Switch statements can be output in one of two forms.  A branch table    is used if there are more than a few labels and the labels are dense    within the range between the smallest and largest case value.  If a    branch table is used, no further manipulations are done with the case    node chain.     The alternative to the use of a branch table is to generate a series    of compare and jump insns.  When that is done, we use the LEFT, RIGHT,    and PARENT fields to hold a binary tree.  Initially the tree is    totally unbalanced, with everything on the right.  We balance the tree    with nodes on the left having lower case values than the parent    and nodes on the right having higher values.  We then output the tree    in order.  */
end_comment

begin_struct
struct|struct
name|case_node
block|{
name|struct
name|case_node
modifier|*
name|left
decl_stmt|;
comment|/* Left son in binary tree */
name|struct
name|case_node
modifier|*
name|right
decl_stmt|;
comment|/* Right son in binary tree; also node chain */
name|struct
name|case_node
modifier|*
name|parent
decl_stmt|;
comment|/* Parent of node in binary tree */
name|tree
name|low
decl_stmt|;
comment|/* Lowest index value for this label */
name|tree
name|high
decl_stmt|;
comment|/* Highest index value for this label */
name|tree
name|code_label
decl_stmt|;
comment|/* Label to jump to when node matches */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|case_node
name|case_node
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|case_node
modifier|*
name|case_node_ptr
typedef|;
end_typedef

begin_comment
comment|/* These are used by estimate_case_costs and balance_case_nodes.  */
end_comment

begin_comment
comment|/* This must be a signed type, and non-ANSI compilers lack signed char.  */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|cost_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|use_cost_table
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Stack of control and binding constructs we are currently inside.     These constructs begin when you call `expand_start_WHATEVER'    and end when you call `expand_end_WHATEVER'.  This stack records    info about how the construct began that tells the end-function    what to do.  It also may provide information about the construct    to alter the behavior of other constructs within the body.    For example, they may affect the behavior of C `break' and `continue'.     Each construct gets one `struct nesting' object.    All of these objects are chained through the `all' field.    `nesting_stack' points to the first object (innermost construct).    The position of an entry on `nesting_stack' is in its `depth' field.     Each type of construct has its own individual stack.    For example, loops have `loop_stack'.  Each object points to the    next object of the same type through the `next' field.     Some constructs are visible to `break' exit-statements and others    are not.  Which constructs are visible depends on the language.    Therefore, the data structure allows each construct to be visible    or not, according to the args given when the construct is started.    The construct is visible if the `exit_label' field is non-null.    In that case, the value should be a CODE_LABEL rtx.  */
end_comment

begin_struct
struct|struct
name|nesting
block|{
name|struct
name|nesting
modifier|*
name|all
decl_stmt|;
name|struct
name|nesting
modifier|*
name|next
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|rtx
name|exit_label
decl_stmt|;
union|union
block|{
comment|/* For conds (if-then and if-then-else statements).  */
struct|struct
block|{
comment|/* Label for the end of the if construct. 	     There is none if EXITFLAG was not set 	     and no `else' has been seen yet.  */
name|rtx
name|endif_label
decl_stmt|;
comment|/* Label for the end of this alternative. 	     This may be the end of the if or the next else/elseif. */
name|rtx
name|next_label
decl_stmt|;
block|}
name|cond
struct|;
comment|/* For loops.  */
struct|struct
block|{
comment|/* Label at the top of the loop; place to loop back to.  */
name|rtx
name|start_label
decl_stmt|;
comment|/* Label at the end of the whole construct.  */
name|rtx
name|end_label
decl_stmt|;
comment|/* Label before a jump that branches to the end of the whole 	     construct.  This is where destructors go if any.  */
name|rtx
name|alt_end_label
decl_stmt|;
comment|/* Label for `continue' statement to jump to; 	     this is in front of the stepper of the loop.  */
name|rtx
name|continue_label
decl_stmt|;
block|}
name|loop
struct|;
comment|/* For variable binding contours.  */
struct|struct
block|{
comment|/* Sequence number of this binding contour within the function, 	     in order of entry.  */
name|int
name|block_start_count
decl_stmt|;
comment|/* Nonzero => value to restore stack to on exit.  Complemented by 	     bc_stack_level (see below) when generating bytecodes. */
name|rtx
name|stack_level
decl_stmt|;
comment|/* The NOTE that starts this contour. 	     Used by expand_goto to check whether the destination 	     is within each contour or not.  */
name|rtx
name|first_insn
decl_stmt|;
comment|/* Innermost containing binding contour that has a stack level.  */
name|struct
name|nesting
modifier|*
name|innermost_stack_block
decl_stmt|;
comment|/* List of cleanups to be run on exit from this contour. 	     This is a list of expressions to be evaluated. 	     The TREE_PURPOSE of each link is the ..._DECL node 	     which the cleanup pertains to.  */
name|tree
name|cleanups
decl_stmt|;
comment|/* List of cleanup-lists of blocks containing this block, 	     as they were at the locus where this block appears. 	     There is an element for each containing block, 	     ordered innermost containing block first. 	     The tail of this list can be 0 (was empty_cleanup_list), 	     if all remaining elements would be empty lists. 	     The element's TREE_VALUE is the cleanup-list of that block, 	     which may be null.  */
name|tree
name|outer_cleanups
decl_stmt|;
comment|/* Chain of labels defined inside this binding contour. 	     For contours that have stack levels or cleanups.  */
name|struct
name|label_chain
modifier|*
name|label_chain
decl_stmt|;
comment|/* Number of function calls seen, as of start of this block.  */
name|int
name|function_call_count
decl_stmt|;
comment|/* Bytecode specific: stack level to restore stack to on exit.  */
name|int
name|bc_stack_level
decl_stmt|;
block|}
name|block
struct|;
comment|/* For switch (C) or case (Pascal) statements, 	 and also for dummies (see `expand_start_case_dummy').  */
struct|struct
block|{
comment|/* The insn after which the case dispatch should finally 	     be emitted.  Zero for a dummy.  */
name|rtx
name|start
decl_stmt|;
comment|/* For bytecodes, the case table is in-lined right in the code. 	     A label is needed for skipping over this block. It is only 	     used when generating bytecodes. */
name|rtx
name|skip_label
decl_stmt|;
comment|/* A list of case labels, kept in ascending order by value 	     as the list is built. 	     During expand_end_case, this list may be rearranged into a 	     nearly balanced binary tree.  */
name|struct
name|case_node
modifier|*
name|case_list
decl_stmt|;
comment|/* Label to jump to if no case matches.  */
name|tree
name|default_label
decl_stmt|;
comment|/* The expression to be dispatched on.  */
name|tree
name|index_expr
decl_stmt|;
comment|/* Type that INDEX_EXPR should be converted to.  */
name|tree
name|nominal_type
decl_stmt|;
comment|/* Number of range exprs in case statement.  */
name|int
name|num_ranges
decl_stmt|;
comment|/* Name of this kind of statement, for warnings.  */
name|char
modifier|*
name|printname
decl_stmt|;
comment|/* Nonzero if a case label has been seen in this case stmt.  */
name|char
name|seenlabel
decl_stmt|;
block|}
name|case_stmt
struct|;
block|}
name|data
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Chain of all pending binding contours.  */
end_comment

begin_decl_stmt
name|struct
name|nesting
modifier|*
name|block_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If any new stacks are added here, add them to POPSTACKS too.  */
end_comment

begin_comment
comment|/* Chain of all pending binding contours that restore stack levels    or have cleanups.  */
end_comment

begin_decl_stmt
name|struct
name|nesting
modifier|*
name|stack_block_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of all pending conditional statements.  */
end_comment

begin_decl_stmt
name|struct
name|nesting
modifier|*
name|cond_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of all pending loops.  */
end_comment

begin_decl_stmt
name|struct
name|nesting
modifier|*
name|loop_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of all pending case or switch statements.  */
end_comment

begin_decl_stmt
name|struct
name|nesting
modifier|*
name|case_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Separate chain including all of the above,    chained through the `all' field.  */
end_comment

begin_decl_stmt
name|struct
name|nesting
modifier|*
name|nesting_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of entries on nesting_stack now.  */
end_comment

begin_decl_stmt
name|int
name|nesting_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate and return a new `struct nesting'.  */
end_comment

begin_define
define|#
directive|define
name|ALLOC_NESTING
parameter_list|()
define|\
value|(struct nesting *) obstack_alloc (&stmt_obstack, sizeof (struct nesting))
end_define

begin_comment
comment|/* Pop the nesting stack element by element until we pop off    the element which is at the top of STACK.    Update all the other stacks, popping off elements from them    as we pop them from nesting_stack.  */
end_comment

begin_define
define|#
directive|define
name|POPSTACK
parameter_list|(
name|STACK
parameter_list|)
define|\
value|do { struct nesting *target = STACK;			\      struct nesting *this;				\      do { this = nesting_stack;				\ 	  if (loop_stack == this)			\ 	    loop_stack = loop_stack->next;		\ 	  if (cond_stack == this)			\ 	    cond_stack = cond_stack->next;		\ 	  if (block_stack == this)			\ 	    block_stack = block_stack->next;		\ 	  if (stack_block_stack == this)		\ 	    stack_block_stack = stack_block_stack->next; \ 	  if (case_stack == this)			\ 	    case_stack = case_stack->next;		\ 	  nesting_depth = nesting_stack->depth - 1;	\ 	  nesting_stack = this->all;			\ 	  obstack_free (&stmt_obstack, this); }		\      while (this != target); } while (0)
end_define

begin_escape
end_escape

begin_comment
comment|/* In some cases it is impossible to generate code for a forward goto    until the label definition is seen.  This happens when it may be necessary    for the goto to reset the stack pointer: we don't yet know how to do that.    So expand_goto puts an entry on this fixup list.    Each time a binding contour that resets the stack is exited,    we check each fixup.    If the target label has now been defined, we can insert the proper code.  */
end_comment

begin_struct
struct|struct
name|goto_fixup
block|{
comment|/* Points to following fixup.  */
name|struct
name|goto_fixup
modifier|*
name|next
decl_stmt|;
comment|/* Points to the insn before the jump insn.      If more code must be inserted, it goes after this insn.  */
name|rtx
name|before_jump
decl_stmt|;
comment|/* The LABEL_DECL that this jump is jumping to, or 0      for break, continue or return.  */
name|tree
name|target
decl_stmt|;
comment|/* The BLOCK for the place where this goto was found.  */
name|tree
name|context
decl_stmt|;
comment|/* The CODE_LABEL rtx that this is jumping to.  */
name|rtx
name|target_rtl
decl_stmt|;
comment|/* Number of binding contours started in current function      before the label reference.  */
name|int
name|block_start_count
decl_stmt|;
comment|/* The outermost stack level that should be restored for this jump.      Each time a binding contour that resets the stack is exited,      if the target label is *not* yet defined, this slot is updated.  */
name|rtx
name|stack_level
decl_stmt|;
comment|/* List of lists of cleanup expressions to be run by this goto.      There is one element for each block that this goto is within.      The tail of this list can be 0 (was empty_cleanup_list),      if all remaining elements would be empty.      The TREE_VALUE contains the cleanup list of that block as of the      time this goto was seen.      The TREE_ADDRESSABLE flag is 1 for a block that has been exited.  */
name|tree
name|cleanup_list_list
decl_stmt|;
comment|/* Bytecode specific members follow */
comment|/* The label that this jump is jumping to, or 0 for break, continue      or return.  */
name|struct
name|bc_label
modifier|*
name|bc_target
decl_stmt|;
comment|/* The label we use for the fixup patch */
name|struct
name|bc_label
modifier|*
name|label
decl_stmt|;
comment|/* True (non-0) if fixup has been handled */
name|int
name|bc_handled
range|:
literal|1
decl_stmt|;
comment|/* Like stack_level above, except refers to the interpreter stack */
name|int
name|bc_stack_level
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|goto_fixup
modifier|*
name|goto_fixup_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Within any binding contour that must restore a stack level,    all labels are recorded with a chain of these structures.  */
end_comment

begin_struct
struct|struct
name|label_chain
block|{
comment|/* Points to following fixup.  */
name|struct
name|label_chain
modifier|*
name|next
decl_stmt|;
name|tree
name|label
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|expand_goto_internal
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bc_expand_goto_internal
name|PROTO
argument_list|(
operator|(
expr|enum
name|bytecode_opcode
operator|,
expr|struct
name|bc_label
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|expand_fixup
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bc_expand_fixup
name|PROTO
argument_list|(
operator|(
expr|enum
name|bytecode_opcode
operator|,
expr|struct
name|bc_label
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_gotos
name|PROTO
argument_list|(
operator|(
expr|struct
name|nesting
operator|*
operator|,
name|rtx
operator|,
name|tree
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bc_fixup_gotos
name|PROTO
argument_list|(
operator|(
expr|struct
name|nesting
operator|*
operator|,
name|int
operator|,
name|tree
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bc_expand_start_cond
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bc_expand_end_cond
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bc_expand_start_else
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bc_expand_end_loop
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bc_expand_end_bindings
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bc_expand_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bc_expand_variable_local_init
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bc_expand_decl_init
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_null_return_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_value_return
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tail_recursion_args
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_cleanups
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bc_expand_start_case
name|PROTO
argument_list|(
operator|(
expr|struct
name|nesting
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bc_pushcase
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bc_check_for_full_enumeration_handling
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bc_expand_end_case
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_jump_if_equal
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|estimate_case_costs
name|PROTO
argument_list|(
operator|(
name|case_node_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|group_case_nodes
name|PROTO
argument_list|(
operator|(
name|case_node_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|balance_case_nodes
name|PROTO
argument_list|(
operator|(
name|case_node_ptr
operator|*
operator|,
name|case_node_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|node_has_low_bound
name|PROTO
argument_list|(
operator|(
name|case_node_ptr
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|node_has_high_bound
name|PROTO
argument_list|(
operator|(
name|case_node_ptr
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|node_is_bounded
name|PROTO
argument_list|(
operator|(
name|case_node_ptr
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_jump_if_reachable
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_case_nodes
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|case_node_ptr
operator|,
name|rtx
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|rtx
name|bc_allocate_local
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|rtx
name|bc_allocate_variable_array
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_function
name|void
name|init_stmt
parameter_list|()
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|stmt_obstack
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|empty_cleanup_list = build_tree_list (NULL_TREE, NULL_TREE);
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|init_stmt_for_function
parameter_list|()
block|{
comment|/* We are not currently within any block, conditional, loop or case.  */
name|block_stack
operator|=
literal|0
expr_stmt|;
name|stack_block_stack
operator|=
literal|0
expr_stmt|;
name|loop_stack
operator|=
literal|0
expr_stmt|;
name|case_stack
operator|=
literal|0
expr_stmt|;
name|cond_stack
operator|=
literal|0
expr_stmt|;
name|nesting_stack
operator|=
literal|0
expr_stmt|;
name|nesting_depth
operator|=
literal|0
expr_stmt|;
name|block_start_count
operator|=
literal|0
expr_stmt|;
comment|/* No gotos have been expanded yet.  */
name|goto_fixup_chain
operator|=
literal|0
expr_stmt|;
comment|/* We are not processing a ({...}) grouping.  */
name|expr_stmts_for_value
operator|=
literal|0
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|save_stmt_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|p
operator|->
name|block_stack
operator|=
name|block_stack
expr_stmt|;
name|p
operator|->
name|stack_block_stack
operator|=
name|stack_block_stack
expr_stmt|;
name|p
operator|->
name|cond_stack
operator|=
name|cond_stack
expr_stmt|;
name|p
operator|->
name|loop_stack
operator|=
name|loop_stack
expr_stmt|;
name|p
operator|->
name|case_stack
operator|=
name|case_stack
expr_stmt|;
name|p
operator|->
name|nesting_stack
operator|=
name|nesting_stack
expr_stmt|;
name|p
operator|->
name|nesting_depth
operator|=
name|nesting_depth
expr_stmt|;
name|p
operator|->
name|block_start_count
operator|=
name|block_start_count
expr_stmt|;
name|p
operator|->
name|last_expr_type
operator|=
name|last_expr_type
expr_stmt|;
name|p
operator|->
name|last_expr_value
operator|=
name|last_expr_value
expr_stmt|;
name|p
operator|->
name|expr_stmts_for_value
operator|=
name|expr_stmts_for_value
expr_stmt|;
name|p
operator|->
name|emit_filename
operator|=
name|emit_filename
expr_stmt|;
name|p
operator|->
name|emit_lineno
operator|=
name|emit_lineno
expr_stmt|;
name|p
operator|->
name|goto_fixup_chain
operator|=
name|goto_fixup_chain
expr_stmt|;
block|}
end_function

begin_function
name|void
name|restore_stmt_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|block_stack
operator|=
name|p
operator|->
name|block_stack
expr_stmt|;
name|stack_block_stack
operator|=
name|p
operator|->
name|stack_block_stack
expr_stmt|;
name|cond_stack
operator|=
name|p
operator|->
name|cond_stack
expr_stmt|;
name|loop_stack
operator|=
name|p
operator|->
name|loop_stack
expr_stmt|;
name|case_stack
operator|=
name|p
operator|->
name|case_stack
expr_stmt|;
name|nesting_stack
operator|=
name|p
operator|->
name|nesting_stack
expr_stmt|;
name|nesting_depth
operator|=
name|p
operator|->
name|nesting_depth
expr_stmt|;
name|block_start_count
operator|=
name|p
operator|->
name|block_start_count
expr_stmt|;
name|last_expr_type
operator|=
name|p
operator|->
name|last_expr_type
expr_stmt|;
name|last_expr_value
operator|=
name|p
operator|->
name|last_expr_value
expr_stmt|;
name|expr_stmts_for_value
operator|=
name|p
operator|->
name|expr_stmts_for_value
expr_stmt|;
name|emit_filename
operator|=
name|p
operator|->
name|emit_filename
expr_stmt|;
name|emit_lineno
operator|=
name|p
operator|->
name|emit_lineno
expr_stmt|;
name|goto_fixup_chain
operator|=
name|p
operator|->
name|goto_fixup_chain
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit a no-op instruction.  */
end_comment

begin_function
name|void
name|emit_nop
parameter_list|()
block|{
name|rtx
name|last_insn
decl_stmt|;
if|if
condition|(
operator|!
name|output_bytecode
condition|)
block|{
name|last_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|optimize
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|last_insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
operator|(
name|GET_CODE
argument_list|(
name|last_insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|prev_real_insn
argument_list|(
name|last_insn
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
name|emit_insn
argument_list|(
name|gen_nop
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the rtx-label that corresponds to a LABEL_DECL,    creating it if necessary.  */
end_comment

begin_function
name|rtx
name|label_rtx
parameter_list|(
name|label
parameter_list|)
name|tree
name|label
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|LABEL_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|DECL_RTL
argument_list|(
name|label
argument_list|)
condition|)
return|return
name|DECL_RTL
argument_list|(
name|label
argument_list|)
return|;
return|return
name|DECL_RTL
argument_list|(
name|label
argument_list|)
operator|=
name|gen_label_rtx
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Add an unconditional jump to LABEL as the next sequential instruction.  */
end_comment

begin_function
name|void
name|emit_jump
parameter_list|(
name|label
parameter_list|)
name|rtx
name|label
decl_stmt|;
block|{
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit code to jump to the address    specified by the pointer expression EXP.  */
end_comment

begin_function
name|void
name|expand_computed_goto
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|bc_expand_expr
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|bc_emit_instruction
argument_list|(
name|jumpP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|x
init|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
name|x
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_queue
argument_list|()
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_indirect_jump
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle goto statements and the labels that they can go to.  */
end_comment

begin_comment
comment|/* Specify the location in the RTL code of a label LABEL,    which is a LABEL_DECL tree node.     This is used for the kind of label that the user can jump to with a    goto statement, and for alternatives of a switch or case statement.    RTL labels generated for loops and conditionals don't go through here;    they are generated directly at the RTL level, by other functions below.     Note that this has nothing to do with defining label *names*.    Languages vary in how they do that and what that even means.  */
end_comment

begin_function
name|void
name|expand_label
parameter_list|(
name|label
parameter_list|)
name|tree
name|label
decl_stmt|;
block|{
name|struct
name|label_chain
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_RTL
argument_list|(
name|label
argument_list|)
condition|)
name|DECL_RTL
argument_list|(
name|label
argument_list|)
operator|=
name|bc_gen_rtx
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|bc_get_bytecode_label
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bc_emit_bytecode_labeldef
argument_list|(
name|BYTECODE_BC_LABEL
argument_list|(
name|DECL_RTL
argument_list|(
name|label
argument_list|)
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"multiply defined label"
argument_list|)
expr_stmt|;
return|return;
block|}
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label_rtx
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|label
argument_list|)
condition|)
name|LABEL_NAME
argument_list|(
name|DECL_RTL
argument_list|(
name|label
argument_list|)
argument_list|)
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack_block_stack
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
operator|(
expr|struct
name|label_chain
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|label_chain
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|stack_block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|label_chain
expr_stmt|;
name|stack_block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|label_chain
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|label
operator|=
name|label
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Declare that LABEL (a LABEL_DECL) may be used for nonlocal gotos    from nested functions.  */
end_comment

begin_function
name|void
name|declare_nonlocal_label
parameter_list|(
name|label
parameter_list|)
name|tree
name|label
decl_stmt|;
block|{
name|nonlocal_labels
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|label
argument_list|,
name|nonlocal_labels
argument_list|)
expr_stmt|;
name|LABEL_PRESERVE_P
argument_list|(
name|label_rtx
argument_list|(
name|label
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nonlocal_goto_handler_slot
operator|==
literal|0
condition|)
block|{
name|nonlocal_goto_handler_slot
operator|=
name|assign_stack_local
argument_list|(
name|Pmode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_stack_save
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
operator|&
name|nonlocal_goto_stack_level
argument_list|,
name|PREV_INSN
argument_list|(
name|tail_recursion_reentry
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate RTL code for a `goto' statement with target label LABEL.    LABEL should be a LABEL_DECL tree node that was or will later be    defined with `expand_label'.  */
end_comment

begin_function
name|void
name|expand_goto
parameter_list|(
name|label
parameter_list|)
name|tree
name|label
decl_stmt|;
block|{
name|tree
name|context
decl_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|expand_goto_internal
argument_list|(
name|label
argument_list|,
name|label_rtx
argument_list|(
name|label
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check for a nonlocal goto to a containing function.  */
name|context
operator|=
name|decl_function_context
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|!=
literal|0
operator|&&
name|context
operator|!=
name|current_function_decl
condition|)
block|{
name|struct
name|function
modifier|*
name|p
init|=
name|find_function_data
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|rtx
name|label_ref
init|=
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|Pmode
argument_list|,
name|label_rtx
argument_list|(
name|label
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|p
operator|->
name|has_nonlocal_label
operator|=
literal|1
expr_stmt|;
name|current_function_has_nonlocal_goto
operator|=
literal|1
expr_stmt|;
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|label_ref
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Copy the rtl for the slots so that they won't be shared in 	 case the virtual stack vars register gets instantiated differently 	 in the parent than in the child.  */
if|#
directive|if
name|HAVE_nonlocal_goto
if|if
condition|(
name|HAVE_nonlocal_goto
condition|)
name|emit_insn
argument_list|(
name|gen_nonlocal_goto
argument_list|(
name|lookup_static_chain
argument_list|(
name|label
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|p
operator|->
name|nonlocal_goto_handler_slot
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|p
operator|->
name|nonlocal_goto_stack_level
argument_list|)
argument_list|,
name|label_ref
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|rtx
name|addr
decl_stmt|;
comment|/* Restore frame pointer for containing function. 	     This sets the actual hard register used for the frame pointer 	     to the location of the function's incoming static chain info. 	     The non-local goto handler will then adjust it to contain the 	     proper value and reload the argument pointer, if needed.  */
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|lookup_static_chain
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We have now loaded the frame pointer hardware register with 	     the address of that corresponds to the start of the virtual 	     stack vars.  So replace virtual_stack_vars_rtx in all 	     addresses we use with stack_pointer_rtx.  */
comment|/* Get addr of containing function's current nonlocal goto handler, 	     which will do any cleanups and then jump to the label.  */
name|addr
operator|=
name|copy_rtx
argument_list|(
name|p
operator|->
name|nonlocal_goto_handler_slot
argument_list|)
expr_stmt|;
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|replace_rtx
argument_list|(
name|addr
argument_list|,
name|virtual_stack_vars_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore the stack pointer.  Note this uses fp just restored.  */
name|addr
operator|=
name|p
operator|->
name|nonlocal_goto_stack_level
expr_stmt|;
if|if
condition|(
name|addr
condition|)
name|addr
operator|=
name|replace_rtx
argument_list|(
name|copy_rtx
argument_list|(
name|addr
argument_list|)
argument_list|,
name|virtual_stack_vars_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
name|emit_stack_restore
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
name|addr
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Put in the static chain register the nonlocal label address.  */
name|emit_move_insn
argument_list|(
name|static_chain_rtx
argument_list|,
name|label_ref
argument_list|)
expr_stmt|;
comment|/* USE of hard_frame_pointer_rtx added for consistency; not clear if 	     really needed.  */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|static_chain_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_indirect_jump
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|expand_goto_internal
argument_list|(
name|label
argument_list|,
name|label_rtx
argument_list|(
name|label
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL code for a `goto' statement with target label BODY.    LABEL should be a LABEL_REF.    LAST_INSN, if non-0, is the rtx we should consider as the last    insn emitted (for the purposes of cleaning up a return).  */
end_comment

begin_function
specifier|static
name|void
name|expand_goto_internal
parameter_list|(
name|body
parameter_list|,
name|label
parameter_list|,
name|last_insn
parameter_list|)
name|tree
name|body
decl_stmt|;
name|rtx
name|label
decl_stmt|;
name|rtx
name|last_insn
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|block
decl_stmt|;
name|rtx
name|stack_level
init|=
literal|0
decl_stmt|;
comment|/* NOTICE!  If a bytecode instruction other than `jump' is needed,      then the caller has to call bc_expand_goto_internal()      directly. This is rather an exceptional case, and there aren't      that many places where this is necessary. */
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|expand_goto_internal
argument_list|(
name|body
argument_list|,
name|label
argument_list|,
name|last_insn
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If label has already been defined, we can tell now      whether and how we must alter the stack level.  */
if|if
condition|(
name|PREV_INSN
argument_list|(
name|label
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Find the innermost pending block that contains the label. 	 (Check containment by comparing insn-uids.) 	 Then restore the outermost stack level within that block, 	 and do cleanups of all blocks contained in it.  */
for|for
control|(
name|block
operator|=
name|block_stack
init|;
name|block
condition|;
name|block
operator|=
name|block
operator|->
name|next
control|)
block|{
if|if
condition|(
name|INSN_UID
argument_list|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
argument_list|)
operator|<
name|INSN_UID
argument_list|(
name|label
argument_list|)
condition|)
break|break;
if|if
condition|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|!=
literal|0
condition|)
name|stack_level
operator|=
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
expr_stmt|;
comment|/* Execute the cleanups for blocks we are exiting.  */
if|if
condition|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|!=
literal|0
condition|)
block|{
name|expand_cleanups
argument_list|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stack_level
condition|)
block|{
comment|/* Ensure stack adjust isn't done by emit_jump, as this would clobber 	     the stack pointer.  This one should be deleted as dead by flow. */
name|clear_pending_stack_adjust
argument_list|()
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_stack_restore
argument_list|(
name|SAVE_BLOCK
argument_list|,
name|stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|body
operator|!=
literal|0
operator|&&
name|DECL_TOO_LATE
argument_list|(
name|body
argument_list|)
condition|)
name|error
argument_list|(
literal|"jump to `%s' invalidly jumps into binding contour"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Label not yet defined: may need to put this goto      on the fixup list.  */
elseif|else
if|if
condition|(
operator|!
name|expand_fixup
argument_list|(
name|body
argument_list|,
name|label
argument_list|,
name|last_insn
argument_list|)
condition|)
block|{
comment|/* No fixup needed.  Record that the label is the target 	 of at least one goto that has no fixup.  */
if|if
condition|(
name|body
operator|!=
literal|0
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|body
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|emit_jump
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate a jump with OPCODE to the given bytecode LABEL which is    found within BODY. */
end_comment

begin_function
specifier|static
name|void
name|bc_expand_goto_internal
parameter_list|(
name|opcode
parameter_list|,
name|label
parameter_list|,
name|body
parameter_list|)
name|enum
name|bytecode_opcode
name|opcode
decl_stmt|;
name|struct
name|bc_label
modifier|*
name|label
decl_stmt|;
name|tree
name|body
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|block
decl_stmt|;
name|int
name|stack_level
init|=
operator|-
literal|1
decl_stmt|;
comment|/* If the label is defined, adjust the stack as necessary.      If it's not defined, we have to push the reference on the      fixup list. */
if|if
condition|(
name|label
operator|->
name|defined
condition|)
block|{
comment|/* Find the innermost pending block that contains the label. 	 (Check containment by comparing bytecode uids.)  Then restore the 	 outermost stack level within that block.  */
for|for
control|(
name|block
operator|=
name|block_stack
init|;
name|block
condition|;
name|block
operator|=
name|block
operator|->
name|next
control|)
block|{
if|if
condition|(
name|BYTECODE_BC_LABEL
argument_list|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
argument_list|)
operator|->
name|uid
operator|<
name|label
operator|->
name|uid
condition|)
break|break;
if|if
condition|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|bc_stack_level
condition|)
name|stack_level
operator|=
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|bc_stack_level
expr_stmt|;
comment|/* Execute the cleanups for blocks we are exiting.  */
if|if
condition|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|!=
literal|0
condition|)
block|{
name|expand_cleanups
argument_list|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Restore the stack level. If we need to adjust the stack, we 	 must do so after the jump, since the jump may depend on 	 what's on the stack.  Thus, any stack-modifying conditional 	 jumps (these are the only ones that rely on what's on the 	 stack) go into the fixup list. */
if|if
condition|(
name|stack_level
operator|>=
literal|0
operator|&&
name|stack_depth
operator|!=
name|stack_level
operator|&&
name|opcode
operator|!=
name|jump
condition|)
name|bc_expand_fixup
argument_list|(
name|opcode
argument_list|,
name|label
argument_list|,
name|stack_level
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|stack_level
operator|>=
literal|0
condition|)
name|bc_adjust_stack
argument_list|(
name|stack_depth
operator|-
name|stack_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|body
operator|&&
name|DECL_BIT_FIELD
argument_list|(
name|body
argument_list|)
condition|)
name|error
argument_list|(
literal|"jump to `%s' invalidly jumps into binding contour"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Emit immediate jump */
name|bc_emit_bytecode
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|bc_emit_bytecode_labelref
argument_list|(
name|label
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PRINT_CODE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
comment|/* Put goto in the fixup list */
name|bc_expand_fixup
argument_list|(
name|opcode
argument_list|,
name|label
argument_list|,
name|stack_level
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate if necessary a fixup for a goto    whose target label in tree structure (if any) is TREE_LABEL    and whose target in rtl is RTL_LABEL.     If LAST_INSN is nonzero, we pretend that the jump appears    after insn LAST_INSN instead of at the current point in the insn stream.     The fixup will be used later to insert insns just before the goto.    Those insns will restore the stack level as appropriate for the    target label, and will (in the case of C++) also invoke any object    destructors which have to be invoked when we exit the scopes which    are exited by the goto.     Value is nonzero if a fixup is made.  */
end_comment

begin_function
specifier|static
name|int
name|expand_fixup
parameter_list|(
name|tree_label
parameter_list|,
name|rtl_label
parameter_list|,
name|last_insn
parameter_list|)
name|tree
name|tree_label
decl_stmt|;
name|rtx
name|rtl_label
decl_stmt|;
name|rtx
name|last_insn
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|block
decl_stmt|,
modifier|*
name|end_block
decl_stmt|;
comment|/* See if we can recognize which block the label will be output in.      This is possible in some very common cases.      If we succeed, set END_BLOCK to that block.      Otherwise, set it to 0.  */
if|if
condition|(
name|cond_stack
operator|&&
operator|(
name|rtl_label
operator|==
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
operator|||
name|rtl_label
operator|==
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
operator|)
condition|)
name|end_block
operator|=
name|cond_stack
expr_stmt|;
comment|/* If we are in a loop, recognize certain labels which      are likely targets.  This reduces the number of fixups      we need to create.  */
elseif|else
if|if
condition|(
name|loop_stack
operator|&&
operator|(
name|rtl_label
operator|==
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
operator|||
name|rtl_label
operator|==
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
operator|||
name|rtl_label
operator|==
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|continue_label
operator|)
condition|)
name|end_block
operator|=
name|loop_stack
expr_stmt|;
else|else
name|end_block
operator|=
literal|0
expr_stmt|;
comment|/* Now set END_BLOCK to the binding level to which we will return.  */
if|if
condition|(
name|end_block
condition|)
block|{
name|struct
name|nesting
modifier|*
name|next_block
init|=
name|end_block
operator|->
name|all
decl_stmt|;
name|block
operator|=
name|block_stack
expr_stmt|;
comment|/* First see if the END_BLOCK is inside the innermost binding level. 	 If so, then no cleanups or stack levels are relevant.  */
while|while
condition|(
name|next_block
operator|&&
name|next_block
operator|!=
name|block
condition|)
name|next_block
operator|=
name|next_block
operator|->
name|all
expr_stmt|;
if|if
condition|(
name|next_block
condition|)
return|return
literal|0
return|;
comment|/* Otherwise, set END_BLOCK to the innermost binding level 	 which is outside the relevant control-structure nesting.  */
name|next_block
operator|=
name|block_stack
operator|->
name|next
expr_stmt|;
for|for
control|(
name|block
operator|=
name|block_stack
init|;
name|block
operator|!=
name|end_block
condition|;
name|block
operator|=
name|block
operator|->
name|all
control|)
if|if
condition|(
name|block
operator|==
name|next_block
condition|)
name|next_block
operator|=
name|next_block
operator|->
name|next
expr_stmt|;
name|end_block
operator|=
name|next_block
expr_stmt|;
block|}
comment|/* Does any containing block have a stack level or cleanups?      If not, no fixup is needed, and that is the normal case      (the only case, for standard C).  */
for|for
control|(
name|block
operator|=
name|block_stack
init|;
name|block
operator|!=
name|end_block
condition|;
name|block
operator|=
name|block
operator|->
name|next
control|)
if|if
condition|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|!=
literal|0
operator|||
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|block
operator|!=
name|end_block
condition|)
block|{
comment|/* Ok, a fixup is needed.  Add a fixup to the list of such.  */
name|struct
name|goto_fixup
modifier|*
name|fixup
init|=
operator|(
expr|struct
name|goto_fixup
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|goto_fixup
argument_list|)
argument_list|)
decl_stmt|;
comment|/* In case an old stack level is restored, make sure that comes 	 after any pending stack adjust.  */
comment|/* ?? If the fixup isn't to come at the present position, 	 doing the stack adjust here isn't useful.  Doing it with our 	 settings at that location isn't useful either.  Let's hope 	 someone does it!  */
if|if
condition|(
name|last_insn
operator|==
literal|0
condition|)
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|fixup
operator|->
name|target
operator|=
name|tree_label
expr_stmt|;
name|fixup
operator|->
name|target_rtl
operator|=
name|rtl_label
expr_stmt|;
comment|/* Create a BLOCK node and a corresponding matched set of 	 NOTE_INSN_BEGIN_BLOCK and NOTE_INSN_END_BLOCK notes at 	 this point.  The notes will encapsulate any and all fixup 	 code which we might later insert at this point in the insn 	 stream.  Also, the BLOCK node will be the parent (i.e. the 	 `SUPERBLOCK') of any other BLOCK nodes which we might create 	 later on when we are expanding the fixup code.  */
block|{
specifier|register
name|rtx
name|original_before_jump
init|=
name|last_insn
condition|?
name|last_insn
else|:
name|get_last_insn
argument_list|()
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fixup
operator|->
name|before_jump
operator|=
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_BLOCK_BEG
argument_list|)
expr_stmt|;
name|last_block_end_note
operator|=
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_BLOCK_END
argument_list|)
expr_stmt|;
name|fixup
operator|->
name|context
operator|=
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Create the BLOCK node now! */
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_after
argument_list|(
name|fixup
operator|->
name|before_jump
argument_list|,
name|original_before_jump
argument_list|)
expr_stmt|;
block|}
name|fixup
operator|->
name|block_start_count
operator|=
name|block_start_count
expr_stmt|;
name|fixup
operator|->
name|stack_level
operator|=
literal|0
expr_stmt|;
name|fixup
operator|->
name|cleanup_list_list
operator|=
operator|(
operator|(
operator|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
if|#
directive|if
literal|0
expr|&& block->data.block.outer_cleanups != empty_cleanup_list
endif|#
directive|endif
operator|)
operator|||
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|)
condition|?
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|,
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|fixup
operator|->
name|next
operator|=
name|goto_fixup_chain
expr_stmt|;
name|goto_fixup_chain
operator|=
name|fixup
expr_stmt|;
block|}
return|return
name|block
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Generate bytecode jump with OPCODE to a fixup routine that links to LABEL.    Make the fixup restore the stack level to STACK_LEVEL.  */
end_comment

begin_function
specifier|static
name|void
name|bc_expand_fixup
parameter_list|(
name|opcode
parameter_list|,
name|label
parameter_list|,
name|stack_level
parameter_list|)
name|enum
name|bytecode_opcode
name|opcode
decl_stmt|;
name|struct
name|bc_label
modifier|*
name|label
decl_stmt|;
name|int
name|stack_level
decl_stmt|;
block|{
name|struct
name|goto_fixup
modifier|*
name|fixup
init|=
operator|(
expr|struct
name|goto_fixup
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|goto_fixup
argument_list|)
argument_list|)
decl_stmt|;
name|fixup
operator|->
name|label
operator|=
name|bc_get_bytecode_label
argument_list|()
expr_stmt|;
name|fixup
operator|->
name|bc_target
operator|=
name|label
expr_stmt|;
name|fixup
operator|->
name|bc_stack_level
operator|=
name|stack_level
expr_stmt|;
name|fixup
operator|->
name|bc_handled
operator|=
name|FALSE
expr_stmt|;
name|fixup
operator|->
name|next
operator|=
name|goto_fixup_chain
expr_stmt|;
name|goto_fixup_chain
operator|=
name|fixup
expr_stmt|;
comment|/* Insert a jump to the fixup code */
name|bc_emit_bytecode
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|bc_emit_bytecode_labelref
argument_list|(
name|fixup
operator|->
name|label
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PRINT_CODE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand any needed fixups in the outputmost binding level of the    function.  FIRST_INSN is the first insn in the function.  */
end_comment

begin_function
name|void
name|expand_fixups
parameter_list|(
name|first_insn
parameter_list|)
name|rtx
name|first_insn
decl_stmt|;
block|{
name|fixup_gotos
argument_list|(
name|NULL_PTR
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_TREE
argument_list|,
name|first_insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When exiting a binding contour, process all pending gotos requiring fixups.    THISBLOCK is the structure that describes the block being exited.    STACK_LEVEL is the rtx for the stack level to restore exiting this contour.    CLEANUP_LIST is a list of expressions to evaluate on exiting this contour.    FIRST_INSN is the insn that began this contour.     Gotos that jump out of this contour must restore the    stack level and do the cleanups before actually jumping.     DONT_JUMP_IN nonzero means report error there is a jump into this    contour from before the beginning of the contour.    This is also done if STACK_LEVEL is nonzero.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_gotos
parameter_list|(
name|thisblock
parameter_list|,
name|stack_level
parameter_list|,
name|cleanup_list
parameter_list|,
name|first_insn
parameter_list|,
name|dont_jump_in
parameter_list|)
name|struct
name|nesting
modifier|*
name|thisblock
decl_stmt|;
name|rtx
name|stack_level
decl_stmt|;
name|tree
name|cleanup_list
decl_stmt|;
name|rtx
name|first_insn
decl_stmt|;
name|int
name|dont_jump_in
decl_stmt|;
block|{
specifier|register
name|struct
name|goto_fixup
modifier|*
name|f
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
block|{
comment|/* ??? The second arg is the bc stack level, which is not the same 	 as STACK_LEVEL.  I have no idea what should go here, so I'll 	 just pass 0.  */
name|bc_fixup_gotos
argument_list|(
name|thisblock
argument_list|,
literal|0
argument_list|,
name|cleanup_list
argument_list|,
name|first_insn
argument_list|,
name|dont_jump_in
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* F is the fixup we are considering; PREV is the previous one.  */
comment|/* We run this loop in two passes so that cleanups of exited blocks      are run first, and blocks that are exited are marked so      afterwards.  */
for|for
control|(
name|prev
operator|=
literal|0
operator|,
name|f
operator|=
name|goto_fixup_chain
init|;
name|f
condition|;
name|prev
operator|=
name|f
operator|,
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
comment|/* Test for a fixup that is inactive because it is already handled.  */
if|if
condition|(
name|f
operator|->
name|before_jump
operator|==
literal|0
condition|)
block|{
comment|/* Delete inactive fixup from the chain, if that is easy to do.  */
if|if
condition|(
name|prev
operator|!=
literal|0
condition|)
name|prev
operator|->
name|next
operator|=
name|f
operator|->
name|next
expr_stmt|;
block|}
comment|/* Has this fixup's target label been defined? 	 If so, we can finalize it.  */
elseif|else
if|if
condition|(
name|PREV_INSN
argument_list|(
name|f
operator|->
name|target_rtl
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|register
name|rtx
name|cleanup_insns
decl_stmt|;
comment|/* Get the first non-label after the label 	     this goto jumps to.  If that's before this scope begins, 	     we don't have a jump into the scope.  */
name|rtx
name|after_label
init|=
name|f
operator|->
name|target_rtl
decl_stmt|;
while|while
condition|(
name|after_label
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|after_label
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|after_label
operator|=
name|NEXT_INSN
argument_list|(
name|after_label
argument_list|)
expr_stmt|;
comment|/* If this fixup jumped into this contour from before the beginning 	     of this contour, report an error.  */
comment|/* ??? Bug: this does not detect jumping in through intermediate 	     blocks that have stack levels or cleanups. 	     It detects only a problem with the innermost block 	     around the label.  */
if|if
condition|(
name|f
operator|->
name|target
operator|!=
literal|0
operator|&&
operator|(
name|dont_jump_in
operator|||
name|stack_level
operator|||
name|cleanup_list
operator|)
comment|/* If AFTER_LABEL is 0, it means the jump goes to the end 		 of the rtl, which means it jumps into this scope.  */
operator|&&
operator|(
name|after_label
operator|==
literal|0
operator|||
name|INSN_UID
argument_list|(
name|first_insn
argument_list|)
operator|<
name|INSN_UID
argument_list|(
name|after_label
argument_list|)
operator|)
operator|&&
name|INSN_UID
argument_list|(
name|first_insn
argument_list|)
operator|>
name|INSN_UID
argument_list|(
name|f
operator|->
name|before_jump
argument_list|)
operator|&&
operator|!
name|DECL_REGISTER
argument_list|(
name|f
operator|->
name|target
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|f
operator|->
name|target
argument_list|,
literal|"label `%s' used before containing binding contour"
argument_list|)
expr_stmt|;
comment|/* Prevent multiple errors for one label.  */
name|DECL_REGISTER
argument_list|(
name|f
operator|->
name|target
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We will expand the cleanups into a sequence of their own and 	     then later on we will attach this new sequence to the insn 	     stream just ahead of the actual jump insn.  */
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Temporarily restore the lexical context where we will 	     logically be inserting the fixup code.  We do this for the 	     sake of getting the debugging information right.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|set_block
argument_list|(
name|f
operator|->
name|context
argument_list|)
expr_stmt|;
comment|/* Expand the cleanups for blocks this jump exits.  */
if|if
condition|(
name|f
operator|->
name|cleanup_list_list
condition|)
block|{
name|tree
name|lists
decl_stmt|;
for|for
control|(
name|lists
operator|=
name|f
operator|->
name|cleanup_list_list
init|;
name|lists
condition|;
name|lists
operator|=
name|TREE_CHAIN
argument_list|(
name|lists
argument_list|)
control|)
comment|/* Marked elements correspond to blocks that have been closed. 		   Do their cleanups.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|lists
argument_list|)
operator|&&
name|TREE_VALUE
argument_list|(
name|lists
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|expand_cleanups
argument_list|(
name|TREE_VALUE
argument_list|(
name|lists
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Pop any pushes done in the cleanups, 		       in case function is about to return.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Restore stack level for the biggest contour that this 	     jump jumps out of.  */
if|if
condition|(
name|f
operator|->
name|stack_level
condition|)
name|emit_stack_restore
argument_list|(
name|SAVE_BLOCK
argument_list|,
name|f
operator|->
name|stack_level
argument_list|,
name|f
operator|->
name|before_jump
argument_list|)
expr_stmt|;
comment|/* Finish up the sequence containing the insns which implement the 	     necessary cleanups, and then attach that whole sequence to the 	     insn stream just ahead of the actual jump insn.  Attaching it 	     at that point insures that any cleanups which are in fact 	     implicit C++ object destructions (which must be executed upon 	     leaving the block) appear (to the debugger) to be taking place 	     in an area of the generated code where the object(s) being 	     destructed are still "in scope".  */
name|cleanup_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_after
argument_list|(
name|cleanup_insns
argument_list|,
name|f
operator|->
name|before_jump
argument_list|)
expr_stmt|;
name|f
operator|->
name|before_jump
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* For any still-undefined labels, do the cleanups for this block now.      We must do this now since items in the cleanup list may go out      of scope when the block ends. */
for|for
control|(
name|prev
operator|=
literal|0
operator|,
name|f
operator|=
name|goto_fixup_chain
init|;
name|f
condition|;
name|prev
operator|=
name|f
operator|,
name|f
operator|=
name|f
operator|->
name|next
control|)
if|if
condition|(
name|f
operator|->
name|before_jump
operator|!=
literal|0
operator|&&
name|PREV_INSN
argument_list|(
name|f
operator|->
name|target_rtl
argument_list|)
operator|==
literal|0
comment|/* Label has still not appeared.  If we are exiting a block with 	   a stack level to restore, that started before the fixup, 	   mark this stack level as needing restoration 	   when the fixup is later finalized.   */
operator|&&
name|thisblock
operator|!=
literal|0
comment|/* Note: if THISBLOCK == 0 and we have a label that hasn't appeared, it 	   means the label is undefined.  That's erroneous, but possible.  */
operator|&&
operator|(
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|block_start_count
operator|<=
name|f
operator|->
name|block_start_count
operator|)
condition|)
block|{
name|tree
name|lists
init|=
name|f
operator|->
name|cleanup_list_list
decl_stmt|;
name|rtx
name|cleanup_insns
decl_stmt|;
for|for
control|(
init|;
name|lists
condition|;
name|lists
operator|=
name|TREE_CHAIN
argument_list|(
name|lists
argument_list|)
control|)
comment|/* If the following elt. corresponds to our containing block 	     then the elt. must be for this block.  */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|lists
argument_list|)
operator|==
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|set_block
argument_list|(
name|f
operator|->
name|context
argument_list|)
expr_stmt|;
name|expand_cleanups
argument_list|(
name|TREE_VALUE
argument_list|(
name|lists
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|cleanup_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|f
operator|->
name|before_jump
operator|=
name|emit_insns_after
argument_list|(
name|cleanup_insns
argument_list|,
name|f
operator|->
name|before_jump
argument_list|)
expr_stmt|;
name|f
operator|->
name|cleanup_list_list
operator|=
name|TREE_CHAIN
argument_list|(
name|lists
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stack_level
condition|)
name|f
operator|->
name|stack_level
operator|=
name|stack_level
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* When exiting a binding contour, process all pending gotos requiring fixups.    Note: STACK_DEPTH is not altered.     The arguments are currently not used in the bytecode compiler, but we may    need them one day for languages other than C.     THISBLOCK is the structure that describes the block being exited.    STACK_LEVEL is the rtx for the stack level to restore exiting this contour.    CLEANUP_LIST is a list of expressions to evaluate on exiting this contour.    FIRST_INSN is the insn that began this contour.     Gotos that jump out of this contour must restore the    stack level and do the cleanups before actually jumping.     DONT_JUMP_IN nonzero means report error there is a jump into this    contour from before the beginning of the contour.    This is also done if STACK_LEVEL is nonzero.  */
end_comment

begin_function
specifier|static
name|void
name|bc_fixup_gotos
parameter_list|(
name|thisblock
parameter_list|,
name|stack_level
parameter_list|,
name|cleanup_list
parameter_list|,
name|first_insn
parameter_list|,
name|dont_jump_in
parameter_list|)
name|struct
name|nesting
modifier|*
name|thisblock
decl_stmt|;
name|int
name|stack_level
decl_stmt|;
name|tree
name|cleanup_list
decl_stmt|;
name|rtx
name|first_insn
decl_stmt|;
name|int
name|dont_jump_in
decl_stmt|;
block|{
specifier|register
name|struct
name|goto_fixup
modifier|*
name|f
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|int
name|saved_stack_depth
decl_stmt|;
comment|/* F is the fixup we are considering; PREV is the previous one.  */
for|for
control|(
name|prev
operator|=
literal|0
operator|,
name|f
operator|=
name|goto_fixup_chain
init|;
name|f
condition|;
name|prev
operator|=
name|f
operator|,
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
comment|/* Test for a fixup that is inactive because it is already handled.  */
if|if
condition|(
name|f
operator|->
name|before_jump
operator|==
literal|0
condition|)
block|{
comment|/* Delete inactive fixup from the chain, if that is easy to do.  */
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|f
operator|->
name|next
expr_stmt|;
block|}
comment|/* Emit code to restore the stack and continue */
name|bc_emit_bytecode_labeldef
argument_list|(
name|f
operator|->
name|label
argument_list|)
expr_stmt|;
comment|/* Save stack_depth across call, since bc_adjust_stack () will alter          the perceived stack depth via the instructions generated. */
if|if
condition|(
name|f
operator|->
name|bc_stack_level
operator|>=
literal|0
condition|)
block|{
name|saved_stack_depth
operator|=
name|stack_depth
expr_stmt|;
name|bc_adjust_stack
argument_list|(
name|stack_depth
operator|-
name|f
operator|->
name|bc_stack_level
argument_list|)
expr_stmt|;
name|stack_depth
operator|=
name|saved_stack_depth
expr_stmt|;
block|}
name|bc_emit_bytecode
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|bc_emit_bytecode_labelref
argument_list|(
name|f
operator|->
name|bc_target
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PRINT_CODE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|goto_fixup_chain
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL for an asm statement (explicit assembler code).    BODY is a STRING_CST node containing the assembler code text,    or an ADDR_EXPR containing a STRING_CST.  */
end_comment

begin_function
name|void
name|expand_asm
parameter_list|(
name|body
parameter_list|)
name|tree
name|body
decl_stmt|;
block|{
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|error
argument_list|(
literal|"`asm' is invalid when generating bytecode"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|body
operator|=
name|TREE_OPERAND
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|ASM_INPUT
argument_list|,
name|VOIDmode
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL for an asm statement with arguments.    STRING is the instruction template.    OUTPUTS is a list of output arguments (lvalues); INPUTS a list of inputs.    Each output or input has an expression in the TREE_VALUE and    a constraint-string in the TREE_PURPOSE.    CLOBBERS is a list of STRING_CST nodes each naming a hard register    that is clobbered by this insn.     Not all kinds of lvalue that may appear in OUTPUTS can be stored directly.    Some elements of OUTPUTS may be replaced with trees representing temporary    values.  The caller should copy those temporary values to the originally    specified lvalues.     VOL nonzero means the insn is volatile; don't optimize it.  */
end_comment

begin_function
name|void
name|expand_asm_operands
parameter_list|(
name|string
parameter_list|,
name|outputs
parameter_list|,
name|inputs
parameter_list|,
name|clobbers
parameter_list|,
name|vol
parameter_list|,
name|filename
parameter_list|,
name|line
parameter_list|)
name|tree
name|string
decl_stmt|,
name|outputs
decl_stmt|,
name|inputs
decl_stmt|,
name|clobbers
decl_stmt|;
name|int
name|vol
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|rtvec
name|argvec
decl_stmt|,
name|constraints
decl_stmt|;
name|rtx
name|body
decl_stmt|;
name|int
name|ninputs
init|=
name|list_length
argument_list|(
name|inputs
argument_list|)
decl_stmt|;
name|int
name|noutputs
init|=
name|list_length
argument_list|(
name|outputs
argument_list|)
decl_stmt|;
name|int
name|nclobbers
decl_stmt|;
name|tree
name|tail
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Vector of RTX's of evaluated output operands.  */
name|rtx
modifier|*
name|output_rtx
init|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|noutputs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
decl_stmt|;
comment|/* The insn we have emitted.  */
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|error
argument_list|(
literal|"`asm' is invalid when generating bytecode"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Count the number of meaningful clobbered registers, ignoring what      we would ignore later.  */
name|nclobbers
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|clobbers
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|char
modifier|*
name|regname
init|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
decl_stmt|;
name|i
operator|=
name|decode_reg_name
argument_list|(
name|regname
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
operator|||
name|i
operator|==
operator|-
literal|4
condition|)
operator|++
name|nclobbers
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
operator|-
literal|2
condition|)
name|error
argument_list|(
literal|"unknown register name `%s' in `asm'"
argument_list|,
name|regname
argument_list|)
expr_stmt|;
block|}
name|last_expr_type
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|tree
name|val1
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|found_equal
init|=
literal|0
decl_stmt|;
name|int
name|allows_reg
init|=
literal|0
decl_stmt|;
comment|/* If there's an erroneous arg, emit no insn.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* Make sure constraint has `=' and does not have `+'.  Also, see 	 if it allows any register.  Be liberal on the latter test, since 	 the worst that happens if we get it wrong is we issue an error 	 message.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TREE_STRING_LENGTH
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|-
literal|1
condition|;
name|j
operator|++
control|)
switch|switch
condition|(
name|TREE_STRING_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
index|[
name|j
index|]
condition|)
block|{
case|case
literal|'+'
case|:
name|error
argument_list|(
literal|"output operand constraint contains `+'"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'='
case|:
name|found_equal
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
case|case
literal|'!'
case|:
case|case
literal|'*'
case|:
case|case
literal|'%'
case|:
case|case
literal|'&'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'V'
case|:
case|case
literal|'m'
case|:
case|case
literal|'o'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'X'
case|:
case|case
literal|'s'
case|:
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|','
case|:
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
endif|#
directive|endif
break|break;
case|case
literal|'p'
case|:
case|case
literal|'g'
case|:
case|case
literal|'r'
case|:
default|default:
name|allows_reg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|found_equal
condition|)
block|{
name|error
argument_list|(
literal|"output operand constraint lacks `='"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If an output operand is not a decl or indirect ref and our constraint 	 allows a register, make a temporary to act as an intermediate. 	 Make the asm insn write into that, then our caller will copy it to 	 the real output operand.  Likewise for promoted variables.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|INDIRECT_REF
operator|||
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
literal|'d'
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|val
argument_list|)
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|)
operator|)
operator|||
operator|!
name|allows_reg
condition|)
block|{
if|if
condition|(
operator|!
name|allows_reg
condition|)
name|mark_addressable
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
name|output_rtx
index|[
name|i
index|]
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allows_reg
operator|&&
name|GET_CODE
argument_list|(
name|output_rtx
index|[
name|i
index|]
argument_list|)
operator|!=
name|MEM
condition|)
name|error
argument_list|(
literal|"output number %d not directly addressable"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
name|output_rtx
index|[
name|i
index|]
operator|=
name|assign_stack_temp
argument_list|(
name|BLKmode
argument_list|,
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|output_rtx
index|[
name|i
index|]
argument_list|)
operator|=
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|output_rtx
index|[
name|i
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|=
name|make_tree
argument_list|(
name|type
argument_list|,
name|output_rtx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ninputs
operator|+
name|noutputs
operator|>
name|MAX_RECOG_OPERANDS
condition|)
block|{
name|error
argument_list|(
literal|"more than %d operands in `asm'"
argument_list|,
name|MAX_RECOG_OPERANDS
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Make vectors for the expression-rtx and constraint strings.  */
name|argvec
operator|=
name|rtvec_alloc
argument_list|(
name|ninputs
argument_list|)
expr_stmt|;
name|constraints
operator|=
name|rtvec_alloc
argument_list|(
name|ninputs
argument_list|)
expr_stmt|;
name|body
operator|=
name|gen_rtx
argument_list|(
name|ASM_OPERANDS
argument_list|,
name|VOIDmode
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|string
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
name|argvec
argument_list|,
name|constraints
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|body
argument_list|)
operator|=
name|vol
expr_stmt|;
comment|/* Eval the inputs and put them into ARGVEC.      Put their constraints into ASM_INPUTs and store in CONSTRAINTS.  */
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|inputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|allows_reg
init|=
literal|0
decl_stmt|;
comment|/* If there's an erroneous arg, emit no insn, 	 because the ASM_INPUT would get VOIDmode 	 and that could cause a crash in reload.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"hard register `%s' listed as input operand to `asm'"
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Make sure constraint has neither `=' nor `+'.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TREE_STRING_LENGTH
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|-
literal|1
condition|;
name|j
operator|++
control|)
switch|switch
condition|(
name|TREE_STRING_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
index|[
name|j
index|]
condition|)
block|{
case|case
literal|'+'
case|:
case|case
literal|'='
case|:
name|error
argument_list|(
literal|"input operand constraint contains `%c'"
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
index|[
name|j
index|]
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'?'
case|:
case|case
literal|'!'
case|:
case|case
literal|'*'
case|:
case|case
literal|'%'
case|:
case|case
literal|'&'
case|:
case|case
literal|'V'
case|:
case|case
literal|'m'
case|:
case|case
literal|'o'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'X'
case|:
case|case
literal|'s'
case|:
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|','
case|:
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
endif|#
directive|endif
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'p'
case|:
case|case
literal|'g'
case|:
case|case
literal|'r'
case|:
default|default:
name|allows_reg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|allows_reg
condition|)
name|mark_addressable
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
comment|/* argvec */
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
argument_list|)
operator|&&
operator|!
name|general_operand
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|allows_reg
condition|)
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
operator|=
name|force_reg
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
operator|=
name|force_const_mem
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|allows_reg
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CONCAT
operator|)
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|memloc
init|=
name|assign_stack_temp
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|memloc
argument_list|)
operator|=
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|memloc
argument_list|,
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
operator|=
name|memloc
expr_stmt|;
block|}
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|4
argument_list|,
name|i
argument_list|)
comment|/* constraints */
operator|=
name|gen_rtx
argument_list|(
name|ASM_INPUT
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
comment|/* Protect all the operands from the queue,      now that they have all been evaluated.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninputs
condition|;
name|i
operator|++
control|)
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
operator|=
name|protect_from_queue
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noutputs
condition|;
name|i
operator|++
control|)
name|output_rtx
index|[
name|i
index|]
operator|=
name|protect_from_queue
argument_list|(
name|output_rtx
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Now, for each output, construct an rtx      (set OUTPUT (asm_operands INSN OUTPUTNUMBER OUTPUTCONSTRAINT 			       ARGVEC CONSTRAINTS))      If there is more than one, put them inside a PARALLEL.  */
if|if
condition|(
name|noutputs
operator|==
literal|1
operator|&&
name|nclobbers
operator|==
literal|0
condition|)
block|{
name|XSTR
argument_list|(
name|body
argument_list|,
literal|1
argument_list|)
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|outputs
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|output_rtx
index|[
literal|0
index|]
argument_list|,
name|body
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|noutputs
operator|==
literal|0
operator|&&
name|nclobbers
operator|==
literal|0
condition|)
block|{
comment|/* No output operands: put in a raw ASM_OPERANDS rtx.  */
name|insn
operator|=
name|emit_insn
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|obody
init|=
name|body
decl_stmt|;
name|int
name|num
init|=
name|noutputs
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
name|num
operator|=
literal|1
expr_stmt|;
name|body
operator|=
name|gen_rtx
argument_list|(
name|PARALLEL
argument_list|,
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|num
operator|+
name|nclobbers
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For each output operand, store a SET.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|output_rtx
index|[
name|i
index|]
argument_list|,
name|gen_rtx
argument_list|(
name|ASM_OPERANDS
argument_list|,
name|VOIDmode
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|string
argument_list|)
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|,
name|i
argument_list|,
name|argvec
argument_list|,
name|constraints
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
operator|=
name|vol
expr_stmt|;
block|}
comment|/* If there are no outputs (but there are some clobbers) 	 store the bare ASM_OPERANDS into the PARALLEL.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
operator|++
argument_list|)
operator|=
name|obody
expr_stmt|;
comment|/* Store (clobber REG) for each clobbered register specified.  */
for|for
control|(
name|tail
operator|=
name|clobbers
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|char
modifier|*
name|regname
init|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|j
init|=
name|decode_reg_name
argument_list|(
name|regname
argument_list|)
decl_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|j
operator|==
operator|-
literal|3
condition|)
comment|/* `cc', which is not a register */
continue|continue;
if|if
condition|(
name|j
operator|==
operator|-
literal|4
condition|)
comment|/* `memory', don't cache memory across asm */
block|{
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
operator|++
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|gen_rtx
argument_list|(
name|SCRATCH
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Ignore unknown register, error already signalled.  */
continue|continue;
block|}
comment|/* Use QImode since that's guaranteed to clobber just one reg.  */
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
operator|++
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|QImode
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_insn
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
name|free_temp_slots
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL to evaluate the expression EXP    and remember it in case this is the VALUE in a ({... VALUE; }) constr.  */
end_comment

begin_function
name|void
name|expand_expr_stmt
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|int
name|org_stack_depth
init|=
name|stack_depth
decl_stmt|;
name|bc_expand_expr
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Restore stack depth */
if|if
condition|(
name|stack_depth
operator|<
name|org_stack_depth
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bc_emit_instruction
argument_list|(
name|drop
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If -W, warn about statements with no side effects,      except for an explicit cast to void (e.g. for assert()), and      except inside a ({...}) where they may be useful.  */
if|if
condition|(
name|expr_stmts_for_value
operator|==
literal|0
operator|&&
name|exp
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|exp
argument_list|)
operator|&&
operator|(
name|extra_warnings
operator|||
name|warn_unused
operator|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONVERT_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|==
name|void_type_node
operator|)
condition|)
name|warning_with_file_and_line
argument_list|(
name|emit_filename
argument_list|,
name|emit_lineno
argument_list|,
literal|"statement with no effect"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_unused
condition|)
name|warn_if_unused_value
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
comment|/* If EXP is of function type and we are expanding statements for      value, convert it to pointer-to-function.  */
if|if
condition|(
name|expr_stmts_for_value
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|exp
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_syntax_only
condition|)
name|last_expr_value
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
operator|(
name|expr_stmts_for_value
condition|?
name|NULL_RTX
else|:
name|const0_rtx
operator|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If all we do is reference a volatile value in memory,      copy it to a register to be sure it is actually touched.  */
if|if
condition|(
name|last_expr_value
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|last_expr_value
argument_list|)
operator|==
name|MEM
operator|&&
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|VOIDmode
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|BLKmode
condition|)
name|copy_to_reg
argument_list|(
name|last_expr_value
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|lab
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
comment|/* Compare the value with itself to reference it.  */
name|emit_cmp_insn
argument_list|(
name|last_expr_value
argument_list|,
name|last_expr_value
argument_list|,
name|EQ
argument_list|,
name|expand_expr
argument_list|(
name|TYPE_SIZE
argument_list|(
name|last_expr_type
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|BLKmode
argument_list|,
literal|0
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|last_expr_type
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|EQ
index|]
call|)
argument_list|(
name|lab
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|lab
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this expression is part of a ({...}) and is in memory, we may have      to preserve temporaries.  */
name|preserve_temp_slots
argument_list|(
name|last_expr_value
argument_list|)
expr_stmt|;
comment|/* Free any temporaries used to evaluate this expression.  Any temporary      used as a result of this expression will already have been preserved      above.  */
name|free_temp_slots
argument_list|()
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Warn if EXP contains any computations whose results are not used.    Return 1 if a warning is printed; 0 otherwise.  */
end_comment

begin_function
name|int
name|warn_if_unused_value
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|TREE_USED
argument_list|(
name|exp
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
case|case
name|INIT_EXPR
case|:
case|case
name|TARGET_EXPR
case|:
case|case
name|CALL_EXPR
case|:
case|case
name|METHOD_CALL_EXPR
case|:
case|case
name|RTL_EXPR
case|:
case|case
name|WITH_CLEANUP_EXPR
case|:
case|case
name|EXIT_EXPR
case|:
comment|/* We don't warn about COND_EXPR because it may be a useful 	 construct if either arm contains a side effect.  */
case|case
name|COND_EXPR
case|:
return|return
literal|0
return|;
case|case
name|BIND_EXPR
case|:
comment|/* For a binding, warn if no side effect within it.  */
return|return
name|warn_if_unused_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|SAVE_EXPR
case|:
return|return
name|warn_if_unused_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
comment|/* In&& or ||, warn if 2nd operand has no side effect.  */
return|return
name|warn_if_unused_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|COMPOUND_EXPR
case|:
if|if
condition|(
name|TREE_NO_UNUSED_WARNING
argument_list|(
name|exp
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|warn_if_unused_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Let people do `(foo (), 0)' without a warning.  */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|warn_if_unused_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
comment|/* Don't warn about values cast to void.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|==
name|void_type_node
condition|)
return|return
literal|0
return|;
comment|/* Don't warn about conversions not explicit in the user's program.  */
if|if
condition|(
name|TREE_NO_UNUSED_WARNING
argument_list|(
name|exp
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Assignment to a cast usually results in a cast of a modify. 	 Don't complain about that.  There can be an arbitrary number of 	 casts before the modify, so we must loop until we find the first 	 non-cast expression and then test to see if that is a modify.  */
block|{
name|tree
name|tem
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|MODIFY_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|INIT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CALL_EXPR
condition|)
return|return
literal|0
return|;
block|}
goto|goto
name|warn
goto|;
case|case
name|INDIRECT_REF
case|:
comment|/* Don't warn about automatic dereferencing of references, since 	 the user cannot control it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
return|return
name|warn_if_unused_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* ... fall through ... */
default|default:
comment|/* Referencing a volatile value is a side effect, so don't warn.  */
if|if
condition|(
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|'d'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|'r'
operator|)
operator|&&
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
condition|)
return|return
literal|0
return|;
name|warn
label|:
name|warning_with_file_and_line
argument_list|(
name|emit_filename
argument_list|,
name|emit_lineno
argument_list|,
literal|"value computed is not used"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Clear out the memory of the last expression evaluated.  */
end_comment

begin_function
name|void
name|clear_last_expr
parameter_list|()
block|{
name|last_expr_type
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a statement which will return a value.    Return the RTL_EXPR for this statement expr.    The caller must save that value and pass it to expand_end_stmt_expr.  */
end_comment

begin_function
name|tree
name|expand_start_stmt_expr
parameter_list|()
block|{
name|int
name|momentary
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* When generating bytecode just note down the stack depth */
if|if
condition|(
name|output_bytecode
condition|)
return|return
operator|(
name|build_int_2
argument_list|(
name|stack_depth
argument_list|,
literal|0
argument_list|)
operator|)
return|;
comment|/* Make the RTL_EXPR node temporary, not momentary,      so that rtl_expr_chain doesn't become garbage.  */
name|momentary
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
expr_stmt|;
name|resume_momentary
argument_list|(
name|momentary
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|start_sequence_for_rtl_expr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
name|expr_stmts_for_value
operator|++
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Restore the previous state at the end of a statement that returns a value.    Returns a tree node representing the statement's value and the    insns to compute the value.     The nodes of that expression have been freed by now, so we cannot use them.    But we don't want to do that anyway; the expression has already been    evaluated and now we just want to use the value.  So generate a RTL_EXPR    with the proper type and RTL value.     If the last substatement was not an expression,    return something with type `void'.  */
end_comment

begin_function
name|tree
name|expand_end_stmt_expr
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* At this point, all expressions have been evaluated in order. 	 However, all expression values have been popped when evaluated, 	 which means we have to recover the last expression value.  This is 	 the last value removed by means of a `drop' instruction.  Instead 	 of adding code to inhibit dropping the last expression value, it 	 is here recovered by undoing the `drop'.  Since `drop' is 	 equivalent to `adjustackSI [1]', it can be undone with `adjstackSI 	 [-1]'. */
name|bc_adjust_stack
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|last_expr_type
condition|)
name|last_expr_type
operator|=
name|void_type_node
expr_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|last_expr_type
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|t
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|RTL_EXPR_SEQUENCE
argument_list|(
name|t
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* Don't consider deleting this expr or containing exprs at tree level.  */
name|TREE_THIS_VOLATILE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
return|return
name|t
return|;
block|}
name|OK_DEFER_POP
expr_stmt|;
if|if
condition|(
name|last_expr_type
operator|==
literal|0
condition|)
block|{
name|last_expr_type
operator|=
name|void_type_node
expr_stmt|;
name|last_expr_value
operator|=
name|const0_rtx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last_expr_value
operator|==
literal|0
condition|)
comment|/* There are some cases where this can happen, such as when the        statement is void type.  */
name|last_expr_value
operator|=
name|const0_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|last_expr_value
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|last_expr_value
argument_list|)
condition|)
comment|/* Remove any possible QUEUED.  */
name|last_expr_value
operator|=
name|protect_from_queue
argument_list|(
name|last_expr_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|last_expr_type
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|t
argument_list|)
operator|=
name|last_expr_value
expr_stmt|;
name|RTL_EXPR_SEQUENCE
argument_list|(
name|t
argument_list|)
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|rtl_expr_chain
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|rtl_expr_chain
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Don't consider deleting this expr or containing exprs at tree level.  */
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Propagate volatility of the actual RTL expr.  */
name|TREE_THIS_VOLATILE
argument_list|(
name|t
argument_list|)
operator|=
name|volatile_refs_p
argument_list|(
name|last_expr_value
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
name|expr_stmts_for_value
operator|--
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL for the start of an if-then.  COND is the expression    whose truth should be tested.     If EXITFLAG is nonzero, this conditional is visible to    `exit_something'.  */
end_comment

begin_function
name|void
name|expand_start_cond
parameter_list|(
name|cond
parameter_list|,
name|exitflag
parameter_list|)
name|tree
name|cond
decl_stmt|;
name|int
name|exitflag
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thiscond
init|=
name|ALLOC_NESTING
argument_list|()
decl_stmt|;
comment|/* Make an entry on cond_stack for the cond we are entering.  */
name|thiscond
operator|->
name|next
operator|=
name|cond_stack
expr_stmt|;
name|thiscond
operator|->
name|all
operator|=
name|nesting_stack
expr_stmt|;
name|thiscond
operator|->
name|depth
operator|=
operator|++
name|nesting_depth
expr_stmt|;
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* Before we encounter an `else', we don't need a separate exit label      unless there are supposed to be exit statements      to exit this conditional.  */
name|thiscond
operator|->
name|exit_label
operator|=
name|exitflag
condition|?
name|gen_label_rtx
argument_list|()
else|:
literal|0
expr_stmt|;
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
operator|=
name|thiscond
operator|->
name|exit_label
expr_stmt|;
name|cond_stack
operator|=
name|thiscond
expr_stmt|;
name|nesting_stack
operator|=
name|thiscond
expr_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
name|bc_expand_start_cond
argument_list|(
name|cond
argument_list|,
name|exitflag
argument_list|)
expr_stmt|;
else|else
name|do_jump
argument_list|(
name|cond
argument_list|,
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL between then-clause and the elseif-clause    of an if-then-elseif-....  */
end_comment

begin_function
name|void
name|expand_start_elseif
parameter_list|(
name|cond
parameter_list|)
name|tree
name|cond
decl_stmt|;
block|{
if|if
condition|(
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
operator|==
literal|0
condition|)
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_jump
argument_list|(
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
argument_list|)
expr_stmt|;
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|cond
argument_list|,
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL between the then-clause and the else-clause    of an if-then-else.  */
end_comment

begin_function
name|void
name|expand_start_else
parameter_list|()
block|{
if|if
condition|(
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
operator|==
literal|0
condition|)
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|bc_expand_start_else
argument_list|()
expr_stmt|;
return|return;
block|}
name|emit_jump
argument_list|(
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
argument_list|)
expr_stmt|;
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
operator|=
literal|0
expr_stmt|;
comment|/* No more _else or _elseif calls. */
block|}
end_function

begin_comment
comment|/* After calling expand_start_else, turn this "else" into an "else if"    by providing another condition.  */
end_comment

begin_function
name|void
name|expand_elseif
parameter_list|(
name|cond
parameter_list|)
name|tree
name|cond
decl_stmt|;
block|{
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|cond
argument_list|,
name|cond_stack
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL for the end of an if-then.    Pop the record for it off of cond_stack.  */
end_comment

begin_function
name|void
name|expand_end_cond
parameter_list|()
block|{
name|struct
name|nesting
modifier|*
name|thiscond
init|=
name|cond_stack
decl_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
name|bc_expand_end_cond
argument_list|()
expr_stmt|;
else|else
block|{
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
if|if
condition|(
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
condition|)
name|emit_label
argument_list|(
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|next_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
condition|)
name|emit_label
argument_list|(
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
argument_list|)
expr_stmt|;
block|}
name|POPSTACK
argument_list|(
name|cond_stack
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code for the start of an if-then.  COND is the expression    whose truth is to be tested; if EXITFLAG is nonzero this conditional    is to be visible to exit_something.  It is assumed that the caller    has pushed the previous context on the cond stack. */
end_comment

begin_function
specifier|static
name|void
name|bc_expand_start_cond
parameter_list|(
name|cond
parameter_list|,
name|exitflag
parameter_list|)
name|tree
name|cond
decl_stmt|;
name|int
name|exitflag
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thiscond
init|=
name|cond_stack
decl_stmt|;
name|thiscond
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
operator|=
name|cond
expr_stmt|;
if|if
condition|(
operator|!
name|exitflag
condition|)
name|thiscond
operator|->
name|exit_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|bc_expand_expr
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|bc_emit_bytecode
argument_list|(
name|xjumpifnot
argument_list|)
expr_stmt|;
name|bc_emit_bytecode_labelref
argument_list|(
name|BYTECODE_BC_LABEL
argument_list|(
name|thiscond
operator|->
name|exit_label
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PRINT_CODE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Generate the label for the end of an if with    no else- clause.  */
end_comment

begin_function
specifier|static
name|void
name|bc_expand_end_cond
parameter_list|()
block|{
name|struct
name|nesting
modifier|*
name|thiscond
init|=
name|cond_stack
decl_stmt|;
name|bc_emit_bytecode_labeldef
argument_list|(
name|BYTECODE_BC_LABEL
argument_list|(
name|thiscond
operator|->
name|exit_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code for the start of the else- clause of    an if-then-else.  */
end_comment

begin_function
specifier|static
name|void
name|bc_expand_start_else
parameter_list|()
block|{
name|struct
name|nesting
modifier|*
name|thiscond
init|=
name|cond_stack
decl_stmt|;
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
operator|=
name|thiscond
operator|->
name|exit_label
expr_stmt|;
name|thiscond
operator|->
name|exit_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|bc_emit_bytecode
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|bc_emit_bytecode_labelref
argument_list|(
name|BYTECODE_BC_LABEL
argument_list|(
name|thiscond
operator|->
name|exit_label
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PRINT_CODE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bc_emit_bytecode_labeldef
argument_list|(
name|BYTECODE_BC_LABEL
argument_list|(
name|thiscond
operator|->
name|data
operator|.
name|cond
operator|.
name|endif_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL for the start of a loop.  EXIT_FLAG is nonzero if this    loop should be exited by `exit_something'.  This is a loop for which    `expand_continue' will jump to the top of the loop.     Make an entry on loop_stack to record the labels associated with    this loop.  */
end_comment

begin_function
name|struct
name|nesting
modifier|*
name|expand_start_loop
parameter_list|(
name|exit_flag
parameter_list|)
name|int
name|exit_flag
decl_stmt|;
block|{
specifier|register
name|struct
name|nesting
modifier|*
name|thisloop
init|=
name|ALLOC_NESTING
argument_list|()
decl_stmt|;
comment|/* Make an entry on loop_stack for the loop we are entering.  */
name|thisloop
operator|->
name|next
operator|=
name|loop_stack
expr_stmt|;
name|thisloop
operator|->
name|all
operator|=
name|nesting_stack
expr_stmt|;
name|thisloop
operator|->
name|depth
operator|=
operator|++
name|nesting_depth
expr_stmt|;
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|alt_end_label
operator|=
literal|0
expr_stmt|;
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|continue_label
operator|=
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
expr_stmt|;
name|thisloop
operator|->
name|exit_label
operator|=
name|exit_flag
condition|?
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
else|:
literal|0
expr_stmt|;
name|loop_stack
operator|=
name|thisloop
expr_stmt|;
name|nesting_stack
operator|=
name|thisloop
expr_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|bc_emit_bytecode_labeldef
argument_list|(
name|BYTECODE_BC_LABEL
argument_list|(
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|thisloop
return|;
block|}
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_LOOP_BEG
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
argument_list|)
expr_stmt|;
return|return
name|thisloop
return|;
block|}
end_function

begin_comment
comment|/* Like expand_start_loop but for a loop where the continuation point    (for expand_continue_loop) will be specified explicitly.  */
end_comment

begin_function
name|struct
name|nesting
modifier|*
name|expand_start_loop_continue_elsewhere
parameter_list|(
name|exit_flag
parameter_list|)
name|int
name|exit_flag
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thisloop
init|=
name|expand_start_loop
argument_list|(
name|exit_flag
argument_list|)
decl_stmt|;
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|continue_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
return|return
name|thisloop
return|;
block|}
end_function

begin_comment
comment|/* Specify the continuation point for a loop started with    expand_start_loop_continue_elsewhere.    Use this at the point in the code to which a continue statement    should jump.  */
end_comment

begin_function
name|void
name|expand_loop_continue_here
parameter_list|()
block|{
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|bc_emit_bytecode_labeldef
argument_list|(
name|BYTECODE_BC_LABEL
argument_list|(
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|continue_label
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_LOOP_CONT
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|continue_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End a loop.  */
end_comment

begin_function
specifier|static
name|void
name|bc_expand_end_loop
parameter_list|()
block|{
name|struct
name|nesting
modifier|*
name|thisloop
init|=
name|loop_stack
decl_stmt|;
name|bc_emit_bytecode
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|bc_emit_bytecode_labelref
argument_list|(
name|BYTECODE_BC_LABEL
argument_list|(
name|thisloop
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PRINT_CODE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bc_emit_bytecode_labeldef
argument_list|(
name|BYTECODE_BC_LABEL
argument_list|(
name|thisloop
operator|->
name|exit_label
argument_list|)
argument_list|)
expr_stmt|;
name|POPSTACK
argument_list|(
name|loop_stack
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a loop.  Generate a jump back to the top and the loop-exit label.    Pop the block off of loop_stack.  */
end_comment

begin_function
name|void
name|expand_end_loop
parameter_list|()
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|rtx
name|start_label
decl_stmt|;
name|rtx
name|last_test_insn
init|=
literal|0
decl_stmt|;
name|int
name|num_insns
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|bc_expand_end_loop
argument_list|()
expr_stmt|;
return|return;
block|}
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|start_label
operator|=
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
expr_stmt|;
comment|/* Mark the continue-point at the top of the loop if none elsewhere.  */
if|if
condition|(
name|start_label
operator|==
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|continue_label
condition|)
name|emit_note_before
argument_list|(
name|NOTE_INSN_LOOP_CONT
argument_list|,
name|start_label
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* If optimizing, perhaps reorder the loop.  If the loop      starts with a conditional exit, roll that to the end      where it will optimize together with the jump back.       We look for the last conditional branch to the exit that we encounter      before hitting 30 insns or a CALL_INSN.  If we see an unconditional      branch to the exit first, use it.       We must also stop at NOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes      because moving them is not valid.  */
if|if
condition|(
name|optimize
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|)
condition|)
block|{
comment|/* Scan insns from the top of the loop looking for a qualified 	 conditional exit.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_END
operator|)
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
condition|)
name|num_insns
operator|++
expr_stmt|;
if|if
condition|(
name|last_test_insn
operator|&&
name|num_insns
operator|>
literal|30
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
operator|(
operator|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
operator|)
operator|||
operator|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|alt_end_label
operator|)
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
operator|(
operator|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
operator|)
operator|||
operator|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|alt_end_label
operator|)
operator|)
operator|)
operator|)
condition|)
name|last_test_insn
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|last_test_insn
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
operator|(
operator|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
operator|)
operator|||
operator|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|alt_end_label
operator|)
operator|)
condition|)
comment|/* Include BARRIER.  */
name|last_test_insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|last_test_insn
operator|!=
literal|0
operator|&&
name|last_test_insn
operator|!=
name|get_last_insn
argument_list|()
condition|)
block|{
comment|/* We found one.  Move everything from there up 	     to the end of the loop, and add a jump into the loop 	     to jump to there.  */
specifier|register
name|rtx
name|newstart_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
specifier|register
name|rtx
name|start_move
init|=
name|start_label
decl_stmt|;
comment|/* If the start label is preceded by a NOTE_INSN_LOOP_CONT note, 	     then we want to move this note also.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|start_move
argument_list|)
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|PREV_INSN
argument_list|(
name|start_move
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_LOOP_CONT
operator|)
condition|)
name|start_move
operator|=
name|PREV_INSN
argument_list|(
name|start_move
argument_list|)
expr_stmt|;
name|emit_label_after
argument_list|(
name|newstart_label
argument_list|,
name|PREV_INSN
argument_list|(
name|start_move
argument_list|)
argument_list|)
expr_stmt|;
name|reorder_insns
argument_list|(
name|start_move
argument_list|,
name|last_test_insn
argument_list|,
name|get_last_insn
argument_list|()
argument_list|)
expr_stmt|;
name|emit_jump_insn_after
argument_list|(
name|gen_jump
argument_list|(
name|start_label
argument_list|)
argument_list|,
name|PREV_INSN
argument_list|(
name|newstart_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier_after
argument_list|(
name|PREV_INSN
argument_list|(
name|newstart_label
argument_list|)
argument_list|)
expr_stmt|;
name|start_label
operator|=
name|newstart_label
expr_stmt|;
block|}
block|}
name|emit_jump
argument_list|(
name|start_label
argument_list|)
expr_stmt|;
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_LOOP_END
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
argument_list|)
expr_stmt|;
name|POPSTACK
argument_list|(
name|loop_stack
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a jump to the current loop's continue-point.    This is usually the top of the loop, but may be specified    explicitly elsewhere.  If not currently inside a loop,    return 0 and do nothing; caller will print an error message.  */
end_comment

begin_function
name|int
name|expand_continue_loop
parameter_list|(
name|whichloop
parameter_list|)
name|struct
name|nesting
modifier|*
name|whichloop
decl_stmt|;
block|{
name|last_expr_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|whichloop
operator|==
literal|0
condition|)
name|whichloop
operator|=
name|loop_stack
expr_stmt|;
if|if
condition|(
name|whichloop
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|expand_goto_internal
argument_list|(
name|NULL_TREE
argument_list|,
name|whichloop
operator|->
name|data
operator|.
name|loop
operator|.
name|continue_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Generate a jump to exit the current loop.  If not currently inside a loop,    return 0 and do nothing; caller will print an error message.  */
end_comment

begin_function
name|int
name|expand_exit_loop
parameter_list|(
name|whichloop
parameter_list|)
name|struct
name|nesting
modifier|*
name|whichloop
decl_stmt|;
block|{
name|last_expr_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|whichloop
operator|==
literal|0
condition|)
name|whichloop
operator|=
name|loop_stack
expr_stmt|;
if|if
condition|(
name|whichloop
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|expand_goto_internal
argument_list|(
name|NULL_TREE
argument_list|,
name|whichloop
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Generate a conditional jump to exit the current loop if COND    evaluates to zero.  If not currently inside a loop,    return 0 and do nothing; caller will print an error message.  */
end_comment

begin_function
name|int
name|expand_exit_loop_if_false
parameter_list|(
name|whichloop
parameter_list|,
name|cond
parameter_list|)
name|struct
name|nesting
modifier|*
name|whichloop
decl_stmt|;
name|tree
name|cond
decl_stmt|;
block|{
name|last_expr_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|whichloop
operator|==
literal|0
condition|)
name|whichloop
operator|=
name|loop_stack
expr_stmt|;
if|if
condition|(
name|whichloop
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|bc_expand_expr
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|bc_expand_goto_internal
argument_list|(
name|xjumpifnot
argument_list|,
name|BYTECODE_BC_LABEL
argument_list|(
name|whichloop
operator|->
name|exit_label
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* In order to handle fixups, we actually create a conditional jump 	 around a unconditional branch to exit the loop.  If fixups are 	 necessary, they go before the unconditional branch.  */
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|last_insn
decl_stmt|;
name|do_jump
argument_list|(
name|cond
argument_list|,
name|NULL_RTX
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|last_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|last_insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|whichloop
operator|->
name|data
operator|.
name|loop
operator|.
name|alt_end_label
operator|=
name|last_insn
expr_stmt|;
name|expand_goto_internal
argument_list|(
name|NULL_TREE
argument_list|,
name|whichloop
operator|->
name|data
operator|.
name|loop
operator|.
name|end_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if we should preserve sub-expressions as separate    pseudos.  We never do so if we aren't optimizing.  We always do so    if -fexpensive-optimizations.     Otherwise, we only do so if we are in the "early" part of a loop.  I.e.,    the loop may still be a small one.  */
end_comment

begin_function
name|int
name|preserve_subexpressions_p
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|flag_expensive_optimizations
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|optimize
operator|==
literal|0
operator|||
name|loop_stack
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|insn
operator|=
name|get_last_insn_anywhere
argument_list|()
expr_stmt|;
return|return
operator|(
name|insn
operator|&&
operator|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|-
name|INSN_UID
argument_list|(
name|loop_stack
operator|->
name|data
operator|.
name|loop
operator|.
name|start_label
argument_list|)
operator|<
name|n_non_fixed_regs
operator|*
literal|3
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Generate a jump to exit the current loop, conditional, binding contour    or case statement.  Not all such constructs are visible to this function,    only those started with EXIT_FLAG nonzero.  Individual languages use    the EXIT_FLAG parameter to control which kinds of constructs you can    exit this way.     If not currently inside anything that can be exited,    return 0 and do nothing; caller will print an error message.  */
end_comment

begin_function
name|int
name|expand_exit_something
parameter_list|()
block|{
name|struct
name|nesting
modifier|*
name|n
decl_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|nesting_stack
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|all
control|)
if|if
condition|(
name|n
operator|->
name|exit_label
operator|!=
literal|0
condition|)
block|{
name|expand_goto_internal
argument_list|(
name|NULL_TREE
argument_list|,
name|n
operator|->
name|exit_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL to return from the current function, with no value.    (That is, we do not do anything about returning any value.)  */
end_comment

begin_function
name|void
name|expand_null_return
parameter_list|()
block|{
name|struct
name|nesting
modifier|*
name|block
init|=
name|block_stack
decl_stmt|;
name|rtx
name|last_insn
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|bc_emit_instruction
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Does any pending block have cleanups?  */
while|while
condition|(
name|block
operator|&&
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|==
literal|0
condition|)
name|block
operator|=
name|block
operator|->
name|next
expr_stmt|;
comment|/* If yes, use a goto to return, since that runs cleanups.  */
name|expand_null_return_1
argument_list|(
name|last_insn
argument_list|,
name|block
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL to return from the current function, with value VAL.  */
end_comment

begin_function
specifier|static
name|void
name|expand_value_return
parameter_list|(
name|val
parameter_list|)
name|rtx
name|val
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|block
init|=
name|block_stack
decl_stmt|;
name|rtx
name|last_insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|return_reg
init|=
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Copy the value to the return location      unless it's already there.  */
if|if
condition|(
name|return_reg
operator|!=
name|val
condition|)
block|{
ifdef|#
directive|ifdef
name|PROMOTE_FUNCTION_RETURN
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|promote_mode
argument_list|(
name|type
argument_list|,
name|DECL_MODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|val
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|val
argument_list|)
operator|!=
name|mode
condition|)
name|convert_move
argument_list|(
name|return_reg
argument_list|,
name|val
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|emit_move_insn
argument_list|(
name|return_reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|return_reg
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|return_reg
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|return_reg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Does any pending block have cleanups?  */
while|while
condition|(
name|block
operator|&&
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|==
literal|0
condition|)
name|block
operator|=
name|block
operator|->
name|next
expr_stmt|;
comment|/* If yes, use a goto to return, since that runs cleanups.      Use LAST_INSN to put cleanups *before* the move insn emitted above.  */
name|expand_null_return_1
argument_list|(
name|last_insn
argument_list|,
name|block
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a return with no value.  If LAST_INSN is nonzero,    pretend that the return takes place after LAST_INSN.    If USE_GOTO is nonzero then don't use a return instruction;    go to the return label instead.  This causes any cleanups    of pending blocks to be executed normally.  */
end_comment

begin_function
specifier|static
name|void
name|expand_null_return_1
parameter_list|(
name|last_insn
parameter_list|,
name|use_goto
parameter_list|)
name|rtx
name|last_insn
decl_stmt|;
name|int
name|use_goto
decl_stmt|;
block|{
name|rtx
name|end_label
init|=
name|cleanup_label
condition|?
name|cleanup_label
else|:
name|return_label
decl_stmt|;
name|clear_pending_stack_adjust
argument_list|()
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|last_expr_type
operator|=
literal|0
expr_stmt|;
comment|/* PCC-struct return always uses an epilogue.  */
if|if
condition|(
name|current_function_returns_pcc_struct
operator|||
name|use_goto
condition|)
block|{
if|if
condition|(
name|end_label
operator|==
literal|0
condition|)
name|end_label
operator|=
name|return_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|expand_goto_internal
argument_list|(
name|NULL_TREE
argument_list|,
name|end_label
argument_list|,
name|last_insn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Otherwise output a simple return-insn if one is available,      unless it won't do the job.  */
ifdef|#
directive|ifdef
name|HAVE_return
if|if
condition|(
name|HAVE_return
operator|&&
name|use_goto
operator|==
literal|0
operator|&&
name|cleanup_label
operator|==
literal|0
condition|)
block|{
name|emit_jump_insn
argument_list|(
name|gen_return
argument_list|()
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Otherwise jump to the epilogue.  */
name|expand_goto_internal
argument_list|(
name|NULL_TREE
argument_list|,
name|end_label
argument_list|,
name|last_insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL to evaluate the expression RETVAL and return it    from the current function.  */
end_comment

begin_function
name|void
name|expand_return
parameter_list|(
name|retval
parameter_list|)
name|tree
name|retval
decl_stmt|;
block|{
comment|/* If there are any cleanups to be performed, then they will      be inserted following LAST_INSN.  It is desirable      that the last_insn, for such purposes, should be the      last insn before computing the return value.  Otherwise, cleanups      which call functions can clobber the return value.  */
comment|/* ??? rms: I think that is erroneous, because in C++ it would      run destructors on variables that might be used in the subsequent      computation of the return value.  */
name|rtx
name|last_insn
init|=
literal|0
decl_stmt|;
specifier|register
name|rtx
name|val
init|=
literal|0
decl_stmt|;
specifier|register
name|rtx
name|op0
decl_stmt|;
name|tree
name|retval_rhs
decl_stmt|;
name|int
name|cleanups
decl_stmt|;
name|struct
name|nesting
modifier|*
name|block
decl_stmt|;
comment|/* Bytecode returns are quite simple, just leave the result on the      arithmetic stack. */
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|bc_expand_expr
argument_list|(
name|retval
argument_list|)
expr_stmt|;
name|bc_emit_instruction
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If function wants no value, give it none.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|expand_expr
argument_list|(
name|retval
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|expand_null_return
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Are any cleanups needed?  E.g. C++ destructors to be run?  */
comment|/* This is not sufficient.  We also need to watch for cleanups of the      expression we are about to expand.  Unfortunately, we cannot know      if it has cleanups until we expand it, and we want to change how we      expand it depending upon if we need cleanups.  We can't win.  */
if|#
directive|if
literal|0
block|cleanups = any_pending_cleanups (1);
else|#
directive|else
name|cleanups
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|==
name|RESULT_DECL
condition|)
name|retval_rhs
operator|=
name|retval
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|==
name|MODIFY_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|==
name|INIT_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|retval
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|RESULT_DECL
condition|)
name|retval_rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|retval
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|retval
argument_list|)
operator|==
name|void_type_node
condition|)
comment|/* Recognize tail-recursive call to void function.  */
name|retval_rhs
operator|=
name|retval
expr_stmt|;
else|else
name|retval_rhs
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Only use `last_insn' if there are cleanups which must be run.  */
if|if
condition|(
name|cleanups
operator|||
name|cleanup_label
operator|!=
literal|0
condition|)
name|last_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Distribute return down conditional expr if either of the sides      may involve tail recursion (see test below).  This enhances the number      of tail recursions we see.  Don't do this always since it can produce      sub-optimal code in some cases and we distribute assignments into      conditional expressions when it would help.  */
if|if
condition|(
name|optimize
operator|&&
name|retval_rhs
operator|!=
literal|0
operator|&&
name|frame_offset
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|retval_rhs
argument_list|)
operator|==
name|COND_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|retval_rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CALL_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|retval_rhs
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CALL_EXPR
operator|)
condition|)
block|{
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|retval_rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|retval_rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_return
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|retval_rhs
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_return
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* For tail-recursive call to current function,      just jump back to the beginning.      It's unsafe if any auto variable in this function      has its address taken; for simplicity,      require stack frame to be empty.  */
if|if
condition|(
name|optimize
operator|&&
name|retval_rhs
operator|!=
literal|0
operator|&&
name|frame_offset
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|retval_rhs
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|retval_rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|retval_rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|current_function_decl
comment|/* Finish checking validity, and if valid emit code 	 to set the argument variables for the new call.  */
operator|&&
name|tail_recursion_args
argument_list|(
name|TREE_OPERAND
argument_list|(
name|retval_rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|tail_recursion_label
operator|==
literal|0
condition|)
block|{
name|tail_recursion_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label_after
argument_list|(
name|tail_recursion_label
argument_list|,
name|tail_recursion_reentry
argument_list|)
expr_stmt|;
block|}
name|emit_queue
argument_list|()
expr_stmt|;
name|expand_goto_internal
argument_list|(
name|NULL_TREE
argument_list|,
name|tail_recursion_label
argument_list|,
name|last_insn
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|HAVE_return
comment|/* This optimization is safe if there are local cleanups      because expand_null_return takes care of them.      ??? I think it should also be safe when there is a cleanup label,      because expand_null_return takes care of them, too.      Any reason why not?  */
if|if
condition|(
name|HAVE_return
operator|&&
name|cleanup_label
operator|==
literal|0
operator|&&
operator|!
name|current_function_returns_pcc_struct
operator|&&
name|BRANCH_COST
operator|<=
literal|1
condition|)
block|{
comment|/* If this is  return x == y;  then generate 	 if (x == y) return 1; else return 0; 	 if we can do it with explicit return insns and 	 branches are cheap.  */
if|if
condition|(
name|retval_rhs
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|retval_rhs
argument_list|)
condition|)
block|{
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
name|op0
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|jumpifnot
argument_list|(
name|retval_rhs
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|expand_value_return
argument_list|(
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|expand_value_return
argument_list|(
name|const0_rtx
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_return */
comment|/* If the result is an aggregate that is being returned in one (or more)      registers, load the registers here.  The compiler currently can't handle      copying a BLKmode value into registers.  We could put this code in a      more general area (for use by everyone instead of just function      call/return), but until this feature is generally usable it is kept here      (and in expand_call).  The value must go into a pseudo in case there      are cleanups that will clobber the real return register.  */
if|if
condition|(
name|retval_rhs
operator|!=
literal|0
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval_rhs
argument_list|)
argument_list|)
operator|==
name|BLKmode
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|i
decl_stmt|,
name|bitpos
decl_stmt|,
name|xbitpos
decl_stmt|;
name|int
name|big_endian_correction
init|=
literal|0
decl_stmt|;
name|int
name|bytes
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval_rhs
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|n_regs
init|=
operator|(
name|bytes
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
name|int
name|bitsize
init|=
name|MIN
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval_rhs
argument_list|)
argument_list|)
argument_list|,
name|BITS_PER_WORD
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|result_pseudos
init|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
operator|*
name|n_regs
argument_list|)
decl_stmt|;
name|rtx
name|result_reg
decl_stmt|,
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|rtx
name|result_val
init|=
name|expand_expr
argument_list|(
name|retval_rhs
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmpmode
decl_stmt|,
name|result_reg_mode
decl_stmt|;
comment|/* Structures whose size is not a multiple of a word are aligned 	 to the least significant byte (to the right).  On a BYTES_BIG_ENDIAN 	 machine, this means we must skip the empty high order bytes when 	 calculating the bit offset.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|bytes
operator|%
name|UNITS_PER_WORD
condition|)
name|big_endian_correction
operator|=
operator|(
name|BITS_PER_WORD
operator|-
operator|(
operator|(
name|bytes
operator|%
name|UNITS_PER_WORD
operator|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
comment|/* Copy the structure BITSIZE bits at a time.  */
for|for
control|(
name|bitpos
operator|=
literal|0
operator|,
name|xbitpos
operator|=
name|big_endian_correction
init|;
name|bitpos
operator|<
name|bytes
operator|*
name|BITS_PER_UNIT
condition|;
name|bitpos
operator|+=
name|bitsize
operator|,
name|xbitpos
operator|+=
name|bitsize
control|)
block|{
comment|/* We need a new destination pseudo each time xbitpos is 	     on a word boundary and when xbitpos == big_endian_correction 	     (the first time through).  */
if|if
condition|(
name|xbitpos
operator|%
name|BITS_PER_WORD
operator|==
literal|0
operator|||
name|xbitpos
operator|==
name|big_endian_correction
condition|)
block|{
comment|/* Generate an appropriate register.  */
name|dst
operator|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
expr_stmt|;
name|result_pseudos
index|[
name|xbitpos
operator|/
name|BITS_PER_WORD
index|]
operator|=
name|dst
expr_stmt|;
comment|/* Clobber the destination before we move anything into it.  */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We need a new source operand each time bitpos is on a word 	     boundary.  */
if|if
condition|(
name|bitpos
operator|%
name|BITS_PER_WORD
operator|==
literal|0
condition|)
name|src
operator|=
name|operand_subword_force
argument_list|(
name|result_val
argument_list|,
name|bitpos
operator|/
name|BITS_PER_WORD
argument_list|,
name|BLKmode
argument_list|)
expr_stmt|;
comment|/* Use bitpos for the source extraction (left justified) and 	     xbitpos for the destination store (right justified).  */
name|store_bit_field
argument_list|(
name|dst
argument_list|,
name|bitsize
argument_list|,
name|xbitpos
operator|%
name|BITS_PER_WORD
argument_list|,
name|word_mode
argument_list|,
name|extract_bit_field
argument_list|(
name|src
argument_list|,
name|bitsize
argument_list|,
name|bitpos
operator|%
name|BITS_PER_WORD
argument_list|,
literal|1
argument_list|,
name|NULL_RTX
argument_list|,
name|word_mode
argument_list|,
name|word_mode
argument_list|,
name|bitsize
operator|/
name|BITS_PER_UNIT
argument_list|,
name|BITS_PER_WORD
argument_list|)
argument_list|,
name|bitsize
operator|/
name|BITS_PER_UNIT
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
comment|/* Find the smallest integer mode large enough to hold the 	 entire structure and use that mode instead of BLKmode 	 on the USE insn for the return register.   */
name|bytes
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval_rhs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|tmpmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|tmpmode
operator|!=
name|MAX_MACHINE_MODE
condition|;
name|tmpmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmpmode
argument_list|)
control|)
block|{
comment|/* Have we found a large enough mode?  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmpmode
argument_list|)
operator|>=
name|bytes
condition|)
break|break;
block|}
comment|/* No suitable mode found.  */
if|if
condition|(
name|tmpmode
operator|==
name|MAX_MACHINE_MODE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|PUT_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|,
name|tmpmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmpmode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|word_mode
argument_list|)
condition|)
name|result_reg_mode
operator|=
name|word_mode
expr_stmt|;
else|else
name|result_reg_mode
operator|=
name|tmpmode
expr_stmt|;
name|result_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|result_reg_mode
argument_list|)
expr_stmt|;
comment|/* Now that the value is in pseudos, copy it to the result reg(s).  */
name|emit_queue
argument_list|()
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_regs
condition|;
name|i
operator|++
control|)
name|emit_move_insn
argument_list|(
name|operand_subword
argument_list|(
name|result_reg
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|result_reg_mode
argument_list|)
argument_list|,
name|result_pseudos
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpmode
operator|!=
name|result_reg_mode
condition|)
name|result_reg
operator|=
name|gen_lowpart
argument_list|(
name|tmpmode
argument_list|,
name|result_reg
argument_list|)
expr_stmt|;
name|expand_value_return
argument_list|(
name|result_reg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cleanups
operator|&&
name|retval_rhs
operator|!=
literal|0
operator|&&
name|TREE_TYPE
argument_list|(
name|retval_rhs
argument_list|)
operator|!=
name|void_type_node
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* Calculate the return value into a pseudo reg.  */
name|val
operator|=
name|expand_expr
argument_list|(
name|retval_rhs
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* All temporaries have now been used.  */
name|free_temp_slots
argument_list|()
expr_stmt|;
comment|/* Return the calculated value, doing cleanups first.  */
name|expand_value_return
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No cleanups or no hard reg used; 	 calculate value into hard return reg.  */
name|expand_expr
argument_list|(
name|retval
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|expand_value_return
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if the end of the generated RTX is not a barrier.    This means code already compiled can drop through.  */
end_comment

begin_function
name|int
name|drop_through_at_end_p
parameter_list|()
block|{
name|rtx
name|insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
while|while
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit code to alter this function's formal parms for a tail-recursive call.    ACTUALS is a list of actual parameter expressions (chain of TREE_LISTs).    FORMALS is the chain of decls of formals.    Return 1 if this can be done;    otherwise return 0 and do not emit any code.  */
end_comment

begin_function
specifier|static
name|int
name|tail_recursion_args
parameter_list|(
name|actuals
parameter_list|,
name|formals
parameter_list|)
name|tree
name|actuals
decl_stmt|,
name|formals
decl_stmt|;
block|{
specifier|register
name|tree
name|a
init|=
name|actuals
decl_stmt|,
name|f
init|=
name|formals
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|rtx
modifier|*
name|argvec
decl_stmt|;
comment|/* Check that number and types of actuals are compatible      with the formals.  This is not always true in valid C code.      Also check that no formal needs to be addressable      and that all formals are scalars.  */
comment|/* Also count the args.  */
for|for
control|(
name|a
operator|=
name|actuals
operator|,
name|f
operator|=
name|formals
operator|,
name|i
operator|=
literal|0
init|;
name|a
operator|&&
name|f
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
operator|,
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|f
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|f
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|DECL_MODE
argument_list|(
name|f
argument_list|)
operator|==
name|BLKmode
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|a
operator|!=
literal|0
operator|||
name|f
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Compute all the actuals.  */
name|argvec
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|actuals
operator|,
name|i
operator|=
literal|0
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
operator|,
name|i
operator|++
control|)
name|argvec
index|[
name|i
index|]
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Find which actual values refer to current values of previous formals.      Copy each of them now, before any formal is changed.  */
for|for
control|(
name|a
operator|=
name|actuals
operator|,
name|i
operator|=
literal|0
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|int
name|copy
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|f
operator|=
name|formals
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
operator|,
name|j
operator|++
control|)
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|DECL_RTL
argument_list|(
name|f
argument_list|)
argument_list|,
name|argvec
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|copy
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|copy
condition|)
name|argvec
index|[
name|i
index|]
operator|=
name|copy_to_reg
argument_list|(
name|argvec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Store the values of the actuals into the formals.  */
for|for
control|(
name|f
operator|=
name|formals
operator|,
name|a
operator|=
name|actuals
operator|,
name|i
operator|=
literal|0
init|;
name|f
condition|;
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
operator|,
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|f
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|argvec
index|[
name|i
index|]
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|DECL_RTL
argument_list|(
name|f
argument_list|)
argument_list|,
name|argvec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|convert_move
argument_list|(
name|DECL_RTL
argument_list|(
name|f
argument_list|)
argument_list|,
name|argvec
index|[
name|i
index|]
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free_temp_slots
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate the RTL code for entering a binding contour.    The variables are declared one by one, by calls to `expand_decl'.     EXIT_FLAG is nonzero if this construct should be visible to    `exit_something'.  */
end_comment

begin_function
name|void
name|expand_start_bindings
parameter_list|(
name|exit_flag
parameter_list|)
name|int
name|exit_flag
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thisblock
init|=
name|ALLOC_NESTING
argument_list|()
decl_stmt|;
name|rtx
name|note
init|=
name|output_bytecode
condition|?
literal|0
else|:
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_BLOCK_BEG
argument_list|)
decl_stmt|;
comment|/* Make an entry on block_stack for the block we are entering.  */
name|thisblock
operator|->
name|next
operator|=
name|block_stack
expr_stmt|;
name|thisblock
operator|->
name|all
operator|=
name|nesting_stack
expr_stmt|;
name|thisblock
operator|->
name|depth
operator|=
operator|++
name|nesting_depth
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|=
literal|0
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|=
literal|0
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|function_call_count
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|if (block_stack)     {       if (block_stack->data.block.cleanups == NULL_TREE&& (block_stack->data.block.outer_cleanups == NULL_TREE 	      || block_stack->data.block.outer_cleanups == empty_cleanup_list)) 	thisblock->data.block.outer_cleanups = empty_cleanup_list;       else 	thisblock->data.block.outer_cleanups 	  = tree_cons (NULL_TREE, block_stack->data.block.cleanups, 		       block_stack->data.block.outer_cleanups);     }   else     thisblock->data.block.outer_cleanups = 0;
endif|#
directive|endif
if|#
directive|if
literal|1
if|if
condition|(
name|block_stack
operator|&&
operator|!
operator|(
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|==
name|NULL_TREE
operator|&&
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
operator|==
name|NULL_TREE
operator|)
condition|)
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|,
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
argument_list|)
expr_stmt|;
else|else
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|label_chain
operator|=
literal|0
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|innermost_stack_block
operator|=
name|stack_block_stack
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
operator|=
name|note
expr_stmt|;
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|block_start_count
operator|=
operator|++
name|block_start_count
expr_stmt|;
name|thisblock
operator|->
name|exit_label
operator|=
name|exit_flag
condition|?
name|gen_label_rtx
argument_list|()
else|:
literal|0
expr_stmt|;
name|block_stack
operator|=
name|thisblock
expr_stmt|;
name|nesting_stack
operator|=
name|thisblock
expr_stmt|;
if|if
condition|(
operator|!
name|output_bytecode
condition|)
block|{
comment|/* Make a new level for allocating stack slots.  */
name|push_temp_slots
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a pointer to a BLOCK node, save a pointer to the most recently    generated NOTE_INSN_BLOCK_END in the BLOCK_END_NOTE field of the given    BLOCK node.  */
end_comment

begin_function
name|void
name|remember_end_note
parameter_list|(
name|block
parameter_list|)
specifier|register
name|tree
name|block
decl_stmt|;
block|{
name|BLOCK_END_NOTE
argument_list|(
name|block
argument_list|)
operator|=
name|last_block_end_note
expr_stmt|;
name|last_block_end_note
operator|=
name|NULL_RTX
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL code to terminate a binding contour.    VARS is the chain of VAR_DECL nodes    for the variables bound in this contour.    MARK_ENDS is nonzero if we should put a note at the beginning    and end of this binding contour.     DONT_JUMP_IN is nonzero if it is not valid to jump into this contour.    (That is true automatically if the contour has a saved stack level.)  */
end_comment

begin_function
name|void
name|expand_end_bindings
parameter_list|(
name|vars
parameter_list|,
name|mark_ends
parameter_list|,
name|dont_jump_in
parameter_list|)
name|tree
name|vars
decl_stmt|;
name|int
name|mark_ends
decl_stmt|;
name|int
name|dont_jump_in
decl_stmt|;
block|{
specifier|register
name|struct
name|nesting
modifier|*
name|thisblock
init|=
name|block_stack
decl_stmt|;
specifier|register
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|bc_expand_end_bindings
argument_list|(
name|vars
argument_list|,
name|mark_ends
argument_list|,
name|dont_jump_in
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|warn_unused
condition|)
for|for
control|(
name|decl
operator|=
name|vars
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"unused variable `%s'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisblock
operator|->
name|exit_label
condition|)
block|{
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|thisblock
operator|->
name|exit_label
argument_list|)
expr_stmt|;
block|}
comment|/* If necessary, make a handler for nonlocal gotos taking      place in the function calls in this block.  */
if|if
condition|(
name|function_call_count
operator|!=
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|function_call_count
operator|&&
name|nonlocal_labels
comment|/* Make handler for outermost block 	 if there were any nonlocal gotos to this function.  */
operator|&&
operator|(
name|thisblock
operator|->
name|next
operator|==
literal|0
condition|?
name|current_function_has_nonlocal_label
comment|/* Make handler for inner block if it has something 	     special to do when you jump out of it.  */
else|:
operator|(
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|!=
literal|0
operator|||
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|tree
name|link
decl_stmt|;
name|rtx
name|afterward
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|handler_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|save_receiver
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
comment|/* Don't let jump_optimize delete the handler.  */
name|LABEL_PRESERVE_P
argument_list|(
name|handler_label
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Record the handler address in the stack slot for that purpose, 	 during this block, saving and restoring the outer value.  */
if|if
condition|(
name|thisblock
operator|->
name|next
operator|!=
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|nonlocal_goto_handler_slot
argument_list|,
name|save_receiver
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|save_receiver
argument_list|,
name|nonlocal_goto_handler_slot
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_before
argument_list|(
name|insns
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
argument_list|)
expr_stmt|;
block|}
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|nonlocal_goto_handler_slot
argument_list|,
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|Pmode
argument_list|,
name|handler_label
argument_list|)
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_before
argument_list|(
name|insns
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
argument_list|)
expr_stmt|;
comment|/* Jump around the handler; it runs only when specially invoked.  */
name|emit_jump
argument_list|(
name|afterward
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|handler_label
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_nonlocal_goto
if|if
condition|(
operator|!
name|HAVE_nonlocal_goto
condition|)
endif|#
directive|endif
comment|/* First adjust our frame pointer to its actual value.  It was 	   previously set to the start of the virtual area corresponding to 	   the stacked variables when we branched here and now needs to be 	   adjusted to the actual hardware fp value.  	   Assignments are to virtual registers are converted by 	   instantiate_virtual_regs into the corresponding assignment 	   to the underlying register (fp in this case) that makes 	   the original assignment true. 	   So the following insn will actually be 	   decrementing fp by STARTING_FRAME_OFFSET.  */
name|emit_move_insn
argument_list|(
name|virtual_stack_vars_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
if|if
condition|(
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
comment|/* If the argument pointer can be eliminated in favor of the 	     frame pointer, we don't need to restore it.  We assume here 	     that if such an elimination is present, it can always be used. 	     This is the case on all known machines; if we don't make this 	     assumption, we do unnecessary saving on many machines.  */
specifier|static
struct|struct
name|elims
block|{
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|}
name|elim_regs
index|[]
init|=
name|ELIMINABLE_REGS
struct|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|elim_regs
operator|/
sizeof|sizeof
name|elim_regs
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|elim_regs
index|[
name|i
index|]
operator|.
name|from
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|elim_regs
index|[
name|i
index|]
operator|.
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
break|break;
if|if
condition|(
name|i
operator|==
sizeof|sizeof
name|elim_regs
operator|/
sizeof|sizeof
name|elim_regs
index|[
literal|0
index|]
condition|)
endif|#
directive|endif
block|{
comment|/* Now restore our arg pointer from the address at which it 		 was saved in our stack frame. 		 If there hasn't be space allocated for it yet, make 		 some now.  */
if|if
condition|(
name|arg_pointer_save_area
operator|==
literal|0
condition|)
name|arg_pointer_save_area
operator|=
name|assign_stack_local
argument_list|(
name|Pmode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
comment|/* We need a pseudo here, or else 				 instantiate_virtual_regs_1 complains.  */
name|copy_to_reg
argument_list|(
name|arg_pointer_save_area
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* The handler expects the desired label address in the static chain 	 register.  It tests the address and does an appropriate jump 	 to whatever label is desired.  */
for|for
control|(
name|link
operator|=
name|nonlocal_labels
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
comment|/* Skip any labels we shouldn't be able to jump to from here.  */
if|if
condition|(
operator|!
name|DECL_TOO_LATE
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|not_this
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|this
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|do_jump_if_equal
argument_list|(
name|static_chain_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|Pmode
argument_list|,
name|DECL_RTL
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump
argument_list|(
name|not_this
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|expand_goto
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|not_this
argument_list|)
expr_stmt|;
block|}
comment|/* If label is not recognized, abort.  */
name|emit_library_call
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"abort"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|afterward
argument_list|)
expr_stmt|;
block|}
comment|/* Don't allow jumping into a block that has cleanups or a stack level.  */
if|if
condition|(
name|dont_jump_in
operator|||
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|!=
literal|0
operator|||
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|!=
literal|0
condition|)
block|{
name|struct
name|label_chain
modifier|*
name|chain
decl_stmt|;
comment|/* Any labels in this block are no longer valid to go to. 	 Mark them to cause an error message.  */
for|for
control|(
name|chain
operator|=
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|label_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|chain
operator|->
name|next
control|)
block|{
name|DECL_TOO_LATE
argument_list|(
name|chain
operator|->
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If any goto without a fixup came to this label, 	     that must be an error, because gotos without fixups 	     come from outside all saved stack-levels and all cleanups.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|chain
operator|->
name|label
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|chain
operator|->
name|label
argument_list|,
literal|"label `%s' used before containing binding contour"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Restore stack level in effect before the block      (only if variable-size objects allocated).  */
comment|/* Perform any cleanups associated with the block.  */
if|if
condition|(
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|!=
literal|0
operator|||
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|!=
literal|0
condition|)
block|{
comment|/* Only clean up here if this point can actually be reached.  */
name|int
name|reachable
init|=
name|GET_CODE
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
operator|!=
name|BARRIER
decl_stmt|;
comment|/* Don't let cleanups affect ({...}) constructs.  */
name|int
name|old_expr_stmts_for_value
init|=
name|expr_stmts_for_value
decl_stmt|;
name|rtx
name|old_last_expr_value
init|=
name|last_expr_value
decl_stmt|;
name|tree
name|old_last_expr_type
init|=
name|last_expr_type
decl_stmt|;
name|expr_stmts_for_value
operator|=
literal|0
expr_stmt|;
comment|/* Do the cleanups.  */
name|expand_cleanups
argument_list|(
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
name|reachable
argument_list|)
expr_stmt|;
if|if
condition|(
name|reachable
condition|)
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|expr_stmts_for_value
operator|=
name|old_expr_stmts_for_value
expr_stmt|;
name|last_expr_value
operator|=
name|old_last_expr_value
expr_stmt|;
name|last_expr_type
operator|=
name|old_last_expr_type
expr_stmt|;
comment|/* Restore the stack level.  */
if|if
condition|(
name|reachable
operator|&&
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|!=
literal|0
condition|)
block|{
name|emit_stack_restore
argument_list|(
name|thisblock
operator|->
name|next
condition|?
name|SAVE_BLOCK
else|:
name|SAVE_FUNCTION
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonlocal_goto_handler_slot
operator|!=
literal|0
condition|)
name|emit_stack_save
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
operator|&
name|nonlocal_goto_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
comment|/* Any gotos out of this block must also do these things. 	 Also report any gotos with fixups that came to labels in this 	 level.  */
name|fixup_gotos
argument_list|(
name|thisblock
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
argument_list|,
name|dont_jump_in
argument_list|)
expr_stmt|;
block|}
comment|/* Mark the beginning and end of the scope if requested.      We do this now, after running cleanups on the variables      just going out of scope, so they are in scope for their cleanups.  */
if|if
condition|(
name|mark_ends
condition|)
name|last_block_end_note
operator|=
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_BLOCK_END
argument_list|)
expr_stmt|;
else|else
comment|/* Get rid of the beginning-mark if we don't make an end-mark.  */
name|NOTE_LINE_NUMBER
argument_list|(
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
comment|/* If doing stupid register allocation, make sure lives of all      register variables declared here extend thru end of scope.  */
if|if
condition|(
name|obey_regdecls
condition|)
for|for
control|(
name|decl
operator|=
name|vars
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
name|rtx
name|rtl
init|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|rtl
operator|!=
literal|0
condition|)
name|use_variable
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
block|}
comment|/* Restore block_stack level for containing block.  */
name|stack_block_stack
operator|=
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|innermost_stack_block
expr_stmt|;
name|POPSTACK
argument_list|(
name|block_stack
argument_list|)
expr_stmt|;
comment|/* Pop the stack slot nesting and free any slots at this level.  */
name|pop_temp_slots
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End a binding contour.    VARS is the chain of VAR_DECL nodes for the variables bound    in this contour.  MARK_ENDS is nonzer if we should put a note    at the beginning and end of this binding contour.    DONT_JUMP_IN is nonzero if it is not valid to jump into this    contour.  */
end_comment

begin_function
specifier|static
name|void
name|bc_expand_end_bindings
parameter_list|(
name|vars
parameter_list|,
name|mark_ends
parameter_list|,
name|dont_jump_in
parameter_list|)
name|tree
name|vars
decl_stmt|;
name|int
name|mark_ends
decl_stmt|;
name|int
name|dont_jump_in
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thisbind
init|=
name|nesting_stack
decl_stmt|;
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|warn_unused
condition|)
for|for
control|(
name|decl
operator|=
name|vars
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"unused variable `%s'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisbind
operator|->
name|exit_label
condition|)
name|bc_emit_bytecode_labeldef
argument_list|(
name|BYTECODE_BC_LABEL
argument_list|(
name|thisbind
operator|->
name|exit_label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Pop block/bindings off stack */
name|POPSTACK
argument_list|(
name|block_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL for the automatic variable declaration DECL.    (Other kinds of declarations are simply ignored if seen here.)  */
end_comment

begin_function
name|void
name|expand_decl
parameter_list|(
name|decl
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thisblock
init|=
name|block_stack
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|bc_expand_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Only automatic variables need any expansion done.      Static and external variables, and external functions,      will be handled by `assemble_variable' (called from finish_decl).      TYPE_DECL and CONST_DECL require nothing.      PARM_DECLs are handled in `assign_parms'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
condition|)
return|return;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Create the RTL representation for the variable.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
comment|/* Variable with incomplete type.  */
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
comment|/* Error message was already done; now avoid a crash.  */
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|assign_stack_temp
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
comment|/* An initializer is going to decide the size of this array. 	   Until we know the size, represent its address with a reg.  */
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|BLKmode
comment|/* If -ffloat-store, don't put explicit float vars 	      into regs.  */
operator|&&
operator|!
operator|(
name|flag_float_store
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|obey_regdecls
operator|)
condition|)
block|{
comment|/* Automatic variable that can go in a register.  */
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|reg_mode
init|=
name|promote_mode
argument_list|(
name|type
argument_list|,
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|rtx
name|realpart
decl_stmt|,
name|imagpart
decl_stmt|;
name|enum
name|machine_mode
name|partmode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
comment|/* For a complex type variable, make a CONCAT of two pseudos 	     so that the real and imaginary parts 	     can be allocated separately.  */
name|realpart
operator|=
name|gen_reg_rtx
argument_list|(
name|partmode
argument_list|)
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|realpart
argument_list|)
operator|=
literal|1
expr_stmt|;
name|imagpart
operator|=
name|gen_reg_rtx
argument_list|(
name|partmode
argument_list|)
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|imagpart
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|CONCAT
argument_list|,
name|reg_mode
argument_list|,
name|realpart
argument_list|,
name|imagpart
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_reg_rtx
argument_list|(
name|reg_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|mark_reg_pointer
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* Variable of fixed size that goes on the stack.  */
name|rtx
name|oldaddr
init|=
literal|0
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
comment|/* If we previously made RTL for this decl, it must be an array 	 whose size was determined by the initializer. 	 The old address was a register; set that register now 	 to the proper address.  */
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|oldaddr
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|assign_stack_temp
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|+
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set alignment we actually gave this decl.  */
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|==
name|BLKmode
condition|?
name|BIGGEST_ALIGNMENT
else|:
name|GET_MODE_BITSIZE
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|oldaddr
condition|)
block|{
name|addr
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|oldaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
name|oldaddr
condition|)
name|emit_move_insn
argument_list|(
name|oldaddr
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a memory ref that contains aggregate components, 	 mark it as such for cse and loop optimize.  */
name|MEM_IN_STRUCT_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* If this is in memory because of -ffloat-store, 	 set the volatile bit, to prevent optimizations from 	 undoing the effects.  */
block|if (flag_float_store&& TREE_CODE (type) == REAL_TYPE) 	MEM_VOLATILE_P (DECL_RTL (decl)) = 1;
endif|#
directive|endif
block|}
else|else
comment|/* Dynamic-size object: must push space on the stack.  */
block|{
name|rtx
name|address
decl_stmt|,
name|size
decl_stmt|;
comment|/* Record the stack pointer on entry to block, if have 	 not already done so.  */
if|if
condition|(
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
operator|==
literal|0
condition|)
block|{
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_stack_save
argument_list|(
name|thisblock
operator|->
name|next
condition|?
name|SAVE_BLOCK
else|:
name|SAVE_FUNCTION
argument_list|,
operator|&
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|stack_level
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|first_insn
argument_list|)
expr_stmt|;
name|stack_block_stack
operator|=
name|thisblock
expr_stmt|;
block|}
comment|/* Compute the variable's size, in bytes.  */
name|size
operator|=
name|expand_expr
argument_list|(
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
comment|/* Allocate space on the stack for the variable.  */
name|address
operator|=
name|allocate_dynamic_stack_space
argument_list|(
name|size
argument_list|,
name|NULL_RTX
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Reference the variable indirect through that rtx.  */
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|address
argument_list|)
expr_stmt|;
comment|/* If this is a memory ref that contains aggregate components, 	 mark it as such for cse and loop optimize.  */
name|MEM_IN_STRUCT_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Indicate the alignment we actually gave this variable.  */
ifdef|#
directive|ifdef
name|STACK_BOUNDARY
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|STACK_BOUNDARY
expr_stmt|;
else|#
directive|else
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|BIGGEST_ALIGNMENT
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
condition|)
name|MEM_VOLATILE_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* A variable is not necessarily unchanging 	 just because it is const.  RTX_UNCHANGING_P 	 means no change in the function, 	 not merely no change in the variable's scope. 	 It is correct to set RTX_UNCHANGING_P if the variable's scope 	 is the whole function.  There's no convenient way to test that.  */
block|if (TREE_READONLY (decl))     RTX_UNCHANGING_P (DECL_RTL (decl)) = 1;
endif|#
directive|endif
comment|/* If doing stupid register allocation, make sure life of any      register variable starts here, at the start of its scope.  */
if|if
condition|(
name|obey_regdecls
condition|)
name|use_variable
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code for the automatic variable declaration DECL.  For    most variables this just means we give it a stack offset.  The    compiler sometimes emits cleanups without variables and we will    have to deal with those too.  */
end_comment

begin_function
specifier|static
name|void
name|bc_expand_decl
parameter_list|(
name|decl
parameter_list|,
name|cleanup
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|cleanup
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
block|{
comment|/* A cleanup with no variable.  */
if|if
condition|(
operator|!
name|cleanup
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Only auto variables need any work.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|||
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|bc_gen_rtx
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|bc_label
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
comment|/* Variable with incomplete type.  The stack offset herein will be        fixed later in expand_decl_init ().  */
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|bc_gen_rtx
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|bc_label
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|bc_allocate_local
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|bc_allocate_variable_array
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit code to perform the initialization of a declaration DECL.  */
end_comment

begin_function
name|void
name|expand_decl_init
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|int
name|was_used
init|=
name|TREE_USED
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|bc_expand_decl_init
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If this is a CONST_DECL, we don't have to generate any code, but      if DECL_INITIAL is a constant, call expand_expr to force TREE_CST_RTL      to be set while in the obstack containing the constant.  If we don't      do this, we can lose if we have functions nested three deep and the middle      function makes a CONST_DECL whose DECL_INITIAL is a STRING_CST while      the innermost function is the first to expand that STRING_CST.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|expand_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_INITIALIZER
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Compute and store the initial value now.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|INTEGER_TYPE
operator|||
name|code
operator|==
name|REAL_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
operator|||
name|code
operator|==
name|POINTER_TYPE
condition|)
name|expand_assignment
argument_list|(
name|decl
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
name|emit_line_note
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|expand_assignment
argument_list|(
name|decl
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
block|}
comment|/* Don't let the initialization count as "using" the variable.  */
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
name|was_used
expr_stmt|;
comment|/* Free any temporaries we made while initializing the decl.  */
name|preserve_temp_slots
argument_list|(
name|NULL_RTX
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand initialization for variable-sized types. Allocate array    using newlocalSI and set local variable, which is a pointer to the    storage. */
end_comment

begin_function
specifier|static
name|void
name|bc_expand_variable_local_init
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
comment|/* Evaluate size expression and coerce to SI */
name|bc_expand_expr
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Type sizes are always (?) of TREE_CODE INTEGER_CST, so      no coercion is necessary (?) */
comment|/*  emit_typecode_conversion (preferred_typecode (TYPE_MODE (DECL_SIZE (decl)), 						TREE_UNSIGNED (DECL_SIZE (decl))), SIcode); */
comment|/* Emit code to allocate array */
name|bc_emit_instruction
argument_list|(
name|newlocalSI
argument_list|)
expr_stmt|;
comment|/* Store array pointer in local variable. This is the only instance      where we actually want the address of the pointer to the      variable-size block, rather than the pointer itself.  We avoid      using expand_address() since that would cause the pointer to be      pushed rather than its address. Hence the hard-coded reference;      notice also that the variable is always local (no global      variable-size type variables). */
name|bc_load_localaddr
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|bc_emit_instruction
argument_list|(
name|storeP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit code to initialize a declaration.  */
end_comment

begin_function
specifier|static
name|void
name|bc_expand_decl_init
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|int
name|org_stack_depth
decl_stmt|;
comment|/* Statical initializers are handled elsewhere */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Memory original stack depth */
name|org_stack_depth
operator|=
name|stack_depth
expr_stmt|;
comment|/* If the type is variable-size, we first create its space (we ASSUME      it CAN'T be static).  We do this regardless of whether there's an      initializer assignment or not. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|bc_expand_variable_local_init
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Expand initializer assignment */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|INTEGER_TYPE
operator|||
name|code
operator|==
name|REAL_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
operator|||
name|code
operator|==
name|POINTER_TYPE
condition|)
name|expand_assignment
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|expand_assignment
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Restore stack depth */
if|if
condition|(
name|org_stack_depth
operator|>
name|stack_depth
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bc_adjust_stack
argument_list|(
name|stack_depth
operator|-
name|org_stack_depth
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* CLEANUP is an expression to be executed at exit from this binding contour;    for example, in C++, it might call the destructor for this variable.     If CLEANUP contains any SAVE_EXPRs, then you must preevaluate them    either before or after calling `expand_decl_cleanup' but before compiling    any subsequent expressions.  This is because CLEANUP may be expanded    more than once, on different branches of execution.    For the same reason, CLEANUP may not contain a CALL_EXPR    except as its topmost node--else `preexpand_calls' would get confused.     If CLEANUP is nonzero and DECL is zero, we record a cleanup    that is not associated with any particular variable.   */
end_comment

begin_function
name|int
name|expand_decl_cleanup
parameter_list|(
name|decl
parameter_list|,
name|cleanup
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|cleanup
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thisblock
init|=
name|block_stack
decl_stmt|;
comment|/* Error if we are not in any block.  */
if|if
condition|(
name|thisblock
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Record the cleanup if there is one.  */
if|if
condition|(
name|cleanup
operator|!=
literal|0
condition|)
block|{
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|=
name|temp_tree_cons
argument_list|(
name|decl
argument_list|,
name|cleanup
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|)
expr_stmt|;
comment|/* If this block has a cleanup, it belongs in stack_block_stack.  */
name|stack_block_stack
operator|=
name|thisblock
expr_stmt|;
call|(
modifier|*
name|interim_eh_hook
call|)
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* DECL is an anonymous union.  CLEANUP is a cleanup for DECL.    DECL_ELTS is the list of elements that belong to DECL's type.    In each, the TREE_VALUE is a VAR_DECL, and the TREE_PURPOSE a cleanup.  */
end_comment

begin_function
name|void
name|expand_anon_union_decl
parameter_list|(
name|decl
parameter_list|,
name|cleanup
parameter_list|,
name|decl_elts
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|cleanup
decl_stmt|,
name|decl_elts
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thisblock
init|=
name|block_stack
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|expand_decl_cleanup
argument_list|(
name|decl
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|x
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
while|while
condition|(
name|decl_elts
condition|)
block|{
name|tree
name|decl_elt
init|=
name|TREE_VALUE
argument_list|(
name|decl_elts
argument_list|)
decl_stmt|;
name|tree
name|cleanup_elt
init|=
name|TREE_PURPOSE
argument_list|(
name|decl_elts
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl_elt
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Propagate the union's alignment to the elements.  */
name|DECL_ALIGN
argument_list|(
name|decl_elt
argument_list|)
operator|=
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If the element has BLKmode and the union doesn't, the union is          aligned such that the element doesn't need to have BLKmode, so          change the element's mode to the appropriate one for its size.  */
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|&&
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|BLKmode
condition|)
name|DECL_MODE
argument_list|(
name|decl_elt
argument_list|)
operator|=
name|mode
operator|=
name|mode_for_size
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl_elt
argument_list|)
argument_list|)
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* (SUBREG (MEM ...)) at RTL generation time is invalid, so we          instead create a new MEM rtx with the proper mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
name|DECL_RTL
argument_list|(
name|decl_elt
argument_list|)
operator|=
name|x
expr_stmt|;
else|else
block|{
name|DECL_RTL
argument_list|(
name|decl_elt
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl_elt
argument_list|)
argument_list|)
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl_elt
argument_list|)
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
name|DECL_RTL
argument_list|(
name|decl_elt
argument_list|)
operator|=
name|x
expr_stmt|;
else|else
name|DECL_RTL
argument_list|(
name|decl_elt
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|mode
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Record the cleanup if there is one.  */
if|if
condition|(
name|cleanup
operator|!=
literal|0
condition|)
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|=
name|temp_tree_cons
argument_list|(
name|decl_elt
argument_list|,
name|cleanup_elt
argument_list|,
name|thisblock
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|)
expr_stmt|;
name|decl_elts
operator|=
name|TREE_CHAIN
argument_list|(
name|decl_elts
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand a list of cleanups LIST.    Elements may be expressions or may be nested lists.     If DONT_DO is nonnull, then any list-element    whose TREE_PURPOSE matches DONT_DO is omitted.    This is sometimes used to avoid a cleanup associated with    a value that is being returned out of the scope.     If IN_FIXUP is non-zero, we are generating this cleanup for a fixup    goto and handle protection regions specially in that case.     If REACHABLE, we emit code, otherwise just inform the exception handling    code about this finalization.  */
end_comment

begin_function
specifier|static
name|void
name|expand_cleanups
parameter_list|(
name|list
parameter_list|,
name|dont_do
parameter_list|,
name|in_fixup
parameter_list|,
name|reachable
parameter_list|)
name|tree
name|list
decl_stmt|;
name|tree
name|dont_do
decl_stmt|;
name|int
name|in_fixup
decl_stmt|;
name|int
name|reachable
decl_stmt|;
block|{
name|tree
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|list
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
if|if
condition|(
name|dont_do
operator|==
literal|0
operator|||
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|!=
name|dont_do
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|expand_cleanups
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
name|dont_do
argument_list|,
name|in_fixup
argument_list|,
name|reachable
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|in_fixup
condition|)
call|(
modifier|*
name|interim_eh_hook
call|)
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reachable
condition|)
block|{
comment|/* Cleanups may be run multiple times.  For example, 		   when exiting a binding contour, we expand the 		   cleanups associated with that contour.  When a goto 		   within that binding contour has a target outside that 		   contour, it will expand all cleanups from its scope to 		   the target.  Though the cleanups are expanded multiple 		   times, the control paths are non-overlapping so the 		   cleanups will not be executed twice.  */
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Move all cleanups from the current block_stack    to the containing block_stack, where they are assumed to    have been created.  If anything can cause a temporary to    be created, but not expanded for more than one level of    block_stacks, then this code will have to change.  */
end_comment

begin_function
name|void
name|move_cleanups_up
parameter_list|()
block|{
name|struct
name|nesting
modifier|*
name|block
init|=
name|block_stack
decl_stmt|;
name|struct
name|nesting
modifier|*
name|outer
init|=
name|block
operator|->
name|next
decl_stmt|;
name|outer
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|=
name|chainon
argument_list|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|,
name|outer
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
argument_list|)
expr_stmt|;
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|last_cleanup_this_contour
parameter_list|()
block|{
if|if
condition|(
name|block_stack
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if there are any pending cleanups at this point.    If THIS_CONTOUR is nonzero, check the current contour as well.    Otherwise, look only at the contours that enclose this one.  */
end_comment

begin_function
name|int
name|any_pending_cleanups
parameter_list|(
name|this_contour
parameter_list|)
name|int
name|this_contour
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|block
decl_stmt|;
if|if
condition|(
name|block_stack
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|this_contour
operator|&&
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|!=
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|==
literal|0
operator|&&
operator|(
name|block_stack
operator|->
name|data
operator|.
name|block
operator|.
name|outer_cleanups
operator|==
literal|0
if|#
directive|if
literal|0
expr||| block_stack->data.block.outer_cleanups == empty_cleanup_list
endif|#
directive|endif
operator|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|block
operator|=
name|block_stack
operator|->
name|next
init|;
name|block
condition|;
name|block
operator|=
name|block
operator|->
name|next
control|)
if|if
condition|(
name|block
operator|->
name|data
operator|.
name|block
operator|.
name|cleanups
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Enter a case (Pascal) or switch (C) statement.    Push a block onto case_stack and nesting_stack    to accumulate the case-labels that are seen    and to record the labels generated for the statement.     EXIT_FLAG is nonzero if `exit_something' should exit this case stmt.    Otherwise, this construct is transparent for `exit_something'.     EXPR is the index-expression to be dispatched on.    TYPE is its nominal type.  We could simply convert EXPR to this type,    but instead we take short cuts.  */
end_comment

begin_function
name|void
name|expand_start_case
parameter_list|(
name|exit_flag
parameter_list|,
name|expr
parameter_list|,
name|type
parameter_list|,
name|printname
parameter_list|)
name|int
name|exit_flag
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|char
modifier|*
name|printname
decl_stmt|;
block|{
specifier|register
name|struct
name|nesting
modifier|*
name|thiscase
init|=
name|ALLOC_NESTING
argument_list|()
decl_stmt|;
comment|/* Make an entry on case_stack for the case we are entering.  */
name|thiscase
operator|->
name|next
operator|=
name|case_stack
expr_stmt|;
name|thiscase
operator|->
name|all
operator|=
name|nesting_stack
expr_stmt|;
name|thiscase
operator|->
name|depth
operator|=
operator|++
name|nesting_depth
expr_stmt|;
name|thiscase
operator|->
name|exit_label
operator|=
name|exit_flag
condition|?
name|gen_label_rtx
argument_list|()
else|:
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|index_expr
operator|=
name|expr
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
operator|=
name|type
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|num_ranges
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|printname
operator|=
name|printname
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|seenlabel
operator|=
literal|0
expr_stmt|;
name|case_stack
operator|=
name|thiscase
expr_stmt|;
name|nesting_stack
operator|=
name|thiscase
expr_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|bc_expand_start_case
argument_list|(
name|thiscase
argument_list|,
name|expr
argument_list|,
name|type
argument_list|,
name|printname
argument_list|)
expr_stmt|;
return|return;
block|}
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Make sure case_stmt.start points to something that won't      need any transformation before expand_end_case.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
operator|!=
name|NOTE
condition|)
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|start
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enter a case statement. It is assumed that the caller has pushed    the current context onto the case stack. */
end_comment

begin_function
specifier|static
name|void
name|bc_expand_start_case
parameter_list|(
name|thiscase
parameter_list|,
name|expr
parameter_list|,
name|type
parameter_list|,
name|printname
parameter_list|)
name|struct
name|nesting
modifier|*
name|thiscase
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|char
modifier|*
name|printname
decl_stmt|;
block|{
name|bc_expand_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|bc_expand_conversion
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* For cases, the skip is a place we jump to that's emitted after      the size of the jump table is known.  */
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|skip_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|bc_emit_bytecode
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|bc_emit_bytecode_labelref
argument_list|(
name|BYTECODE_BC_LABEL
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|skip_label
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PRINT_CODE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Start a "dummy case statement" within which case labels are invalid    and are not connected to any larger real case statement.    This can be used if you don't want to let a case statement jump    into the middle of certain kinds of constructs.  */
end_comment

begin_function
name|void
name|expand_start_case_dummy
parameter_list|()
block|{
specifier|register
name|struct
name|nesting
modifier|*
name|thiscase
init|=
name|ALLOC_NESTING
argument_list|()
decl_stmt|;
comment|/* Make an entry on case_stack for the dummy.  */
name|thiscase
operator|->
name|next
operator|=
name|case_stack
expr_stmt|;
name|thiscase
operator|->
name|all
operator|=
name|nesting_stack
expr_stmt|;
name|thiscase
operator|->
name|depth
operator|=
operator|++
name|nesting_depth
expr_stmt|;
name|thiscase
operator|->
name|exit_label
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|=
literal|0
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|num_ranges
operator|=
literal|0
expr_stmt|;
name|case_stack
operator|=
name|thiscase
expr_stmt|;
name|nesting_stack
operator|=
name|thiscase
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End a dummy case statement.  */
end_comment

begin_function
name|void
name|expand_end_case_dummy
parameter_list|()
block|{
name|POPSTACK
argument_list|(
name|case_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the data type of the index-expression    of the innermost case statement, or null if none.  */
end_comment

begin_function
name|tree
name|case_index_expr_type
parameter_list|()
block|{
if|if
condition|(
name|case_stack
condition|)
return|return
name|TREE_TYPE
argument_list|(
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|index_expr
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Accumulate one case or default label inside a case or switch statement.    VALUE is the value of the case (a null pointer, for a default label).    The function CONVERTER, when applied to arguments T and V,    converts the value V to the type T.     If not currently inside a case or switch statement, return 1 and do    nothing.  The caller will print a language-specific error message.    If VALUE is a duplicate or overlaps, return 2 and do nothing    except store the (first) duplicate node in *DUPLICATE.    If VALUE is out of range, return 3 and do nothing.    If we are jumping into the scope of a cleaup or var-sized array, return 5.    Return 0 on success.     Extended to handle range statements.  */
end_comment

begin_function_decl
name|int
name|pushcase
parameter_list|(
name|value
parameter_list|,
name|converter
parameter_list|,
name|label
parameter_list|,
name|duplicate
parameter_list|)
specifier|register
name|tree
name|value
decl_stmt|;
function_decl|tree
parameter_list|(
function_decl|*converter
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|tree
name|label
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
modifier|*
name|duplicate
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|case_node
modifier|*
modifier|*
name|l
decl_stmt|;
specifier|register
name|struct
name|case_node
modifier|*
name|n
decl_stmt|;
name|tree
name|index_type
decl_stmt|;
name|tree
name|nominal_type
decl_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
return|return
name|bc_pushcase
argument_list|(
name|value
argument_list|,
name|label
argument_list|)
return|;
comment|/* Fail if not inside a real case statement.  */
if|if
condition|(
operator|!
operator|(
name|case_stack
operator|&&
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|start
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|stack_block_stack
operator|&&
name|stack_block_stack
operator|->
name|depth
operator|>
name|case_stack
operator|->
name|depth
condition|)
return|return
literal|5
return|;
name|index_type
operator|=
name|TREE_TYPE
argument_list|(
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|index_expr
argument_list|)
expr_stmt|;
name|nominal_type
operator|=
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
expr_stmt|;
comment|/* If the index is erroneous, avoid more problems: pretend to succeed.  */
if|if
condition|(
name|index_type
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
comment|/* Convert VALUE to the type in which the comparisons are nominally done.  */
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
name|value
operator|=
call|(
modifier|*
name|converter
call|)
argument_list|(
name|nominal_type
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* If this is the first label, warn if any insns have been emitted.  */
if|if
condition|(
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|seenlabel
operator|==
literal|0
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|start
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"unreachable code at beginning of %s"
argument_list|,
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|printname
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|seenlabel
operator|=
literal|1
expr_stmt|;
comment|/* Fail if this value is out of range for the actual type of the index      (which may be narrower than NOMINAL_TYPE).  */
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|value
argument_list|,
name|index_type
argument_list|)
condition|)
return|return
literal|3
return|;
comment|/* Fail if this is a duplicate or overlaps another entry.  */
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|!=
literal|0
condition|)
block|{
operator|*
name|duplicate
operator|=
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
expr_stmt|;
return|return
literal|2
return|;
block|}
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|=
name|label
expr_stmt|;
block|}
else|else
block|{
comment|/* Find the elt in the chain before which to insert the new value, 	 to keep the chain sorted in increasing order. 	 But report an error if this element is a duplicate.  */
for|for
control|(
name|l
operator|=
operator|&
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
init|;
comment|/* Keep going past elements distinctly less than VALUE.  */
operator|*
name|l
operator|!=
literal|0
operator|&&
name|tree_int_cst_lt
argument_list|(
operator|(
operator|*
name|l
operator|)
operator|->
name|high
argument_list|,
name|value
argument_list|)
condition|;
name|l
operator|=
operator|&
operator|(
operator|*
name|l
operator|)
operator|->
name|right
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|l
condition|)
block|{
comment|/* Element we will insert before must be distinctly greater; 	     overlap means error.  */
if|if
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|value
argument_list|,
operator|(
operator|*
name|l
operator|)
operator|->
name|low
argument_list|)
condition|)
block|{
operator|*
name|duplicate
operator|=
operator|(
operator|*
name|l
operator|)
operator|->
name|code_label
expr_stmt|;
return|return
literal|2
return|;
block|}
block|}
comment|/* Add this label to the chain, and succeed. 	 Copy VALUE so it is on temporary rather than momentary 	 obstack and will thus survive till the end of the case statement.  */
name|n
operator|=
operator|(
expr|struct
name|case_node
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|case_node
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|right
operator|=
operator|*
name|l
expr_stmt|;
name|n
operator|->
name|high
operator|=
name|n
operator|->
name|low
operator|=
name|copy_node
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|n
operator|->
name|code_label
operator|=
name|label
expr_stmt|;
operator|*
name|l
operator|=
name|n
expr_stmt|;
block|}
name|expand_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Like pushcase but this case applies to all values    between VALUE1 and VALUE2 (inclusive).    The return value is the same as that of pushcase    but there is one additional error code:    4 means the specified range was empty.  */
end_comment

begin_function_decl
name|int
name|pushcase_range
parameter_list|(
name|value1
parameter_list|,
name|value2
parameter_list|,
name|converter
parameter_list|,
name|label
parameter_list|,
name|duplicate
parameter_list|)
specifier|register
name|tree
name|value1
decl_stmt|,
name|value2
decl_stmt|;
function_decl|tree
parameter_list|(
function_decl|*converter
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|tree
name|label
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
modifier|*
name|duplicate
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|case_node
modifier|*
modifier|*
name|l
decl_stmt|;
specifier|register
name|struct
name|case_node
modifier|*
name|n
decl_stmt|;
name|tree
name|index_type
decl_stmt|;
name|tree
name|nominal_type
decl_stmt|;
comment|/* Fail if not inside a real case statement.  */
if|if
condition|(
operator|!
operator|(
name|case_stack
operator|&&
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|start
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|stack_block_stack
operator|&&
name|stack_block_stack
operator|->
name|depth
operator|>
name|case_stack
operator|->
name|depth
condition|)
return|return
literal|5
return|;
name|index_type
operator|=
name|TREE_TYPE
argument_list|(
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|index_expr
argument_list|)
expr_stmt|;
name|nominal_type
operator|=
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
expr_stmt|;
comment|/* If the index is erroneous, avoid more problems: pretend to succeed.  */
if|if
condition|(
name|index_type
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
comment|/* If this is the first label, warn if any insns have been emitted.  */
if|if
condition|(
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|seenlabel
operator|==
literal|0
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|start
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"unreachable code at beginning of %s"
argument_list|,
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|printname
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|seenlabel
operator|=
literal|1
expr_stmt|;
comment|/* Convert VALUEs to type in which the comparisons are nominally done.  */
if|if
condition|(
name|value1
operator|==
literal|0
condition|)
comment|/* Negative infinity. */
name|value1
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|index_type
argument_list|)
expr_stmt|;
name|value1
operator|=
call|(
modifier|*
name|converter
call|)
argument_list|(
name|nominal_type
argument_list|,
name|value1
argument_list|)
expr_stmt|;
if|if
condition|(
name|value2
operator|==
literal|0
condition|)
comment|/* Positive infinity. */
name|value2
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|index_type
argument_list|)
expr_stmt|;
name|value2
operator|=
call|(
modifier|*
name|converter
call|)
argument_list|(
name|nominal_type
argument_list|,
name|value2
argument_list|)
expr_stmt|;
comment|/* Fail if these values are out of range.  */
if|if
condition|(
operator|!
name|int_fits_type_p
argument_list|(
name|value1
argument_list|,
name|index_type
argument_list|)
condition|)
return|return
literal|3
return|;
if|if
condition|(
operator|!
name|int_fits_type_p
argument_list|(
name|value2
argument_list|,
name|index_type
argument_list|)
condition|)
return|return
literal|3
return|;
comment|/* Fail if the range is empty.  */
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|value2
argument_list|,
name|value1
argument_list|)
condition|)
return|return
literal|4
return|;
comment|/* If the bounds are equal, turn this into the one-value case.  */
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|value1
argument_list|,
name|value2
argument_list|)
condition|)
return|return
name|pushcase
argument_list|(
name|value1
argument_list|,
name|converter
argument_list|,
name|label
argument_list|,
name|duplicate
argument_list|)
return|;
comment|/* Find the elt in the chain before which to insert the new value,      to keep the chain sorted in increasing order.      But report an error if this element is a duplicate.  */
for|for
control|(
name|l
operator|=
operator|&
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
init|;
comment|/* Keep going past elements distinctly less than this range.  */
operator|*
name|l
operator|!=
literal|0
operator|&&
name|tree_int_cst_lt
argument_list|(
operator|(
operator|*
name|l
operator|)
operator|->
name|high
argument_list|,
name|value1
argument_list|)
condition|;
name|l
operator|=
operator|&
operator|(
operator|*
name|l
operator|)
operator|->
name|right
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|l
condition|)
block|{
comment|/* Element we will insert before must be distinctly greater; 	 overlap means error.  */
if|if
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|value2
argument_list|,
operator|(
operator|*
name|l
operator|)
operator|->
name|low
argument_list|)
condition|)
block|{
operator|*
name|duplicate
operator|=
operator|(
operator|*
name|l
operator|)
operator|->
name|code_label
expr_stmt|;
return|return
literal|2
return|;
block|}
block|}
comment|/* Add this label to the chain, and succeed.      Copy VALUE1, VALUE2 so they are on temporary rather than momentary      obstack and will thus survive till the end of the case statement.  */
name|n
operator|=
operator|(
expr|struct
name|case_node
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|case_node
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|right
operator|=
operator|*
name|l
expr_stmt|;
name|n
operator|->
name|low
operator|=
name|copy_node
argument_list|(
name|value1
argument_list|)
expr_stmt|;
name|n
operator|->
name|high
operator|=
name|copy_node
argument_list|(
name|value2
argument_list|)
expr_stmt|;
name|n
operator|->
name|code_label
operator|=
name|label
expr_stmt|;
operator|*
name|l
operator|=
name|n
expr_stmt|;
name|expand_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|num_ranges
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Accumulate one case or default label; VALUE is the value of the    case, or nil for a default label.  If not currently inside a case,    return 1 and do nothing.  If VALUE is a duplicate or overlaps, return    2 and do nothing.  If VALUE is out of range, return 3 and do nothing.    Return 0 on success.  This function is a leftover from the earlier    bytecode compiler, which was based on gcc 1.37.  It should be    merged into pushcase. */
end_comment

begin_function
specifier|static
name|int
name|bc_pushcase
parameter_list|(
name|value
parameter_list|,
name|label
parameter_list|)
name|tree
name|value
decl_stmt|;
name|tree
name|label
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thiscase
init|=
name|case_stack
decl_stmt|;
name|struct
name|case_node
modifier|*
name|case_label
decl_stmt|,
modifier|*
name|new_label
decl_stmt|;
if|if
condition|(
operator|!
name|thiscase
condition|)
return|return
literal|1
return|;
comment|/* Fail if duplicate, overlap, or out of type range.  */
if|if
condition|(
name|value
condition|)
block|{
name|value
operator|=
name|convert
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|int_fits_type_p
argument_list|(
name|value
argument_list|,
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
argument_list|)
condition|)
return|return
literal|3
return|;
for|for
control|(
name|case_label
operator|=
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
init|;
name|case_label
operator|->
name|left
condition|;
name|case_label
operator|=
name|case_label
operator|->
name|left
control|)
if|if
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|case_label
operator|->
name|left
operator|->
name|high
argument_list|,
name|value
argument_list|)
condition|)
break|break;
if|if
condition|(
name|case_label
operator|!=
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|&&
operator|!
name|tree_int_cst_lt
argument_list|(
name|case_label
operator|->
name|high
argument_list|,
name|value
argument_list|)
operator|||
name|case_label
operator|->
name|left
operator|&&
operator|!
name|tree_int_cst_lt
argument_list|(
name|value
argument_list|,
name|case_label
operator|->
name|left
operator|->
name|low
argument_list|)
condition|)
return|return
literal|2
return|;
name|new_label
operator|=
operator|(
expr|struct
name|case_node
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|case_node
argument_list|)
argument_list|)
expr_stmt|;
name|new_label
operator|->
name|low
operator|=
name|new_label
operator|->
name|high
operator|=
name|copy_node
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|new_label
operator|->
name|code_label
operator|=
name|label
expr_stmt|;
name|new_label
operator|->
name|left
operator|=
name|case_label
operator|->
name|left
expr_stmt|;
name|case_label
operator|->
name|left
operator|=
name|new_label
expr_stmt|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|num_ranges
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
condition|)
return|return
literal|2
return|;
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|=
name|label
expr_stmt|;
block|}
name|expand_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns the number of possible values of TYPE.    Returns -1 if the number is unknown or variable.    Returns -2 if the number does not fit in a HOST_WIDE_INT.    Sets *SPARENESS to 2 if TYPE is an ENUMERAL_TYPE whose values    do not increase monotonically (there may be duplicates);    to 1 if the values increase monotonically, but not always by 1;    otherwise sets it to 0.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|all_cases_count
parameter_list|(
name|type
parameter_list|,
name|spareness
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
modifier|*
name|spareness
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|count
decl_stmt|,
name|count_high
init|=
literal|0
decl_stmt|;
operator|*
name|spareness
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|t
decl_stmt|;
case|case
name|BOOLEAN_TYPE
case|:
name|count
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|CHAR_TYPE
case|:
name|count
operator|=
literal|1
operator|<<
name|BITS_PER_UNIT
expr_stmt|;
break|break;
default|default:
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
operator|-
literal|1
return|;
else|else
block|{
comment|/* count 	     = TREE_INT_CST_LOW (TYPE_MAX_VALUE (type)) 	     - TREE_INT_CST_LOW (TYPE_MIN_VALUE (type)) + 1 	     but with overflow checking. */
name|tree
name|mint
init|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|maxt
init|=
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|lo
decl_stmt|,
name|hi
decl_stmt|;
name|neg_double
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|mint
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|mint
argument_list|)
argument_list|,
operator|&
name|lo
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|maxt
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|maxt
argument_list|)
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|,
operator|&
name|lo
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|lo
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi
operator|!=
literal|0
operator|||
name|lo
operator|<
literal|0
condition|)
return|return
operator|-
literal|2
return|;
name|count
operator|=
name|lo
expr_stmt|;
block|}
break|break;
case|case
name|ENUMERAL_TYPE
case|:
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|+
name|count
operator|!=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
operator|*
name|spareness
operator|=
literal|1
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|spareness
operator|==
literal|1
condition|)
block|{
name|tree
name|prev
init|=
name|TREE_VALUE
argument_list|(
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|t
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
init|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|,
name|t
operator|!=
name|NULL_TREE
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|prev
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|spareness
operator|=
literal|2
expr_stmt|;
break|break;
block|}
name|prev
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|count
return|;
block|}
end_function

begin_define
define|#
directive|define
name|BITARRAY_TEST
parameter_list|(
name|ARRAY
parameter_list|,
name|INDEX
parameter_list|)
define|\
value|((ARRAY)[(unsigned)(INDEX) / HOST_BITS_PER_CHAR]\& (1<< ((unsigned)(INDEX) % HOST_BITS_PER_CHAR)))
end_define

begin_define
define|#
directive|define
name|BITARRAY_SET
parameter_list|(
name|ARRAY
parameter_list|,
name|INDEX
parameter_list|)
define|\
value|((ARRAY)[(unsigned)(INDEX) / HOST_BITS_PER_CHAR]\ 			  |= 1<< ((unsigned)(INDEX) % HOST_BITS_PER_CHAR))
end_define

begin_comment
comment|/* Set the elements of the bitstring CASES_SEEN (which has length COUNT),    with the case values we have seen, assuming the case expression    has the given TYPE.    SPARSENESS is as determined by all_cases_count.     The time needed is proportional to COUNT, unless    SPARSENESS is 2, in which case quadratic time is needed.  */
end_comment

begin_function
name|void
name|mark_seen_cases
parameter_list|(
name|type
parameter_list|,
name|cases_seen
parameter_list|,
name|count
parameter_list|,
name|sparseness
parameter_list|)
name|tree
name|type
decl_stmt|;
name|unsigned
name|char
modifier|*
name|cases_seen
decl_stmt|;
name|long
name|count
decl_stmt|;
name|int
name|sparseness
decl_stmt|;
block|{
name|long
name|i
decl_stmt|;
name|tree
name|next_node_to_try
init|=
name|NULL_TREE
decl_stmt|;
name|long
name|next_node_offset
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|case_node
modifier|*
name|n
decl_stmt|;
name|tree
name|val
init|=
name|make_node
argument_list|(
name|INTEGER_CST
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|=
name|type
expr_stmt|;
for|for
control|(
name|n
operator|=
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
block|{
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|low
argument_list|)
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|n
operator|->
name|low
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|n
operator|->
name|high
argument_list|,
name|val
argument_list|)
condition|)
block|{
comment|/* Calculate (into xlo) the "offset" of the integer (val). 	     The element with lowest value has offset 0, the next smallest 	     element has offset 1, etc.  */
name|HOST_WIDE_INT
name|xlo
decl_stmt|,
name|xhi
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|sparseness
operator|==
literal|2
condition|)
block|{
comment|/* This less efficient loop is only needed to handle 		 duplicate case values (multiple enum constants 		 with the same value).  */
for|for
control|(
name|t
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
operator|,
name|xlo
operator|=
literal|0
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|,
name|xlo
operator|++
control|)
block|{
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|val
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|BITARRAY_SET
argument_list|(
name|cases_seen
argument_list|,
name|xlo
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sparseness
operator|&&
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* The TYPE_VALUES will be in increasing order, so 		     starting searching where we last ended.  */
name|t
operator|=
name|next_node_to_try
expr_stmt|;
name|xlo
operator|=
name|next_node_offset
expr_stmt|;
name|xhi
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
block|{
name|t
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|xlo
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|val
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|next_node_to_try
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|next_node_offset
operator|=
name|xlo
operator|+
literal|1
expr_stmt|;
break|break;
block|}
name|xlo
operator|++
expr_stmt|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|next_node_to_try
condition|)
break|break;
block|}
block|}
else|else
block|{
name|t
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|neg_double
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|xlo
argument_list|,
operator|&
name|xhi
argument_list|)
expr_stmt|;
else|else
name|xlo
operator|=
name|xhi
operator|=
literal|0
expr_stmt|;
name|add_double
argument_list|(
name|xlo
argument_list|,
name|xhi
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
argument_list|,
operator|&
name|xlo
argument_list|,
operator|&
name|xhi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xhi
operator|==
literal|0
operator|&&
name|xlo
operator|>=
literal|0
operator|&&
name|xlo
operator|<
name|count
condition|)
name|BITARRAY_SET
argument_list|(
name|cases_seen
argument_list|,
name|xlo
argument_list|)
expr_stmt|;
block|}
name|add_double
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
argument_list|,
operator|&
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Called when the index of a switch statement is an enumerated type    and there is no default label.     Checks that all enumeration literals are covered by the case    expressions of a switch.  Also, warn if there are any extra    switch cases that are *not* elements of the enumerated type.     If all enumeration literals were covered by the case expressions,    turn one of the expressions into the default expression since it should    not be possible to fall through such a switch.  */
end_comment

begin_function
name|void
name|check_for_full_enumeration_handling
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
specifier|register
name|struct
name|case_node
modifier|*
name|n
decl_stmt|;
specifier|register
name|struct
name|case_node
modifier|*
modifier|*
name|l
decl_stmt|;
specifier|register
name|tree
name|chain
decl_stmt|;
name|int
name|all_values
init|=
literal|1
decl_stmt|;
comment|/* True iff the selector type is a numbered set mode. */
name|int
name|sparseness
init|=
literal|0
decl_stmt|;
comment|/* The number of possible selector values. */
name|HOST_WIDE_INT
name|size
decl_stmt|;
comment|/* For each possible selector value. a one iff it has been matched      by a case value alternative. */
name|unsigned
name|char
modifier|*
name|cases_seen
decl_stmt|;
comment|/* The allocated size of cases_seen, in chars. */
name|long
name|bytes_needed
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|bc_check_for_full_enumeration_handling
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|warn_switch
condition|)
return|return;
name|size
operator|=
name|all_cases_count
argument_list|(
name|type
argument_list|,
operator|&
name|sparseness
argument_list|)
expr_stmt|;
name|bytes_needed
operator|=
operator|(
name|size
operator|+
name|HOST_BITS_PER_CHAR
operator|)
operator|/
name|HOST_BITS_PER_CHAR
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|<
literal|600000
comment|/* We deliberately use malloc here - not xmalloc. */
operator|&&
operator|(
name|cases_seen
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bytes_needed
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|long
name|i
decl_stmt|;
name|tree
name|v
init|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|cases_seen
argument_list|,
name|bytes_needed
argument_list|)
expr_stmt|;
comment|/* The time complexity of this code is normally O(N), where 	 N being the number of members in the enumerated type. 	 However, if type is a ENUMERAL_TYPE whose values do not 	 increase monotonically, quadratic time may be needed. */
name|mark_seen_cases
argument_list|(
name|type
argument_list|,
name|cases_seen
argument_list|,
name|size
argument_list|,
name|sparseness
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|v
operator|!=
name|NULL_TREE
operator|&&
name|i
operator|<
name|size
condition|;
name|i
operator|++
operator|,
name|v
operator|=
name|TREE_CHAIN
argument_list|(
name|v
argument_list|)
control|)
block|{
if|if
condition|(
name|BITARRAY_TEST
argument_list|(
name|cases_seen
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"enumeration value `%s' not handled in switch"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|v
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|cases_seen
argument_list|)
expr_stmt|;
block|}
comment|/* Now we go the other way around; we warn if there are case      expressions that don't correspond to enumerators.  This can      occur since C and C++ don't enforce type-checking of      assignments to enumeration variables. */
if|if
condition|(
name|warn_switch
condition|)
for|for
control|(
name|n
operator|=
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
block|{
for|for
control|(
name|chain
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
init|;
name|chain
operator|&&
operator|!
name|tree_int_cst_equal
argument_list|(
name|n
operator|->
name|low
argument_list|,
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|chain
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"case value `%d' not in enumerated type"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|low
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"case value `%d' not in enumerated type `%s'"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|low
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|)
condition|?
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
else|:
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|n
operator|->
name|low
argument_list|,
name|n
operator|->
name|high
argument_list|)
condition|)
block|{
for|for
control|(
name|chain
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
init|;
name|chain
operator|&&
operator|!
name|tree_int_cst_equal
argument_list|(
name|n
operator|->
name|high
argument_list|,
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|chain
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"case value `%d' not in enumerated type"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|high
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"case value `%d' not in enumerated type `%s'"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|high
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|)
condition|?
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
else|:
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|#
directive|if
literal|0
comment|/* ??? This optimization is disabled because it causes valid programs to      fail.  ANSI C does not guarantee that an expression with enum type      will have a value that is the same as one of the enumeration literals.  */
comment|/* If all values were found as case labels, make one of them the default      label.  Thus, this switch will never fall through.  We arbitrarily pick      the last one to make the default since this is likely the most      efficient choice.  */
block|if (all_values)     {       for (l =&case_stack->data.case_stmt.case_list; 	   (*l)->right != 0; 	   l =&(*l)->right) 	;        case_stack->data.case_stmt.default_label = (*l)->code_label;       *l = 0;     }
endif|#
directive|endif
comment|/* 0 */
block|}
end_function

begin_comment
comment|/* Check that all enumeration literals are covered by the case    expressions of a switch.  Also warn if there are any cases    that are not elements of the enumerated type.  */
end_comment

begin_function
specifier|static
name|void
name|bc_check_for_full_enumeration_handling
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thiscase
init|=
name|case_stack
decl_stmt|;
name|struct
name|case_node
modifier|*
name|c
decl_stmt|;
name|tree
name|e
decl_stmt|;
comment|/* Check for enums not handled.  */
for|for
control|(
name|e
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
init|;
name|e
condition|;
name|e
operator|=
name|TREE_CHAIN
argument_list|(
name|e
argument_list|)
control|)
block|{
for|for
control|(
name|c
operator|=
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|->
name|left
init|;
name|c
operator|&&
name|tree_int_cst_lt
argument_list|(
name|c
operator|->
name|high
argument_list|,
name|TREE_VALUE
argument_list|(
name|e
argument_list|)
argument_list|)
condition|;
name|c
operator|=
name|c
operator|->
name|left
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|&&
name|tree_int_cst_equal
argument_list|(
name|c
operator|->
name|low
argument_list|,
name|TREE_VALUE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"enumerated value `%s' not handled in switch"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|e
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Check for cases not in the enumeration.  */
for|for
control|(
name|c
operator|=
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|->
name|left
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|left
control|)
block|{
for|for
control|(
name|e
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
init|;
name|e
operator|&&
operator|!
name|tree_int_cst_equal
argument_list|(
name|c
operator|->
name|low
argument_list|,
name|TREE_VALUE
argument_list|(
name|e
argument_list|)
argument_list|)
condition|;
name|e
operator|=
name|TREE_CHAIN
argument_list|(
name|e
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
name|warning
argument_list|(
literal|"case value `%d' not in enumerated type `%s'"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|c
operator|->
name|low
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|?
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
else|:
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Terminate a case (Pascal) or switch (C) statement    in which ORIG_INDEX is the expression to be tested.    Generate the code to test it and jump to the right place.  */
end_comment

begin_function
name|void
name|expand_end_case
parameter_list|(
name|orig_index
parameter_list|)
name|tree
name|orig_index
decl_stmt|;
block|{
name|tree
name|minval
decl_stmt|,
name|maxval
decl_stmt|,
name|range
decl_stmt|,
name|orig_minval
decl_stmt|;
name|rtx
name|default_label
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|case_node
modifier|*
name|n
decl_stmt|;
name|int
name|count
decl_stmt|;
name|rtx
name|index
decl_stmt|;
name|rtx
name|table_label
decl_stmt|;
name|int
name|ncases
decl_stmt|;
name|rtx
modifier|*
name|labelvec
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|before_case
decl_stmt|;
specifier|register
name|struct
name|nesting
modifier|*
name|thiscase
init|=
name|case_stack
decl_stmt|;
name|tree
name|index_expr
decl_stmt|,
name|index_type
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|bc_expand_end_case
argument_list|(
name|orig_index
argument_list|)
expr_stmt|;
return|return;
block|}
name|table_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|index_expr
operator|=
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|index_expr
expr_stmt|;
name|index_type
operator|=
name|TREE_TYPE
argument_list|(
name|index_expr
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|index_type
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* An ERROR_MARK occurs for various reasons including invalid data type.  */
if|if
condition|(
name|index_type
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* If switch expression was an enumerated type, check that all 	 enumeration literals are covered by the cases. 	 No sense trying this if there's a default case, however.  */
if|if
condition|(
operator|!
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_index
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|index_expr
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|check_for_full_enumeration_handling
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_index
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is the first label, warn if any insns have been emitted.  */
if|if
condition|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|seenlabel
operator|==
literal|0
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|insn
operator|!=
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|start
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"unreachable code at beginning of %s"
argument_list|,
name|case_stack
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|printname
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we don't have a default-label, create one here, 	 after the body of the switch.  */
if|if
condition|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|==
literal|0
condition|)
block|{
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|expand_label
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
argument_list|)
expr_stmt|;
block|}
name|default_label
operator|=
name|label_rtx
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
argument_list|)
expr_stmt|;
name|before_case
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Simplify the case-list before we count it.  */
name|group_case_nodes
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
argument_list|)
expr_stmt|;
comment|/* Get upper and lower bounds of case values. 	 Also convert all the case values to the index expr's data type.  */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
block|{
comment|/* Check low and high label values are integers.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
operator|->
name|low
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
operator|->
name|high
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|abort
argument_list|()
expr_stmt|;
name|n
operator|->
name|low
operator|=
name|convert
argument_list|(
name|index_type
argument_list|,
name|n
operator|->
name|low
argument_list|)
expr_stmt|;
name|n
operator|->
name|high
operator|=
name|convert
argument_list|(
name|index_type
argument_list|,
name|n
operator|->
name|high
argument_list|)
expr_stmt|;
comment|/* Count the elements and track the largest and smallest 	     of them (treating them as signed even if they are not).  */
if|if
condition|(
name|count
operator|++
operator|==
literal|0
condition|)
block|{
name|minval
operator|=
name|n
operator|->
name|low
expr_stmt|;
name|maxval
operator|=
name|n
operator|->
name|high
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|INT_CST_LT
argument_list|(
name|n
operator|->
name|low
argument_list|,
name|minval
argument_list|)
condition|)
name|minval
operator|=
name|n
operator|->
name|low
expr_stmt|;
if|if
condition|(
name|INT_CST_LT
argument_list|(
name|maxval
argument_list|,
name|n
operator|->
name|high
argument_list|)
condition|)
name|maxval
operator|=
name|n
operator|->
name|high
expr_stmt|;
block|}
comment|/* A range counts double, since it requires two compares.  */
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|n
operator|->
name|low
argument_list|,
name|n
operator|->
name|high
argument_list|)
condition|)
name|count
operator|++
expr_stmt|;
block|}
name|orig_minval
operator|=
name|minval
expr_stmt|;
comment|/* Compute span of values.  */
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
name|range
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index_type
argument_list|,
name|maxval
argument_list|,
name|minval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|expand_expr
argument_list|(
name|index_expr
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|emit_jump
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
block|}
comment|/* If range of values is much bigger than number of values, 	 make a sequence of conditional branches instead of a dispatch. 	 If the switch-index is a constant, do it this way 	 because we can optimize it.  */
ifndef|#
directive|ifndef
name|CASE_VALUES_THRESHOLD
ifdef|#
directive|ifdef
name|HAVE_casesi
define|#
directive|define
name|CASE_VALUES_THRESHOLD
value|(HAVE_casesi ? 4 : 5)
else|#
directive|else
comment|/* If machine does not have a case insn that compares the 	 bounds, this means extra overhead for dispatch tables 	 which raises the threshold for using them.  */
define|#
directive|define
name|CASE_VALUES_THRESHOLD
value|5
endif|#
directive|endif
comment|/* HAVE_casesi */
endif|#
directive|endif
comment|/* CASE_VALUES_THRESHOLD */
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|range
argument_list|)
operator|!=
literal|0
operator|||
name|count
operator|<
name|CASE_VALUES_THRESHOLD
operator|||
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|range
argument_list|)
argument_list|)
operator|>
literal|10
operator|*
name|count
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|index_expr
argument_list|)
operator|==
name|INTEGER_CST
comment|/* These will reduce to a constant.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|index_expr
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|index_expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|index_expr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_FUNCTION_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|index_expr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|BUILT_IN_CLASSIFY_TYPE
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|index_expr
argument_list|)
operator|==
name|COMPOUND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|index_expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|)
condition|)
block|{
name|index
operator|=
name|expand_expr
argument_list|(
name|index_expr
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the index is a short or char that we do not have 	     an insn to handle comparisons directly, convert it to 	     a full integer now, rather than letting each comparison 	     generate the conversion.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|index
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|index
argument_list|)
index|]
operator|.
name|insn_code
operator|==
name|CODE_FOR_nothing
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|wider_mode
decl_stmt|;
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE
argument_list|(
name|index
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
if|if
condition|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|index
operator|=
name|convert_to_mode
argument_list|(
name|wider_mode
argument_list|,
name|index
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|emit_queue
argument_list|()
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|index
operator|=
name|protect_from_queue
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|MEM
condition|)
name|index
operator|=
name|copy_to_reg
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|CONST_INT
operator|||
name|TREE_CODE
argument_list|(
name|index_expr
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* Make a tree node with the proper constant value 		 if we don't already have one.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index_expr
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|index_expr
operator|=
name|build_int_2
argument_list|(
name|INTVAL
argument_list|(
name|index
argument_list|)
argument_list|,
name|unsignedp
operator|||
name|INTVAL
argument_list|(
name|index
argument_list|)
operator|>=
literal|0
condition|?
literal|0
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
name|index_expr
operator|=
name|convert
argument_list|(
name|index_type
argument_list|,
name|index_expr
argument_list|)
expr_stmt|;
block|}
comment|/* For constant index expressions we need only 		 issue a unconditional branch to the appropriate 		 target code.  The job of removing any unreachable 		 code is left to the optimisation phase if the 		 "-O" option is specified.  */
for|for
control|(
name|n
operator|=
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
if|if
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|index_expr
argument_list|,
name|n
operator|->
name|low
argument_list|)
operator|&&
operator|!
name|tree_int_cst_lt
argument_list|(
name|n
operator|->
name|high
argument_list|,
name|index_expr
argument_list|)
condition|)
break|break;
if|if
condition|(
name|n
condition|)
name|emit_jump
argument_list|(
name|label_rtx
argument_list|(
name|n
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_jump
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the index expression is not constant we generate 		 a binary decision tree to select the appropriate 		 target code.  This is done as follows:  		 The list of cases is rearranged into a binary tree, 		 nearly optimal assuming equal probability for each case.  		 The tree is transformed into RTL, eliminating 		 redundant test conditions at the same time.  		 If program flow could reach the end of the 		 decision tree an unconditional jump to the 		 default code is emitted.  */
name|use_cost_table
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_index
argument_list|)
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|estimate_case_costs
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
argument_list|)
operator|)
expr_stmt|;
name|balance_case_nodes
argument_list|(
operator|&
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
name|emit_jump_if_reachable
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|win
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_casesi
if|if
condition|(
name|HAVE_casesi
condition|)
block|{
name|enum
name|machine_mode
name|index_mode
init|=
name|SImode
decl_stmt|;
name|int
name|index_bits
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|index_mode
argument_list|)
decl_stmt|;
name|rtx
name|op1
decl_stmt|,
name|op2
decl_stmt|;
name|enum
name|machine_mode
name|op_mode
decl_stmt|;
comment|/* Convert the index to SImode.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|index_type
argument_list|)
argument_list|)
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|index_mode
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|omode
init|=
name|TYPE_MODE
argument_list|(
name|index_type
argument_list|)
decl_stmt|;
name|rtx
name|rangertx
init|=
name|expand_expr
argument_list|(
name|range
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* We must handle the endpoints in the original mode.  */
name|index_expr
operator|=
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index_type
argument_list|,
name|index_expr
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|minval
operator|=
name|integer_zero_node
expr_stmt|;
name|index
operator|=
name|expand_expr
argument_list|(
name|index_expr
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|rangertx
argument_list|,
name|index
argument_list|,
name|LTU
argument_list|,
name|NULL_RTX
argument_list|,
name|omode
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_bltu
argument_list|(
name|default_label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now we can safely truncate.  */
name|index
operator|=
name|convert_to_mode
argument_list|(
name|index_mode
argument_list|,
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|index_type
argument_list|)
operator|!=
name|index_mode
condition|)
block|{
name|index_expr
operator|=
name|convert
argument_list|(
name|type_for_size
argument_list|(
name|index_bits
argument_list|,
literal|0
argument_list|)
argument_list|,
name|index_expr
argument_list|)
expr_stmt|;
name|index_type
operator|=
name|TREE_TYPE
argument_list|(
name|index_expr
argument_list|)
expr_stmt|;
block|}
name|index
operator|=
name|expand_expr
argument_list|(
name|index_expr
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|emit_queue
argument_list|()
expr_stmt|;
name|index
operator|=
name|protect_from_queue
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|op_mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_casesi
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_casesi
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|index
argument_list|,
name|op_mode
argument_list|)
condition|)
name|index
operator|=
name|copy_to_mode_reg
argument_list|(
name|op_mode
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|minval
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op_mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_casesi
index|]
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_casesi
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|op1
argument_list|,
name|op_mode
argument_list|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|op_mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|op2
operator|=
name|expand_expr
argument_list|(
name|range
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op_mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_casesi
index|]
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_casesi
index|]
index|[
literal|2
index|]
call|)
argument_list|(
name|op2
argument_list|,
name|op_mode
argument_list|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|op_mode
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_casesi
argument_list|(
name|index
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|table_label
argument_list|,
name|default_label
argument_list|)
argument_list|)
expr_stmt|;
name|win
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_tablejump
if|if
condition|(
operator|!
name|win
operator|&&
name|HAVE_tablejump
condition|)
block|{
name|index_expr
operator|=
name|convert
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index_type
argument_list|,
name|index_expr
argument_list|,
name|minval
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|index_type
operator|=
name|TREE_TYPE
argument_list|(
name|index_expr
argument_list|)
expr_stmt|;
name|index
operator|=
name|expand_expr
argument_list|(
name|index_expr
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|index
operator|=
name|protect_from_queue
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|do_tablejump
argument_list|(
name|index
argument_list|,
name|TYPE_MODE
argument_list|(
name|index_type
argument_list|)
argument_list|,
name|expand_expr
argument_list|(
name|range
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|table_label
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
name|win
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|win
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Get table of labels to jump to, in order of case index.  */
name|ncases
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|range
argument_list|)
operator|+
literal|1
expr_stmt|;
name|labelvec
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|ncases
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|labelvec
argument_list|,
name|ncases
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
block|{
specifier|register
name|HOST_WIDE_INT
name|i
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|low
argument_list|)
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|orig_minval
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|labelvec
index|[
name|i
index|]
operator|=
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|Pmode
argument_list|,
name|label_rtx
argument_list|(
name|n
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
name|TREE_INT_CST_LOW
argument_list|(
name|orig_minval
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|high
argument_list|)
condition|)
break|break;
name|i
operator|++
expr_stmt|;
block|}
block|}
comment|/* Fill in the gaps with the default.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncases
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|labelvec
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|labelvec
index|[
name|i
index|]
operator|=
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|Pmode
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
comment|/* Output the table */
name|emit_label
argument_list|(
name|table_label
argument_list|)
expr_stmt|;
comment|/* This would be a lot nicer if CASE_VECTOR_PC_RELATIVE 	     were an expression, instead of an #ifdef/#ifndef.  */
if|if
condition|(
ifdef|#
directive|ifdef
name|CASE_VECTOR_PC_RELATIVE
literal|1
operator|||
endif|#
directive|endif
name|flag_pic
condition|)
name|emit_jump_insn
argument_list|(
name|gen_rtx
argument_list|(
name|ADDR_DIFF_VEC
argument_list|,
name|CASE_VECTOR_MODE
argument_list|,
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|Pmode
argument_list|,
name|table_label
argument_list|)
argument_list|,
name|gen_rtvec_v
argument_list|(
name|ncases
argument_list|,
name|labelvec
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_jump_insn
argument_list|(
name|gen_rtx
argument_list|(
name|ADDR_VEC
argument_list|,
name|CASE_VECTOR_MODE
argument_list|,
name|gen_rtvec_v
argument_list|(
name|ncases
argument_list|,
name|labelvec
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the case insn drops through the table, 	     after the table we must jump to the default-label. 	     Otherwise record no drop-through after the table.  */
ifdef|#
directive|ifdef
name|CASE_DROPS_THROUGH
name|emit_jump
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_barrier
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|before_case
operator|=
name|squeeze_notes
argument_list|(
name|NEXT_INSN
argument_list|(
name|before_case
argument_list|)
argument_list|,
name|get_last_insn
argument_list|()
argument_list|)
expr_stmt|;
name|reorder_insns
argument_list|(
name|before_case
argument_list|,
name|get_last_insn
argument_list|()
argument_list|,
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|start
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|thiscase
operator|->
name|exit_label
condition|)
name|emit_label
argument_list|(
name|thiscase
operator|->
name|exit_label
argument_list|)
expr_stmt|;
name|POPSTACK
argument_list|(
name|case_stack
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Terminate a case statement.  EXPR is the original index    expression.  */
end_comment

begin_function
specifier|static
name|void
name|bc_expand_end_case
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|struct
name|nesting
modifier|*
name|thiscase
init|=
name|case_stack
decl_stmt|;
name|enum
name|bytecode_opcode
name|opcode
decl_stmt|;
name|struct
name|bc_label
modifier|*
name|jump_label
decl_stmt|;
name|struct
name|case_node
modifier|*
name|c
decl_stmt|;
name|bc_emit_bytecode
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|bc_emit_bytecode_labelref
argument_list|(
name|BYTECODE_BC_LABEL
argument_list|(
name|thiscase
operator|->
name|exit_label
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PRINT_CODE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Now that the size of the jump table is known, emit the actual      indexed jump instruction.  */
name|bc_emit_bytecode_labeldef
argument_list|(
name|BYTECODE_BC_LABEL
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|skip_label
argument_list|)
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|TYPE_MODE
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
argument_list|)
operator|==
name|SImode
condition|?
name|TREE_UNSIGNED
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
argument_list|)
condition|?
name|caseSU
else|:
name|caseSI
else|:
name|TREE_UNSIGNED
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
argument_list|)
condition|?
name|caseDU
else|:
name|caseDI
expr_stmt|;
name|bc_emit_bytecode
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
comment|/* Now emit the case instructions literal arguments, in order.      In addition to the value on the stack, it uses:      1.  The address of the jump table.      2.  The size of the jump table.      3.  The default label.  */
name|jump_label
operator|=
name|bc_get_bytecode_label
argument_list|()
expr_stmt|;
name|bc_emit_bytecode_labelref
argument_list|(
name|jump_label
argument_list|)
expr_stmt|;
name|bc_emit_bytecode_const
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|num_ranges
argument_list|,
sizeof|sizeof
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|num_ranges
argument_list|)
expr_stmt|;
if|if
condition|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
condition|)
name|bc_emit_bytecode_labelref
argument_list|(
name|BYTECODE_BC_LABEL
argument_list|(
name|DECL_RTL
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|bc_emit_bytecode_labelref
argument_list|(
name|BYTECODE_BC_LABEL
argument_list|(
name|thiscase
operator|->
name|exit_label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output the jump table.  */
name|bc_align_bytecode
argument_list|(
literal|3
comment|/* PTR_ALIGN */
argument_list|)
expr_stmt|;
name|bc_emit_bytecode_labeldef
argument_list|(
name|jump_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
argument_list|)
operator|==
name|SImode
condition|)
for|for
control|(
name|c
operator|=
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|->
name|left
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|left
control|)
block|{
name|opcode
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|c
operator|->
name|low
argument_list|)
expr_stmt|;
name|bc_emit_bytecode_const
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|opcode
argument_list|,
sizeof|sizeof
name|opcode
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|c
operator|->
name|high
argument_list|)
expr_stmt|;
name|bc_emit_bytecode_const
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|opcode
argument_list|,
sizeof|sizeof
name|opcode
argument_list|)
expr_stmt|;
name|bc_emit_bytecode_labelref
argument_list|(
name|BYTECODE_BC_LABEL
argument_list|(
name|DECL_RTL
argument_list|(
name|c
operator|->
name|code_label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|nominal_type
argument_list|)
operator|==
name|DImode
condition|)
for|for
control|(
name|c
operator|=
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|case_list
operator|->
name|left
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|left
control|)
block|{
name|bc_emit_bytecode_DI_const
argument_list|(
name|c
operator|->
name|low
argument_list|)
expr_stmt|;
name|bc_emit_bytecode_DI_const
argument_list|(
name|c
operator|->
name|high
argument_list|)
expr_stmt|;
name|bc_emit_bytecode_labelref
argument_list|(
name|BYTECODE_BC_LABEL
argument_list|(
name|DECL_RTL
argument_list|(
name|c
operator|->
name|code_label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Bad mode */
name|abort
argument_list|()
expr_stmt|;
name|bc_emit_bytecode_labeldef
argument_list|(
name|BYTECODE_BC_LABEL
argument_list|(
name|thiscase
operator|->
name|exit_label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Possibly issue enumeration warnings.  */
if|if
condition|(
operator|!
name|thiscase
operator|->
name|data
operator|.
name|case_stmt
operator|.
name|default_label
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|warn_switch
condition|)
name|check_for_full_enumeration_handling
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PRINT_CODE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|POPSTACK
argument_list|(
name|case_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return unique bytecode ID. */
end_comment

begin_function
name|int
name|bc_new_uid
parameter_list|()
block|{
specifier|static
name|int
name|bc_uid
init|=
literal|0
decl_stmt|;
return|return
operator|(
operator|++
name|bc_uid
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Generate code to jump to LABEL if OP1 and OP2 are equal.  */
end_comment

begin_function
specifier|static
name|void
name|do_jump_if_equal
parameter_list|(
name|op1
parameter_list|,
name|op2
parameter_list|,
name|label
parameter_list|,
name|unsignedp
parameter_list|)
name|rtx
name|op1
decl_stmt|,
name|op2
decl_stmt|,
name|label
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|op2
argument_list|)
condition|)
name|emit_jump
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|op1
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op2
argument_list|)
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_beq
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Not all case values are encountered equally.  This function    uses a heuristic to weight case labels, in cases where that    looks like a reasonable thing to do.     Right now, all we try to guess is text, and we establish the    following weights:  	chars above space:	16 	digits:			16 	default:		12 	space, punct:		8 	tab:			4 	newline:		2 	other "\" chars:	1 	remaining chars:	0     If we find any cases in the switch that are not either -1 or in the range    of valid ASCII characters, or are control characters other than those    commonly used with "\", don't treat this switch scanning text.     Return 1 if these nodes are suitable for cost estimation, otherwise    return 0.  */
end_comment

begin_function
specifier|static
name|int
name|estimate_case_costs
parameter_list|(
name|node
parameter_list|)
name|case_node_ptr
name|node
decl_stmt|;
block|{
name|tree
name|min_ascii
init|=
name|build_int_2
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|tree
name|max_ascii
init|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|node
operator|->
name|high
argument_list|)
argument_list|,
name|build_int_2
argument_list|(
literal|127
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|case_node_ptr
name|n
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If we haven't already made the cost table, make it now.  Note that the      lower bound of the table is -1, not zero.  */
if|if
condition|(
name|cost_table
operator|==
name|NULL
condition|)
block|{
name|cost_table
operator|=
operator|(
operator|(
name|short
operator|*
operator|)
name|xmalloc
argument_list|(
literal|129
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
operator|)
operator|+
literal|1
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|cost_table
operator|-
literal|1
operator|)
argument_list|,
literal|129
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isalnum
argument_list|(
name|i
argument_list|)
condition|)
name|cost_table
index|[
name|i
index|]
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|ispunct
argument_list|(
name|i
argument_list|)
condition|)
name|cost_table
index|[
name|i
index|]
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|iscntrl
argument_list|(
name|i
argument_list|)
condition|)
name|cost_table
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|cost_table
index|[
literal|' '
index|]
operator|=
literal|8
expr_stmt|;
name|cost_table
index|[
literal|'\t'
index|]
operator|=
literal|4
expr_stmt|;
name|cost_table
index|[
literal|'\0'
index|]
operator|=
literal|4
expr_stmt|;
name|cost_table
index|[
literal|'\n'
index|]
operator|=
literal|2
expr_stmt|;
name|cost_table
index|[
literal|'\f'
index|]
operator|=
literal|1
expr_stmt|;
name|cost_table
index|[
literal|'\v'
index|]
operator|=
literal|1
expr_stmt|;
name|cost_table
index|[
literal|'\b'
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* See if all the case expressions look like text.  It is text if the      constant is>= -1 and the highest constant is<= 127.  Do all comparisons      as signed arithmetic since we don't want to ever access cost_table with a      value less than -1.  Also check that none of the constants in a range      are strange control characters.  */
for|for
control|(
name|n
operator|=
name|node
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|right
control|)
block|{
if|if
condition|(
operator|(
name|INT_CST_LT
argument_list|(
name|n
operator|->
name|low
argument_list|,
name|min_ascii
argument_list|)
operator|)
operator|||
name|INT_CST_LT
argument_list|(
name|max_ascii
argument_list|,
name|n
operator|->
name|high
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|low
argument_list|)
init|;
name|i
operator|<=
name|TREE_INT_CST_LOW
argument_list|(
name|n
operator|->
name|high
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cost_table
index|[
name|i
index|]
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* All interesting values are within the range of interesting      ASCII characters.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Scan an ordered list of case nodes    combining those with consecutive values or ranges.     Eg. three separate entries 1: 2: 3: become one entry 1..3:  */
end_comment

begin_function
specifier|static
name|void
name|group_case_nodes
parameter_list|(
name|head
parameter_list|)
name|case_node_ptr
name|head
decl_stmt|;
block|{
name|case_node_ptr
name|node
init|=
name|head
decl_stmt|;
while|while
condition|(
name|node
condition|)
block|{
name|rtx
name|lb
init|=
name|next_real_insn
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
decl_stmt|;
name|case_node_ptr
name|np
init|=
name|node
decl_stmt|;
comment|/* Try to group the successors of NODE with NODE.  */
while|while
condition|(
operator|(
operator|(
name|np
operator|=
name|np
operator|->
name|right
operator|)
operator|!=
literal|0
operator|)
comment|/* Do they jump to the same place?  */
operator|&&
name|next_real_insn
argument_list|(
name|label_rtx
argument_list|(
name|np
operator|->
name|code_label
argument_list|)
argument_list|)
operator|==
name|lb
comment|/* Are their ranges consecutive?  */
operator|&&
name|tree_int_cst_equal
argument_list|(
name|np
operator|->
name|low
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|node
operator|->
name|high
argument_list|)
argument_list|,
name|node
operator|->
name|high
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|)
comment|/* An overflow is not consecutive.  */
operator|&&
name|tree_int_cst_lt
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|node
operator|->
name|high
argument_list|)
argument_list|,
name|node
operator|->
name|high
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|node
operator|->
name|high
operator|=
name|np
operator|->
name|high
expr_stmt|;
block|}
comment|/* NP is the first node after NODE which can't be grouped with it. 	 Delete the nodes in between, and move on to that node.  */
name|node
operator|->
name|right
operator|=
name|np
expr_stmt|;
name|node
operator|=
name|np
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Take an ordered list of case nodes    and transform them into a near optimal binary tree,    on the assumption that any target code selection value is as    likely as any other.     The transformation is performed by splitting the ordered    list into two equal sections plus a pivot.  The parts are    then attached to the pivot as left and right branches.  Each    branch is is then transformed recursively.  */
end_comment

begin_function
specifier|static
name|void
name|balance_case_nodes
parameter_list|(
name|head
parameter_list|,
name|parent
parameter_list|)
name|case_node_ptr
modifier|*
name|head
decl_stmt|;
name|case_node_ptr
name|parent
decl_stmt|;
block|{
specifier|register
name|case_node_ptr
name|np
decl_stmt|;
name|np
operator|=
operator|*
name|head
expr_stmt|;
if|if
condition|(
name|np
condition|)
block|{
name|int
name|cost
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|ranges
init|=
literal|0
decl_stmt|;
specifier|register
name|case_node_ptr
modifier|*
name|npp
decl_stmt|;
name|case_node_ptr
name|left
decl_stmt|;
comment|/* Count the number of entries on branch.  Also count the ranges.  */
while|while
condition|(
name|np
condition|)
block|{
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|np
operator|->
name|low
argument_list|,
name|np
operator|->
name|high
argument_list|)
condition|)
block|{
name|ranges
operator|++
expr_stmt|;
if|if
condition|(
name|use_cost_table
condition|)
name|cost
operator|+=
name|cost_table
index|[
name|TREE_INT_CST_LOW
argument_list|(
name|np
operator|->
name|high
argument_list|)
index|]
expr_stmt|;
block|}
if|if
condition|(
name|use_cost_table
condition|)
name|cost
operator|+=
name|cost_table
index|[
name|TREE_INT_CST_LOW
argument_list|(
name|np
operator|->
name|low
argument_list|)
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|np
operator|=
name|np
operator|->
name|right
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|2
condition|)
block|{
comment|/* Split this list if it is long enough for that to help.  */
name|npp
operator|=
name|head
expr_stmt|;
name|left
operator|=
operator|*
name|npp
expr_stmt|;
if|if
condition|(
name|use_cost_table
condition|)
block|{
comment|/* Find the place in the list that bisects the list's total cost, 		 Here I gets half the total cost.  */
name|int
name|n_moved
init|=
literal|0
decl_stmt|;
name|i
operator|=
operator|(
name|cost
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Skip nodes while their cost does not reach that amount.  */
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
operator|(
operator|*
name|npp
operator|)
operator|->
name|low
argument_list|,
operator|(
operator|*
name|npp
operator|)
operator|->
name|high
argument_list|)
condition|)
name|i
operator|-=
name|cost_table
index|[
name|TREE_INT_CST_LOW
argument_list|(
operator|(
operator|*
name|npp
operator|)
operator|->
name|high
argument_list|)
index|]
expr_stmt|;
name|i
operator|-=
name|cost_table
index|[
name|TREE_INT_CST_LOW
argument_list|(
operator|(
operator|*
name|npp
operator|)
operator|->
name|low
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
break|break;
name|npp
operator|=
operator|&
operator|(
operator|*
name|npp
operator|)
operator|->
name|right
expr_stmt|;
name|n_moved
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|n_moved
operator|==
literal|0
condition|)
block|{
comment|/* Leave this branch lopsided, but optimize left-hand 		     side and fill in `parent' fields for right-hand side.  */
name|np
operator|=
operator|*
name|head
expr_stmt|;
name|np
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|balance_case_nodes
argument_list|(
operator|&
name|np
operator|->
name|left
argument_list|,
name|np
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|np
operator|->
name|right
condition|;
name|np
operator|=
name|np
operator|->
name|right
control|)
name|np
operator|->
name|right
operator|->
name|parent
operator|=
name|np
expr_stmt|;
return|return;
block|}
block|}
comment|/* If there are just three nodes, split at the middle one.  */
elseif|else
if|if
condition|(
name|i
operator|==
literal|3
condition|)
name|npp
operator|=
operator|&
operator|(
operator|*
name|npp
operator|)
operator|->
name|right
expr_stmt|;
else|else
block|{
comment|/* Find the place in the list that bisects the list's total cost, 		 where ranges count as 2. 		 Here I gets half the total cost.  */
name|i
operator|=
operator|(
name|i
operator|+
name|ranges
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Skip nodes while their cost does not reach that amount.  */
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
operator|(
operator|*
name|npp
operator|)
operator|->
name|low
argument_list|,
operator|(
operator|*
name|npp
operator|)
operator|->
name|high
argument_list|)
condition|)
name|i
operator|--
expr_stmt|;
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
break|break;
name|npp
operator|=
operator|&
operator|(
operator|*
name|npp
operator|)
operator|->
name|right
expr_stmt|;
block|}
block|}
operator|*
name|head
operator|=
name|np
operator|=
operator|*
name|npp
expr_stmt|;
operator|*
name|npp
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|np
operator|->
name|left
operator|=
name|left
expr_stmt|;
comment|/* Optimize each of the two split parts.  */
name|balance_case_nodes
argument_list|(
operator|&
name|np
operator|->
name|left
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|balance_case_nodes
argument_list|(
operator|&
name|np
operator|->
name|right
argument_list|,
name|np
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Else leave this branch as one level, 	     but fill in `parent' fields.  */
name|np
operator|=
operator|*
name|head
expr_stmt|;
name|np
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
for|for
control|(
init|;
name|np
operator|->
name|right
condition|;
name|np
operator|=
name|np
operator|->
name|right
control|)
name|np
operator|->
name|right
operator|->
name|parent
operator|=
name|np
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Search the parent sections of the case node tree    to see if a test for the lower bound of NODE would be redundant.    INDEX_TYPE is the type of the index expression.     The instructions to generate the case decision tree are    output in the same order as nodes are processed so it is    known that if a parent node checks the range of the current    node minus one that the current node is bounded at its lower    span.  Thus the test would be redundant.  */
end_comment

begin_function
specifier|static
name|int
name|node_has_low_bound
parameter_list|(
name|node
parameter_list|,
name|index_type
parameter_list|)
name|case_node_ptr
name|node
decl_stmt|;
name|tree
name|index_type
decl_stmt|;
block|{
name|tree
name|low_minus_one
decl_stmt|;
name|case_node_ptr
name|pnode
decl_stmt|;
comment|/* If the lower bound of this node is the lowest value in the index type,      we need not test it.  */
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|node
operator|->
name|low
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|index_type
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If this node has a left branch, the value at the left must be less      than that at this node, so it cannot be bounded at the bottom and      we need not bother testing any further.  */
if|if
condition|(
name|node
operator|->
name|left
condition|)
return|return
literal|0
return|;
name|low_minus_one
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|node
operator|->
name|low
argument_list|)
argument_list|,
name|node
operator|->
name|low
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the subtraction above overflowed, we can't verify anything.      Otherwise, look for a parent that tests our value - 1.  */
if|if
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|low_minus_one
argument_list|,
name|node
operator|->
name|low
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|pnode
operator|=
name|node
operator|->
name|parent
init|;
name|pnode
condition|;
name|pnode
operator|=
name|pnode
operator|->
name|parent
control|)
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|low_minus_one
argument_list|,
name|pnode
operator|->
name|high
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Search the parent sections of the case node tree    to see if a test for the upper bound of NODE would be redundant.    INDEX_TYPE is the type of the index expression.     The instructions to generate the case decision tree are    output in the same order as nodes are processed so it is    known that if a parent node checks the range of the current    node plus one that the current node is bounded at its upper    span.  Thus the test would be redundant.  */
end_comment

begin_function
specifier|static
name|int
name|node_has_high_bound
parameter_list|(
name|node
parameter_list|,
name|index_type
parameter_list|)
name|case_node_ptr
name|node
decl_stmt|;
name|tree
name|index_type
decl_stmt|;
block|{
name|tree
name|high_plus_one
decl_stmt|;
name|case_node_ptr
name|pnode
decl_stmt|;
comment|/* If the upper bound of this node is the highest value in the type      of the index expression, we need not test against it.  */
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|index_type
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If this node has a right branch, the value at the right must be greater      than that at this node, so it cannot be bounded at the top and      we need not bother testing any further.  */
if|if
condition|(
name|node
operator|->
name|right
condition|)
return|return
literal|0
return|;
name|high_plus_one
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|node
operator|->
name|high
argument_list|)
argument_list|,
name|node
operator|->
name|high
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the addition above overflowed, we can't verify anything.      Otherwise, look for a parent that tests our value + 1.  */
if|if
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|high_plus_one
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|pnode
operator|=
name|node
operator|->
name|parent
init|;
name|pnode
condition|;
name|pnode
operator|=
name|pnode
operator|->
name|parent
control|)
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|high_plus_one
argument_list|,
name|pnode
operator|->
name|low
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Search the parent sections of the    case node tree to see if both tests for the upper and lower    bounds of NODE would be redundant.  */
end_comment

begin_function
specifier|static
name|int
name|node_is_bounded
parameter_list|(
name|node
parameter_list|,
name|index_type
parameter_list|)
name|case_node_ptr
name|node
decl_stmt|;
name|tree
name|index_type
decl_stmt|;
block|{
return|return
operator|(
name|node_has_low_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
operator|&&
name|node_has_high_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  Emit an unconditional jump to LABEL unless it would be dead code.  */
end_comment

begin_function
specifier|static
name|void
name|emit_jump_if_reachable
parameter_list|(
name|label
parameter_list|)
name|rtx
name|label
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
operator|!=
name|BARRIER
condition|)
name|emit_jump
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit step-by-step code to select a case for the value of INDEX.    The thus generated decision tree follows the form of the    case-node binary tree NODE, whose nodes represent test conditions.    INDEX_TYPE is the type of the index of the switch.     Care is taken to prune redundant tests from the decision tree    by detecting any boundary conditions already checked by    emitted rtx.  (See node_has_high_bound, node_has_low_bound    and node_is_bounded, above.)     Where the test conditions can be shown to be redundant we emit    an unconditional jump to the target code.  As a further    optimization, the subordinates of a tree node are examined to    check for bounded nodes.  In this case conditional and/or    unconditional jumps as a result of the boundary check for the    current node are arranged to target the subordinates associated    code for out of bound conditions on the current node node.     We can assume that when control reaches the code generated here,    the index value has already been compared with the parents    of this node, and determined to be on the same side of each parent    as this node is.  Thus, if this node tests for the value 51,    and a parent tested for 52, we don't need to consider    the possibility of a value greater than 51.  If another parent    tests for the value 50, then this node need not test anything.  */
end_comment

begin_function
specifier|static
name|void
name|emit_case_nodes
parameter_list|(
name|index
parameter_list|,
name|node
parameter_list|,
name|default_label
parameter_list|,
name|index_type
parameter_list|)
name|rtx
name|index
decl_stmt|;
name|case_node_ptr
name|node
decl_stmt|;
name|rtx
name|default_label
decl_stmt|;
name|tree
name|index_type
decl_stmt|;
block|{
comment|/* If INDEX has an unsigned type, we must make unsigned branches.  */
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|index_type
argument_list|)
decl_stmt|;
typedef|typedef
name|rtx
name|rtx_function
parameter_list|()
function_decl|;
name|rtx_function
modifier|*
name|gen_bgt_pat
init|=
name|unsignedp
condition|?
name|gen_bgtu
else|:
name|gen_bgt
decl_stmt|;
name|rtx_function
modifier|*
name|gen_bge_pat
init|=
name|unsignedp
condition|?
name|gen_bgeu
else|:
name|gen_bge
decl_stmt|;
name|rtx_function
modifier|*
name|gen_blt_pat
init|=
name|unsignedp
condition|?
name|gen_bltu
else|:
name|gen_blt
decl_stmt|;
name|rtx_function
modifier|*
name|gen_ble_pat
init|=
name|unsignedp
condition|?
name|gen_bleu
else|:
name|gen_ble
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|index
argument_list|)
decl_stmt|;
comment|/* See if our parents have already tested everything for us.      If they have, emit an unconditional jump for this node.  */
if|if
condition|(
name|node_is_bounded
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
condition|)
name|emit_jump
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|node
operator|->
name|low
argument_list|,
name|node
operator|->
name|high
argument_list|)
condition|)
block|{
comment|/* Node is single valued.  First see if the index expression matches 	 this node and then check our children, if any. */
name|do_jump_if_equal
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|low
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|right
operator|!=
literal|0
operator|&&
name|node
operator|->
name|left
operator|!=
literal|0
condition|)
block|{
comment|/* This node has children on both sides. 	     Dispatch to one side or the other 	     by comparing the index value with this node's value. 	     If one subtree is bounded, check that one first, 	     so we can avoid real branches in the tree.  */
if|if
condition|(
name|node_is_bounded
argument_list|(
name|node
operator|->
name|right
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_insn
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_bgt_pat
call|)
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|right
operator|->
name|code_label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|left
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node_is_bounded
argument_list|(
name|node
operator|->
name|left
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_insn
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_blt_pat
call|)
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|left
operator|->
name|code_label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|right
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Neither node is bounded.  First distinguish the two sides; 		 then emit the code for one side at a time.  */
name|tree
name|test_label
init|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
comment|/* See if the value is on the right.  */
name|emit_cmp_insn
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_bgt_pat
call|)
argument_list|(
name|label_rtx
argument_list|(
name|test_label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Value must be on the left. 		 Handle the left-hand subtree.  */
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|left
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
comment|/* If left-hand subtree does nothing, 		 go to default.  */
name|emit_jump_if_reachable
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
comment|/* Code branches here for the right-hand subtree.  */
name|expand_label
argument_list|(
name|test_label
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|right
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|right
operator|!=
literal|0
operator|&&
name|node
operator|->
name|left
operator|==
literal|0
condition|)
block|{
comment|/* Here we have a right child but no left so we issue conditional 	     branch to default and process the right child.  	     Omit the conditional branch to default if we it avoid only one 	     right child; it costs too much space to save so little time.  */
if|if
condition|(
name|node
operator|->
name|right
operator|->
name|right
operator|||
name|node
operator|->
name|right
operator|->
name|left
operator|||
operator|!
name|tree_int_cst_equal
argument_list|(
name|node
operator|->
name|right
operator|->
name|low
argument_list|,
name|node
operator|->
name|right
operator|->
name|high
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|node_has_low_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_insn
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_blt_pat
call|)
argument_list|(
name|default_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|right
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We cannot process node->right normally 	       since we haven't ruled out the numbers less than 	       this node's value.  So handle node->right explicitly.  */
name|do_jump_if_equal
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|right
operator|->
name|low
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|right
operator|->
name|code_label
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|right
operator|==
literal|0
operator|&&
name|node
operator|->
name|left
operator|!=
literal|0
condition|)
block|{
comment|/* Just one subtree, on the left.  */
if|#
directive|if
literal|0
comment|/* The following code and comment were formerly part 	 of the condition here, but they didn't work 	 and I don't understand what the idea was.  -- rms.  */
comment|/* If our "most probable entry" is less probable 	     than the default label, emit a jump to 	     the default label using condition codes 	     already lying around.  With no right branch, 	     a branch-greater-than will get us to the default 	     label correctly.  */
block|if (use_cost_table&& cost_table[TREE_INT_CST_LOW (node->high)]< 12) 	    ;
endif|#
directive|endif
comment|/* 0 */
if|if
condition|(
name|node
operator|->
name|left
operator|->
name|left
operator|||
name|node
operator|->
name|left
operator|->
name|right
operator|||
operator|!
name|tree_int_cst_equal
argument_list|(
name|node
operator|->
name|left
operator|->
name|low
argument_list|,
name|node
operator|->
name|left
operator|->
name|high
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|node_has_high_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_insn
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_bgt_pat
call|)
argument_list|(
name|default_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|left
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We cannot process node->left normally 	       since we haven't ruled out the numbers less than 	       this node's value.  So handle node->left explicitly.  */
name|do_jump_if_equal
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|left
operator|->
name|low
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|label_rtx
argument_list|(
name|node
operator|->
name|left
operator|->
name|code_label
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Node is a range.  These cases are very similar to those for a single 	 value, except that we do not start by testing whether this node 	 is the one to branch to.  */
if|if
condition|(
name|node
operator|->
name|right
operator|!=
literal|0
operator|&&
name|node
operator|->
name|left
operator|!=
literal|0
condition|)
block|{
comment|/* Node has subtrees on both sides. 	     If the right-hand subtree is bounded, 	     test for it first, since we can go straight there. 	     Otherwise, we need to make a branch in the control structure, 	     then handle the two subtrees.  */
name|tree
name|test_label
init|=
literal|0
decl_stmt|;
name|emit_cmp_insn
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_is_bounded
argument_list|(
name|node
operator|->
name|right
argument_list|,
name|index_type
argument_list|)
condition|)
comment|/* Right hand node is fully bounded so we can eliminate any 	       testing and branch directly to the target code.  */
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_bgt_pat
call|)
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|right
operator|->
name|code_label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Right hand node requires testing. 		 Branch to a label where we will handle it later.  */
name|test_label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_bgt_pat
call|)
argument_list|(
name|label_rtx
argument_list|(
name|test_label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Value belongs to this node or to the left-hand subtree.  */
name|emit_cmp_insn
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|low
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GE
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_bge_pat
call|)
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle the left-hand subtree.  */
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|left
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
comment|/* If right node had to be handled later, do that now.  */
if|if
condition|(
name|test_label
condition|)
block|{
comment|/* If the left-hand subtree fell through, 		 don't let it fall into the right-hand subtree.  */
name|emit_jump_if_reachable
argument_list|(
name|default_label
argument_list|)
expr_stmt|;
name|expand_label
argument_list|(
name|test_label
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|right
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|right
operator|!=
literal|0
operator|&&
name|node
operator|->
name|left
operator|==
literal|0
condition|)
block|{
comment|/* Deal with values to the left of this node, 	     if they are possible.  */
if|if
condition|(
operator|!
name|node_has_low_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_insn
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|low
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_blt_pat
call|)
argument_list|(
name|default_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Value belongs to this node or to the right-hand subtree.  */
name|emit_cmp_insn
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LE
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_ble_pat
call|)
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|right
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|right
operator|==
literal|0
operator|&&
name|node
operator|->
name|left
operator|!=
literal|0
condition|)
block|{
comment|/* Deal with values to the right of this node, 	     if they are possible.  */
if|if
condition|(
operator|!
name|node_has_high_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_insn
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_bgt_pat
call|)
argument_list|(
name|default_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Value belongs to this node or to the left-hand subtree.  */
name|emit_cmp_insn
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|low
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GE
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_bge_pat
call|)
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_case_nodes
argument_list|(
name|index
argument_list|,
name|node
operator|->
name|left
argument_list|,
name|default_label
argument_list|,
name|index_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Node has no children so we check low and high bounds to remove 	     redundant tests.  Only one of the bounds can exist, 	     since otherwise this node is bounded--a case tested already.  */
if|if
condition|(
operator|!
name|node_has_high_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_insn
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|high
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_bgt_pat
call|)
argument_list|(
name|default_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|node_has_low_bound
argument_list|(
name|node
argument_list|,
name|index_type
argument_list|)
condition|)
block|{
name|emit_cmp_insn
argument_list|(
name|index
argument_list|,
name|expand_expr
argument_list|(
name|node
operator|->
name|low
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LT
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|gen_blt_pat
call|)
argument_list|(
name|default_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_jump
argument_list|(
name|label_rtx
argument_list|(
name|node
operator|->
name|code_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These routines are used by the loop unrolling code.  They copy BLOCK trees    so that the debugging info will be correct for the unrolled loop.  */
end_comment

begin_comment
comment|/* Indexed by block number, contains a pointer to the N'th block node.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|block_vector
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|find_loop_tree_blocks
parameter_list|()
block|{
name|tree
name|block
init|=
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
comment|/* There first block is for the function body, and does not have      corresponding block notes.  Don't include it in the block vector.  */
name|block
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|block_vector
operator|=
name|identify_blocks
argument_list|(
name|block
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|unroll_block_trees
parameter_list|()
block|{
name|tree
name|block
init|=
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|reorder_blocks
argument_list|(
name|block_vector
argument_list|,
name|block
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

