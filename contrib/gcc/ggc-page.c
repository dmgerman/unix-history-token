begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* "Bag-of-pages" garbage collector for the GNU compiler.    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_VALGRIND_CHECKING
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_VALGRIND_MEMCHECK_H
end_ifdef

begin_include
include|#
directive|include
file|<valgrind/memcheck.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
name|HAVE_MEMCHECK_H
end_elif

begin_include
include|#
directive|include
file|<memcheck.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<valgrind.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Avoid #ifdef:s when we can help it.  */
end_comment

begin_define
define|#
directive|define
name|VALGRIND_DISCARD
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Prefer MAP_ANON(YMOUS) to /dev/zero, since we don't need to keep a    file open.  Prefer either to valloc.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MMAP_ANON
end_ifdef

begin_undef
undef|#
directive|undef
name|HAVE_MMAP_DEV_ZERO
end_undef

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAP_FAILED
end_ifndef

begin_define
define|#
directive|define
name|MAP_FAILED
value|-1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAP_ANONYMOUS
argument_list|)
operator|&&
name|defined
argument_list|(
name|MAP_ANON
argument_list|)
end_if

begin_define
define|#
directive|define
name|MAP_ANONYMOUS
value|MAP_ANON
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|USING_MMAP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MMAP_DEV_ZERO
end_ifdef

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAP_FAILED
end_ifndef

begin_define
define|#
directive|define
name|MAP_FAILED
value|-1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|USING_MMAP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|USING_MMAP
end_ifndef

begin_define
define|#
directive|define
name|USING_MALLOC_PAGE_GROUPS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Strategy:     This garbage-collecting allocator allocates objects on one of a set    of pages.  Each page can allocate objects of a single size only;    available sizes are powers of two starting at four bytes.  The size    of an allocation request is rounded up to the next power of two    (`order'), and satisfied from the appropriate page.     Each page is recorded in a page-entry, which also maintains an    in-use bitmap of object positions on the page.  This allows the    allocation state of a particular object to be flipped without    touching the page itself.     Each page-entry also has a context depth, which is used to track    pushing and popping of allocation contexts.  Only objects allocated    in the current (highest-numbered) context may be collected.     Page entries are arranged in an array of singly-linked lists.  The    array is indexed by the allocation size, in bits, of the pages on    it; i.e. all pages on a list allocate objects of the same size.    Pages are ordered on the list such that all non-full pages precede    all full pages, with non-full pages arranged in order of decreasing    context depth.     Empty pages (of all orders) are kept on a single page cache list,    and are considered first when new pages are required; they are    deallocated at the start of the next collection if they haven't    been recycled by then.  */
end_comment

begin_comment
comment|/* Define GGC_DEBUG_LEVEL to print debugging information.      0: No debugging output.      1: GC statistics only.      2: Page-entry allocations/deallocations as well.      3: Object allocations as well.      4: Object marks as well.  */
end_comment

begin_define
define|#
directive|define
name|GGC_DEBUG_LEVEL
value|(0)
end_define

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|HOST_BITS_PER_PTR
end_ifndef

begin_define
define|#
directive|define
name|HOST_BITS_PER_PTR
value|HOST_BITS_PER_LONG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* A two-level tree is used to look up the page-entry for a given    pointer.  Two chunks of the pointer's bits are extracted to index    the first and second levels of the tree, as follows:  				   HOST_PAGE_SIZE_BITS 			   32		|      |        msb +----------------+----+------+------+ lsb 			    |    |      | 			 PAGE_L1_BITS   | 				 |      | 			       PAGE_L2_BITS     The bottommost HOST_PAGE_SIZE_BITS are ignored, since page-entry    pages are aligned on system page boundaries.  The next most    significant PAGE_L2_BITS and PAGE_L1_BITS are the second and first    index values in the lookup table, respectively.     For 32-bit architectures and the settings below, there are no    leftover bits.  For architectures with wider pointers, the lookup    tree points to a list of pages, which must be scanned to find the    correct one.  */
end_comment

begin_define
define|#
directive|define
name|PAGE_L1_BITS
value|(8)
end_define

begin_define
define|#
directive|define
name|PAGE_L2_BITS
value|(32 - PAGE_L1_BITS - G.lg_pagesize)
end_define

begin_define
define|#
directive|define
name|PAGE_L1_SIZE
value|((size_t) 1<< PAGE_L1_BITS)
end_define

begin_define
define|#
directive|define
name|PAGE_L2_SIZE
value|((size_t) 1<< PAGE_L2_BITS)
end_define

begin_define
define|#
directive|define
name|LOOKUP_L1
parameter_list|(
name|p
parameter_list|)
define|\
value|(((size_t) (p)>> (32 - PAGE_L1_BITS))& ((1<< PAGE_L1_BITS) - 1))
end_define

begin_define
define|#
directive|define
name|LOOKUP_L2
parameter_list|(
name|p
parameter_list|)
define|\
value|(((size_t) (p)>> G.lg_pagesize)& ((1<< PAGE_L2_BITS) - 1))
end_define

begin_comment
comment|/* The number of objects per allocation page, for objects on a page of    the indicated ORDER.  */
end_comment

begin_define
define|#
directive|define
name|OBJECTS_PER_PAGE
parameter_list|(
name|ORDER
parameter_list|)
value|objects_per_page_table[ORDER]
end_define

begin_comment
comment|/* The number of objects in P.  */
end_comment

begin_define
define|#
directive|define
name|OBJECTS_IN_PAGE
parameter_list|(
name|P
parameter_list|)
value|((P)->bytes / OBJECT_SIZE ((P)->order))
end_define

begin_comment
comment|/* The size of an object on a page of the indicated ORDER.  */
end_comment

begin_define
define|#
directive|define
name|OBJECT_SIZE
parameter_list|(
name|ORDER
parameter_list|)
value|object_size_table[ORDER]
end_define

begin_comment
comment|/* For speed, we avoid doing a general integer divide to locate the    offset in the allocation bitmap, by precalculating numbers M, S    such that (O * M)>> S == O / Z (modulo 2^32), for any offset O    within the page which is evenly divisible by the object size Z.  */
end_comment

begin_define
define|#
directive|define
name|DIV_MULT
parameter_list|(
name|ORDER
parameter_list|)
value|inverse_table[ORDER].mult
end_define

begin_define
define|#
directive|define
name|DIV_SHIFT
parameter_list|(
name|ORDER
parameter_list|)
value|inverse_table[ORDER].shift
end_define

begin_define
define|#
directive|define
name|OFFSET_TO_BIT
parameter_list|(
name|OFFSET
parameter_list|,
name|ORDER
parameter_list|)
define|\
value|(((OFFSET) * DIV_MULT (ORDER))>> DIV_SHIFT (ORDER))
end_define

begin_comment
comment|/* The number of extra orders, not corresponding to power-of-two sized    objects.  */
end_comment

begin_define
define|#
directive|define
name|NUM_EXTRA_ORDERS
value|ARRAY_SIZE (extra_order_size_table)
end_define

begin_define
define|#
directive|define
name|RTL_SIZE
parameter_list|(
name|NSLOTS
parameter_list|)
define|\
value|(RTX_HDR_SIZE + (NSLOTS) * sizeof (rtunion))
end_define

begin_define
define|#
directive|define
name|TREE_EXP_SIZE
parameter_list|(
name|OPS
parameter_list|)
define|\
value|(sizeof (struct tree_exp) + ((OPS) - 1) * sizeof (tree))
end_define

begin_comment
comment|/* The Ith entry is the maximum size of an object to be stored in the    Ith extra order.  Adding a new entry to this array is the *only*    thing you need to do to add a new special allocation size.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|size_t
name|extra_order_size_table
index|[]
init|=
block|{
sizeof|sizeof
argument_list|(
expr|struct
name|stmt_ann_d
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|var_ann_d
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl_non_common
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_field_decl
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_parm_decl
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_var_decl
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_list
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_ssa_name
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|function
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|basic_block_def
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|bitmap_element
argument_list|)
block|,
comment|/* PHI nodes with one to three arguments are already covered by the      above sizes.  */
sizeof|sizeof
argument_list|(
expr|struct
name|tree_phi_node
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|phi_arg_d
argument_list|)
operator|*
literal|3
block|,
name|TREE_EXP_SIZE
argument_list|(
literal|2
argument_list|)
block|,
name|RTL_SIZE
argument_list|(
literal|2
argument_list|)
block|,
comment|/* MEM, PLUS, etc.  */
name|RTL_SIZE
argument_list|(
literal|9
argument_list|)
block|,
comment|/* INSN */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The total number of orders.  */
end_comment

begin_define
define|#
directive|define
name|NUM_ORDERS
value|(HOST_BITS_PER_PTR + NUM_EXTRA_ORDERS)
end_define

begin_comment
comment|/* We use this structure to determine the alignment required for    allocations.  For power-of-two sized allocations, that's not a    problem, but it does matter for odd-sized allocations.  */
end_comment

begin_struct
struct|struct
name|max_alignment
block|{
name|char
name|c
decl_stmt|;
union|union
block|{
name|HOST_WIDEST_INT
name|i
decl_stmt|;
name|long
name|double
name|d
decl_stmt|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* The biggest alignment required.  */
end_comment

begin_define
define|#
directive|define
name|MAX_ALIGNMENT
value|(offsetof (struct max_alignment, u))
end_define

begin_comment
comment|/* Compute the smallest nonnegative number which when added to X gives    a multiple of F.  */
end_comment

begin_define
define|#
directive|define
name|ROUND_UP_VALUE
parameter_list|(
name|x
parameter_list|,
name|f
parameter_list|)
value|((f) - 1 - ((f) - 1 + (x)) % (f))
end_define

begin_comment
comment|/* Compute the smallest multiple of F that is>= X.  */
end_comment

begin_define
define|#
directive|define
name|ROUND_UP
parameter_list|(
name|x
parameter_list|,
name|f
parameter_list|)
value|(CEIL (x, f) * (f))
end_define

begin_comment
comment|/* The Ith entry is the number of objects on a page or order I.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|objects_per_page_table
index|[
name|NUM_ORDERS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The Ith entry is the size of an object on a page of order I.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|object_size_table
index|[
name|NUM_ORDERS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The Ith entry is a pair of numbers (mult, shift) such that    ((k * mult)>> shift) mod 2^32 == (k / OBJECT_SIZE(I)) mod 2^32,    for all k evenly divisible by OBJECT_SIZE(I).  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|size_t
name|mult
decl_stmt|;
name|unsigned
name|int
name|shift
decl_stmt|;
block|}
name|inverse_table
index|[
name|NUM_ORDERS
index|]
struct|;
end_struct

begin_comment
comment|/* A page_entry records the status of an allocation page.  This    structure is dynamically sized to fit the bitmap in_use_p.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|page_entry
block|{
comment|/* The next page-entry with objects of the same size, or NULL if      this is the last page-entry.  */
name|struct
name|page_entry
modifier|*
name|next
decl_stmt|;
comment|/* The previous page-entry with objects of the same size, or NULL if      this is the first page-entry.   The PREV pointer exists solely to      keep the cost of ggc_free manageable.  */
name|struct
name|page_entry
modifier|*
name|prev
decl_stmt|;
comment|/* The number of bytes allocated.  (This will always be a multiple      of the host system page size.)  */
name|size_t
name|bytes
decl_stmt|;
comment|/* The address at which the memory is allocated.  */
name|char
modifier|*
name|page
decl_stmt|;
ifdef|#
directive|ifdef
name|USING_MALLOC_PAGE_GROUPS
comment|/* Back pointer to the page group this page came from.  */
name|struct
name|page_group
modifier|*
name|group
decl_stmt|;
endif|#
directive|endif
comment|/* This is the index in the by_depth varray where this page table      can be found.  */
name|unsigned
name|long
name|index_by_depth
decl_stmt|;
comment|/* Context depth of this page.  */
name|unsigned
name|short
name|context_depth
decl_stmt|;
comment|/* The number of free objects remaining on this page.  */
name|unsigned
name|short
name|num_free_objects
decl_stmt|;
comment|/* A likely candidate for the bit position of a free object for the      next allocation from this page.  */
name|unsigned
name|short
name|next_bit_hint
decl_stmt|;
comment|/* The lg of size of objects allocated from this page.  */
name|unsigned
name|char
name|order
decl_stmt|;
comment|/* A bit vector indicating whether or not objects are in use.  The      Nth bit is one if the Nth object on this page is allocated.  This      array is dynamically sized.  */
name|unsigned
name|long
name|in_use_p
index|[
literal|1
index|]
decl_stmt|;
block|}
name|page_entry
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|USING_MALLOC_PAGE_GROUPS
end_ifdef

begin_comment
comment|/* A page_group describes a large allocation from malloc, from which    we parcel out aligned pages.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|page_group
block|{
comment|/* A linked list of all extant page groups.  */
name|struct
name|page_group
modifier|*
name|next
decl_stmt|;
comment|/* The address we received from malloc.  */
name|char
modifier|*
name|allocation
decl_stmt|;
comment|/* The size of the block.  */
name|size_t
name|alloc_size
decl_stmt|;
comment|/* A bitmask of pages in use.  */
name|unsigned
name|int
name|in_use
decl_stmt|;
block|}
name|page_group
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HOST_BITS_PER_PTR
operator|<=
literal|32
end_if

begin_comment
comment|/* On 32-bit hosts, we use a two level page table, as pictured above.  */
end_comment

begin_typedef
typedef|typedef
name|page_entry
modifier|*
modifier|*
name|page_table
index|[
name|PAGE_L1_SIZE
index|]
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* On 64-bit hosts, we use the same two level page tables plus a linked    list that disambiguates the top 32-bits.  There will almost always be    exactly one entry in the list.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|page_table_chain
block|{
name|struct
name|page_table_chain
modifier|*
name|next
decl_stmt|;
name|size_t
name|high_bits
decl_stmt|;
name|page_entry
modifier|*
modifier|*
name|table
index|[
name|PAGE_L1_SIZE
index|]
decl_stmt|;
block|}
typedef|*
name|page_table
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The rest of the global variables.  */
end_comment

begin_struct
specifier|static
struct|struct
name|globals
block|{
comment|/* The Nth element in this array is a page with objects of size 2^N.      If there are any pages with free objects, they will be at the      head of the list.  NULL if there are no page-entries for this      object size.  */
name|page_entry
modifier|*
name|pages
index|[
name|NUM_ORDERS
index|]
decl_stmt|;
comment|/* The Nth element in this array is the last page with objects of      size 2^N.  NULL if there are no page-entries for this object      size.  */
name|page_entry
modifier|*
name|page_tails
index|[
name|NUM_ORDERS
index|]
decl_stmt|;
comment|/* Lookup table for associating allocation pages with object addresses.  */
name|page_table
name|lookup
decl_stmt|;
comment|/* The system's page size.  */
name|size_t
name|pagesize
decl_stmt|;
name|size_t
name|lg_pagesize
decl_stmt|;
comment|/* Bytes currently allocated.  */
name|size_t
name|allocated
decl_stmt|;
comment|/* Bytes currently allocated at the end of the last collection.  */
name|size_t
name|allocated_last_gc
decl_stmt|;
comment|/* Total amount of memory mapped.  */
name|size_t
name|bytes_mapped
decl_stmt|;
comment|/* Bit N set if any allocations have been done at context depth N.  */
name|unsigned
name|long
name|context_depth_allocations
decl_stmt|;
comment|/* Bit N set if any collections have been done at context depth N.  */
name|unsigned
name|long
name|context_depth_collections
decl_stmt|;
comment|/* The current depth in the context stack.  */
name|unsigned
name|short
name|context_depth
decl_stmt|;
comment|/* A file descriptor open to /dev/zero for reading.  */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MMAP_DEV_ZERO
argument_list|)
name|int
name|dev_zero_fd
decl_stmt|;
endif|#
directive|endif
comment|/* A cache of free system pages.  */
name|page_entry
modifier|*
name|free_pages
decl_stmt|;
ifdef|#
directive|ifdef
name|USING_MALLOC_PAGE_GROUPS
name|page_group
modifier|*
name|page_groups
decl_stmt|;
endif|#
directive|endif
comment|/* The file descriptor for debugging output.  */
name|FILE
modifier|*
name|debug_file
decl_stmt|;
comment|/* Current number of elements in use in depth below.  */
name|unsigned
name|int
name|depth_in_use
decl_stmt|;
comment|/* Maximum number of elements that can be used before resizing.  */
name|unsigned
name|int
name|depth_max
decl_stmt|;
comment|/* Each element of this arry is an index in by_depth where the given      depth starts.  This structure is indexed by that given depth we      are interested in.  */
name|unsigned
name|int
modifier|*
name|depth
decl_stmt|;
comment|/* Current number of elements in use in by_depth below.  */
name|unsigned
name|int
name|by_depth_in_use
decl_stmt|;
comment|/* Maximum number of elements that can be used before resizing.  */
name|unsigned
name|int
name|by_depth_max
decl_stmt|;
comment|/* Each element of this array is a pointer to a page_entry, all      page_entries can be found in here by increasing depth.      index_by_depth in the page_entry is the index into this data      structure where that page_entry can be found.  This is used to      speed up finding all page_entries at a particular depth.  */
name|page_entry
modifier|*
modifier|*
name|by_depth
decl_stmt|;
comment|/* Each element is a pointer to the saved in_use_p bits, if any,      zero otherwise.  We allocate them all together, to enable a      better runtime data access pattern.  */
name|unsigned
name|long
modifier|*
modifier|*
name|save_in_use
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_GC_ALWAYS_COLLECT
comment|/* List of free objects to be verified as actually free on the      next collection.  */
struct|struct
name|free_object
block|{
name|void
modifier|*
name|object
decl_stmt|;
name|struct
name|free_object
modifier|*
name|next
decl_stmt|;
block|}
modifier|*
name|free_object_list
struct|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
struct|struct
block|{
comment|/* Total memory allocated with ggc_alloc.  */
name|unsigned
name|long
name|long
name|total_allocated
decl_stmt|;
comment|/* Total overhead for memory to be allocated with ggc_alloc.  */
name|unsigned
name|long
name|long
name|total_overhead
decl_stmt|;
comment|/* Total allocations and overhead for sizes less than 32, 64 and 128.        These sizes are interesting because they are typical cache line        sizes.  */
name|unsigned
name|long
name|long
name|total_allocated_under32
decl_stmt|;
name|unsigned
name|long
name|long
name|total_overhead_under32
decl_stmt|;
name|unsigned
name|long
name|long
name|total_allocated_under64
decl_stmt|;
name|unsigned
name|long
name|long
name|total_overhead_under64
decl_stmt|;
name|unsigned
name|long
name|long
name|total_allocated_under128
decl_stmt|;
name|unsigned
name|long
name|long
name|total_overhead_under128
decl_stmt|;
comment|/* The allocations for each of the allocation orders.  */
name|unsigned
name|long
name|long
name|total_allocated_per_order
index|[
name|NUM_ORDERS
index|]
decl_stmt|;
comment|/* The overhead for each of the allocation orders.  */
name|unsigned
name|long
name|long
name|total_overhead_per_order
index|[
name|NUM_ORDERS
index|]
decl_stmt|;
block|}
name|stats
struct|;
endif|#
directive|endif
block|}
name|G
struct|;
end_struct

begin_comment
comment|/* The size in bytes required to maintain a bitmap for the objects    on a page-entry.  */
end_comment

begin_define
define|#
directive|define
name|BITMAP_SIZE
parameter_list|(
name|Num_objects
parameter_list|)
define|\
value|(CEIL ((Num_objects), HOST_BITS_PER_LONG) * sizeof(long))
end_define

begin_comment
comment|/* Allocate pages in chunks of this size, to throttle calls to memory    allocation routines.  The first page is used, the rest go onto the    free list.  This cannot be larger than HOST_BITS_PER_INT for the    in_use bitmask for page_group.  Hosts that need a different value    can override this by defining GGC_QUIRE_SIZE explicitly.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GGC_QUIRE_SIZE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|USING_MMAP
end_ifdef

begin_define
define|#
directive|define
name|GGC_QUIRE_SIZE
value|256
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GGC_QUIRE_SIZE
value|16
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Initial guess as to how many page table entries we might need.  */
end_comment

begin_define
define|#
directive|define
name|INITIAL_PTE_COUNT
value|128
end_define

begin_escape
end_escape

begin_function_decl
specifier|static
name|int
name|ggc_allocated_p
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|page_entry
modifier|*
name|lookup_page_table_entry
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_page_table_entry
parameter_list|(
name|void
modifier|*
parameter_list|,
name|page_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|USING_MMAP
end_ifdef

begin_function_decl
specifier|static
name|char
modifier|*
name|alloc_anon
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USING_MALLOC_PAGE_GROUPS
end_ifdef

begin_function_decl
specifier|static
name|size_t
name|page_group_index
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_page_group_in_use
parameter_list|(
name|page_group
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_page_group_in_use
parameter_list|(
name|page_group
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|page_entry
modifier|*
name|alloc_page
parameter_list|(
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_page
parameter_list|(
name|struct
name|page_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|release_pages
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_marks
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sweep_pages
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ggc_recalculate_in_use_p
parameter_list|(
name|page_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_inverse
parameter_list|(
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|adjust_depth
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|move_ptes_to_front
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|debug_print_page_list
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|push_depth
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|push_by_depth
parameter_list|(
name|page_entry
modifier|*
parameter_list|,
name|unsigned
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Push an entry onto G.depth.  */
end_comment

begin_function
specifier|inline
specifier|static
name|void
name|push_depth
parameter_list|(
name|unsigned
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|G
operator|.
name|depth_in_use
operator|>=
name|G
operator|.
name|depth_max
condition|)
block|{
name|G
operator|.
name|depth_max
operator|*=
literal|2
expr_stmt|;
name|G
operator|.
name|depth
operator|=
name|xrealloc
argument_list|(
name|G
operator|.
name|depth
argument_list|,
name|G
operator|.
name|depth_max
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
block|}
name|G
operator|.
name|depth
index|[
name|G
operator|.
name|depth_in_use
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push an entry onto G.by_depth and G.save_in_use.  */
end_comment

begin_function
specifier|inline
specifier|static
name|void
name|push_by_depth
parameter_list|(
name|page_entry
modifier|*
name|p
parameter_list|,
name|unsigned
name|long
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|G
operator|.
name|by_depth_in_use
operator|>=
name|G
operator|.
name|by_depth_max
condition|)
block|{
name|G
operator|.
name|by_depth_max
operator|*=
literal|2
expr_stmt|;
name|G
operator|.
name|by_depth
operator|=
name|xrealloc
argument_list|(
name|G
operator|.
name|by_depth
argument_list|,
name|G
operator|.
name|by_depth_max
operator|*
sizeof|sizeof
argument_list|(
name|page_entry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|G
operator|.
name|save_in_use
operator|=
name|xrealloc
argument_list|(
name|G
operator|.
name|save_in_use
argument_list|,
name|G
operator|.
name|by_depth_max
operator|*
expr|sizeof
operator|(
name|unsigned
name|long
operator|*
operator|)
argument_list|)
expr_stmt|;
block|}
name|G
operator|.
name|by_depth
index|[
name|G
operator|.
name|by_depth_in_use
index|]
operator|=
name|p
expr_stmt|;
name|G
operator|.
name|save_in_use
index|[
name|G
operator|.
name|by_depth_in_use
operator|++
index|]
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|GCC_VERSION
operator|<
literal|3001
operator|)
end_if

begin_define
define|#
directive|define
name|prefetch
parameter_list|(
name|X
parameter_list|)
value|((void) X)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|prefetch
parameter_list|(
name|X
parameter_list|)
value|__builtin_prefetch (X)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|save_in_use_p_i
parameter_list|(
name|__i
parameter_list|)
define|\
value|(G.save_in_use[__i])
end_define

begin_define
define|#
directive|define
name|save_in_use_p
parameter_list|(
name|__p
parameter_list|)
define|\
value|(save_in_use_p_i (__p->index_by_depth))
end_define

begin_comment
comment|/* Returns nonzero if P was allocated in GC'able memory.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ggc_allocated_p
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|page_entry
modifier|*
modifier|*
modifier|*
name|base
decl_stmt|;
name|size_t
name|L1
decl_stmt|,
name|L2
decl_stmt|;
if|#
directive|if
name|HOST_BITS_PER_PTR
operator|<=
literal|32
name|base
operator|=
operator|&
name|G
operator|.
name|lookup
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
name|page_table
name|table
init|=
name|G
operator|.
name|lookup
decl_stmt|;
name|size_t
name|high_bits
init|=
operator|(
name|size_t
operator|)
name|p
operator|&
operator|~
operator|(
name|size_t
operator|)
literal|0xffffffff
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|table
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|table
operator|->
name|high_bits
operator|==
name|high_bits
condition|)
break|break;
name|table
operator|=
name|table
operator|->
name|next
expr_stmt|;
block|}
name|base
operator|=
operator|&
name|table
operator|->
name|table
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* Extract the level 1 and 2 indices.  */
name|L1
operator|=
name|LOOKUP_L1
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|L2
operator|=
name|LOOKUP_L2
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|base
index|[
name|L1
index|]
operator|&&
name|base
index|[
name|L1
index|]
index|[
name|L2
index|]
return|;
block|}
end_function

begin_comment
comment|/* Traverse the page table and find the entry for a page.    Die (probably) if the object wasn't allocated via GC.  */
end_comment

begin_function
specifier|static
specifier|inline
name|page_entry
modifier|*
name|lookup_page_table_entry
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|page_entry
modifier|*
modifier|*
modifier|*
name|base
decl_stmt|;
name|size_t
name|L1
decl_stmt|,
name|L2
decl_stmt|;
if|#
directive|if
name|HOST_BITS_PER_PTR
operator|<=
literal|32
name|base
operator|=
operator|&
name|G
operator|.
name|lookup
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
name|page_table
name|table
init|=
name|G
operator|.
name|lookup
decl_stmt|;
name|size_t
name|high_bits
init|=
operator|(
name|size_t
operator|)
name|p
operator|&
operator|~
operator|(
name|size_t
operator|)
literal|0xffffffff
decl_stmt|;
while|while
condition|(
name|table
operator|->
name|high_bits
operator|!=
name|high_bits
condition|)
name|table
operator|=
name|table
operator|->
name|next
expr_stmt|;
name|base
operator|=
operator|&
name|table
operator|->
name|table
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* Extract the level 1 and 2 indices.  */
name|L1
operator|=
name|LOOKUP_L1
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|L2
operator|=
name|LOOKUP_L2
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|base
index|[
name|L1
index|]
index|[
name|L2
index|]
return|;
block|}
end_function

begin_comment
comment|/* Set the page table entry for a page.  */
end_comment

begin_function
specifier|static
name|void
name|set_page_table_entry
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|page_entry
modifier|*
name|entry
parameter_list|)
block|{
name|page_entry
modifier|*
modifier|*
modifier|*
name|base
decl_stmt|;
name|size_t
name|L1
decl_stmt|,
name|L2
decl_stmt|;
if|#
directive|if
name|HOST_BITS_PER_PTR
operator|<=
literal|32
name|base
operator|=
operator|&
name|G
operator|.
name|lookup
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
name|page_table
name|table
decl_stmt|;
name|size_t
name|high_bits
init|=
operator|(
name|size_t
operator|)
name|p
operator|&
operator|~
operator|(
name|size_t
operator|)
literal|0xffffffff
decl_stmt|;
for|for
control|(
name|table
operator|=
name|G
operator|.
name|lookup
init|;
name|table
condition|;
name|table
operator|=
name|table
operator|->
name|next
control|)
if|if
condition|(
name|table
operator|->
name|high_bits
operator|==
name|high_bits
condition|)
goto|goto
name|found
goto|;
comment|/* Not found -- allocate a new table.  */
name|table
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|table
argument_list|)
argument_list|)
expr_stmt|;
name|table
operator|->
name|next
operator|=
name|G
operator|.
name|lookup
expr_stmt|;
name|table
operator|->
name|high_bits
operator|=
name|high_bits
expr_stmt|;
name|G
operator|.
name|lookup
operator|=
name|table
expr_stmt|;
name|found
label|:
name|base
operator|=
operator|&
name|table
operator|->
name|table
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* Extract the level 1 and 2 indices.  */
name|L1
operator|=
name|LOOKUP_L1
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|L2
operator|=
name|LOOKUP_L2
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
index|[
name|L1
index|]
operator|==
name|NULL
condition|)
name|base
index|[
name|L1
index|]
operator|=
name|XCNEWVEC
argument_list|(
name|page_entry
operator|*
argument_list|,
name|PAGE_L2_SIZE
argument_list|)
expr_stmt|;
name|base
index|[
name|L1
index|]
index|[
name|L2
index|]
operator|=
name|entry
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prints the page-entry for object size ORDER, for debugging.  */
end_comment

begin_function
name|void
name|debug_print_page_list
parameter_list|(
name|int
name|order
parameter_list|)
block|{
name|page_entry
modifier|*
name|p
decl_stmt|;
name|printf
argument_list|(
literal|"Head=%p, Tail=%p:\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|G
operator|.
name|pages
index|[
name|order
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|G
operator|.
name|page_tails
index|[
name|order
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
name|G
operator|.
name|pages
index|[
name|order
index|]
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%p(%1d|%3d) -> "
argument_list|,
operator|(
name|void
operator|*
operator|)
name|p
argument_list|,
name|p
operator|->
name|context_depth
argument_list|,
name|p
operator|->
name|num_free_objects
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"NULL\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USING_MMAP
end_ifdef

begin_comment
comment|/* Allocate SIZE bytes of anonymous memory, preferably near PREF,    (if non-null).  The ifdef structure here is intended to cause a    compile error unless exactly one of the HAVE_* is defined.  */
end_comment

begin_function
specifier|static
specifier|inline
name|char
modifier|*
name|alloc_anon
parameter_list|(
name|char
modifier|*
name|pref
name|ATTRIBUTE_UNUSED
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_MMAP_ANON
name|char
modifier|*
name|page
init|=
name|mmap
argument_list|(
name|pref
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_ANONYMOUS
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_MMAP_DEV_ZERO
name|char
modifier|*
name|page
init|=
name|mmap
argument_list|(
name|pref
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|G
operator|.
name|dev_zero_fd
argument_list|,
literal|0
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|page
operator|==
operator|(
name|char
operator|*
operator|)
name|MAP_FAILED
condition|)
block|{
name|perror
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
comment|/* Remember that we allocated this memory.  */
name|G
operator|.
name|bytes_mapped
operator|+=
name|size
expr_stmt|;
comment|/* Pretend we don't have access to the allocated pages.  We'll enable      access to smaller pieces of the area in ggc_alloc.  Discard the      handle to avoid handle leak.  */
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_NOACCESS
argument_list|(
name|page
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|page
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USING_MALLOC_PAGE_GROUPS
end_ifdef

begin_comment
comment|/* Compute the index for this page into the page group.  */
end_comment

begin_function
specifier|static
specifier|inline
name|size_t
name|page_group_index
parameter_list|(
name|char
modifier|*
name|allocation
parameter_list|,
name|char
modifier|*
name|page
parameter_list|)
block|{
return|return
call|(
name|size_t
call|)
argument_list|(
name|page
operator|-
name|allocation
argument_list|)
operator|>>
name|G
operator|.
name|lg_pagesize
return|;
block|}
end_function

begin_comment
comment|/* Set and clear the in_use bit for this page in the page group.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_page_group_in_use
parameter_list|(
name|page_group
modifier|*
name|group
parameter_list|,
name|char
modifier|*
name|page
parameter_list|)
block|{
name|group
operator|->
name|in_use
operator||=
literal|1
operator|<<
name|page_group_index
argument_list|(
name|group
operator|->
name|allocation
argument_list|,
name|page
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|clear_page_group_in_use
parameter_list|(
name|page_group
modifier|*
name|group
parameter_list|,
name|char
modifier|*
name|page
parameter_list|)
block|{
name|group
operator|->
name|in_use
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|page_group_index
argument_list|(
name|group
operator|->
name|allocation
argument_list|,
name|page
argument_list|)
operator|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Allocate a new page for allocating objects of size 2^ORDER,    and return an entry for it.  The entry is not added to the    appropriate page_table list.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|page_entry
modifier|*
name|alloc_page
parameter_list|(
name|unsigned
name|order
parameter_list|)
block|{
name|struct
name|page_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|char
modifier|*
name|page
decl_stmt|;
name|size_t
name|num_objects
decl_stmt|;
name|size_t
name|bitmap_size
decl_stmt|;
name|size_t
name|page_entry_size
decl_stmt|;
name|size_t
name|entry_size
decl_stmt|;
ifdef|#
directive|ifdef
name|USING_MALLOC_PAGE_GROUPS
name|page_group
modifier|*
name|group
decl_stmt|;
endif|#
directive|endif
name|num_objects
operator|=
name|OBJECTS_PER_PAGE
argument_list|(
name|order
argument_list|)
expr_stmt|;
name|bitmap_size
operator|=
name|BITMAP_SIZE
argument_list|(
name|num_objects
operator|+
literal|1
argument_list|)
expr_stmt|;
name|page_entry_size
operator|=
sizeof|sizeof
argument_list|(
name|page_entry
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|+
name|bitmap_size
expr_stmt|;
name|entry_size
operator|=
name|num_objects
operator|*
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry_size
operator|<
name|G
operator|.
name|pagesize
condition|)
name|entry_size
operator|=
name|G
operator|.
name|pagesize
expr_stmt|;
name|entry
operator|=
name|NULL
expr_stmt|;
name|page
operator|=
name|NULL
expr_stmt|;
comment|/* Check the list of free pages for one we can use.  */
for|for
control|(
name|pp
operator|=
operator|&
name|G
operator|.
name|free_pages
operator|,
name|p
operator|=
operator|*
name|pp
init|;
name|p
condition|;
name|pp
operator|=
operator|&
name|p
operator|->
name|next
operator|,
name|p
operator|=
operator|*
name|pp
control|)
if|if
condition|(
name|p
operator|->
name|bytes
operator|==
name|entry_size
condition|)
break|break;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* Recycle the allocated memory from this page ...  */
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|page
operator|=
name|p
operator|->
name|page
expr_stmt|;
ifdef|#
directive|ifdef
name|USING_MALLOC_PAGE_GROUPS
name|group
operator|=
name|p
operator|->
name|group
expr_stmt|;
endif|#
directive|endif
comment|/* ... and, if possible, the page entry itself.  */
if|if
condition|(
name|p
operator|->
name|order
operator|==
name|order
condition|)
block|{
name|entry
operator|=
name|p
expr_stmt|;
name|memset
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|,
name|page_entry_size
argument_list|)
expr_stmt|;
block|}
else|else
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USING_MMAP
elseif|else
if|if
condition|(
name|entry_size
operator|==
name|G
operator|.
name|pagesize
condition|)
block|{
comment|/* We want just one page.  Allocate a bunch of them and put the 	 extras on the freelist.  (Can only do this optimization with 	 mmap for backing store.)  */
name|struct
name|page_entry
modifier|*
name|e
decl_stmt|,
modifier|*
name|f
init|=
name|G
operator|.
name|free_pages
decl_stmt|;
name|int
name|i
decl_stmt|;
name|page
operator|=
name|alloc_anon
argument_list|(
name|NULL
argument_list|,
name|G
operator|.
name|pagesize
operator|*
name|GGC_QUIRE_SIZE
argument_list|)
expr_stmt|;
comment|/* This loop counts down so that the chain will be in ascending 	 memory order.  */
for|for
control|(
name|i
operator|=
name|GGC_QUIRE_SIZE
operator|-
literal|1
init|;
name|i
operator|>=
literal|1
condition|;
name|i
operator|--
control|)
block|{
name|e
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|page_entry_size
argument_list|)
expr_stmt|;
name|e
operator|->
name|order
operator|=
name|order
expr_stmt|;
name|e
operator|->
name|bytes
operator|=
name|G
operator|.
name|pagesize
expr_stmt|;
name|e
operator|->
name|page
operator|=
name|page
operator|+
operator|(
name|i
operator|<<
name|G
operator|.
name|lg_pagesize
operator|)
expr_stmt|;
name|e
operator|->
name|next
operator|=
name|f
expr_stmt|;
name|f
operator|=
name|e
expr_stmt|;
block|}
name|G
operator|.
name|free_pages
operator|=
name|f
expr_stmt|;
block|}
else|else
name|page
operator|=
name|alloc_anon
argument_list|(
name|NULL
argument_list|,
name|entry_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USING_MALLOC_PAGE_GROUPS
else|else
block|{
comment|/* Allocate a large block of memory and serve out the aligned 	 pages therein.  This results in much less memory wastage 	 than the traditional implementation of valloc.  */
name|char
modifier|*
name|allocation
decl_stmt|,
modifier|*
name|a
decl_stmt|,
modifier|*
name|enda
decl_stmt|;
name|size_t
name|alloc_size
decl_stmt|,
name|head_slop
decl_stmt|,
name|tail_slop
decl_stmt|;
name|int
name|multiple_pages
init|=
operator|(
name|entry_size
operator|==
name|G
operator|.
name|pagesize
operator|)
decl_stmt|;
if|if
condition|(
name|multiple_pages
condition|)
name|alloc_size
operator|=
name|GGC_QUIRE_SIZE
operator|*
name|G
operator|.
name|pagesize
expr_stmt|;
else|else
name|alloc_size
operator|=
name|entry_size
operator|+
name|G
operator|.
name|pagesize
operator|-
literal|1
expr_stmt|;
name|allocation
operator|=
name|xmalloc
argument_list|(
name|alloc_size
argument_list|)
expr_stmt|;
name|page
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|size_t
operator|)
name|allocation
operator|+
name|G
operator|.
name|pagesize
operator|-
literal|1
operator|)
operator|&
operator|-
name|G
operator|.
name|pagesize
operator|)
expr_stmt|;
name|head_slop
operator|=
name|page
operator|-
name|allocation
expr_stmt|;
if|if
condition|(
name|multiple_pages
condition|)
name|tail_slop
operator|=
operator|(
operator|(
name|size_t
operator|)
name|allocation
operator|+
name|alloc_size
operator|)
operator|&
operator|(
name|G
operator|.
name|pagesize
operator|-
literal|1
operator|)
expr_stmt|;
else|else
name|tail_slop
operator|=
name|alloc_size
operator|-
name|entry_size
operator|-
name|head_slop
expr_stmt|;
name|enda
operator|=
name|allocation
operator|+
name|alloc_size
operator|-
name|tail_slop
expr_stmt|;
comment|/* We allocated N pages, which are likely not aligned, leaving 	 us with N-1 usable pages.  We plan to place the page_group 	 structure somewhere in the slop.  */
if|if
condition|(
name|head_slop
operator|>=
sizeof|sizeof
argument_list|(
name|page_group
argument_list|)
condition|)
name|group
operator|=
operator|(
name|page_group
operator|*
operator|)
name|page
operator|-
literal|1
expr_stmt|;
else|else
block|{
comment|/* We magically got an aligned allocation.  Too bad, we have 	     to waste a page anyway.  */
if|if
condition|(
name|tail_slop
operator|==
literal|0
condition|)
block|{
name|enda
operator|-=
name|G
operator|.
name|pagesize
expr_stmt|;
name|tail_slop
operator|+=
name|G
operator|.
name|pagesize
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|tail_slop
operator|>=
sizeof|sizeof
argument_list|(
name|page_group
argument_list|)
argument_list|)
expr_stmt|;
name|group
operator|=
operator|(
name|page_group
operator|*
operator|)
name|enda
expr_stmt|;
name|tail_slop
operator|-=
sizeof|sizeof
argument_list|(
name|page_group
argument_list|)
expr_stmt|;
block|}
comment|/* Remember that we allocated this memory.  */
name|group
operator|->
name|next
operator|=
name|G
operator|.
name|page_groups
expr_stmt|;
name|group
operator|->
name|allocation
operator|=
name|allocation
expr_stmt|;
name|group
operator|->
name|alloc_size
operator|=
name|alloc_size
expr_stmt|;
name|group
operator|->
name|in_use
operator|=
literal|0
expr_stmt|;
name|G
operator|.
name|page_groups
operator|=
name|group
expr_stmt|;
name|G
operator|.
name|bytes_mapped
operator|+=
name|alloc_size
expr_stmt|;
comment|/* If we allocated multiple pages, put the rest on the free list.  */
if|if
condition|(
name|multiple_pages
condition|)
block|{
name|struct
name|page_entry
modifier|*
name|e
decl_stmt|,
modifier|*
name|f
init|=
name|G
operator|.
name|free_pages
decl_stmt|;
for|for
control|(
name|a
operator|=
name|enda
operator|-
name|G
operator|.
name|pagesize
init|;
name|a
operator|!=
name|page
condition|;
name|a
operator|-=
name|G
operator|.
name|pagesize
control|)
block|{
name|e
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|page_entry_size
argument_list|)
expr_stmt|;
name|e
operator|->
name|order
operator|=
name|order
expr_stmt|;
name|e
operator|->
name|bytes
operator|=
name|G
operator|.
name|pagesize
expr_stmt|;
name|e
operator|->
name|page
operator|=
name|a
expr_stmt|;
name|e
operator|->
name|group
operator|=
name|group
expr_stmt|;
name|e
operator|->
name|next
operator|=
name|f
expr_stmt|;
name|f
operator|=
name|e
expr_stmt|;
block|}
name|G
operator|.
name|free_pages
operator|=
name|f
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
name|entry
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|page_entry_size
argument_list|)
expr_stmt|;
name|entry
operator|->
name|bytes
operator|=
name|entry_size
expr_stmt|;
name|entry
operator|->
name|page
operator|=
name|page
expr_stmt|;
name|entry
operator|->
name|context_depth
operator|=
name|G
operator|.
name|context_depth
expr_stmt|;
name|entry
operator|->
name|order
operator|=
name|order
expr_stmt|;
name|entry
operator|->
name|num_free_objects
operator|=
name|num_objects
expr_stmt|;
name|entry
operator|->
name|next_bit_hint
operator|=
literal|1
expr_stmt|;
name|G
operator|.
name|context_depth_allocations
operator||=
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
name|G
operator|.
name|context_depth
expr_stmt|;
ifdef|#
directive|ifdef
name|USING_MALLOC_PAGE_GROUPS
name|entry
operator|->
name|group
operator|=
name|group
expr_stmt|;
name|set_page_group_in_use
argument_list|(
name|group
argument_list|,
name|page
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set the one-past-the-end in-use bit.  This acts as a sentry as we      increment the hint.  */
name|entry
operator|->
name|in_use_p
index|[
name|num_objects
operator|/
name|HOST_BITS_PER_LONG
index|]
operator|=
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
operator|(
name|num_objects
operator|%
name|HOST_BITS_PER_LONG
operator|)
expr_stmt|;
name|set_page_table_entry
argument_list|(
name|page
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|GGC_DEBUG_LEVEL
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|G
operator|.
name|debug_file
argument_list|,
literal|"Allocating page at %p, object size=%lu, data %p-%p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
argument_list|,
name|page
argument_list|,
name|page
operator|+
name|entry_size
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Adjust the size of G.depth so that no index greater than the one    used by the top of the G.by_depth is used.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|adjust_depth
parameter_list|(
name|void
parameter_list|)
block|{
name|page_entry
modifier|*
name|top
decl_stmt|;
if|if
condition|(
name|G
operator|.
name|by_depth_in_use
condition|)
block|{
name|top
operator|=
name|G
operator|.
name|by_depth
index|[
name|G
operator|.
name|by_depth_in_use
operator|-
literal|1
index|]
expr_stmt|;
comment|/* Peel back indices in depth that index into by_depth, so that 	 as new elements are added to by_depth, we note the indices 	 of those elements, if they are for new context depths.  */
while|while
condition|(
name|G
operator|.
name|depth_in_use
operator|>
operator|(
name|size_t
operator|)
name|top
operator|->
name|context_depth
operator|+
literal|1
condition|)
operator|--
name|G
operator|.
name|depth_in_use
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* For a page that is no longer needed, put it on the free page list.  */
end_comment

begin_function
specifier|static
name|void
name|free_page
parameter_list|(
name|page_entry
modifier|*
name|entry
parameter_list|)
block|{
if|if
condition|(
name|GGC_DEBUG_LEVEL
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|G
operator|.
name|debug_file
argument_list|,
literal|"Deallocating page at %p, data %p-%p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
argument_list|,
name|entry
operator|->
name|page
argument_list|,
name|entry
operator|->
name|page
operator|+
name|entry
operator|->
name|bytes
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Mark the page as inaccessible.  Discard the handle to avoid handle      leak.  */
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_NOACCESS
argument_list|(
name|entry
operator|->
name|page
argument_list|,
name|entry
operator|->
name|bytes
argument_list|)
argument_list|)
expr_stmt|;
name|set_page_table_entry
argument_list|(
name|entry
operator|->
name|page
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USING_MALLOC_PAGE_GROUPS
name|clear_page_group_in_use
argument_list|(
name|entry
operator|->
name|group
argument_list|,
name|entry
operator|->
name|page
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|G
operator|.
name|by_depth_in_use
operator|>
literal|1
condition|)
block|{
name|page_entry
modifier|*
name|top
init|=
name|G
operator|.
name|by_depth
index|[
name|G
operator|.
name|by_depth_in_use
operator|-
literal|1
index|]
decl_stmt|;
name|int
name|i
init|=
name|entry
operator|->
name|index_by_depth
decl_stmt|;
comment|/* We cannot free a page from a context deeper than the current 	 one.  */
name|gcc_assert
argument_list|(
name|entry
operator|->
name|context_depth
operator|==
name|top
operator|->
name|context_depth
argument_list|)
expr_stmt|;
comment|/* Put top element into freed slot.  */
name|G
operator|.
name|by_depth
index|[
name|i
index|]
operator|=
name|top
expr_stmt|;
name|G
operator|.
name|save_in_use
index|[
name|i
index|]
operator|=
name|G
operator|.
name|save_in_use
index|[
name|G
operator|.
name|by_depth_in_use
operator|-
literal|1
index|]
expr_stmt|;
name|top
operator|->
name|index_by_depth
operator|=
name|i
expr_stmt|;
block|}
operator|--
name|G
operator|.
name|by_depth_in_use
expr_stmt|;
name|adjust_depth
argument_list|()
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|G
operator|.
name|free_pages
expr_stmt|;
name|G
operator|.
name|free_pages
operator|=
name|entry
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Release the free page cache to the system.  */
end_comment

begin_function
specifier|static
name|void
name|release_pages
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USING_MMAP
name|page_entry
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/* Gather up adjacent pages so they are unmapped together.  */
name|p
operator|=
name|G
operator|.
name|free_pages
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|start
operator|=
name|p
operator|->
name|page
expr_stmt|;
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|len
operator|=
name|p
operator|->
name|bytes
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|next
expr_stmt|;
while|while
condition|(
name|p
operator|&&
name|p
operator|->
name|page
operator|==
name|start
operator|+
name|len
condition|)
block|{
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|len
operator|+=
name|p
operator|->
name|bytes
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|next
expr_stmt|;
block|}
name|munmap
argument_list|(
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|G
operator|.
name|bytes_mapped
operator|-=
name|len
expr_stmt|;
block|}
name|G
operator|.
name|free_pages
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USING_MALLOC_PAGE_GROUPS
name|page_entry
modifier|*
modifier|*
name|pp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|page_group
modifier|*
modifier|*
name|gp
decl_stmt|,
modifier|*
name|g
decl_stmt|;
comment|/* Remove all pages from free page groups from the list.  */
name|pp
operator|=
operator|&
name|G
operator|.
name|free_pages
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|p
operator|->
name|group
operator|->
name|in_use
operator|==
literal|0
condition|)
block|{
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
comment|/* Remove all free page groups, and release the storage.  */
name|gp
operator|=
operator|&
name|G
operator|.
name|page_groups
expr_stmt|;
while|while
condition|(
operator|(
name|g
operator|=
operator|*
name|gp
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|g
operator|->
name|in_use
operator|==
literal|0
condition|)
block|{
operator|*
name|gp
operator|=
name|g
operator|->
name|next
expr_stmt|;
name|G
operator|.
name|bytes_mapped
operator|-=
name|g
operator|->
name|alloc_size
expr_stmt|;
name|free
argument_list|(
name|g
operator|->
name|allocation
argument_list|)
expr_stmt|;
block|}
else|else
name|gp
operator|=
operator|&
name|g
operator|->
name|next
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* This table provides a fast way to determine ceil(log_2(size)) for    allocation requests.  The minimum allocation size is eight bytes.  */
end_comment

begin_define
define|#
directive|define
name|NUM_SIZE_LOOKUP
value|512
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|size_lookup
index|[
name|NUM_SIZE_LOOKUP
index|]
init|=
block|{
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Typed allocation function.  Does nothing special in this collector.  */
end_comment

begin_function
name|void
modifier|*
name|ggc_alloc_typed_stat
parameter_list|(
name|enum
name|gt_types_enum
name|type
name|ATTRIBUTE_UNUSED
parameter_list|,
name|size_t
name|size
name|MEM_STAT_DECL
parameter_list|)
block|{
return|return
name|ggc_alloc_stat
argument_list|(
argument|size PASS_MEM_STAT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate a chunk of memory of SIZE bytes.  Its contents are undefined.  */
end_comment

begin_function
name|void
modifier|*
name|ggc_alloc_stat
parameter_list|(
name|size_t
name|size
name|MEM_STAT_DECL
parameter_list|)
block|{
name|size_t
name|order
decl_stmt|,
name|word
decl_stmt|,
name|bit
decl_stmt|,
name|object_offset
decl_stmt|,
name|object_size
decl_stmt|;
name|struct
name|page_entry
modifier|*
name|entry
decl_stmt|;
name|void
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|size
operator|<
name|NUM_SIZE_LOOKUP
condition|)
block|{
name|order
operator|=
name|size_lookup
index|[
name|size
index|]
expr_stmt|;
name|object_size
operator|=
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|order
operator|=
literal|10
expr_stmt|;
while|while
condition|(
name|size
operator|>
operator|(
name|object_size
operator|=
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
operator|)
condition|)
name|order
operator|++
expr_stmt|;
block|}
comment|/* If there are non-full pages for this size allocation, they are at      the head of the list.  */
name|entry
operator|=
name|G
operator|.
name|pages
index|[
name|order
index|]
expr_stmt|;
comment|/* If there is no page for this object size, or all pages in this      context are full, allocate a new page.  */
if|if
condition|(
name|entry
operator|==
name|NULL
operator|||
name|entry
operator|->
name|num_free_objects
operator|==
literal|0
condition|)
block|{
name|struct
name|page_entry
modifier|*
name|new_entry
decl_stmt|;
name|new_entry
operator|=
name|alloc_page
argument_list|(
name|order
argument_list|)
expr_stmt|;
name|new_entry
operator|->
name|index_by_depth
operator|=
name|G
operator|.
name|by_depth_in_use
expr_stmt|;
name|push_by_depth
argument_list|(
name|new_entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We can skip context depths, if we do, make sure we go all the 	 way to the new depth.  */
while|while
condition|(
name|new_entry
operator|->
name|context_depth
operator|>=
name|G
operator|.
name|depth_in_use
condition|)
name|push_depth
argument_list|(
name|G
operator|.
name|by_depth_in_use
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* If this is the only entry, it's also the tail.  If it is not 	 the only entry, then we must update the PREV pointer of the 	 ENTRY (G.pages[order]) to point to our new page entry.  */
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
name|G
operator|.
name|page_tails
index|[
name|order
index|]
operator|=
name|new_entry
expr_stmt|;
else|else
name|entry
operator|->
name|prev
operator|=
name|new_entry
expr_stmt|;
comment|/* Put new pages at the head of the page list.  By definition the 	 entry at the head of the list always has a NULL pointer.  */
name|new_entry
operator|->
name|next
operator|=
name|entry
expr_stmt|;
name|new_entry
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|entry
operator|=
name|new_entry
expr_stmt|;
name|G
operator|.
name|pages
index|[
name|order
index|]
operator|=
name|new_entry
expr_stmt|;
comment|/* For a new page, we know the word and bit positions (in the 	 in_use bitmap) of the first available object -- they're zero.  */
name|new_entry
operator|->
name|next_bit_hint
operator|=
literal|1
expr_stmt|;
name|word
operator|=
literal|0
expr_stmt|;
name|bit
operator|=
literal|0
expr_stmt|;
name|object_offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* First try to use the hint left from the previous allocation 	 to locate a clear bit in the in-use bitmap.  We've made sure 	 that the one-past-the-end bit is always set, so if the hint 	 has run over, this test will fail.  */
name|unsigned
name|hint
init|=
name|entry
operator|->
name|next_bit_hint
decl_stmt|;
name|word
operator|=
name|hint
operator|/
name|HOST_BITS_PER_LONG
expr_stmt|;
name|bit
operator|=
name|hint
operator|%
name|HOST_BITS_PER_LONG
expr_stmt|;
comment|/* If the hint didn't work, scan the bitmap from the beginning.  */
if|if
condition|(
operator|(
name|entry
operator|->
name|in_use_p
index|[
name|word
index|]
operator|>>
name|bit
operator|)
operator|&
literal|1
condition|)
block|{
name|word
operator|=
name|bit
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|~
name|entry
operator|->
name|in_use_p
index|[
name|word
index|]
operator|==
literal|0
condition|)
operator|++
name|word
expr_stmt|;
if|#
directive|if
name|GCC_VERSION
operator|>=
literal|3004
name|bit
operator|=
name|__builtin_ctzl
argument_list|(
operator|~
name|entry
operator|->
name|in_use_p
index|[
name|word
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
while|while
condition|(
operator|(
name|entry
operator|->
name|in_use_p
index|[
name|word
index|]
operator|>>
name|bit
operator|)
operator|&
literal|1
condition|)
operator|++
name|bit
expr_stmt|;
endif|#
directive|endif
name|hint
operator|=
name|word
operator|*
name|HOST_BITS_PER_LONG
operator|+
name|bit
expr_stmt|;
block|}
comment|/* Next time, try the next bit.  */
name|entry
operator|->
name|next_bit_hint
operator|=
name|hint
operator|+
literal|1
expr_stmt|;
name|object_offset
operator|=
name|hint
operator|*
name|object_size
expr_stmt|;
block|}
comment|/* Set the in-use bit.  */
name|entry
operator|->
name|in_use_p
index|[
name|word
index|]
operator||=
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
comment|/* Keep a running total of the number of free objects.  If this page      fills up, we may have to move it to the end of the list if the      next page isn't full.  If the next page is full, all subsequent      pages are full, so there's no need to move it.  */
if|if
condition|(
operator|--
name|entry
operator|->
name|num_free_objects
operator|==
literal|0
operator|&&
name|entry
operator|->
name|next
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|next
operator|->
name|num_free_objects
operator|>
literal|0
condition|)
block|{
comment|/* We have a new head for the list.  */
name|G
operator|.
name|pages
index|[
name|order
index|]
operator|=
name|entry
operator|->
name|next
expr_stmt|;
comment|/* We are moving ENTRY to the end of the page table list. 	 The new page at the head of the list will have NULL in 	 its PREV field and ENTRY will have NULL in its NEXT field.  */
name|entry
operator|->
name|next
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* Append ENTRY to the tail of the list.  */
name|entry
operator|->
name|prev
operator|=
name|G
operator|.
name|page_tails
index|[
name|order
index|]
expr_stmt|;
name|G
operator|.
name|page_tails
index|[
name|order
index|]
operator|->
name|next
operator|=
name|entry
expr_stmt|;
name|G
operator|.
name|page_tails
index|[
name|order
index|]
operator|=
name|entry
expr_stmt|;
block|}
comment|/* Calculate the object's address.  */
name|result
operator|=
name|entry
operator|->
name|page
operator|+
name|object_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|ggc_record_overhead
argument_list|(
argument|OBJECT_SIZE (order)
argument_list|,
argument|OBJECT_SIZE (order) - size
argument_list|,
argument|result PASS_MEM_STAT
argument_list|)
empty_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENABLE_GC_CHECKING
comment|/* Keep poisoning-by-writing-0xaf the object, in an attempt to keep the      exact same semantics in presence of memory bugs, regardless of      ENABLE_VALGRIND_CHECKING.  We override this request below.  Drop the      handle to avoid handle leak.  */
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_WRITABLE
argument_list|(
name|result
argument_list|,
name|object_size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* `Poison' the entire allocated object, including any padding at      the end.  */
name|memset
argument_list|(
name|result
argument_list|,
literal|0xaf
argument_list|,
name|object_size
argument_list|)
expr_stmt|;
comment|/* Make the bytes after the end of the object unaccessible.  Discard the      handle to avoid handle leak.  */
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_NOACCESS
argument_list|(
operator|(
name|char
operator|*
operator|)
name|result
operator|+
name|size
argument_list|,
name|object_size
operator|-
name|size
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Tell Valgrind that the memory is there, but its content isn't      defined.  The bytes at the end of the object are still marked      unaccessible.  */
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_WRITABLE
argument_list|(
name|result
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Keep track of how many bytes are being allocated.  This      information is used in deciding when to collect.  */
name|G
operator|.
name|allocated
operator|+=
name|object_size
expr_stmt|;
comment|/* For timevar statistics.  */
name|timevar_ggc_mem_total
operator|+=
name|object_size
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
block|{
name|size_t
name|overhead
init|=
name|object_size
operator|-
name|size
decl_stmt|;
name|G
operator|.
name|stats
operator|.
name|total_overhead
operator|+=
name|overhead
expr_stmt|;
name|G
operator|.
name|stats
operator|.
name|total_allocated
operator|+=
name|object_size
expr_stmt|;
name|G
operator|.
name|stats
operator|.
name|total_overhead_per_order
index|[
name|order
index|]
operator|+=
name|overhead
expr_stmt|;
name|G
operator|.
name|stats
operator|.
name|total_allocated_per_order
index|[
name|order
index|]
operator|+=
name|object_size
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|32
condition|)
block|{
name|G
operator|.
name|stats
operator|.
name|total_overhead_under32
operator|+=
name|overhead
expr_stmt|;
name|G
operator|.
name|stats
operator|.
name|total_allocated_under32
operator|+=
name|object_size
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|<=
literal|64
condition|)
block|{
name|G
operator|.
name|stats
operator|.
name|total_overhead_under64
operator|+=
name|overhead
expr_stmt|;
name|G
operator|.
name|stats
operator|.
name|total_allocated_under64
operator|+=
name|object_size
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|<=
literal|128
condition|)
block|{
name|G
operator|.
name|stats
operator|.
name|total_overhead_under128
operator|+=
name|overhead
expr_stmt|;
name|G
operator|.
name|stats
operator|.
name|total_allocated_under128
operator|+=
name|object_size
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|GGC_DEBUG_LEVEL
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|G
operator|.
name|debug_file
argument_list|,
literal|"Allocating object, requested size=%lu, actual=%lu at %p on %p\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|size
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|object_size
argument_list|,
name|result
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* If P is not marked, marks it and return false.  Otherwise return true.    P must have been allocated by the GC allocator; it mustn't point to    static objects, stack variables, or memory allocated with malloc.  */
end_comment

begin_function
name|int
name|ggc_set_mark
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|page_entry
modifier|*
name|entry
decl_stmt|;
name|unsigned
name|bit
decl_stmt|,
name|word
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
comment|/* Look up the page on which the object is alloced.  If the object      wasn't allocated by the collector, we'll probably die.  */
name|entry
operator|=
name|lookup_page_table_entry
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|/* Calculate the index of the object on the page; this is its bit      position in the in_use_p bitmap.  */
name|bit
operator|=
name|OFFSET_TO_BIT
argument_list|(
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
operator|)
operator|-
name|entry
operator|->
name|page
argument_list|,
name|entry
operator|->
name|order
argument_list|)
expr_stmt|;
name|word
operator|=
name|bit
operator|/
name|HOST_BITS_PER_LONG
expr_stmt|;
name|mask
operator|=
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
operator|(
name|bit
operator|%
name|HOST_BITS_PER_LONG
operator|)
expr_stmt|;
comment|/* If the bit was previously set, skip it.  */
if|if
condition|(
name|entry
operator|->
name|in_use_p
index|[
name|word
index|]
operator|&
name|mask
condition|)
return|return
literal|1
return|;
comment|/* Otherwise set it, and decrement the free object count.  */
name|entry
operator|->
name|in_use_p
index|[
name|word
index|]
operator||=
name|mask
expr_stmt|;
name|entry
operator|->
name|num_free_objects
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|GGC_DEBUG_LEVEL
operator|>=
literal|4
condition|)
name|fprintf
argument_list|(
name|G
operator|.
name|debug_file
argument_list|,
literal|"Marking %p\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if P has been marked, zero otherwise.    P must have been allocated by the GC allocator; it mustn't point to    static objects, stack variables, or memory allocated with malloc.  */
end_comment

begin_function
name|int
name|ggc_marked_p
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|page_entry
modifier|*
name|entry
decl_stmt|;
name|unsigned
name|bit
decl_stmt|,
name|word
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
comment|/* Look up the page on which the object is alloced.  If the object      wasn't allocated by the collector, we'll probably die.  */
name|entry
operator|=
name|lookup_page_table_entry
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|/* Calculate the index of the object on the page; this is its bit      position in the in_use_p bitmap.  */
name|bit
operator|=
name|OFFSET_TO_BIT
argument_list|(
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
operator|)
operator|-
name|entry
operator|->
name|page
argument_list|,
name|entry
operator|->
name|order
argument_list|)
expr_stmt|;
name|word
operator|=
name|bit
operator|/
name|HOST_BITS_PER_LONG
expr_stmt|;
name|mask
operator|=
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
operator|(
name|bit
operator|%
name|HOST_BITS_PER_LONG
operator|)
expr_stmt|;
return|return
operator|(
name|entry
operator|->
name|in_use_p
index|[
name|word
index|]
operator|&
name|mask
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the size of the gc-able object P.  */
end_comment

begin_function
name|size_t
name|ggc_get_size
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|page_entry
modifier|*
name|pe
init|=
name|lookup_page_table_entry
argument_list|(
name|p
argument_list|)
decl_stmt|;
return|return
name|OBJECT_SIZE
argument_list|(
name|pe
operator|->
name|order
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Release the memory for object P.  */
end_comment

begin_function
name|void
name|ggc_free
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|page_entry
modifier|*
name|pe
init|=
name|lookup_page_table_entry
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|size_t
name|order
init|=
name|pe
operator|->
name|order
decl_stmt|;
name|size_t
name|size
init|=
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|ggc_free_overhead
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|GGC_DEBUG_LEVEL
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|G
operator|.
name|debug_file
argument_list|,
literal|"Freeing object, actual size=%lu, at %p on %p\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|size
argument_list|,
name|p
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pe
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_GC_CHECKING
comment|/* Poison the data, to indicate the data is garbage.  */
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_WRITABLE
argument_list|(
name|p
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0xa5
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Let valgrind know the object is free.  */
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_NOACCESS
argument_list|(
name|p
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_GC_ALWAYS_COLLECT
comment|/* In the completely-anal-checking mode, we do *not* immediately free      the data, but instead verify that the data is *actually* not       reachable the next time we collect.  */
block|{
name|struct
name|free_object
modifier|*
name|fo
init|=
name|XNEW
argument_list|(
expr|struct
name|free_object
argument_list|)
decl_stmt|;
name|fo
operator|->
name|object
operator|=
name|p
expr_stmt|;
name|fo
operator|->
name|next
operator|=
name|G
operator|.
name|free_object_list
expr_stmt|;
name|G
operator|.
name|free_object_list
operator|=
name|fo
expr_stmt|;
block|}
else|#
directive|else
block|{
name|unsigned
name|int
name|bit_offset
decl_stmt|,
name|word
decl_stmt|,
name|bit
decl_stmt|;
name|G
operator|.
name|allocated
operator|-=
name|size
expr_stmt|;
comment|/* Mark the object not-in-use.  */
name|bit_offset
operator|=
name|OFFSET_TO_BIT
argument_list|(
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
operator|)
operator|-
name|pe
operator|->
name|page
argument_list|,
name|order
argument_list|)
expr_stmt|;
name|word
operator|=
name|bit_offset
operator|/
name|HOST_BITS_PER_LONG
expr_stmt|;
name|bit
operator|=
name|bit_offset
operator|%
name|HOST_BITS_PER_LONG
expr_stmt|;
name|pe
operator|->
name|in_use_p
index|[
name|word
index|]
operator|&=
operator|~
operator|(
literal|1UL
operator|<<
name|bit
operator|)
expr_stmt|;
if|if
condition|(
name|pe
operator|->
name|num_free_objects
operator|++
operator|==
literal|0
condition|)
block|{
name|page_entry
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* If the page is completely full, then it's supposed to 	   be after all pages that aren't.  Since we've freed one 	   object from a page that was full, we need to move the 	   page to the head of the list.   	   PE is the node we want to move.  Q is the previous node 	   and P is the next node in the list.  */
name|q
operator|=
name|pe
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|q
operator|&&
name|q
operator|->
name|num_free_objects
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|pe
operator|->
name|next
expr_stmt|;
name|q
operator|->
name|next
operator|=
name|p
expr_stmt|;
comment|/* If PE was at the end of the list, then Q becomes the 	       new end of the list.  If PE was not the end of the 	       list, then we need to update the PREV field for P.  */
if|if
condition|(
operator|!
name|p
condition|)
name|G
operator|.
name|page_tails
index|[
name|order
index|]
operator|=
name|q
expr_stmt|;
else|else
name|p
operator|->
name|prev
operator|=
name|q
expr_stmt|;
comment|/* Move PE to the head of the list.  */
name|pe
operator|->
name|next
operator|=
name|G
operator|.
name|pages
index|[
name|order
index|]
expr_stmt|;
name|pe
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|G
operator|.
name|pages
index|[
name|order
index|]
operator|->
name|prev
operator|=
name|pe
expr_stmt|;
name|G
operator|.
name|pages
index|[
name|order
index|]
operator|=
name|pe
expr_stmt|;
block|}
comment|/* Reset the hint bit to point to the only free object.  */
name|pe
operator|->
name|next_bit_hint
operator|=
name|bit_offset
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of init_ggc which computes the pair of numbers used to    perform division by OBJECT_SIZE (order) and fills in inverse_table[].     This algorithm is taken from Granlund and Montgomery's paper    "Division by Invariant Integers using Multiplication"    (Proc. SIGPLAN PLDI, 1994), section 9 (Exact division by    constants).  */
end_comment

begin_function
specifier|static
name|void
name|compute_inverse
parameter_list|(
name|unsigned
name|order
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|,
name|inv
decl_stmt|;
name|unsigned
name|int
name|e
decl_stmt|;
name|size
operator|=
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
expr_stmt|;
name|e
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|size
operator|%
literal|2
operator|==
literal|0
condition|)
block|{
name|e
operator|++
expr_stmt|;
name|size
operator|>>=
literal|1
expr_stmt|;
block|}
name|inv
operator|=
name|size
expr_stmt|;
while|while
condition|(
name|inv
operator|*
name|size
operator|!=
literal|1
condition|)
name|inv
operator|=
name|inv
operator|*
operator|(
literal|2
operator|-
name|inv
operator|*
name|size
operator|)
expr_stmt|;
name|DIV_MULT
argument_list|(
name|order
argument_list|)
operator|=
name|inv
expr_stmt|;
name|DIV_SHIFT
argument_list|(
name|order
argument_list|)
operator|=
name|e
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the ggc-mmap allocator.  */
end_comment

begin_function
name|void
name|init_ggc
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|order
decl_stmt|;
name|G
operator|.
name|pagesize
operator|=
name|getpagesize
argument_list|()
expr_stmt|;
name|G
operator|.
name|lg_pagesize
operator|=
name|exact_log2
argument_list|(
name|G
operator|.
name|pagesize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_MMAP_DEV_ZERO
name|G
operator|.
name|dev_zero_fd
operator|=
name|open
argument_list|(
literal|"/dev/zero"
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|G
operator|.
name|dev_zero_fd
operator|==
operator|-
literal|1
condition|)
name|internal_error
argument_list|(
literal|"open /dev/zero: %m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|G.debug_file = fopen ("ggc-mmap.debug", "w");
else|#
directive|else
name|G
operator|.
name|debug_file
operator|=
name|stdout
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USING_MMAP
comment|/* StunOS has an amazing off-by-one error for the first mmap allocation      after fiddling with RLIMIT_STACK.  The result, as hard as it is to      believe, is an unaligned page allocation, which would cause us to      hork badly if we tried to use it.  */
block|{
name|char
modifier|*
name|p
init|=
name|alloc_anon
argument_list|(
name|NULL
argument_list|,
name|G
operator|.
name|pagesize
argument_list|)
decl_stmt|;
name|struct
name|page_entry
modifier|*
name|e
decl_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|p
operator|&
operator|(
name|G
operator|.
name|pagesize
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* How losing.  Discard this one and try another.  If we still 	   can't get something useful, give up.  */
name|p
operator|=
name|alloc_anon
argument_list|(
name|NULL
argument_list|,
name|G
operator|.
name|pagesize
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
operator|(
operator|(
name|size_t
operator|)
name|p
operator|&
operator|(
name|G
operator|.
name|pagesize
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* We have a good page, might as well hold onto it...  */
name|e
operator|=
name|XCNEW
argument_list|(
expr|struct
name|page_entry
argument_list|)
expr_stmt|;
name|e
operator|->
name|bytes
operator|=
name|G
operator|.
name|pagesize
expr_stmt|;
name|e
operator|->
name|page
operator|=
name|p
expr_stmt|;
name|e
operator|->
name|next
operator|=
name|G
operator|.
name|free_pages
expr_stmt|;
name|G
operator|.
name|free_pages
operator|=
name|e
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Initialize the object size table.  */
for|for
control|(
name|order
operator|=
literal|0
init|;
name|order
operator|<
name|HOST_BITS_PER_PTR
condition|;
operator|++
name|order
control|)
name|object_size_table
index|[
name|order
index|]
operator|=
operator|(
name|size_t
operator|)
literal|1
operator|<<
name|order
expr_stmt|;
for|for
control|(
name|order
operator|=
name|HOST_BITS_PER_PTR
init|;
name|order
operator|<
name|NUM_ORDERS
condition|;
operator|++
name|order
control|)
block|{
name|size_t
name|s
init|=
name|extra_order_size_table
index|[
name|order
operator|-
name|HOST_BITS_PER_PTR
index|]
decl_stmt|;
comment|/* If S is not a multiple of the MAX_ALIGNMENT, then round it up 	 so that we're sure of getting aligned memory.  */
name|s
operator|=
name|ROUND_UP
argument_list|(
name|s
argument_list|,
name|MAX_ALIGNMENT
argument_list|)
expr_stmt|;
name|object_size_table
index|[
name|order
index|]
operator|=
name|s
expr_stmt|;
block|}
comment|/* Initialize the objects-per-page and inverse tables.  */
for|for
control|(
name|order
operator|=
literal|0
init|;
name|order
operator|<
name|NUM_ORDERS
condition|;
operator|++
name|order
control|)
block|{
name|objects_per_page_table
index|[
name|order
index|]
operator|=
name|G
operator|.
name|pagesize
operator|/
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
expr_stmt|;
if|if
condition|(
name|objects_per_page_table
index|[
name|order
index|]
operator|==
literal|0
condition|)
name|objects_per_page_table
index|[
name|order
index|]
operator|=
literal|1
expr_stmt|;
name|compute_inverse
argument_list|(
name|order
argument_list|)
expr_stmt|;
block|}
comment|/* Reset the size_lookup array to put appropriately sized objects in      the special orders.  All objects bigger than the previous power      of two, but no greater than the special size, should go in the      new order.  */
for|for
control|(
name|order
operator|=
name|HOST_BITS_PER_PTR
init|;
name|order
operator|<
name|NUM_ORDERS
condition|;
operator|++
name|order
control|)
block|{
name|int
name|o
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|NUM_SIZE_LOOKUP
condition|)
continue|continue;
for|for
control|(
name|o
operator|=
name|size_lookup
index|[
name|i
index|]
init|;
name|o
operator|==
name|size_lookup
index|[
name|i
index|]
condition|;
operator|--
name|i
control|)
name|size_lookup
index|[
name|i
index|]
operator|=
name|order
expr_stmt|;
block|}
name|G
operator|.
name|depth_in_use
operator|=
literal|0
expr_stmt|;
name|G
operator|.
name|depth_max
operator|=
literal|10
expr_stmt|;
name|G
operator|.
name|depth
operator|=
name|XNEWVEC
argument_list|(
argument|unsigned int
argument_list|,
argument|G.depth_max
argument_list|)
expr_stmt|;
name|G
operator|.
name|by_depth_in_use
operator|=
literal|0
expr_stmt|;
name|G
operator|.
name|by_depth_max
operator|=
name|INITIAL_PTE_COUNT
expr_stmt|;
name|G
operator|.
name|by_depth
operator|=
name|XNEWVEC
argument_list|(
name|page_entry
operator|*
argument_list|,
name|G
operator|.
name|by_depth_max
argument_list|)
expr_stmt|;
name|G
operator|.
name|save_in_use
operator|=
name|XNEWVEC
argument_list|(
argument|unsigned long *
argument_list|,
argument|G.by_depth_max
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start a new GGC zone.  */
end_comment

begin_function
name|struct
name|alloc_zone
modifier|*
name|new_ggc_zone
parameter_list|(
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Destroy a GGC zone.  */
end_comment

begin_function
name|void
name|destroy_ggc_zone
parameter_list|(
name|struct
name|alloc_zone
modifier|*
name|zone
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Merge the SAVE_IN_USE_P and IN_USE_P arrays in P so that IN_USE_P    reflects reality.  Recalculate NUM_FREE_OBJECTS as well.  */
end_comment

begin_function
specifier|static
name|void
name|ggc_recalculate_in_use_p
parameter_list|(
name|page_entry
modifier|*
name|p
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|size_t
name|num_objects
decl_stmt|;
comment|/* Because the past-the-end bit in in_use_p is always set, we      pretend there is one additional object.  */
name|num_objects
operator|=
name|OBJECTS_IN_PAGE
argument_list|(
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Reset the free object count.  */
name|p
operator|->
name|num_free_objects
operator|=
name|num_objects
expr_stmt|;
comment|/* Combine the IN_USE_P and SAVE_IN_USE_P arrays.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CEIL
argument_list|(
name|BITMAP_SIZE
argument_list|(
name|num_objects
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
operator|->
name|in_use_p
argument_list|)
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|long
name|j
decl_stmt|;
comment|/* Something is in use if it is marked, or if it was in use in a 	 context further down the context stack.  */
name|p
operator|->
name|in_use_p
index|[
name|i
index|]
operator||=
name|save_in_use_p
argument_list|(
name|p
argument_list|)
index|[
name|i
index|]
expr_stmt|;
comment|/* Decrement the free object count for every object allocated.  */
for|for
control|(
name|j
operator|=
name|p
operator|->
name|in_use_p
index|[
name|i
index|]
init|;
name|j
condition|;
name|j
operator|>>=
literal|1
control|)
name|p
operator|->
name|num_free_objects
operator|-=
operator|(
name|j
operator|&
literal|1
operator|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|p
operator|->
name|num_free_objects
operator|<
name|num_objects
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Unmark all objects.  */
end_comment

begin_function
specifier|static
name|void
name|clear_marks
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|order
decl_stmt|;
for|for
control|(
name|order
operator|=
literal|2
init|;
name|order
operator|<
name|NUM_ORDERS
condition|;
name|order
operator|++
control|)
block|{
name|page_entry
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|G
operator|.
name|pages
index|[
name|order
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|size_t
name|num_objects
init|=
name|OBJECTS_IN_PAGE
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|size_t
name|bitmap_size
init|=
name|BITMAP_SIZE
argument_list|(
name|num_objects
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* The data should be page-aligned.  */
name|gcc_assert
argument_list|(
operator|!
operator|(
operator|(
name|size_t
operator|)
name|p
operator|->
name|page
operator|&
operator|(
name|G
operator|.
name|pagesize
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Pages that aren't in the topmost context are not collected; 	     nevertheless, we need their in-use bit vectors to store GC 	     marks.  So, back them up first.  */
if|if
condition|(
name|p
operator|->
name|context_depth
operator|<
name|G
operator|.
name|context_depth
condition|)
block|{
if|if
condition|(
operator|!
name|save_in_use_p
argument_list|(
name|p
argument_list|)
condition|)
name|save_in_use_p
argument_list|(
name|p
argument_list|)
operator|=
name|xmalloc
argument_list|(
name|bitmap_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|save_in_use_p
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
operator|->
name|in_use_p
argument_list|,
name|bitmap_size
argument_list|)
expr_stmt|;
block|}
comment|/* Reset reset the number of free objects and clear the              in-use bits.  These will be adjusted by mark_obj.  */
name|p
operator|->
name|num_free_objects
operator|=
name|num_objects
expr_stmt|;
name|memset
argument_list|(
name|p
operator|->
name|in_use_p
argument_list|,
literal|0
argument_list|,
name|bitmap_size
argument_list|)
expr_stmt|;
comment|/* Make sure the one-past-the-end bit is always set.  */
name|p
operator|->
name|in_use_p
index|[
name|num_objects
operator|/
name|HOST_BITS_PER_LONG
index|]
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
operator|(
name|num_objects
operator|%
name|HOST_BITS_PER_LONG
operator|)
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Free all empty pages.  Partially empty pages need no attention    because the `mark' bit doubles as an `unused' bit.  */
end_comment

begin_function
specifier|static
name|void
name|sweep_pages
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|order
decl_stmt|;
for|for
control|(
name|order
operator|=
literal|2
init|;
name|order
operator|<
name|NUM_ORDERS
condition|;
name|order
operator|++
control|)
block|{
comment|/* The last page-entry to consider, regardless of entries 	 placed at the end of the list.  */
name|page_entry
modifier|*
specifier|const
name|last
init|=
name|G
operator|.
name|page_tails
index|[
name|order
index|]
decl_stmt|;
name|size_t
name|num_objects
decl_stmt|;
name|size_t
name|live_objects
decl_stmt|;
name|page_entry
modifier|*
name|p
decl_stmt|,
modifier|*
name|previous
decl_stmt|;
name|int
name|done
decl_stmt|;
name|p
operator|=
name|G
operator|.
name|pages
index|[
name|order
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
continue|continue;
name|previous
operator|=
name|NULL
expr_stmt|;
do|do
block|{
name|page_entry
modifier|*
name|next
init|=
name|p
operator|->
name|next
decl_stmt|;
comment|/* Loop until all entries have been examined.  */
name|done
operator|=
operator|(
name|p
operator|==
name|last
operator|)
expr_stmt|;
name|num_objects
operator|=
name|OBJECTS_IN_PAGE
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Add all live objects on this page to the count of              allocated memory.  */
name|live_objects
operator|=
name|num_objects
operator|-
name|p
operator|->
name|num_free_objects
expr_stmt|;
name|G
operator|.
name|allocated
operator|+=
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
operator|*
name|live_objects
expr_stmt|;
comment|/* Only objects on pages in the topmost context should get 	     collected.  */
if|if
condition|(
name|p
operator|->
name|context_depth
operator|<
name|G
operator|.
name|context_depth
condition|)
empty_stmt|;
comment|/* Remove the page if it's empty.  */
elseif|else
if|if
condition|(
name|live_objects
operator|==
literal|0
condition|)
block|{
comment|/* If P was the first page in the list, then NEXT 		 becomes the new first page in the list, otherwise 		 splice P out of the forward pointers.  */
if|if
condition|(
operator|!
name|previous
condition|)
name|G
operator|.
name|pages
index|[
name|order
index|]
operator|=
name|next
expr_stmt|;
else|else
name|previous
operator|->
name|next
operator|=
name|next
expr_stmt|;
comment|/* Splice P out of the back pointers too.  */
if|if
condition|(
name|next
condition|)
name|next
operator|->
name|prev
operator|=
name|previous
expr_stmt|;
comment|/* Are we removing the last element?  */
if|if
condition|(
name|p
operator|==
name|G
operator|.
name|page_tails
index|[
name|order
index|]
condition|)
name|G
operator|.
name|page_tails
index|[
name|order
index|]
operator|=
name|previous
expr_stmt|;
name|free_page
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|previous
expr_stmt|;
block|}
comment|/* If the page is full, move it to the end.  */
elseif|else
if|if
condition|(
name|p
operator|->
name|num_free_objects
operator|==
literal|0
condition|)
block|{
comment|/* Don't move it if it's already at the end.  */
if|if
condition|(
name|p
operator|!=
name|G
operator|.
name|page_tails
index|[
name|order
index|]
condition|)
block|{
comment|/* Move p to the end of the list.  */
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|prev
operator|=
name|G
operator|.
name|page_tails
index|[
name|order
index|]
expr_stmt|;
name|G
operator|.
name|page_tails
index|[
name|order
index|]
operator|->
name|next
operator|=
name|p
expr_stmt|;
comment|/* Update the tail pointer...  */
name|G
operator|.
name|page_tails
index|[
name|order
index|]
operator|=
name|p
expr_stmt|;
comment|/* ... and the head pointer, if necessary.  */
if|if
condition|(
operator|!
name|previous
condition|)
name|G
operator|.
name|pages
index|[
name|order
index|]
operator|=
name|next
expr_stmt|;
else|else
name|previous
operator|->
name|next
operator|=
name|next
expr_stmt|;
comment|/* And update the backpointer in NEXT if necessary.  */
if|if
condition|(
name|next
condition|)
name|next
operator|->
name|prev
operator|=
name|previous
expr_stmt|;
name|p
operator|=
name|previous
expr_stmt|;
block|}
block|}
comment|/* If we've fallen through to here, it's a page in the 	     topmost context that is neither full nor empty.  Such a 	     page must precede pages at lesser context depth in the 	     list, so move it to the head.  */
elseif|else
if|if
condition|(
name|p
operator|!=
name|G
operator|.
name|pages
index|[
name|order
index|]
condition|)
block|{
name|previous
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
comment|/* Update the backchain in the next node if it exists.  */
if|if
condition|(
name|p
operator|->
name|next
condition|)
name|p
operator|->
name|next
operator|->
name|prev
operator|=
name|previous
expr_stmt|;
comment|/* Move P to the head of the list.  */
name|p
operator|->
name|next
operator|=
name|G
operator|.
name|pages
index|[
name|order
index|]
expr_stmt|;
name|p
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|G
operator|.
name|pages
index|[
name|order
index|]
operator|->
name|prev
operator|=
name|p
expr_stmt|;
comment|/* Update the head pointer.  */
name|G
operator|.
name|pages
index|[
name|order
index|]
operator|=
name|p
expr_stmt|;
comment|/* Are we moving the last element?  */
if|if
condition|(
name|G
operator|.
name|page_tails
index|[
name|order
index|]
operator|==
name|p
condition|)
name|G
operator|.
name|page_tails
index|[
name|order
index|]
operator|=
name|previous
expr_stmt|;
name|p
operator|=
name|previous
expr_stmt|;
block|}
name|previous
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|next
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
comment|/* Now, restore the in_use_p vectors for any pages from contexts          other than the current one.  */
for|for
control|(
name|p
operator|=
name|G
operator|.
name|pages
index|[
name|order
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|context_depth
operator|!=
name|G
operator|.
name|context_depth
condition|)
name|ggc_recalculate_in_use_p
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_GC_CHECKING
end_ifdef

begin_comment
comment|/* Clobber all free objects.  */
end_comment

begin_function
specifier|static
name|void
name|poison_pages
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|order
decl_stmt|;
for|for
control|(
name|order
operator|=
literal|2
init|;
name|order
operator|<
name|NUM_ORDERS
condition|;
name|order
operator|++
control|)
block|{
name|size_t
name|size
init|=
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
decl_stmt|;
name|page_entry
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|G
operator|.
name|pages
index|[
name|order
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|size_t
name|num_objects
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|context_depth
operator|!=
name|G
operator|.
name|context_depth
condition|)
comment|/* Since we don't do any collection for pages in pushed 	       contexts, there's no need to do any poisoning.  And 	       besides, the IN_USE_P array isn't valid until we pop 	       contexts.  */
continue|continue;
name|num_objects
operator|=
name|OBJECTS_IN_PAGE
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_objects
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|word
decl_stmt|,
name|bit
decl_stmt|;
name|word
operator|=
name|i
operator|/
name|HOST_BITS_PER_LONG
expr_stmt|;
name|bit
operator|=
name|i
operator|%
name|HOST_BITS_PER_LONG
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|p
operator|->
name|in_use_p
index|[
name|word
index|]
operator|>>
name|bit
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|object
init|=
name|p
operator|->
name|page
operator|+
name|i
operator|*
name|size
decl_stmt|;
comment|/* Keep poison-by-write when we expect to use Valgrind, 		     so the exact same memory semantics is kept, in case 		     there are memory errors.  We override this request 		     below.  */
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_WRITABLE
argument_list|(
name|object
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|object
argument_list|,
literal|0xa5
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Drop the handle to avoid handle leak.  */
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_NOACCESS
argument_list|(
name|object
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|poison_pages
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_GC_ALWAYS_COLLECT
end_ifdef

begin_comment
comment|/* Validate that the reportedly free objects actually are.  */
end_comment

begin_function
specifier|static
name|void
name|validate_free_objects
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|free_object
modifier|*
name|f
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|still_free
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|f
operator|=
name|G
operator|.
name|free_object_list
init|;
name|f
condition|;
name|f
operator|=
name|next
control|)
block|{
name|page_entry
modifier|*
name|pe
init|=
name|lookup_page_table_entry
argument_list|(
name|f
operator|->
name|object
argument_list|)
decl_stmt|;
name|size_t
name|bit
decl_stmt|,
name|word
decl_stmt|;
name|bit
operator|=
name|OFFSET_TO_BIT
argument_list|(
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|object
operator|-
name|pe
operator|->
name|page
argument_list|,
name|pe
operator|->
name|order
argument_list|)
expr_stmt|;
name|word
operator|=
name|bit
operator|/
name|HOST_BITS_PER_LONG
expr_stmt|;
name|bit
operator|=
name|bit
operator|%
name|HOST_BITS_PER_LONG
expr_stmt|;
name|next
operator|=
name|f
operator|->
name|next
expr_stmt|;
comment|/* Make certain it isn't visible from any root.  Notice that we 	 do this check before sweep_pages merges save_in_use_p.  */
name|gcc_assert
argument_list|(
operator|!
operator|(
name|pe
operator|->
name|in_use_p
index|[
name|word
index|]
operator|&
operator|(
literal|1UL
operator|<<
name|bit
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* If the object comes from an outer context, then retain the 	 free_object entry, so that we can verify that the address 	 isn't live on the stack in some outer context.  */
if|if
condition|(
name|pe
operator|->
name|context_depth
operator|!=
name|G
operator|.
name|context_depth
condition|)
block|{
name|f
operator|->
name|next
operator|=
name|still_free
expr_stmt|;
name|still_free
operator|=
name|f
expr_stmt|;
block|}
else|else
name|free
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|G
operator|.
name|free_object_list
operator|=
name|still_free
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|validate_free_objects
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Top level mark-and-sweep routine.  */
end_comment

begin_function
name|void
name|ggc_collect
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Avoid frequent unnecessary work by skipping collection if the      total allocations haven't expanded much since the last      collection.  */
name|float
name|allocated_last_gc
init|=
name|MAX
argument_list|(
name|G
operator|.
name|allocated_last_gc
argument_list|,
operator|(
name|size_t
operator|)
name|PARAM_VALUE
argument_list|(
name|GGC_MIN_HEAPSIZE
argument_list|)
operator|*
literal|1024
argument_list|)
decl_stmt|;
name|float
name|min_expand
init|=
name|allocated_last_gc
operator|*
name|PARAM_VALUE
argument_list|(
name|GGC_MIN_EXPAND
argument_list|)
operator|/
literal|100
decl_stmt|;
if|if
condition|(
name|G
operator|.
name|allocated
operator|<
name|allocated_last_gc
operator|+
name|min_expand
operator|&&
operator|!
name|ggc_force_collect
condition|)
return|return;
name|timevar_push
argument_list|(
name|TV_GC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" {GC %luk -> "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|G
operator|.
name|allocated
operator|/
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|GGC_DEBUG_LEVEL
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|G
operator|.
name|debug_file
argument_list|,
literal|"BEGIN COLLECTING\n"
argument_list|)
expr_stmt|;
comment|/* Zero the total allocated bytes.  This will be recalculated in the      sweep phase.  */
name|G
operator|.
name|allocated
operator|=
literal|0
expr_stmt|;
comment|/* Release the pages we freed the last time we collected, but didn't      reuse in the interim.  */
name|release_pages
argument_list|()
expr_stmt|;
comment|/* Indicate that we've seen collections at this context depth.  */
name|G
operator|.
name|context_depth_collections
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
operator|(
name|G
operator|.
name|context_depth
operator|+
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|clear_marks
argument_list|()
expr_stmt|;
name|ggc_mark_roots
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|ggc_prune_overhead_list
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|poison_pages
argument_list|()
expr_stmt|;
name|validate_free_objects
argument_list|()
expr_stmt|;
name|sweep_pages
argument_list|()
expr_stmt|;
name|G
operator|.
name|allocated_last_gc
operator|=
name|G
operator|.
name|allocated
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_GC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%luk}"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|G
operator|.
name|allocated
operator|/
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|GGC_DEBUG_LEVEL
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|G
operator|.
name|debug_file
argument_list|,
literal|"END COLLECTING\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print allocation statistics.  */
end_comment

begin_define
define|#
directive|define
name|SCALE
parameter_list|(
name|x
parameter_list|)
value|((unsigned long) ((x)< 1024*10 \ 		  ? (x) \ 		  : ((x)< 1024*1024*10 \ 		     ? (x) / 1024 \ 		     : (x) / (1024*1024))))
end_define

begin_define
define|#
directive|define
name|STAT_LABEL
parameter_list|(
name|x
parameter_list|)
value|((x)< 1024*10 ? ' ' : ((x)< 1024*1024*10 ? 'k' : 'M'))
end_define

begin_function
name|void
name|ggc_print_statistics
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ggc_statistics
name|stats
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|size_t
name|total_overhead
init|=
literal|0
decl_stmt|;
comment|/* Clear the statistics.  */
name|memset
argument_list|(
operator|&
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stats
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure collection will really occur.  */
name|G
operator|.
name|allocated_last_gc
operator|=
literal|0
expr_stmt|;
comment|/* Collect and print the statistics common across collectors.  */
name|ggc_print_common_statistics
argument_list|(
name|stderr
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
comment|/* Release free pages so that we will not count the bytes allocated      there as part of the total allocated memory.  */
name|release_pages
argument_list|()
expr_stmt|;
comment|/* Collect some information about the various sizes of      allocation.  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Memory still allocated at the end of the compilation process\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-5s %10s  %10s  %10s\n"
argument_list|,
literal|"Size"
argument_list|,
literal|"Allocated"
argument_list|,
literal|"Used"
argument_list|,
literal|"Overhead"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ORDERS
condition|;
operator|++
name|i
control|)
block|{
name|page_entry
modifier|*
name|p
decl_stmt|;
name|size_t
name|allocated
decl_stmt|;
name|size_t
name|in_use
decl_stmt|;
name|size_t
name|overhead
decl_stmt|;
comment|/* Skip empty entries.  */
if|if
condition|(
operator|!
name|G
operator|.
name|pages
index|[
name|i
index|]
condition|)
continue|continue;
name|overhead
operator|=
name|allocated
operator|=
name|in_use
operator|=
literal|0
expr_stmt|;
comment|/* Figure out the total number of bytes allocated for objects of 	 this size, and how many of them are actually in use.  Also figure 	 out how much memory the page table is using.  */
for|for
control|(
name|p
operator|=
name|G
operator|.
name|pages
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|allocated
operator|+=
name|p
operator|->
name|bytes
expr_stmt|;
name|in_use
operator|+=
operator|(
name|OBJECTS_IN_PAGE
argument_list|(
name|p
argument_list|)
operator|-
name|p
operator|->
name|num_free_objects
operator|)
operator|*
name|OBJECT_SIZE
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|overhead
operator|+=
operator|(
sizeof|sizeof
argument_list|(
name|page_entry
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|+
name|BITMAP_SIZE
argument_list|(
name|OBJECTS_IN_PAGE
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-5lu %10lu%c %10lu%c %10lu%c\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|OBJECT_SIZE
argument_list|(
name|i
argument_list|)
argument_list|,
name|SCALE
argument_list|(
name|allocated
argument_list|)
argument_list|,
name|STAT_LABEL
argument_list|(
name|allocated
argument_list|)
argument_list|,
name|SCALE
argument_list|(
name|in_use
argument_list|)
argument_list|,
name|STAT_LABEL
argument_list|(
name|in_use
argument_list|)
argument_list|,
name|SCALE
argument_list|(
name|overhead
argument_list|)
argument_list|,
name|STAT_LABEL
argument_list|(
name|overhead
argument_list|)
argument_list|)
expr_stmt|;
name|total_overhead
operator|+=
name|overhead
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-5s %10lu%c %10lu%c %10lu%c\n"
argument_list|,
literal|"Total"
argument_list|,
name|SCALE
argument_list|(
name|G
operator|.
name|bytes_mapped
argument_list|)
argument_list|,
name|STAT_LABEL
argument_list|(
name|G
operator|.
name|bytes_mapped
argument_list|)
argument_list|,
name|SCALE
argument_list|(
name|G
operator|.
name|allocated
argument_list|)
argument_list|,
name|STAT_LABEL
argument_list|(
name|G
operator|.
name|allocated
argument_list|)
argument_list|,
name|SCALE
argument_list|(
name|total_overhead
argument_list|)
argument_list|,
name|STAT_LABEL
argument_list|(
name|total_overhead
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nTotal allocations and overheads during the compilation process\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total Overhead:                        %10lld\n"
argument_list|,
name|G
operator|.
name|stats
operator|.
name|total_overhead
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total Allocated:                       %10lld\n"
argument_list|,
name|G
operator|.
name|stats
operator|.
name|total_allocated
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total Overhead  under  32B:            %10lld\n"
argument_list|,
name|G
operator|.
name|stats
operator|.
name|total_overhead_under32
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total Allocated under  32B:            %10lld\n"
argument_list|,
name|G
operator|.
name|stats
operator|.
name|total_allocated_under32
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total Overhead  under  64B:            %10lld\n"
argument_list|,
name|G
operator|.
name|stats
operator|.
name|total_overhead_under64
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total Allocated under  64B:            %10lld\n"
argument_list|,
name|G
operator|.
name|stats
operator|.
name|total_allocated_under64
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total Overhead  under 128B:            %10lld\n"
argument_list|,
name|G
operator|.
name|stats
operator|.
name|total_overhead_under128
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total Allocated under 128B:            %10lld\n"
argument_list|,
name|G
operator|.
name|stats
operator|.
name|total_allocated_under128
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ORDERS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|G
operator|.
name|stats
operator|.
name|total_allocated_per_order
index|[
name|i
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total Overhead  page size %7d:     %10lld\n"
argument_list|,
name|OBJECT_SIZE
argument_list|(
name|i
argument_list|)
argument_list|,
name|G
operator|.
name|stats
operator|.
name|total_overhead_per_order
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total Allocated page size %7d:     %10lld\n"
argument_list|,
name|OBJECT_SIZE
argument_list|(
name|i
argument_list|)
argument_list|,
name|G
operator|.
name|stats
operator|.
name|total_allocated_per_order
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|ggc_pch_data
block|{
struct|struct
name|ggc_pch_ondisk
block|{
name|unsigned
name|totals
index|[
name|NUM_ORDERS
index|]
decl_stmt|;
block|}
name|d
struct|;
name|size_t
name|base
index|[
name|NUM_ORDERS
index|]
decl_stmt|;
name|size_t
name|written
index|[
name|NUM_ORDERS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|struct
name|ggc_pch_data
modifier|*
name|init_ggc_pch
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|XCNEW
argument_list|(
expr|struct
name|ggc_pch_data
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ggc_pch_count_object
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
parameter_list|,
name|void
modifier|*
name|x
name|ATTRIBUTE_UNUSED
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|is_string
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|gt_types_enum
name|type
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|order
decl_stmt|;
if|if
condition|(
name|size
operator|<
name|NUM_SIZE_LOOKUP
condition|)
name|order
operator|=
name|size_lookup
index|[
name|size
index|]
expr_stmt|;
else|else
block|{
name|order
operator|=
literal|10
expr_stmt|;
while|while
condition|(
name|size
operator|>
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
condition|)
name|order
operator|++
expr_stmt|;
block|}
name|d
operator|->
name|d
operator|.
name|totals
index|[
name|order
index|]
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|ggc_pch_total_size
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
parameter_list|)
block|{
name|size_t
name|a
init|=
literal|0
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ORDERS
condition|;
name|i
operator|++
control|)
name|a
operator|+=
name|ROUND_UP
argument_list|(
name|d
operator|->
name|d
operator|.
name|totals
index|[
name|i
index|]
operator|*
name|OBJECT_SIZE
argument_list|(
name|i
argument_list|)
argument_list|,
name|G
operator|.
name|pagesize
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_function

begin_function
name|void
name|ggc_pch_this_base
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
parameter_list|,
name|void
modifier|*
name|base
parameter_list|)
block|{
name|size_t
name|a
init|=
operator|(
name|size_t
operator|)
name|base
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ORDERS
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|->
name|base
index|[
name|i
index|]
operator|=
name|a
expr_stmt|;
name|a
operator|+=
name|ROUND_UP
argument_list|(
name|d
operator|->
name|d
operator|.
name|totals
index|[
name|i
index|]
operator|*
name|OBJECT_SIZE
argument_list|(
name|i
argument_list|)
argument_list|,
name|G
operator|.
name|pagesize
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|ggc_pch_alloc_object
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
parameter_list|,
name|void
modifier|*
name|x
name|ATTRIBUTE_UNUSED
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|is_string
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|gt_types_enum
name|type
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|order
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|size
operator|<
name|NUM_SIZE_LOOKUP
condition|)
name|order
operator|=
name|size_lookup
index|[
name|size
index|]
expr_stmt|;
else|else
block|{
name|order
operator|=
literal|10
expr_stmt|;
while|while
condition|(
name|size
operator|>
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
condition|)
name|order
operator|++
expr_stmt|;
block|}
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|d
operator|->
name|base
index|[
name|order
index|]
expr_stmt|;
name|d
operator|->
name|base
index|[
name|order
index|]
operator|+=
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
name|ggc_pch_prepare_write
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
name|ATTRIBUTE_UNUSED
parameter_list|,
name|FILE
modifier|*
name|f
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Nothing to do.  */
block|}
end_function

begin_function
name|void
name|ggc_pch_write_object
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
name|ATTRIBUTE_UNUSED
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|newx
name|ATTRIBUTE_UNUSED
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|is_string
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|order
decl_stmt|;
specifier|static
specifier|const
name|char
name|emptyBytes
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|size
operator|<
name|NUM_SIZE_LOOKUP
condition|)
name|order
operator|=
name|size_lookup
index|[
name|size
index|]
expr_stmt|;
else|else
block|{
name|order
operator|=
literal|10
expr_stmt|;
while|while
condition|(
name|size
operator|>
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
condition|)
name|order
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fwrite
argument_list|(
name|x
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_error
argument_list|(
literal|"can't write PCH file: %m"
argument_list|)
expr_stmt|;
comment|/* If SIZE is not the same as OBJECT_SIZE(order), then we need to pad the      object out to OBJECT_SIZE(order).  This happens for strings.  */
if|if
condition|(
name|size
operator|!=
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
condition|)
block|{
name|unsigned
name|padding
init|=
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
operator|-
name|size
decl_stmt|;
comment|/* To speed small writes, we use a nulled-out array that's larger          than most padding requests as the source for our null bytes.  This          permits us to do the padding with fwrite() rather than fseek(), and          limits the chance the OS may try to flush any outstanding writes.  */
if|if
condition|(
name|padding
operator|<=
sizeof|sizeof
argument_list|(
name|emptyBytes
argument_list|)
condition|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|emptyBytes
argument_list|,
literal|1
argument_list|,
name|padding
argument_list|,
name|f
argument_list|)
operator|!=
name|padding
condition|)
name|fatal_error
argument_list|(
literal|"can't write PCH file"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Larger than our buffer?  Just default to fseek.  */
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
name|padding
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"can't write PCH file"
argument_list|)
expr_stmt|;
block|}
block|}
name|d
operator|->
name|written
index|[
name|order
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|written
index|[
name|order
index|]
operator|==
name|d
operator|->
name|d
operator|.
name|totals
index|[
name|order
index|]
operator|&&
name|fseek
argument_list|(
name|f
argument_list|,
name|ROUND_UP_VALUE
argument_list|(
name|d
operator|->
name|d
operator|.
name|totals
index|[
name|order
index|]
operator|*
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
argument_list|,
name|G
operator|.
name|pagesize
argument_list|)
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"can't write PCH file: %m"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ggc_pch_finish
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|d
operator|->
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|d
operator|->
name|d
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_error
argument_list|(
literal|"can't write PCH file: %m"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move the PCH PTE entries just added to the end of by_depth, to the    front.  */
end_comment

begin_function
specifier|static
name|void
name|move_ptes_to_front
parameter_list|(
name|int
name|count_old_page_tables
parameter_list|,
name|int
name|count_new_page_tables
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
comment|/* First, we swap the new entries to the front of the varrays.  */
name|page_entry
modifier|*
modifier|*
name|new_by_depth
decl_stmt|;
name|unsigned
name|long
modifier|*
modifier|*
name|new_save_in_use
decl_stmt|;
name|new_by_depth
operator|=
name|XNEWVEC
argument_list|(
name|page_entry
operator|*
argument_list|,
name|G
operator|.
name|by_depth_max
argument_list|)
expr_stmt|;
name|new_save_in_use
operator|=
name|XNEWVEC
argument_list|(
argument|unsigned long *
argument_list|,
argument|G.by_depth_max
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|new_by_depth
index|[
literal|0
index|]
argument_list|,
operator|&
name|G
operator|.
name|by_depth
index|[
name|count_old_page_tables
index|]
argument_list|,
name|count_new_page_tables
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|new_by_depth
index|[
name|count_new_page_tables
index|]
argument_list|,
operator|&
name|G
operator|.
name|by_depth
index|[
literal|0
index|]
argument_list|,
name|count_old_page_tables
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|new_save_in_use
index|[
literal|0
index|]
argument_list|,
operator|&
name|G
operator|.
name|save_in_use
index|[
name|count_old_page_tables
index|]
argument_list|,
name|count_new_page_tables
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|new_save_in_use
index|[
name|count_new_page_tables
index|]
argument_list|,
operator|&
name|G
operator|.
name|save_in_use
index|[
literal|0
index|]
argument_list|,
name|count_old_page_tables
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|G
operator|.
name|by_depth
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|G
operator|.
name|save_in_use
argument_list|)
expr_stmt|;
name|G
operator|.
name|by_depth
operator|=
name|new_by_depth
expr_stmt|;
name|G
operator|.
name|save_in_use
operator|=
name|new_save_in_use
expr_stmt|;
comment|/* Now update all the index_by_depth fields.  */
for|for
control|(
name|i
operator|=
name|G
operator|.
name|by_depth_in_use
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|page_entry
modifier|*
name|p
init|=
name|G
operator|.
name|by_depth
index|[
name|i
operator|-
literal|1
index|]
decl_stmt|;
name|p
operator|->
name|index_by_depth
operator|=
name|i
operator|-
literal|1
expr_stmt|;
block|}
comment|/* And last, we update the depth pointers in G.depth.  The first      entry is already 0, and context 0 entries always start at index      0, so there is nothing to update in the first slot.  We need a      second slot, only if we have old ptes, and if we do, they start      at index count_new_page_tables.  */
if|if
condition|(
name|count_old_page_tables
condition|)
name|push_depth
argument_list|(
name|count_new_page_tables
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ggc_pch_read
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|ggc_pch_ondisk
name|d
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|char
modifier|*
name|offs
init|=
name|addr
decl_stmt|;
name|unsigned
name|long
name|count_old_page_tables
decl_stmt|;
name|unsigned
name|long
name|count_new_page_tables
decl_stmt|;
name|count_old_page_tables
operator|=
name|G
operator|.
name|by_depth_in_use
expr_stmt|;
comment|/* We've just read in a PCH file.  So, every object that used to be      allocated is now free.  */
name|clear_marks
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_GC_CHECKING
name|poison_pages
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* No object read from a PCH file should ever be freed.  So, set the      context depth to 1, and set the depth of all the currently-allocated      pages to be 1 too.  PCH pages will have depth 0.  */
name|gcc_assert
argument_list|(
operator|!
name|G
operator|.
name|context_depth
argument_list|)
expr_stmt|;
name|G
operator|.
name|context_depth
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ORDERS
condition|;
name|i
operator|++
control|)
block|{
name|page_entry
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|G
operator|.
name|pages
index|[
name|i
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|p
operator|->
name|context_depth
operator|=
name|G
operator|.
name|context_depth
expr_stmt|;
block|}
comment|/* Allocate the appropriate page-table entries for the pages read from      the PCH file.  */
if|if
condition|(
name|fread
argument_list|(
operator|&
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|d
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_error
argument_list|(
literal|"can't read PCH file: %m"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ORDERS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|page_entry
modifier|*
name|entry
decl_stmt|;
name|char
modifier|*
name|pte
decl_stmt|;
name|size_t
name|bytes
decl_stmt|;
name|size_t
name|num_objs
decl_stmt|;
name|size_t
name|j
decl_stmt|;
if|if
condition|(
name|d
operator|.
name|totals
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|bytes
operator|=
name|ROUND_UP
argument_list|(
name|d
operator|.
name|totals
index|[
name|i
index|]
operator|*
name|OBJECT_SIZE
argument_list|(
name|i
argument_list|)
argument_list|,
name|G
operator|.
name|pagesize
argument_list|)
expr_stmt|;
name|num_objs
operator|=
name|bytes
operator|/
name|OBJECT_SIZE
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|entry
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|page_entry
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|+
name|BITMAP_SIZE
argument_list|(
name|num_objs
operator|+
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|bytes
operator|=
name|bytes
expr_stmt|;
name|entry
operator|->
name|page
operator|=
name|offs
expr_stmt|;
name|entry
operator|->
name|context_depth
operator|=
literal|0
expr_stmt|;
name|offs
operator|+=
name|bytes
expr_stmt|;
name|entry
operator|->
name|num_free_objects
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|order
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|+
name|HOST_BITS_PER_LONG
operator|<=
name|num_objs
operator|+
literal|1
condition|;
name|j
operator|+=
name|HOST_BITS_PER_LONG
control|)
name|entry
operator|->
name|in_use_p
index|[
name|j
operator|/
name|HOST_BITS_PER_LONG
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
name|j
operator|<
name|num_objs
operator|+
literal|1
condition|;
name|j
operator|++
control|)
name|entry
operator|->
name|in_use_p
index|[
name|j
operator|/
name|HOST_BITS_PER_LONG
index|]
operator||=
literal|1L
operator|<<
operator|(
name|j
operator|%
name|HOST_BITS_PER_LONG
operator|)
expr_stmt|;
for|for
control|(
name|pte
operator|=
name|entry
operator|->
name|page
init|;
name|pte
operator|<
name|entry
operator|->
name|page
operator|+
name|entry
operator|->
name|bytes
condition|;
name|pte
operator|+=
name|G
operator|.
name|pagesize
control|)
name|set_page_table_entry
argument_list|(
name|pte
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|G
operator|.
name|page_tails
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|G
operator|.
name|page_tails
index|[
name|i
index|]
operator|->
name|next
operator|=
name|entry
expr_stmt|;
else|else
name|G
operator|.
name|pages
index|[
name|i
index|]
operator|=
name|entry
expr_stmt|;
name|G
operator|.
name|page_tails
index|[
name|i
index|]
operator|=
name|entry
expr_stmt|;
comment|/* We start off by just adding all the new information to the 	 end of the varrays, later, we will move the new information 	 to the front of the varrays, as the PCH page tables are at 	 context 0.  */
name|push_by_depth
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Now, we update the various data structures that speed page table      handling.  */
name|count_new_page_tables
operator|=
name|G
operator|.
name|by_depth_in_use
operator|-
name|count_old_page_tables
expr_stmt|;
name|move_ptes_to_front
argument_list|(
name|count_old_page_tables
argument_list|,
name|count_new_page_tables
argument_list|)
expr_stmt|;
comment|/* Update the statistics.  */
name|G
operator|.
name|allocated
operator|=
name|G
operator|.
name|allocated_last_gc
operator|=
name|offs
operator|-
operator|(
name|char
operator|*
operator|)
name|addr
expr_stmt|;
block|}
end_function

end_unit

