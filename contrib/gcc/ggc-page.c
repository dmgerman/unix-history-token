begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* "Bag-of-pages" garbage collector for the GNU compiler.    Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_comment
comment|/* Prefer MAP_ANON(YMOUS) to /dev/zero, since we don't need to keep a    file open.  Prefer either to valloc.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MMAP_ANON
end_ifdef

begin_undef
undef|#
directive|undef
name|HAVE_MMAP_DEV_ZERO
end_undef

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAP_FAILED
end_ifndef

begin_define
define|#
directive|define
name|MAP_FAILED
value|-1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAP_ANONYMOUS
argument_list|)
operator|&&
name|defined
argument_list|(
name|MAP_ANON
argument_list|)
end_if

begin_define
define|#
directive|define
name|MAP_ANONYMOUS
value|MAP_ANON
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|USING_MMAP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MMAP_DEV_ZERO
end_ifdef

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAP_FAILED
end_ifndef

begin_define
define|#
directive|define
name|MAP_FAILED
value|-1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|USING_MMAP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|USING_MMAP
end_ifndef

begin_define
define|#
directive|define
name|USING_MALLOC_PAGE_GROUPS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Stategy:      This garbage-collecting allocator allocates objects on one of a set    of pages.  Each page can allocate objects of a single size only;    available sizes are powers of two starting at four bytes.  The size    of an allocation request is rounded up to the next power of two    (`order'), and satisfied from the appropriate page.     Each page is recorded in a page-entry, which also maintains an    in-use bitmap of object positions on the page.  This allows the    allocation state of a particular object to be flipped without    touching the page itself.     Each page-entry also has a context depth, which is used to track    pushing and popping of allocation contexts.  Only objects allocated    in the current (highest-numbered) context may be collected.       Page entries are arranged in an array of singly-linked lists.  The    array is indexed by the allocation size, in bits, of the pages on    it; i.e. all pages on a list allocate objects of the same size.    Pages are ordered on the list such that all non-full pages precede    all full pages, with non-full pages arranged in order of decreasing    context depth.     Empty pages (of all orders) are kept on a single page cache list,    and are considered first when new pages are required; they are    deallocated at the start of the next collection if they haven't    been recycled by then.  */
end_comment

begin_comment
comment|/* Define GGC_POISON to poison memory marked unused by the collector.  */
end_comment

begin_undef
undef|#
directive|undef
name|GGC_POISON
end_undef

begin_comment
comment|/* Define GGC_ALWAYS_COLLECT to perform collection every time    ggc_collect is invoked.  Otherwise, collection is performed only    when a significant amount of memory has been allocated since the    last collection.  */
end_comment

begin_undef
undef|#
directive|undef
name|GGC_ALWAYS_COLLECT
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_GC_CHECKING
end_ifdef

begin_define
define|#
directive|define
name|GGC_POISON
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_GC_ALWAYS_COLLECT
end_ifdef

begin_define
define|#
directive|define
name|GGC_ALWAYS_COLLECT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define GGC_DEBUG_LEVEL to print debugging information.      0: No debugging output.      1: GC statistics only.      2: Page-entry allocations/deallocations as well.      3: Object allocations as well.      4: Object marks as well.  */
end_comment

begin_define
define|#
directive|define
name|GGC_DEBUG_LEVEL
value|(0)
end_define

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|HOST_BITS_PER_PTR
end_ifndef

begin_define
define|#
directive|define
name|HOST_BITS_PER_PTR
value|HOST_BITS_PER_LONG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* A two-level tree is used to look up the page-entry for a given    pointer.  Two chunks of the pointer's bits are extracted to index    the first and second levels of the tree, as follows:  				   HOST_PAGE_SIZE_BITS 			   32		|      |        msb +----------------+----+------+------+ lsb 			    |    |      | 			 PAGE_L1_BITS   | 				 |      | 			       PAGE_L2_BITS     The bottommost HOST_PAGE_SIZE_BITS are ignored, since page-entry    pages are aligned on system page boundaries.  The next most    significant PAGE_L2_BITS and PAGE_L1_BITS are the second and first    index values in the lookup table, respectively.       For 32-bit architectures and the settings below, there are no    leftover bits.  For architectures with wider pointers, the lookup    tree points to a list of pages, which must be scanned to find the    correct one.  */
end_comment

begin_define
define|#
directive|define
name|PAGE_L1_BITS
value|(8)
end_define

begin_define
define|#
directive|define
name|PAGE_L2_BITS
value|(32 - PAGE_L1_BITS - G.lg_pagesize)
end_define

begin_define
define|#
directive|define
name|PAGE_L1_SIZE
value|((size_t) 1<< PAGE_L1_BITS)
end_define

begin_define
define|#
directive|define
name|PAGE_L2_SIZE
value|((size_t) 1<< PAGE_L2_BITS)
end_define

begin_define
define|#
directive|define
name|LOOKUP_L1
parameter_list|(
name|p
parameter_list|)
define|\
value|(((size_t) (p)>> (32 - PAGE_L1_BITS))& ((1<< PAGE_L1_BITS) - 1))
end_define

begin_define
define|#
directive|define
name|LOOKUP_L2
parameter_list|(
name|p
parameter_list|)
define|\
value|(((size_t) (p)>> G.lg_pagesize)& ((1<< PAGE_L2_BITS) - 1))
end_define

begin_comment
comment|/* The number of objects per allocation page, for objects on a page of    the indicated ORDER.  */
end_comment

begin_define
define|#
directive|define
name|OBJECTS_PER_PAGE
parameter_list|(
name|ORDER
parameter_list|)
value|objects_per_page_table[ORDER]
end_define

begin_comment
comment|/* The size of an object on a page of the indicated ORDER.  */
end_comment

begin_define
define|#
directive|define
name|OBJECT_SIZE
parameter_list|(
name|ORDER
parameter_list|)
value|object_size_table[ORDER]
end_define

begin_comment
comment|/* The number of extra orders, not corresponding to power-of-two sized    objects.  */
end_comment

begin_define
define|#
directive|define
name|NUM_EXTRA_ORDERS
define|\
value|(sizeof (extra_order_size_table) / sizeof (extra_order_size_table[0]))
end_define

begin_comment
comment|/* The Ith entry is the maximum size of an object to be stored in the    Ith extra order.  Adding a new entry to this array is the *only*    thing you need to do to add a new special allocation size.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|size_t
name|extra_order_size_table
index|[]
init|=
block|{
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl
argument_list|)
block|,
expr|sizeof
operator|(
expr|struct
name|tree_list
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The total number of orders.  */
end_comment

begin_define
define|#
directive|define
name|NUM_ORDERS
value|(HOST_BITS_PER_PTR + NUM_EXTRA_ORDERS)
end_define

begin_comment
comment|/* We use this structure to determine the alignment required for    allocations.  For power-of-two sized allocations, that's not a    problem, but it does matter for odd-sized allocations.  */
end_comment

begin_struct
struct|struct
name|max_alignment
block|{
name|char
name|c
decl_stmt|;
union|union
block|{
name|HOST_WIDEST_INT
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LONG_DOUBLE
name|long
name|double
name|d
decl_stmt|;
else|#
directive|else
name|double
name|d
decl_stmt|;
endif|#
directive|endif
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* The biggest alignment required.  */
end_comment

begin_define
define|#
directive|define
name|MAX_ALIGNMENT
value|(offsetof (struct max_alignment, u))
end_define

begin_comment
comment|/* The Ith entry is the number of objects on a page or order I.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|objects_per_page_table
index|[
name|NUM_ORDERS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The Ith entry is the size of an object on a page of order I.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|object_size_table
index|[
name|NUM_ORDERS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A page_entry records the status of an allocation page.  This    structure is dynamically sized to fit the bitmap in_use_p.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|page_entry
block|{
comment|/* The next page-entry with objects of the same size, or NULL if      this is the last page-entry.  */
name|struct
name|page_entry
modifier|*
name|next
decl_stmt|;
comment|/* The number of bytes allocated.  (This will always be a multiple      of the host system page size.)  */
name|size_t
name|bytes
decl_stmt|;
comment|/* The address at which the memory is allocated.  */
name|char
modifier|*
name|page
decl_stmt|;
ifdef|#
directive|ifdef
name|USING_MALLOC_PAGE_GROUPS
comment|/* Back pointer to the page group this page came from.  */
name|struct
name|page_group
modifier|*
name|group
decl_stmt|;
endif|#
directive|endif
comment|/* Saved in-use bit vector for pages that aren't in the topmost      context during collection.  */
name|unsigned
name|long
modifier|*
name|save_in_use_p
decl_stmt|;
comment|/* Context depth of this page.  */
name|unsigned
name|short
name|context_depth
decl_stmt|;
comment|/* The number of free objects remaining on this page.  */
name|unsigned
name|short
name|num_free_objects
decl_stmt|;
comment|/* A likely candidate for the bit position of a free object for the      next allocation from this page.  */
name|unsigned
name|short
name|next_bit_hint
decl_stmt|;
comment|/* The lg of size of objects allocated from this page.  */
name|unsigned
name|char
name|order
decl_stmt|;
comment|/* A bit vector indicating whether or not objects are in use.  The      Nth bit is one if the Nth object on this page is allocated.  This      array is dynamically sized.  */
name|unsigned
name|long
name|in_use_p
index|[
literal|1
index|]
decl_stmt|;
block|}
name|page_entry
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|USING_MALLOC_PAGE_GROUPS
end_ifdef

begin_comment
comment|/* A page_group describes a large allocation from malloc, from which    we parcel out aligned pages.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|page_group
block|{
comment|/* A linked list of all extant page groups.  */
name|struct
name|page_group
modifier|*
name|next
decl_stmt|;
comment|/* The address we received from malloc.  */
name|char
modifier|*
name|allocation
decl_stmt|;
comment|/* The size of the block.  */
name|size_t
name|alloc_size
decl_stmt|;
comment|/* A bitmask of pages in use.  */
name|unsigned
name|int
name|in_use
decl_stmt|;
block|}
name|page_group
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HOST_BITS_PER_PTR
operator|<=
literal|32
end_if

begin_comment
comment|/* On 32-bit hosts, we use a two level page table, as pictured above.  */
end_comment

begin_typedef
typedef|typedef
name|page_entry
modifier|*
modifier|*
name|page_table
index|[
name|PAGE_L1_SIZE
index|]
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* On 64-bit hosts, we use the same two level page tables plus a linked    list that disambiguates the top 32-bits.  There will almost always be    exactly one entry in the list.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|page_table_chain
block|{
name|struct
name|page_table_chain
modifier|*
name|next
decl_stmt|;
name|size_t
name|high_bits
decl_stmt|;
name|page_entry
modifier|*
modifier|*
name|table
index|[
name|PAGE_L1_SIZE
index|]
decl_stmt|;
block|}
typedef|*
name|page_table
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The rest of the global variables.  */
end_comment

begin_struct
specifier|static
struct|struct
name|globals
block|{
comment|/* The Nth element in this array is a page with objects of size 2^N.      If there are any pages with free objects, they will be at the      head of the list.  NULL if there are no page-entries for this      object size.  */
name|page_entry
modifier|*
name|pages
index|[
name|NUM_ORDERS
index|]
decl_stmt|;
comment|/* The Nth element in this array is the last page with objects of      size 2^N.  NULL if there are no page-entries for this object      size.  */
name|page_entry
modifier|*
name|page_tails
index|[
name|NUM_ORDERS
index|]
decl_stmt|;
comment|/* Lookup table for associating allocation pages with object addresses.  */
name|page_table
name|lookup
decl_stmt|;
comment|/* The system's page size.  */
name|size_t
name|pagesize
decl_stmt|;
name|size_t
name|lg_pagesize
decl_stmt|;
comment|/* Bytes currently allocated.  */
name|size_t
name|allocated
decl_stmt|;
comment|/* Bytes currently allocated at the end of the last collection.  */
name|size_t
name|allocated_last_gc
decl_stmt|;
comment|/* Total amount of memory mapped.  */
name|size_t
name|bytes_mapped
decl_stmt|;
comment|/* The current depth in the context stack.  */
name|unsigned
name|short
name|context_depth
decl_stmt|;
comment|/* A file descriptor open to /dev/zero for reading.  */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MMAP_DEV_ZERO
argument_list|)
name|int
name|dev_zero_fd
decl_stmt|;
endif|#
directive|endif
comment|/* A cache of free system pages.  */
name|page_entry
modifier|*
name|free_pages
decl_stmt|;
ifdef|#
directive|ifdef
name|USING_MALLOC_PAGE_GROUPS
name|page_group
modifier|*
name|page_groups
decl_stmt|;
endif|#
directive|endif
comment|/* The file descriptor for debugging output.  */
name|FILE
modifier|*
name|debug_file
decl_stmt|;
block|}
name|G
struct|;
end_struct

begin_comment
comment|/* The size in bytes required to maintain a bitmap for the objects    on a page-entry.  */
end_comment

begin_define
define|#
directive|define
name|BITMAP_SIZE
parameter_list|(
name|Num_objects
parameter_list|)
define|\
value|(CEIL ((Num_objects), HOST_BITS_PER_LONG) * sizeof(long))
end_define

begin_comment
comment|/* Skip garbage collection if the current allocation is not at least    this factor times the allocation at the end of the last collection.    In other words, total allocation must expand by (this factor minus    one) before collection is performed.  */
end_comment

begin_define
define|#
directive|define
name|GGC_MIN_EXPAND_FOR_GC
value|(1.3)
end_define

begin_comment
comment|/* Bound `allocated_last_gc' to 4MB, to prevent the memory expansion    test from triggering too often when the heap is small.  */
end_comment

begin_define
define|#
directive|define
name|GGC_MIN_LAST_ALLOCATED
value|(4 * 1024 * 1024)
end_define

begin_comment
comment|/* Allocate pages in chunks of this size, to throttle calls to memory    allocation routines.  The first page is used, the rest go onto the    free list.  This cannot be larger than HOST_BITS_PER_INT for the    in_use bitmask for page_group.  */
end_comment

begin_define
define|#
directive|define
name|GGC_QUIRE_SIZE
value|16
end_define

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|ggc_allocated_p
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|page_entry
modifier|*
name|lookup_page_table_entry
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_page_table_entry
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|page_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USING_MMAP
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|alloc_anon
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USING_MALLOC_PAGE_GROUPS
end_ifdef

begin_decl_stmt
specifier|static
name|size_t
name|page_group_index
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_page_group_in_use
name|PARAMS
argument_list|(
operator|(
name|page_group
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_page_group_in_use
name|PARAMS
argument_list|(
operator|(
name|page_group
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|page_entry
modifier|*
name|alloc_page
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_page
name|PARAMS
argument_list|(
operator|(
expr|struct
name|page_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|release_pages
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_marks
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sweep_pages
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ggc_recalculate_in_use_p
name|PARAMS
argument_list|(
operator|(
name|page_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|GGC_POISON
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|poison_pages
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|void
name|debug_print_page_list
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Returns non-zero if P was allocated in GC'able memory.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ggc_allocated_p
parameter_list|(
name|p
parameter_list|)
specifier|const
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|page_entry
modifier|*
modifier|*
modifier|*
name|base
decl_stmt|;
name|size_t
name|L1
decl_stmt|,
name|L2
decl_stmt|;
if|#
directive|if
name|HOST_BITS_PER_PTR
operator|<=
literal|32
name|base
operator|=
operator|&
name|G
operator|.
name|lookup
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
name|page_table
name|table
init|=
name|G
operator|.
name|lookup
decl_stmt|;
name|size_t
name|high_bits
init|=
operator|(
name|size_t
operator|)
name|p
operator|&
operator|~
operator|(
name|size_t
operator|)
literal|0xffffffff
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|table
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|table
operator|->
name|high_bits
operator|==
name|high_bits
condition|)
break|break;
name|table
operator|=
name|table
operator|->
name|next
expr_stmt|;
block|}
name|base
operator|=
operator|&
name|table
operator|->
name|table
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* Extract the level 1 and 2 indices.  */
name|L1
operator|=
name|LOOKUP_L1
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|L2
operator|=
name|LOOKUP_L2
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|base
index|[
name|L1
index|]
operator|&&
name|base
index|[
name|L1
index|]
index|[
name|L2
index|]
return|;
block|}
end_function

begin_comment
comment|/* Traverse the page table and find the entry for a page.     Die (probably) if the object wasn't allocated via GC.  */
end_comment

begin_function
specifier|static
specifier|inline
name|page_entry
modifier|*
name|lookup_page_table_entry
parameter_list|(
name|p
parameter_list|)
specifier|const
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|page_entry
modifier|*
modifier|*
modifier|*
name|base
decl_stmt|;
name|size_t
name|L1
decl_stmt|,
name|L2
decl_stmt|;
if|#
directive|if
name|HOST_BITS_PER_PTR
operator|<=
literal|32
name|base
operator|=
operator|&
name|G
operator|.
name|lookup
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
name|page_table
name|table
init|=
name|G
operator|.
name|lookup
decl_stmt|;
name|size_t
name|high_bits
init|=
operator|(
name|size_t
operator|)
name|p
operator|&
operator|~
operator|(
name|size_t
operator|)
literal|0xffffffff
decl_stmt|;
while|while
condition|(
name|table
operator|->
name|high_bits
operator|!=
name|high_bits
condition|)
name|table
operator|=
name|table
operator|->
name|next
expr_stmt|;
name|base
operator|=
operator|&
name|table
operator|->
name|table
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* Extract the level 1 and 2 indices.  */
name|L1
operator|=
name|LOOKUP_L1
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|L2
operator|=
name|LOOKUP_L2
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|base
index|[
name|L1
index|]
index|[
name|L2
index|]
return|;
block|}
end_function

begin_comment
comment|/* Set the page table entry for a page.  */
end_comment

begin_function
specifier|static
name|void
name|set_page_table_entry
parameter_list|(
name|p
parameter_list|,
name|entry
parameter_list|)
name|void
modifier|*
name|p
decl_stmt|;
name|page_entry
modifier|*
name|entry
decl_stmt|;
block|{
name|page_entry
modifier|*
modifier|*
modifier|*
name|base
decl_stmt|;
name|size_t
name|L1
decl_stmt|,
name|L2
decl_stmt|;
if|#
directive|if
name|HOST_BITS_PER_PTR
operator|<=
literal|32
name|base
operator|=
operator|&
name|G
operator|.
name|lookup
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
name|page_table
name|table
decl_stmt|;
name|size_t
name|high_bits
init|=
operator|(
name|size_t
operator|)
name|p
operator|&
operator|~
operator|(
name|size_t
operator|)
literal|0xffffffff
decl_stmt|;
for|for
control|(
name|table
operator|=
name|G
operator|.
name|lookup
init|;
name|table
condition|;
name|table
operator|=
name|table
operator|->
name|next
control|)
if|if
condition|(
name|table
operator|->
name|high_bits
operator|==
name|high_bits
condition|)
goto|goto
name|found
goto|;
comment|/* Not found -- allocate a new table.  */
name|table
operator|=
operator|(
name|page_table
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|table
argument_list|)
argument_list|)
expr_stmt|;
name|table
operator|->
name|next
operator|=
name|G
operator|.
name|lookup
expr_stmt|;
name|table
operator|->
name|high_bits
operator|=
name|high_bits
expr_stmt|;
name|G
operator|.
name|lookup
operator|=
name|table
expr_stmt|;
name|found
label|:
name|base
operator|=
operator|&
name|table
operator|->
name|table
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* Extract the level 1 and 2 indices.  */
name|L1
operator|=
name|LOOKUP_L1
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|L2
operator|=
name|LOOKUP_L2
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
index|[
name|L1
index|]
operator|==
name|NULL
condition|)
name|base
index|[
name|L1
index|]
operator|=
operator|(
name|page_entry
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
name|PAGE_L2_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
name|page_entry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|base
index|[
name|L1
index|]
index|[
name|L2
index|]
operator|=
name|entry
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prints the page-entry for object size ORDER, for debugging.  */
end_comment

begin_function
name|void
name|debug_print_page_list
parameter_list|(
name|order
parameter_list|)
name|int
name|order
decl_stmt|;
block|{
name|page_entry
modifier|*
name|p
decl_stmt|;
name|printf
argument_list|(
literal|"Head=%p, Tail=%p:\n"
argument_list|,
operator|(
name|PTR
operator|)
name|G
operator|.
name|pages
index|[
name|order
index|]
argument_list|,
operator|(
name|PTR
operator|)
name|G
operator|.
name|page_tails
index|[
name|order
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
name|G
operator|.
name|pages
index|[
name|order
index|]
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%p(%1d|%3d) -> "
argument_list|,
operator|(
name|PTR
operator|)
name|p
argument_list|,
name|p
operator|->
name|context_depth
argument_list|,
name|p
operator|->
name|num_free_objects
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"NULL\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USING_MMAP
end_ifdef

begin_comment
comment|/* Allocate SIZE bytes of anonymous memory, preferably near PREF,    (if non-null).  The ifdef structure here is intended to cause a    compile error unless exactly one of the HAVE_* is defined.  */
end_comment

begin_function
specifier|static
specifier|inline
name|char
modifier|*
name|alloc_anon
parameter_list|(
name|pref
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|pref
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_MMAP_ANON
name|char
modifier|*
name|page
init|=
operator|(
name|char
operator|*
operator|)
name|mmap
argument_list|(
name|pref
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_ANONYMOUS
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_MMAP_DEV_ZERO
name|char
modifier|*
name|page
init|=
operator|(
name|char
operator|*
operator|)
name|mmap
argument_list|(
name|pref
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|G
operator|.
name|dev_zero_fd
argument_list|,
literal|0
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|page
operator|==
operator|(
name|char
operator|*
operator|)
name|MAP_FAILED
condition|)
block|{
name|perror
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
comment|/* Remember that we allocated this memory.  */
name|G
operator|.
name|bytes_mapped
operator|+=
name|size
expr_stmt|;
return|return
name|page
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USING_MALLOC_PAGE_GROUPS
end_ifdef

begin_comment
comment|/* Compute the index for this page into the page group.  */
end_comment

begin_function
specifier|static
specifier|inline
name|size_t
name|page_group_index
parameter_list|(
name|allocation
parameter_list|,
name|page
parameter_list|)
name|char
modifier|*
name|allocation
decl_stmt|,
decl|*
name|page
decl_stmt|;
end_function

begin_block
block|{
return|return
call|(
name|size_t
call|)
argument_list|(
name|page
operator|-
name|allocation
argument_list|)
operator|>>
name|G
operator|.
name|lg_pagesize
return|;
block|}
end_block

begin_comment
comment|/* Set and clear the in_use bit for this page in the page group.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_page_group_in_use
parameter_list|(
name|group
parameter_list|,
name|page
parameter_list|)
name|page_group
modifier|*
name|group
decl_stmt|;
name|char
modifier|*
name|page
decl_stmt|;
block|{
name|group
operator|->
name|in_use
operator||=
literal|1
operator|<<
name|page_group_index
argument_list|(
name|group
operator|->
name|allocation
argument_list|,
name|page
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|clear_page_group_in_use
parameter_list|(
name|group
parameter_list|,
name|page
parameter_list|)
name|page_group
modifier|*
name|group
decl_stmt|;
name|char
modifier|*
name|page
decl_stmt|;
block|{
name|group
operator|->
name|in_use
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|page_group_index
argument_list|(
name|group
operator|->
name|allocation
argument_list|,
name|page
argument_list|)
operator|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Allocate a new page for allocating objects of size 2^ORDER,    and return an entry for it.  The entry is not added to the    appropriate page_table list.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|page_entry
modifier|*
name|alloc_page
parameter_list|(
name|order
parameter_list|)
name|unsigned
name|order
decl_stmt|;
block|{
name|struct
name|page_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|char
modifier|*
name|page
decl_stmt|;
name|size_t
name|num_objects
decl_stmt|;
name|size_t
name|bitmap_size
decl_stmt|;
name|size_t
name|page_entry_size
decl_stmt|;
name|size_t
name|entry_size
decl_stmt|;
ifdef|#
directive|ifdef
name|USING_MALLOC_PAGE_GROUPS
name|page_group
modifier|*
name|group
decl_stmt|;
endif|#
directive|endif
name|num_objects
operator|=
name|OBJECTS_PER_PAGE
argument_list|(
name|order
argument_list|)
expr_stmt|;
name|bitmap_size
operator|=
name|BITMAP_SIZE
argument_list|(
name|num_objects
operator|+
literal|1
argument_list|)
expr_stmt|;
name|page_entry_size
operator|=
sizeof|sizeof
argument_list|(
name|page_entry
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|+
name|bitmap_size
expr_stmt|;
name|entry_size
operator|=
name|num_objects
operator|*
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry_size
operator|<
name|G
operator|.
name|pagesize
condition|)
name|entry_size
operator|=
name|G
operator|.
name|pagesize
expr_stmt|;
name|entry
operator|=
name|NULL
expr_stmt|;
name|page
operator|=
name|NULL
expr_stmt|;
comment|/* Check the list of free pages for one we can use.  */
for|for
control|(
name|pp
operator|=
operator|&
name|G
operator|.
name|free_pages
operator|,
name|p
operator|=
operator|*
name|pp
init|;
name|p
condition|;
name|pp
operator|=
operator|&
name|p
operator|->
name|next
operator|,
name|p
operator|=
operator|*
name|pp
control|)
if|if
condition|(
name|p
operator|->
name|bytes
operator|==
name|entry_size
condition|)
break|break;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* Recycle the allocated memory from this page ...  */
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|page
operator|=
name|p
operator|->
name|page
expr_stmt|;
ifdef|#
directive|ifdef
name|USING_MALLOC_PAGE_GROUPS
name|group
operator|=
name|p
operator|->
name|group
expr_stmt|;
endif|#
directive|endif
comment|/* ... and, if possible, the page entry itself.  */
if|if
condition|(
name|p
operator|->
name|order
operator|==
name|order
condition|)
block|{
name|entry
operator|=
name|p
expr_stmt|;
name|memset
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|,
name|page_entry_size
argument_list|)
expr_stmt|;
block|}
else|else
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USING_MMAP
elseif|else
if|if
condition|(
name|entry_size
operator|==
name|G
operator|.
name|pagesize
condition|)
block|{
comment|/* We want just one page.  Allocate a bunch of them and put the 	 extras on the freelist.  (Can only do this optimization with 	 mmap for backing store.)  */
name|struct
name|page_entry
modifier|*
name|e
decl_stmt|,
modifier|*
name|f
init|=
name|G
operator|.
name|free_pages
decl_stmt|;
name|int
name|i
decl_stmt|;
name|page
operator|=
name|alloc_anon
argument_list|(
name|NULL
argument_list|,
name|G
operator|.
name|pagesize
operator|*
name|GGC_QUIRE_SIZE
argument_list|)
expr_stmt|;
comment|/* This loop counts down so that the chain will be in ascending 	 memory order.  */
for|for
control|(
name|i
operator|=
name|GGC_QUIRE_SIZE
operator|-
literal|1
init|;
name|i
operator|>=
literal|1
condition|;
name|i
operator|--
control|)
block|{
name|e
operator|=
operator|(
expr|struct
name|page_entry
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|page_entry_size
argument_list|)
expr_stmt|;
name|e
operator|->
name|order
operator|=
name|order
expr_stmt|;
name|e
operator|->
name|bytes
operator|=
name|G
operator|.
name|pagesize
expr_stmt|;
name|e
operator|->
name|page
operator|=
name|page
operator|+
operator|(
name|i
operator|<<
name|G
operator|.
name|lg_pagesize
operator|)
expr_stmt|;
name|e
operator|->
name|next
operator|=
name|f
expr_stmt|;
name|f
operator|=
name|e
expr_stmt|;
block|}
name|G
operator|.
name|free_pages
operator|=
name|f
expr_stmt|;
block|}
else|else
name|page
operator|=
name|alloc_anon
argument_list|(
name|NULL
argument_list|,
name|entry_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USING_MALLOC_PAGE_GROUPS
else|else
block|{
comment|/* Allocate a large block of memory and serve out the aligned 	 pages therein.  This results in much less memory wastage 	 than the traditional implementation of valloc.  */
name|char
modifier|*
name|allocation
decl_stmt|,
modifier|*
name|a
decl_stmt|,
modifier|*
name|enda
decl_stmt|;
name|size_t
name|alloc_size
decl_stmt|,
name|head_slop
decl_stmt|,
name|tail_slop
decl_stmt|;
name|int
name|multiple_pages
init|=
operator|(
name|entry_size
operator|==
name|G
operator|.
name|pagesize
operator|)
decl_stmt|;
if|if
condition|(
name|multiple_pages
condition|)
name|alloc_size
operator|=
name|GGC_QUIRE_SIZE
operator|*
name|G
operator|.
name|pagesize
expr_stmt|;
else|else
name|alloc_size
operator|=
name|entry_size
operator|+
name|G
operator|.
name|pagesize
operator|-
literal|1
expr_stmt|;
name|allocation
operator|=
name|xmalloc
argument_list|(
name|alloc_size
argument_list|)
expr_stmt|;
name|page
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|size_t
operator|)
name|allocation
operator|+
name|G
operator|.
name|pagesize
operator|-
literal|1
operator|)
operator|&
operator|-
name|G
operator|.
name|pagesize
operator|)
expr_stmt|;
name|head_slop
operator|=
name|page
operator|-
name|allocation
expr_stmt|;
if|if
condition|(
name|multiple_pages
condition|)
name|tail_slop
operator|=
operator|(
operator|(
name|size_t
operator|)
name|allocation
operator|+
name|alloc_size
operator|)
operator|&
operator|(
name|G
operator|.
name|pagesize
operator|-
literal|1
operator|)
expr_stmt|;
else|else
name|tail_slop
operator|=
name|alloc_size
operator|-
name|entry_size
operator|-
name|head_slop
expr_stmt|;
name|enda
operator|=
name|allocation
operator|+
name|alloc_size
operator|-
name|tail_slop
expr_stmt|;
comment|/* We allocated N pages, which are likely not aligned, leaving 	 us with N-1 usable pages.  We plan to place the page_group 	 structure somewhere in the slop.  */
if|if
condition|(
name|head_slop
operator|>=
sizeof|sizeof
argument_list|(
name|page_group
argument_list|)
condition|)
name|group
operator|=
operator|(
name|page_group
operator|*
operator|)
name|page
operator|-
literal|1
expr_stmt|;
else|else
block|{
comment|/* We magically got an aligned allocation.  Too bad, we have 	     to waste a page anyway.  */
if|if
condition|(
name|tail_slop
operator|==
literal|0
condition|)
block|{
name|enda
operator|-=
name|G
operator|.
name|pagesize
expr_stmt|;
name|tail_slop
operator|+=
name|G
operator|.
name|pagesize
expr_stmt|;
block|}
if|if
condition|(
name|tail_slop
operator|<
sizeof|sizeof
argument_list|(
name|page_group
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|group
operator|=
operator|(
name|page_group
operator|*
operator|)
name|enda
expr_stmt|;
name|tail_slop
operator|-=
sizeof|sizeof
argument_list|(
name|page_group
argument_list|)
expr_stmt|;
block|}
comment|/* Remember that we allocated this memory.  */
name|group
operator|->
name|next
operator|=
name|G
operator|.
name|page_groups
expr_stmt|;
name|group
operator|->
name|allocation
operator|=
name|allocation
expr_stmt|;
name|group
operator|->
name|alloc_size
operator|=
name|alloc_size
expr_stmt|;
name|group
operator|->
name|in_use
operator|=
literal|0
expr_stmt|;
name|G
operator|.
name|page_groups
operator|=
name|group
expr_stmt|;
name|G
operator|.
name|bytes_mapped
operator|+=
name|alloc_size
expr_stmt|;
comment|/* If we allocated multiple pages, put the rest on the free list.  */
if|if
condition|(
name|multiple_pages
condition|)
block|{
name|struct
name|page_entry
modifier|*
name|e
decl_stmt|,
modifier|*
name|f
init|=
name|G
operator|.
name|free_pages
decl_stmt|;
for|for
control|(
name|a
operator|=
name|enda
operator|-
name|G
operator|.
name|pagesize
init|;
name|a
operator|!=
name|page
condition|;
name|a
operator|-=
name|G
operator|.
name|pagesize
control|)
block|{
name|e
operator|=
operator|(
expr|struct
name|page_entry
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|page_entry_size
argument_list|)
expr_stmt|;
name|e
operator|->
name|order
operator|=
name|order
expr_stmt|;
name|e
operator|->
name|bytes
operator|=
name|G
operator|.
name|pagesize
expr_stmt|;
name|e
operator|->
name|page
operator|=
name|a
expr_stmt|;
name|e
operator|->
name|group
operator|=
name|group
expr_stmt|;
name|e
operator|->
name|next
operator|=
name|f
expr_stmt|;
name|f
operator|=
name|e
expr_stmt|;
block|}
name|G
operator|.
name|free_pages
operator|=
name|f
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
name|entry
operator|=
operator|(
expr|struct
name|page_entry
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|page_entry_size
argument_list|)
expr_stmt|;
name|entry
operator|->
name|bytes
operator|=
name|entry_size
expr_stmt|;
name|entry
operator|->
name|page
operator|=
name|page
expr_stmt|;
name|entry
operator|->
name|context_depth
operator|=
name|G
operator|.
name|context_depth
expr_stmt|;
name|entry
operator|->
name|order
operator|=
name|order
expr_stmt|;
name|entry
operator|->
name|num_free_objects
operator|=
name|num_objects
expr_stmt|;
name|entry
operator|->
name|next_bit_hint
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|USING_MALLOC_PAGE_GROUPS
name|entry
operator|->
name|group
operator|=
name|group
expr_stmt|;
name|set_page_group_in_use
argument_list|(
name|group
argument_list|,
name|page
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set the one-past-the-end in-use bit.  This acts as a sentry as we      increment the hint.  */
name|entry
operator|->
name|in_use_p
index|[
name|num_objects
operator|/
name|HOST_BITS_PER_LONG
index|]
operator|=
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
operator|(
name|num_objects
operator|%
name|HOST_BITS_PER_LONG
operator|)
expr_stmt|;
name|set_page_table_entry
argument_list|(
name|page
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|GGC_DEBUG_LEVEL
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|G
operator|.
name|debug_file
argument_list|,
literal|"Allocating page at %p, object size=%ld, data %p-%p\n"
argument_list|,
operator|(
name|PTR
operator|)
name|entry
argument_list|,
operator|(
name|long
operator|)
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
argument_list|,
name|page
argument_list|,
name|page
operator|+
name|entry_size
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* For a page that is no longer needed, put it on the free page list.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|free_page
parameter_list|(
name|entry
parameter_list|)
name|page_entry
modifier|*
name|entry
decl_stmt|;
block|{
if|if
condition|(
name|GGC_DEBUG_LEVEL
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|G
operator|.
name|debug_file
argument_list|,
literal|"Deallocating page at %p, data %p-%p\n"
argument_list|,
operator|(
name|PTR
operator|)
name|entry
argument_list|,
name|entry
operator|->
name|page
argument_list|,
name|entry
operator|->
name|page
operator|+
name|entry
operator|->
name|bytes
operator|-
literal|1
argument_list|)
expr_stmt|;
name|set_page_table_entry
argument_list|(
name|entry
operator|->
name|page
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USING_MALLOC_PAGE_GROUPS
name|clear_page_group_in_use
argument_list|(
name|entry
operator|->
name|group
argument_list|,
name|entry
operator|->
name|page
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|entry
operator|->
name|next
operator|=
name|G
operator|.
name|free_pages
expr_stmt|;
name|G
operator|.
name|free_pages
operator|=
name|entry
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Release the free page cache to the system.  */
end_comment

begin_function
specifier|static
name|void
name|release_pages
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|USING_MMAP
name|page_entry
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/* Gather up adjacent pages so they are unmapped together.  */
name|p
operator|=
name|G
operator|.
name|free_pages
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|start
operator|=
name|p
operator|->
name|page
expr_stmt|;
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|len
operator|=
name|p
operator|->
name|bytes
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|next
expr_stmt|;
while|while
condition|(
name|p
operator|&&
name|p
operator|->
name|page
operator|==
name|start
operator|+
name|len
condition|)
block|{
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|len
operator|+=
name|p
operator|->
name|bytes
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|next
expr_stmt|;
block|}
name|munmap
argument_list|(
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|G
operator|.
name|bytes_mapped
operator|-=
name|len
expr_stmt|;
block|}
name|G
operator|.
name|free_pages
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USING_MALLOC_PAGE_GROUPS
name|page_entry
modifier|*
modifier|*
name|pp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|page_group
modifier|*
modifier|*
name|gp
decl_stmt|,
modifier|*
name|g
decl_stmt|;
comment|/* Remove all pages from free page groups from the list.  */
name|pp
operator|=
operator|&
name|G
operator|.
name|free_pages
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|p
operator|->
name|group
operator|->
name|in_use
operator|==
literal|0
condition|)
block|{
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
comment|/* Remove all free page groups, and release the storage.  */
name|gp
operator|=
operator|&
name|G
operator|.
name|page_groups
expr_stmt|;
while|while
condition|(
operator|(
name|g
operator|=
operator|*
name|gp
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|g
operator|->
name|in_use
operator|==
literal|0
condition|)
block|{
operator|*
name|gp
operator|=
name|g
operator|->
name|next
expr_stmt|;
name|G
operator|.
name|bytes_mapped
operator|-=
name|g
operator|->
name|alloc_size
expr_stmt|;
name|free
argument_list|(
name|g
operator|->
name|allocation
argument_list|)
expr_stmt|;
block|}
else|else
name|gp
operator|=
operator|&
name|g
operator|->
name|next
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* This table provides a fast way to determine ceil(log_2(size)) for    allocation requests.  The minimum allocation size is eight bytes.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|size_lookup
index|[
literal|257
index|]
init|=
block|{
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate a chunk of memory of SIZE bytes.  If ZERO is non-zero, the    memory is zeroed; otherwise, its contents are undefined.  */
end_comment

begin_function
name|void
modifier|*
name|ggc_alloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
name|unsigned
name|order
decl_stmt|,
name|word
decl_stmt|,
name|bit
decl_stmt|,
name|object_offset
decl_stmt|;
name|struct
name|page_entry
modifier|*
name|entry
decl_stmt|;
name|void
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|size
operator|<=
literal|256
condition|)
name|order
operator|=
name|size_lookup
index|[
name|size
index|]
expr_stmt|;
else|else
block|{
name|order
operator|=
literal|9
expr_stmt|;
while|while
condition|(
name|size
operator|>
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
condition|)
name|order
operator|++
expr_stmt|;
block|}
comment|/* If there are non-full pages for this size allocation, they are at      the head of the list.  */
name|entry
operator|=
name|G
operator|.
name|pages
index|[
name|order
index|]
expr_stmt|;
comment|/* If there is no page for this object size, or all pages in this      context are full, allocate a new page.  */
if|if
condition|(
name|entry
operator|==
name|NULL
operator|||
name|entry
operator|->
name|num_free_objects
operator|==
literal|0
condition|)
block|{
name|struct
name|page_entry
modifier|*
name|new_entry
decl_stmt|;
name|new_entry
operator|=
name|alloc_page
argument_list|(
name|order
argument_list|)
expr_stmt|;
comment|/* If this is the only entry, it's also the tail.  */
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
name|G
operator|.
name|page_tails
index|[
name|order
index|]
operator|=
name|new_entry
expr_stmt|;
comment|/* Put new pages at the head of the page list.  */
name|new_entry
operator|->
name|next
operator|=
name|entry
expr_stmt|;
name|entry
operator|=
name|new_entry
expr_stmt|;
name|G
operator|.
name|pages
index|[
name|order
index|]
operator|=
name|new_entry
expr_stmt|;
comment|/* For a new page, we know the word and bit positions (in the 	 in_use bitmap) of the first available object -- they're zero.  */
name|new_entry
operator|->
name|next_bit_hint
operator|=
literal|1
expr_stmt|;
name|word
operator|=
literal|0
expr_stmt|;
name|bit
operator|=
literal|0
expr_stmt|;
name|object_offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* First try to use the hint left from the previous allocation 	 to locate a clear bit in the in-use bitmap.  We've made sure 	 that the one-past-the-end bit is always set, so if the hint 	 has run over, this test will fail.  */
name|unsigned
name|hint
init|=
name|entry
operator|->
name|next_bit_hint
decl_stmt|;
name|word
operator|=
name|hint
operator|/
name|HOST_BITS_PER_LONG
expr_stmt|;
name|bit
operator|=
name|hint
operator|%
name|HOST_BITS_PER_LONG
expr_stmt|;
comment|/* If the hint didn't work, scan the bitmap from the beginning.  */
if|if
condition|(
operator|(
name|entry
operator|->
name|in_use_p
index|[
name|word
index|]
operator|>>
name|bit
operator|)
operator|&
literal|1
condition|)
block|{
name|word
operator|=
name|bit
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|~
name|entry
operator|->
name|in_use_p
index|[
name|word
index|]
operator|==
literal|0
condition|)
operator|++
name|word
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|->
name|in_use_p
index|[
name|word
index|]
operator|>>
name|bit
operator|)
operator|&
literal|1
condition|)
operator|++
name|bit
expr_stmt|;
name|hint
operator|=
name|word
operator|*
name|HOST_BITS_PER_LONG
operator|+
name|bit
expr_stmt|;
block|}
comment|/* Next time, try the next bit.  */
name|entry
operator|->
name|next_bit_hint
operator|=
name|hint
operator|+
literal|1
expr_stmt|;
name|object_offset
operator|=
name|hint
operator|*
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
expr_stmt|;
block|}
comment|/* Set the in-use bit.  */
name|entry
operator|->
name|in_use_p
index|[
name|word
index|]
operator||=
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
comment|/* Keep a running total of the number of free objects.  If this page      fills up, we may have to move it to the end of the list if the      next page isn't full.  If the next page is full, all subsequent      pages are full, so there's no need to move it.  */
if|if
condition|(
operator|--
name|entry
operator|->
name|num_free_objects
operator|==
literal|0
operator|&&
name|entry
operator|->
name|next
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|next
operator|->
name|num_free_objects
operator|>
literal|0
condition|)
block|{
name|G
operator|.
name|pages
index|[
name|order
index|]
operator|=
name|entry
operator|->
name|next
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|G
operator|.
name|page_tails
index|[
name|order
index|]
operator|->
name|next
operator|=
name|entry
expr_stmt|;
name|G
operator|.
name|page_tails
index|[
name|order
index|]
operator|=
name|entry
expr_stmt|;
block|}
comment|/* Calculate the object's address.  */
name|result
operator|=
name|entry
operator|->
name|page
operator|+
name|object_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|GGC_POISON
comment|/* `Poison' the entire allocated object, including any padding at      the end.  */
name|memset
argument_list|(
name|result
argument_list|,
literal|0xaf
argument_list|,
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Keep track of how many bytes are being allocated.  This      information is used in deciding when to collect.  */
name|G
operator|.
name|allocated
operator|+=
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
expr_stmt|;
if|if
condition|(
name|GGC_DEBUG_LEVEL
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|G
operator|.
name|debug_file
argument_list|,
literal|"Allocating object, requested size=%ld, actual=%ld at %p on %p\n"
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|,
operator|(
name|long
operator|)
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
argument_list|,
name|result
argument_list|,
operator|(
name|PTR
operator|)
name|entry
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* If P is not marked, marks it and return false.  Otherwise return true.    P must have been allocated by the GC allocator; it mustn't point to    static objects, stack variables, or memory allocated with malloc.  */
end_comment

begin_function
name|int
name|ggc_set_mark
parameter_list|(
name|p
parameter_list|)
specifier|const
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|page_entry
modifier|*
name|entry
decl_stmt|;
name|unsigned
name|bit
decl_stmt|,
name|word
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
comment|/* Look up the page on which the object is alloced.  If the object      wasn't allocated by the collector, we'll probably die.  */
name|entry
operator|=
name|lookup_page_table_entry
argument_list|(
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Calculate the index of the object on the page; this is its bit      position in the in_use_p bitmap.  */
name|bit
operator|=
operator|(
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
operator|)
operator|-
name|entry
operator|->
name|page
operator|)
operator|/
name|OBJECT_SIZE
argument_list|(
name|entry
operator|->
name|order
argument_list|)
expr_stmt|;
name|word
operator|=
name|bit
operator|/
name|HOST_BITS_PER_LONG
expr_stmt|;
name|mask
operator|=
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
operator|(
name|bit
operator|%
name|HOST_BITS_PER_LONG
operator|)
expr_stmt|;
comment|/* If the bit was previously set, skip it.  */
if|if
condition|(
name|entry
operator|->
name|in_use_p
index|[
name|word
index|]
operator|&
name|mask
condition|)
return|return
literal|1
return|;
comment|/* Otherwise set it, and decrement the free object count.  */
name|entry
operator|->
name|in_use_p
index|[
name|word
index|]
operator||=
name|mask
expr_stmt|;
name|entry
operator|->
name|num_free_objects
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|GGC_DEBUG_LEVEL
operator|>=
literal|4
condition|)
name|fprintf
argument_list|(
name|G
operator|.
name|debug_file
argument_list|,
literal|"Marking %p\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if P has been marked, zero otherwise.     P must have been allocated by the GC allocator; it mustn't point to    static objects, stack variables, or memory allocated with malloc.  */
end_comment

begin_function
name|int
name|ggc_marked_p
parameter_list|(
name|p
parameter_list|)
specifier|const
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|page_entry
modifier|*
name|entry
decl_stmt|;
name|unsigned
name|bit
decl_stmt|,
name|word
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
comment|/* Look up the page on which the object is alloced.  If the object      wasn't allocated by the collector, we'll probably die.  */
name|entry
operator|=
name|lookup_page_table_entry
argument_list|(
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Calculate the index of the object on the page; this is its bit      position in the in_use_p bitmap.  */
name|bit
operator|=
operator|(
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
operator|)
operator|-
name|entry
operator|->
name|page
operator|)
operator|/
name|OBJECT_SIZE
argument_list|(
name|entry
operator|->
name|order
argument_list|)
expr_stmt|;
name|word
operator|=
name|bit
operator|/
name|HOST_BITS_PER_LONG
expr_stmt|;
name|mask
operator|=
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
operator|(
name|bit
operator|%
name|HOST_BITS_PER_LONG
operator|)
expr_stmt|;
return|return
operator|(
name|entry
operator|->
name|in_use_p
index|[
name|word
index|]
operator|&
name|mask
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the size of the gc-able object P.  */
end_comment

begin_function
name|size_t
name|ggc_get_size
parameter_list|(
name|p
parameter_list|)
specifier|const
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|page_entry
modifier|*
name|pe
init|=
name|lookup_page_table_entry
argument_list|(
name|p
argument_list|)
decl_stmt|;
return|return
name|OBJECT_SIZE
argument_list|(
name|pe
operator|->
name|order
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize the ggc-mmap allocator.  */
end_comment

begin_function
name|void
name|init_ggc
parameter_list|()
block|{
name|unsigned
name|order
decl_stmt|;
name|G
operator|.
name|pagesize
operator|=
name|getpagesize
argument_list|()
expr_stmt|;
name|G
operator|.
name|lg_pagesize
operator|=
name|exact_log2
argument_list|(
name|G
operator|.
name|pagesize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_MMAP_DEV_ZERO
name|G
operator|.
name|dev_zero_fd
operator|=
name|open
argument_list|(
literal|"/dev/zero"
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|G
operator|.
name|dev_zero_fd
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|G.debug_file = fopen ("ggc-mmap.debug", "w");
else|#
directive|else
name|G
operator|.
name|debug_file
operator|=
name|stdout
expr_stmt|;
endif|#
directive|endif
name|G
operator|.
name|allocated_last_gc
operator|=
name|GGC_MIN_LAST_ALLOCATED
expr_stmt|;
ifdef|#
directive|ifdef
name|USING_MMAP
comment|/* StunOS has an amazing off-by-one error for the first mmap allocation      after fiddling with RLIMIT_STACK.  The result, as hard as it is to      believe, is an unaligned page allocation, which would cause us to      hork badly if we tried to use it.  */
block|{
name|char
modifier|*
name|p
init|=
name|alloc_anon
argument_list|(
name|NULL
argument_list|,
name|G
operator|.
name|pagesize
argument_list|)
decl_stmt|;
name|struct
name|page_entry
modifier|*
name|e
decl_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|p
operator|&
operator|(
name|G
operator|.
name|pagesize
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* How losing.  Discard this one and try another.  If we still 	   can't get something useful, give up.  */
name|p
operator|=
name|alloc_anon
argument_list|(
name|NULL
argument_list|,
name|G
operator|.
name|pagesize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|p
operator|&
operator|(
name|G
operator|.
name|pagesize
operator|-
literal|1
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* We have a good page, might as well hold onto it...  */
name|e
operator|=
operator|(
expr|struct
name|page_entry
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|page_entry
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|bytes
operator|=
name|G
operator|.
name|pagesize
expr_stmt|;
name|e
operator|->
name|page
operator|=
name|p
expr_stmt|;
name|e
operator|->
name|next
operator|=
name|G
operator|.
name|free_pages
expr_stmt|;
name|G
operator|.
name|free_pages
operator|=
name|e
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Initialize the object size table.  */
for|for
control|(
name|order
operator|=
literal|0
init|;
name|order
operator|<
name|HOST_BITS_PER_PTR
condition|;
operator|++
name|order
control|)
name|object_size_table
index|[
name|order
index|]
operator|=
operator|(
name|size_t
operator|)
literal|1
operator|<<
name|order
expr_stmt|;
for|for
control|(
name|order
operator|=
name|HOST_BITS_PER_PTR
init|;
name|order
operator|<
name|NUM_ORDERS
condition|;
operator|++
name|order
control|)
block|{
name|size_t
name|s
init|=
name|extra_order_size_table
index|[
name|order
operator|-
name|HOST_BITS_PER_PTR
index|]
decl_stmt|;
comment|/* If S is not a multiple of the MAX_ALIGNMENT, then round it up 	 so that we're sure of getting aligned memory.  */
name|s
operator|=
name|CEIL
argument_list|(
name|s
argument_list|,
name|MAX_ALIGNMENT
argument_list|)
operator|*
name|MAX_ALIGNMENT
expr_stmt|;
name|object_size_table
index|[
name|order
index|]
operator|=
name|s
expr_stmt|;
block|}
comment|/* Initialize the objects-per-page table.  */
for|for
control|(
name|order
operator|=
literal|0
init|;
name|order
operator|<
name|NUM_ORDERS
condition|;
operator|++
name|order
control|)
block|{
name|objects_per_page_table
index|[
name|order
index|]
operator|=
name|G
operator|.
name|pagesize
operator|/
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
expr_stmt|;
if|if
condition|(
name|objects_per_page_table
index|[
name|order
index|]
operator|==
literal|0
condition|)
name|objects_per_page_table
index|[
name|order
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Reset the size_lookup array to put appropriately sized objects in      the special orders.  All objects bigger than the previous power      of two, but no greater than the special size, should go in the      new order.  */
for|for
control|(
name|order
operator|=
name|HOST_BITS_PER_PTR
init|;
name|order
operator|<
name|NUM_ORDERS
condition|;
operator|++
name|order
control|)
block|{
name|int
name|o
decl_stmt|;
name|int
name|i
decl_stmt|;
name|o
operator|=
name|size_lookup
index|[
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
init|;
name|size_lookup
index|[
name|i
index|]
operator|==
name|o
condition|;
operator|--
name|i
control|)
name|size_lookup
index|[
name|i
index|]
operator|=
name|order
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Increment the `GC context'.  Objects allocated in an outer context    are never freed, eliminating the need to register their roots.  */
end_comment

begin_function
name|void
name|ggc_push_context
parameter_list|()
block|{
operator|++
name|G
operator|.
name|context_depth
expr_stmt|;
comment|/* Die on wrap.  */
if|if
condition|(
name|G
operator|.
name|context_depth
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Merge the SAVE_IN_USE_P and IN_USE_P arrays in P so that IN_USE_P    reflects reality.  Recalculate NUM_FREE_OBJECTS as well.  */
end_comment

begin_function
specifier|static
name|void
name|ggc_recalculate_in_use_p
parameter_list|(
name|p
parameter_list|)
name|page_entry
modifier|*
name|p
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|size_t
name|num_objects
decl_stmt|;
comment|/* Because the past-the-end bit in in_use_p is always set, we       pretend there is one additional object.  */
name|num_objects
operator|=
name|OBJECTS_PER_PAGE
argument_list|(
name|p
operator|->
name|order
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Reset the free object count.  */
name|p
operator|->
name|num_free_objects
operator|=
name|num_objects
expr_stmt|;
comment|/* Combine the IN_USE_P and SAVE_IN_USE_P arrays.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CEIL
argument_list|(
name|BITMAP_SIZE
argument_list|(
name|num_objects
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
operator|->
name|in_use_p
argument_list|)
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|long
name|j
decl_stmt|;
comment|/* Something is in use if it is marked, or if it was in use in a 	 context further down the context stack.  */
name|p
operator|->
name|in_use_p
index|[
name|i
index|]
operator||=
name|p
operator|->
name|save_in_use_p
index|[
name|i
index|]
expr_stmt|;
comment|/* Decrement the free object count for every object allocated.  */
for|for
control|(
name|j
operator|=
name|p
operator|->
name|in_use_p
index|[
name|i
index|]
init|;
name|j
condition|;
name|j
operator|>>=
literal|1
control|)
name|p
operator|->
name|num_free_objects
operator|-=
operator|(
name|j
operator|&
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|num_free_objects
operator|>=
name|num_objects
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decrement the `GC context'.  All objects allocated since the     previous ggc_push_context are migrated to the outer context.  */
end_comment

begin_function
name|void
name|ggc_pop_context
parameter_list|()
block|{
name|unsigned
name|order
decl_stmt|,
name|depth
decl_stmt|;
name|depth
operator|=
operator|--
name|G
operator|.
name|context_depth
expr_stmt|;
comment|/* Any remaining pages in the popped context are lowered to the new      current context; i.e. objects allocated in the popped context and      left over are imported into the previous context.  */
for|for
control|(
name|order
operator|=
literal|2
init|;
name|order
operator|<
name|NUM_ORDERS
condition|;
name|order
operator|++
control|)
block|{
name|page_entry
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|G
operator|.
name|pages
index|[
name|order
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|context_depth
operator|>
name|depth
condition|)
name|p
operator|->
name|context_depth
operator|=
name|depth
expr_stmt|;
comment|/* If this page is now in the topmost context, and we'd 	     saved its allocation state, restore it.  */
elseif|else
if|if
condition|(
name|p
operator|->
name|context_depth
operator|==
name|depth
operator|&&
name|p
operator|->
name|save_in_use_p
condition|)
block|{
name|ggc_recalculate_in_use_p
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|save_in_use_p
argument_list|)
expr_stmt|;
name|p
operator|->
name|save_in_use_p
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Unmark all objects.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|clear_marks
parameter_list|()
block|{
name|unsigned
name|order
decl_stmt|;
for|for
control|(
name|order
operator|=
literal|2
init|;
name|order
operator|<
name|NUM_ORDERS
condition|;
name|order
operator|++
control|)
block|{
name|size_t
name|num_objects
init|=
name|OBJECTS_PER_PAGE
argument_list|(
name|order
argument_list|)
decl_stmt|;
name|size_t
name|bitmap_size
init|=
name|BITMAP_SIZE
argument_list|(
name|num_objects
operator|+
literal|1
argument_list|)
decl_stmt|;
name|page_entry
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|G
operator|.
name|pages
index|[
name|order
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* The data should be page-aligned.  */
if|if
condition|(
operator|(
name|size_t
operator|)
name|p
operator|->
name|page
operator|&
operator|(
name|G
operator|.
name|pagesize
operator|-
literal|1
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Pages that aren't in the topmost context are not collected; 	     nevertheless, we need their in-use bit vectors to store GC 	     marks.  So, back them up first.  */
if|if
condition|(
name|p
operator|->
name|context_depth
operator|<
name|G
operator|.
name|context_depth
condition|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|save_in_use_p
condition|)
name|p
operator|->
name|save_in_use_p
operator|=
name|xmalloc
argument_list|(
name|bitmap_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|save_in_use_p
argument_list|,
name|p
operator|->
name|in_use_p
argument_list|,
name|bitmap_size
argument_list|)
expr_stmt|;
block|}
comment|/* Reset reset the number of free objects and clear the              in-use bits.  These will be adjusted by mark_obj.  */
name|p
operator|->
name|num_free_objects
operator|=
name|num_objects
expr_stmt|;
name|memset
argument_list|(
name|p
operator|->
name|in_use_p
argument_list|,
literal|0
argument_list|,
name|bitmap_size
argument_list|)
expr_stmt|;
comment|/* Make sure the one-past-the-end bit is always set.  */
name|p
operator|->
name|in_use_p
index|[
name|num_objects
operator|/
name|HOST_BITS_PER_LONG
index|]
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
operator|(
name|num_objects
operator|%
name|HOST_BITS_PER_LONG
operator|)
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Free all empty pages.  Partially empty pages need no attention    because the `mark' bit doubles as an `unused' bit.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|sweep_pages
parameter_list|()
block|{
name|unsigned
name|order
decl_stmt|;
for|for
control|(
name|order
operator|=
literal|2
init|;
name|order
operator|<
name|NUM_ORDERS
condition|;
name|order
operator|++
control|)
block|{
comment|/* The last page-entry to consider, regardless of entries 	 placed at the end of the list.  */
name|page_entry
modifier|*
specifier|const
name|last
init|=
name|G
operator|.
name|page_tails
index|[
name|order
index|]
decl_stmt|;
name|size_t
name|num_objects
init|=
name|OBJECTS_PER_PAGE
argument_list|(
name|order
argument_list|)
decl_stmt|;
name|size_t
name|live_objects
decl_stmt|;
name|page_entry
modifier|*
name|p
decl_stmt|,
modifier|*
name|previous
decl_stmt|;
name|int
name|done
decl_stmt|;
name|p
operator|=
name|G
operator|.
name|pages
index|[
name|order
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
continue|continue;
name|previous
operator|=
name|NULL
expr_stmt|;
do|do
block|{
name|page_entry
modifier|*
name|next
init|=
name|p
operator|->
name|next
decl_stmt|;
comment|/* Loop until all entries have been examined.  */
name|done
operator|=
operator|(
name|p
operator|==
name|last
operator|)
expr_stmt|;
comment|/* Add all live objects on this page to the count of              allocated memory.  */
name|live_objects
operator|=
name|num_objects
operator|-
name|p
operator|->
name|num_free_objects
expr_stmt|;
name|G
operator|.
name|allocated
operator|+=
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
operator|*
name|live_objects
expr_stmt|;
comment|/* Only objects on pages in the topmost context should get 	     collected.  */
if|if
condition|(
name|p
operator|->
name|context_depth
operator|<
name|G
operator|.
name|context_depth
condition|)
empty_stmt|;
comment|/* Remove the page if it's empty.  */
elseif|else
if|if
condition|(
name|live_objects
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|previous
condition|)
name|G
operator|.
name|pages
index|[
name|order
index|]
operator|=
name|next
expr_stmt|;
else|else
name|previous
operator|->
name|next
operator|=
name|next
expr_stmt|;
comment|/* Are we removing the last element?  */
if|if
condition|(
name|p
operator|==
name|G
operator|.
name|page_tails
index|[
name|order
index|]
condition|)
name|G
operator|.
name|page_tails
index|[
name|order
index|]
operator|=
name|previous
expr_stmt|;
name|free_page
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|previous
expr_stmt|;
block|}
comment|/* If the page is full, move it to the end.  */
elseif|else
if|if
condition|(
name|p
operator|->
name|num_free_objects
operator|==
literal|0
condition|)
block|{
comment|/* Don't move it if it's already at the end.  */
if|if
condition|(
name|p
operator|!=
name|G
operator|.
name|page_tails
index|[
name|order
index|]
condition|)
block|{
comment|/* Move p to the end of the list.  */
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|G
operator|.
name|page_tails
index|[
name|order
index|]
operator|->
name|next
operator|=
name|p
expr_stmt|;
comment|/* Update the tail pointer...  */
name|G
operator|.
name|page_tails
index|[
name|order
index|]
operator|=
name|p
expr_stmt|;
comment|/* ... and the head pointer, if necessary.  */
if|if
condition|(
operator|!
name|previous
condition|)
name|G
operator|.
name|pages
index|[
name|order
index|]
operator|=
name|next
expr_stmt|;
else|else
name|previous
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|p
operator|=
name|previous
expr_stmt|;
block|}
block|}
comment|/* If we've fallen through to here, it's a page in the 	     topmost context that is neither full nor empty.  Such a 	     page must precede pages at lesser context depth in the 	     list, so move it to the head.  */
elseif|else
if|if
condition|(
name|p
operator|!=
name|G
operator|.
name|pages
index|[
name|order
index|]
condition|)
block|{
name|previous
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|G
operator|.
name|pages
index|[
name|order
index|]
expr_stmt|;
name|G
operator|.
name|pages
index|[
name|order
index|]
operator|=
name|p
expr_stmt|;
comment|/* Are we moving the last element?  */
if|if
condition|(
name|G
operator|.
name|page_tails
index|[
name|order
index|]
operator|==
name|p
condition|)
name|G
operator|.
name|page_tails
index|[
name|order
index|]
operator|=
name|previous
expr_stmt|;
name|p
operator|=
name|previous
expr_stmt|;
block|}
name|previous
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|next
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
comment|/* Now, restore the in_use_p vectors for any pages from contexts          other than the current one.  */
for|for
control|(
name|p
operator|=
name|G
operator|.
name|pages
index|[
name|order
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|context_depth
operator|!=
name|G
operator|.
name|context_depth
condition|)
name|ggc_recalculate_in_use_p
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GGC_POISON
end_ifdef

begin_comment
comment|/* Clobber all free objects.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|poison_pages
parameter_list|()
block|{
name|unsigned
name|order
decl_stmt|;
for|for
control|(
name|order
operator|=
literal|2
init|;
name|order
operator|<
name|NUM_ORDERS
condition|;
name|order
operator|++
control|)
block|{
name|size_t
name|num_objects
init|=
name|OBJECTS_PER_PAGE
argument_list|(
name|order
argument_list|)
decl_stmt|;
name|size_t
name|size
init|=
name|OBJECT_SIZE
argument_list|(
name|order
argument_list|)
decl_stmt|;
name|page_entry
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|G
operator|.
name|pages
index|[
name|order
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|context_depth
operator|!=
name|G
operator|.
name|context_depth
condition|)
comment|/* Since we don't do any collection for pages in pushed 	       contexts, there's no need to do any poisoning.  And 	       besides, the IN_USE_P array isn't valid until we pop 	       contexts.  */
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_objects
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|word
decl_stmt|,
name|bit
decl_stmt|;
name|word
operator|=
name|i
operator|/
name|HOST_BITS_PER_LONG
expr_stmt|;
name|bit
operator|=
name|i
operator|%
name|HOST_BITS_PER_LONG
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|p
operator|->
name|in_use_p
index|[
name|word
index|]
operator|>>
name|bit
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|memset
argument_list|(
name|p
operator|->
name|page
operator|+
name|i
operator|*
name|size
argument_list|,
literal|0xa5
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Top level mark-and-sweep routine.  */
end_comment

begin_function
name|void
name|ggc_collect
parameter_list|()
block|{
comment|/* Avoid frequent unnecessary work by skipping collection if the      total allocations haven't expanded much since the last      collection.  */
ifndef|#
directive|ifndef
name|GGC_ALWAYS_COLLECT
if|if
condition|(
name|G
operator|.
name|allocated
operator|<
name|GGC_MIN_EXPAND_FOR_GC
operator|*
name|G
operator|.
name|allocated_last_gc
condition|)
return|return;
endif|#
directive|endif
name|timevar_push
argument_list|(
name|TV_GC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" {GC %luk -> "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|G
operator|.
name|allocated
operator|/
literal|1024
argument_list|)
expr_stmt|;
comment|/* Zero the total allocated bytes.  This will be recalculated in the      sweep phase.  */
name|G
operator|.
name|allocated
operator|=
literal|0
expr_stmt|;
comment|/* Release the pages we freed the last time we collected, but didn't       reuse in the interim.  */
name|release_pages
argument_list|()
expr_stmt|;
name|clear_marks
argument_list|()
expr_stmt|;
name|ggc_mark_roots
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|GGC_POISON
name|poison_pages
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|sweep_pages
argument_list|()
expr_stmt|;
name|G
operator|.
name|allocated_last_gc
operator|=
name|G
operator|.
name|allocated
expr_stmt|;
if|if
condition|(
name|G
operator|.
name|allocated_last_gc
operator|<
name|GGC_MIN_LAST_ALLOCATED
condition|)
name|G
operator|.
name|allocated_last_gc
operator|=
name|GGC_MIN_LAST_ALLOCATED
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_GC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%luk}"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|G
operator|.
name|allocated
operator|/
literal|1024
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print allocation statistics.  */
end_comment

begin_define
define|#
directive|define
name|SCALE
parameter_list|(
name|x
parameter_list|)
value|((unsigned long) ((x)< 1024*10 \ 		  ? (x) \ 		  : ((x)< 1024*1024*10 \ 		     ? (x) / 1024 \ 		     : (x) / (1024*1024))))
end_define

begin_define
define|#
directive|define
name|LABEL
parameter_list|(
name|x
parameter_list|)
value|((x)< 1024*10 ? ' ' : ((x)< 1024*1024*10 ? 'k' : 'M'))
end_define

begin_function
name|void
name|ggc_print_statistics
parameter_list|()
block|{
name|struct
name|ggc_statistics
name|stats
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|size_t
name|total_overhead
init|=
literal|0
decl_stmt|;
comment|/* Clear the statistics.  */
name|memset
argument_list|(
operator|&
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stats
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure collection will really occur.  */
name|G
operator|.
name|allocated_last_gc
operator|=
literal|0
expr_stmt|;
comment|/* Collect and print the statistics common across collectors.  */
name|ggc_print_common_statistics
argument_list|(
name|stderr
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
comment|/* Release free pages so that we will not count the bytes allocated      there as part of the total allocated memory.  */
name|release_pages
argument_list|()
expr_stmt|;
comment|/* Collect some information about the various sizes of       allocation.  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%-5s %10s  %10s  %10s\n"
argument_list|,
literal|"Size"
argument_list|,
literal|"Allocated"
argument_list|,
literal|"Used"
argument_list|,
literal|"Overhead"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ORDERS
condition|;
operator|++
name|i
control|)
block|{
name|page_entry
modifier|*
name|p
decl_stmt|;
name|size_t
name|allocated
decl_stmt|;
name|size_t
name|in_use
decl_stmt|;
name|size_t
name|overhead
decl_stmt|;
comment|/* Skip empty entries.  */
if|if
condition|(
operator|!
name|G
operator|.
name|pages
index|[
name|i
index|]
condition|)
continue|continue;
name|overhead
operator|=
name|allocated
operator|=
name|in_use
operator|=
literal|0
expr_stmt|;
comment|/* Figure out the total number of bytes allocated for objects of 	 this size, and how many of them are actually in use.  Also figure 	 out how much memory the page table is using.  */
for|for
control|(
name|p
operator|=
name|G
operator|.
name|pages
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|allocated
operator|+=
name|p
operator|->
name|bytes
expr_stmt|;
name|in_use
operator|+=
operator|(
name|OBJECTS_PER_PAGE
argument_list|(
name|i
argument_list|)
operator|-
name|p
operator|->
name|num_free_objects
operator|)
operator|*
name|OBJECT_SIZE
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|overhead
operator|+=
operator|(
sizeof|sizeof
argument_list|(
name|page_entry
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|+
name|BITMAP_SIZE
argument_list|(
name|OBJECTS_PER_PAGE
argument_list|(
name|i
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-5d %10ld%c %10ld%c %10ld%c\n"
argument_list|,
name|OBJECT_SIZE
argument_list|(
name|i
argument_list|)
argument_list|,
name|SCALE
argument_list|(
name|allocated
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|allocated
argument_list|)
argument_list|,
name|SCALE
argument_list|(
name|in_use
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|in_use
argument_list|)
argument_list|,
name|SCALE
argument_list|(
name|overhead
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|overhead
argument_list|)
argument_list|)
expr_stmt|;
name|total_overhead
operator|+=
name|overhead
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-5s %10ld%c %10ld%c %10ld%c\n"
argument_list|,
literal|"Total"
argument_list|,
name|SCALE
argument_list|(
name|G
operator|.
name|bytes_mapped
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|G
operator|.
name|bytes_mapped
argument_list|)
argument_list|,
name|SCALE
argument_list|(
name|G
operator|.
name|allocated
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|G
operator|.
name|allocated
argument_list|)
argument_list|,
name|SCALE
argument_list|(
name|total_overhead
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|total_overhead
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

