begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Mainly the interface between cpplib and the C front ends.    Copyright (C) 1987, 1988, 1989, 1992, 1994, 1995, 1996, 1997    1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"splay-tree.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_comment
comment|/* The current line map.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|line_map
modifier|*
name|map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We may keep statistics about how long which files took to compile.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|header_time
decl_stmt|,
name|body_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|splay_tree
name|file_info_tree
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|WCHAR_TYPE_SIZE
end_undef

begin_define
define|#
directive|define
name|WCHAR_TYPE_SIZE
value|TYPE_PRECISION (wchar_type_node)
end_define

begin_comment
comment|/* Number of bytes in a wide character.  */
end_comment

begin_define
define|#
directive|define
name|WCHAR_BYTES
value|(WCHAR_TYPE_SIZE / BITS_PER_UNIT)
end_define

begin_decl_stmt
name|int
name|pending_lang_change
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If we need to switch languages - C++ only */
end_comment

begin_decl_stmt
name|int
name|c_header_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* depth in C headers - C++ only */
end_comment

begin_function_decl
specifier|static
name|tree
name|interpret_integer
parameter_list|(
specifier|const
name|cpp_token
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|interpret_float
parameter_list|(
specifier|const
name|cpp_token
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|integer_type_kind
name|narrowest_unsigned_type
parameter_list|(
name|tree
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|integer_type_kind
name|narrowest_signed_type
parameter_list|(
name|tree
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|cpp_ttype
name|lex_string
parameter_list|(
specifier|const
name|cpp_token
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lex_charconst
parameter_list|(
specifier|const
name|cpp_token
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_header_times
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dump_one_header
parameter_list|(
name|splay_tree_node
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cb_line_change
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
specifier|const
name|cpp_token
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cb_ident
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
specifier|const
name|cpp_string
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cb_def_pragma
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cb_define
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|cpp_hashnode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cb_undef
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|cpp_hashnode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_function
name|void
name|init_c_lex
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cpp_callbacks
modifier|*
name|cb
decl_stmt|;
name|struct
name|c_fileinfo
modifier|*
name|toplevel
decl_stmt|;
comment|/* Set up filename timing.  Must happen before cpp_read_main_file.  */
name|file_info_tree
operator|=
name|splay_tree_new
argument_list|(
operator|(
name|splay_tree_compare_fn
operator|)
name|strcmp
argument_list|,
literal|0
argument_list|,
operator|(
name|splay_tree_delete_value_fn
operator|)
name|free
argument_list|)
expr_stmt|;
name|toplevel
operator|=
name|get_fileinfo
argument_list|(
literal|"<top level>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_detailed_statistics
condition|)
block|{
name|header_time
operator|=
literal|0
expr_stmt|;
name|body_time
operator|=
name|get_run_time
argument_list|()
expr_stmt|;
name|toplevel
operator|->
name|time
operator|=
name|body_time
expr_stmt|;
block|}
name|cb
operator|=
name|cpp_get_callbacks
argument_list|(
name|parse_in
argument_list|)
expr_stmt|;
name|cb
operator|->
name|line_change
operator|=
name|cb_line_change
expr_stmt|;
name|cb
operator|->
name|ident
operator|=
name|cb_ident
expr_stmt|;
name|cb
operator|->
name|def_pragma
operator|=
name|cb_def_pragma
expr_stmt|;
name|cb
operator|->
name|valid_pch
operator|=
name|c_common_valid_pch
expr_stmt|;
name|cb
operator|->
name|read_pch
operator|=
name|c_common_read_pch
expr_stmt|;
comment|/* Set the debug callbacks if we can use them.  */
if|if
condition|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
operator|&&
operator|(
name|write_symbols
operator|==
name|DWARF_DEBUG
operator|||
name|write_symbols
operator|==
name|DWARF2_DEBUG
operator|||
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
operator|)
condition|)
block|{
name|cb
operator|->
name|define
operator|=
name|cb_define
expr_stmt|;
name|cb
operator|->
name|undef
operator|=
name|cb_undef
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|c_fileinfo
modifier|*
name|get_fileinfo
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|splay_tree_node
name|n
decl_stmt|;
name|struct
name|c_fileinfo
modifier|*
name|fi
decl_stmt|;
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|file_info_tree
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
return|return
operator|(
expr|struct
name|c_fileinfo
operator|*
operator|)
name|n
operator|->
name|value
return|;
name|fi
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|c_fileinfo
argument_list|)
argument_list|)
expr_stmt|;
name|fi
operator|->
name|time
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|interface_only
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|interface_unknown
operator|=
literal|1
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|file_info_tree
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|name
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|fi
argument_list|)
expr_stmt|;
return|return
name|fi
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_header_times
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* Changing files again.  This means currently collected time      is charged against header time, and body time starts back at 0.  */
if|if
condition|(
name|flag_detailed_statistics
condition|)
block|{
name|int
name|this_time
init|=
name|get_run_time
argument_list|()
decl_stmt|;
name|struct
name|c_fileinfo
modifier|*
name|file
init|=
name|get_fileinfo
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|header_time
operator|+=
name|this_time
operator|-
name|body_time
expr_stmt|;
name|file
operator|->
name|time
operator|+=
name|this_time
operator|-
name|body_time
expr_stmt|;
name|body_time
operator|=
name|this_time
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|dump_one_header
parameter_list|(
name|splay_tree_node
name|n
parameter_list|,
name|void
modifier|*
name|dummy
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|print_time
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|n
operator|->
name|key
argument_list|,
operator|(
operator|(
expr|struct
name|c_fileinfo
operator|*
operator|)
name|n
operator|->
name|value
operator|)
operator|->
name|time
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|dump_time_statistics
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|c_fileinfo
modifier|*
name|file
init|=
name|get_fileinfo
argument_list|(
name|input_filename
argument_list|)
decl_stmt|;
name|int
name|this_time
init|=
name|get_run_time
argument_list|()
decl_stmt|;
name|file
operator|->
name|time
operator|+=
name|this_time
operator|-
name|body_time
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n******\n"
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"header files (total)"
argument_list|,
name|header_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"main file (total)"
argument_list|,
name|this_time
operator|-
name|body_time
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ratio = %g : 1\n"
argument_list|,
operator|(
name|double
operator|)
name|header_time
operator|/
call|(
name|double
call|)
argument_list|(
name|this_time
operator|-
name|body_time
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n******\n"
argument_list|)
expr_stmt|;
name|splay_tree_foreach
argument_list|(
name|file_info_tree
argument_list|,
name|dump_one_header
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cb_ident
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|cpp_string
modifier|*
name|str
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_IDENT
if|if
condition|(
operator|!
name|flag_no_ident
condition|)
block|{
comment|/* Convert escapes in the string.  */
name|cpp_string
name|cstr
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|cpp_interpret_string
argument_list|(
name|pfile
argument_list|,
name|str
argument_list|,
literal|1
argument_list|,
operator|&
name|cstr
argument_list|,
name|false
argument_list|)
condition|)
block|{
name|ASM_OUTPUT_IDENT
argument_list|(
name|asm_out_file
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|cstr
operator|.
name|text
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|cstr
operator|.
name|text
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Called at the start of every non-empty line.  TOKEN is the first    lexed token on the line.  Used for diagnostic line numbers.  */
end_comment

begin_function
specifier|static
name|void
name|cb_line_change
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|cpp_token
modifier|*
name|token
parameter_list|,
name|int
name|parsing_args
parameter_list|)
block|{
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
operator|||
name|parsing_args
condition|)
return|return;
name|input_line
operator|=
name|SOURCE_LINE
argument_list|(
name|map
argument_list|,
name|token
operator|->
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fe_file_change
parameter_list|(
specifier|const
name|struct
name|line_map
modifier|*
name|new_map
parameter_list|)
block|{
if|if
condition|(
name|new_map
operator|==
name|NULL
condition|)
block|{
name|map
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|new_map
operator|->
name|reason
operator|==
name|LC_ENTER
condition|)
block|{
comment|/* Don't stack the main buffer on the input stack; 	 we already did in compile_file.  */
if|if
condition|(
name|map
operator|!=
name|NULL
condition|)
block|{
name|int
name|included_at
init|=
name|SOURCE_LINE
argument_list|(
name|new_map
operator|-
literal|1
argument_list|,
name|new_map
operator|->
name|from_line
operator|-
literal|1
argument_list|)
decl_stmt|;
name|input_line
operator|=
name|included_at
expr_stmt|;
name|push_srcloc
argument_list|(
name|new_map
operator|->
name|to_file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
call|(
modifier|*
name|debug_hooks
operator|->
name|start_source_file
call|)
argument_list|(
name|included_at
argument_list|,
name|new_map
operator|->
name|to_file
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_IMPLICIT_EXTERN_C
if|if
condition|(
name|c_header_level
condition|)
operator|++
name|c_header_level
expr_stmt|;
elseif|else
if|if
condition|(
name|new_map
operator|->
name|sysp
operator|==
literal|2
condition|)
block|{
name|c_header_level
operator|=
literal|1
expr_stmt|;
operator|++
name|pending_lang_change
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
name|new_map
operator|->
name|reason
operator|==
name|LC_LEAVE
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_IMPLICIT_EXTERN_C
if|if
condition|(
name|c_header_level
operator|&&
operator|--
name|c_header_level
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|new_map
operator|->
name|sysp
operator|==
literal|2
condition|)
name|warning
argument_list|(
literal|"badly nested C headers from preprocessor"
argument_list|)
expr_stmt|;
operator|--
name|pending_lang_change
expr_stmt|;
block|}
endif|#
directive|endif
name|pop_srcloc
argument_list|()
expr_stmt|;
call|(
modifier|*
name|debug_hooks
operator|->
name|end_source_file
call|)
argument_list|(
name|new_map
operator|->
name|to_line
argument_list|)
expr_stmt|;
block|}
name|update_header_times
argument_list|(
name|new_map
operator|->
name|to_file
argument_list|)
expr_stmt|;
name|in_system_header
operator|=
name|new_map
operator|->
name|sysp
operator|!=
literal|0
expr_stmt|;
name|input_filename
operator|=
name|new_map
operator|->
name|to_file
expr_stmt|;
name|input_line
operator|=
name|new_map
operator|->
name|to_line
expr_stmt|;
name|map
operator|=
name|new_map
expr_stmt|;
comment|/* Hook for C++.  */
name|extract_interface_info
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cb_def_pragma
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|)
block|{
comment|/* Issue a warning message if we have been asked to do so.  Ignore      unknown pragmas in system headers unless an explicit      -Wunknown-pragmas has been given.  */
if|if
condition|(
name|warn_unknown_pragmas
operator|>
name|in_system_header
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|space
decl_stmt|,
modifier|*
name|name
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|s
decl_stmt|;
name|space
operator|=
name|name
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
literal|""
expr_stmt|;
name|s
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|!=
name|CPP_EOF
condition|)
block|{
name|space
operator|=
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|CPP_NAME
condition|)
name|name
operator|=
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|input_line
operator|=
name|SOURCE_LINE
argument_list|(
name|map
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"ignoring #pragma %s %s"
argument_list|,
name|space
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* #define callback for DWARF and DWARF2 debug info.  */
end_comment

begin_function
specifier|static
name|void
name|cb_define
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|,
name|cpp_hashnode
modifier|*
name|node
parameter_list|)
block|{
call|(
modifier|*
name|debug_hooks
operator|->
name|define
call|)
argument_list|(
name|SOURCE_LINE
argument_list|(
name|map
argument_list|,
name|line
argument_list|)
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|cpp_macro_definition
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* #undef callback for DWARF and DWARF2 debug info.  */
end_comment

begin_function
specifier|static
name|void
name|cb_undef
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|,
name|cpp_hashnode
modifier|*
name|node
parameter_list|)
block|{
call|(
modifier|*
name|debug_hooks
operator|->
name|undef
call|)
argument_list|(
name|SOURCE_LINE
argument_list|(
name|map
argument_list|,
name|line
argument_list|)
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
specifier|inline
specifier|const
name|cpp_token
modifier|*
name|get_nonpadding_token
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|cpp_token
modifier|*
name|tok
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_CPP
argument_list|)
expr_stmt|;
do|do
name|tok
operator|=
name|cpp_get_token
argument_list|(
name|parse_in
argument_list|)
expr_stmt|;
do|while
condition|(
name|tok
operator|->
name|type
operator|==
name|CPP_PADDING
condition|)
do|;
name|timevar_pop
argument_list|(
name|TV_CPP
argument_list|)
expr_stmt|;
return|return
name|tok
return|;
block|}
end_function

begin_function
name|int
name|c_lex_with_flags
parameter_list|(
name|tree
modifier|*
name|value
parameter_list|,
name|unsigned
name|char
modifier|*
name|cpp_flags
parameter_list|)
block|{
specifier|const
name|cpp_token
modifier|*
name|tok
decl_stmt|;
name|location_t
name|atloc
decl_stmt|;
specifier|static
name|bool
name|no_more_pch
decl_stmt|;
name|retry
label|:
name|tok
operator|=
name|get_nonpadding_token
argument_list|()
expr_stmt|;
name|retry_after_at
label|:
switch|switch
condition|(
name|tok
operator|->
name|type
condition|)
block|{
case|case
name|CPP_NAME
case|:
operator|*
name|value
operator|=
name|HT_IDENT_TO_GCC_IDENT
argument_list|(
name|HT_NODE
argument_list|(
name|tok
operator|->
name|val
operator|.
name|node
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_NUMBER
case|:
block|{
name|unsigned
name|int
name|flags
init|=
name|cpp_classify_number
argument_list|(
name|parse_in
argument_list|,
name|tok
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|flags
operator|&
name|CPP_N_CATEGORY
condition|)
block|{
case|case
name|CPP_N_INVALID
case|:
comment|/* cpplib has issued an error.  */
operator|*
name|value
operator|=
name|error_mark_node
expr_stmt|;
break|break;
case|case
name|CPP_N_INTEGER
case|:
operator|*
name|value
operator|=
name|interpret_integer
argument_list|(
name|tok
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_N_FLOATING
case|:
operator|*
name|value
operator|=
name|interpret_float
argument_list|(
name|tok
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CPP_ATSIGN
case|:
comment|/* An @ may give the next token special significance in Objective-C.  */
name|atloc
operator|=
name|input_location
expr_stmt|;
name|tok
operator|=
name|get_nonpadding_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|c_dialect_objc
argument_list|()
condition|)
block|{
name|tree
name|val
decl_stmt|;
switch|switch
condition|(
name|tok
operator|->
name|type
condition|)
block|{
case|case
name|CPP_NAME
case|:
name|val
operator|=
name|HT_IDENT_TO_GCC_IDENT
argument_list|(
name|HT_NODE
argument_list|(
name|tok
operator|->
name|val
operator|.
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|C_IS_RESERVED_WORD
argument_list|(
name|val
argument_list|)
operator|&&
name|OBJC_IS_AT_KEYWORD
argument_list|(
name|C_RID_CODE
argument_list|(
name|val
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|value
operator|=
name|val
expr_stmt|;
return|return
name|CPP_AT_NAME
return|;
block|}
break|break;
case|case
name|CPP_STRING
case|:
case|case
name|CPP_WSTRING
case|:
return|return
name|lex_string
argument_list|(
name|tok
argument_list|,
name|value
argument_list|,
name|true
argument_list|)
return|;
default|default:
break|break;
block|}
block|}
comment|/* ... or not.  */
name|error
argument_list|(
literal|"%Hstray '@' in program"
argument_list|,
operator|&
name|atloc
argument_list|)
expr_stmt|;
goto|goto
name|retry_after_at
goto|;
case|case
name|CPP_OTHER
case|:
block|{
name|cppchar_t
name|c
init|=
name|tok
operator|->
name|val
operator|.
name|str
operator|.
name|text
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
operator|||
name|c
operator|==
literal|'\''
condition|)
name|error
argument_list|(
literal|"missing terminating %c character"
argument_list|,
operator|(
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISGRAPH
argument_list|(
name|c
argument_list|)
condition|)
name|error
argument_list|(
literal|"stray '%c' in program"
argument_list|,
operator|(
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"stray '\\%o' in program"
argument_list|,
operator|(
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
goto|goto
name|retry
goto|;
case|case
name|CPP_CHAR
case|:
case|case
name|CPP_WCHAR
case|:
operator|*
name|value
operator|=
name|lex_charconst
argument_list|(
name|tok
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_STRING
case|:
case|case
name|CPP_WSTRING
case|:
return|return
name|lex_string
argument_list|(
name|tok
argument_list|,
name|value
argument_list|,
name|false
argument_list|)
return|;
break|break;
comment|/* These tokens should not be visible outside cpplib.  */
case|case
name|CPP_HEADER_NAME
case|:
case|case
name|CPP_COMMENT
case|:
case|case
name|CPP_MACRO_ARG
case|:
name|abort
argument_list|()
expr_stmt|;
default|default:
operator|*
name|value
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|no_more_pch
condition|)
block|{
name|no_more_pch
operator|=
name|true
expr_stmt|;
name|c_common_no_more_pch
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cpp_flags
condition|)
operator|*
name|cpp_flags
operator|=
name|tok
operator|->
name|flags
expr_stmt|;
return|return
name|tok
operator|->
name|type
return|;
block|}
end_function

begin_function
name|int
name|c_lex
parameter_list|(
name|tree
modifier|*
name|value
parameter_list|)
block|{
return|return
name|c_lex_with_flags
argument_list|(
name|value
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the narrowest C-visible unsigned type, starting with the    minimum specified by FLAGS, that can fit VALUE, or itk_none if    there isn't one.  */
end_comment

begin_function
specifier|static
name|enum
name|integer_type_kind
name|narrowest_unsigned_type
parameter_list|(
name|tree
name|value
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|enum
name|integer_type_kind
name|itk
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|CPP_N_WIDTH
operator|)
operator|==
name|CPP_N_SMALL
condition|)
name|itk
operator|=
name|itk_unsigned_int
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|CPP_N_WIDTH
operator|)
operator|==
name|CPP_N_MEDIUM
condition|)
name|itk
operator|=
name|itk_unsigned_long
expr_stmt|;
else|else
name|itk
operator|=
name|itk_unsigned_long_long
expr_stmt|;
comment|/* int_fits_type_p must think the type of its first argument is      wider than its second argument, or it won't do the proper check.  */
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|widest_unsigned_literal_type_node
expr_stmt|;
for|for
control|(
init|;
name|itk
operator|<
name|itk_none
condition|;
name|itk
operator|+=
literal|2
comment|/* skip unsigned types */
control|)
if|if
condition|(
name|int_fits_type_p
argument_list|(
name|value
argument_list|,
name|integer_types
index|[
name|itk
index|]
argument_list|)
condition|)
return|return
name|itk
return|;
return|return
name|itk_none
return|;
block|}
end_function

begin_comment
comment|/* Ditto, but narrowest signed type.  */
end_comment

begin_function
specifier|static
name|enum
name|integer_type_kind
name|narrowest_signed_type
parameter_list|(
name|tree
name|value
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|enum
name|integer_type_kind
name|itk
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|CPP_N_WIDTH
operator|)
operator|==
name|CPP_N_SMALL
condition|)
name|itk
operator|=
name|itk_int
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|CPP_N_WIDTH
operator|)
operator|==
name|CPP_N_MEDIUM
condition|)
name|itk
operator|=
name|itk_long
expr_stmt|;
else|else
name|itk
operator|=
name|itk_long_long
expr_stmt|;
comment|/* int_fits_type_p must think the type of its first argument is      wider than its second argument, or it won't do the proper check.  */
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|widest_unsigned_literal_type_node
expr_stmt|;
for|for
control|(
init|;
name|itk
operator|<
name|itk_none
condition|;
name|itk
operator|+=
literal|2
comment|/* skip signed types */
control|)
if|if
condition|(
name|int_fits_type_p
argument_list|(
name|value
argument_list|,
name|integer_types
index|[
name|itk
index|]
argument_list|)
condition|)
return|return
name|itk
return|;
return|return
name|itk_none
return|;
block|}
end_function

begin_comment
comment|/* Interpret TOKEN, an integer with FLAGS as classified by cpplib.  */
end_comment

begin_function
specifier|static
name|tree
name|interpret_integer
parameter_list|(
specifier|const
name|cpp_token
modifier|*
name|token
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|tree
name|value
decl_stmt|,
name|type
decl_stmt|;
name|enum
name|integer_type_kind
name|itk
decl_stmt|;
name|cpp_num
name|integer
decl_stmt|;
name|cpp_options
modifier|*
name|options
init|=
name|cpp_get_options
argument_list|(
name|parse_in
argument_list|)
decl_stmt|;
name|integer
operator|=
name|cpp_interpret_integer
argument_list|(
name|parse_in
argument_list|,
name|token
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|integer
operator|=
name|cpp_num_sign_extend
argument_list|(
name|integer
argument_list|,
name|options
operator|->
name|precision
argument_list|)
expr_stmt|;
name|value
operator|=
name|build_int_2_wide
argument_list|(
name|integer
operator|.
name|low
argument_list|,
name|integer
operator|.
name|high
argument_list|)
expr_stmt|;
comment|/* The type of a constant with a U suffix is straightforward.  */
if|if
condition|(
name|flags
operator|&
name|CPP_N_UNSIGNED
condition|)
name|itk
operator|=
name|narrowest_unsigned_type
argument_list|(
name|value
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* The type of a potentially-signed integer constant varies 	 depending on the base it's in, the standard in use, and the 	 length suffixes.  */
name|enum
name|integer_type_kind
name|itk_u
init|=
name|narrowest_unsigned_type
argument_list|(
name|value
argument_list|,
name|flags
argument_list|)
decl_stmt|;
name|enum
name|integer_type_kind
name|itk_s
init|=
name|narrowest_signed_type
argument_list|(
name|value
argument_list|,
name|flags
argument_list|)
decl_stmt|;
comment|/* In both C89 and C99, octal and hex constants may be signed or 	 unsigned, whichever fits tighter.  We do not warn about this 	 choice differing from the traditional choice, as the constant 	 is probably a bit pattern and either way will work.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|CPP_N_RADIX
operator|)
operator|!=
name|CPP_N_DECIMAL
condition|)
name|itk
operator|=
name|MIN
argument_list|(
name|itk_u
argument_list|,
name|itk_s
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* In C99, decimal constants are always signed. 	     In C89, decimal constants that don't fit in long have 	     undefined behavior; we try to make them unsigned long. 	     In GCC's extended C89, that last is true of decimal 	     constants that don't fit in long long, too.  */
name|itk
operator|=
name|itk_s
expr_stmt|;
if|if
condition|(
name|itk_s
operator|>
name|itk_u
operator|&&
name|itk_s
operator|>
name|itk_long
condition|)
block|{
if|if
condition|(
operator|!
name|flag_isoc99
condition|)
block|{
if|if
condition|(
name|itk_u
operator|<
name|itk_unsigned_long
condition|)
name|itk_u
operator|=
name|itk_unsigned_long
expr_stmt|;
name|itk
operator|=
name|itk_u
expr_stmt|;
name|warning
argument_list|(
literal|"this decimal constant is unsigned only in ISO C90"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|warn_traditional
condition|)
name|warning
argument_list|(
literal|"this decimal constant would be unsigned in ISO C90"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|itk
operator|==
name|itk_none
condition|)
comment|/* cpplib has already issued a warning for overflow.  */
name|type
operator|=
operator|(
operator|(
name|flags
operator|&
name|CPP_N_UNSIGNED
operator|)
condition|?
name|widest_unsigned_literal_type_node
else|:
name|widest_integer_literal_type_node
operator|)
expr_stmt|;
else|else
name|type
operator|=
name|integer_types
index|[
name|itk
index|]
expr_stmt|;
if|if
condition|(
name|itk
operator|>
name|itk_unsigned_long
operator|&&
operator|(
name|flags
operator|&
name|CPP_N_WIDTH
operator|)
operator|!=
name|CPP_N_LARGE
operator|&&
operator|!
name|in_system_header
operator|&&
operator|!
name|flag_isoc99
condition|)
name|pedwarn
argument_list|(
literal|"integer constant is too large for \"%s\" type"
argument_list|,
operator|(
name|flags
operator|&
name|CPP_N_UNSIGNED
operator|)
condition|?
literal|"unsigned long"
else|:
literal|"long"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* Convert imaginary to a complex type.  */
if|if
condition|(
name|flags
operator|&
name|CPP_N_IMAGINARY
condition|)
name|value
operator|=
name|build_complex
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Interpret TOKEN, a floating point number with FLAGS as classified    by cpplib.  */
end_comment

begin_function
specifier|static
name|tree
name|interpret_float
parameter_list|(
specifier|const
name|cpp_token
modifier|*
name|token
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|value
decl_stmt|;
name|REAL_VALUE_TYPE
name|real
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|;
name|size_t
name|copylen
decl_stmt|;
specifier|const
name|char
modifier|*
name|typename
decl_stmt|;
comment|/* FIXME: make %T work in error/warning, then we don't need typename.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|CPP_N_WIDTH
operator|)
operator|==
name|CPP_N_LARGE
condition|)
block|{
name|type
operator|=
name|long_double_type_node
expr_stmt|;
name|typename
operator|=
literal|"long double"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|CPP_N_WIDTH
operator|)
operator|==
name|CPP_N_SMALL
operator|||
name|flag_single_precision_constant
condition|)
block|{
name|type
operator|=
name|float_type_node
expr_stmt|;
name|typename
operator|=
literal|"float"
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|double_type_node
expr_stmt|;
name|typename
operator|=
literal|"double"
expr_stmt|;
block|}
comment|/* Copy the constant to a nul-terminated buffer.  If the constant      has any suffixes, cut them off; REAL_VALUE_ATOF/ REAL_VALUE_HTOF      can't handle them.  */
name|copylen
operator|=
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|CPP_N_WIDTH
operator|)
operator|!=
name|CPP_N_MEDIUM
condition|)
comment|/* Must be an F or L suffix.  */
name|copylen
operator|--
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CPP_N_IMAGINARY
condition|)
comment|/* I or J suffix.  */
name|copylen
operator|--
expr_stmt|;
name|copy
operator|=
name|alloca
argument_list|(
name|copylen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
argument_list|,
name|copylen
argument_list|)
expr_stmt|;
name|copy
index|[
name|copylen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|real_from_string
argument_list|(
operator|&
name|real
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|real_convert
argument_list|(
operator|&
name|real
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|real
argument_list|)
expr_stmt|;
comment|/* A diagnostic is required for "soft" overflow by some ISO C      testsuites.  This is not pedwarn, because some people don't want      an error for this.      ??? That's a dubious reason... is this a mandatory diagnostic or      isn't it?   -- zw, 2001-08-21.  */
if|if
condition|(
name|REAL_VALUE_ISINF
argument_list|(
name|real
argument_list|)
operator|&&
name|pedantic
condition|)
name|warning
argument_list|(
literal|"floating constant exceeds range of \"%s\""
argument_list|,
name|typename
argument_list|)
expr_stmt|;
comment|/* Create a node with determined type and value.  */
name|value
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CPP_N_IMAGINARY
condition|)
name|value
operator|=
name|build_complex
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Convert a series of STRING and/or WSTRING tokens into a tree,    performing string constant concatenation.  TOK is the first of    these.  VALP is the location to write the string into.  OBJC_STRING    indicates whether an '@' token preceded the incoming token.    Returns the CPP token type of the result (CPP_STRING, CPP_WSTRING,    or CPP_OBJC_STRING).     This is unfortunately more work than it should be.  If any of the    strings in the series has an L prefix, the result is a wide string    (6.4.5p4).  Whether or not the result is a wide string affects the    meaning of octal and hexadecimal escapes (6.4.4.4p6,9).  But escape    sequences do not continue across the boundary between two strings in    a series (6.4.5p7), so we must not lose the boundaries.  Therefore    cpp_interpret_string takes a vector of cpp_string structures, which    we must arrange to provide.  */
end_comment

begin_function
specifier|static
name|enum
name|cpp_ttype
name|lex_string
parameter_list|(
specifier|const
name|cpp_token
modifier|*
name|tok
parameter_list|,
name|tree
modifier|*
name|valp
parameter_list|,
name|bool
name|objc_string
parameter_list|)
block|{
name|tree
name|value
decl_stmt|;
name|bool
name|wide
init|=
name|false
decl_stmt|;
name|size_t
name|count
init|=
literal|1
decl_stmt|;
name|struct
name|obstack
name|str_ob
decl_stmt|;
name|cpp_string
name|istr
decl_stmt|;
comment|/* Try to avoid the overhead of creating and destroying an obstack      for the common case of just one string.  */
name|cpp_string
name|str
init|=
name|tok
operator|->
name|val
operator|.
name|str
decl_stmt|;
name|cpp_string
modifier|*
name|strs
init|=
operator|&
name|str
decl_stmt|;
if|if
condition|(
name|tok
operator|->
name|type
operator|==
name|CPP_WSTRING
condition|)
name|wide
operator|=
name|true
expr_stmt|;
name|tok
operator|=
name|get_nonpadding_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|c_dialect_objc
argument_list|()
operator|&&
name|tok
operator|->
name|type
operator|==
name|CPP_ATSIGN
condition|)
block|{
name|objc_string
operator|=
name|true
expr_stmt|;
name|tok
operator|=
name|get_nonpadding_token
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|tok
operator|->
name|type
operator|==
name|CPP_STRING
operator|||
name|tok
operator|->
name|type
operator|==
name|CPP_WSTRING
condition|)
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|str_ob
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|str_ob
argument_list|,
operator|&
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|cpp_string
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|tok
operator|->
name|type
operator|==
name|CPP_WSTRING
condition|)
name|wide
operator|=
name|true
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|str_ob
argument_list|,
operator|&
name|tok
operator|->
name|val
operator|.
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|cpp_string
argument_list|)
argument_list|)
expr_stmt|;
name|tok
operator|=
name|get_nonpadding_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|c_dialect_objc
argument_list|()
operator|&&
name|tok
operator|->
name|type
operator|==
name|CPP_ATSIGN
condition|)
block|{
name|objc_string
operator|=
name|true
expr_stmt|;
name|tok
operator|=
name|get_nonpadding_token
argument_list|()
expr_stmt|;
block|}
block|}
do|while
condition|(
name|tok
operator|->
name|type
operator|==
name|CPP_STRING
operator|||
name|tok
operator|->
name|type
operator|==
name|CPP_WSTRING
condition|)
do|;
name|strs
operator|=
name|obstack_finish
argument_list|(
operator|&
name|str_ob
argument_list|)
expr_stmt|;
block|}
comment|/* We have read one more token than we want.  */
name|_cpp_backup_tokens
argument_list|(
name|parse_in
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
operator|&&
operator|!
name|objc_string
operator|&&
name|warn_traditional
operator|&&
operator|!
name|in_system_header
condition|)
name|warning
argument_list|(
literal|"traditional C rejects string constant concatenation"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpp_interpret_string
argument_list|(
name|parse_in
argument_list|,
name|strs
argument_list|,
name|count
argument_list|,
operator|&
name|istr
argument_list|,
name|wide
argument_list|)
condition|)
block|{
name|value
operator|=
name|build_string
argument_list|(
name|istr
operator|.
name|len
argument_list|,
operator|(
name|char
operator|*
operator|)
name|istr
operator|.
name|text
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|istr
operator|.
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Callers cannot generally handle error_mark_node in this context, 	 so return the empty string instead.  cpp_interpret_string has 	 issued an error.  */
if|if
condition|(
name|wide
condition|)
name|value
operator|=
name|build_string
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|wchar_type_node
argument_list|)
operator|/
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
argument_list|,
literal|"\0\0\0"
argument_list|)
expr_stmt|;
comment|/* widest supported wchar_t 					     is 32 bits */
else|else
name|value
operator|=
name|build_string
argument_list|(
literal|1
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|wide
condition|?
name|wchar_array_type_node
else|:
name|char_array_type_node
expr_stmt|;
operator|*
name|valp
operator|=
name|fix_string_type
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|strs
operator|!=
operator|&
name|str
condition|)
name|obstack_free
argument_list|(
operator|&
name|str_ob
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|objc_string
condition|?
name|CPP_OBJC_STRING
else|:
name|wide
condition|?
name|CPP_WSTRING
else|:
name|CPP_STRING
return|;
block|}
end_function

begin_comment
comment|/* Converts a (possibly wide) character constant token into a tree.  */
end_comment

begin_function
specifier|static
name|tree
name|lex_charconst
parameter_list|(
specifier|const
name|cpp_token
modifier|*
name|token
parameter_list|)
block|{
name|cppchar_t
name|result
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|value
decl_stmt|;
name|unsigned
name|int
name|chars_seen
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|result
operator|=
name|cpp_interpret_charconst
argument_list|(
name|parse_in
argument_list|,
name|token
argument_list|,
operator|&
name|chars_seen
argument_list|,
operator|&
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* Cast to cppchar_signed_t to get correct sign-extension of RESULT      before possibly widening to HOST_WIDE_INT for build_int_2.  */
if|if
condition|(
name|unsignedp
operator|||
operator|(
name|cppchar_signed_t
operator|)
name|result
operator|>=
literal|0
condition|)
name|value
operator|=
name|build_int_2
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|build_int_2
argument_list|(
operator|(
name|cppchar_signed_t
operator|)
name|result
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_WCHAR
condition|)
name|type
operator|=
name|wchar_type_node
expr_stmt|;
comment|/* In C, a character constant has type 'int'.      In C++ 'char', but multi-char charconsts have type 'int'.  */
elseif|else
if|if
condition|(
operator|!
name|c_dialect_cxx
argument_list|()
operator|||
name|chars_seen
operator|>
literal|1
condition|)
name|type
operator|=
name|integer_type_node
expr_stmt|;
else|else
name|type
operator|=
name|char_type_node
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

end_unit

