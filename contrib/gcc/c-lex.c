begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Mainly the interface between cpplib and the C front ends.    Copyright (C) 1987, 1988, 1989, 1992, 1994, 1995, 1996, 1997    1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"splay-tree.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
end_ifdef

begin_include
include|#
directive|include
file|"mbchar.h"
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MULTIBYTE_CHARS */
end_comment

begin_comment
comment|/* The current line map.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|line_map
modifier|*
name|map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The line used to refresh the lineno global variable after each token.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|src_lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We may keep statistics about how long which files took to compile.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|header_time
decl_stmt|,
name|body_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|splay_tree
name|file_info_tree
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File used for outputting assembler code.  */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|WCHAR_TYPE_SIZE
end_undef

begin_define
define|#
directive|define
name|WCHAR_TYPE_SIZE
value|TYPE_PRECISION (wchar_type_node)
end_define

begin_comment
comment|/* Number of bytes in a wide character.  */
end_comment

begin_define
define|#
directive|define
name|WCHAR_BYTES
value|(WCHAR_TYPE_SIZE / BITS_PER_UNIT)
end_define

begin_decl_stmt
name|int
name|pending_lang_change
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If we need to switch languages - C++ only */
end_comment

begin_decl_stmt
name|int
name|c_header_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* depth in C headers - C++ only */
end_comment

begin_comment
comment|/* Nonzero tells yylex to ignore \ in string constants.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ignore_escape_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|interpret_integer
name|PARAMS
argument_list|(
operator|(
specifier|const
name|cpp_token
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|interpret_float
name|PARAMS
argument_list|(
operator|(
specifier|const
name|cpp_token
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|integer_type_kind
name|narrowest_unsigned_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|integer_type_kind
name|narrowest_signed_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lex_string
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lex_charconst
name|PARAMS
argument_list|(
operator|(
specifier|const
name|cpp_token
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_header_times
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dump_one_header
name|PARAMS
argument_list|(
operator|(
name|splay_tree_node
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cb_line_change
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|cpp_token
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cb_ident
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|unsigned
name|int
operator|,
specifier|const
name|cpp_string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cb_file_change
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
expr|struct
name|line_map
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cb_def_pragma
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cb_define
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|unsigned
name|int
operator|,
name|cpp_hashnode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cb_undef
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|unsigned
name|int
operator|,
name|cpp_hashnode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|const
name|char
modifier|*
name|init_c_lex
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|struct
name|cpp_callbacks
modifier|*
name|cb
decl_stmt|;
name|struct
name|c_fileinfo
modifier|*
name|toplevel
decl_stmt|;
comment|/* Set up filename timing.  Must happen before cpp_read_main_file.  */
name|file_info_tree
operator|=
name|splay_tree_new
argument_list|(
operator|(
name|splay_tree_compare_fn
operator|)
name|strcmp
argument_list|,
literal|0
argument_list|,
operator|(
name|splay_tree_delete_value_fn
operator|)
name|free
argument_list|)
expr_stmt|;
name|toplevel
operator|=
name|get_fileinfo
argument_list|(
literal|"<top level>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_detailed_statistics
condition|)
block|{
name|header_time
operator|=
literal|0
expr_stmt|;
name|body_time
operator|=
name|get_run_time
argument_list|()
expr_stmt|;
name|toplevel
operator|->
name|time
operator|=
name|body_time
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
comment|/* Change to the native locale for multibyte conversions.  */
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|GET_ENVIRONMENT
argument_list|(
name|literal_codeset
argument_list|,
literal|"LANG"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cb
operator|=
name|cpp_get_callbacks
argument_list|(
name|parse_in
argument_list|)
expr_stmt|;
name|cb
operator|->
name|line_change
operator|=
name|cb_line_change
expr_stmt|;
name|cb
operator|->
name|ident
operator|=
name|cb_ident
expr_stmt|;
name|cb
operator|->
name|file_change
operator|=
name|cb_file_change
expr_stmt|;
name|cb
operator|->
name|def_pragma
operator|=
name|cb_def_pragma
expr_stmt|;
comment|/* Set the debug callbacks if we can use them.  */
if|if
condition|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
operator|&&
operator|(
name|write_symbols
operator|==
name|DWARF_DEBUG
operator|||
name|write_symbols
operator|==
name|DWARF2_DEBUG
operator|||
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
operator|)
condition|)
block|{
name|cb
operator|->
name|define
operator|=
name|cb_define
expr_stmt|;
name|cb
operator|->
name|undef
operator|=
name|cb_undef
expr_stmt|;
block|}
comment|/* Start it at 0.  */
name|lineno
operator|=
literal|0
expr_stmt|;
return|return
name|cpp_read_main_file
argument_list|(
name|parse_in
argument_list|,
name|filename
argument_list|,
name|ident_hash
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A thin wrapper around the real parser that initializes the     integrated preprocessor after debug output has been initialized.    Also, make sure the start_source_file debug hook gets called for    the primary source file.  */
end_comment

begin_function
name|void
name|c_common_parse_file
parameter_list|(
name|set_yydebug
parameter_list|)
name|int
name|set_yydebug
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|#
directive|if
name|YYDEBUG
operator|!=
literal|0
name|yydebug
operator|=
name|set_yydebug
expr_stmt|;
else|#
directive|else
name|warning
argument_list|(
literal|"YYDEBUG not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
call|(
modifier|*
name|debug_hooks
operator|->
name|start_source_file
call|)
argument_list|(
name|lineno
argument_list|,
name|input_filename
argument_list|)
expr_stmt|;
name|cpp_finish_options
argument_list|(
name|parse_in
argument_list|)
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
name|free_parser_stacks
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|c_fileinfo
modifier|*
name|get_fileinfo
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|splay_tree_node
name|n
decl_stmt|;
name|struct
name|c_fileinfo
modifier|*
name|fi
decl_stmt|;
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|file_info_tree
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
return|return
operator|(
expr|struct
name|c_fileinfo
operator|*
operator|)
name|n
operator|->
name|value
return|;
name|fi
operator|=
operator|(
expr|struct
name|c_fileinfo
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|c_fileinfo
argument_list|)
argument_list|)
expr_stmt|;
name|fi
operator|->
name|time
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|interface_only
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|interface_unknown
operator|=
literal|1
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|file_info_tree
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|name
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|fi
argument_list|)
expr_stmt|;
return|return
name|fi
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_header_times
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
comment|/* Changing files again.  This means currently collected time      is charged against header time, and body time starts back at 0.  */
if|if
condition|(
name|flag_detailed_statistics
condition|)
block|{
name|int
name|this_time
init|=
name|get_run_time
argument_list|()
decl_stmt|;
name|struct
name|c_fileinfo
modifier|*
name|file
init|=
name|get_fileinfo
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|header_time
operator|+=
name|this_time
operator|-
name|body_time
expr_stmt|;
name|file
operator|->
name|time
operator|+=
name|this_time
operator|-
name|body_time
expr_stmt|;
name|body_time
operator|=
name|this_time
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|dump_one_header
parameter_list|(
name|n
parameter_list|,
name|dummy
parameter_list|)
name|splay_tree_node
name|n
decl_stmt|;
name|void
modifier|*
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|print_time
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|n
operator|->
name|key
argument_list|,
operator|(
operator|(
expr|struct
name|c_fileinfo
operator|*
operator|)
name|n
operator|->
name|value
operator|)
operator|->
name|time
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|dump_time_statistics
parameter_list|()
block|{
name|struct
name|c_fileinfo
modifier|*
name|file
init|=
name|get_fileinfo
argument_list|(
name|input_filename
argument_list|)
decl_stmt|;
name|int
name|this_time
init|=
name|get_run_time
argument_list|()
decl_stmt|;
name|file
operator|->
name|time
operator|+=
name|this_time
operator|-
name|body_time
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n******\n"
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"header files (total)"
argument_list|,
name|header_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"main file (total)"
argument_list|,
name|this_time
operator|-
name|body_time
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ratio = %g : 1\n"
argument_list|,
operator|(
name|double
operator|)
name|header_time
operator|/
call|(
name|double
call|)
argument_list|(
name|this_time
operator|-
name|body_time
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n******\n"
argument_list|)
expr_stmt|;
name|splay_tree_foreach
argument_list|(
name|file_info_tree
argument_list|,
name|dump_one_header
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cb_ident
parameter_list|(
name|pfile
parameter_list|,
name|line
parameter_list|,
name|str
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|cpp_string
modifier|*
name|str
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_IDENT
if|if
condition|(
operator|!
name|flag_no_ident
condition|)
block|{
comment|/* Convert escapes in the string.  */
name|tree
name|value
init|=
name|lex_string
argument_list|(
name|str
operator|->
name|text
argument_list|,
name|str
operator|->
name|len
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ASM_OUTPUT_IDENT
argument_list|(
name|asm_out_file
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Called at the start of every non-empty line.  TOKEN is the first    lexed token on the line.  Used for diagnostic line numbers.  */
end_comment

begin_function
specifier|static
name|void
name|cb_line_change
parameter_list|(
name|pfile
parameter_list|,
name|token
parameter_list|,
name|parsing_args
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
name|int
name|parsing_args
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|src_lineno
operator|=
name|SOURCE_LINE
argument_list|(
name|map
argument_list|,
name|token
operator|->
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cb_file_change
parameter_list|(
name|pfile
parameter_list|,
name|new_map
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|line_map
modifier|*
name|new_map
decl_stmt|;
block|{
name|unsigned
name|int
name|to_line
init|=
name|SOURCE_LINE
argument_list|(
name|new_map
argument_list|,
name|new_map
operator|->
name|to_line
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_map
operator|->
name|reason
operator|==
name|LC_ENTER
condition|)
block|{
comment|/* Don't stack the main buffer on the input stack; 	 we already did in compile_file.  */
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
name|main_input_filename
operator|=
name|new_map
operator|->
name|to_file
expr_stmt|;
else|else
block|{
name|int
name|included_at
init|=
name|SOURCE_LINE
argument_list|(
name|new_map
operator|-
literal|1
argument_list|,
name|new_map
operator|->
name|from_line
operator|-
literal|1
argument_list|)
decl_stmt|;
name|lineno
operator|=
name|included_at
expr_stmt|;
name|push_srcloc
argument_list|(
name|new_map
operator|->
name|to_file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
call|(
modifier|*
name|debug_hooks
operator|->
name|start_source_file
call|)
argument_list|(
name|included_at
argument_list|,
name|new_map
operator|->
name|to_file
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_IMPLICIT_EXTERN_C
if|if
condition|(
name|c_header_level
condition|)
operator|++
name|c_header_level
expr_stmt|;
elseif|else
if|if
condition|(
name|new_map
operator|->
name|sysp
operator|==
literal|2
condition|)
block|{
name|c_header_level
operator|=
literal|1
expr_stmt|;
operator|++
name|pending_lang_change
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
name|new_map
operator|->
name|reason
operator|==
name|LC_LEAVE
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_IMPLICIT_EXTERN_C
if|if
condition|(
name|c_header_level
operator|&&
operator|--
name|c_header_level
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|new_map
operator|->
name|sysp
operator|==
literal|2
condition|)
name|warning
argument_list|(
literal|"badly nested C headers from preprocessor"
argument_list|)
expr_stmt|;
operator|--
name|pending_lang_change
expr_stmt|;
block|}
endif|#
directive|endif
name|pop_srcloc
argument_list|()
expr_stmt|;
call|(
modifier|*
name|debug_hooks
operator|->
name|end_source_file
call|)
argument_list|(
name|to_line
argument_list|)
expr_stmt|;
block|}
name|update_header_times
argument_list|(
name|new_map
operator|->
name|to_file
argument_list|)
expr_stmt|;
name|in_system_header
operator|=
operator|(
name|warn_system_headers
operator|&&
name|new_map
operator|->
name|sysp
operator|!=
literal|0
operator|)
expr_stmt|;
name|input_filename
operator|=
name|new_map
operator|->
name|to_file
expr_stmt|;
name|lineno
operator|=
name|to_line
expr_stmt|;
name|map
operator|=
name|new_map
expr_stmt|;
comment|/* Hook for C++.  */
name|extract_interface_info
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cb_def_pragma
parameter_list|(
name|pfile
parameter_list|,
name|line
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
block|{
comment|/* Issue a warning message if we have been asked to do so.  Ignore      unknown pragmas in system headers unless an explicit      -Wunknown-pragmas has been given.  */
if|if
condition|(
name|warn_unknown_pragmas
operator|>
name|in_system_header
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|space
decl_stmt|,
modifier|*
name|name
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|s
decl_stmt|;
name|space
operator|=
name|name
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
literal|""
expr_stmt|;
name|s
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|!=
name|CPP_EOF
condition|)
block|{
name|space
operator|=
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|CPP_NAME
condition|)
name|name
operator|=
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|lineno
operator|=
name|SOURCE_LINE
argument_list|(
name|map
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"ignoring #pragma %s %s"
argument_list|,
name|space
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* #define callback for DWARF and DWARF2 debug info.  */
end_comment

begin_function
specifier|static
name|void
name|cb_define
parameter_list|(
name|pfile
parameter_list|,
name|line
parameter_list|,
name|node
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
block|{
call|(
modifier|*
name|debug_hooks
operator|->
name|define
call|)
argument_list|(
name|SOURCE_LINE
argument_list|(
name|map
argument_list|,
name|line
argument_list|)
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|cpp_macro_definition
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* #undef callback for DWARF and DWARF2 debug info.  */
end_comment

begin_function
specifier|static
name|void
name|cb_undef
parameter_list|(
name|pfile
parameter_list|,
name|line
parameter_list|,
name|node
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
block|{
call|(
modifier|*
name|debug_hooks
operator|->
name|undef
call|)
argument_list|(
name|SOURCE_LINE
argument_list|(
name|map
argument_list|,
name|line
argument_list|)
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* not yet */
end_comment

begin_comment
comment|/* Returns nonzero if C is a universal-character-name.  Give an error if it    is not one which may appear in an identifier, as per [extendid].     Note that extended character support in identifiers has not yet been    implemented.  It is my personal opinion that this is not a desirable    feature.  Portable code cannot count on support for more than the basic    identifier character set.  */
end_comment

begin_ifdef
unit|static inline int is_extended_char (c)      int c; {
ifdef|#
directive|ifdef
name|TARGET_EBCDIC
end_ifdef

begin_else
unit|return 0;
else|#
directive|else
end_else

begin_comment
comment|/* ASCII.  */
end_comment

begin_comment
unit|if (c< 0x7f)     return 0;
comment|/* None of the valid chars are outside the Basic Multilingual Plane (the      low 16 bits).  */
end_comment

begin_comment
unit|if (c> 0xffff)     {       error ("universal-character-name '\\U%08x' not valid in identifier", c);       return 1;     }
comment|/* Latin */
end_comment

begin_comment
unit|if ((c>= 0x00c0&& c<= 0x00d6)       || (c>= 0x00d8&& c<= 0x00f6)       || (c>= 0x00f8&& c<= 0x01f5)       || (c>= 0x01fa&& c<= 0x0217)       || (c>= 0x0250&& c<= 0x02a8)       || (c>= 0x1e00&& c<= 0x1e9a)       || (c>= 0x1ea0&& c<= 0x1ef9))     return 1;
comment|/* Greek */
end_comment

begin_comment
unit|if ((c == 0x0384)       || (c>= 0x0388&& c<= 0x038a)       || (c == 0x038c)       || (c>= 0x038e&& c<= 0x03a1)       || (c>= 0x03a3&& c<= 0x03ce)       || (c>= 0x03d0&& c<= 0x03d6)       || (c == 0x03da)       || (c == 0x03dc)       || (c == 0x03de)       || (c == 0x03e0)       || (c>= 0x03e2&& c<= 0x03f3)       || (c>= 0x1f00&& c<= 0x1f15)       || (c>= 0x1f18&& c<= 0x1f1d)       || (c>= 0x1f20&& c<= 0x1f45)       || (c>= 0x1f48&& c<= 0x1f4d)       || (c>= 0x1f50&& c<= 0x1f57)       || (c == 0x1f59)       || (c == 0x1f5b)       || (c == 0x1f5d)       || (c>= 0x1f5f&& c<= 0x1f7d)       || (c>= 0x1f80&& c<= 0x1fb4)       || (c>= 0x1fb6&& c<= 0x1fbc)       || (c>= 0x1fc2&& c<= 0x1fc4)       || (c>= 0x1fc6&& c<= 0x1fcc)       || (c>= 0x1fd0&& c<= 0x1fd3)       || (c>= 0x1fd6&& c<= 0x1fdb)       || (c>= 0x1fe0&& c<= 0x1fec)       || (c>= 0x1ff2&& c<= 0x1ff4)       || (c>= 0x1ff6&& c<= 0x1ffc))     return 1;
comment|/* Cyrillic */
end_comment

begin_comment
unit|if ((c>= 0x0401&& c<= 0x040d)       || (c>= 0x040f&& c<= 0x044f)       || (c>= 0x0451&& c<= 0x045c)       || (c>= 0x045e&& c<= 0x0481)       || (c>= 0x0490&& c<= 0x04c4)       || (c>= 0x04c7&& c<= 0x04c8)       || (c>= 0x04cb&& c<= 0x04cc)       || (c>= 0x04d0&& c<= 0x04eb)       || (c>= 0x04ee&& c<= 0x04f5)       || (c>= 0x04f8&& c<= 0x04f9))     return 1;
comment|/* Armenian */
end_comment

begin_comment
unit|if ((c>= 0x0531&& c<= 0x0556)       || (c>= 0x0561&& c<= 0x0587))     return 1;
comment|/* Hebrew */
end_comment

begin_comment
unit|if ((c>= 0x05d0&& c<= 0x05ea)       || (c>= 0x05f0&& c<= 0x05f4))     return 1;
comment|/* Arabic */
end_comment

begin_comment
unit|if ((c>= 0x0621&& c<= 0x063a)       || (c>= 0x0640&& c<= 0x0652)       || (c>= 0x0670&& c<= 0x06b7)       || (c>= 0x06ba&& c<= 0x06be)       || (c>= 0x06c0&& c<= 0x06ce)       || (c>= 0x06e5&& c<= 0x06e7))     return 1;
comment|/* Devanagari */
end_comment

begin_comment
unit|if ((c>= 0x0905&& c<= 0x0939)       || (c>= 0x0958&& c<= 0x0962))     return 1;
comment|/* Bengali */
end_comment

begin_comment
unit|if ((c>= 0x0985&& c<= 0x098c)       || (c>= 0x098f&& c<= 0x0990)       || (c>= 0x0993&& c<= 0x09a8)       || (c>= 0x09aa&& c<= 0x09b0)       || (c == 0x09b2)       || (c>= 0x09b6&& c<= 0x09b9)       || (c>= 0x09dc&& c<= 0x09dd)       || (c>= 0x09df&& c<= 0x09e1)       || (c>= 0x09f0&& c<= 0x09f1))     return 1;
comment|/* Gurmukhi */
end_comment

begin_comment
unit|if ((c>= 0x0a05&& c<= 0x0a0a)       || (c>= 0x0a0f&& c<= 0x0a10)       || (c>= 0x0a13&& c<= 0x0a28)       || (c>= 0x0a2a&& c<= 0x0a30)       || (c>= 0x0a32&& c<= 0x0a33)       || (c>= 0x0a35&& c<= 0x0a36)       || (c>= 0x0a38&& c<= 0x0a39)       || (c>= 0x0a59&& c<= 0x0a5c)       || (c == 0x0a5e))     return 1;
comment|/* Gujarati */
end_comment

begin_comment
unit|if ((c>= 0x0a85&& c<= 0x0a8b)       || (c == 0x0a8d)       || (c>= 0x0a8f&& c<= 0x0a91)       || (c>= 0x0a93&& c<= 0x0aa8)       || (c>= 0x0aaa&& c<= 0x0ab0)       || (c>= 0x0ab2&& c<= 0x0ab3)       || (c>= 0x0ab5&& c<= 0x0ab9)       || (c == 0x0ae0))     return 1;
comment|/* Oriya */
end_comment

begin_comment
unit|if ((c>= 0x0b05&& c<= 0x0b0c)       || (c>= 0x0b0f&& c<= 0x0b10)       || (c>= 0x0b13&& c<= 0x0b28)       || (c>= 0x0b2a&& c<= 0x0b30)       || (c>= 0x0b32&& c<= 0x0b33)       || (c>= 0x0b36&& c<= 0x0b39)       || (c>= 0x0b5c&& c<= 0x0b5d)       || (c>= 0x0b5f&& c<= 0x0b61))     return 1;
comment|/* Tamil */
end_comment

begin_comment
unit|if ((c>= 0x0b85&& c<= 0x0b8a)       || (c>= 0x0b8e&& c<= 0x0b90)       || (c>= 0x0b92&& c<= 0x0b95)       || (c>= 0x0b99&& c<= 0x0b9a)       || (c == 0x0b9c)       || (c>= 0x0b9e&& c<= 0x0b9f)       || (c>= 0x0ba3&& c<= 0x0ba4)       || (c>= 0x0ba8&& c<= 0x0baa)       || (c>= 0x0bae&& c<= 0x0bb5)       || (c>= 0x0bb7&& c<= 0x0bb9))     return 1;
comment|/* Telugu */
end_comment

begin_comment
unit|if ((c>= 0x0c05&& c<= 0x0c0c)       || (c>= 0x0c0e&& c<= 0x0c10)       || (c>= 0x0c12&& c<= 0x0c28)       || (c>= 0x0c2a&& c<= 0x0c33)       || (c>= 0x0c35&& c<= 0x0c39)       || (c>= 0x0c60&& c<= 0x0c61))     return 1;
comment|/* Kannada */
end_comment

begin_comment
unit|if ((c>= 0x0c85&& c<= 0x0c8c)       || (c>= 0x0c8e&& c<= 0x0c90)       || (c>= 0x0c92&& c<= 0x0ca8)       || (c>= 0x0caa&& c<= 0x0cb3)       || (c>= 0x0cb5&& c<= 0x0cb9)       || (c>= 0x0ce0&& c<= 0x0ce1))     return 1;
comment|/* Malayalam */
end_comment

begin_comment
unit|if ((c>= 0x0d05&& c<= 0x0d0c)       || (c>= 0x0d0e&& c<= 0x0d10)       || (c>= 0x0d12&& c<= 0x0d28)       || (c>= 0x0d2a&& c<= 0x0d39)       || (c>= 0x0d60&& c<= 0x0d61))     return 1;
comment|/* Thai */
end_comment

begin_comment
unit|if ((c>= 0x0e01&& c<= 0x0e30)       || (c>= 0x0e32&& c<= 0x0e33)       || (c>= 0x0e40&& c<= 0x0e46)       || (c>= 0x0e4f&& c<= 0x0e5b))     return 1;
comment|/* Lao */
end_comment

begin_comment
unit|if ((c>= 0x0e81&& c<= 0x0e82)       || (c == 0x0e84)       || (c == 0x0e87)       || (c == 0x0e88)       || (c == 0x0e8a)       || (c == 0x0e0d)       || (c>= 0x0e94&& c<= 0x0e97)       || (c>= 0x0e99&& c<= 0x0e9f)       || (c>= 0x0ea1&& c<= 0x0ea3)       || (c == 0x0ea5)       || (c == 0x0ea7)       || (c == 0x0eaa)       || (c == 0x0eab)       || (c>= 0x0ead&& c<= 0x0eb0)       || (c == 0x0eb2)       || (c == 0x0eb3)       || (c == 0x0ebd)       || (c>= 0x0ec0&& c<= 0x0ec4)       || (c == 0x0ec6))     return 1;
comment|/* Georgian */
end_comment

begin_comment
unit|if ((c>= 0x10a0&& c<= 0x10c5)       || (c>= 0x10d0&& c<= 0x10f6))     return 1;
comment|/* Hiragana */
end_comment

begin_comment
unit|if ((c>= 0x3041&& c<= 0x3094)       || (c>= 0x309b&& c<= 0x309e))     return 1;
comment|/* Katakana */
end_comment

begin_comment
unit|if ((c>= 0x30a1&& c<= 0x30fe))     return 1;
comment|/* Bopmofo */
end_comment

begin_comment
unit|if ((c>= 0x3105&& c<= 0x312c))     return 1;
comment|/* Hangul */
end_comment

begin_comment
unit|if ((c>= 0x1100&& c<= 0x1159)       || (c>= 0x1161&& c<= 0x11a2)       || (c>= 0x11a8&& c<= 0x11f9))     return 1;
comment|/* CJK Unified Ideographs */
end_comment

begin_endif
unit|if ((c>= 0xf900&& c<= 0xfa2d)       || (c>= 0xfb1f&& c<= 0xfb36)       || (c>= 0xfb38&& c<= 0xfb3c)       || (c == 0xfb3e)       || (c>= 0xfb40&& c<= 0xfb41)       || (c>= 0xfb42&& c<= 0xfb44)       || (c>= 0xfb46&& c<= 0xfbb1)       || (c>= 0xfbd3&& c<= 0xfd3f)       || (c>= 0xfd50&& c<= 0xfd8f)       || (c>= 0xfd92&& c<= 0xfdc7)       || (c>= 0xfdf0&& c<= 0xfdfb)       || (c>= 0xfe70&& c<= 0xfe72)       || (c == 0xfe74)       || (c>= 0xfe76&& c<= 0xfefc)       || (c>= 0xff21&& c<= 0xff3a)       || (c>= 0xff41&& c<= 0xff5a)       || (c>= 0xff66&& c<= 0xffbe)       || (c>= 0xffc2&& c<= 0xffc7)       || (c>= 0xffca&& c<= 0xffcf)       || (c>= 0xffd2&& c<= 0xffd7)       || (c>= 0xffda&& c<= 0xffdc)       || (c>= 0x4e00&& c<= 0x9fa5))     return 1;    error ("universal-character-name '\\u%04x' not valid in identifier", c);   return 1;
endif|#
directive|endif
end_endif

begin_comment
unit|}
comment|/* Add the UTF-8 representation of C to the token_buffer.  */
end_comment

begin_endif
unit|static void utf8_extend_token (c)      int c; {   int shift, mask;    if      (c<= 0x0000007f)     {       extend_token (c);       return;     }   else if (c<= 0x000007ff)     shift = 6, mask = 0xc0;   else if (c<= 0x0000ffff)     shift = 12, mask = 0xe0;   else if (c<= 0x001fffff)     shift = 18, mask = 0xf0;   else if (c<= 0x03ffffff)     shift = 24, mask = 0xf8;   else     shift = 30, mask = 0xfc;    extend_token (mask | (c>> shift));   do     {       shift -= 6;       extend_token ((unsigned char) (0x80 | (c>> shift)));     }   while (shift); }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_function
name|int
name|c_lex
parameter_list|(
name|value
parameter_list|)
name|tree
modifier|*
name|value
decl_stmt|;
block|{
specifier|const
name|cpp_token
modifier|*
name|tok
decl_stmt|;
name|retry
label|:
name|timevar_push
argument_list|(
name|TV_CPP
argument_list|)
expr_stmt|;
do|do
name|tok
operator|=
name|cpp_get_token
argument_list|(
name|parse_in
argument_list|)
expr_stmt|;
do|while
condition|(
name|tok
operator|->
name|type
operator|==
name|CPP_PADDING
condition|)
do|;
name|timevar_pop
argument_list|(
name|TV_CPP
argument_list|)
expr_stmt|;
comment|/* The C++ front end does horrible things with the current line      number.  To ensure an accurate line number, we must reset it      every time we return a token.  */
name|lineno
operator|=
name|src_lineno
expr_stmt|;
operator|*
name|value
operator|=
name|NULL_TREE
expr_stmt|;
switch|switch
condition|(
name|tok
operator|->
name|type
condition|)
block|{
comment|/* Issue this error here, where we can get at tok->val.c.  */
case|case
name|CPP_OTHER
case|:
if|if
condition|(
name|ISGRAPH
argument_list|(
name|tok
operator|->
name|val
operator|.
name|c
argument_list|)
condition|)
name|error
argument_list|(
literal|"stray '%c' in program"
argument_list|,
name|tok
operator|->
name|val
operator|.
name|c
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"stray '\\%o' in program"
argument_list|,
name|tok
operator|->
name|val
operator|.
name|c
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
name|CPP_NAME
case|:
operator|*
name|value
operator|=
name|HT_IDENT_TO_GCC_IDENT
argument_list|(
name|HT_NODE
argument_list|(
name|tok
operator|->
name|val
operator|.
name|node
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_NUMBER
case|:
block|{
name|unsigned
name|int
name|flags
init|=
name|cpp_classify_number
argument_list|(
name|parse_in
argument_list|,
name|tok
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|flags
operator|&
name|CPP_N_CATEGORY
condition|)
block|{
case|case
name|CPP_N_INVALID
case|:
comment|/* cpplib has issued an error.  */
operator|*
name|value
operator|=
name|error_mark_node
expr_stmt|;
break|break;
case|case
name|CPP_N_INTEGER
case|:
operator|*
name|value
operator|=
name|interpret_integer
argument_list|(
name|tok
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_N_FLOATING
case|:
operator|*
name|value
operator|=
name|interpret_float
argument_list|(
name|tok
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CPP_CHAR
case|:
case|case
name|CPP_WCHAR
case|:
operator|*
name|value
operator|=
name|lex_charconst
argument_list|(
name|tok
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_STRING
case|:
case|case
name|CPP_WSTRING
case|:
operator|*
name|value
operator|=
name|lex_string
argument_list|(
name|tok
operator|->
name|val
operator|.
name|str
operator|.
name|text
argument_list|,
name|tok
operator|->
name|val
operator|.
name|str
operator|.
name|len
argument_list|,
name|tok
operator|->
name|type
operator|==
name|CPP_WSTRING
argument_list|)
expr_stmt|;
break|break;
comment|/* These tokens should not be visible outside cpplib.  */
case|case
name|CPP_HEADER_NAME
case|:
case|case
name|CPP_COMMENT
case|:
case|case
name|CPP_MACRO_ARG
case|:
name|abort
argument_list|()
expr_stmt|;
default|default:
break|break;
block|}
return|return
name|tok
operator|->
name|type
return|;
block|}
end_function

begin_comment
comment|/* Returns the narrowest C-visible unsigned type, starting with the    minimum specified by FLAGS, that can fit VALUE, or itk_none if    there isn't one.  */
end_comment

begin_function
specifier|static
name|enum
name|integer_type_kind
name|narrowest_unsigned_type
parameter_list|(
name|value
parameter_list|,
name|flags
parameter_list|)
name|tree
name|value
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
block|{
name|enum
name|integer_type_kind
name|itk
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|CPP_N_WIDTH
operator|)
operator|==
name|CPP_N_SMALL
condition|)
name|itk
operator|=
name|itk_unsigned_int
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|CPP_N_WIDTH
operator|)
operator|==
name|CPP_N_MEDIUM
condition|)
name|itk
operator|=
name|itk_unsigned_long
expr_stmt|;
else|else
name|itk
operator|=
name|itk_unsigned_long_long
expr_stmt|;
comment|/* int_fits_type_p must think the type of its first argument is      wider than its second argument, or it won't do the proper check.  */
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|widest_unsigned_literal_type_node
expr_stmt|;
for|for
control|(
init|;
name|itk
operator|<
name|itk_none
condition|;
name|itk
operator|+=
literal|2
comment|/* skip unsigned types */
control|)
if|if
condition|(
name|int_fits_type_p
argument_list|(
name|value
argument_list|,
name|integer_types
index|[
name|itk
index|]
argument_list|)
condition|)
return|return
name|itk
return|;
return|return
name|itk_none
return|;
block|}
end_function

begin_comment
comment|/* Ditto, but narrowest signed type.  */
end_comment

begin_function
specifier|static
name|enum
name|integer_type_kind
name|narrowest_signed_type
parameter_list|(
name|value
parameter_list|,
name|flags
parameter_list|)
name|tree
name|value
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
block|{
name|enum
name|integer_type_kind
name|itk
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|CPP_N_WIDTH
operator|)
operator|==
name|CPP_N_SMALL
condition|)
name|itk
operator|=
name|itk_int
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|CPP_N_WIDTH
operator|)
operator|==
name|CPP_N_MEDIUM
condition|)
name|itk
operator|=
name|itk_long
expr_stmt|;
else|else
name|itk
operator|=
name|itk_long_long
expr_stmt|;
comment|/* int_fits_type_p must think the type of its first argument is      wider than its second argument, or it won't do the proper check.  */
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|widest_unsigned_literal_type_node
expr_stmt|;
for|for
control|(
init|;
name|itk
operator|<
name|itk_none
condition|;
name|itk
operator|+=
literal|2
comment|/* skip signed types */
control|)
if|if
condition|(
name|int_fits_type_p
argument_list|(
name|value
argument_list|,
name|integer_types
index|[
name|itk
index|]
argument_list|)
condition|)
return|return
name|itk
return|;
return|return
name|itk_none
return|;
block|}
end_function

begin_comment
comment|/* Interpret TOKEN, an integer with FLAGS as classified by cpplib.  */
end_comment

begin_function
specifier|static
name|tree
name|interpret_integer
parameter_list|(
name|token
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|value
decl_stmt|,
name|type
decl_stmt|;
name|enum
name|integer_type_kind
name|itk
decl_stmt|;
name|cpp_num
name|integer
decl_stmt|;
name|cpp_options
modifier|*
name|options
init|=
name|cpp_get_options
argument_list|(
name|parse_in
argument_list|)
decl_stmt|;
name|integer
operator|=
name|cpp_interpret_integer
argument_list|(
name|parse_in
argument_list|,
name|token
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|integer
operator|=
name|cpp_num_sign_extend
argument_list|(
name|integer
argument_list|,
name|options
operator|->
name|precision
argument_list|)
expr_stmt|;
name|value
operator|=
name|build_int_2_wide
argument_list|(
name|integer
operator|.
name|low
argument_list|,
name|integer
operator|.
name|high
argument_list|)
expr_stmt|;
comment|/* The type of a constant with a U suffix is straightforward.  */
if|if
condition|(
name|flags
operator|&
name|CPP_N_UNSIGNED
condition|)
name|itk
operator|=
name|narrowest_unsigned_type
argument_list|(
name|value
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* The type of a potentially-signed integer constant varies 	 depending on the base it's in, the standard in use, and the 	 length suffixes.  */
name|enum
name|integer_type_kind
name|itk_u
init|=
name|narrowest_unsigned_type
argument_list|(
name|value
argument_list|,
name|flags
argument_list|)
decl_stmt|;
name|enum
name|integer_type_kind
name|itk_s
init|=
name|narrowest_signed_type
argument_list|(
name|value
argument_list|,
name|flags
argument_list|)
decl_stmt|;
comment|/* In both C89 and C99, octal and hex constants may be signed or 	 unsigned, whichever fits tighter.  We do not warn about this 	 choice differing from the traditional choice, as the constant 	 is probably a bit pattern and either way will work.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|CPP_N_RADIX
operator|)
operator|!=
name|CPP_N_DECIMAL
condition|)
name|itk
operator|=
name|MIN
argument_list|(
name|itk_u
argument_list|,
name|itk_s
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* In C99, decimal constants are always signed. 	     In C89, decimal constants that don't fit in long have 	     undefined behavior; we try to make them unsigned long. 	     In GCC's extended C89, that last is true of decimal 	     constants that don't fit in long long, too.  */
name|itk
operator|=
name|itk_s
expr_stmt|;
if|if
condition|(
name|itk_s
operator|>
name|itk_u
operator|&&
name|itk_s
operator|>
name|itk_long
condition|)
block|{
if|if
condition|(
operator|!
name|flag_isoc99
condition|)
block|{
if|if
condition|(
name|itk_u
operator|<
name|itk_unsigned_long
condition|)
name|itk_u
operator|=
name|itk_unsigned_long
expr_stmt|;
name|itk
operator|=
name|itk_u
expr_stmt|;
name|warning
argument_list|(
literal|"this decimal constant is unsigned only in ISO C90"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|warn_traditional
condition|)
name|warning
argument_list|(
literal|"this decimal constant would be unsigned in ISO C90"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|itk
operator|==
name|itk_none
condition|)
comment|/* cpplib has already issued a warning for overflow.  */
name|type
operator|=
operator|(
operator|(
name|flags
operator|&
name|CPP_N_UNSIGNED
operator|)
condition|?
name|widest_unsigned_literal_type_node
else|:
name|widest_integer_literal_type_node
operator|)
expr_stmt|;
else|else
name|type
operator|=
name|integer_types
index|[
name|itk
index|]
expr_stmt|;
if|if
condition|(
name|itk
operator|>
name|itk_unsigned_long
operator|&&
operator|(
name|flags
operator|&
name|CPP_N_WIDTH
operator|)
operator|!=
name|CPP_N_LARGE
operator|&&
operator|!
name|in_system_header
operator|&&
operator|!
name|flag_isoc99
condition|)
name|pedwarn
argument_list|(
literal|"integer constant is too large for \"%s\" type"
argument_list|,
operator|(
name|flags
operator|&
name|CPP_N_UNSIGNED
operator|)
condition|?
literal|"unsigned long"
else|:
literal|"long"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* Convert imaginary to a complex type.  */
if|if
condition|(
name|flags
operator|&
name|CPP_N_IMAGINARY
condition|)
name|value
operator|=
name|build_complex
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Interpret TOKEN, a floating point number with FLAGS as classified    by cpplib.  */
end_comment

begin_function
specifier|static
name|tree
name|interpret_float
parameter_list|(
name|token
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|value
decl_stmt|;
name|REAL_VALUE_TYPE
name|real
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|;
name|size_t
name|copylen
decl_stmt|;
specifier|const
name|char
modifier|*
name|typename
decl_stmt|;
comment|/* FIXME: make %T work in error/warning, then we don't need typename.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|CPP_N_WIDTH
operator|)
operator|==
name|CPP_N_LARGE
condition|)
block|{
name|type
operator|=
name|long_double_type_node
expr_stmt|;
name|typename
operator|=
literal|"long double"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|CPP_N_WIDTH
operator|)
operator|==
name|CPP_N_SMALL
operator|||
name|flag_single_precision_constant
condition|)
block|{
name|type
operator|=
name|float_type_node
expr_stmt|;
name|typename
operator|=
literal|"float"
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|double_type_node
expr_stmt|;
name|typename
operator|=
literal|"double"
expr_stmt|;
block|}
comment|/* Copy the constant to a nul-terminated buffer.  If the constant      has any suffixes, cut them off; REAL_VALUE_ATOF/ REAL_VALUE_HTOF      can't handle them.  */
name|copylen
operator|=
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|CPP_N_WIDTH
operator|)
operator|!=
name|CPP_N_MEDIUM
condition|)
comment|/* Must be an F or L suffix.  */
name|copylen
operator|--
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CPP_N_IMAGINARY
condition|)
comment|/* I or J suffix.  */
name|copylen
operator|--
expr_stmt|;
name|copy
operator|=
name|alloca
argument_list|(
name|copylen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
argument_list|,
name|copylen
argument_list|)
expr_stmt|;
name|copy
index|[
name|copylen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|real_from_string
argument_list|(
operator|&
name|real
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|real_convert
argument_list|(
operator|&
name|real
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|real
argument_list|)
expr_stmt|;
comment|/* A diagnostic is required for "soft" overflow by some ISO C      testsuites.  This is not pedwarn, because some people don't want      an error for this.      ??? That's a dubious reason... is this a mandatory diagnostic or      isn't it?   -- zw, 2001-08-21.  */
if|if
condition|(
name|REAL_VALUE_ISINF
argument_list|(
name|real
argument_list|)
operator|&&
name|pedantic
condition|)
name|warning
argument_list|(
literal|"floating constant exceeds range of \"%s\""
argument_list|,
name|typename
argument_list|)
expr_stmt|;
comment|/* Create a node with determined type and value.  */
name|value
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CPP_N_IMAGINARY
condition|)
name|value
operator|=
name|build_complex
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|lex_string
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|,
name|wide
parameter_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|int
name|wide
decl_stmt|;
block|{
name|tree
name|value
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
operator|(
name|wide
condition|?
name|WCHAR_BYTES
else|:
literal|1
operator|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|q
init|=
name|buf
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
name|str
decl_stmt|,
modifier|*
name|limit
init|=
name|str
operator|+
name|len
decl_stmt|;
name|cppchar_t
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
comment|/* Reset multibyte conversion state.  */
operator|(
name|void
operator|)
name|local_mbtowc
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|p
operator|<
name|limit
condition|)
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|wchar_t
name|wc
decl_stmt|;
name|int
name|char_len
decl_stmt|;
name|char_len
operator|=
name|local_mbtowc
argument_list|(
operator|&
name|wc
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
argument_list|,
name|limit
operator|-
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|char_len
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"ignoring invalid multibyte character"
argument_list|)
expr_stmt|;
name|char_len
operator|=
literal|1
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
name|p
operator|+=
name|char_len
expr_stmt|;
name|c
operator|=
name|wc
expr_stmt|;
block|}
else|#
directive|else
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
operator|!
name|ignore_escape_flag
condition|)
name|c
operator|=
name|cpp_parse_escape
argument_list|(
name|parse_in
argument_list|,
operator|&
name|p
argument_list|,
name|limit
argument_list|,
name|wide
argument_list|)
expr_stmt|;
comment|/* Add this single character into the buffer either as a wchar_t, 	 a multibyte sequence, or as a single byte.  */
if|if
condition|(
name|wide
condition|)
block|{
name|unsigned
name|charwidth
init|=
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
decl_stmt|;
name|unsigned
name|bytemask
init|=
operator|(
literal|1
operator|<<
name|charwidth
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|byte
decl_stmt|;
for|for
control|(
name|byte
operator|=
literal|0
init|;
name|byte
operator|<
name|WCHAR_BYTES
condition|;
operator|++
name|byte
control|)
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|byte
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|c
argument_list|)
condition|)
name|n
operator|=
literal|0
expr_stmt|;
else|else
name|n
operator|=
operator|(
name|c
operator|>>
operator|(
name|byte
operator|*
name|charwidth
operator|)
operator|)
operator|&
name|bytemask
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|q
index|[
name|WCHAR_BYTES
operator|-
name|byte
operator|-
literal|1
index|]
operator|=
name|n
expr_stmt|;
else|else
name|q
index|[
name|byte
index|]
operator|=
name|n
expr_stmt|;
block|}
name|q
operator|+=
name|WCHAR_BYTES
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
elseif|else
if|if
condition|(
name|char_len
operator|>
literal|1
condition|)
block|{
comment|/* We're dealing with a multibyte character.  */
for|for
control|(
init|;
name|char_len
operator|>
literal|0
condition|;
operator|--
name|char_len
control|)
block|{
operator|*
name|q
operator|++
operator|=
operator|*
operator|(
name|p
operator|-
name|char_len
operator|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
else|else
block|{
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
comment|/* Terminate the string value, either with a single byte zero      or with a wide zero.  */
if|if
condition|(
name|wide
condition|)
block|{
name|memset
argument_list|(
name|q
argument_list|,
literal|0
argument_list|,
name|WCHAR_BYTES
argument_list|)
expr_stmt|;
name|q
operator|+=
name|WCHAR_BYTES
expr_stmt|;
block|}
else|else
block|{
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
name|value
operator|=
name|build_string
argument_list|(
name|q
operator|-
name|buf
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|wide
condition|)
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|wchar_array_type_node
expr_stmt|;
else|else
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|char_array_type_node
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Converts a (possibly wide) character constant token into a tree.  */
end_comment

begin_function
specifier|static
name|tree
name|lex_charconst
parameter_list|(
name|token
parameter_list|)
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
block|{
name|cppchar_t
name|result
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|value
decl_stmt|;
name|unsigned
name|int
name|chars_seen
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|result
operator|=
name|cpp_interpret_charconst
argument_list|(
name|parse_in
argument_list|,
name|token
argument_list|,
operator|&
name|chars_seen
argument_list|,
operator|&
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* Cast to cppchar_signed_t to get correct sign-extension of RESULT      before possibly widening to HOST_WIDE_INT for build_int_2.  */
if|if
condition|(
name|unsignedp
operator|||
operator|(
name|cppchar_signed_t
operator|)
name|result
operator|>=
literal|0
condition|)
name|value
operator|=
name|build_int_2
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|build_int_2
argument_list|(
operator|(
name|cppchar_signed_t
operator|)
name|result
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_WCHAR
condition|)
name|type
operator|=
name|wchar_type_node
expr_stmt|;
comment|/* In C, a character constant has type 'int'.      In C++ 'char', but multi-char charconsts have type 'int'.  */
elseif|else
if|if
condition|(
operator|(
name|c_language
operator|==
name|clk_c
operator|)
operator|||
name|chars_seen
operator|>
literal|1
condition|)
name|type
operator|=
name|integer_type_node
expr_stmt|;
else|else
name|type
operator|=
name|char_type_node
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

end_unit

