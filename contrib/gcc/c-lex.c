begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Lexical analyzer for C and Objective C.    Copyright (C) 1987, 88, 89, 92, 94-97, 1998 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"c-lex.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"c-parse.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_comment
comment|/* MULTIBYTE_CHARS support only works for native compilers.    ??? Ideally what we want is to model widechar support after    the current floating point support.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CROSS_COMPILE
end_ifdef

begin_undef
undef|#
directive|undef
name|MULTIBYTE_CHARS
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
end_ifdef

begin_include
include|#
directive|include
file|"mbchar.h"
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MULTIBYTE_CHARS */
end_comment

begin_if
if|#
directive|if
name|USE_CPPLIB
end_if

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_decl_stmt
specifier|extern
name|cpp_reader
name|parse_in
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|cpp_options
name|parse_options
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Stream for reading from the input file.  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|finput
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|void
name|yyprint
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|YYSTYPE
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The elements of `ridpointers' are identifier nodes    for the reserved type names and storage classes.    It is indexed by a RID_... value.  */
end_comment

begin_decl_stmt
name|tree
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cause the `yydebug' variable to be defined.  */
end_comment

begin_define
define|#
directive|define
name|YYDEBUG
value|1
end_define

begin_if
if|#
directive|if
name|USE_CPPLIB
end_if

begin_decl_stmt
specifier|extern
name|unsigned
name|char
modifier|*
name|yy_cur
decl_stmt|,
modifier|*
name|yy_lim
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|yy_get_token
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|GETC
parameter_list|()
value|(yy_cur< yy_lim ? *yy_cur++ : yy_get_token ())
end_define

begin_define
define|#
directive|define
name|UNGETC
parameter_list|(
name|c
parameter_list|)
value|((c) == EOF ? 0 : yy_cur--)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GETC
parameter_list|()
value|getc (finput)
end_define

begin_define
define|#
directive|define
name|UNGETC
parameter_list|(
name|c
parameter_list|)
value|ungetc (c, finput)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* the declaration found for the last IDENTIFIER token read in.    yylex must look this up to detect typedefs, which get token type TYPENAME,    so it is left around in case the identifier is not a typedef but is    used in a context which makes it a reference to a variable.  */
end_comment

begin_decl_stmt
name|tree
name|lastiddecl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero enables objc features.  */
end_comment

begin_decl_stmt
name|int
name|doing_objc_thang
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|yydebug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File used for outputting assembler code.  */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|WCHAR_TYPE_SIZE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|INT_TYPE_SIZE
end_ifdef

begin_define
define|#
directive|define
name|WCHAR_TYPE_SIZE
value|INT_TYPE_SIZE
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|WCHAR_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of bytes in a wide character.  */
end_comment

begin_define
define|#
directive|define
name|WCHAR_BYTES
value|(WCHAR_TYPE_SIZE / BITS_PER_UNIT)
end_define

begin_decl_stmt
specifier|static
name|int
name|maxtoken
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current nominal length of token buffer.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|token_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to token buffer. 			   Actual allocated length is maxtoken + 2. 			   This is not static because objc-parse.y uses it.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|indent_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of { minus number of }. */
end_comment

begin_comment
comment|/* Nonzero if end-of-file has been seen on input.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|end_of_file
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|USE_CPPLIB
end_if

begin_comment
comment|/* Buffered-back input character; faster than using ungetc.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nextchar
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HANDLE_GENERIC_PRAGMAS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|handle_generic_pragma
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HANDLE_GENERIC_PRAGMAS */
end_comment

begin_decl_stmt
specifier|static
name|int
name|whitespace_cr
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|skip_white_space
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|skip_white_space_on_line
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|extend_token_buffer
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|readescape
name|PROTO
argument_list|(
operator|(
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parse_float
name|PROTO
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Do not insert generated code into the source, instead, include it.    This allows us to build gcc automatically even for targets that    need to add or modify the reserved keyword lists.  */
end_comment

begin_include
include|#
directive|include
file|"c-gperf.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Return something to represent absolute declarators containing a *.    TARGET is the absolute declarator that the * contains.    TYPE_QUALS is a list of modifiers such as const or volatile    to apply to the pointer type, represented as identifiers.     We return an INDIRECT_REF whose "contents" are TARGET    and whose type is the modifier list.  */
end_comment

begin_function
name|tree
name|make_pointer_declarator
parameter_list|(
name|type_quals
parameter_list|,
name|target
parameter_list|)
name|tree
name|type_quals
decl_stmt|,
name|target
decl_stmt|;
block|{
return|return
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type_quals
argument_list|,
name|target
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|forget_protocol_qualifiers
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|n
init|=
sizeof|sizeof
name|wordlist
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|resword
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|int
operator|)
name|wordlist
index|[
name|i
index|]
operator|.
name|rid
operator|>=
operator|(
name|int
operator|)
name|RID_IN
operator|&&
operator|(
name|int
operator|)
name|wordlist
index|[
name|i
index|]
operator|.
name|rid
operator|<=
operator|(
name|int
operator|)
name|RID_ONEWAY
condition|)
name|wordlist
index|[
name|i
index|]
operator|.
name|name
operator|=
literal|""
expr_stmt|;
block|}
end_function

begin_function
name|void
name|remember_protocol_qualifiers
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|n
init|=
sizeof|sizeof
name|wordlist
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|resword
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|wordlist
index|[
name|i
index|]
operator|.
name|rid
operator|==
name|RID_IN
condition|)
name|wordlist
index|[
name|i
index|]
operator|.
name|name
operator|=
literal|"in"
expr_stmt|;
elseif|else
if|if
condition|(
name|wordlist
index|[
name|i
index|]
operator|.
name|rid
operator|==
name|RID_OUT
condition|)
name|wordlist
index|[
name|i
index|]
operator|.
name|name
operator|=
literal|"out"
expr_stmt|;
elseif|else
if|if
condition|(
name|wordlist
index|[
name|i
index|]
operator|.
name|rid
operator|==
name|RID_INOUT
condition|)
name|wordlist
index|[
name|i
index|]
operator|.
name|name
operator|=
literal|"inout"
expr_stmt|;
elseif|else
if|if
condition|(
name|wordlist
index|[
name|i
index|]
operator|.
name|rid
operator|==
name|RID_BYCOPY
condition|)
name|wordlist
index|[
name|i
index|]
operator|.
name|name
operator|=
literal|"bycopy"
expr_stmt|;
elseif|else
if|if
condition|(
name|wordlist
index|[
name|i
index|]
operator|.
name|rid
operator|==
name|RID_BYREF
condition|)
name|wordlist
index|[
name|i
index|]
operator|.
name|name
operator|=
literal|"byref"
expr_stmt|;
elseif|else
if|if
condition|(
name|wordlist
index|[
name|i
index|]
operator|.
name|rid
operator|==
name|RID_ONEWAY
condition|)
name|wordlist
index|[
name|i
index|]
operator|.
name|name
operator|=
literal|"oneway"
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|char
modifier|*
name|init_parse
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
if|#
directive|if
operator|!
name|USE_CPPLIB
comment|/* Open input file.  */
if|if
condition|(
name|filename
operator|==
literal|0
operator|||
operator|!
name|strcmp
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|finput
operator|=
name|stdin
expr_stmt|;
name|filename
operator|=
literal|"stdin"
expr_stmt|;
block|}
else|else
name|finput
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|finput
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IO_BUFFER_SIZE
name|setvbuf
argument_list|(
name|finput
argument_list|,
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|IO_BUFFER_SIZE
argument_list|)
argument_list|,
name|_IOFBF
argument_list|,
name|IO_BUFFER_SIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* !USE_CPPLIB */
name|parse_in
operator|.
name|show_column
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|cpp_start_read
argument_list|(
operator|&
name|parse_in
argument_list|,
name|filename
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|filename
operator|==
literal|0
operator|||
operator|!
name|strcmp
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
condition|)
name|filename
operator|=
literal|"stdin"
expr_stmt|;
comment|/* cpp_start_read always puts at least one line directive into the      token buffer.  We must arrange to read it out here. */
name|yy_cur
operator|=
name|parse_in
operator|.
name|token_buffer
expr_stmt|;
name|yy_lim
operator|=
name|CPP_PWRITTEN
argument_list|(
operator|&
name|parse_in
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|init_lex
argument_list|()
expr_stmt|;
return|return
name|filename
return|;
block|}
end_function

begin_function
name|void
name|finish_parse
parameter_list|()
block|{
if|#
directive|if
name|USE_CPPLIB
name|cpp_finish
argument_list|(
operator|&
name|parse_in
argument_list|)
expr_stmt|;
else|#
directive|else
name|fclose
argument_list|(
name|finput
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|init_lex
parameter_list|()
block|{
comment|/* Make identifier nodes long enough for the language-specific slots.  */
name|set_identifier_size
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lang_identifier
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start it at 0, because check_newline is called at the very beginning      and will increment it to 1.  */
name|lineno
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
comment|/* Change to the native locale for multibyte conversions.  */
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|literal_codeset
operator|=
name|getenv
argument_list|(
literal|"LANG"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|maxtoken
operator|=
literal|40
expr_stmt|;
name|token_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|maxtoken
operator|+
literal|2
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
operator|=
name|get_identifier
argument_list|(
literal|"int"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"char"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOID
index|]
operator|=
name|get_identifier
argument_list|(
literal|"void"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_FLOAT
index|]
operator|=
name|get_identifier
argument_list|(
literal|"float"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_DOUBLE
index|]
operator|=
name|get_identifier
argument_list|(
literal|"double"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_SHORT
index|]
operator|=
name|get_identifier
argument_list|(
literal|"short"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_LONG
index|]
operator|=
name|get_identifier
argument_list|(
literal|"long"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_UNSIGNED
index|]
operator|=
name|get_identifier
argument_list|(
literal|"unsigned"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_SIGNED
index|]
operator|=
name|get_identifier
argument_list|(
literal|"signed"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INLINE
index|]
operator|=
name|get_identifier
argument_list|(
literal|"inline"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CONST
index|]
operator|=
name|get_identifier
argument_list|(
literal|"const"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_RESTRICT
index|]
operator|=
name|get_identifier
argument_list|(
literal|"restrict"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
operator|=
name|get_identifier
argument_list|(
literal|"volatile"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_AUTO
index|]
operator|=
name|get_identifier
argument_list|(
literal|"auto"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
operator|=
name|get_identifier
argument_list|(
literal|"static"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
operator|=
name|get_identifier
argument_list|(
literal|"extern"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_TYPEDEF
index|]
operator|=
name|get_identifier
argument_list|(
literal|"typedef"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_REGISTER
index|]
operator|=
name|get_identifier
argument_list|(
literal|"register"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_ITERATOR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"iterator"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_COMPLEX
index|]
operator|=
name|get_identifier
argument_list|(
literal|"complex"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_ID
index|]
operator|=
name|get_identifier
argument_list|(
literal|"id"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_IN
index|]
operator|=
name|get_identifier
argument_list|(
literal|"in"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_OUT
index|]
operator|=
name|get_identifier
argument_list|(
literal|"out"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INOUT
index|]
operator|=
name|get_identifier
argument_list|(
literal|"inout"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_BYCOPY
index|]
operator|=
name|get_identifier
argument_list|(
literal|"bycopy"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_BYREF
index|]
operator|=
name|get_identifier
argument_list|(
literal|"byref"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_ONEWAY
index|]
operator|=
name|get_identifier
argument_list|(
literal|"oneway"
argument_list|)
expr_stmt|;
name|forget_protocol_qualifiers
argument_list|()
expr_stmt|;
comment|/* Some options inhibit certain reserved words.      Clear those words out of the hash table so they won't be recognized.  */
define|#
directive|define
name|UNSET_RESERVED_WORD
parameter_list|(
name|STRING
parameter_list|)
define|\
value|do { struct resword *s = is_reserved_word (STRING, sizeof (STRING) - 1); \        if (s) s->name = ""; } while (0)
if|if
condition|(
operator|!
name|doing_objc_thang
condition|)
name|UNSET_RESERVED_WORD
argument_list|(
literal|"id"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_traditional
condition|)
block|{
name|UNSET_RESERVED_WORD
argument_list|(
literal|"const"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"restrict"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"volatile"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"typeof"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"signed"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"inline"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"iterator"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"complex"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|flag_isoc9x
condition|)
name|UNSET_RESERVED_WORD
argument_list|(
literal|"restrict"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_no_asm
condition|)
block|{
name|UNSET_RESERVED_WORD
argument_list|(
literal|"asm"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"typeof"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"inline"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"iterator"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"complex"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|reinit_parse_for_function
parameter_list|()
block|{ }
end_function

begin_escape
end_escape

begin_comment
comment|/* Function used when yydebug is set, to print a token in more detail.  */
end_comment

begin_function
name|void
name|yyprint
parameter_list|(
name|file
parameter_list|,
name|yychar
parameter_list|,
name|yylval
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|yychar
decl_stmt|;
name|YYSTYPE
name|yylval
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
switch|switch
condition|(
name|yychar
condition|)
block|{
case|case
name|IDENTIFIER
case|:
case|case
name|TYPENAME
case|:
case|case
name|OBJECTNAME
case|:
name|t
operator|=
name|yylval
operator|.
name|ttype
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONSTANT
case|:
name|t
operator|=
name|yylval
operator|.
name|ttype
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
name|HOST_BITS_PER_INT
literal|" 0x%x%016x"
argument_list|,
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
name|HOST_BITS_PER_LONG
literal|" 0x%lx%016lx"
argument_list|,
else|#
directive|else
literal|" 0x%llx%016llx"
argument_list|,
endif|#
directive|endif
endif|#
directive|endif
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|!=
name|HOST_BITS_PER_INT
literal|" 0x%lx%08lx"
argument_list|,
else|#
directive|else
literal|" 0x%x%08x"
argument_list|,
endif|#
directive|endif
endif|#
directive|endif
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Iff C is a carriage return, warn about it - if appropriate -    and return nonzero.  */
end_comment

begin_function
specifier|static
name|int
name|whitespace_cr
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
specifier|static
name|int
name|newline_warning
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
block|{
comment|/* ANSI C says the effects of a carriage return in a source file 	 are undefined.  */
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|newline_warning
condition|)
block|{
name|warning
argument_list|(
literal|"carriage return in source file"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"(we only warn about the first carriage return)"
argument_list|)
expr_stmt|;
name|newline_warning
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If C is not whitespace, return C.    Otherwise skip whitespace and return first nonwhite char read.  */
end_comment

begin_function
specifier|static
name|int
name|skip_white_space
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* We don't recognize comments here, because 	     cpp output can include / and * consecutively as operators. 	     Also, there's no need, since cpp removes all comments.  */
case|case
literal|'\n'
case|:
name|c
operator|=
name|check_newline
argument_list|()
expr_stmt|;
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\v'
case|:
case|case
literal|'\b'
case|:
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|whitespace_cr
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
else|else
name|error
argument_list|(
literal|"stray '\\' in program"
argument_list|)
expr_stmt|;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|c
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Skips all of the white space at the current location in the input file.    Must use and reset nextchar if it has the next character.  */
end_comment

begin_function
name|void
name|position_after_white_space
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
if|#
directive|if
operator|!
name|USE_CPPLIB
if|if
condition|(
name|nextchar
operator|!=
operator|-
literal|1
condition|)
name|c
operator|=
name|nextchar
operator|,
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
else|else
endif|#
directive|endif
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
name|UNGETC
argument_list|(
name|skip_white_space
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like skip_white_space, but don't advance beyond the end of line.    Moreover, we don't get passed a character to start with.  */
end_comment

begin_function
specifier|static
name|int
name|skip_white_space_on_line
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
default|default:
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\v'
case|:
case|case
literal|'\b'
case|:
continue|continue;
case|case
literal|'\r'
case|:
name|whitespace_cr
argument_list|(
name|c
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Make the token buffer longer, preserving the data in it.    P should point to just beyond the last valid character in the old buffer.    The value we return is a pointer to the new buffer    at a place corresponding to P.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|extend_token_buffer
parameter_list|(
name|p
parameter_list|)
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|offset
init|=
name|p
operator|-
name|token_buffer
decl_stmt|;
name|maxtoken
operator|=
name|maxtoken
operator|*
literal|2
operator|+
literal|10
expr_stmt|;
name|token_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|token_buffer
argument_list|,
name|maxtoken
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
name|token_buffer
operator|+
name|offset
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
name|HANDLE_PRAGMA
end_if

begin_comment
comment|/* Local versions of these macros, that can be passed as function pointers.  */
end_comment

begin_function
specifier|static
name|int
name|pragma_getc
parameter_list|()
block|{
return|return
name|GETC
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pragma_ungetc
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
name|UNGETC
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* At the beginning of a line, increment the line number    and process any #-directive on this line.    If the line is a #-directive, read the entire line and return a newline.    Otherwise, return the line's first non-whitespace character.  */
end_comment

begin_function
name|int
name|check_newline
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|token
decl_stmt|;
name|lineno
operator|++
expr_stmt|;
comment|/* Read first nonwhite char on the line.  */
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'#'
condition|)
block|{
comment|/* If not #, return it so caller will use it.  */
return|return
name|c
return|;
block|}
comment|/* Read first nonwhite char after the `#'.  */
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
comment|/* If a letter follows, then if the word here is `line', skip      it and ignore it; otherwise, ignore the line, with an error      if the word isn't `pragma', `ident', `define', or `undef'.  */
if|if
condition|(
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'p'
condition|)
block|{
if|if
condition|(
name|GETC
argument_list|()
operator|==
literal|'r'
operator|&&
name|GETC
argument_list|()
operator|==
literal|'a'
operator|&&
name|GETC
argument_list|()
operator|==
literal|'g'
operator|&&
name|GETC
argument_list|()
operator|==
literal|'m'
operator|&&
name|GETC
argument_list|()
operator|==
literal|'a'
operator|&&
operator|(
operator|(
name|c
operator|=
name|GETC
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|whitespace_cr
argument_list|(
name|c
argument_list|)
operator|)
condition|)
block|{
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|whitespace_cr
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
name|c
return|;
if|#
directive|if
name|defined
name|HANDLE_PRAGMA
operator|||
name|defined
name|HANDLE_GENERIC_PRAGMAS
name|UNGETC
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|token
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|IDENTIFIER
condition|)
goto|goto
name|skipline
goto|;
endif|#
directive|endif
comment|/* HANDLE_PRAGMA || HANDLE_GENERIC_PRAGMAS */
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA
comment|/* We invoke HANDLE_PRAGMA before HANDLE_GENERIC_PRAGMAS (if 		 both are defined), in order to give the back end a chance to 		 override the interpretation of generic style pragmas.  */
if|#
directive|if
operator|!
name|USE_CPPLIB
if|if
condition|(
name|nextchar
operator|>=
literal|0
condition|)
block|{
name|c
operator|=
name|nextchar
operator|,
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
name|UNGETC
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !USE_CPPLIB */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
goto|goto
name|skipline
goto|;
if|if
condition|(
name|HANDLE_PRAGMA
argument_list|(
name|pragma_getc
argument_list|,
name|pragma_ungetc
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
condition|)
return|return
name|GETC
argument_list|()
return|;
endif|#
directive|endif
comment|/* HANDLE_PRAGMA */
ifdef|#
directive|ifdef
name|HANDLE_GENERIC_PRAGMAS
if|if
condition|(
name|handle_generic_pragma
argument_list|(
name|token
argument_list|)
condition|)
return|return
name|GETC
argument_list|()
return|;
endif|#
directive|endif
comment|/* HANDLE_GENERIC_PRAGMAS */
comment|/* Issue a warning message if we have been asked to do so. 		 Ignoring unknown pragmas in system header file unless 		 an explcit -Wunknown-pragmas has been given. */
if|if
condition|(
name|warn_unknown_pragmas
operator|>
literal|1
operator|||
operator|(
name|warn_unknown_pragmas
operator|&&
operator|!
name|in_system_header
operator|)
condition|)
name|warning
argument_list|(
literal|"ignoring pragma: %s"
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'d'
condition|)
block|{
if|if
condition|(
name|GETC
argument_list|()
operator|==
literal|'e'
operator|&&
name|GETC
argument_list|()
operator|==
literal|'f'
operator|&&
name|GETC
argument_list|()
operator|==
literal|'i'
operator|&&
name|GETC
argument_list|()
operator|==
literal|'n'
operator|&&
name|GETC
argument_list|()
operator|==
literal|'e'
operator|&&
operator|(
operator|(
name|c
operator|=
name|GETC
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|debug_define
argument_list|(
name|lineno
argument_list|,
name|GET_DIRECTIVE_LINE
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'u'
condition|)
block|{
if|if
condition|(
name|GETC
argument_list|()
operator|==
literal|'n'
operator|&&
name|GETC
argument_list|()
operator|==
literal|'d'
operator|&&
name|GETC
argument_list|()
operator|==
literal|'e'
operator|&&
name|GETC
argument_list|()
operator|==
literal|'f'
operator|&&
operator|(
operator|(
name|c
operator|=
name|GETC
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|debug_undef
argument_list|(
name|lineno
argument_list|,
name|GET_DIRECTIVE_LINE
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'l'
condition|)
block|{
if|if
condition|(
name|GETC
argument_list|()
operator|==
literal|'i'
operator|&&
name|GETC
argument_list|()
operator|==
literal|'n'
operator|&&
name|GETC
argument_list|()
operator|==
literal|'e'
operator|&&
operator|(
operator|(
name|c
operator|=
name|GETC
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
goto|goto
name|linenum
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'i'
condition|)
block|{
if|if
condition|(
name|GETC
argument_list|()
operator|==
literal|'d'
operator|&&
name|GETC
argument_list|()
operator|==
literal|'e'
operator|&&
name|GETC
argument_list|()
operator|==
literal|'n'
operator|&&
name|GETC
argument_list|()
operator|==
literal|'t'
operator|&&
operator|(
operator|(
name|c
operator|=
name|GETC
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
block|{
comment|/* #ident.  The pedantic warning is now in cccp.c.  */
comment|/* Here we have just seen `#ident '. 		 A string constant should follow.  */
name|c
operator|=
name|skip_white_space_on_line
argument_list|()
expr_stmt|;
comment|/* If no argument, ignore the line.  */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
name|c
return|;
name|UNGETC
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|token
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
operator|||
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"invalid #ident"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
if|if
condition|(
operator|!
name|flag_no_ident
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_IDENT
name|ASM_OUTPUT_IDENT
argument_list|(
name|asm_out_file
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Skip the rest of this line.  */
goto|goto
name|skipline
goto|;
block|}
block|}
name|error
argument_list|(
literal|"undefined or invalid # directive"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
name|linenum
label|:
comment|/* Here we have either `#line' or `#<nonletter>'.      In either case, it should be a line number; a digit should follow.  */
comment|/* Can't use skip_white_space here, but must handle all whitespace      that is not '\n', lest we get a recursion for '\r' '\n' when      calling yylex.  */
name|UNGETC
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|skip_white_space_on_line
argument_list|()
expr_stmt|;
comment|/* If the # is the only nonwhite char on the line,      just ignore it.  Check the new newline.  */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
name|c
return|;
comment|/* Something follows the #; read a token.  */
name|UNGETC
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|token
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|CONSTANT
operator|&&
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|int
name|old_lineno
init|=
name|lineno
decl_stmt|;
name|int
name|used_up
init|=
literal|0
decl_stmt|;
comment|/* subtract one, because it is the following line that 	 gets the specified number */
name|int
name|l
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|-
literal|1
decl_stmt|;
comment|/* Is this the last nonwhite stuff on the line?  */
name|c
operator|=
name|skip_white_space_on_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* No more: store the line number and check following line.  */
name|lineno
operator|=
name|l
expr_stmt|;
return|return
name|c
return|;
block|}
name|UNGETC
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* More follows: it must be a string constant (filename).  */
comment|/* Read the string constant.  */
name|token
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
operator|||
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"invalid #line"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
name|input_filename
operator|=
operator|(
name|char
operator|*
operator|)
name|permalloc
argument_list|(
name|TREE_STRING_LENGTH
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|input_filename
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|l
expr_stmt|;
comment|/* Each change of file name 	 reinitializes whether we are now in a system header.  */
name|in_system_header
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|main_input_filename
operator|==
literal|0
condition|)
name|main_input_filename
operator|=
name|input_filename
expr_stmt|;
comment|/* Is this the last nonwhite stuff on the line?  */
name|c
operator|=
name|skip_white_space_on_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* Update the name in the top element of input_file_stack.  */
if|if
condition|(
name|input_file_stack
condition|)
name|input_file_stack
operator|->
name|name
operator|=
name|input_filename
expr_stmt|;
return|return
name|c
return|;
block|}
name|UNGETC
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|token
operator|=
name|yylex
argument_list|()
expr_stmt|;
name|used_up
operator|=
literal|0
expr_stmt|;
comment|/* `1' after file name means entering new file. 	 `2' after file name means just left a file.  */
if|if
condition|(
name|token
operator|==
name|CONSTANT
operator|&&
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* Pushing to a new file.  */
name|struct
name|file_stack
modifier|*
name|p
init|=
operator|(
expr|struct
name|file_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_stack
argument_list|)
argument_list|)
decl_stmt|;
name|input_file_stack
operator|->
name|line
operator|=
name|old_lineno
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|input_file_stack
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|input_filename
expr_stmt|;
name|p
operator|->
name|indent_level
operator|=
name|indent_level
expr_stmt|;
name|input_file_stack
operator|=
name|p
expr_stmt|;
name|input_file_stack_tick
operator|++
expr_stmt|;
name|debug_start_source_file
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|used_up
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
literal|2
condition|)
block|{
comment|/* Popping out of a file.  */
if|if
condition|(
name|input_file_stack
operator|->
name|next
condition|)
block|{
name|struct
name|file_stack
modifier|*
name|p
init|=
name|input_file_stack
decl_stmt|;
if|if
condition|(
name|indent_level
operator|!=
name|p
operator|->
name|indent_level
condition|)
block|{
name|warning_with_file_and_line
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|old_lineno
argument_list|,
literal|"This file contains more `%c's than `%c's."
argument_list|,
name|indent_level
operator|>
name|p
operator|->
name|indent_level
condition|?
literal|'{'
else|:
literal|'}'
argument_list|,
name|indent_level
operator|>
name|p
operator|->
name|indent_level
condition|?
literal|'}'
else|:
literal|'{'
argument_list|)
expr_stmt|;
block|}
name|input_file_stack
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|input_file_stack_tick
operator|++
expr_stmt|;
name|debug_end_source_file
argument_list|(
name|input_file_stack
operator|->
name|line
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"#-lines for entering and leaving files don't match"
argument_list|)
expr_stmt|;
name|used_up
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Now that we've pushed or popped the input stack, 	 update the name in the top element.  */
if|if
condition|(
name|input_file_stack
condition|)
name|input_file_stack
operator|->
name|name
operator|=
name|input_filename
expr_stmt|;
comment|/* If we have handled a `1' or a `2', 	 see if there is another number to read.  */
if|if
condition|(
name|used_up
condition|)
block|{
comment|/* Is this the last nonwhite stuff on the line?  */
name|c
operator|=
name|skip_white_space_on_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
name|c
return|;
name|UNGETC
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|token
operator|=
name|yylex
argument_list|()
expr_stmt|;
name|used_up
operator|=
literal|0
expr_stmt|;
block|}
comment|/* `3' after file name means this is a system header file.  */
if|if
condition|(
name|token
operator|==
name|CONSTANT
operator|&&
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
literal|3
condition|)
name|in_system_header
operator|=
literal|1
operator|,
name|used_up
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|used_up
condition|)
block|{
comment|/* Is this the last nonwhite stuff on the line?  */
name|c
operator|=
name|skip_white_space_on_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
name|c
return|;
name|UNGETC
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|warning
argument_list|(
literal|"unrecognized text at end of #line"
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"invalid #-line"
argument_list|)
expr_stmt|;
comment|/* skip the rest of this line.  */
name|skipline
label|:
if|#
directive|if
operator|!
name|USE_CPPLIB
if|if
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
operator|&&
name|nextchar
operator|>=
literal|0
condition|)
name|c
operator|=
name|nextchar
operator|,
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HANDLE_GENERIC_PRAGMAS
end_ifdef

begin_comment
comment|/* Handle a #pragma directive.    TOKEN is the token we read after `#pragma'.  Processes the entire input    line and return non-zero iff the pragma has been successfully parsed.  */
end_comment

begin_comment
comment|/* This function has to be in this file, in order to get at    the token types.  */
end_comment

begin_function
specifier|static
name|int
name|handle_generic_pragma
parameter_list|(
name|token
parameter_list|)
specifier|register
name|int
name|token
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|IDENTIFIER
case|:
case|case
name|TYPENAME
case|:
case|case
name|STRING
case|:
case|case
name|CONSTANT
case|:
name|handle_pragma_token
argument_list|(
name|token_buffer
argument_list|,
name|yylval
operator|.
name|ttype
argument_list|)
expr_stmt|;
break|break;
default|default:
name|handle_pragma_token
argument_list|(
name|token_buffer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|USE_CPPLIB
if|if
condition|(
name|nextchar
operator|>=
literal|0
condition|)
name|c
operator|=
name|nextchar
operator|,
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
else|else
endif|#
directive|endif
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
name|UNGETC
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOF
condition|)
return|return
name|handle_pragma_token
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
name|token
operator|=
name|yylex
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HANDLE_GENERIC_PRAGMAS */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|ENDFILE
value|-1
end_define

begin_comment
comment|/* token that represents end-of-file */
end_comment

begin_comment
comment|/* Read an escape sequence, returning its equivalent as a character,    or store 1 in *ignore_ptr if it is backslash-newline.  */
end_comment

begin_function
specifier|static
name|int
name|readescape
parameter_list|(
name|ignore_ptr
parameter_list|)
name|int
modifier|*
name|ignore_ptr
decl_stmt|;
block|{
specifier|register
name|int
name|c
init|=
name|GETC
argument_list|()
decl_stmt|;
specifier|register
name|int
name|code
decl_stmt|;
specifier|register
name|unsigned
name|count
decl_stmt|;
name|unsigned
name|firstdig
init|=
literal|0
decl_stmt|;
name|int
name|nonnull
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'x'
case|:
if|if
condition|(
name|warn_traditional
condition|)
name|warning
argument_list|(
literal|"the meaning of `\\x' varies with -traditional"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_traditional
condition|)
return|return
name|c
return|;
name|code
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|nonnull
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
operator|)
operator|&&
operator|!
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
operator|)
operator|&&
operator|!
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|UNGETC
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
name|code
operator|*=
literal|16
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
name|code
operator|+=
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
condition|)
name|code
operator|+=
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|code
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0
operator|||
name|count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|firstdig
operator|=
name|code
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|nonnull
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nonnull
condition|)
name|error
argument_list|(
literal|"\\x used with no following hex digits"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|count
operator|==
literal|0
condition|)
comment|/* Digits are all 0's.  Ok.  */
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|4
operator|>=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|||
operator|(
name|count
operator|>
literal|1
operator|&&
operator|(
operator|(
operator|(
name|unsigned
operator|)
literal|1
operator|<<
operator|(
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|-
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|4
operator|)
operator|)
operator|<=
name|firstdig
operator|)
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"hex escape out of range"
argument_list|)
expr_stmt|;
return|return
name|code
return|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|code
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|<=
literal|'7'
operator|)
operator|&&
operator|(
name|c
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|count
operator|++
operator|<
literal|3
operator|)
condition|)
block|{
name|code
operator|=
operator|(
name|code
operator|*
literal|8
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
block|}
name|UNGETC
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|code
return|;
case|case
literal|'\\'
case|:
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
return|return
name|c
return|;
case|case
literal|'\n'
case|:
name|lineno
operator|++
expr_stmt|;
operator|*
name|ignore_ptr
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'n'
case|:
return|return
name|TARGET_NEWLINE
return|;
case|case
literal|'t'
case|:
return|return
name|TARGET_TAB
return|;
case|case
literal|'r'
case|:
return|return
name|TARGET_CR
return|;
case|case
literal|'f'
case|:
return|return
name|TARGET_FF
return|;
case|case
literal|'b'
case|:
return|return
name|TARGET_BS
return|;
case|case
literal|'a'
case|:
if|if
condition|(
name|warn_traditional
condition|)
name|warning
argument_list|(
literal|"the meaning of `\\a' varies with -traditional"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_traditional
condition|)
return|return
name|c
return|;
return|return
name|TARGET_BELL
return|;
case|case
literal|'v'
case|:
if|#
directive|if
literal|0
comment|/* Vertical tab is present in common usage compilers.  */
block|if (flag_traditional) 	return c;
endif|#
directive|endif
return|return
name|TARGET_VT
return|;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"non-ANSI-standard escape sequence, `\\%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
literal|033
return|;
case|case
literal|'?'
case|:
return|return
name|c
return|;
comment|/* `\(', etc, are used at beginning of line to avoid confusing Emacs.  */
case|case
literal|'('
case|:
case|case
literal|'{'
case|:
case|case
literal|'['
case|:
comment|/* `\%' is used to prevent SCCS from getting confused.  */
case|case
literal|'%'
case|:
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"non-ANSI escape sequence `\\%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
if|if
condition|(
name|c
operator|>=
literal|040
operator|&&
name|c
operator|<
literal|0177
condition|)
name|pedwarn
argument_list|(
literal|"unknown escape sequence `\\%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"unknown escape sequence: `\\' followed by char code 0x%x"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|yyerror
parameter_list|(
name|msgid
parameter_list|)
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|string
init|=
name|_
argument_list|(
name|msgid
argument_list|)
decl_stmt|;
comment|/* We can't print string and character constants well      because the token_buffer contains the result of processing escapes.  */
if|if
condition|(
name|end_of_file
condition|)
name|error
argument_list|(
literal|"%s at end of input"
argument_list|,
name|string
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|token_buffer
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"%s at null character"
argument_list|,
name|string
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|token_buffer
index|[
literal|0
index|]
operator|==
literal|'"'
condition|)
name|error
argument_list|(
literal|"%s before string constant"
argument_list|,
name|string
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|token_buffer
index|[
literal|0
index|]
operator|==
literal|'\''
condition|)
name|error
argument_list|(
literal|"%s before character constant"
argument_list|,
name|string
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|token_buffer
index|[
literal|0
index|]
operator|<
literal|040
operator|||
operator|(
name|unsigned
name|char
operator|)
name|token_buffer
index|[
literal|0
index|]
operator|>=
literal|0177
condition|)
name|error
argument_list|(
literal|"%s before character 0%o"
argument_list|,
name|string
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|token_buffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%s before `%s'"
argument_list|,
name|string
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|struct try_type {   tree *node_var;   char unsigned_flag;   char long_flag;   char long_long_flag; };  struct try_type type_sequence[] = {   {&integer_type_node, 0, 0, 0},   {&unsigned_type_node, 1, 0, 0},   {&long_integer_type_node, 0, 1, 0},   {&long_unsigned_type_node, 1, 1, 0},   {&long_long_integer_type_node, 0, 1, 1},   {&long_long_unsigned_type_node, 1, 1, 1} };
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_struct
struct|struct
name|pf_args
block|{
comment|/* Input */
name|int
name|base
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* I/O */
name|int
name|c
decl_stmt|;
name|int
name|imag
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|conversion_errno
decl_stmt|;
comment|/* Output */
name|REAL_VALUE_TYPE
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|parse_float
parameter_list|(
name|data
parameter_list|)
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|pf_args
modifier|*
name|args
init|=
operator|(
expr|struct
name|pf_args
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|fflag
init|=
literal|0
decl_stmt|,
name|lflag
init|=
literal|0
decl_stmt|;
comment|/* Copy token_buffer now, while it has just the number      and not the suffixes; once we add `f' or `i',      REAL_VALUE_ATOF may not work any more.  */
name|char
modifier|*
name|copy
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|args
operator|->
name|p
operator|-
name|token_buffer
operator|+
literal|1
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|token_buffer
argument_list|,
name|copy
argument_list|,
name|args
operator|->
name|p
operator|-
name|token_buffer
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|lose
init|=
literal|0
decl_stmt|;
comment|/* Read the suffixes to choose a data type.  */
switch|switch
condition|(
name|args
operator|->
name|c
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
if|if
condition|(
name|fflag
condition|)
name|error
argument_list|(
literal|"more than one `f' in numeric constant"
argument_list|)
expr_stmt|;
name|fflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
if|if
condition|(
name|lflag
condition|)
name|error
argument_list|(
literal|"more than one `l' in numeric constant"
argument_list|)
expr_stmt|;
name|lflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
if|if
condition|(
name|args
operator|->
name|imag
condition|)
name|error
argument_list|(
literal|"more than one `i' or `j' in numeric constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids imaginary numeric constants"
argument_list|)
expr_stmt|;
name|args
operator|->
name|imag
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|lose
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|lose
condition|)
break|break;
if|if
condition|(
name|args
operator|->
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|args
operator|->
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|args
operator|->
name|p
argument_list|)
expr_stmt|;
operator|*
operator|(
name|args
operator|->
name|p
operator|++
operator|)
operator|=
name|args
operator|->
name|c
expr_stmt|;
operator|*
operator|(
name|args
operator|->
name|p
operator|)
operator|=
literal|0
expr_stmt|;
name|args
operator|->
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
block|}
comment|/* The second argument, machine_mode, of REAL_VALUE_ATOF      tells the desired precision of the binary result      of decimal-to-binary conversion.  */
if|if
condition|(
name|fflag
condition|)
block|{
if|if
condition|(
name|lflag
condition|)
name|error
argument_list|(
literal|"both `f' and `l' in floating constant"
argument_list|)
expr_stmt|;
name|args
operator|->
name|type
operator|=
name|float_type_node
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|base
operator|==
literal|16
condition|)
name|args
operator|->
name|value
operator|=
name|REAL_VALUE_HTOF
argument_list|(
name|copy
argument_list|,
name|TYPE_MODE
argument_list|(
name|args
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|args
operator|->
name|value
operator|=
name|REAL_VALUE_ATOF
argument_list|(
name|copy
argument_list|,
name|TYPE_MODE
argument_list|(
name|args
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|->
name|conversion_errno
operator|=
name|errno
expr_stmt|;
comment|/* A diagnostic is required here by some ANSI C testsuites. 	 This is not pedwarn, because some people don't want 	 an error for this.  */
if|if
condition|(
name|REAL_VALUE_ISINF
argument_list|(
name|args
operator|->
name|value
argument_list|)
operator|&&
name|pedantic
condition|)
name|warning
argument_list|(
literal|"floating point number exceeds range of `float'"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lflag
condition|)
block|{
name|args
operator|->
name|type
operator|=
name|long_double_type_node
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|base
operator|==
literal|16
condition|)
name|args
operator|->
name|value
operator|=
name|REAL_VALUE_HTOF
argument_list|(
name|copy
argument_list|,
name|TYPE_MODE
argument_list|(
name|args
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|args
operator|->
name|value
operator|=
name|REAL_VALUE_ATOF
argument_list|(
name|copy
argument_list|,
name|TYPE_MODE
argument_list|(
name|args
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|->
name|conversion_errno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|REAL_VALUE_ISINF
argument_list|(
name|args
operator|->
name|value
argument_list|)
operator|&&
name|pedantic
condition|)
name|warning
argument_list|(
literal|"floating point number exceeds range of `long double'"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|base
operator|==
literal|16
condition|)
name|args
operator|->
name|value
operator|=
name|REAL_VALUE_HTOF
argument_list|(
name|copy
argument_list|,
name|TYPE_MODE
argument_list|(
name|args
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|args
operator|->
name|value
operator|=
name|REAL_VALUE_ATOF
argument_list|(
name|copy
argument_list|,
name|TYPE_MODE
argument_list|(
name|args
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|->
name|conversion_errno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|REAL_VALUE_ISINF
argument_list|(
name|args
operator|->
name|value
argument_list|)
operator|&&
name|pedantic
condition|)
name|warning
argument_list|(
literal|"floating point number exceeds range of `double'"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|yylex
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|value
decl_stmt|;
name|int
name|wide_flag
init|=
literal|0
decl_stmt|;
name|int
name|objc_flag
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|!
name|USE_CPPLIB
if|if
condition|(
name|nextchar
operator|>=
literal|0
condition|)
name|c
operator|=
name|nextchar
operator|,
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
else|else
endif|#
directive|endif
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
comment|/* Effectively do c = skip_white_space (c)      but do it faster in the usual cases.  */
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\v'
case|:
case|case
literal|'\b'
case|:
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
comment|/* Call skip_white_space so we can warn if appropriate.  */
case|case
literal|'\n'
case|:
case|case
literal|'/'
case|:
case|case
literal|'\\'
case|:
name|c
operator|=
name|skip_white_space
argument_list|(
name|c
argument_list|)
expr_stmt|;
default|default:
goto|goto
name|found_nonwhite
goto|;
block|}
name|found_nonwhite
label|:
name|token_buffer
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/*  yylloc.first_line = lineno; */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|EOF
case|:
name|end_of_file
operator|=
literal|1
expr_stmt|;
name|token_buffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|ENDFILE
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* Capital L may start a wide-string or wide-character constant.  */
block|{
specifier|register
name|int
name|c
init|=
name|GETC
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
block|{
name|wide_flag
operator|=
literal|1
expr_stmt|;
goto|goto
name|char_constant
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|wide_flag
operator|=
literal|1
expr_stmt|;
goto|goto
name|string_constant
goto|;
block|}
name|UNGETC
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
goto|goto
name|letter
goto|;
case|case
literal|'@'
case|:
if|if
condition|(
operator|!
name|doing_objc_thang
condition|)
block|{
name|value
operator|=
name|c
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* '@' may start a constant string object.  */
specifier|register
name|int
name|c
init|=
name|GETC
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|objc_flag
operator|=
literal|1
expr_stmt|;
goto|goto
name|string_constant
goto|;
block|}
name|UNGETC
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Fall through to treat '@' as the start of an identifier.  */
block|}
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'_'
case|:
case|case
literal|'$'
case|:
name|letter
label|:
name|p
operator|=
name|token_buffer
expr_stmt|;
while|while
condition|(
name|ISALNUM
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'$'
operator|||
name|c
operator|==
literal|'@'
condition|)
block|{
comment|/* Make sure this char really belongs in an identifier.  */
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
operator|!
name|dollars_in_ident
condition|)
name|error
argument_list|(
literal|"`$' in identifier"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"`$' in identifier"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|USE_CPPLIB
name|UNGETC
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|#
directive|else
name|nextchar
operator|=
name|c
expr_stmt|;
endif|#
directive|endif
name|value
operator|=
name|IDENTIFIER
expr_stmt|;
name|yylval
operator|.
name|itype
operator|=
literal|0
expr_stmt|;
comment|/* Try to recognize a keyword.  Uses minimum-perfect hash function */
block|{
specifier|register
name|struct
name|resword
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|is_reserved_word
argument_list|(
name|token_buffer
argument_list|,
name|p
operator|-
name|token_buffer
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ptr
operator|->
name|rid
condition|)
name|yylval
operator|.
name|ttype
operator|=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|ptr
operator|->
name|rid
index|]
expr_stmt|;
name|value
operator|=
operator|(
name|int
operator|)
name|ptr
operator|->
name|token
expr_stmt|;
comment|/* Only return OBJECTNAME if it is a typedef.  */
if|if
condition|(
name|doing_objc_thang
operator|&&
name|value
operator|==
name|OBJECTNAME
condition|)
block|{
name|lastiddecl
operator|=
name|lookup_name
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastiddecl
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|lastiddecl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
name|value
operator|=
name|IDENTIFIER
expr_stmt|;
block|}
comment|/* Even if we decided to recognize asm, still perhaps warn.  */
if|if
condition|(
name|pedantic
operator|&&
operator|(
name|value
operator|==
name|ASM_KEYWORD
operator|||
name|value
operator|==
name|TYPEOF
operator|||
name|ptr
operator|->
name|rid
operator|==
name|RID_INLINE
operator|)
operator|&&
name|token_buffer
index|[
literal|0
index|]
operator|!=
literal|'_'
condition|)
name|pedwarn
argument_list|(
literal|"ANSI does not permit the keyword `%s'"
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we did not find a keyword, look for an identifier 	 (or a typename).  */
if|if
condition|(
name|value
operator|==
name|IDENTIFIER
condition|)
block|{
if|if
condition|(
name|token_buffer
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
name|error
argument_list|(
literal|"invalid identifier `%s'"
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|get_identifier
argument_list|(
name|token_buffer
argument_list|)
expr_stmt|;
name|lastiddecl
operator|=
name|lookup_name
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastiddecl
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|lastiddecl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|value
operator|=
name|TYPENAME
expr_stmt|;
comment|/* A user-invisible read-only initialized variable 	     should be replaced by its value. 	     We handle only strings since that's the only case used in C.  */
elseif|else
if|if
condition|(
name|lastiddecl
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|lastiddecl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_IGNORED_P
argument_list|(
name|lastiddecl
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|lastiddecl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|lastiddecl
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|lastiddecl
argument_list|)
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
name|tree
name|stringval
init|=
name|DECL_INITIAL
argument_list|(
name|lastiddecl
argument_list|)
decl_stmt|;
comment|/* Copy the string value so that we won't clobber anything 		 if we put something in the TREE_CHAIN of this one.  */
name|yylval
operator|.
name|ttype
operator|=
name|build_string
argument_list|(
name|TREE_STRING_LENGTH
argument_list|(
name|stringval
argument_list|)
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|stringval
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|STRING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|doing_objc_thang
condition|)
block|{
name|tree
name|objc_interface_decl
init|=
name|is_class_name
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
decl_stmt|;
if|if
condition|(
name|objc_interface_decl
condition|)
block|{
name|value
operator|=
name|CLASSNAME
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|objc_interface_decl
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
block|{
name|int
name|next_c
decl_stmt|;
comment|/* Check first for common special case:  single-digit 0 or 1.  */
name|next_c
operator|=
name|GETC
argument_list|()
expr_stmt|;
name|UNGETC
argument_list|(
name|next_c
argument_list|)
expr_stmt|;
comment|/* Always undo this lookahead.  */
if|if
condition|(
operator|!
name|ISALNUM
argument_list|(
name|next_c
argument_list|)
operator|&&
name|next_c
operator|!=
literal|'.'
condition|)
block|{
name|token_buffer
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|c
operator|,
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
operator|(
name|c
operator|==
literal|'0'
operator|)
condition|?
name|integer_zero_node
else|:
name|integer_one_node
expr_stmt|;
name|value
operator|=
name|CONSTANT
expr_stmt|;
break|break;
block|}
comment|/*FALLTHRU*/
block|}
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'.'
case|:
block|{
name|int
name|base
init|=
literal|10
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|largest_digit
init|=
literal|0
decl_stmt|;
name|int
name|numdigits
init|=
literal|0
decl_stmt|;
comment|/* for multi-precision arithmetic, 	   we actually store only HOST_BITS_PER_CHAR bits in each part. 	   The number of parts is chosen so as to be sufficient to hold 	   the enough bits to fit into the two HOST_WIDE_INTs that contain 	   the integer value (this is always at least as many bits as are 	   in a target `long long' value, but may be wider).  */
define|#
directive|define
name|TOTAL_PARTS
value|((HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR) * 2 + 2)
name|int
name|parts
index|[
name|TOTAL_PARTS
index|]
decl_stmt|;
name|int
name|overflow
init|=
literal|0
decl_stmt|;
enum|enum
name|anon1
block|{
name|NOT_FLOAT
block|,
name|AFTER_POINT
block|,
name|TOO_MANY_POINTS
block|,
name|AFTER_EXPON
block|}
name|floatflag
init|=
name|NOT_FLOAT
enum|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|TOTAL_PARTS
condition|;
name|count
operator|++
control|)
name|parts
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|token_buffer
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
operator|(
name|c
operator|=
name|GETC
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'x'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'X'
operator|)
condition|)
block|{
name|base
operator|=
literal|16
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|c
operator|=
name|GETC
argument_list|()
operator|)
expr_stmt|;
block|}
comment|/* Leading 0 forces octal unless the 0 is the only digit.  */
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|base
operator|=
literal|8
expr_stmt|;
name|numdigits
operator|++
expr_stmt|;
block|}
else|else
name|numdigits
operator|++
expr_stmt|;
block|}
comment|/* Read all the digits-and-decimal-points.  */
while|while
condition|(
name|c
operator|==
literal|'.'
operator|||
operator|(
name|ISALNUM
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'l'
operator|&&
name|c
operator|!=
literal|'L'
operator|&&
name|c
operator|!=
literal|'u'
operator|&&
name|c
operator|!=
literal|'U'
operator|&&
name|c
operator|!=
literal|'i'
operator|&&
name|c
operator|!=
literal|'I'
operator|&&
name|c
operator|!=
literal|'j'
operator|&&
name|c
operator|!=
literal|'J'
operator|&&
operator|(
name|floatflag
operator|==
name|NOT_FLOAT
operator|||
operator|(
operator|(
name|c
operator|!=
literal|'f'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'F'
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|base
operator|==
literal|16
operator|&&
name|pedantic
condition|)
name|error
argument_list|(
literal|"floating constant may not be in radix 16"
argument_list|)
expr_stmt|;
if|if
condition|(
name|floatflag
operator|==
name|TOO_MANY_POINTS
condition|)
comment|/* We have already emitted an error.  Don't need another.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|floatflag
operator|==
name|AFTER_POINT
operator|||
name|floatflag
operator|==
name|AFTER_EXPON
condition|)
block|{
name|error
argument_list|(
literal|"malformed floating constant"
argument_list|)
expr_stmt|;
name|floatflag
operator|=
name|TOO_MANY_POINTS
expr_stmt|;
comment|/* Avoid another error from atof by forcing all characters 		       from here on to be ignored.  */
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|floatflag
operator|=
name|AFTER_POINT
expr_stmt|;
if|if
condition|(
name|base
operator|==
literal|8
condition|)
name|base
operator|=
literal|10
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
comment|/* Accept '.' as the start of a floating-point number 		   only when it is followed by a digit. 		   Otherwise, unread the following non-digit 		   and use the '.' as a structural token.  */
if|if
condition|(
name|p
operator|==
name|token_buffer
operator|+
literal|2
operator|&&
operator|!
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
name|ELLIPSIS
return|;
block|}
name|error
argument_list|(
literal|"parse error at `..'"
argument_list|)
expr_stmt|;
block|}
name|UNGETC
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|value
operator|=
literal|'.'
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
comment|/* It is not a decimal point. 		   It should be a digit (perhaps a hex digit).  */
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|c
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|base
operator|<=
literal|10
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
condition|)
block|{
name|base
operator|=
literal|10
expr_stmt|;
name|floatflag
operator|=
name|AFTER_EXPON
expr_stmt|;
break|break;
comment|/* start of exponent */
block|}
name|error
argument_list|(
literal|"nondigits in number and not hexadecimal"
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|base
operator|==
literal|16
operator|&&
operator|(
name|c
operator|==
literal|'p'
operator|||
name|c
operator|==
literal|'P'
operator|)
condition|)
block|{
name|floatflag
operator|=
name|AFTER_EXPON
expr_stmt|;
break|break;
comment|/* start of exponent */
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'a'
condition|)
block|{
name|c
operator|=
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|>=
name|largest_digit
condition|)
name|largest_digit
operator|=
name|c
expr_stmt|;
name|numdigits
operator|++
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|TOTAL_PARTS
condition|;
name|count
operator|++
control|)
block|{
name|parts
index|[
name|count
index|]
operator|*=
name|base
expr_stmt|;
if|if
condition|(
name|count
condition|)
block|{
name|parts
index|[
name|count
index|]
operator|+=
operator|(
name|parts
index|[
name|count
operator|-
literal|1
index|]
operator|>>
name|HOST_BITS_PER_CHAR
operator|)
expr_stmt|;
name|parts
index|[
name|count
operator|-
literal|1
index|]
operator|&=
operator|(
literal|1
operator|<<
name|HOST_BITS_PER_CHAR
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|parts
index|[
literal|0
index|]
operator|+=
name|c
expr_stmt|;
block|}
comment|/* If the extra highest-order part ever gets anything in it, 		   the number is certainly too big.  */
if|if
condition|(
name|parts
index|[
name|TOTAL_PARTS
operator|-
literal|1
index|]
operator|!=
literal|0
condition|)
name|overflow
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|c
operator|=
name|GETC
argument_list|()
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|numdigits
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"numeric constant with no digits"
argument_list|)
expr_stmt|;
if|if
condition|(
name|largest_digit
operator|>=
name|base
condition|)
name|error
argument_list|(
literal|"numeric constant contains digits beyond the radix"
argument_list|)
expr_stmt|;
comment|/* Remove terminating char from the token buffer and delimit the string */
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|floatflag
operator|!=
name|NOT_FLOAT
condition|)
block|{
name|tree
name|type
init|=
name|double_type_node
decl_stmt|;
name|int
name|imag
init|=
literal|0
decl_stmt|;
name|int
name|conversion_errno
init|=
literal|0
decl_stmt|;
name|REAL_VALUE_TYPE
name|value
decl_stmt|;
name|struct
name|pf_args
name|args
decl_stmt|;
comment|/* Read explicit exponent if any, and put it in tokenbuf.  */
if|if
condition|(
operator|(
name|base
operator|==
literal|10
operator|&&
operator|(
operator|(
name|c
operator|==
literal|'e'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'E'
operator|)
operator|)
operator|)
operator|||
operator|(
name|base
operator|==
literal|16
operator|&&
operator|(
name|c
operator|==
literal|'p'
operator|||
name|c
operator|==
literal|'P'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'+'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'-'
operator|)
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
block|}
comment|/* Exponent is decimal, even if string is a hex float.  */
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
name|error
argument_list|(
literal|"floating constant exponent has no digits"
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|base
operator|==
literal|16
operator|&&
name|floatflag
operator|!=
name|AFTER_EXPON
condition|)
name|error
argument_list|(
literal|"hexadecimal floating constant has no exponent"
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
comment|/* Setup input for parse_float() */
name|args
operator|.
name|base
operator|=
name|base
expr_stmt|;
name|args
operator|.
name|p
operator|=
name|p
expr_stmt|;
name|args
operator|.
name|c
operator|=
name|c
expr_stmt|;
name|args
operator|.
name|imag
operator|=
name|imag
expr_stmt|;
name|args
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|args
operator|.
name|conversion_errno
operator|=
name|conversion_errno
expr_stmt|;
comment|/* Convert string to a double, checking for overflow.  */
if|if
condition|(
name|do_float_handler
argument_list|(
name|parse_float
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|args
argument_list|)
condition|)
block|{
comment|/* Receive output from parse_float() */
name|value
operator|=
name|args
operator|.
name|value
expr_stmt|;
block|}
else|else
block|{
comment|/* We got an exception from parse_float() */
name|error
argument_list|(
literal|"floating constant out of range"
argument_list|)
expr_stmt|;
name|value
operator|=
name|dconst0
expr_stmt|;
block|}
comment|/* Receive output from parse_float() */
name|c
operator|=
name|args
operator|.
name|c
expr_stmt|;
name|imag
operator|=
name|args
operator|.
name|imag
expr_stmt|;
name|type
operator|=
name|args
operator|.
name|type
expr_stmt|;
name|conversion_errno
operator|=
name|args
operator|.
name|conversion_errno
expr_stmt|;
ifdef|#
directive|ifdef
name|ERANGE
comment|/* ERANGE is also reported for underflow, 	       so test the value to distinguish overflow from that.  */
if|if
condition|(
name|conversion_errno
operator|==
name|ERANGE
operator|&&
operator|!
name|flag_traditional
operator|&&
name|pedantic
operator|&&
operator|(
name|REAL_VALUES_LESS
argument_list|(
name|dconst1
argument_list|,
name|value
argument_list|)
operator|||
name|REAL_VALUES_LESS
argument_list|(
name|value
argument_list|,
name|dconstm1
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"floating point number exceeds range of `double'"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If the result is not a number, assume it must have been 	       due to some error message above, so silently convert 	       it to a zero.  */
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|value
argument_list|)
condition|)
name|value
operator|=
name|dconst0
expr_stmt|;
comment|/* Create a node with determined type and value.  */
if|if
condition|(
name|imag
condition|)
name|yylval
operator|.
name|ttype
operator|=
name|build_complex
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|yylval
operator|.
name|ttype
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|traditional_type
decl_stmt|,
name|ansi_type
decl_stmt|,
name|type
decl_stmt|;
name|HOST_WIDE_INT
name|high
decl_stmt|,
name|low
decl_stmt|;
name|int
name|spec_unsigned
init|=
literal|0
decl_stmt|;
name|int
name|spec_long
init|=
literal|0
decl_stmt|;
name|int
name|spec_long_long
init|=
literal|0
decl_stmt|;
name|int
name|spec_imag
init|=
literal|0
decl_stmt|;
name|int
name|warn
decl_stmt|,
name|i
decl_stmt|;
name|traditional_type
operator|=
name|ansi_type
operator|=
name|type
operator|=
name|NULL_TREE
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'u'
operator|||
name|c
operator|==
literal|'U'
condition|)
block|{
if|if
condition|(
name|spec_unsigned
condition|)
name|error
argument_list|(
literal|"two `u's in integer constant"
argument_list|)
expr_stmt|;
name|spec_unsigned
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'l'
operator|||
name|c
operator|==
literal|'L'
condition|)
block|{
if|if
condition|(
name|spec_long
condition|)
block|{
if|if
condition|(
name|spec_long_long
condition|)
name|error
argument_list|(
literal|"three `l's in integer constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|in_system_header
operator|&&
name|warn_long_long
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids long long integer constants"
argument_list|)
expr_stmt|;
name|spec_long_long
operator|=
literal|1
expr_stmt|;
block|}
name|spec_long
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'i'
operator|||
name|c
operator|==
literal|'j'
operator|||
name|c
operator|==
literal|'I'
operator|||
name|c
operator|==
literal|'J'
condition|)
block|{
if|if
condition|(
name|spec_imag
condition|)
name|error
argument_list|(
literal|"more than one `i' or `j' in numeric constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids imaginary numeric constants"
argument_list|)
expr_stmt|;
name|spec_imag
operator|=
literal|1
expr_stmt|;
block|}
else|else
break|break;
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
block|}
comment|/* If it won't fit in the host's representation for integers, 	       then pedwarn. */
name|warn
operator|=
name|overflow
expr_stmt|;
if|if
condition|(
name|warn
condition|)
name|pedwarn
argument_list|(
literal|"integer constant out of range"
argument_list|)
expr_stmt|;
comment|/* This is simplified by the fact that our constant 	       is always positive.  */
name|high
operator|=
name|low
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|/
name|HOST_BITS_PER_CHAR
condition|;
name|i
operator|++
control|)
block|{
name|high
operator||=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|parts
index|[
name|i
operator|+
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
name|HOST_BITS_PER_CHAR
operator|)
index|]
operator|<<
operator|(
name|i
operator|*
name|HOST_BITS_PER_CHAR
operator|)
operator|)
expr_stmt|;
name|low
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
name|parts
index|[
name|i
index|]
operator|<<
operator|(
name|i
operator|*
name|HOST_BITS_PER_CHAR
operator|)
expr_stmt|;
block|}
name|yylval
operator|.
name|ttype
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|long_long_unsigned_type_node
expr_stmt|;
comment|/* If warn_traditional, calculate both the ANSI type and the 	       traditional type, then see if they disagree. 	       Otherwise, calculate only the type for the dialect in use.  */
if|if
condition|(
name|warn_traditional
operator|||
name|flag_traditional
condition|)
block|{
comment|/* Calculate the traditional type.  */
comment|/* Traditionally, any constant is signed; 		   but if unsigned is specified explicitly, obey that. 		   Use the smallest size with the right number of bits, 		   except for one special case with decimal constants.  */
if|if
condition|(
operator|!
name|spec_long
operator|&&
name|base
operator|!=
literal|10
operator|&&
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|unsigned_type_node
argument_list|)
condition|)
name|traditional_type
operator|=
operator|(
name|spec_unsigned
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
operator|)
expr_stmt|;
comment|/* A decimal constant must be long 		   if it does not fit in type int. 		   I think this is independent of whether 		   the constant is signed.  */
elseif|else
if|if
condition|(
operator|!
name|spec_long
operator|&&
name|base
operator|==
literal|10
operator|&&
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|integer_type_node
argument_list|)
condition|)
name|traditional_type
operator|=
operator|(
name|spec_unsigned
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|spec_long_long
condition|)
name|traditional_type
operator|=
operator|(
name|spec_unsigned
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
operator|)
expr_stmt|;
else|else
name|traditional_type
operator|=
operator|(
name|spec_unsigned
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|warn_traditional
operator|||
operator|!
name|flag_traditional
condition|)
block|{
comment|/* Calculate the ANSI type.  */
if|if
condition|(
operator|!
name|spec_long
operator|&&
operator|!
name|spec_unsigned
operator|&&
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|integer_type_node
argument_list|)
condition|)
name|ansi_type
operator|=
name|integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|spec_long
operator|&&
operator|(
name|base
operator|!=
literal|10
operator|||
name|spec_unsigned
operator|)
operator|&&
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|unsigned_type_node
argument_list|)
condition|)
name|ansi_type
operator|=
name|unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|spec_unsigned
operator|&&
operator|!
name|spec_long_long
operator|&&
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|long_integer_type_node
argument_list|)
condition|)
name|ansi_type
operator|=
name|long_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|spec_long_long
operator|&&
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|long_unsigned_type_node
argument_list|)
condition|)
name|ansi_type
operator|=
name|long_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|spec_unsigned
operator|&&
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|long_long_integer_type_node
argument_list|)
condition|)
name|ansi_type
operator|=
name|long_long_integer_type_node
expr_stmt|;
else|else
name|ansi_type
operator|=
name|long_long_unsigned_type_node
expr_stmt|;
block|}
name|type
operator|=
name|flag_traditional
condition|?
name|traditional_type
else|:
name|ansi_type
expr_stmt|;
if|if
condition|(
name|warn_traditional
operator|&&
name|traditional_type
operator|!=
name|ansi_type
condition|)
block|{
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|traditional_type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|ansi_type
argument_list|)
condition|)
name|warning
argument_list|(
literal|"width of integer constant changes with -traditional"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|traditional_type
argument_list|)
operator|!=
name|TREE_UNSIGNED
argument_list|(
name|ansi_type
argument_list|)
condition|)
name|warning
argument_list|(
literal|"integer constant is unsigned in ANSI C, signed with -traditional"
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"width of integer constant may change on other systems with -traditional"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|flag_traditional
operator|&&
operator|!
name|spec_long_long
operator|&&
operator|!
name|warn
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
name|warn
operator|=
literal|1
expr_stmt|;
name|pedwarn
argument_list|(
literal|"integer constant out of range"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|base
operator|==
literal|10
operator|&&
operator|!
name|spec_unsigned
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|warning
argument_list|(
literal|"decimal constant is so large that it is unsigned"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec_imag
condition|)
block|{
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|yylval
operator|.
name|ttype
operator|=
name|build_complex
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"complex integer constant is too wide for `complex int'"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_traditional
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|type
argument_list|)
condition|)
comment|/* The traditional constant 0x80000000 is signed 		 but doesn't fit in the range of int. 		 This will change it to -0x80000000, which does fit.  */
block|{
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|unsigned_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|yylval
operator|.
name|ttype
argument_list|)
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* If it's still an integer (not a complex), and it doesn't 	       fit in the type we choose for it, then pedwarn. */
if|if
condition|(
operator|!
name|warn
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"integer constant out of range"
argument_list|)
expr_stmt|;
block|}
name|UNGETC
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ISALNUM
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'$'
operator|||
operator|(
operator|!
name|flag_traditional
operator|&&
operator|(
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'+'
operator|)
operator|&&
operator|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'e'
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'E'
operator|)
operator|)
condition|)
name|error
argument_list|(
literal|"missing white space after number `%s'"
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
name|value
operator|=
name|CONSTANT
expr_stmt|;
break|break;
block|}
case|case
literal|'\''
case|:
name|char_constant
label|:
block|{
specifier|register
name|int
name|result
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|num_chars
init|=
literal|0
decl_stmt|;
name|int
name|chars_seen
init|=
literal|0
decl_stmt|;
name|unsigned
name|width
init|=
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
decl_stmt|;
name|int
name|max_chars
decl_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|int
name|longest_char
init|=
name|local_mb_cur_max
argument_list|()
decl_stmt|;
operator|(
name|void
operator|)
name|local_mbtowc
argument_list|(
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|max_chars
operator|=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|/
name|width
expr_stmt|;
if|if
condition|(
name|wide_flag
condition|)
name|width
operator|=
name|WCHAR_TYPE_SIZE
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tryagain
label|:
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
name|EOF
condition|)
break|break;
operator|++
name|chars_seen
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|int
name|ignore
init|=
literal|0
decl_stmt|;
name|c
operator|=
name|readescape
argument_list|(
operator|&
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignore
condition|)
goto|goto
name|tryagain
goto|;
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_INT
operator|&&
operator|(
name|unsigned
operator|)
name|c
operator|>=
operator|(
operator|(
name|unsigned
operator|)
literal|1
operator|<<
name|width
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"escape sequence out of range for character"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAP_CHARACTER
if|if
condition|(
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|MAP_CHARACTER
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids newline in character constant"
argument_list|)
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|wchar_t
name|wc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|char_len
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|longest_char
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|>
name|maxtoken
operator|-
literal|4
condition|)
name|extend_token_buffer
argument_list|(
name|token_buffer
argument_list|)
expr_stmt|;
name|token_buffer
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
name|char_len
operator|=
name|local_mbtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|token_buffer
operator|+
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|char_len
operator|!=
operator|-
literal|1
condition|)
break|break;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|char_len
operator|>
literal|1
condition|)
block|{
comment|/* mbtowc sometimes needs an extra char before accepting */
if|if
condition|(
name|char_len
operator|<
name|i
condition|)
name|UNGETC
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wide_flag
condition|)
block|{
comment|/* Merge character into result; ignore excess chars.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|char_len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|>
name|max_chars
condition|)
break|break;
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_INT
condition|)
name|result
operator|=
operator|(
name|result
operator|<<
name|width
operator|)
operator||
operator|(
name|token_buffer
index|[
name|i
index|]
operator|&
operator|(
operator|(
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
else|else
name|result
operator|=
name|token_buffer
index|[
name|i
index|]
expr_stmt|;
block|}
name|num_chars
operator|+=
name|char_len
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
name|c
operator|=
name|wc
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|char_len
operator|==
operator|-
literal|1
condition|)
name|warning
argument_list|(
literal|"Ignoring invalid multibyte character"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wide_flag
condition|)
name|c
operator|=
name|wc
expr_stmt|;
ifdef|#
directive|ifdef
name|MAP_CHARACTER
else|else
name|c
operator|=
name|MAP_CHARACTER
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|#
directive|else
comment|/* ! MULTIBYTE_CHARS */
ifdef|#
directive|ifdef
name|MAP_CHARACTER
name|c
operator|=
name|MAP_CHARACTER
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* ! MULTIBYTE_CHARS */
block|}
if|if
condition|(
name|wide_flag
condition|)
block|{
if|if
condition|(
name|chars_seen
operator|==
literal|1
condition|)
comment|/* only keep the first one */
name|result
operator|=
name|c
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
comment|/* Merge character into result; ignore excess chars.  */
name|num_chars
operator|+=
operator|(
name|width
operator|/
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|num_chars
operator|<
name|max_chars
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_INT
condition|)
name|result
operator|=
operator|(
name|result
operator|<<
name|width
operator|)
operator||
operator|(
name|c
operator|&
operator|(
operator|(
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
else|else
name|result
operator|=
name|c
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|!=
literal|'\''
condition|)
name|error
argument_list|(
literal|"malformatted character constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|chars_seen
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"empty character constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num_chars
operator|>
name|max_chars
condition|)
block|{
name|num_chars
operator|=
name|max_chars
expr_stmt|;
name|error
argument_list|(
literal|"character constant too long"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chars_seen
operator|!=
literal|1
operator|&&
operator|!
name|flag_traditional
operator|&&
name|warn_multichar
condition|)
name|warning
argument_list|(
literal|"multi-character character constant"
argument_list|)
expr_stmt|;
comment|/* If char type is signed, sign-extend the constant.  */
if|if
condition|(
operator|!
name|wide_flag
condition|)
block|{
name|int
name|num_bits
init|=
name|num_chars
operator|*
name|width
decl_stmt|;
if|if
condition|(
name|num_bits
operator|==
literal|0
condition|)
comment|/* We already got an error; avoid invalid shift.  */
name|yylval
operator|.
name|ttype
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|char_type_node
argument_list|)
operator|||
operator|(
operator|(
name|result
operator|>>
operator|(
name|num_bits
operator|-
literal|1
operator|)
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|yylval
operator|.
name|ttype
operator|=
name|build_int_2
argument_list|(
name|result
operator|&
operator|(
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|num_bits
operator|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|yylval
operator|.
name|ttype
operator|=
name|build_int_2
argument_list|(
name|result
operator||
operator|~
operator|(
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|num_bits
operator|)
operator|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
block|}
else|else
block|{
name|yylval
operator|.
name|ttype
operator|=
name|build_int_2
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|wchar_type_node
expr_stmt|;
block|}
name|value
operator|=
name|CONSTANT
expr_stmt|;
break|break;
block|}
case|case
literal|'"'
case|:
name|string_constant
label|:
block|{
name|unsigned
name|width
init|=
name|wide_flag
condition|?
name|WCHAR_TYPE_SIZE
else|:
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|int
name|longest_char
init|=
name|local_mb_cur_max
argument_list|()
decl_stmt|;
operator|(
name|void
operator|)
name|local_mbtowc
argument_list|(
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
name|p
operator|=
name|token_buffer
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'"'
operator|&&
name|c
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|int
name|ignore
init|=
literal|0
decl_stmt|;
name|c
operator|=
name|readescape
argument_list|(
operator|&
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignore
condition|)
goto|goto
name|skipnewline
goto|;
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_INT
operator|&&
operator|(
name|unsigned
operator|)
name|c
operator|>=
operator|(
operator|(
name|unsigned
operator|)
literal|1
operator|<<
name|width
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"escape sequence out of range for character"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids newline in string constant"
argument_list|)
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|wchar_t
name|wc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|char_len
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|longest_char
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|p
operator|+
name|i
operator|>=
name|token_buffer
operator|+
name|maxtoken
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
name|char_len
operator|=
name|local_mbtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|p
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|char_len
operator|!=
operator|-
literal|1
condition|)
break|break;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|char_len
operator|==
operator|-
literal|1
condition|)
name|warning
argument_list|(
literal|"Ignoring invalid multibyte character"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* mbtowc sometimes needs an extra char before accepting */
if|if
condition|(
name|char_len
operator|<=
name|i
condition|)
name|UNGETC
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wide_flag
condition|)
block|{
name|p
operator|+=
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
name|wc
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MULTIBYTE_CHARS */
block|}
comment|/* Add this single character into the buffer either as a wchar_t 	       or as a single byte.  */
if|if
condition|(
name|wide_flag
condition|)
block|{
name|unsigned
name|width
init|=
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
decl_stmt|;
name|unsigned
name|bytemask
init|=
operator|(
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|byte
decl_stmt|;
if|if
condition|(
name|p
operator|+
name|WCHAR_BYTES
operator|>
name|token_buffer
operator|+
name|maxtoken
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|byte
operator|=
literal|0
init|;
name|byte
operator|<
name|WCHAR_BYTES
condition|;
operator|++
name|byte
control|)
block|{
name|int
name|value
decl_stmt|;
if|if
condition|(
name|byte
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|c
argument_list|)
condition|)
name|value
operator|=
literal|0
expr_stmt|;
else|else
name|value
operator|=
operator|(
name|c
operator|>>
operator|(
name|byte
operator|*
name|width
operator|)
operator|)
operator|&
name|bytemask
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|p
index|[
name|WCHAR_BYTES
operator|-
name|byte
operator|-
literal|1
index|]
operator|=
name|value
expr_stmt|;
else|else
name|p
index|[
name|byte
index|]
operator|=
name|value
expr_stmt|;
block|}
name|p
operator|+=
name|WCHAR_BYTES
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|skipnewline
label|:
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
block|}
comment|/* Terminate the string value, either with a single byte zero 	   or with a wide zero.  */
if|if
condition|(
name|wide_flag
condition|)
block|{
if|if
condition|(
name|p
operator|+
name|WCHAR_BYTES
operator|>
name|token_buffer
operator|+
name|maxtoken
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|WCHAR_BYTES
argument_list|)
expr_stmt|;
name|p
operator|+=
name|WCHAR_BYTES
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Unterminated string constant"
argument_list|)
expr_stmt|;
comment|/* We have read the entire constant. 	   Construct a STRING_CST for the result.  */
if|if
condition|(
name|wide_flag
condition|)
block|{
name|yylval
operator|.
name|ttype
operator|=
name|build_string
argument_list|(
name|p
operator|-
operator|(
name|token_buffer
operator|+
literal|1
operator|)
argument_list|,
name|token_buffer
operator|+
literal|1
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|wchar_array_type_node
expr_stmt|;
name|value
operator|=
name|STRING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|objc_flag
condition|)
block|{
comment|/* Return an Objective-C @"..." constant string object.  */
name|yylval
operator|.
name|ttype
operator|=
name|build_objc_string
argument_list|(
name|p
operator|-
operator|(
name|token_buffer
operator|+
literal|1
operator|)
argument_list|,
name|token_buffer
operator|+
literal|1
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|char_array_type_node
expr_stmt|;
name|value
operator|=
name|OBJC_STRING
expr_stmt|;
block|}
else|else
block|{
name|yylval
operator|.
name|ttype
operator|=
name|build_string
argument_list|(
name|p
operator|-
operator|(
name|token_buffer
operator|+
literal|1
operator|)
argument_list|,
name|token_buffer
operator|+
literal|1
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|char_array_type_node
expr_stmt|;
name|value
operator|=
name|STRING
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
case|case
literal|'&'
case|:
case|case
literal|'|'
case|:
case|case
literal|':'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'*'
case|:
case|case
literal|'/'
case|:
case|case
literal|'%'
case|:
case|case
literal|'^'
case|:
case|case
literal|'!'
case|:
case|case
literal|'='
case|:
block|{
specifier|register
name|int
name|c1
decl_stmt|;
name|combine
label|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'+'
case|:
name|yylval
operator|.
name|code
operator|=
name|PLUS_EXPR
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|yylval
operator|.
name|code
operator|=
name|MINUS_EXPR
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
name|yylval
operator|.
name|code
operator|=
name|BIT_AND_EXPR
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
name|yylval
operator|.
name|code
operator|=
name|BIT_IOR_EXPR
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|yylval
operator|.
name|code
operator|=
name|MULT_EXPR
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|yylval
operator|.
name|code
operator|=
name|TRUNC_DIV_EXPR
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|yylval
operator|.
name|code
operator|=
name|TRUNC_MOD_EXPR
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|yylval
operator|.
name|code
operator|=
name|BIT_XOR_EXPR
expr_stmt|;
break|break;
case|case
name|LSHIFT
case|:
name|yylval
operator|.
name|code
operator|=
name|LSHIFT_EXPR
expr_stmt|;
break|break;
case|case
name|RSHIFT
case|:
name|yylval
operator|.
name|code
operator|=
name|RSHIFT_EXPR
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|yylval
operator|.
name|code
operator|=
name|LT_EXPR
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|yylval
operator|.
name|code
operator|=
name|GT_EXPR
expr_stmt|;
break|break;
block|}
name|token_buffer
index|[
literal|1
index|]
operator|=
name|c1
operator|=
name|GETC
argument_list|()
expr_stmt|;
name|token_buffer
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c1
operator|==
literal|'='
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'<'
case|:
name|value
operator|=
name|ARITHCOMPARE
expr_stmt|;
name|yylval
operator|.
name|code
operator|=
name|LE_EXPR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'>'
case|:
name|value
operator|=
name|ARITHCOMPARE
expr_stmt|;
name|yylval
operator|.
name|code
operator|=
name|GE_EXPR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'!'
case|:
name|value
operator|=
name|EQCOMPARE
expr_stmt|;
name|yylval
operator|.
name|code
operator|=
name|NE_EXPR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'='
case|:
name|value
operator|=
name|EQCOMPARE
expr_stmt|;
name|yylval
operator|.
name|code
operator|=
name|EQ_EXPR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|value
operator|=
name|ASSIGN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|c1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'+'
case|:
name|value
operator|=
name|PLUSPLUS
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'-'
case|:
name|value
operator|=
name|MINUSMINUS
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'&'
case|:
name|value
operator|=
name|ANDAND
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'|'
case|:
name|value
operator|=
name|OROR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'<'
case|:
name|c
operator|=
name|LSHIFT
expr_stmt|;
goto|goto
name|combine
goto|;
case|case
literal|'>'
case|:
name|c
operator|=
name|RSHIFT
expr_stmt|;
goto|goto
name|combine
goto|;
block|}
else|else
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'-'
case|:
if|if
condition|(
name|c1
operator|==
literal|'>'
condition|)
block|{
name|value
operator|=
name|POINTSAT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
case|case
literal|':'
case|:
if|if
condition|(
name|c1
operator|==
literal|'>'
condition|)
block|{
name|value
operator|=
literal|']'
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|c1
operator|==
literal|'%'
condition|)
block|{
name|value
operator|=
literal|'{'
expr_stmt|;
name|indent_level
operator|++
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|c1
operator|==
literal|':'
condition|)
block|{
name|value
operator|=
literal|'['
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
case|case
literal|'%'
case|:
if|if
condition|(
name|c1
operator|==
literal|'>'
condition|)
block|{
name|value
operator|=
literal|'}'
expr_stmt|;
name|indent_level
operator|--
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
block|}
name|UNGETC
argument_list|(
name|c1
argument_list|)
expr_stmt|;
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'<'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'>'
operator|)
condition|)
name|value
operator|=
name|ARITHCOMPARE
expr_stmt|;
else|else
name|value
operator|=
name|c
expr_stmt|;
goto|goto
name|done
goto|;
block|}
case|case
literal|0
case|:
comment|/* Don't make yyparse think this is eof.  */
name|value
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
name|indent_level
operator|++
expr_stmt|;
name|value
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|indent_level
operator|--
expr_stmt|;
name|value
operator|=
name|c
expr_stmt|;
break|break;
default|default:
name|value
operator|=
name|c
expr_stmt|;
block|}
name|done
label|:
comment|/*  yylloc.last_line = lineno; */
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Sets the value of the 'yydebug' variable to VALUE.    This is a function so we don't have to have YYDEBUG defined    in order to build the compiler.  */
end_comment

begin_function
name|void
name|set_yydebug
parameter_list|(
name|value
parameter_list|)
name|int
name|value
decl_stmt|;
block|{
if|#
directive|if
name|YYDEBUG
operator|!=
literal|0
name|yydebug
operator|=
name|value
expr_stmt|;
else|#
directive|else
name|warning
argument_list|(
literal|"YYDEBUG not defined."
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

