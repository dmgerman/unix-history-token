begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Lexical analyzer for C and Objective C.    Copyright (C) 1987, 1988, 1989, 1992, 1994, 1995, 1996, 1997    1998, 1999, 2000 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"c-lex.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"splay-tree.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_comment
comment|/* MULTIBYTE_CHARS support only works for native compilers.    ??? Ideally what we want is to model widechar support after    the current floating point support.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CROSS_COMPILE
end_ifdef

begin_undef
undef|#
directive|undef
name|MULTIBYTE_CHARS
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
end_ifdef

begin_include
include|#
directive|include
file|"mbchar.h"
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MULTIBYTE_CHARS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GET_ENVIRONMENT
end_ifndef

begin_define
define|#
directive|define
name|GET_ENVIRONMENT
parameter_list|(
name|ENV_VALUE
parameter_list|,
name|ENV_NAME
parameter_list|)
value|((ENV_VALUE) = getenv (ENV_NAME))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The current line map.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|line_map
modifier|*
name|map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The line used to refresh the lineno global variable after each token.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|src_lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We may keep statistics about how long which files took to compile.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|header_time
decl_stmt|,
name|body_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|splay_tree
name|file_info_tree
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cause the `yydebug' variable to be defined.  */
end_comment

begin_define
define|#
directive|define
name|YYDEBUG
value|1
end_define

begin_comment
comment|/* File used for outputting assembler code.  */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|WCHAR_TYPE_SIZE
end_undef

begin_define
define|#
directive|define
name|WCHAR_TYPE_SIZE
value|TYPE_PRECISION (wchar_type_node)
end_define

begin_comment
comment|/* Number of bytes in a wide character.  */
end_comment

begin_define
define|#
directive|define
name|WCHAR_BYTES
value|(WCHAR_TYPE_SIZE / BITS_PER_UNIT)
end_define

begin_decl_stmt
name|int
name|indent_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of { minus number of }.  */
end_comment

begin_decl_stmt
name|int
name|pending_lang_change
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If we need to switch languages - C++ only */
end_comment

begin_decl_stmt
name|int
name|c_header_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* depth in C headers - C++ only */
end_comment

begin_comment
comment|/* Nonzero tells yylex to ignore \ in string constants.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ignore_escape_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parse_float
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lex_number
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lex_string
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lex_charconst
name|PARAMS
argument_list|(
operator|(
specifier|const
name|cpp_token
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_header_times
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dump_one_header
name|PARAMS
argument_list|(
operator|(
name|splay_tree_node
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cb_line_change
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|cpp_token
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cb_ident
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|unsigned
name|int
operator|,
specifier|const
name|cpp_string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cb_file_change
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
expr|struct
name|line_map
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cb_def_pragma
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cb_define
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|unsigned
name|int
operator|,
name|cpp_hashnode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cb_undef
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|unsigned
name|int
operator|,
name|cpp_hashnode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|const
name|char
modifier|*
name|init_c_lex
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|struct
name|cpp_callbacks
modifier|*
name|cb
decl_stmt|;
name|struct
name|c_fileinfo
modifier|*
name|toplevel
decl_stmt|;
comment|/* Set up filename timing.  Must happen before cpp_read_main_file.  */
name|file_info_tree
operator|=
name|splay_tree_new
argument_list|(
operator|(
name|splay_tree_compare_fn
operator|)
name|strcmp
argument_list|,
literal|0
argument_list|,
operator|(
name|splay_tree_delete_value_fn
operator|)
name|free
argument_list|)
expr_stmt|;
name|toplevel
operator|=
name|get_fileinfo
argument_list|(
literal|"<top level>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_detailed_statistics
condition|)
block|{
name|header_time
operator|=
literal|0
expr_stmt|;
name|body_time
operator|=
name|get_run_time
argument_list|()
expr_stmt|;
name|toplevel
operator|->
name|time
operator|=
name|body_time
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
comment|/* Change to the native locale for multibyte conversions.  */
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|GET_ENVIRONMENT
argument_list|(
name|literal_codeset
argument_list|,
literal|"LANG"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cb
operator|=
name|cpp_get_callbacks
argument_list|(
name|parse_in
argument_list|)
expr_stmt|;
name|cb
operator|->
name|line_change
operator|=
name|cb_line_change
expr_stmt|;
name|cb
operator|->
name|ident
operator|=
name|cb_ident
expr_stmt|;
name|cb
operator|->
name|file_change
operator|=
name|cb_file_change
expr_stmt|;
name|cb
operator|->
name|def_pragma
operator|=
name|cb_def_pragma
expr_stmt|;
comment|/* Set the debug callbacks if we can use them.  */
if|if
condition|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
operator|&&
operator|(
name|write_symbols
operator|==
name|DWARF_DEBUG
operator|||
name|write_symbols
operator|==
name|DWARF2_DEBUG
operator|||
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
operator|)
condition|)
block|{
name|cb
operator|->
name|define
operator|=
name|cb_define
expr_stmt|;
name|cb
operator|->
name|undef
operator|=
name|cb_undef
expr_stmt|;
block|}
comment|/* Start it at 0.  */
name|lineno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
operator|||
operator|!
name|strcmp
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
condition|)
name|filename
operator|=
literal|""
expr_stmt|;
return|return
name|cpp_read_main_file
argument_list|(
name|parse_in
argument_list|,
name|filename
argument_list|,
name|ident_hash
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A thin wrapper around the real parser that initializes the     integrated preprocessor after debug output has been initialized.    Also, make sure the start_source_file debug hook gets called for    the primary source file.  */
end_comment

begin_function
name|int
name|yyparse
parameter_list|()
block|{
call|(
modifier|*
name|debug_hooks
operator|->
name|start_source_file
call|)
argument_list|(
name|lineno
argument_list|,
name|input_filename
argument_list|)
expr_stmt|;
name|cpp_finish_options
argument_list|(
name|parse_in
argument_list|)
expr_stmt|;
return|return
name|yyparse_1
argument_list|()
return|;
block|}
end_function

begin_function
name|struct
name|c_fileinfo
modifier|*
name|get_fileinfo
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|splay_tree_node
name|n
decl_stmt|;
name|struct
name|c_fileinfo
modifier|*
name|fi
decl_stmt|;
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|file_info_tree
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
return|return
operator|(
expr|struct
name|c_fileinfo
operator|*
operator|)
name|n
operator|->
name|value
return|;
name|fi
operator|=
operator|(
expr|struct
name|c_fileinfo
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|c_fileinfo
argument_list|)
argument_list|)
expr_stmt|;
name|fi
operator|->
name|time
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|interface_only
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|interface_unknown
operator|=
literal|1
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|file_info_tree
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|name
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|fi
argument_list|)
expr_stmt|;
return|return
name|fi
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_header_times
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
comment|/* Changing files again.  This means currently collected time      is charged against header time, and body time starts back at 0.  */
if|if
condition|(
name|flag_detailed_statistics
condition|)
block|{
name|int
name|this_time
init|=
name|get_run_time
argument_list|()
decl_stmt|;
name|struct
name|c_fileinfo
modifier|*
name|file
init|=
name|get_fileinfo
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|header_time
operator|+=
name|this_time
operator|-
name|body_time
expr_stmt|;
name|file
operator|->
name|time
operator|+=
name|this_time
operator|-
name|body_time
expr_stmt|;
name|body_time
operator|=
name|this_time
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|dump_one_header
parameter_list|(
name|n
parameter_list|,
name|dummy
parameter_list|)
name|splay_tree_node
name|n
decl_stmt|;
name|void
modifier|*
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|print_time
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|n
operator|->
name|key
argument_list|,
operator|(
operator|(
expr|struct
name|c_fileinfo
operator|*
operator|)
name|n
operator|->
name|value
operator|)
operator|->
name|time
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|dump_time_statistics
parameter_list|()
block|{
name|struct
name|c_fileinfo
modifier|*
name|file
init|=
name|get_fileinfo
argument_list|(
name|input_filename
argument_list|)
decl_stmt|;
name|int
name|this_time
init|=
name|get_run_time
argument_list|()
decl_stmt|;
name|file
operator|->
name|time
operator|+=
name|this_time
operator|-
name|body_time
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n******\n"
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"header files (total)"
argument_list|,
name|header_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"main file (total)"
argument_list|,
name|this_time
operator|-
name|body_time
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ratio = %g : 1\n"
argument_list|,
operator|(
name|double
operator|)
name|header_time
operator|/
call|(
name|double
call|)
argument_list|(
name|this_time
operator|-
name|body_time
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n******\n"
argument_list|)
expr_stmt|;
name|splay_tree_foreach
argument_list|(
name|file_info_tree
argument_list|,
name|dump_one_header
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Not yet handled: #pragma, #define, #undef.    No need to deal with linemarkers under normal conditions.  */
end_comment

begin_function
specifier|static
name|void
name|cb_ident
parameter_list|(
name|pfile
parameter_list|,
name|line
parameter_list|,
name|str
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|cpp_string
modifier|*
name|str
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_IDENT
if|if
condition|(
operator|!
name|flag_no_ident
condition|)
block|{
comment|/* Convert escapes in the string.  */
name|tree
name|value
init|=
name|lex_string
argument_list|(
name|str
operator|->
name|text
argument_list|,
name|str
operator|->
name|len
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ASM_OUTPUT_IDENT
argument_list|(
name|asm_out_file
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Called at the start of every non-empty line.  TOKEN is the first    lexed token on the line.  Used for diagnostic line numbers.  */
end_comment

begin_function
specifier|static
name|void
name|cb_line_change
parameter_list|(
name|pfile
parameter_list|,
name|token
parameter_list|,
name|parsing_args
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
name|int
name|parsing_args
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|src_lineno
operator|=
name|SOURCE_LINE
argument_list|(
name|map
argument_list|,
name|token
operator|->
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cb_file_change
parameter_list|(
name|pfile
parameter_list|,
name|new_map
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|line_map
modifier|*
name|new_map
decl_stmt|;
block|{
name|unsigned
name|int
name|to_line
init|=
name|SOURCE_LINE
argument_list|(
name|new_map
argument_list|,
name|new_map
operator|->
name|to_line
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_map
operator|->
name|reason
operator|==
name|LC_ENTER
condition|)
block|{
comment|/* Don't stack the main buffer on the input stack; 	 we already did in compile_file.  */
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
name|main_input_filename
operator|=
name|new_map
operator|->
name|to_file
expr_stmt|;
else|else
block|{
name|int
name|included_at
init|=
name|SOURCE_LINE
argument_list|(
name|new_map
operator|-
literal|1
argument_list|,
name|new_map
operator|->
name|from_line
operator|-
literal|1
argument_list|)
decl_stmt|;
name|lineno
operator|=
name|included_at
expr_stmt|;
name|push_srcloc
argument_list|(
name|new_map
operator|->
name|to_file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|input_file_stack
operator|->
name|indent_level
operator|=
name|indent_level
expr_stmt|;
call|(
modifier|*
name|debug_hooks
operator|->
name|start_source_file
call|)
argument_list|(
name|included_at
argument_list|,
name|new_map
operator|->
name|to_file
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_IMPLICIT_EXTERN_C
if|if
condition|(
name|c_header_level
condition|)
operator|++
name|c_header_level
expr_stmt|;
elseif|else
if|if
condition|(
name|new_map
operator|->
name|sysp
operator|==
literal|2
condition|)
block|{
name|c_header_level
operator|=
literal|1
expr_stmt|;
operator|++
name|pending_lang_change
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
name|new_map
operator|->
name|reason
operator|==
name|LC_LEAVE
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_IMPLICIT_EXTERN_C
if|if
condition|(
name|c_header_level
operator|&&
operator|--
name|c_header_level
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|new_map
operator|->
name|sysp
operator|==
literal|2
condition|)
name|warning
argument_list|(
literal|"badly nested C headers from preprocessor"
argument_list|)
expr_stmt|;
operator|--
name|pending_lang_change
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
literal|0
block|if (indent_level != input_file_stack->indent_level) 	{ 	  warning_with_file_and_line 	    (input_filename, lineno, 	     "this file contains more '%c's than '%c's", 	     indent_level> input_file_stack->indent_level ? '{' : '}', 	     indent_level> input_file_stack->indent_level ? '}' : '{'); 	}
endif|#
directive|endif
name|pop_srcloc
argument_list|()
expr_stmt|;
call|(
modifier|*
name|debug_hooks
operator|->
name|end_source_file
call|)
argument_list|(
name|to_line
argument_list|)
expr_stmt|;
block|}
name|update_header_times
argument_list|(
name|new_map
operator|->
name|to_file
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FREEBSD_NATIVE
name|in_system_header
operator|=
name|new_map
operator|->
name|sysp
operator|!=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* FREEBSD_NATIVE */
name|in_system_header
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* FREEBSD_NATIVE */
name|input_filename
operator|=
name|new_map
operator|->
name|to_file
expr_stmt|;
name|lineno
operator|=
name|to_line
expr_stmt|;
name|map
operator|=
name|new_map
expr_stmt|;
comment|/* Hook for C++.  */
name|extract_interface_info
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cb_def_pragma
parameter_list|(
name|pfile
parameter_list|,
name|line
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
block|{
comment|/* Issue a warning message if we have been asked to do so.  Ignore      unknown pragmas in system headers unless an explicit      -Wunknown-pragmas has been given.  */
if|if
condition|(
name|warn_unknown_pragmas
operator|>
name|in_system_header
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|space
decl_stmt|,
modifier|*
name|name
init|=
literal|0
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|space
operator|=
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|CPP_NAME
condition|)
name|name
operator|=
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|SOURCE_LINE
argument_list|(
name|map
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|warning
argument_list|(
literal|"ignoring #pragma %s %s"
argument_list|,
name|space
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"ignoring #pragma %s"
argument_list|,
name|space
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* #define callback for DWARF and DWARF2 debug info.  */
end_comment

begin_function
specifier|static
name|void
name|cb_define
parameter_list|(
name|pfile
parameter_list|,
name|line
parameter_list|,
name|node
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
block|{
call|(
modifier|*
name|debug_hooks
operator|->
name|define
call|)
argument_list|(
name|SOURCE_LINE
argument_list|(
name|map
argument_list|,
name|line
argument_list|)
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|cpp_macro_definition
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* #undef callback for DWARF and DWARF2 debug info.  */
end_comment

begin_function
specifier|static
name|void
name|cb_undef
parameter_list|(
name|pfile
parameter_list|,
name|line
parameter_list|,
name|node
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
block|{
call|(
modifier|*
name|debug_hooks
operator|->
name|undef
call|)
argument_list|(
name|SOURCE_LINE
argument_list|(
name|map
argument_list|,
name|line
argument_list|)
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* not yet */
end_comment

begin_comment
comment|/* Returns nonzero if C is a universal-character-name.  Give an error if it    is not one which may appear in an identifier, as per [extendid].     Note that extended character support in identifiers has not yet been    implemented.  It is my personal opinion that this is not a desirable    feature.  Portable code cannot count on support for more than the basic    identifier character set.  */
end_comment

begin_ifdef
unit|static inline int is_extended_char (c)      int c; {
ifdef|#
directive|ifdef
name|TARGET_EBCDIC
end_ifdef

begin_else
unit|return 0;
else|#
directive|else
end_else

begin_comment
comment|/* ASCII.  */
end_comment

begin_comment
unit|if (c< 0x7f)     return 0;
comment|/* None of the valid chars are outside the Basic Multilingual Plane (the      low 16 bits).  */
end_comment

begin_comment
unit|if (c> 0xffff)     {       error ("universal-character-name '\\U%08x' not valid in identifier", c);       return 1;     }
comment|/* Latin */
end_comment

begin_comment
unit|if ((c>= 0x00c0&& c<= 0x00d6)       || (c>= 0x00d8&& c<= 0x00f6)       || (c>= 0x00f8&& c<= 0x01f5)       || (c>= 0x01fa&& c<= 0x0217)       || (c>= 0x0250&& c<= 0x02a8)       || (c>= 0x1e00&& c<= 0x1e9a)       || (c>= 0x1ea0&& c<= 0x1ef9))     return 1;
comment|/* Greek */
end_comment

begin_comment
unit|if ((c == 0x0384)       || (c>= 0x0388&& c<= 0x038a)       || (c == 0x038c)       || (c>= 0x038e&& c<= 0x03a1)       || (c>= 0x03a3&& c<= 0x03ce)       || (c>= 0x03d0&& c<= 0x03d6)       || (c == 0x03da)       || (c == 0x03dc)       || (c == 0x03de)       || (c == 0x03e0)       || (c>= 0x03e2&& c<= 0x03f3)       || (c>= 0x1f00&& c<= 0x1f15)       || (c>= 0x1f18&& c<= 0x1f1d)       || (c>= 0x1f20&& c<= 0x1f45)       || (c>= 0x1f48&& c<= 0x1f4d)       || (c>= 0x1f50&& c<= 0x1f57)       || (c == 0x1f59)       || (c == 0x1f5b)       || (c == 0x1f5d)       || (c>= 0x1f5f&& c<= 0x1f7d)       || (c>= 0x1f80&& c<= 0x1fb4)       || (c>= 0x1fb6&& c<= 0x1fbc)       || (c>= 0x1fc2&& c<= 0x1fc4)       || (c>= 0x1fc6&& c<= 0x1fcc)       || (c>= 0x1fd0&& c<= 0x1fd3)       || (c>= 0x1fd6&& c<= 0x1fdb)       || (c>= 0x1fe0&& c<= 0x1fec)       || (c>= 0x1ff2&& c<= 0x1ff4)       || (c>= 0x1ff6&& c<= 0x1ffc))     return 1;
comment|/* Cyrillic */
end_comment

begin_comment
unit|if ((c>= 0x0401&& c<= 0x040d)       || (c>= 0x040f&& c<= 0x044f)       || (c>= 0x0451&& c<= 0x045c)       || (c>= 0x045e&& c<= 0x0481)       || (c>= 0x0490&& c<= 0x04c4)       || (c>= 0x04c7&& c<= 0x04c8)       || (c>= 0x04cb&& c<= 0x04cc)       || (c>= 0x04d0&& c<= 0x04eb)       || (c>= 0x04ee&& c<= 0x04f5)       || (c>= 0x04f8&& c<= 0x04f9))     return 1;
comment|/* Armenian */
end_comment

begin_comment
unit|if ((c>= 0x0531&& c<= 0x0556)       || (c>= 0x0561&& c<= 0x0587))     return 1;
comment|/* Hebrew */
end_comment

begin_comment
unit|if ((c>= 0x05d0&& c<= 0x05ea)       || (c>= 0x05f0&& c<= 0x05f4))     return 1;
comment|/* Arabic */
end_comment

begin_comment
unit|if ((c>= 0x0621&& c<= 0x063a)       || (c>= 0x0640&& c<= 0x0652)       || (c>= 0x0670&& c<= 0x06b7)       || (c>= 0x06ba&& c<= 0x06be)       || (c>= 0x06c0&& c<= 0x06ce)       || (c>= 0x06e5&& c<= 0x06e7))     return 1;
comment|/* Devanagari */
end_comment

begin_comment
unit|if ((c>= 0x0905&& c<= 0x0939)       || (c>= 0x0958&& c<= 0x0962))     return 1;
comment|/* Bengali */
end_comment

begin_comment
unit|if ((c>= 0x0985&& c<= 0x098c)       || (c>= 0x098f&& c<= 0x0990)       || (c>= 0x0993&& c<= 0x09a8)       || (c>= 0x09aa&& c<= 0x09b0)       || (c == 0x09b2)       || (c>= 0x09b6&& c<= 0x09b9)       || (c>= 0x09dc&& c<= 0x09dd)       || (c>= 0x09df&& c<= 0x09e1)       || (c>= 0x09f0&& c<= 0x09f1))     return 1;
comment|/* Gurmukhi */
end_comment

begin_comment
unit|if ((c>= 0x0a05&& c<= 0x0a0a)       || (c>= 0x0a0f&& c<= 0x0a10)       || (c>= 0x0a13&& c<= 0x0a28)       || (c>= 0x0a2a&& c<= 0x0a30)       || (c>= 0x0a32&& c<= 0x0a33)       || (c>= 0x0a35&& c<= 0x0a36)       || (c>= 0x0a38&& c<= 0x0a39)       || (c>= 0x0a59&& c<= 0x0a5c)       || (c == 0x0a5e))     return 1;
comment|/* Gujarati */
end_comment

begin_comment
unit|if ((c>= 0x0a85&& c<= 0x0a8b)       || (c == 0x0a8d)       || (c>= 0x0a8f&& c<= 0x0a91)       || (c>= 0x0a93&& c<= 0x0aa8)       || (c>= 0x0aaa&& c<= 0x0ab0)       || (c>= 0x0ab2&& c<= 0x0ab3)       || (c>= 0x0ab5&& c<= 0x0ab9)       || (c == 0x0ae0))     return 1;
comment|/* Oriya */
end_comment

begin_comment
unit|if ((c>= 0x0b05&& c<= 0x0b0c)       || (c>= 0x0b0f&& c<= 0x0b10)       || (c>= 0x0b13&& c<= 0x0b28)       || (c>= 0x0b2a&& c<= 0x0b30)       || (c>= 0x0b32&& c<= 0x0b33)       || (c>= 0x0b36&& c<= 0x0b39)       || (c>= 0x0b5c&& c<= 0x0b5d)       || (c>= 0x0b5f&& c<= 0x0b61))     return 1;
comment|/* Tamil */
end_comment

begin_comment
unit|if ((c>= 0x0b85&& c<= 0x0b8a)       || (c>= 0x0b8e&& c<= 0x0b90)       || (c>= 0x0b92&& c<= 0x0b95)       || (c>= 0x0b99&& c<= 0x0b9a)       || (c == 0x0b9c)       || (c>= 0x0b9e&& c<= 0x0b9f)       || (c>= 0x0ba3&& c<= 0x0ba4)       || (c>= 0x0ba8&& c<= 0x0baa)       || (c>= 0x0bae&& c<= 0x0bb5)       || (c>= 0x0bb7&& c<= 0x0bb9))     return 1;
comment|/* Telugu */
end_comment

begin_comment
unit|if ((c>= 0x0c05&& c<= 0x0c0c)       || (c>= 0x0c0e&& c<= 0x0c10)       || (c>= 0x0c12&& c<= 0x0c28)       || (c>= 0x0c2a&& c<= 0x0c33)       || (c>= 0x0c35&& c<= 0x0c39)       || (c>= 0x0c60&& c<= 0x0c61))     return 1;
comment|/* Kannada */
end_comment

begin_comment
unit|if ((c>= 0x0c85&& c<= 0x0c8c)       || (c>= 0x0c8e&& c<= 0x0c90)       || (c>= 0x0c92&& c<= 0x0ca8)       || (c>= 0x0caa&& c<= 0x0cb3)       || (c>= 0x0cb5&& c<= 0x0cb9)       || (c>= 0x0ce0&& c<= 0x0ce1))     return 1;
comment|/* Malayalam */
end_comment

begin_comment
unit|if ((c>= 0x0d05&& c<= 0x0d0c)       || (c>= 0x0d0e&& c<= 0x0d10)       || (c>= 0x0d12&& c<= 0x0d28)       || (c>= 0x0d2a&& c<= 0x0d39)       || (c>= 0x0d60&& c<= 0x0d61))     return 1;
comment|/* Thai */
end_comment

begin_comment
unit|if ((c>= 0x0e01&& c<= 0x0e30)       || (c>= 0x0e32&& c<= 0x0e33)       || (c>= 0x0e40&& c<= 0x0e46)       || (c>= 0x0e4f&& c<= 0x0e5b))     return 1;
comment|/* Lao */
end_comment

begin_comment
unit|if ((c>= 0x0e81&& c<= 0x0e82)       || (c == 0x0e84)       || (c == 0x0e87)       || (c == 0x0e88)       || (c == 0x0e8a)       || (c == 0x0e0d)       || (c>= 0x0e94&& c<= 0x0e97)       || (c>= 0x0e99&& c<= 0x0e9f)       || (c>= 0x0ea1&& c<= 0x0ea3)       || (c == 0x0ea5)       || (c == 0x0ea7)       || (c == 0x0eaa)       || (c == 0x0eab)       || (c>= 0x0ead&& c<= 0x0eb0)       || (c == 0x0eb2)       || (c == 0x0eb3)       || (c == 0x0ebd)       || (c>= 0x0ec0&& c<= 0x0ec4)       || (c == 0x0ec6))     return 1;
comment|/* Georgian */
end_comment

begin_comment
unit|if ((c>= 0x10a0&& c<= 0x10c5)       || (c>= 0x10d0&& c<= 0x10f6))     return 1;
comment|/* Hiragana */
end_comment

begin_comment
unit|if ((c>= 0x3041&& c<= 0x3094)       || (c>= 0x309b&& c<= 0x309e))     return 1;
comment|/* Katakana */
end_comment

begin_comment
unit|if ((c>= 0x30a1&& c<= 0x30fe))     return 1;
comment|/* Bopmofo */
end_comment

begin_comment
unit|if ((c>= 0x3105&& c<= 0x312c))     return 1;
comment|/* Hangul */
end_comment

begin_comment
unit|if ((c>= 0x1100&& c<= 0x1159)       || (c>= 0x1161&& c<= 0x11a2)       || (c>= 0x11a8&& c<= 0x11f9))     return 1;
comment|/* CJK Unified Ideographs */
end_comment

begin_endif
unit|if ((c>= 0xf900&& c<= 0xfa2d)       || (c>= 0xfb1f&& c<= 0xfb36)       || (c>= 0xfb38&& c<= 0xfb3c)       || (c == 0xfb3e)       || (c>= 0xfb40&& c<= 0xfb41)       || (c>= 0xfb42&& c<= 0xfb44)       || (c>= 0xfb46&& c<= 0xfbb1)       || (c>= 0xfbd3&& c<= 0xfd3f)       || (c>= 0xfd50&& c<= 0xfd8f)       || (c>= 0xfd92&& c<= 0xfdc7)       || (c>= 0xfdf0&& c<= 0xfdfb)       || (c>= 0xfe70&& c<= 0xfe72)       || (c == 0xfe74)       || (c>= 0xfe76&& c<= 0xfefc)       || (c>= 0xff21&& c<= 0xff3a)       || (c>= 0xff41&& c<= 0xff5a)       || (c>= 0xff66&& c<= 0xffbe)       || (c>= 0xffc2&& c<= 0xffc7)       || (c>= 0xffca&& c<= 0xffcf)       || (c>= 0xffd2&& c<= 0xffd7)       || (c>= 0xffda&& c<= 0xffdc)       || (c>= 0x4e00&& c<= 0x9fa5))     return 1;    error ("universal-character-name '\\u%04x' not valid in identifier", c);   return 1;
endif|#
directive|endif
end_endif

begin_comment
unit|}
comment|/* Add the UTF-8 representation of C to the token_buffer.  */
end_comment

begin_endif
unit|static void utf8_extend_token (c)      int c; {   int shift, mask;    if      (c<= 0x0000007f)     {       extend_token (c);       return;     }   else if (c<= 0x000007ff)     shift = 6, mask = 0xc0;   else if (c<= 0x0000ffff)     shift = 12, mask = 0xe0;   else if (c<= 0x001fffff)     shift = 18, mask = 0xf0;   else if (c<= 0x03ffffff)     shift = 24, mask = 0xf8;   else     shift = 30, mask = 0xfc;    extend_token (mask | (c>> shift));   do     {       shift -= 6;       extend_token ((unsigned char) (0x80 | (c>> shift)));     }   while (shift); }
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|struct try_type {   tree *const node_var;   const char unsigned_flag;   const char long_flag;   const char long_long_flag; };  struct try_type type_sequence[] = {   {&integer_type_node, 0, 0, 0},   {&unsigned_type_node, 1, 0, 0},   {&long_integer_type_node, 0, 1, 0},   {&long_unsigned_type_node, 1, 1, 0},   {&long_long_integer_type_node, 0, 1, 1},   {&long_long_unsigned_type_node, 1, 1, 1} };
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_struct
struct|struct
name|pf_args
block|{
comment|/* Input */
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|fflag
decl_stmt|;
name|int
name|lflag
decl_stmt|;
name|int
name|base
decl_stmt|;
comment|/* Output */
name|int
name|conversion_errno
decl_stmt|;
name|REAL_VALUE_TYPE
name|value
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|parse_float
parameter_list|(
name|data
parameter_list|)
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|pf_args
modifier|*
name|args
init|=
operator|(
expr|struct
name|pf_args
operator|*
operator|)
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|typename
decl_stmt|;
name|args
operator|->
name|conversion_errno
operator|=
literal|0
expr_stmt|;
name|args
operator|->
name|type
operator|=
name|double_type_node
expr_stmt|;
name|typename
operator|=
literal|"double"
expr_stmt|;
comment|/* The second argument, machine_mode, of REAL_VALUE_ATOF      tells the desired precision of the binary result      of decimal-to-binary conversion.  */
if|if
condition|(
name|args
operator|->
name|fflag
condition|)
block|{
if|if
condition|(
name|args
operator|->
name|lflag
condition|)
name|error
argument_list|(
literal|"both 'f' and 'l' suffixes on floating constant"
argument_list|)
expr_stmt|;
name|args
operator|->
name|type
operator|=
name|float_type_node
expr_stmt|;
name|typename
operator|=
literal|"float"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
operator|->
name|lflag
condition|)
block|{
name|args
operator|->
name|type
operator|=
name|long_double_type_node
expr_stmt|;
name|typename
operator|=
literal|"long double"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_single_precision_constant
condition|)
block|{
name|args
operator|->
name|type
operator|=
name|float_type_node
expr_stmt|;
name|typename
operator|=
literal|"float"
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|base
operator|==
literal|16
condition|)
name|args
operator|->
name|value
operator|=
name|REAL_VALUE_HTOF
argument_list|(
name|args
operator|->
name|str
argument_list|,
name|TYPE_MODE
argument_list|(
name|args
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|args
operator|->
name|value
operator|=
name|REAL_VALUE_ATOF
argument_list|(
name|args
operator|->
name|str
argument_list|,
name|TYPE_MODE
argument_list|(
name|args
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|->
name|conversion_errno
operator|=
name|errno
expr_stmt|;
comment|/* A diagnostic is required here by some ISO C testsuites.      This is not pedwarn, because some people don't want      an error for this.  */
if|if
condition|(
name|REAL_VALUE_ISINF
argument_list|(
name|args
operator|->
name|value
argument_list|)
operator|&&
name|pedantic
condition|)
name|warning
argument_list|(
literal|"floating point number exceeds range of '%s'"
argument_list|,
name|typename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|c_lex
parameter_list|(
name|value
parameter_list|)
name|tree
modifier|*
name|value
decl_stmt|;
block|{
specifier|const
name|cpp_token
modifier|*
name|tok
decl_stmt|;
name|retry
label|:
name|timevar_push
argument_list|(
name|TV_CPP
argument_list|)
expr_stmt|;
do|do
name|tok
operator|=
name|cpp_get_token
argument_list|(
name|parse_in
argument_list|)
expr_stmt|;
do|while
condition|(
name|tok
operator|->
name|type
operator|==
name|CPP_PADDING
condition|)
do|;
name|timevar_pop
argument_list|(
name|TV_CPP
argument_list|)
expr_stmt|;
comment|/* The C++ front end does horrible things with the current line      number.  To ensure an accurate line number, we must reset it      every time we return a token.  */
name|lineno
operator|=
name|src_lineno
expr_stmt|;
operator|*
name|value
operator|=
name|NULL_TREE
expr_stmt|;
switch|switch
condition|(
name|tok
operator|->
name|type
condition|)
block|{
case|case
name|CPP_OPEN_BRACE
case|:
name|indent_level
operator|++
expr_stmt|;
break|break;
case|case
name|CPP_CLOSE_BRACE
case|:
name|indent_level
operator|--
expr_stmt|;
break|break;
comment|/* Issue this error here, where we can get at tok->val.c.  */
case|case
name|CPP_OTHER
case|:
if|if
condition|(
name|ISGRAPH
argument_list|(
name|tok
operator|->
name|val
operator|.
name|c
argument_list|)
condition|)
name|error
argument_list|(
literal|"stray '%c' in program"
argument_list|,
name|tok
operator|->
name|val
operator|.
name|c
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"stray '\\%o' in program"
argument_list|,
name|tok
operator|->
name|val
operator|.
name|c
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
name|CPP_NAME
case|:
operator|*
name|value
operator|=
name|HT_IDENT_TO_GCC_IDENT
argument_list|(
name|HT_NODE
argument_list|(
name|tok
operator|->
name|val
operator|.
name|node
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_NUMBER
case|:
operator|*
name|value
operator|=
name|lex_number
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|tok
operator|->
name|val
operator|.
name|str
operator|.
name|text
argument_list|,
name|tok
operator|->
name|val
operator|.
name|str
operator|.
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_CHAR
case|:
case|case
name|CPP_WCHAR
case|:
operator|*
name|value
operator|=
name|lex_charconst
argument_list|(
name|tok
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_STRING
case|:
case|case
name|CPP_WSTRING
case|:
operator|*
name|value
operator|=
name|lex_string
argument_list|(
name|tok
operator|->
name|val
operator|.
name|str
operator|.
name|text
argument_list|,
name|tok
operator|->
name|val
operator|.
name|str
operator|.
name|len
argument_list|,
name|tok
operator|->
name|type
operator|==
name|CPP_WSTRING
argument_list|)
expr_stmt|;
break|break;
comment|/* These tokens should not be visible outside cpplib.  */
case|case
name|CPP_HEADER_NAME
case|:
case|case
name|CPP_COMMENT
case|:
case|case
name|CPP_MACRO_ARG
case|:
name|abort
argument_list|()
expr_stmt|;
default|default:
break|break;
block|}
return|return
name|tok
operator|->
name|type
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ERROR
parameter_list|(
name|msgid
parameter_list|)
value|do { error(msgid); goto syntax_error; } while(0)
end_define

begin_function
specifier|static
name|tree
name|lex_number
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
block|{
name|int
name|base
init|=
literal|10
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|largest_digit
init|=
literal|0
decl_stmt|;
name|int
name|numdigits
init|=
literal|0
decl_stmt|;
name|int
name|overflow
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|tree
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
enum|enum
name|anon1
block|{
name|NOT_FLOAT
init|=
literal|0
block|,
name|AFTER_POINT
block|,
name|AFTER_EXPON
block|}
name|floatflag
init|=
name|NOT_FLOAT
enum|;
comment|/* We actually store only HOST_BITS_PER_CHAR bits in each part.      The code below which fills the parts array assumes that a host      int is at least twice as wide as a host char, and that       HOST_BITS_PER_WIDE_INT is an even multiple of HOST_BITS_PER_CHAR.      Two HOST_WIDE_INTs is the largest int literal we can store.      In order to detect overflow below, the number of parts (TOTAL_PARTS)      must be exactly the number of parts needed to hold the bits      of two HOST_WIDE_INTs.  */
define|#
directive|define
name|TOTAL_PARTS
value|((HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR) * 2)
name|unsigned
name|int
name|parts
index|[
name|TOTAL_PARTS
index|]
decl_stmt|;
comment|/* Optimize for most frequent case.  */
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|'0'
condition|)
return|return
name|integer_zero_node
return|;
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|'1'
condition|)
return|return
name|integer_one_node
return|;
else|else
return|return
name|build_int_2
argument_list|(
operator|*
name|str
operator|-
literal|'0'
argument_list|,
literal|0
argument_list|)
return|;
block|}
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|TOTAL_PARTS
condition|;
name|count
operator|++
control|)
name|parts
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
comment|/* len is known to be>1 at this point.  */
name|p
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|2
operator|&&
name|str
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
operator|(
name|str
index|[
literal|1
index|]
operator|==
literal|'x'
operator|||
name|str
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
condition|)
block|{
name|base
operator|=
literal|16
expr_stmt|;
name|p
operator|=
name|str
operator|+
literal|2
expr_stmt|;
block|}
comment|/* The ISDIGIT check is so we are not confused by a suffix on 0.  */
elseif|else
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|ISDIGIT
argument_list|(
name|str
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|base
operator|=
literal|8
expr_stmt|;
name|p
operator|=
name|str
operator|+
literal|1
expr_stmt|;
block|}
do|do
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|floatflag
operator|==
name|AFTER_POINT
condition|)
name|ERROR
argument_list|(
literal|"too many decimal points in floating constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|floatflag
operator|==
name|AFTER_EXPON
condition|)
name|ERROR
argument_list|(
literal|"decimal point in exponent - impossible!"
argument_list|)
expr_stmt|;
else|else
name|floatflag
operator|=
name|AFTER_POINT
expr_stmt|;
if|if
condition|(
name|base
operator|==
literal|8
condition|)
name|base
operator|=
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
comment|/* Possible future extension: silently ignore _ in numbers, 	   permitting cosmetic grouping - e.g. 0x8000_0000 == 0x80000000 	   but somewhat easier to read.  Ada has this?  */
name|ERROR
argument_list|(
literal|"underscore in number"
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|n
decl_stmt|;
comment|/* It is not a decimal point. 	     It should be a digit (perhaps a hex digit).  */
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|base
operator|==
literal|16
operator|&&
name|ISXDIGIT
argument_list|(
name|c
argument_list|)
operator|)
condition|)
block|{
name|n
operator|=
name|hex_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|base
operator|<=
literal|10
operator|&&
operator|(
name|c
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
operator|)
condition|)
block|{
name|base
operator|=
literal|10
expr_stmt|;
name|floatflag
operator|=
name|AFTER_EXPON
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|base
operator|==
literal|16
operator|&&
operator|(
name|c
operator|==
literal|'p'
operator|||
name|c
operator|==
literal|'P'
operator|)
condition|)
block|{
name|floatflag
operator|=
name|AFTER_EXPON
expr_stmt|;
break|break;
comment|/* start of exponent */
block|}
else|else
block|{
name|p
operator|--
expr_stmt|;
break|break;
comment|/* start of suffix */
block|}
if|if
condition|(
name|n
operator|>=
name|largest_digit
condition|)
name|largest_digit
operator|=
name|n
expr_stmt|;
name|numdigits
operator|++
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|TOTAL_PARTS
condition|;
name|count
operator|++
control|)
block|{
name|parts
index|[
name|count
index|]
operator|*=
name|base
expr_stmt|;
if|if
condition|(
name|count
condition|)
block|{
name|parts
index|[
name|count
index|]
operator|+=
operator|(
name|parts
index|[
name|count
operator|-
literal|1
index|]
operator|>>
name|HOST_BITS_PER_CHAR
operator|)
expr_stmt|;
name|parts
index|[
name|count
operator|-
literal|1
index|]
operator|&=
operator|(
literal|1
operator|<<
name|HOST_BITS_PER_CHAR
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|parts
index|[
literal|0
index|]
operator|+=
name|n
expr_stmt|;
block|}
comment|/* If the highest-order part overflows (gets larger than 	     a host char will hold) then the whole number has  	     overflowed.  Record this and truncate the highest-order 	     part.  */
if|if
condition|(
name|parts
index|[
name|TOTAL_PARTS
operator|-
literal|1
index|]
operator|>>
name|HOST_BITS_PER_CHAR
condition|)
block|{
name|overflow
operator|=
literal|1
expr_stmt|;
name|parts
index|[
name|TOTAL_PARTS
operator|-
literal|1
index|]
operator|&=
operator|(
literal|1
operator|<<
name|HOST_BITS_PER_CHAR
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|p
operator|<
name|str
operator|+
name|len
condition|)
do|;
comment|/* This can happen on input like `int i = 0x;' */
if|if
condition|(
name|numdigits
operator|==
literal|0
condition|)
name|ERROR
argument_list|(
literal|"numeric constant with no digits"
argument_list|)
expr_stmt|;
if|if
condition|(
name|largest_digit
operator|>=
name|base
condition|)
name|ERROR
argument_list|(
literal|"numeric constant contains digits beyond the radix"
argument_list|)
expr_stmt|;
if|if
condition|(
name|floatflag
operator|!=
name|NOT_FLOAT
condition|)
block|{
name|tree
name|type
decl_stmt|;
name|int
name|imag
decl_stmt|,
name|fflag
decl_stmt|,
name|lflag
decl_stmt|,
name|conversion_errno
decl_stmt|;
name|REAL_VALUE_TYPE
name|real
decl_stmt|;
name|struct
name|pf_args
name|args
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|;
if|if
condition|(
name|base
operator|==
literal|16
operator|&&
name|pedantic
operator|&&
operator|!
name|flag_isoc99
condition|)
name|pedwarn
argument_list|(
literal|"floating constant may not be in radix 16"
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
literal|16
operator|&&
name|floatflag
operator|!=
name|AFTER_EXPON
condition|)
name|ERROR
argument_list|(
literal|"hexadecimal floating constant has no exponent"
argument_list|)
expr_stmt|;
comment|/* Read explicit exponent if any, and put it in tokenbuf.  */
if|if
condition|(
operator|(
name|base
operator|==
literal|10
operator|&&
operator|(
operator|(
name|c
operator|==
literal|'e'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'E'
operator|)
operator|)
operator|)
operator|||
operator|(
name|base
operator|==
literal|16
operator|&&
operator|(
name|c
operator|==
literal|'p'
operator|||
name|c
operator|==
literal|'P'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|<
name|str
operator|+
name|len
condition|)
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|<
name|str
operator|+
name|len
operator|&&
operator|(
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'-'
operator|)
condition|)
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* Exponent is decimal, even if string is a hex float.  */
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
name|ERROR
argument_list|(
literal|"floating constant exponent has no digits"
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|str
operator|+
name|len
operator|&&
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
name|p
operator|--
expr_stmt|;
block|}
comment|/* Copy the float constant now; we don't want any suffixes in the 	 string passed to parse_float.  */
name|copy
operator|=
name|alloca
argument_list|(
name|p
operator|-
name|str
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
name|str
argument_list|,
name|p
operator|-
name|str
argument_list|)
expr_stmt|;
name|copy
index|[
name|p
operator|-
name|str
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Now parse suffixes.  */
name|fflag
operator|=
name|lflag
operator|=
name|imag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|str
operator|+
name|len
condition|)
switch|switch
condition|(
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
if|if
condition|(
name|fflag
condition|)
name|ERROR
argument_list|(
literal|"more than one 'f' suffix on floating constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_traditional
operator|&&
operator|!
name|in_system_header
operator|&&
operator|!
name|cpp_sys_macro_p
argument_list|(
name|parse_in
argument_list|)
condition|)
name|warning
argument_list|(
literal|"traditional C rejects the 'f' suffix"
argument_list|)
expr_stmt|;
name|fflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
if|if
condition|(
name|lflag
condition|)
name|ERROR
argument_list|(
literal|"more than one 'l' suffix on floating constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_traditional
operator|&&
operator|!
name|in_system_header
operator|&&
operator|!
name|cpp_sys_macro_p
argument_list|(
name|parse_in
argument_list|)
condition|)
name|warning
argument_list|(
literal|"traditional C rejects the 'l' suffix"
argument_list|)
expr_stmt|;
name|lflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
case|case
literal|'j'
case|:
case|case
literal|'J'
case|:
if|if
condition|(
name|imag
condition|)
name|ERROR
argument_list|(
literal|"more than one 'i' or 'j' suffix on floating constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids imaginary numeric constants"
argument_list|)
expr_stmt|;
name|imag
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|ERROR
argument_list|(
literal|"invalid suffix on floating constant"
argument_list|)
expr_stmt|;
block|}
comment|/* Setup input for parse_float() */
name|args
operator|.
name|str
operator|=
name|copy
expr_stmt|;
name|args
operator|.
name|fflag
operator|=
name|fflag
expr_stmt|;
name|args
operator|.
name|lflag
operator|=
name|lflag
expr_stmt|;
name|args
operator|.
name|base
operator|=
name|base
expr_stmt|;
comment|/* Convert string to a double, checking for overflow.  */
if|if
condition|(
name|do_float_handler
argument_list|(
name|parse_float
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|args
argument_list|)
condition|)
block|{
comment|/* Receive output from parse_float() */
name|real
operator|=
name|args
operator|.
name|value
expr_stmt|;
block|}
else|else
comment|/* We got an exception from parse_float() */
name|ERROR
argument_list|(
literal|"floating constant out of range"
argument_list|)
expr_stmt|;
comment|/* Receive output from parse_float() */
name|conversion_errno
operator|=
name|args
operator|.
name|conversion_errno
expr_stmt|;
name|type
operator|=
name|args
operator|.
name|type
expr_stmt|;
ifdef|#
directive|ifdef
name|ERANGE
comment|/* ERANGE is also reported for underflow, 	 so test the value to distinguish overflow from that.  */
if|if
condition|(
name|conversion_errno
operator|==
name|ERANGE
operator|&&
operator|!
name|flag_traditional
operator|&&
name|pedantic
operator|&&
operator|(
name|REAL_VALUES_LESS
argument_list|(
name|dconst1
argument_list|,
name|real
argument_list|)
operator|||
name|REAL_VALUES_LESS
argument_list|(
name|real
argument_list|,
name|dconstm1
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"floating point number exceeds range of 'double'"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Create a node with determined type and value.  */
if|if
condition|(
name|imag
condition|)
name|value
operator|=
name|build_complex
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|real
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|real
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|trad_type
decl_stmt|,
name|ansi_type
decl_stmt|,
name|type
decl_stmt|;
name|HOST_WIDE_INT
name|high
decl_stmt|,
name|low
decl_stmt|;
name|int
name|spec_unsigned
init|=
literal|0
decl_stmt|;
name|int
name|spec_long
init|=
literal|0
decl_stmt|;
name|int
name|spec_long_long
init|=
literal|0
decl_stmt|;
name|int
name|spec_imag
init|=
literal|0
decl_stmt|;
name|int
name|suffix_lu
init|=
literal|0
decl_stmt|;
name|int
name|warn
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|trad_type
operator|=
name|ansi_type
operator|=
name|type
operator|=
name|NULL_TREE
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|str
operator|+
name|len
condition|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'u'
case|:
case|case
literal|'U'
case|:
if|if
condition|(
name|spec_unsigned
condition|)
name|error
argument_list|(
literal|"two 'u' suffixes on integer constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_traditional
operator|&&
operator|!
name|in_system_header
operator|&&
operator|!
name|cpp_sys_macro_p
argument_list|(
name|parse_in
argument_list|)
condition|)
name|warning
argument_list|(
literal|"traditional C rejects the 'u' suffix"
argument_list|)
expr_stmt|;
name|spec_unsigned
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|spec_long
condition|)
name|suffix_lu
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
if|if
condition|(
name|spec_long
condition|)
block|{
if|if
condition|(
name|spec_long_long
condition|)
name|error
argument_list|(
literal|"three 'l' suffixes on integer constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|suffix_lu
condition|)
name|error
argument_list|(
literal|"'lul' is not a valid integer suffix"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
name|spec_long
condition|)
name|error
argument_list|(
literal|"'Ll' and 'lL' are not valid integer suffixes"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|flag_isoc99
operator|&&
operator|!
name|in_system_header
operator|&&
name|warn_long_long
condition|)
name|pedwarn
argument_list|(
literal|"ISO C89 forbids long long integer constants"
argument_list|)
expr_stmt|;
name|spec_long_long
operator|=
literal|1
expr_stmt|;
block|}
name|spec_long
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
case|case
literal|'j'
case|:
case|case
literal|'J'
case|:
if|if
condition|(
name|spec_imag
condition|)
name|error
argument_list|(
literal|"more than one 'i' or 'j' suffix on integer constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids imaginary numeric constants"
argument_list|)
expr_stmt|;
name|spec_imag
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|ERROR
argument_list|(
literal|"invalid suffix on integer constant"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the literal overflowed, pedwarn about it now.  */
if|if
condition|(
name|overflow
condition|)
block|{
name|warn
operator|=
literal|1
expr_stmt|;
name|pedwarn
argument_list|(
literal|"integer constant is too large for this configuration of the compiler - truncated to %d bits"
argument_list|,
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* This is simplified by the fact that our constant 	 is always positive.  */
name|high
operator|=
name|low
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|/
name|HOST_BITS_PER_CHAR
condition|;
name|i
operator|++
control|)
block|{
name|high
operator||=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|parts
index|[
name|i
operator|+
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
name|HOST_BITS_PER_CHAR
operator|)
index|]
operator|<<
operator|(
name|i
operator|*
name|HOST_BITS_PER_CHAR
operator|)
operator|)
expr_stmt|;
name|low
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
name|parts
index|[
name|i
index|]
operator|<<
operator|(
name|i
operator|*
name|HOST_BITS_PER_CHAR
operator|)
expr_stmt|;
block|}
name|value
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|long_long_unsigned_type_node
expr_stmt|;
comment|/* If warn_traditional, calculate both the ISO type and the 	 traditional type, then see if they disagree. 	 Otherwise, calculate only the type for the dialect in use.  */
if|if
condition|(
name|warn_traditional
operator|||
name|flag_traditional
condition|)
block|{
comment|/* Calculate the traditional type.  */
comment|/* Traditionally, any constant is signed; but if unsigned is 	     specified explicitly, obey that.  Use the smallest size 	     with the right number of bits, except for one special 	     case with decimal constants.  */
if|if
condition|(
operator|!
name|spec_long
operator|&&
name|base
operator|!=
literal|10
operator|&&
name|int_fits_type_p
argument_list|(
name|value
argument_list|,
name|unsigned_type_node
argument_list|)
condition|)
name|trad_type
operator|=
name|spec_unsigned
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
expr_stmt|;
comment|/* A decimal constant must be long if it does not fit in 	     type int.  I think this is independent of whether the 	     constant is signed.  */
elseif|else
if|if
condition|(
operator|!
name|spec_long
operator|&&
name|base
operator|==
literal|10
operator|&&
name|int_fits_type_p
argument_list|(
name|value
argument_list|,
name|integer_type_node
argument_list|)
condition|)
name|trad_type
operator|=
name|spec_unsigned
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|spec_long_long
condition|)
name|trad_type
operator|=
operator|(
name|spec_unsigned
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|int_fits_type_p
argument_list|(
name|value
argument_list|,
name|spec_unsigned
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
argument_list|)
condition|)
name|trad_type
operator|=
operator|(
name|spec_unsigned
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
operator|)
expr_stmt|;
else|else
name|trad_type
operator|=
operator|(
name|spec_unsigned
condition|?
name|widest_unsigned_literal_type_node
else|:
name|widest_integer_literal_type_node
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|warn_traditional
operator|||
operator|!
name|flag_traditional
condition|)
block|{
comment|/* Calculate the ISO type.  */
if|if
condition|(
operator|!
name|spec_long
operator|&&
operator|!
name|spec_unsigned
operator|&&
name|int_fits_type_p
argument_list|(
name|value
argument_list|,
name|integer_type_node
argument_list|)
condition|)
name|ansi_type
operator|=
name|integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|spec_long
operator|&&
operator|(
name|base
operator|!=
literal|10
operator|||
name|spec_unsigned
operator|)
operator|&&
name|int_fits_type_p
argument_list|(
name|value
argument_list|,
name|unsigned_type_node
argument_list|)
condition|)
name|ansi_type
operator|=
name|unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|spec_unsigned
operator|&&
operator|!
name|spec_long_long
operator|&&
name|int_fits_type_p
argument_list|(
name|value
argument_list|,
name|long_integer_type_node
argument_list|)
condition|)
name|ansi_type
operator|=
name|long_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|spec_long_long
operator|&&
name|int_fits_type_p
argument_list|(
name|value
argument_list|,
name|long_unsigned_type_node
argument_list|)
condition|)
name|ansi_type
operator|=
name|long_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|spec_unsigned
operator|&&
name|int_fits_type_p
argument_list|(
name|value
argument_list|,
name|long_long_integer_type_node
argument_list|)
condition|)
name|ansi_type
operator|=
name|long_long_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|int_fits_type_p
argument_list|(
name|value
argument_list|,
name|long_long_unsigned_type_node
argument_list|)
condition|)
name|ansi_type
operator|=
name|long_long_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|spec_unsigned
operator|&&
name|int_fits_type_p
argument_list|(
name|value
argument_list|,
name|widest_integer_literal_type_node
argument_list|)
condition|)
name|ansi_type
operator|=
name|widest_integer_literal_type_node
expr_stmt|;
else|else
name|ansi_type
operator|=
name|widest_unsigned_literal_type_node
expr_stmt|;
block|}
name|type
operator|=
name|flag_traditional
condition|?
name|trad_type
else|:
name|ansi_type
expr_stmt|;
comment|/* We assume that constants specified in a non-decimal 	 base are bit patterns, and that the programmer really 	 meant what they wrote.  */
if|if
condition|(
name|warn_traditional
operator|&&
operator|!
name|in_system_header
operator|&&
name|base
operator|==
literal|10
operator|&&
name|trad_type
operator|!=
name|ansi_type
condition|)
block|{
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|trad_type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|ansi_type
argument_list|)
condition|)
name|warning
argument_list|(
literal|"width of integer constant changes with -traditional"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|trad_type
argument_list|)
operator|!=
name|TREE_UNSIGNED
argument_list|(
name|ansi_type
argument_list|)
condition|)
name|warning
argument_list|(
literal|"integer constant is unsigned in ISO C, signed with -traditional"
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"width of integer constant may change on other systems with -traditional"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|flag_traditional
operator|&&
operator|(
name|flag_isoc99
operator|||
operator|!
name|spec_long_long
operator|)
operator|&&
operator|!
name|warn
operator|&&
operator|(
operator|(
name|flag_isoc99
condition|?
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
else|:
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
operator|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
name|warn
operator|=
literal|1
expr_stmt|;
name|pedwarn
argument_list|(
literal|"integer constant larger than the maximum value of %s"
argument_list|,
operator|(
name|flag_isoc99
condition|?
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|_
argument_list|(
literal|"an unsigned long long int"
argument_list|)
else|:
name|_
argument_list|(
literal|"a long long int"
argument_list|)
operator|)
else|:
name|_
argument_list|(
literal|"an unsigned long int"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|base
operator|==
literal|10
operator|&&
operator|!
name|spec_unsigned
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|warning
argument_list|(
literal|"decimal constant is so large that it is unsigned"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec_imag
condition|)
block|{
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|value
operator|=
name|build_complex
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ERROR
argument_list|(
literal|"complex integer constant is too wide for 'complex int'"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_traditional
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|value
argument_list|,
name|type
argument_list|)
condition|)
comment|/* The traditional constant 0x80000000 is signed 	   but doesn't fit in the range of int. 	   This will change it to -0x80000000, which does fit.  */
block|{
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|unsigned_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|value
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|=
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* If it's still an integer (not a complex), and it doesn't 	 fit in the type we choose for it, then pedwarn.  */
if|if
condition|(
operator|!
name|warn
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|value
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"integer constant is larger than the maximum value for its type"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|<
name|str
operator|+
name|len
condition|)
name|error
argument_list|(
literal|"missing white space after number '%.*s'"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|-
name|str
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
name|value
return|;
name|syntax_error
label|:
return|return
name|integer_zero_node
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|lex_string
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|,
name|wide
parameter_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|int
name|wide
decl_stmt|;
block|{
name|tree
name|value
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
operator|(
name|wide
condition|?
name|WCHAR_BYTES
else|:
literal|1
operator|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|q
init|=
name|buf
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
name|str
decl_stmt|,
modifier|*
name|limit
init|=
name|str
operator|+
name|len
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
name|unsigned
name|width
init|=
name|wide
condition|?
name|WCHAR_TYPE_SIZE
else|:
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
comment|/* Reset multibyte conversion state.  */
operator|(
name|void
operator|)
name|local_mbtowc
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|p
operator|<
name|limit
condition|)
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|wchar_t
name|wc
decl_stmt|;
name|int
name|char_len
decl_stmt|;
name|char_len
operator|=
name|local_mbtowc
argument_list|(
operator|&
name|wc
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
argument_list|,
name|limit
operator|-
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|char_len
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"ignoring invalid multibyte character"
argument_list|)
expr_stmt|;
name|char_len
operator|=
literal|1
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
name|p
operator|+=
name|char_len
expr_stmt|;
name|c
operator|=
name|wc
expr_stmt|;
block|}
else|#
directive|else
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
operator|!
name|ignore_escape_flag
condition|)
block|{
name|unsigned
name|int
name|mask
decl_stmt|;
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_INT
condition|)
name|mask
operator|=
operator|(
operator|(
name|unsigned
name|int
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
else|else
name|mask
operator|=
operator|~
literal|0
expr_stmt|;
name|c
operator|=
name|cpp_parse_escape
argument_list|(
name|parse_in
argument_list|,
operator|&
name|p
argument_list|,
name|limit
argument_list|,
name|mask
argument_list|,
name|flag_traditional
argument_list|)
expr_stmt|;
block|}
comment|/* Add this single character into the buffer either as a wchar_t 	 or as a single byte.  */
if|if
condition|(
name|wide
condition|)
block|{
name|unsigned
name|charwidth
init|=
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
decl_stmt|;
name|unsigned
name|bytemask
init|=
operator|(
literal|1
operator|<<
name|charwidth
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|byte
decl_stmt|;
for|for
control|(
name|byte
operator|=
literal|0
init|;
name|byte
operator|<
name|WCHAR_BYTES
condition|;
operator|++
name|byte
control|)
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|byte
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|c
argument_list|)
condition|)
name|n
operator|=
literal|0
expr_stmt|;
else|else
name|n
operator|=
operator|(
name|c
operator|>>
operator|(
name|byte
operator|*
name|charwidth
operator|)
operator|)
operator|&
name|bytemask
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|q
index|[
name|WCHAR_BYTES
operator|-
name|byte
operator|-
literal|1
index|]
operator|=
name|n
expr_stmt|;
else|else
name|q
index|[
name|byte
index|]
operator|=
name|n
expr_stmt|;
block|}
name|q
operator|+=
name|WCHAR_BYTES
expr_stmt|;
block|}
else|else
block|{
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
comment|/* Terminate the string value, either with a single byte zero      or with a wide zero.  */
if|if
condition|(
name|wide
condition|)
block|{
name|memset
argument_list|(
name|q
argument_list|,
literal|0
argument_list|,
name|WCHAR_BYTES
argument_list|)
expr_stmt|;
name|q
operator|+=
name|WCHAR_BYTES
expr_stmt|;
block|}
else|else
block|{
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
name|value
operator|=
name|build_string
argument_list|(
name|q
operator|-
name|buf
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|wide
condition|)
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|wchar_array_type_node
expr_stmt|;
else|else
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|char_array_type_node
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Converts a (possibly wide) character constant token into a tree.  */
end_comment

begin_function
specifier|static
name|tree
name|lex_charconst
parameter_list|(
name|token
parameter_list|)
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|result
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|value
decl_stmt|;
name|unsigned
name|int
name|chars_seen
decl_stmt|;
name|result
operator|=
name|cpp_interpret_charconst
argument_list|(
name|parse_in
argument_list|,
name|token
argument_list|,
name|warn_multichar
argument_list|,
name|flag_traditional
argument_list|,
operator|&
name|chars_seen
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_WCHAR
condition|)
block|{
name|value
operator|=
name|build_int_2
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|wchar_type_node
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|value
operator|=
name|build_int_2
argument_list|(
name|result
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|build_int_2
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* In C, a character constant has type 'int'.  	 In C++ 'char', but multi-char charconsts have type 'int'.  */
if|if
condition|(
name|c_language
operator|==
name|clk_cplusplus
operator|&&
name|chars_seen
operator|<=
literal|1
condition|)
name|type
operator|=
name|char_type_node
expr_stmt|;
else|else
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* cpp_interpret_charconst issues a warning if the constant      overflows, but if the number fits in HOST_WIDE_INT anyway, it      will return it un-truncated, which may cause problems down the      line.  So set the type to widest_integer_literal_type, call      convert to truncate it to the proper type, then clear      TREE_OVERFLOW so we don't get a second warning.       FIXME: cpplib's assessment of overflow may not be accurate on a      platform where the final type can change at (compiler's) runtime.  */
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|widest_integer_literal_type_node
expr_stmt|;
name|value
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

end_unit

