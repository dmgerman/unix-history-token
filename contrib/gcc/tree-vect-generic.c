begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Lower vector operations to scalar operations.    Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.  This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.     You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"machmode.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"tree-iterator.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_comment
comment|/* Build a constant of type TYPE, made of VALUE's bits replicated    every TYPE_SIZE (INNER_TYPE) bits to fit TYPE's precision.  */
end_comment

begin_function
specifier|static
name|tree
name|build_replicated_const
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|inner_type
parameter_list|,
name|HOST_WIDE_INT
name|value
parameter_list|)
block|{
name|int
name|width
init|=
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|HOST_BITS_PER_WIDE_INT
operator|/
name|width
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|high
decl_stmt|,
name|mask
decl_stmt|;
name|tree
name|ret
decl_stmt|;
name|gcc_assert
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|==
name|HOST_BITS_PER_WIDE_INT
condition|)
name|low
operator|=
name|value
expr_stmt|;
else|else
block|{
name|mask
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
name|low
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|~
literal|0
operator|/
name|mask
operator|*
operator|(
name|value
operator|&
name|mask
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|low
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|)
operator|-
literal|1
operator|,
name|high
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|HOST_BITS_PER_WIDE_INT
condition|)
name|high
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
name|high
operator|=
name|low
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
name|ret
operator|=
name|build_int_cst_wide
argument_list|(
name|type
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|vector_inner_type
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|vector_last_type
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|vector_last_nunits
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Return a suitable vector types made of SUBPARTS units each of mode    "word_mode" (the global variable).  */
end_comment

begin_function
specifier|static
name|tree
name|build_word_mode_vector_type
parameter_list|(
name|int
name|nunits
parameter_list|)
block|{
if|if
condition|(
operator|!
name|vector_inner_type
condition|)
name|vector_inner_type
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|word_mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vector_last_nunits
operator|==
name|nunits
condition|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|vector_last_type
argument_list|)
operator|==
name|VECTOR_TYPE
argument_list|)
expr_stmt|;
return|return
name|vector_last_type
return|;
block|}
comment|/* We build a new type, but we canonicalize it nevertheless,      because it still saves some memory.  */
name|vector_last_nunits
operator|=
name|nunits
expr_stmt|;
name|vector_last_type
operator|=
name|type_hash_canon
argument_list|(
name|nunits
argument_list|,
name|build_vector_type
argument_list|(
name|vector_inner_type
argument_list|,
name|nunits
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|vector_last_type
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|tree
function_decl|(
modifier|*
name|elem_op_func
function_decl|)
parameter_list|(
name|block_stmt_iterator
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|enum
name|tree_code
parameter_list|)
function_decl|;
end_typedef

begin_function
specifier|static
specifier|inline
name|tree
name|tree_vec_extract
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|t
parameter_list|,
name|tree
name|bitsize
parameter_list|,
name|tree
name|bitpos
parameter_list|)
block|{
if|if
condition|(
name|bitpos
condition|)
return|return
name|gimplify_build3
argument_list|(
name|bsi
argument_list|,
name|BIT_FIELD_REF
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|)
return|;
else|else
return|return
name|gimplify_build1
argument_list|(
name|bsi
argument_list|,
name|VIEW_CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|do_unop
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
name|inner_type
parameter_list|,
name|tree
name|a
parameter_list|,
name|tree
name|b
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|bitpos
parameter_list|,
name|tree
name|bitsize
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|)
block|{
name|a
operator|=
name|tree_vec_extract
argument_list|(
name|bsi
argument_list|,
name|inner_type
argument_list|,
name|a
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|)
expr_stmt|;
return|return
name|gimplify_build1
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|inner_type
argument_list|,
name|a
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|do_binop
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
name|inner_type
parameter_list|,
name|tree
name|a
parameter_list|,
name|tree
name|b
parameter_list|,
name|tree
name|bitpos
parameter_list|,
name|tree
name|bitsize
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|)
block|{
name|a
operator|=
name|tree_vec_extract
argument_list|(
name|bsi
argument_list|,
name|inner_type
argument_list|,
name|a
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|)
expr_stmt|;
name|b
operator|=
name|tree_vec_extract
argument_list|(
name|bsi
argument_list|,
name|inner_type
argument_list|,
name|b
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|)
expr_stmt|;
return|return
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|inner_type
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand vector addition to scalars.  This does bit twiddling    in order to increase parallelism:     a + b = (((int) a& 0x7f7f7f7f) + ((int) b& 0x7f7f7f7f)) ^            (a ^ b)& 0x80808080     a - b =  (((int) a | 0x80808080) - ((int) b& 0x7f7f7f7f)) ^             (a ^ ~b)& 0x80808080     -b = (0x80808080 - ((int) b& 0x7f7f7f7f)) ^ (~b& 0x80808080)     This optimization should be done only if 4 vector items or more    fit into a word.  */
end_comment

begin_function
specifier|static
name|tree
name|do_plus_minus
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
name|word_type
parameter_list|,
name|tree
name|a
parameter_list|,
name|tree
name|b
parameter_list|,
name|tree
name|bitpos
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|bitsize
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|)
block|{
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|a
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|max
decl_stmt|;
name|tree
name|low_bits
decl_stmt|,
name|high_bits
decl_stmt|,
name|a_low
decl_stmt|,
name|b_low
decl_stmt|,
name|result_low
decl_stmt|,
name|signs
decl_stmt|;
name|max
operator|=
name|GET_MODE_MASK
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
expr_stmt|;
name|low_bits
operator|=
name|build_replicated_const
argument_list|(
name|word_type
argument_list|,
name|inner_type
argument_list|,
name|max
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|high_bits
operator|=
name|build_replicated_const
argument_list|(
name|word_type
argument_list|,
name|inner_type
argument_list|,
name|max
operator|&
operator|~
operator|(
name|max
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
name|a
operator|=
name|tree_vec_extract
argument_list|(
name|bsi
argument_list|,
name|word_type
argument_list|,
name|a
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|)
expr_stmt|;
name|b
operator|=
name|tree_vec_extract
argument_list|(
name|bsi
argument_list|,
name|word_type
argument_list|,
name|b
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|)
expr_stmt|;
name|signs
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|BIT_XOR_EXPR
argument_list|,
name|word_type
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|b_low
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|BIT_AND_EXPR
argument_list|,
name|word_type
argument_list|,
name|b
argument_list|,
name|low_bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
condition|)
name|a_low
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|BIT_AND_EXPR
argument_list|,
name|word_type
argument_list|,
name|a
argument_list|,
name|low_bits
argument_list|)
expr_stmt|;
else|else
block|{
name|a_low
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|BIT_IOR_EXPR
argument_list|,
name|word_type
argument_list|,
name|a
argument_list|,
name|high_bits
argument_list|)
expr_stmt|;
name|signs
operator|=
name|gimplify_build1
argument_list|(
name|bsi
argument_list|,
name|BIT_NOT_EXPR
argument_list|,
name|word_type
argument_list|,
name|signs
argument_list|)
expr_stmt|;
block|}
name|signs
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|BIT_AND_EXPR
argument_list|,
name|word_type
argument_list|,
name|signs
argument_list|,
name|high_bits
argument_list|)
expr_stmt|;
name|result_low
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|code
argument_list|,
name|word_type
argument_list|,
name|a_low
argument_list|,
name|b_low
argument_list|)
expr_stmt|;
return|return
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|BIT_XOR_EXPR
argument_list|,
name|word_type
argument_list|,
name|result_low
argument_list|,
name|signs
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|do_negate
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
name|word_type
parameter_list|,
name|tree
name|b
parameter_list|,
name|tree
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|bitpos
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|bitsize
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|tree_code
name|code
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|b
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|max
decl_stmt|;
name|tree
name|low_bits
decl_stmt|,
name|high_bits
decl_stmt|,
name|b_low
decl_stmt|,
name|result_low
decl_stmt|,
name|signs
decl_stmt|;
name|max
operator|=
name|GET_MODE_MASK
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
expr_stmt|;
name|low_bits
operator|=
name|build_replicated_const
argument_list|(
name|word_type
argument_list|,
name|inner_type
argument_list|,
name|max
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|high_bits
operator|=
name|build_replicated_const
argument_list|(
name|word_type
argument_list|,
name|inner_type
argument_list|,
name|max
operator|&
operator|~
operator|(
name|max
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
name|b
operator|=
name|tree_vec_extract
argument_list|(
name|bsi
argument_list|,
name|word_type
argument_list|,
name|b
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|)
expr_stmt|;
name|b_low
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|BIT_AND_EXPR
argument_list|,
name|word_type
argument_list|,
name|b
argument_list|,
name|low_bits
argument_list|)
expr_stmt|;
name|signs
operator|=
name|gimplify_build1
argument_list|(
name|bsi
argument_list|,
name|BIT_NOT_EXPR
argument_list|,
name|word_type
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|signs
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|BIT_AND_EXPR
argument_list|,
name|word_type
argument_list|,
name|signs
argument_list|,
name|high_bits
argument_list|)
expr_stmt|;
name|result_low
operator|=
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|MINUS_EXPR
argument_list|,
name|word_type
argument_list|,
name|high_bits
argument_list|,
name|b_low
argument_list|)
expr_stmt|;
return|return
name|gimplify_build2
argument_list|(
name|bsi
argument_list|,
name|BIT_XOR_EXPR
argument_list|,
name|word_type
argument_list|,
name|result_low
argument_list|,
name|signs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand a vector operation to scalars, by using many operations    whose type is the vector type's inner type.  */
end_comment

begin_function
specifier|static
name|tree
name|expand_vector_piecewise
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|elem_op_func
name|f
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|inner_type
parameter_list|,
name|tree
name|a
parameter_list|,
name|tree
name|b
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|)
block|{
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|v
expr_stmt|;
name|tree
name|part_width
init|=
name|TYPE_SIZE
argument_list|(
name|inner_type
argument_list|)
decl_stmt|;
name|tree
name|index
init|=
name|bitsize_int
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|nunits
init|=
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|delta
init|=
name|tree_low_cst
argument_list|(
name|part_width
argument_list|,
literal|1
argument_list|)
operator|/
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|v
operator|=
name|VEC_alloc
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|,
operator|(
name|nunits
operator|+
name|delta
operator|-
literal|1
operator|)
operator|/
name|delta
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nunits
condition|;
name|i
operator|+=
name|delta
operator|,
name|index
operator|=
name|int_const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|index
argument_list|,
name|part_width
argument_list|,
literal|0
argument_list|)
control|)
block|{
name|tree
name|result
init|=
name|f
argument_list|(
name|bsi
argument_list|,
name|inner_type
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|index
argument_list|,
name|part_width
argument_list|,
name|code
argument_list|)
decl_stmt|;
name|constructor_elt
modifier|*
name|ce
init|=
name|VEC_quick_push
argument_list|(
name|constructor_elt
argument_list|,
name|v
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|ce
operator|->
name|index
operator|=
name|NULL_TREE
expr_stmt|;
name|ce
operator|->
name|value
operator|=
name|result
expr_stmt|;
block|}
return|return
name|build_constructor
argument_list|(
name|type
argument_list|,
name|v
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand a vector operation to scalars with the freedom to use    a scalar integer type, or to use a different size for the items    in the vector type.  */
end_comment

begin_function
specifier|static
name|tree
name|expand_vector_parallel
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|elem_op_func
name|f
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|a
parameter_list|,
name|tree
name|b
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|)
block|{
name|tree
name|result
decl_stmt|,
name|compute_type
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|n_words
init|=
name|tree_low_cst
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
comment|/* We have three strategies.  If the type is already correct, just do      the operation an element at a time.  Else, if the vector is wider than      one word, do it a word at a time; finally, if the vector is smaller      than one word, do it as a scalar.  */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|word_mode
condition|)
return|return
name|expand_vector_piecewise
argument_list|(
name|bsi
argument_list|,
name|f
argument_list|,
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|code
argument_list|)
return|;
elseif|else
if|if
condition|(
name|n_words
operator|>
literal|1
condition|)
block|{
name|tree
name|word_type
init|=
name|build_word_mode_vector_type
argument_list|(
name|n_words
argument_list|)
decl_stmt|;
name|result
operator|=
name|expand_vector_piecewise
argument_list|(
name|bsi
argument_list|,
name|f
argument_list|,
name|word_type
argument_list|,
name|TREE_TYPE
argument_list|(
name|word_type
argument_list|)
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|result
operator|=
name|gimplify_val
argument_list|(
name|bsi
argument_list|,
name|word_type
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Use a single scalar operation with a mode no wider than word_mode.  */
name|mode
operator|=
name|mode_for_size
argument_list|(
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|compute_type
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|f
argument_list|(
name|bsi
argument_list|,
name|compute_type
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Expand a vector operation to scalars; for integer types we can use    special bit twiddling tricks to do the sums a word at a time, using    function F_PARALLEL instead of F.  These tricks are done only if    they can process at least four items, that is, only if the vector    holds at least four items and if a word can hold four items.  */
end_comment

begin_function
specifier|static
name|tree
name|expand_vector_addition
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|elem_op_func
name|f
parameter_list|,
name|elem_op_func
name|f_parallel
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|a
parameter_list|,
name|tree
name|b
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|)
block|{
name|int
name|parts_per_word
init|=
name|UNITS_PER_WORD
operator|/
name|tree_low_cst
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|parts_per_word
operator|>=
literal|4
operator|&&
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|type
argument_list|)
operator|>=
literal|4
condition|)
return|return
name|expand_vector_parallel
argument_list|(
name|bsi
argument_list|,
name|f_parallel
argument_list|,
name|type
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|code
argument_list|)
return|;
else|else
return|return
name|expand_vector_piecewise
argument_list|(
name|bsi
argument_list|,
name|f
argument_list|,
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|code
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|expand_vector_operation
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|compute_type
parameter_list|,
name|tree
name|rhs
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|)
block|{
name|enum
name|machine_mode
name|compute_mode
init|=
name|TYPE_MODE
argument_list|(
name|compute_type
argument_list|)
decl_stmt|;
comment|/* If the compute mode is not a vector mode (hence we are not decomposing      a BLKmode vector to smaller, hardware-supported vectors), we may want      to expand the operations in parallel.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|compute_mode
argument_list|)
operator|!=
name|MODE_VECTOR_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|compute_mode
argument_list|)
operator|!=
name|MODE_VECTOR_FLOAT
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
operator|!
name|TYPE_OVERFLOW_TRAPS
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|expand_vector_addition
argument_list|(
name|bsi
argument_list|,
name|do_binop
argument_list|,
name|do_plus_minus
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|code
argument_list|)
return|;
break|break;
case|case
name|NEGATE_EXPR
case|:
if|if
condition|(
operator|!
name|TYPE_OVERFLOW_TRAPS
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|expand_vector_addition
argument_list|(
name|bsi
argument_list|,
name|do_unop
argument_list|,
name|do_negate
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|code
argument_list|)
return|;
break|break;
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
return|return
name|expand_vector_parallel
argument_list|(
name|bsi
argument_list|,
name|do_binop
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|code
argument_list|)
return|;
case|case
name|BIT_NOT_EXPR
case|:
return|return
name|expand_vector_parallel
argument_list|(
name|bsi
argument_list|,
name|do_unop
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|code
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_unary
condition|)
return|return
name|expand_vector_piecewise
argument_list|(
name|bsi
argument_list|,
name|do_unop
argument_list|,
name|type
argument_list|,
name|compute_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|code
argument_list|)
return|;
else|else
return|return
name|expand_vector_piecewise
argument_list|(
name|bsi
argument_list|,
name|do_binop
argument_list|,
name|type
argument_list|,
name|compute_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|code
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a type for the widest vector mode whose components are of mode    INNER_MODE, or NULL_TREE if none is found.  */
end_comment

begin_function
specifier|static
name|tree
name|type_for_widest_vector_mode
parameter_list|(
name|enum
name|machine_mode
name|inner_mode
parameter_list|,
name|optab
name|op
parameter_list|)
block|{
name|enum
name|machine_mode
name|best_mode
init|=
name|VOIDmode
decl_stmt|,
name|mode
decl_stmt|;
name|int
name|best_nunits
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|inner_mode
argument_list|)
condition|)
name|mode
operator|=
name|MIN_MODE_VECTOR_FLOAT
expr_stmt|;
else|else
name|mode
operator|=
name|MIN_MODE_VECTOR_INT
expr_stmt|;
for|for
control|(
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
operator|==
name|inner_mode
operator|&&
name|GET_MODE_NUNITS
argument_list|(
name|mode
argument_list|)
operator|>
name|best_nunits
operator|&&
name|op
operator|->
name|handlers
index|[
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
name|best_mode
operator|=
name|mode
operator|,
name|best_nunits
operator|=
name|GET_MODE_NUNITS
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|best_mode
operator|==
name|VOIDmode
condition|)
return|return
name|NULL_TREE
return|;
else|else
return|return
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|best_mode
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Process one statement.  If we identify a vector operation, expand it.  */
end_comment

begin_function
specifier|static
name|void
name|expand_vector_operations_1
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
operator|*
name|bsi
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|p_lhs
decl_stmt|,
modifier|*
name|p_rhs
decl_stmt|,
name|lhs
decl_stmt|,
name|rhs
decl_stmt|,
name|type
decl_stmt|,
name|compute_type
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|compute_mode
decl_stmt|;
name|optab
name|op
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
case|case
name|RETURN_EXPR
case|:
name|stmt
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stmt
operator|||
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return;
comment|/* FALLTHRU */
case|case
name|MODIFY_EXPR
case|:
name|p_lhs
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p_rhs
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lhs
operator|=
operator|*
name|p_lhs
expr_stmt|;
name|rhs
operator|=
operator|*
name|p_rhs
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|VECTOR_TYPE
condition|)
return|return;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
name|tcc_unary
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
name|tcc_binary
condition|)
return|return;
if|if
condition|(
name|code
operator|==
name|NOP_EXPR
operator|||
name|code
operator|==
name|VIEW_CONVERT_EXPR
condition|)
return|return;
name|gcc_assert
argument_list|(
name|code
operator|!=
name|CONVERT_EXPR
argument_list|)
expr_stmt|;
name|op
operator|=
name|optab_for_tree_code
argument_list|(
name|code
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* For widening vector operations, the relevant type is of the arguments,      not the widened result.  */
if|if
condition|(
name|code
operator|==
name|WIDEN_SUM_EXPR
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Optabs will try converting a negation into a subtraction, so      look for it as well.  TODO: negation of floating-point vectors      might be turned into an exclusive OR toggling the sign bit.  */
if|if
condition|(
name|op
operator|==
name|NULL
operator|&&
name|code
operator|==
name|NEGATE_EXPR
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|op
operator|=
name|optab_for_tree_code
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* For very wide vectors, try using a smaller vector mode.  */
name|compute_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|BLKmode
operator|&&
name|op
condition|)
block|{
name|tree
name|vector_compute_type
init|=
name|type_for_widest_vector_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|vector_compute_type
operator|!=
name|NULL_TREE
condition|)
name|compute_type
operator|=
name|vector_compute_type
expr_stmt|;
block|}
comment|/* If we are breaking a BLKmode vector into smaller pieces,      type_for_widest_vector_mode has already looked into the optab,      so skip these checks.  */
if|if
condition|(
name|compute_type
operator|==
name|type
condition|)
block|{
name|compute_mode
operator|=
name|TYPE_MODE
argument_list|(
name|compute_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|compute_mode
argument_list|)
operator|==
name|MODE_VECTOR_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|compute_mode
argument_list|)
operator|==
name|MODE_VECTOR_FLOAT
operator|)
operator|&&
name|op
operator|!=
name|NULL
operator|&&
name|op
operator|->
name|handlers
index|[
name|compute_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
return|return;
else|else
comment|/* There is no operation in hardware, so fall back to scalars.  */
name|compute_type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|code
operator|!=
name|VEC_LSHIFT_EXPR
operator|&&
name|code
operator|!=
name|VEC_RSHIFT_EXPR
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|expand_vector_operation
argument_list|(
name|bsi
argument_list|,
name|type
argument_list|,
name|compute_type
argument_list|,
name|rhs
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
condition|)
operator|*
name|p_rhs
operator|=
name|rhs
expr_stmt|;
else|else
operator|*
name|p_rhs
operator|=
name|gimplify_build1
argument_list|(
name|bsi
argument_list|,
name|VIEW_CONVERT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
name|mark_stmt_modified
argument_list|(
name|bsi_stmt
argument_list|(
operator|*
name|bsi
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Use this to lower vector operations introduced by the vectorizer,    if it may need the bit-twiddling tricks implemented in this file.  */
end_comment

begin_function
specifier|static
name|bool
name|gate_expand_vector_operations
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_tree_vectorize
operator|!=
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|expand_vector_operations
parameter_list|(
name|void
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|expand_vector_operations_1
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
name|update_stmt_if_modified
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_lower_vector
init|=
block|{
literal|"veclower"
block|,
comment|/* name */
literal|0
block|,
comment|/* gate */
name|expand_vector_operations
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
name|PROP_cfg
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_ggc_collect
operator||
name|TODO_verify_stmts
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_lower_vector_ssa
init|=
block|{
literal|"veclower2"
block|,
comment|/* name */
name|gate_expand_vector_operations
block|,
comment|/* gate */
name|expand_vector_operations
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
name|PROP_cfg
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_update_ssa
comment|/* todo_flags_finish */
operator||
name|TODO_verify_ssa
operator||
name|TODO_verify_stmts
operator||
name|TODO_verify_flow
block|,
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"gt-tree-vect-generic.h"
end_include

end_unit

