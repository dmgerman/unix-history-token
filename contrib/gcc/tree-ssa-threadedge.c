begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* SSA Jump Threading    Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.    Contributed by Jeff Law<law@redhat.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"domwalk.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"tree-ssa-propagate.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_comment
comment|/* To avoid code explosion due to jump threading, we limit the    number of statements we are going to copy.  This variable    holds the number of statements currently seen that we'll have    to copy as part of the jump threading process.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stmt_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return TRUE if we may be able to thread an incoming edge into    BB to an outgoing edge from BB.  Return FALSE otherwise.  */
end_comment

begin_function
name|bool
name|potentially_threadable_block
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
comment|/* If BB has a single successor or a single predecessor, then      there is no threading opportunity.  */
if|if
condition|(
name|single_succ_p
argument_list|(
name|bb
argument_list|)
operator|||
name|single_pred_p
argument_list|(
name|bb
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If BB does not end with a conditional, switch or computed goto,      then there is no threading opportunity.  */
name|bsi
operator|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
operator|||
operator|!
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
operator|!=
name|COND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
operator|!=
name|GOTO_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
operator|!=
name|SWITCH_EXPR
operator|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return the LHS of any ASSERT_EXPR where OP appears as the first    argument to the ASSERT_EXPR and in which the ASSERT_EXPR dominates    BB.  If no such ASSERT_EXPR is found, return OP.  */
end_comment

begin_function
specifier|static
name|tree
name|lhs_of_dominating_assert
parameter_list|(
name|tree
name|op
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|imm_use_iterator
name|imm_iter
decl_stmt|;
name|tree
name|use_stmt
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|FOR_EACH_IMM_USE_FAST
argument_list|(
argument|use_p
argument_list|,
argument|imm_iter
argument_list|,
argument|op
argument_list|)
block|{
name|use_stmt
operator|=
name|USE_STMT
argument_list|(
name|use_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_stmt
operator|!=
name|stmt
operator|&&
name|TREE_CODE
argument_list|(
name|use_stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|use_stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|ASSERT_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|use_stmt
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|op
operator|&&
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|,
name|bb_for_stmt
argument_list|(
name|use_stmt
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|TREE_OPERAND
argument_list|(
name|use_stmt
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
return|return
name|op
return|;
block|}
end_function

begin_comment
comment|/* We record temporary equivalences created by PHI nodes or    statements within the target block.  Doing so allows us to    identify more jump threading opportunities, even in blocks    with side effects.     We keep track of those temporary equivalences in a stack    structure so that we can unwind them when we're done processing    a particular edge.  This routine handles unwinding the data    structures.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|remove_temporary_equivalences
argument_list|(
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|stack
argument_list|)
block|{
while|while
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
operator|*
name|stack
argument_list|)
operator|>
literal|0
condition|)
block|{
name|tree
name|prev_value
decl_stmt|,
name|dest
decl_stmt|;
name|dest
operator|=
name|VEC_pop
argument_list|(
name|tree
argument_list|,
operator|*
name|stack
argument_list|)
expr_stmt|;
comment|/* A NULL value indicates we should stop unwinding, otherwise 	 pop off the next entry as they're recorded in pairs.  */
if|if
condition|(
name|dest
operator|==
name|NULL
condition|)
break|break;
name|prev_value
operator|=
name|VEC_pop
argument_list|(
name|tree
argument_list|,
operator|*
name|stack
argument_list|)
expr_stmt|;
name|SSA_NAME_VALUE
argument_list|(
name|dest
argument_list|)
operator|=
name|prev_value
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Record a temporary equivalence, saving enough information so that    we can restore the state of recorded equivalences when we're    done processing the current edge.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|record_temporary_equivalence
argument_list|(
name|tree
name|x
argument_list|,
name|tree
name|y
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|stack
argument_list|)
block|{
name|tree
name|prev_x
init|=
name|SSA_NAME_VALUE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|tree
name|tmp
init|=
name|SSA_NAME_VALUE
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|y
operator|=
name|tmp
condition|?
name|tmp
else|:
name|y
expr_stmt|;
block|}
name|SSA_NAME_VALUE
argument_list|(
name|x
argument_list|)
operator|=
name|y
expr_stmt|;
name|VEC_reserve
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
operator|*
name|stack
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|VEC_quick_push
argument_list|(
name|tree
argument_list|,
operator|*
name|stack
argument_list|,
name|prev_x
argument_list|)
expr_stmt|;
name|VEC_quick_push
argument_list|(
name|tree
argument_list|,
operator|*
name|stack
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Record temporary equivalences created by PHIs at the target of the    edge E.  Record unwind information for the equivalences onto STACK.      If a PHI which prevents threading is encountered, then return FALSE    indicating we should not thread this edge, else return TRUE.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|record_temporary_equivalences_from_phis
argument_list|(
name|edge
name|e
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|stack
argument_list|)
block|{
name|tree
name|phi
decl_stmt|;
comment|/* Each PHI creates a temporary equivalence, record them.      These are context sensitive equivalences and will be removed      later.  */
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|e
operator|->
name|dest
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|tree
name|src
init|=
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|phi
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|tree
name|dst
init|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
decl_stmt|;
comment|/* If the desired argument is not the same as this PHI's result  	 and it is set by a PHI in E->dest, then we can not thread 	 through E->dest.  */
if|if
condition|(
name|src
operator|!=
name|dst
operator|&&
name|TREE_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|TREE_CODE
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|src
argument_list|)
argument_list|)
operator|==
name|PHI_NODE
operator|&&
name|bb_for_stmt
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|src
argument_list|)
argument_list|)
operator|==
name|e
operator|->
name|dest
condition|)
return|return
name|false
return|;
comment|/* We consider any non-virtual PHI as a statement since it 	 count result in a constant assignment or copy operation.  */
if|if
condition|(
name|is_gimple_reg
argument_list|(
name|dst
argument_list|)
condition|)
name|stmt_count
operator|++
expr_stmt|;
name|record_temporary_equivalence
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|stack
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Try to simplify each statement in E->dest, ultimately leading to    a simplification of the COND_EXPR at the end of E->dest.     Record unwind information for temporary equivalences onto STACK.     Use SIMPLIFY (a pointer to a callback function) to further simplify    statements using pass specific information.      We might consider marking just those statements which ultimately    feed the COND_EXPR.  It's not clear if the overhead of bookkeeping    would be recovered by trying to simplify fewer statements.     If we are able to simplify a statement into the form    SSA_NAME = (SSA_NAME | gimple invariant), then we can record    a context sensitive equivalency which may help us simplify    later statements in E->dest.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|record_temporary_equivalences_from_stmts_at_dest
argument_list|(
name|edge
name|e
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|stack
argument_list|,
name|tree
argument_list|(
operator|*
name|simplify
argument_list|)
argument_list|(
name|tree
argument_list|,
name|tree
argument_list|)
argument_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|stmt
init|=
name|NULL
decl_stmt|;
name|int
name|max_stmt_count
decl_stmt|;
name|max_stmt_count
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_JUMP_THREAD_DUPLICATION_STMTS
argument_list|)
expr_stmt|;
comment|/* Walk through each statement in the block recording equivalences      we discover.  Note any equivalences we discover are context      sensitive (ie, are dependent on traversing E) and must be unwound      when we're finished processing E.  */
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|e
operator|->
name|dest
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|cached_lhs
init|=
name|NULL
decl_stmt|;
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
comment|/* Ignore empty statements and labels.  */
if|if
condition|(
name|IS_EMPTY_STMT
argument_list|(
name|stmt
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|LABEL_EXPR
condition|)
continue|continue;
comment|/* If the statement has volatile operands, then we assume we 	 can not thread through this block.  This is overly 	 conservative in some ways.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|ASM_EXPR
operator|&&
name|ASM_VOLATILE_P
argument_list|(
name|stmt
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* If duplicating this block is going to cause too much code 	 expansion, then do not thread through this block.  */
name|stmt_count
operator|++
expr_stmt|;
if|if
condition|(
name|stmt_count
operator|>
name|max_stmt_count
condition|)
return|return
name|NULL
return|;
comment|/* If this is not a MODIFY_EXPR which sets an SSA_NAME to a new 	 value, then do not try to simplify this statement as it will 	 not simplify in any way that is helpful for jump threading.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SSA_NAME
condition|)
continue|continue;
comment|/* At this point we have a statement which assigns an RHS to an 	 SSA_VAR on the LHS.  We want to try and simplify this statement 	 to expose more context sensitive equivalences which in turn may 	 allow us to simplify the condition at the end of the loop.   	 Handle simple copy operations as well as implied copies from 	 ASSERT_EXPRs.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|cached_lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|ASSERT_EXPR
condition|)
name|cached_lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* A statement that is not a trivial copy or ASSERT_EXPR. 	     We're going to temporarily copy propagate the operands 	     and see if that allows us to simplify this statement.  */
name|tree
modifier|*
name|copy
decl_stmt|,
name|pre_fold_expr
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|unsigned
name|int
name|num
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|num
operator|=
name|NUM_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
operator|(
name|SSA_OP_USE
operator||
name|SSA_OP_VUSE
operator|)
argument_list|)
expr_stmt|;
name|copy
operator|=
name|XCNEWVEC
argument_list|(
name|tree
argument_list|,
name|num
argument_list|)
expr_stmt|;
comment|/* Make a copy of the uses& vuses into USES_COPY, then cprop into 	     the operands.  */
name|FOR_EACH_SSA_USE_OPERAND
argument_list|(
argument|use_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE | SSA_OP_VUSE
argument_list|)
block|{
name|tree
name|tmp
init|=
name|NULL
decl_stmt|;
name|tree
name|use
init|=
name|USE_FROM_PTR
argument_list|(
name|use_p
argument_list|)
decl_stmt|;
name|copy
index|[
name|i
operator|++
index|]
operator|=
name|use
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|use
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|tmp
operator|=
name|SSA_NAME_VALUE
argument_list|(
name|use
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&&
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|VALUE_HANDLE
condition|)
name|SET_USE
argument_list|(
name|use_p
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* Try to fold/lookup the new expression.  Inserting the 	     expression into the hash table is unlikely to help 	     Sadly, we have to handle conditional assignments specially 	     here, because fold expects all the operands of an expression 	     to be folded before the expression itself is folded, but we 	     can't just substitute the folded condition here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|tree
name|cond
init|=
name|COND_EXPR_COND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|cond
operator|=
name|fold
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|==
name|boolean_true_node
condition|)
name|pre_fold_expr
operator|=
name|COND_EXPR_THEN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cond
operator|==
name|boolean_false_node
condition|)
name|pre_fold_expr
operator|=
name|COND_EXPR_ELSE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pre_fold_expr
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|pre_fold_expr
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre_fold_expr
condition|)
block|{
name|cached_lhs
operator|=
name|fold
argument_list|(
name|pre_fold_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cached_lhs
argument_list|)
operator|!=
name|SSA_NAME
operator|&&
operator|!
name|is_gimple_min_invariant
argument_list|(
name|cached_lhs
argument_list|)
condition|)
name|cached_lhs
operator|=
call|(
modifier|*
name|simplify
call|)
argument_list|(
name|stmt
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the statement's original uses/defs.  */
name|i
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_SSA_USE_OPERAND
argument_list|(
argument|use_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE | SSA_OP_VUSE
argument_list|)
name|SET_USE
argument_list|(
name|use_p
argument_list|,
name|copy
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|copy
argument_list|)
expr_stmt|;
block|}
comment|/* Record the context sensitive equivalence if we were able 	 to simplify this statement.  */
if|if
condition|(
name|cached_lhs
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|cached_lhs
argument_list|)
operator|==
name|SSA_NAME
operator|||
name|is_gimple_min_invariant
argument_list|(
name|cached_lhs
argument_list|)
operator|)
condition|)
name|record_temporary_equivalence
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cached_lhs
argument_list|,
name|stack
argument_list|)
expr_stmt|;
block|}
return|return
name|stmt
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Simplify the control statement at the end of the block E->dest.     To avoid allocating memory unnecessarily, a scratch COND_EXPR    is available to use/clobber in DUMMY_COND.     Use SIMPLIFY (a pointer to a callback function) to further simplify    a condition using pass specific information.     Return the simplified condition or NULL if simplification could    not be performed.  */
end_comment

begin_function
specifier|static
name|tree
name|simplify_control_stmt_condition
parameter_list|(
name|edge
name|e
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|tree
name|dummy_cond
parameter_list|,
name|tree
function_decl|(
modifier|*
name|simplify
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
parameter_list|,
name|bool
name|handle_dominating_asserts
parameter_list|)
block|{
name|tree
name|cond
decl_stmt|,
name|cached_lhs
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
condition|)
name|cond
operator|=
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|GOTO_EXPR
condition|)
name|cond
operator|=
name|GOTO_DESTINATION
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
else|else
name|cond
operator|=
name|SWITCH_COND
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* For comparisons, we have to update both operands, then try      to simplify the comparison.  */
if|if
condition|(
name|COMPARISON_CLASS_P
argument_list|(
name|cond
argument_list|)
condition|)
block|{
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|enum
name|tree_code
name|cond_code
decl_stmt|;
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cond_code
operator|=
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
comment|/* Get the current value of both operands.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|tree
name|tmp
init|=
name|SSA_NAME_VALUE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|&&
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|VALUE_HANDLE
condition|)
name|op0
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|tree
name|tmp
init|=
name|SSA_NAME_VALUE
argument_list|(
name|op1
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|&&
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|VALUE_HANDLE
condition|)
name|op1
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|handle_dominating_asserts
condition|)
block|{
comment|/* Now see if the operand was consumed by an ASSERT_EXPR 	     which dominates E->src.  If so, we want to replace the 	     operand with the LHS of the ASSERT_EXPR.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|op0
operator|=
name|lhs_of_dominating_assert
argument_list|(
name|op0
argument_list|,
name|e
operator|->
name|src
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|op1
operator|=
name|lhs_of_dominating_assert
argument_list|(
name|op1
argument_list|,
name|e
operator|->
name|src
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
comment|/* We may need to canonicalize the comparison.  For 	 example, op0 might be a constant while op1 is an 	 SSA_NAME.  Failure to canonicalize will cause us to 	 miss threading opportunities.  */
if|if
condition|(
name|cond_code
operator|!=
name|SSA_NAME
operator|&&
name|tree_swap_operands_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|false
argument_list|)
condition|)
block|{
name|tree
name|tmp
decl_stmt|;
name|cond_code
operator|=
name|swap_tree_comparison
argument_list|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Stuff the operator and operands into our dummy conditional 	 expression.  */
name|TREE_SET_CODE
argument_list|(
name|COND_EXPR_COND
argument_list|(
name|dummy_cond
argument_list|)
argument_list|,
name|cond_code
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|COND_EXPR_COND
argument_list|(
name|dummy_cond
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|op0
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|COND_EXPR_COND
argument_list|(
name|dummy_cond
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|=
name|op1
expr_stmt|;
comment|/* We absolutely do not care about any type conversions          we only care about a zero/nonzero value.  */
name|fold_defer_overflow_warnings
argument_list|()
expr_stmt|;
name|cached_lhs
operator|=
name|fold
argument_list|(
name|COND_EXPR_COND
argument_list|(
name|dummy_cond
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|cached_lhs
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|cached_lhs
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|cached_lhs
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|cached_lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|cached_lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fold_undefer_overflow_warnings
argument_list|(
name|is_gimple_min_invariant
argument_list|(
name|cached_lhs
argument_list|)
argument_list|,
name|stmt
argument_list|,
name|WARN_STRICT_OVERFLOW_CONDITIONAL
argument_list|)
expr_stmt|;
comment|/* If we have not simplified the condition down to an invariant, 	 then use the pass specific callback to simplify the condition.  */
if|if
condition|(
operator|!
name|is_gimple_min_invariant
argument_list|(
name|cached_lhs
argument_list|)
condition|)
name|cached_lhs
operator|=
call|(
modifier|*
name|simplify
call|)
argument_list|(
name|dummy_cond
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
comment|/* We can have conditionals which just test the state of a variable      rather than use a relational operator.  These are simpler to handle.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|cached_lhs
operator|=
name|cond
expr_stmt|;
comment|/* Get the variable's current value from the equivalency chains.  	 It is possible to get loops in the SSA_NAME_VALUE chains 	 (consider threading the backedge of a loop where we have 	 a loop invariant SSA_NAME used in the condition.  */
if|if
condition|(
name|cached_lhs
operator|&&
name|TREE_CODE
argument_list|(
name|cached_lhs
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|SSA_NAME_VALUE
argument_list|(
name|cached_lhs
argument_list|)
condition|)
name|cached_lhs
operator|=
name|SSA_NAME_VALUE
argument_list|(
name|cached_lhs
argument_list|)
expr_stmt|;
comment|/* If we're dominated by a suitable ASSERT_EXPR, then 	 update CACHED_LHS appropriately.  */
if|if
condition|(
name|handle_dominating_asserts
operator|&&
name|TREE_CODE
argument_list|(
name|cached_lhs
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|cached_lhs
operator|=
name|lhs_of_dominating_assert
argument_list|(
name|cached_lhs
argument_list|,
name|e
operator|->
name|src
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
comment|/* If we haven't simplified to an invariant yet, then use the 	 pass specific callback to try and simplify it further.  */
if|if
condition|(
name|cached_lhs
operator|&&
operator|!
name|is_gimple_min_invariant
argument_list|(
name|cached_lhs
argument_list|)
condition|)
name|cached_lhs
operator|=
call|(
modifier|*
name|simplify
call|)
argument_list|(
name|stmt
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
else|else
name|cached_lhs
operator|=
name|NULL
expr_stmt|;
return|return
name|cached_lhs
return|;
block|}
end_function

begin_comment
comment|/* We are exiting E->src, see if E->dest ends with a conditional    jump which has a known value when reached via E.      Special care is necessary if E is a back edge in the CFG as we    may have already recorded equivalences for E->dest into our    various tables, including the result of the conditional at    the end of E->dest.  Threading opportunities are severely    limited in that case to avoid short-circuiting the loop    incorrectly.     Note it is quite common for the first block inside a loop to    end with a conditional which is either always true or always    false when reached via the loop backedge.  Thus we do not want    to blindly disable threading across a loop backedge.  */
end_comment

begin_decl_stmt
name|void
name|thread_across_edge
argument_list|(
name|tree
name|dummy_cond
argument_list|,
name|edge
name|e
argument_list|,
name|bool
name|handle_dominating_asserts
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|stack
argument_list|,
name|tree
argument_list|(
operator|*
name|simplify
argument_list|)
argument_list|(
name|tree
argument_list|,
name|tree
argument_list|)
argument_list|)
block|{
name|tree
name|stmt
decl_stmt|;
comment|/* If E is a backedge, then we want to verify that the COND_EXPR,      SWITCH_EXPR or GOTO_EXPR at the end of e->dest is not affected      by any statements in e->dest.  If it is affected, then it is not      safe to thread this edge.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
condition|)
block|{
name|ssa_op_iter
name|iter
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|tree
name|last
init|=
name|bsi_stmt
argument_list|(
name|bsi_last
argument_list|(
name|e
operator|->
name|dest
argument_list|)
argument_list|)
decl_stmt|;
name|FOR_EACH_SSA_USE_OPERAND
argument_list|(
argument|use_p
argument_list|,
argument|last
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE | SSA_OP_VUSE
argument_list|)
block|{
name|tree
name|use
init|=
name|USE_FROM_PTR
argument_list|(
name|use_p
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|use
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|TREE_CODE
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|use
argument_list|)
argument_list|)
operator|!=
name|PHI_NODE
operator|&&
name|bb_for_stmt
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|use
argument_list|)
argument_list|)
operator|==
name|e
operator|->
name|dest
condition|)
goto|goto
name|fail
goto|;
block|}
block|}
name|stmt_count
operator|=
literal|0
expr_stmt|;
comment|/* PHIs create temporary equivalences.  */
if|if
condition|(
operator|!
name|record_temporary_equivalences_from_phis
argument_list|(
name|e
argument_list|,
name|stack
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* Now walk each statement recording any context sensitive      temporary equivalences we can detect.  */
name|stmt
operator|=
name|record_temporary_equivalences_from_stmts_at_dest
argument_list|(
name|e
argument_list|,
name|stack
argument_list|,
name|simplify
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stmt
condition|)
goto|goto
name|fail
goto|;
comment|/* If we stopped at a COND_EXPR or SWITCH_EXPR, see if we know which arm      will be taken.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|GOTO_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|SWITCH_EXPR
condition|)
block|{
name|tree
name|cond
decl_stmt|;
comment|/* Extract and simplify the condition.  */
name|cond
operator|=
name|simplify_control_stmt_condition
argument_list|(
name|e
argument_list|,
name|stmt
argument_list|,
name|dummy_cond
argument_list|,
name|simplify
argument_list|,
name|handle_dominating_asserts
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|&&
name|is_gimple_min_invariant
argument_list|(
name|cond
argument_list|)
condition|)
block|{
name|edge
name|taken_edge
init|=
name|find_taken_edge
argument_list|(
name|e
operator|->
name|dest
argument_list|,
name|cond
argument_list|)
decl_stmt|;
name|basic_block
name|dest
init|=
operator|(
name|taken_edge
condition|?
name|taken_edge
operator|->
name|dest
else|:
name|NULL
operator|)
decl_stmt|;
if|if
condition|(
name|dest
operator|==
name|e
operator|->
name|dest
condition|)
goto|goto
name|fail
goto|;
name|remove_temporary_equivalences
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|register_jump_thread
argument_list|(
name|e
argument_list|,
name|taken_edge
argument_list|)
expr_stmt|;
block|}
block|}
name|fail
label|:
name|remove_temporary_equivalences
argument_list|(
name|stack
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

end_unit

