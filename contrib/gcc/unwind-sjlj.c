begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* DWARF2 exception handling and frame unwind runtime interface routines.    Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"tconfig.h"
end_include

begin_include
include|#
directive|include
file|"tsystem.h"
end_include

begin_include
include|#
directive|include
file|"unwind.h"
end_include

begin_include
include|#
directive|include
file|"gthr.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__USING_SJLJ_EXCEPTIONS__
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|DONT_USE_BUILTIN_SETJMP
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|inhibit_libc
end_ifndef

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|void
modifier|*
name|jmp_buf
index|[
name|JMP_BUF_SIZE
index|]
typedef|;
end_typedef

begin_function_decl
specifier|extern
name|void
name|longjmp
parameter_list|(
name|jmp_buf
parameter_list|,
name|int
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(noreturn
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|setjmp
value|__builtin_setjmp
end_define

begin_define
define|#
directive|define
name|longjmp
value|__builtin_longjmp
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This structure is allocated on the stack of the target function.    This must match the definition created in except.c:init_eh.  */
end_comment

begin_struct
struct|struct
name|SjLj_Function_Context
block|{
comment|/* This is the chain through all registered contexts.  It is      filled in by _Unwind_SjLj_Register.  */
name|struct
name|SjLj_Function_Context
modifier|*
name|prev
decl_stmt|;
comment|/* This is assigned in by the target function before every call      to the index of the call site in the lsda.  It is assigned by      the personality routine to the landing pad index.  */
name|int
name|call_site
decl_stmt|;
comment|/* This is how data is returned from the personality routine to      the target function's handler.  */
name|_Unwind_Word
name|data
index|[
literal|4
index|]
decl_stmt|;
comment|/* These are filled in once by the target function before any      exceptions are expected to be handled.  */
name|_Unwind_Personality_Fn
name|personality
decl_stmt|;
name|void
modifier|*
name|lsda
decl_stmt|;
ifdef|#
directive|ifdef
name|DONT_USE_BUILTIN_SETJMP
comment|/* We don't know what sort of alignment requirements the system      jmp_buf has.  We over estimated in except.c, and now we have      to match that here just in case the system *didn't* have more       restrictive requirements.  */
name|jmp_buf
name|jbuf
name|__attribute__
argument_list|(
operator|(
name|aligned
operator|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|void
modifier|*
name|jbuf
index|[]
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_Unwind_Context
block|{
name|struct
name|SjLj_Function_Context
modifier|*
name|fc
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
block|{
name|_Unwind_Personality_Fn
name|personality
decl_stmt|;
block|}
name|_Unwind_FrameState
typedef|;
end_typedef

begin_escape
end_escape

begin_comment
comment|/* Manage the chain of registered function contexts.  */
end_comment

begin_comment
comment|/* Single threaded fallback chain.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|SjLj_Function_Context
modifier|*
name|fc_static
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|__GTHREADS
end_if

begin_decl_stmt
specifier|static
name|__gthread_key_t
name|fc_key
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|use_fc_key
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|fc_key_dtor
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|__gthread_key_dtor
argument_list|(
name|fc_key
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fc_key_init
parameter_list|(
name|void
parameter_list|)
block|{
name|use_fc_key
operator|=
name|__gthread_key_create
argument_list|(
operator|&
name|fc_key
argument_list|,
name|fc_key_dtor
argument_list|)
operator|==
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fc_key_init_once
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|__gthread_once_t
name|once
init|=
name|__GTHREAD_ONCE_INIT
decl_stmt|;
if|if
condition|(
name|__gthread_once
argument_list|(
operator|&
name|once
argument_list|,
name|fc_key_init
argument_list|)
operator|!=
literal|0
operator|||
name|use_fc_key
operator|<
literal|0
condition|)
name|use_fc_key
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|_Unwind_SjLj_Register
parameter_list|(
name|struct
name|SjLj_Function_Context
modifier|*
name|fc
parameter_list|)
block|{
if|#
directive|if
name|__GTHREADS
if|if
condition|(
name|use_fc_key
operator|<
literal|0
condition|)
name|fc_key_init_once
argument_list|()
expr_stmt|;
if|if
condition|(
name|use_fc_key
condition|)
block|{
name|fc
operator|->
name|prev
operator|=
name|__gthread_getspecific
argument_list|(
name|fc_key
argument_list|)
expr_stmt|;
name|__gthread_setspecific
argument_list|(
name|fc_key
argument_list|,
name|fc
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|fc
operator|->
name|prev
operator|=
name|fc_static
expr_stmt|;
name|fc_static
operator|=
name|fc
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|SjLj_Function_Context
modifier|*
name|_Unwind_SjLj_GetContext
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|__GTHREADS
if|if
condition|(
name|use_fc_key
operator|<
literal|0
condition|)
name|fc_key_init_once
argument_list|()
expr_stmt|;
if|if
condition|(
name|use_fc_key
condition|)
return|return
name|__gthread_getspecific
argument_list|(
name|fc_key
argument_list|)
return|;
endif|#
directive|endif
return|return
name|fc_static
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|_Unwind_SjLj_SetContext
parameter_list|(
name|struct
name|SjLj_Function_Context
modifier|*
name|fc
parameter_list|)
block|{
if|#
directive|if
name|__GTHREADS
if|if
condition|(
name|use_fc_key
operator|<
literal|0
condition|)
name|fc_key_init_once
argument_list|()
expr_stmt|;
if|if
condition|(
name|use_fc_key
condition|)
name|__gthread_setspecific
argument_list|(
name|fc_key
argument_list|,
name|fc
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|fc_static
operator|=
name|fc
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_Unwind_SjLj_Unregister
parameter_list|(
name|struct
name|SjLj_Function_Context
modifier|*
name|fc
parameter_list|)
block|{
name|_Unwind_SjLj_SetContext
argument_list|(
name|fc
operator|->
name|prev
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get/set the return data value at INDEX in CONTEXT.  */
end_comment

begin_function
name|_Unwind_Word
name|_Unwind_GetGR
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|int
name|index
parameter_list|)
block|{
return|return
name|context
operator|->
name|fc
operator|->
name|data
index|[
name|index
index|]
return|;
block|}
end_function

begin_function
name|void
name|_Unwind_SetGR
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|int
name|index
parameter_list|,
name|_Unwind_Word
name|val
parameter_list|)
block|{
name|context
operator|->
name|fc
operator|->
name|data
index|[
name|index
index|]
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the call-site index as saved in CONTEXT.  */
end_comment

begin_function
name|_Unwind_Ptr
name|_Unwind_GetIP
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
name|context
operator|->
name|fc
operator|->
name|call_site
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Set the return landing pad index in CONTEXT.  */
end_comment

begin_function
name|void
name|_Unwind_SetIP
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_Ptr
name|val
parameter_list|)
block|{
name|context
operator|->
name|fc
operator|->
name|call_site
operator|=
name|val
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|_Unwind_GetLanguageSpecificData
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
name|context
operator|->
name|fc
operator|->
name|lsda
return|;
block|}
end_function

begin_decl_stmt
name|_Unwind_Ptr
name|_Unwind_GetRegionStart
argument_list|(
expr|struct
name|_Unwind_Context
operator|*
name|context
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|)
block|{
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__ia64__
end_ifndef

begin_decl_stmt
name|_Unwind_Ptr
name|_Unwind_GetDataRelBase
argument_list|(
expr|struct
name|_Unwind_Context
operator|*
name|context
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|)
block|{
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|_Unwind_Ptr
name|_Unwind_GetTextRelBase
argument_list|(
expr|struct
name|_Unwind_Context
operator|*
name|context
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|)
block|{
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_function
specifier|static
specifier|inline
name|_Unwind_Reason_Code
name|uw_frame_state_for
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_FrameState
modifier|*
name|fs
parameter_list|)
block|{
if|if
condition|(
name|context
operator|->
name|fc
operator|==
name|NULL
condition|)
block|{
name|fs
operator|->
name|personality
operator|=
name|NULL
expr_stmt|;
return|return
name|_URC_END_OF_STACK
return|;
block|}
else|else
block|{
name|fs
operator|->
name|personality
operator|=
name|context
operator|->
name|fc
operator|->
name|personality
expr_stmt|;
return|return
name|_URC_NO_REASON
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|uw_update_context
argument_list|(
expr|struct
name|_Unwind_Context
operator|*
name|context
argument_list|,
name|_Unwind_FrameState
operator|*
name|fs
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|)
block|{
name|context
operator|->
name|fc
operator|=
name|context
operator|->
name|fc
operator|->
name|prev
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|void
name|uw_init_context
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
name|context
operator|->
name|fc
operator|=
name|_Unwind_SjLj_GetContext
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ??? There appear to be bugs in integrate.c wrt __builtin_longjmp and    virtual-stack-vars.  An inline version of this segfaults on Sparc.  */
end_comment

begin_define
define|#
directive|define
name|uw_install_context
parameter_list|(
name|CURRENT
parameter_list|,
name|TARGET
parameter_list|)
define|\
value|do							\     {							\       _Unwind_SjLj_SetContext ((TARGET)->fc);		\       longjmp ((TARGET)->fc->jbuf, 1);			\     }							\   while (0)
end_define

begin_function
specifier|static
specifier|inline
name|_Unwind_Ptr
name|uw_identify_context
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
operator|(
name|_Unwind_Ptr
operator|)
name|context
operator|->
name|fc
return|;
block|}
end_function

begin_comment
comment|/* Play games with unwind symbols so that we can have call frame    and sjlj symbols in the same shared library.  Not that you can    use them simultaneously...  */
end_comment

begin_define
define|#
directive|define
name|_Unwind_RaiseException
value|_Unwind_SjLj_RaiseException
end_define

begin_define
define|#
directive|define
name|_Unwind_ForcedUnwind
value|_Unwind_SjLj_ForcedUnwind
end_define

begin_define
define|#
directive|define
name|_Unwind_Resume
value|_Unwind_SjLj_Resume
end_define

begin_include
include|#
directive|include
file|"unwind.inc"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USING_SJLJ_EXCEPTIONS */
end_comment

end_unit

