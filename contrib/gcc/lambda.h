begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Lambda matrix and vector interface.    Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.    Contributed by Daniel Berlin<dberlin@dberlin.org>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LAMBDA_H
end_ifndef

begin_define
define|#
directive|define
name|LAMBDA_H
end_define

begin_include
include|#
directive|include
file|"vec.h"
end_include

begin_comment
comment|/* An integer vector.  A vector formally consists of an element of a vector    space. A vector space is a set that is closed under vector addition    and scalar multiplication.  In this vector space, an element is a list of    integers.  */
end_comment

begin_typedef
typedef|typedef
name|int
modifier|*
name|lambda_vector
typedef|;
end_typedef

begin_expr_stmt
name|DEF_VEC_P
argument_list|(
name|lambda_vector
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|lambda_vector
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* An integer matrix.  A matrix consists of m vectors of length n (IE    all vectors are the same length).  */
end_comment

begin_typedef
typedef|typedef
name|lambda_vector
modifier|*
name|lambda_matrix
typedef|;
end_typedef

begin_comment
comment|/* A transformation matrix, which is a self-contained ROWSIZE x COLSIZE    matrix.  Rather than use floats, we simply keep a single DENOMINATOR that    represents the denominator for every element in the matrix.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|lambda_matrix
name|matrix
decl_stmt|;
name|int
name|rowsize
decl_stmt|;
name|int
name|colsize
decl_stmt|;
name|int
name|denominator
decl_stmt|;
block|}
typedef|*
name|lambda_trans_matrix
typedef|;
end_typedef

begin_define
define|#
directive|define
name|LTM_MATRIX
parameter_list|(
name|T
parameter_list|)
value|((T)->matrix)
end_define

begin_define
define|#
directive|define
name|LTM_ROWSIZE
parameter_list|(
name|T
parameter_list|)
value|((T)->rowsize)
end_define

begin_define
define|#
directive|define
name|LTM_COLSIZE
parameter_list|(
name|T
parameter_list|)
value|((T)->colsize)
end_define

begin_define
define|#
directive|define
name|LTM_DENOMINATOR
parameter_list|(
name|T
parameter_list|)
value|((T)->denominator)
end_define

begin_comment
comment|/* A vector representing a statement in the body of a loop.    The COEFFICIENTS vector contains a coefficient for each induction variable    in the loop nest containing the statement.    The DENOMINATOR represents the denominator for each coefficient in the    COEFFICIENT vector.     This structure is used during code generation in order to rewrite the old    induction variable uses in a statement in terms of the newly created    induction variables.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|lambda_vector
name|coefficients
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|denominator
decl_stmt|;
block|}
typedef|*
name|lambda_body_vector
typedef|;
end_typedef

begin_define
define|#
directive|define
name|LBV_COEFFICIENTS
parameter_list|(
name|T
parameter_list|)
value|((T)->coefficients)
end_define

begin_define
define|#
directive|define
name|LBV_SIZE
parameter_list|(
name|T
parameter_list|)
value|((T)->size)
end_define

begin_define
define|#
directive|define
name|LBV_DENOMINATOR
parameter_list|(
name|T
parameter_list|)
value|((T)->denominator)
end_define

begin_comment
comment|/* Piecewise linear expression.      This structure represents a linear expression with terms for the invariants    and induction variables of a loop.     COEFFICIENTS is a vector of coefficients for the induction variables, one    per loop in the loop nest.    CONSTANT is the constant portion of the linear expression    INVARIANT_COEFFICIENTS is a vector of coefficients for the loop invariants,    one per invariant.    DENOMINATOR is the denominator for all of the coefficients and constants in    the expression.      The linear expressions can be linked together using the NEXT field, in    order to represent MAX or MIN of a group of linear expressions.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|lambda_linear_expression_s
block|{
name|lambda_vector
name|coefficients
decl_stmt|;
name|int
name|constant
decl_stmt|;
name|lambda_vector
name|invariant_coefficients
decl_stmt|;
name|int
name|denominator
decl_stmt|;
name|struct
name|lambda_linear_expression_s
modifier|*
name|next
decl_stmt|;
block|}
typedef|*
name|lambda_linear_expression
typedef|;
end_typedef

begin_define
define|#
directive|define
name|LLE_COEFFICIENTS
parameter_list|(
name|T
parameter_list|)
value|((T)->coefficients)
end_define

begin_define
define|#
directive|define
name|LLE_CONSTANT
parameter_list|(
name|T
parameter_list|)
value|((T)->constant)
end_define

begin_define
define|#
directive|define
name|LLE_INVARIANT_COEFFICIENTS
parameter_list|(
name|T
parameter_list|)
value|((T)->invariant_coefficients)
end_define

begin_define
define|#
directive|define
name|LLE_DENOMINATOR
parameter_list|(
name|T
parameter_list|)
value|((T)->denominator)
end_define

begin_define
define|#
directive|define
name|LLE_NEXT
parameter_list|(
name|T
parameter_list|)
value|((T)->next)
end_define

begin_function_decl
name|lambda_linear_expression
name|lambda_linear_expression_new
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_lambda_linear_expression
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|lambda_linear_expression
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Loop structure.  Our loop structure consists of a constant representing the    STEP of the loop, a set of linear expressions representing the LOWER_BOUND    of the loop, a set of linear expressions representing the UPPER_BOUND of    the loop, and a set of linear expressions representing the LINEAR_OFFSET of    the loop.  The linear offset is a set of linear expressions that are    applied to *both* the lower bound, and the upper bound.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|lambda_loop_s
block|{
name|lambda_linear_expression
name|lower_bound
decl_stmt|;
name|lambda_linear_expression
name|upper_bound
decl_stmt|;
name|lambda_linear_expression
name|linear_offset
decl_stmt|;
name|int
name|step
decl_stmt|;
block|}
typedef|*
name|lambda_loop
typedef|;
end_typedef

begin_define
define|#
directive|define
name|LL_LOWER_BOUND
parameter_list|(
name|T
parameter_list|)
value|((T)->lower_bound)
end_define

begin_define
define|#
directive|define
name|LL_UPPER_BOUND
parameter_list|(
name|T
parameter_list|)
value|((T)->upper_bound)
end_define

begin_define
define|#
directive|define
name|LL_LINEAR_OFFSET
parameter_list|(
name|T
parameter_list|)
value|((T)->linear_offset)
end_define

begin_define
define|#
directive|define
name|LL_STEP
parameter_list|(
name|T
parameter_list|)
value|((T)->step)
end_define

begin_comment
comment|/* Loop nest structure.      The loop nest structure consists of a set of loop structures (defined    above) in LOOPS, along with an integer representing the DEPTH of the loop,    and an integer representing the number of INVARIANTS in the loop.  Both of    these integers are used to size the associated coefficient vectors in the    linear expression structures.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|lambda_loop
modifier|*
name|loops
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|int
name|invariants
decl_stmt|;
block|}
typedef|*
name|lambda_loopnest
typedef|;
end_typedef

begin_define
define|#
directive|define
name|LN_LOOPS
parameter_list|(
name|T
parameter_list|)
value|((T)->loops)
end_define

begin_define
define|#
directive|define
name|LN_DEPTH
parameter_list|(
name|T
parameter_list|)
value|((T)->depth)
end_define

begin_define
define|#
directive|define
name|LN_INVARIANTS
parameter_list|(
name|T
parameter_list|)
value|((T)->invariants)
end_define

begin_function_decl
name|lambda_loopnest
name|lambda_loopnest_new
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|lambda_loopnest
name|lambda_loopnest_transform
parameter_list|(
name|lambda_loopnest
parameter_list|,
name|lambda_trans_matrix
parameter_list|)
function_decl|;
end_function_decl

begin_struct_decl
struct_decl|struct
name|loop
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|loops
struct_decl|;
end_struct_decl

begin_function_decl
name|bool
name|perfect_nest_p
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_lambda_loopnest
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|lambda_loopnest
parameter_list|,
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|lambda_loop_new
parameter_list|()
value|(lambda_loop) ggc_alloc_cleared (sizeof (struct lambda_loop_s))
end_define

begin_function_decl
name|void
name|print_lambda_loop
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|lambda_loop
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|lambda_matrix
name|lambda_matrix_new
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lambda_matrix_id
parameter_list|(
name|lambda_matrix
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|lambda_matrix_id_p
parameter_list|(
name|lambda_matrix
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lambda_matrix_copy
parameter_list|(
name|lambda_matrix
parameter_list|,
name|lambda_matrix
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lambda_matrix_negate
parameter_list|(
name|lambda_matrix
parameter_list|,
name|lambda_matrix
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lambda_matrix_transpose
parameter_list|(
name|lambda_matrix
parameter_list|,
name|lambda_matrix
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lambda_matrix_add
parameter_list|(
name|lambda_matrix
parameter_list|,
name|lambda_matrix
parameter_list|,
name|lambda_matrix
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lambda_matrix_add_mc
parameter_list|(
name|lambda_matrix
parameter_list|,
name|int
parameter_list|,
name|lambda_matrix
parameter_list|,
name|int
parameter_list|,
name|lambda_matrix
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lambda_matrix_mult
parameter_list|(
name|lambda_matrix
parameter_list|,
name|lambda_matrix
parameter_list|,
name|lambda_matrix
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lambda_matrix_delete_rows
parameter_list|(
name|lambda_matrix
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lambda_matrix_row_exchange
parameter_list|(
name|lambda_matrix
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lambda_matrix_row_add
parameter_list|(
name|lambda_matrix
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lambda_matrix_row_negate
parameter_list|(
name|lambda_matrix
name|mat
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lambda_matrix_row_mc
parameter_list|(
name|lambda_matrix
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lambda_matrix_col_exchange
parameter_list|(
name|lambda_matrix
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lambda_matrix_col_add
parameter_list|(
name|lambda_matrix
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lambda_matrix_col_negate
parameter_list|(
name|lambda_matrix
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lambda_matrix_col_mc
parameter_list|(
name|lambda_matrix
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|lambda_matrix_inverse
parameter_list|(
name|lambda_matrix
parameter_list|,
name|lambda_matrix
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lambda_matrix_hermite
parameter_list|(
name|lambda_matrix
parameter_list|,
name|int
parameter_list|,
name|lambda_matrix
parameter_list|,
name|lambda_matrix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lambda_matrix_left_hermite
parameter_list|(
name|lambda_matrix
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|lambda_matrix
parameter_list|,
name|lambda_matrix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lambda_matrix_right_hermite
parameter_list|(
name|lambda_matrix
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|lambda_matrix
parameter_list|,
name|lambda_matrix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|lambda_matrix_first_nz_vec
parameter_list|(
name|lambda_matrix
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lambda_matrix_project_to_null
parameter_list|(
name|lambda_matrix
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|lambda_vector
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_lambda_matrix
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|lambda_matrix
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|lambda_trans_matrix
name|lambda_trans_matrix_new
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|lambda_trans_matrix_nonsingular_p
parameter_list|(
name|lambda_trans_matrix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|lambda_trans_matrix_fullrank_p
parameter_list|(
name|lambda_trans_matrix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|lambda_trans_matrix_rank
parameter_list|(
name|lambda_trans_matrix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|lambda_trans_matrix
name|lambda_trans_matrix_basis
parameter_list|(
name|lambda_trans_matrix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|lambda_trans_matrix
name|lambda_trans_matrix_padding
parameter_list|(
name|lambda_trans_matrix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|lambda_trans_matrix
name|lambda_trans_matrix_inverse
parameter_list|(
name|lambda_trans_matrix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_lambda_trans_matrix
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|lambda_trans_matrix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lambda_matrix_vector_mult
parameter_list|(
name|lambda_matrix
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|lambda_vector
parameter_list|,
name|lambda_vector
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|lambda_trans_matrix_id_p
parameter_list|(
name|lambda_trans_matrix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|lambda_body_vector
name|lambda_body_vector_new
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|lambda_body_vector
name|lambda_body_vector_compute_new
parameter_list|(
name|lambda_trans_matrix
parameter_list|,
name|lambda_body_vector
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_lambda_body_vector
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|lambda_body_vector
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|lambda_loopnest
name|gcc_loopnest_to_lambda_loopnest
argument_list|(
expr|struct
name|loops
operator|*
argument_list|,
expr|struct
name|loop
operator|*
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|lambda_loopnest_to_gcc_loopnest
argument_list|(
expr|struct
name|loop
operator|*
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
argument_list|,
name|lambda_loopnest
argument_list|,
name|lambda_trans_matrix
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
specifier|inline
name|void
name|lambda_vector_negate
parameter_list|(
name|lambda_vector
parameter_list|,
name|lambda_vector
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|lambda_vector_mult_const
parameter_list|(
name|lambda_vector
parameter_list|,
name|lambda_vector
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|lambda_vector_add
parameter_list|(
name|lambda_vector
parameter_list|,
name|lambda_vector
parameter_list|,
name|lambda_vector
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|lambda_vector_add_mc
parameter_list|(
name|lambda_vector
parameter_list|,
name|int
parameter_list|,
name|lambda_vector
parameter_list|,
name|int
parameter_list|,
name|lambda_vector
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|lambda_vector_copy
parameter_list|(
name|lambda_vector
parameter_list|,
name|lambda_vector
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|bool
name|lambda_vector_zerop
parameter_list|(
name|lambda_vector
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|lambda_vector_clear
parameter_list|(
name|lambda_vector
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|bool
name|lambda_vector_equal
parameter_list|(
name|lambda_vector
parameter_list|,
name|lambda_vector
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|lambda_vector_min_nz
parameter_list|(
name|lambda_vector
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|lambda_vector_first_nz
parameter_list|(
name|lambda_vector
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|print_lambda_vector
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|lambda_vector
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Allocate a new vector of given SIZE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|lambda_vector
name|lambda_vector_new
parameter_list|(
name|int
name|size
parameter_list|)
block|{
return|return
name|GGC_CNEWVEC
argument_list|(
name|int
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Multiply vector VEC1 of length SIZE by a constant CONST1,    and store the result in VEC2.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|lambda_vector_mult_const
parameter_list|(
name|lambda_vector
name|vec1
parameter_list|,
name|lambda_vector
name|vec2
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|const1
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|const1
operator|==
literal|0
condition|)
name|lambda_vector_clear
argument_list|(
name|vec2
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|vec2
index|[
name|i
index|]
operator|=
name|const1
operator|*
name|vec1
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Negate vector VEC1 with length SIZE and store it in VEC2.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|lambda_vector_negate
parameter_list|(
name|lambda_vector
name|vec1
parameter_list|,
name|lambda_vector
name|vec2
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|lambda_vector_mult_const
argument_list|(
name|vec1
argument_list|,
name|vec2
argument_list|,
name|size
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VEC3 = VEC1+VEC2, where all three the vectors are of length SIZE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|lambda_vector_add
parameter_list|(
name|lambda_vector
name|vec1
parameter_list|,
name|lambda_vector
name|vec2
parameter_list|,
name|lambda_vector
name|vec3
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|vec3
index|[
name|i
index|]
operator|=
name|vec1
index|[
name|i
index|]
operator|+
name|vec2
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VEC3 = CONSTANT1*VEC1 + CONSTANT2*VEC2.  All vectors have length SIZE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|lambda_vector_add_mc
parameter_list|(
name|lambda_vector
name|vec1
parameter_list|,
name|int
name|const1
parameter_list|,
name|lambda_vector
name|vec2
parameter_list|,
name|int
name|const2
parameter_list|,
name|lambda_vector
name|vec3
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|vec3
index|[
name|i
index|]
operator|=
name|const1
operator|*
name|vec1
index|[
name|i
index|]
operator|+
name|const2
operator|*
name|vec2
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the elements of vector VEC1 with length SIZE to VEC2.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|lambda_vector_copy
parameter_list|(
name|lambda_vector
name|vec1
parameter_list|,
name|lambda_vector
name|vec2
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|memcpy
argument_list|(
name|vec2
argument_list|,
name|vec1
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|vec1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if vector VEC1 of length SIZE is the zero vector.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|lambda_vector_zerop
parameter_list|(
name|lambda_vector
name|vec1
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|vec1
index|[
name|i
index|]
operator|!=
literal|0
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Clear out vector VEC1 of length SIZE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|lambda_vector_clear
parameter_list|(
name|lambda_vector
name|vec1
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|memset
argument_list|(
name|vec1
argument_list|,
literal|0
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|vec1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if two vectors are equal.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|lambda_vector_equal
parameter_list|(
name|lambda_vector
name|vec1
parameter_list|,
name|lambda_vector
name|vec2
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|vec1
index|[
name|i
index|]
operator|!=
name|vec2
index|[
name|i
index|]
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return the minimum nonzero element in vector VEC1 between START and N.    We must have START<= N.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|lambda_vector_min_nz
parameter_list|(
name|lambda_vector
name|vec1
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|min
init|=
operator|-
literal|1
decl_stmt|;
name|gcc_assert
argument_list|(
name|start
operator|<=
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|start
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|vec1
index|[
name|j
index|]
condition|)
if|if
condition|(
name|min
operator|<
literal|0
operator|||
name|vec1
index|[
name|j
index|]
operator|<
name|vec1
index|[
name|min
index|]
condition|)
name|min
operator|=
name|j
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|min
operator|>=
literal|0
argument_list|)
expr_stmt|;
return|return
name|min
return|;
block|}
end_function

begin_comment
comment|/* Return the first nonzero element of vector VEC1 between START and N.    We must have START<= N.   Returns N if VEC1 is the zero vector.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|lambda_vector_first_nz
parameter_list|(
name|lambda_vector
name|vec1
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|int
name|j
init|=
name|start
decl_stmt|;
while|while
condition|(
name|j
operator|<
name|n
operator|&&
name|vec1
index|[
name|j
index|]
operator|==
literal|0
condition|)
name|j
operator|++
expr_stmt|;
return|return
name|j
return|;
block|}
end_function

begin_comment
comment|/* Multiply a vector by a matrix.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|lambda_vector_matrix_mult
parameter_list|(
name|lambda_vector
name|vect
parameter_list|,
name|int
name|m
parameter_list|,
name|lambda_matrix
name|mat
parameter_list|,
name|int
name|n
parameter_list|,
name|lambda_vector
name|dest
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|lambda_vector_clear
argument_list|(
name|dest
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|m
condition|;
name|j
operator|++
control|)
name|dest
index|[
name|i
index|]
operator|+=
name|mat
index|[
name|j
index|]
index|[
name|i
index|]
operator|*
name|vect
index|[
name|j
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out a vector VEC of length N to OUTFILE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|print_lambda_vector
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|lambda_vector
name|vector
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%3d "
argument_list|,
name|vector
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the greatest common divisor of two numbers using    Euclid's algorithm.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|gcd
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
name|x
operator|=
name|abs
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|y
operator|=
name|abs
argument_list|(
name|b
argument_list|)
expr_stmt|;
while|while
condition|(
name|x
operator|>
literal|0
condition|)
block|{
name|z
operator|=
name|y
operator|%
name|x
expr_stmt|;
name|y
operator|=
name|x
expr_stmt|;
name|x
operator|=
name|z
expr_stmt|;
block|}
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/* Compute the greatest common divisor of a VECTOR of SIZE numbers.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|lambda_vector_gcd
parameter_list|(
name|lambda_vector
name|vector
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|gcd1
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|gcd1
operator|=
name|vector
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|gcd1
operator|=
name|gcd
argument_list|(
name|gcd1
argument_list|,
name|vector
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|gcd1
return|;
block|}
end_function

begin_comment
comment|/* Returns true when the vector V is lexicographically positive, in    other words, when the first nonzero element is positive.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|lambda_vector_lexico_pos
parameter_list|(
name|lambda_vector
name|v
parameter_list|,
name|unsigned
name|n
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|v
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|v
index|[
name|i
index|]
operator|<
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|v
index|[
name|i
index|]
operator|>
literal|0
condition|)
return|return
name|true
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LAMBDA_H  */
end_comment

end_unit

